internal static class FxResources.System.Security.Cryptography.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [CompilerGeneratedAttribute]
private static bool <HasSymmetricEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasMD5>k__BackingField;
    [UnsupportedOSPlatformGuardAttribute("browser")]
internal static bool HasSymmetricEncryption { get; }
    [UnsupportedOSPlatformGuardAttribute("ios")]
[UnsupportedOSPlatformGuardAttribute("tvos")]
public static bool IsDSASupported { get; }
    [UnsupportedOSPlatformGuardAttribute("android")]
[UnsupportedOSPlatformGuardAttribute("browser")]
public static bool IsRC2Supported { get; }
    [UnsupportedOSPlatformGuardAttribute("browser")]
internal static bool HasMD5 { get; }
    private static Helpers();
    [CompilerGeneratedAttribute]
internal static bool get_HasSymmetricEncryption();
    public static bool get_IsDSASupported();
    public static bool get_IsRC2Supported();
    [CompilerGeneratedAttribute]
internal static bool get_HasMD5();
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
internal static bool TryCopyToDestination(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal static int HashOidToByteLength(string hashOid);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> coll, IEnumerable`1<T> newData);
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static Byte[] FixupKeyParity(Byte[] key);
    [ExtensionAttribute]
internal static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
internal static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] LaxDecodeHexString(string hexString);
    [ExtensionAttribute]
internal static bool ContentsEqual(Byte[] a1, Byte[] a2);
    internal static ReadOnlyMemory`1<byte> DecodeOctetStringAsMemory(ReadOnlyMemory`1<byte> encodedOctetString);
    internal static bool AreSamePublicECParameters(ECParameters aParameters, ECParameters bParameters);
    [ExtensionAttribute]
internal static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year);
    [ExtensionAttribute]
internal static void DisposeAll(IEnumerable`1<IDisposable> disposables);
    internal static void ValidateDer(ReadOnlySpan`1<byte> encodedValue);
    [ExtensionAttribute]
public static int GetPaddingSize(SymmetricAlgorithm algorithm, CipherMode mode, int feedbackSizeInBits);
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeEvpCipherCtxHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeEvpMdCtxHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class Microsoft.Win32.SafeHandles.SafeHmacCtxHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
internal class Microsoft.Win32.SafeHandles.SafePasswordHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PasswordProvided>k__BackingField;
    internal int Length { get; private set; }
    internal bool PasswordProvided { get; }
    public SafePasswordHandle(string password, bool passwordProvided);
    public SafePasswordHandle(ReadOnlySpan`1<char> password, bool passwordProvided);
    public SafePasswordHandle(SecureString password, bool passwordProvided);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
internal bool get_PasswordProvided();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    internal ReadOnlySpan`1<char> DangerousGetSpan();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [NullableAttribute("1")]
internal static SafeX509ChainHandle InvalidHandle { get; }
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Formats.Asn1.AsnValueReader : ValueType {
    private static Byte[] s_singleByte;
    private ReadOnlySpan`1<byte> _span;
    private AsnEncodingRules _ruleSet;
    internal bool HasData { get; }
    internal AsnValueReader(ReadOnlySpan`1<byte> span, AsnEncodingRules ruleSet);
    private static AsnValueReader();
    internal bool get_HasData();
    internal void ThrowIfNotEmpty();
    internal Asn1Tag PeekTag();
    internal ReadOnlySpan`1<byte> PeekContentBytes();
    internal ReadOnlySpan`1<byte> PeekEncodedValue();
    internal ReadOnlySpan`1<byte> ReadEncodedValue();
    internal bool ReadBoolean(Nullable`1<Asn1Tag> expectedTag);
    internal BigInteger ReadInteger(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadInt32(Int32& value, Nullable`1<Asn1Tag> expectedTag);
    internal ReadOnlySpan`1<byte> ReadIntegerBytes(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveBitString(Int32& unusedBitCount, ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadBitString(Int32& unusedBitCount, Nullable`1<Asn1Tag> expectedTag);
    internal TFlagsEnum ReadNamedBitListValue(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveOctetString(ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadOctetString(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadObjectIdentifier(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSequence(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSetOf(Nullable`1<Asn1Tag> expectedTag, bool skipSortOrderValidation);
    internal DateTimeOffset ReadUtcTime(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadGeneralizedTime(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadCharacterString(UniversalTagNumber encodingType, Nullable`1<Asn1Tag> expectedTag);
}
[ExtensionAttribute]
internal static class System.Formats.Asn1.AsnWriterExtensions : object {
    [ExtensionAttribute]
internal static void WriteObjectIdentifierForCrypto(AsnWriter writer, string value);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.LocalAppContextSwitches : object {
    [CompilerGeneratedAttribute]
private static long <Pkcs12UnspecifiedPasswordIterationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <X509ChainBuildThrowOnInternalError>k__BackingField;
    internal static long Pkcs12UnspecifiedPasswordIterationLimit { get; }
    internal static bool X509ChainBuildThrowOnInternalError { get; }
    private static LocalAppContextSwitches();
    [CompilerGeneratedAttribute]
internal static long get_Pkcs12UnspecifiedPasswordIterationLimit();
    [CompilerGeneratedAttribute]
internal static bool get_X509ChainBuildThrowOnInternalError();
    private static long InitializePkcs12UnspecifiedPasswordIterationLimit();
    private static bool InitializeX509ChainBuildThrowOnInternalError();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Aes();
    [UnsupportedOSPlatformAttribute("browser")]
public static Aes Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static Aes Create(string algorithmName);
}
internal static class System.Security.Cryptography.AesAEAD : object {
    public static void CheckKeySize(int keySizeInBytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesCcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    private Byte[] _key;
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public static bool IsSupported { get; }
    [NullableContextAttribute("0")]
public AesCcm(ReadOnlySpan`1<byte> key);
    public AesCcm(Byte[] key);
    private static AesCcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    public static bool get_IsSupported();
    [MemberNotNullAttribute("_key")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static IntPtr GetCipher(int keySizeInBits);
    [MemberNotNullAttribute("_key")]
private void CheckDisposed();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AesCng : Aes {
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesGcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TagSizeInBytes>k__BackingField;
    private SafeEvpCipherCtxHandle _ctxHandle;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    public static KeySizes NonceByteSizes { get; }
    public Nullable`1<int> TagSizeInBytes { get; }
    public static bool IsSupported { get; }
    public static KeySizes TagByteSizes { get; }
    [NullableContextAttribute("0")]
[ObsoleteAttribute("AesGcm should indicate the required tag size for encryption and decryption. Use a constructor that accepts the tag size.")]
public AesGcm(ReadOnlySpan`1<byte> key);
    [ObsoleteAttribute("AesGcm should indicate the required tag size for encryption and decryption. Use a constructor that accepts the tag size.")]
public AesGcm(Byte[] key);
    [NullableContextAttribute("0")]
public AesGcm(ReadOnlySpan`1<byte> key, int tagSizeInBytes);
    public AesGcm(Byte[] key, int tagSizeInBytes);
    private static AesGcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TagSizeInBytes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    public static bool get_IsSupported();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    [MemberNotNullAttribute("_ctxHandle")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static IntPtr GetCipher(int keySizeInBits);
    public sealed virtual void Dispose();
}
internal class System.Security.Cryptography.AesImplementation : Aes {
    public sealed virtual ICryptoTransform CreateDecryptor();
    public sealed virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual ICryptoTransform CreateEncryptor();
    public sealed virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    protected sealed virtual void Dispose(bool disposing);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private UniversalCryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int paddingSize, int feedback, bool encrypting);
    private static OpenSslCipherLite CreateLiteCipher(CipherMode cipherMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int paddingSize, int feedback, bool encrypting);
    private static IntPtr GetAlgorithm(int keySize, int feedback, CipherMode cipherMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.AesManaged : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal string Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    [IsReadOnlyAttribute]
internal bool HasNullEquivalentParameters();
    internal static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal string AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    public AttributeAsn(AsnEncodedData attribute);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.CurveAsn : ValueType {
    internal ReadOnlyMemory`1<byte> A;
    internal ReadOnlyMemory`1<byte> B;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Seed;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DigestInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal ReadOnlyMemory`1<byte> Digest;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DirectoryStringAsn : ValueType {
    internal string TeletexString;
    internal string PrintableString;
    internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    internal string Utf8String;
    internal string BmpString;
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DssParms : ValueType {
    internal BigInteger P;
    internal BigInteger Q;
    internal BigInteger G;
    internal static DssParms Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static DssParms Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, DssParms& decoded);
}
internal class System.Security.Cryptography.Asn1.ECDomainParameters : ValueType {
    internal Nullable`1<SpecifiedECDomain> Specified;
    internal string Named;
    internal void Encode(AsnWriter writer);
    internal static ECDomainParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
}
internal class System.Security.Cryptography.Asn1.ECPrivateKey : ValueType {
    internal int Version;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal Nullable`1<ECDomainParameters> Parameters;
    internal Nullable`1<ReadOnlyMemory`1<byte>> PublicKey;
    internal static ECPrivateKey Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ECPrivateKey Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ECPrivateKey& decoded);
}
internal class System.Security.Cryptography.Asn1.EdiPartyNameAsn : ValueType {
    internal Nullable`1<DirectoryStringAsn> NameAssigner;
    internal DirectoryStringAsn PartyName;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.FieldID : ValueType {
    internal string FieldType;
    internal ReadOnlyMemory`1<byte> Parameters;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
}
internal class System.Security.Cryptography.Asn1.GeneralNameAsn : ValueType {
    internal Nullable`1<OtherNameAsn> OtherName;
    internal string Rfc822Name;
    internal string DnsName;
    internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    internal Nullable`1<EdiPartyNameAsn> EdiPartyName;
    internal string Uri;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    internal string RegisteredId;
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.OtherNameAsn : ValueType {
    internal string TypeId;
    internal ReadOnlyMemory`1<byte> Value;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<int> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static ReadOnlySpan`1<byte> DefaultPrf { get; }
    private static ReadOnlySpan`1<byte> get_DefaultPrf();
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.CertBagAsn : ValueType {
    internal string CertId;
    internal ReadOnlyMemory`1<byte> CertValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CertBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertBagAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.MacData : ValueType {
    internal DigestInfoAsn Mac;
    internal ReadOnlyMemory`1<byte> MacSalt;
    internal int IterationCount;
    private static ReadOnlySpan`1<byte> DefaultIterationCount { get; }
    private static ReadOnlySpan`1<byte> get_DefaultIterationCount();
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.PfxAsn : ValueType {
    internal int Version;
    internal ContentInfoAsn AuthSafe;
    internal Nullable`1<MacData> MacData;
    private static ReadOnlySpan`1<char> EmptyPassword { get; }
    private static ReadOnlySpan`1<char> NullPassword { get; }
    private static ReadOnlySpan`1<char> get_EmptyPassword();
    private static ReadOnlySpan`1<char> get_NullPassword();
    internal bool VerifyMac(ReadOnlySpan`1<char> macPassword, ReadOnlySpan`1<byte> authSafeContents);
    internal ulong CountTotalIterations();
    private static ArraySegment`1<byte> DecryptContentInfo(ContentInfoAsn contentInfo, UInt32& iterations);
    private static UInt32 IterationsFromParameters(AlgorithmIdentifierAsn& algorithmIdentifier);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.SafeBagAsn : ValueType {
    internal string BagId;
    internal ReadOnlyMemory`1<byte> BagValue;
    internal AttributeAsn[] BagAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.ContentInfoAsn : ValueType {
    internal string ContentType;
    internal ReadOnlyMemory`1<byte> Content;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedContentInfoAsn : ValueType {
    internal string ContentType;
    internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedDataAsn : ValueType {
    internal int Version;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal static EncryptedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedDataAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal static PrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PssParamsAsn : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal AlgorithmIdentifierAsn MaskGenAlgorithm;
    internal int SaltLength;
    internal int TrailerField;
    private static ReadOnlySpan`1<byte> DefaultHashAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultMaskGenAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultSaltLength { get; }
    private static ReadOnlySpan`1<byte> DefaultTrailerField { get; }
    internal RSASignaturePadding GetSignaturePadding(Nullable`1<int> digestValueLength);
    private static ReadOnlySpan`1<byte> get_DefaultHashAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultMaskGenAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultSaltLength();
    private static ReadOnlySpan`1<byte> get_DefaultTrailerField();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PssParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PssParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PssParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static ReadOnlySpan`1<byte> Rc2EkbEncoding { get; }
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    private static ReadOnlySpan`1<byte> get_Rc2EkbEncoding();
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.RSAPrivateKeyAsn : ValueType {
    internal int Version;
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal BigInteger PrivateExponent;
    internal BigInteger Prime1;
    internal BigInteger Prime2;
    internal BigInteger Exponent1;
    internal BigInteger Exponent2;
    internal BigInteger Coefficient;
    internal static RSAPrivateKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPrivateKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, RSAPrivateKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.RSAPublicKeyAsn : ValueType {
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal static RSAPublicKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPublicKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, RSAPublicKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.SpecifiedECDomain : ValueType {
    internal int Version;
    internal FieldID FieldID;
    internal CurveAsn Curve;
    internal ReadOnlyMemory`1<byte> Base;
    internal ReadOnlyMemory`1<byte> Order;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Cofactor;
    internal string Hash;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SubjectPublicKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SubjectPublicKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.X509ExtensionAsn : ValueType {
    internal string ExtnId;
    internal bool Critical;
    internal ReadOnlyMemory`1<byte> ExtnValue;
    private static ReadOnlySpan`1<byte> DefaultCritical { get; }
    public X509ExtensionAsn(X509Extension extension);
    private static ReadOnlySpan`1<byte> get_DefaultCritical();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedData : object {
    private Oid _oid;
    private Byte[] _rawData;
    [NullableAttribute("2")]
public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(ReadOnlySpan`1<byte> rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(Oid oid, ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(string oid, ReadOnlySpan`1<byte> rawData);
    internal AsnEncodedData(Oid oid, Byte[] rawData, bool skipCopy);
    [NullableContextAttribute("2")]
public Oid get_Oid();
    [NullableContextAttribute("2")]
public void set_Oid(Oid value);
    public Byte[] get_RawData();
    [MemberNotNullAttribute("_rawData")]
public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
    [MemberNotNullAttribute("_rawData")]
private void Reset(Oid oid, Byte[] rawData);
    [MemberNotNullAttribute("_rawData")]
private void Reset(Oid oid, ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    private List`1<AsnEncodedData> _list;
    public AsnEncodedData Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public int Add(AsnEncodedData asnEncodedData);
    public void Remove(AsnEncodedData asnEncodedData);
    public AsnEncodedData get_Item(int index);
    public sealed virtual int get_Count();
    public AsnEncodedDataEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(AsnEncodedData[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    private AsnEncodedDataCollection _asnEncodedDatas;
    private int _current;
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AsnEncodedDataEnumerator(AsnEncodedDataCollection asnEncodedDatas);
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.AsnFormatter : object {
    private static AsnFormatter s_instance;
    internal static AsnFormatter Instance { get; }
    private static AsnFormatter();
    internal static AsnFormatter get_Instance();
    public string Format(Oid oid, Byte[] rawData, bool multiLine);
    protected abstract virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
    protected static string EncodeSpaceSeparatedHexString(Byte[] sArray);
}
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static AsymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static AsymmetricAlgorithm Create(string algName);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportPkcs8PrivateKey();
    [NullableContextAttribute("1")]
public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("1")]
public string ExportPkcs8PrivateKeyPem();
    [NullableContextAttribute("1")]
public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public string ExportSubjectPublicKeyInfoPem();
    public bool TryExportSubjectPublicKeyInfoPem(Span`1<char> destination, Int32& charsWritten);
    public bool TryExportPkcs8PrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<char> destination, Int32& charsWritten);
    public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<char> destination, Int32& charsWritten);
    private static Byte[] ExportArray(ReadOnlySpan`1<T> password, PbeParameters pbeParameters, TryExportPbe`1<T> exporter);
    private static Byte[] ExportArray(TryExport exporter);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__33_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportSubjectPublicKeyInfoPem>g__Export|38_0(AsymmetricAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportPkcs8PrivateKeyPem>g__Export|39_0(AsymmetricAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportEncryptedPkcs8PrivateKeyPem>g__Export|40_0(AsymmetricAlgorithm alg, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportEncryptedPkcs8PrivateKeyPem>g__Export|41_0(AsymmetricAlgorithm alg, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.AsymmetricAlgorithmHelpers : object {
    public static Byte[] ConvertIeee1363ToDer(ReadOnlySpan`1<byte> input);
    internal static bool TryConvertIeee1363ToDer(ReadOnlySpan`1<byte> input, Span`1<byte> destination, Int32& bytesWritten);
    private static AsnWriter WriteIeee1363ToDer(ReadOnlySpan`1<byte> input);
    public static Byte[] ConvertDerToIeee1363(ReadOnlySpan`1<byte> input, int fieldSizeBits);
    internal static int ConvertDerToIeee1363(ReadOnlySpan`1<byte> input, int fieldSizeBits, Span`1<byte> destination);
    internal static int GetMaxDerSignatureSize(int fieldSizeBits);
    internal static Byte[] ConvertFromIeeeP1363Signature(Byte[] signature, DSASignatureFormat targetFormat);
    internal static Byte[] ConvertSignatureToIeeeP1363(DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature, int fieldSizeBits);
    public static int BitsToBytes(int bitLength);
    private static void CopySignatureField(ReadOnlySpan`1<byte> signatureField, Span`1<byte> response);
    [ExtensionAttribute]
internal static Byte[] ConvertSignatureToIeeeP1363(DSA dsa, DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature, int fieldSizeBits);
    [ExtensionAttribute]
internal static Byte[] ConvertSignatureToIeeeP1363(ECDsa ecdsa, DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature);
    [CompilerGeneratedAttribute]
internal static int <GetMaxDerSignatureSize>g__GetDerLengthLength|5_0(int payloadLength);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    [NullableContextAttribute("1")]
public abstract virtual void SetKey(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    [NullableAttribute("2")]
public string Parameters { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_Parameters();
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AuthenticationTagMismatchException : CryptographicException {
    public AuthenticationTagMismatchException(string message);
    public AuthenticationTagMismatchException(string message, Exception inner);
}
internal abstract class System.Security.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    public int PaddingSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes, int paddingSizeInBytes);
    public abstract virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PaddingSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_PaddingSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.CapiHelper : object {
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(DSAParameters dsaParameters);
    [ExtensionAttribute]
internal static DSAParameters ToDSAParameters(Byte[] cspBlob, bool includePrivateParameters, Byte[] cspPublicBlob);
    private static void ReadKeyBlobHeader(BinaryReader br, Byte& bVersion);
    private static void WriteKeyBlobHeader(DSAParameters dsaParameters, BinaryWriter bw, bool isPrivate, Boolean& isV3);
    private static void ReadDSSSeed(DSAParameters dsaParameters, BinaryReader br, bool isV3);
    private static void WriteDSSSeed(DSAParameters dsaParameters, BinaryWriter bw);
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(RSAParameters rsaParameters);
    [ExtensionAttribute]
private static void WriteReversed(BinaryWriter bw, Byte[] bytes);
    [ExtensionAttribute]
internal static RSAParameters ToRSAParameters(Byte[] cspBlob, bool includePrivateParameters);
    private static Byte[] ExponentAsBytes(UInt32 exponent);
    [ExtensionAttribute]
private static Byte[] ReadReversed(BinaryReader br, int count);
    internal static Byte[] TrimLargeIV(Byte[] currentIV, int blockSizeInBits);
    internal static HashAlgorithmName ObjToHashAlgorithmName(object hashAlg);
    internal static HashAlgorithmName NameOrOidToHashAlgorithmName(string nameOrOid);
    private static HashAlgorithmName AlgorithmToHashAlgorithmName(HashAlgorithm hashAlgorithm);
    private static HashAlgorithmName OidToHashAlgorithmName(string oid);
    private static HashAlgorithmName HashAlgorithmTypeToHashAlgorithmName(Type hashAlgType);
    internal static CryptographicException GetBadDataException();
    internal static CryptographicException GetEFailException();
}
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.ChaCha20Poly1305 : object {
    private SafeEvpCipherCtxHandle _ctxHandle;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    public ChaCha20Poly1305(ReadOnlySpan`1<byte> key);
    [NullableContextAttribute("1")]
public ChaCha20Poly1305(Byte[] key);
    private static ChaCha20Poly1305();
    private static void CheckKeySize(int keySizeInBytes);
    [NullableContextAttribute("1")]
public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    [NullableContextAttribute("1")]
public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [MemberNotNullAttribute("_ctxHandle")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    public static CipherMode ECB;
    [EditorBrowsableAttribute("1")]
public static CipherMode OFB;
    public static CipherMode CFB;
    public static CipherMode CTS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithm : object {
    private static CngAlgorithm s_ecdh;
    private static CngAlgorithm s_ecdhp256;
    private static CngAlgorithm s_ecdhp384;
    private static CngAlgorithm s_ecdhp521;
    private static CngAlgorithm s_ecdsa;
    private static CngAlgorithm s_ecdsap256;
    private static CngAlgorithm s_ecdsap384;
    private static CngAlgorithm s_ecdsap521;
    private static CngAlgorithm s_md5;
    private static CngAlgorithm s_sha1;
    private static CngAlgorithm s_sha256;
    private static CngAlgorithm s_sha384;
    private static CngAlgorithm s_sha512;
    private static CngAlgorithm s_rsa;
    private string _algorithm;
    public string Algorithm { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    private static CngAlgorithmGroup s_dh;
    private static CngAlgorithmGroup s_dsa;
    private static CngAlgorithmGroup s_ecdh;
    private static CngAlgorithmGroup s_ecdsa;
    private static CngAlgorithmGroup s_rsa;
    private string _algorithmGroup;
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKey : object {
    public CngAlgorithm Algorithm { get; }
    [NullableAttribute("2")]
public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngExportPolicies ExportPolicy { get; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; }
    public bool IsMachineKey { get; }
    [NullableAttribute("2")]
public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    [NullableAttribute("2")]
public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public CngUIPolicy UIPolicy { get; }
    [NullableAttribute("2")]
public string UniqueName { get; }
    public CngAlgorithm get_Algorithm();
    [NullableContextAttribute("2")]
public CngAlgorithmGroup get_AlgorithmGroup();
    public CngExportPolicies get_ExportPolicy();
    public SafeNCryptKeyHandle get_Handle();
    public bool get_IsEphemeral();
    public bool get_IsMachineKey();
    [NullableContextAttribute("2")]
public string get_KeyName();
    public int get_KeySize();
    public CngKeyUsages get_KeyUsage();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    [NullableContextAttribute("2")]
public CngProvider get_Provider();
    public SafeNCryptProviderHandle get_ProviderHandle();
    public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
public string get_UniqueName();
    public void Delete();
    public sealed virtual void Dispose();
    public Byte[] Export(CngKeyBlobFormat format);
    public CngProperty GetProperty(string name, CngPropertyOptions options);
    public bool HasProperty(string name, CngPropertyOptions options);
    public void SetProperty(CngProperty property);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    private static CngKeyBlobFormat s_eccPrivate;
    private static CngKeyBlobFormat s_eccPublic;
    private static CngKeyBlobFormat s_eccFullPrivate;
    private static CngKeyBlobFormat s_eccFullPublic;
    private static CngKeyBlobFormat s_genericPrivate;
    private static CngKeyBlobFormat s_genericPublic;
    private static CngKeyBlobFormat s_opaqueTransport;
    private static CngKeyBlobFormat s_pkcs8Private;
    private string _format;
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<CngExportPolicies> <ExportPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKeyCreationOptions <KeyCreationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CngKeyUsages> <KeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <ParentWindowHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private CngUIPolicy <UIPolicy>k__BackingField;
    private CngProvider _provider;
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public CngPropertyCollection Parameters { get; private set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; public set; }
    [NullableAttribute("2")]
public CngUIPolicy UIPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CngExportPolicies> get_ExportPolicy();
    [CompilerGeneratedAttribute]
public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    [CompilerGeneratedAttribute]
public CngKeyCreationOptions get_KeyCreationOptions();
    [CompilerGeneratedAttribute]
public void set_KeyCreationOptions(CngKeyCreationOptions value);
    [CompilerGeneratedAttribute]
public Nullable`1<CngKeyUsages> get_KeyUsage();
    [CompilerGeneratedAttribute]
public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    [CompilerGeneratedAttribute]
public CngPropertyCollection get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(CngPropertyCollection value);
    [CompilerGeneratedAttribute]
public IntPtr get_ParentWindowHandle();
    [CompilerGeneratedAttribute]
public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProperty : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyOptions <Options>k__BackingField;
    private Byte[] _value;
    private Nullable`1<int> _lazyHashCode;
    public string Name { get; private set; }
    public CngPropertyOptions Options { get; private set; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [NullableContextAttribute("2")]
public Byte[] GetValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CngPropertyOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CngPropertyOptions value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProvider : object {
    private static CngProvider s_msPlatformKsp;
    private static CngProvider s_msSmartCardKsp;
    private static CngProvider s_msSoftwareKsp;
    private string _provider;
    public string Provider { get; }
    public static CngProvider MicrosoftPlatformCryptoProvider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftPlatformCryptoProvider();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngUIPolicy : object {
    [CompilerGeneratedAttribute]
private CngUIProtectionLevels <ProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreationTitle>k__BackingField;
    public CngUIProtectionLevels ProtectionLevel { get; private set; }
    public string FriendlyName { get; private set; }
    public string Description { get; private set; }
    public string UseContext { get; private set; }
    public string CreationTitle { get; private set; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    [CompilerGeneratedAttribute]
public CngUIProtectionLevels get_ProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_ProtectionLevel(CngUIProtectionLevels value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_UseContext();
    [CompilerGeneratedAttribute]
private void set_UseContext(string value);
    [CompilerGeneratedAttribute]
public string get_CreationTitle();
    [CompilerGeneratedAttribute]
private void set_CreationTitle(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
internal class System.Security.Cryptography.ConcurrencyBlock : ValueType {
    internal static Scope Enter(ConcurrencyBlock& block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoConfig : object {
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultOidHT;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultNameHT;
    private static ConcurrentDictionary`2<string, Type> appNameHT;
    private static ConcurrentDictionary`2<string, string> appOidHT;
    private static Dictionary`2<string, string> DefaultOidHT { get; }
    private static Dictionary`2<string, object> DefaultNameHT { get; }
    public static bool AllowOnlyFipsAlgorithms { get; }
    private static CryptoConfig();
    private static Dictionary`2<string, string> get_DefaultOidHT();
    private static Dictionary`2<string, object> get_DefaultNameHT();
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddAlgorithm(Type algorithm, String[] names);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name, Object[] args);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name);
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddOID(string oid, String[] names);
    [UnsupportedOSPlatformAttribute("browser")]
public static string MapNameToOID(string name);
    [UnsupportedOSPlatformAttribute("browser")]
[ObsoleteAttribute("EncodeOID is obsolete. Use the ASN.1 functionality provided in System.Formats.Asn1.")]
public static Byte[] EncodeOID(string str);
    private static void EncodeSingleOidNum(UInt32 value, Byte[] destination, Int32& index);
    public static bool get_AllowOnlyFipsAlgorithms();
}
internal static class System.Security.Cryptography.CryptoConfigForwarder : object {
    private static Func`2<string, object> s_createFromName;
    private static CryptoConfigForwarder();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
private static Func`2<string, object> BindCreateFromName();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
internal static T CreateFromName(string name);
    internal static HashAlgorithm CreateDefaultHashAlgorithm();
}
public static class System.Security.Cryptography.CryptographicOperations : object {
    public static bool FixedTimeEquals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static void ZeroMemory(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message);
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message, Exception inner);
    public CryptographicUnexpectedOperationException(string format, string insert);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(ArraySegment`1<byte> arraySegment);
    internal static void Return(Byte[] array, int clearSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoStream : Stream {
    private Stream _stream;
    private ICryptoTransform _transform;
    private Byte[] _inputBuffer;
    private int _inputBufferIndex;
    private int _inputBlockSize;
    private Byte[] _outputBuffer;
    private int _outputBufferIndex;
    private int _outputBlockSize;
    private bool _canRead;
    private bool _canWrite;
    private bool _finalBlockTransformed;
    private SemaphoreSlim _lazyAsyncActiveSemaphore;
    private bool _leaveOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool HasFlushedFinalBlock { get; }
    [MemberNotNullAttribute("_lazyAsyncActiveSemaphore")]
private SemaphoreSlim AsyncActiveSemaphore { get; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public bool get_HasFlushedFinalBlock();
    public void FlushFinalBlock();
    public ValueTask FlushFinalBlockAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<FlushFinalBlockAsync>d__30")]
private ValueTask FlushFinalBlockAsync(bool useAsync, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncInternal>d__37")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CheckReadArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncCore>d__44")]
private ValueTask`1<int> ReadAsyncCore(Memory`1<byte> buffer, CancellationToken cancellationToken, bool useAsync);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncInternal>d__47")]
private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    private void CheckWriteArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncCore>d__53")]
private ValueTask WriteAsyncCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, bool useAsync);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<CopyToAsyncInternal>d__56")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckCopyToArguments(Stream destination, int bufferSize);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<DisposeAsyncCore>d__61")]
private ValueTask DisposeAsyncCore();
    [MemberNotNullAttribute("_lazyAsyncActiveSemaphore")]
private SemaphoreSlim get_AsyncActiveSemaphore();
    [CompilerGeneratedAttribute]
internal static int <WriteAsyncCore>g__TransformBlock|53_0(ICryptoTransform transform, ReadOnlyMemory`1<byte> inputBuffer, Byte[] outputBuffer, int outputOffset);
}
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    public bool Accessible { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    public string UniqueKeyContainerName { get; }
    public CspKeyContainerInfo(CspParameters parameters);
    public bool get_Accessible();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    public string get_UniqueKeyContainerName();
    private static PlatformNotSupportedException GetPlatformNotSupported();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspParameters : object {
    public int ProviderType;
    public string ProviderName;
    public string KeyContainerName;
    public int KeyNumber;
    private int _flags;
    private IntPtr _parentWindowHandle;
    [CompilerGeneratedAttribute]
private SecureString <KeyPassword>k__BackingField;
    public CspProviderFlags Flags { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    internal CspParameters(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    [CompilerGeneratedAttribute]
public SecureString get_KeyPassword();
    [CompilerGeneratedAttribute]
public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
public abstract class System.Security.Cryptography.DeriveBytes : object {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static DES();
    [UnsupportedOSPlatformAttribute("browser")]
public static DES Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static DES Create(string algName);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    private static bool IsLegalKeySize(Byte[] rgbKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    private DES _impl;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
}
internal class System.Security.Cryptography.DesImplementation : DES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private UniversalCryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int feedbackSize, int paddingSize, bool encrypting);
    private static OpenSslCipherLite CreateLiteCipher(CipherMode cipherMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int feedbackSize, int paddingSize, bool encrypting);
    private static IntPtr GetAlgorithm(CipherMode cipherMode, int feedbackSize);
}
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static DSA Create(string algName);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create();
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(int keySizeInBits);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(DSAParameters parameters);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("1")]
public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] CreateSignature(Byte[] rgbHash, DSASignatureFormat signatureFormat);
    protected virtual Byte[] CreateSignatureCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TryCreateSignatureCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature, DSASignatureFormat signatureFormat);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    protected virtual bool VerifySignatureCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    private ReadOnlySpan`1<byte> HashSpanToTmp(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Span`1<byte> tmp);
    private Byte[] HashSpanToArray(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8();
    private AsnWriter WriteSubjectPublicKeyInfo();
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    private static DSAAndroid CreateCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACng : DSA {
    public CngKey Key { get; }
    [SupportedOSPlatformAttribute("windows")]
public DSACng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public DSACng(CngKey key);
    public CngKey get_Key();
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    private DSA _impl;
    private bool _publicOnly;
    private static KeySizes[] s_legalKeySizesWindowsCsp;
    private static KeySizes[] s_legalKeySizesAndroid;
    private static KeySizes[] s_legalKeySizes;
    [CompilerGeneratedAttribute]
private bool <PersistKeyInCsp>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseMachineKeyStore>k__BackingField;
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSACryptoServiceProvider(int dwKeySize);
    [SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    [SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(CspParameters parameters);
    private static DSACryptoServiceProvider();
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("0")]
public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void FromXmlString(string xmlString);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    [CompilerGeneratedAttribute]
public bool get_PersistKeyInCsp();
    [CompilerGeneratedAttribute]
public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public Byte[] SignData(Stream inputStream);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("0")]
public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    [CompilerGeneratedAttribute]
public static bool get_UseMachineKeyStore();
    [CompilerGeneratedAttribute]
public static void set_UseMachineKeyStore(bool value);
    private static bool IsPublic(Byte[] keyBlob);
}
internal static class System.Security.Cryptography.DSAImplementation : object {
}
internal static class System.Security.Cryptography.DSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static DSAKeyFormatHelper();
    internal static void ReadDsaPrivateKey(ReadOnlyMemory`1<byte> xBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    internal static void ReadDsaPublicKey(ReadOnlyMemory`1<byte> yBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    private static bool IsValidPLength(long pBitLength);
    private static bool IsValidQLength(long qBitLength);
    internal static void ReadSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadPkcs8(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, DSAParameters& key);
    internal static AsnWriter WriteSubjectPublicKeyInfo(DSAParameters& dsaParameters);
    internal static AsnWriter WritePkcs8(DSAParameters& dsaParameters);
    private static void WriteAlgorithmId(AsnWriter writer, DSAParameters& dsaParameters);
    private static void WriteKeyComponent(AsnWriter writer, Byte[] component, bool bitString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAOpenSsl : DSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(DSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAParameters : ValueType {
    public Byte[] P;
    public Byte[] Q;
    public Byte[] G;
    public Byte[] Y;
    public Byte[] J;
    public Byte[] X;
    public Byte[] Seed;
    public int Counter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    private DSA _dsaKey;
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public enum System.Security.Cryptography.DSASignatureFormat : Enum {
    public int value__;
    public static DSASignatureFormat IeeeP1363FixedFieldConcatenation;
    public static DSASignatureFormat Rfc3279DerSequence;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.DSASignatureFormatHelpers : object {
    [ExtensionAttribute]
internal static bool IsKnownValue(DSASignatureFormat signatureFormat);
    internal static Exception CreateUnknownValueException(DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    private DSA _dsaKey;
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
public abstract class System.Security.Cryptography.ECAlgorithm : AsymmetricAlgorithm {
    private static String[] s_validOids;
    private protected static KeySizes[] s_defaultKeySizes;
    private static ECAlgorithm();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    [NullableContextAttribute("1")]
public string ExportECPrivateKeyPem();
    public bool TryExportECPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__17_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportECPrivateKeyPem>g__Export|21_0(ECAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
}
internal class System.Security.Cryptography.ECAndroid : object {
    private Lazy`1<SafeEcKeyHandle> _key;
    internal SafeEcKeyHandle Value { get; }
    internal int KeySize { get; }
    public ECAndroid(ECCurve curve);
    public ECAndroid(AsymmetricAlgorithm owner);
    public ECAndroid(ECParameters ecParameters);
    public ECAndroid(SafeEcKeyHandle key);
    internal SafeEcKeyHandle get_Value();
    private static SafeEcKeyHandle GenerateKeyLazy(AsymmetricAlgorithm owner);
    public sealed virtual void Dispose();
    internal int get_KeySize();
    internal SafeEcKeyHandle UpRefKeyHandle();
    internal void SetKey(SafeEcKeyHandle key);
    internal int GenerateKey(ECCurve curve);
    private void FreeKey();
    public int ImportParameters(ECParameters parameters);
    public static ECParameters ExportExplicitParameters(SafeEcKeyHandle currentKey, bool includePrivateParameters);
    public static ECParameters ExportParameters(SafeEcKeyHandle currentKey, bool includePrivateParameters);
    private static ECParameters ExportNamedCurveParameters(SafeEcKeyHandle key, string curveName, bool includePrivateParameters);
    private static ECParameters ExportExplicitCurveParameters(SafeEcKeyHandle key, bool includePrivateParameters);
    private static SafeEcKeyHandle ImportNamedCurveParameters(ECParameters parameters);
    private static SafeEcKeyHandle ImportPrimeCurveParameters(ECParameters parameters);
    private static SafeEcKeyHandle ImportCharacteristic2CurveParameters(ECParameters parameters);
    private static void CheckInvalidKey(SafeEcKeyHandle key);
    public static SafeEcKeyHandle GenerateKeyByKeySize(int keySize);
}
internal static class System.Security.Cryptography.EccKeyFormatHelper : object {
    internal static ECParameters FromECPrivateKey(ReadOnlySpan`1<byte> key, Int32& bytesRead);
    internal static void FromECPrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPrivateKey(ECPrivateKey key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPublicKey(ReadOnlyMemory`1<byte> key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    private static void ValidateParameters(Nullable`1<ECDomainParameters> keyParameters, AlgorithmIdentifierAsn& algId);
    private static ECCurve GetCurve(ECDomainParameters domainParameters);
    private static ECCurve GetSpecifiedECCurve(SpecifiedECDomain specifiedParameters);
    private static ECCurve GetSpecifiedECCurveCore(SpecifiedECDomain specifiedParameters);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ECParameters ecParameters);
    private static AsnWriter WriteAlgorithmIdentifier(ECParameters& ecParameters);
    private static void WriteAlgorithmIdentifier(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WritePkcs8PrivateKey(ECParameters ecParameters, AttributeAsn[] attributes);
    private static AsnWriter WritePrivateKeyInfoAttributes(AttributeAsn[] attributes);
    private static void WriteEcParameters(ECParameters ecParameters, AsnWriter writer);
    private static void WriteSpecifiedECDomain(ECParameters ecParameters, AsnWriter writer);
    private static void DetermineChar2Parameters(ECParameters& ecParameters, Int32& m, Int32& k1, Int32& k2, Int32& k3);
    private static void WriteCurve(ECCurve& curve, AsnWriter writer);
    private static void WriteFieldElement(Byte[] fieldElement, AsnWriter writer);
    private static void WriteUncompressedBasePoint(ECParameters& ecParameters, AsnWriter writer);
    private static void WriteUncompressedPublicKey(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WriteECPrivateKey(ECParameters& ecParameters);
    private static AsnWriter WriteEcPrivateKey(ECParameters& ecParameters, bool includeDomainParameters);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ECCurve = {Oid}")]
public class System.Security.Cryptography.ECCurve : ValueType {
    public Byte[] A;
    public Byte[] B;
    public ECPoint G;
    public Byte[] Order;
    public Byte[] Cofactor;
    public Byte[] Seed;
    public ECCurveType CurveType;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Polynomial;
    public Byte[] Prime;
    private Oid _oid;
    [NullableAttribute("1")]
public Oid Oid { get; private set; }
    public bool IsPrime { get; }
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    [NullableContextAttribute("1")]
public Oid get_Oid();
    private void set_Oid(Oid value);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromOid(Oid curveOid);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromValue(string oidValue);
    private static ECCurve CreateFromValueAndName(string oidValue, string oidFriendlyName);
    public bool get_IsPrime();
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public void Validate();
    private bool HasAnyExplicitParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellman : ECAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public virtual string get_KeyExchangeAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECParameters parameters);
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static ECDiffieHellman Create(string algorithm);
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual Byte[] DeriveRawSecretAgreement(ECDiffieHellmanPublicKey otherPartyPublicKey);
    private static NotImplementedException DerivedClassMustOverride();
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    [NullableAttribute("1")]
public CngAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HmacKey { get; public set; }
    [NullableAttribute("1")]
public CngKey Key { get; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    public Byte[] Label { get; public set; }
    public Byte[] SecretAppend { get; public set; }
    public Byte[] SecretPrepend { get; public set; }
    public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    [NullableAttribute("1")]
public ECDiffieHellmanPublicKey PublicKey { get; }
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(int keySize);
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(ECCurve curve);
    [NullableContextAttribute("1")]
public CngAlgorithm get_HashAlgorithm();
    [NullableContextAttribute("1")]
public void set_HashAlgorithm(CngAlgorithm value);
    public Byte[] get_HmacKey();
    public void set_HmacKey(Byte[] value);
    [NullableContextAttribute("1")]
public CngKey get_Key();
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    public Byte[] get_Label();
    public void set_Label(Byte[] value);
    public Byte[] get_SecretAppend();
    public void set_SecretAppend(Byte[] value);
    public Byte[] get_SecretPrepend();
    public void set_SecretPrepend(Byte[] value);
    public Byte[] get_Seed();
    public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    [NullableContextAttribute("1")]
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    [NullableContextAttribute("1")]
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    [NullableContextAttribute("1")]
public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
    [NullableContextAttribute("1")]
public virtual ECDiffieHellmanPublicKey get_PublicKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    public CngKeyBlobFormat BlobFormat { get; }
    public CngKeyBlobFormat get_BlobFormat();
    protected virtual void Dispose(bool disposing);
    public CngKey Import();
    [SupportedOSPlatformAttribute("windows")]
public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
}
internal static class System.Security.Cryptography.ECDiffieHellmanDerivation : object {
    internal static Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> secretPrepend, ReadOnlySpan`1<byte> secretAppend, DeriveSecretAgreement deriveSecretAgreement);
    internal static Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, ReadOnlySpan`1<byte> secretPrepend, ReadOnlySpan`1<byte> secretAppend, DeriveSecretAgreement deriveSecretAgreement);
    internal static Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, ReadOnlySpan`1<byte> prfLabel, ReadOnlySpan`1<byte> prfSeed, DeriveSecretAgreement deriveSecretAgreement);
    private static void PHash(HashAlgorithmName algorithmName, ReadOnlySpan`1<byte> secret, ReadOnlySpan`1<byte> prfLabel, ReadOnlySpan`1<byte> prfSeed, int hashOutputSize, Span`1<byte> ret);
}
internal static class System.Security.Cryptography.ECDiffieHellmanImplementation : object {
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanOpenSsl : ECDiffieHellman {
    public ECDiffieHellmanPublicKey PublicKey { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    private Byte[] _keyBlob;
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
public virtual Byte[] ToByteArray();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
    public virtual ECParameters ExportParameters();
    public virtual ECParameters ExportExplicitParameters();
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportSubjectPublicKeyInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDsa : ECAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECParameters parameters);
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static ECDsa Create(string algorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignHash(Byte[] hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignHashCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignHashCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public bool VerifyHash(Byte[] hash, Byte[] signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyHashCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    private ReadOnlySpan`1<byte> HashSpanToTmp(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Span`1<byte> tmp);
    private Byte[] HashSpanToArray(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; }
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public CngKey get_Key();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public Byte[] SignData(Stream data);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
internal static class System.Security.Cryptography.ECDsaImplementation : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaOpenSsl : ECDsa {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECPoint Q;
    [NullableAttribute("2")]
public Byte[] D;
    public ECCurve Curve;
    public void Validate();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.FromBase64Transform : object {
    private static SearchValues`1<byte> s_whiteSpace;
    private FromBase64TransformMode _whitespaces;
    private Byte[] _inputBuffer;
    private int _inputIndex;
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    private static FromBase64Transform();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Span`1<byte> AppendInputBuffers(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> transformBuffer);
    private static int GetOutputSize(int bytesToTransform, Span`1<byte> tmpBuffer);
    private void ConvertFromBase64(Span`1<byte> transformBuffer, Span`1<byte> outputBuffer, Int32& consumed, Int32& written);
    private static void ReturnToCryptoPool(Byte[] array, int clearSize);
    public void Clear();
    private void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    private bool _disposed;
    protected int HashSizeValue;
    [NullableAttribute("2")]
protected internal Byte[] HashValue;
    protected int State;
    public int HashSize { get; }
    [NullableAttribute("2")]
public Byte[] Hash { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HashAlgorithm Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static HashAlgorithm Create(string hashName);
    public virtual int get_HashSize();
    [NullableContextAttribute("2")]
public virtual Byte[] get_Hash();
    public Byte[] ComputeHash(Byte[] buffer);
    [NullableContextAttribute("0")]
public bool TryComputeHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public Byte[] ComputeHash(Stream inputStream);
    public Task`1<Byte[]> ComputeHashAsync(Stream inputStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.HashAlgorithm/<ComputeHashAsyncCore>d__16")]
private Task`1<Byte[]> ComputeHashAsyncCore(Stream inputStream, CancellationToken cancellationToken);
    private Byte[] CaptureHashCodeAndReinitialize();
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected abstract virtual Byte[] HashFinal();
    public abstract virtual void Initialize();
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Security.Cryptography.HashAlgorithmName : ValueType {
    private string _name;
    public static HashAlgorithmName MD5 { get; }
    public static HashAlgorithmName SHA1 { get; }
    public static HashAlgorithmName SHA256 { get; }
    public static HashAlgorithmName SHA384 { get; }
    public static HashAlgorithmName SHA512 { get; }
    public static HashAlgorithmName SHA3_256 { get; }
    public static HashAlgorithmName SHA3_384 { get; }
    public static HashAlgorithmName SHA3_512 { get; }
    public string Name { get; }
    public HashAlgorithmName(string name);
    public static HashAlgorithmName get_MD5();
    public static HashAlgorithmName get_SHA1();
    public static HashAlgorithmName get_SHA256();
    public static HashAlgorithmName get_SHA384();
    public static HashAlgorithmName get_SHA512();
    public static HashAlgorithmName get_SHA3_256();
    public static HashAlgorithmName get_SHA3_384();
    public static HashAlgorithmName get_SHA3_512();
    public string get_Name();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashAlgorithmName other);
    public virtual int GetHashCode();
    public static bool op_Equality(HashAlgorithmName left, HashAlgorithmName right);
    public static bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right);
    [NullableContextAttribute("1")]
public static bool TryFromOid(string oidValue, HashAlgorithmName& value);
    [NullableContextAttribute("1")]
public static HashAlgorithmName FromOid(string oidValue);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.HashAlgorithmNames : object {
    [ExtensionAttribute]
public static string ToAlgorithmName(HashAlgorithm hashAlgorithm);
    public static string ToUpper(string hashAlgorithmName);
}
internal static class System.Security.Cryptography.HashOneShotHelpers : object {
    internal static Byte[] HashData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> source);
    internal static bool TryHashData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] HashData(HashAlgorithmName hashAlgorithm, Stream source);
    internal static int MacData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
}
internal abstract class System.Security.Cryptography.HashProvider : object {
    public int HashSizeInBytes { get; }
    public void AppendHashData(Byte[] data, int offset, int count);
    public abstract virtual void AppendHashData(ReadOnlySpan`1<byte> data);
    public abstract virtual int FinalizeHashAndReset(Span`1<byte> destination);
    public abstract virtual int GetCurrentHash(Span`1<byte> destination);
    public Byte[] FinalizeHashAndReset();
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public abstract virtual int get_HashSizeInBytes();
    public sealed virtual void Dispose();
    public abstract virtual void Dispose(bool disposing);
    public abstract virtual void Reset();
}
internal static class System.Security.Cryptography.HashProviderDispenser : object {
    internal static HashProvider CreateHashProvider(string hashAlgorithmId);
    internal static HashProvider CreateMacProvider(string hashAlgorithmId, ReadOnlySpan`1<byte> key);
    internal static bool HashSupported(string hashAlgorithmId);
    internal static bool MacSupported(string hashAlgorithmId);
}
public static class System.Security.Cryptography.HKDF : object {
    [NullableContextAttribute("1")]
public static Byte[] Extract(HashAlgorithmName hashAlgorithmName, Byte[] ikm, Byte[] salt);
    public static int Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, ReadOnlySpan`1<byte> salt, Span`1<byte> prk);
    private static void Extract(HashAlgorithmName hashAlgorithmName, int hashLength, ReadOnlySpan`1<byte> ikm, ReadOnlySpan`1<byte> salt, Span`1<byte> prk);
    [NullableContextAttribute("1")]
public static Byte[] Expand(HashAlgorithmName hashAlgorithmName, Byte[] prk, int outputLength, Byte[] info);
    public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> prk, Span`1<byte> output, ReadOnlySpan`1<byte> info);
    private static void Expand(HashAlgorithmName hashAlgorithmName, int hashLength, ReadOnlySpan`1<byte> prk, Span`1<byte> output, ReadOnlySpan`1<byte> info);
    [NullableContextAttribute("1")]
public static Byte[] DeriveKey(HashAlgorithmName hashAlgorithmName, Byte[] ikm, int outputLength, Byte[] salt, Byte[] info);
    public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, Span`1<byte> output, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info);
    private static void GetHashAndReset(IncrementalHash hmac, Span`1<byte> output);
    private static int HashLength(HashAlgorithmName hashAlgorithmName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    private string _hashName;
    private int _blockSizeValue;
    protected int BlockSizeValue { get; protected set; }
    public string HashName { get; public set; }
    public Byte[] Key { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HMAC Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static HMAC Create(string algorithmName);
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
}
internal class System.Security.Cryptography.HMACCommon : object {
    [CompilerGeneratedAttribute]
private Byte[] <ActualKey>k__BackingField;
    private string _hashAlgorithmId;
    private HashProvider _hMacProvider;
    private int _blockSize;
    public int HashSizeInBits { get; }
    public int HashSizeInBytes { get; }
    public Byte[] ActualKey { get; private set; }
    public HMACCommon(string hashAlgorithmId, Byte[] key, int blockSize);
    internal HMACCommon(string hashAlgorithmId, ReadOnlySpan`1<byte> key, int blockSize);
    public int get_HashSizeInBits();
    public int get_HashSizeInBytes();
    public void ChangeKey(Byte[] key);
    [MemberNotNullAttribute("_hMacProvider")]
private Byte[] ChangeKeyImpl(ReadOnlySpan`1<byte> key);
    [CompilerGeneratedAttribute]
public Byte[] get_ActualKey();
    [CompilerGeneratedAttribute]
private void set_ActualKey(Byte[] value);
    public void AppendHashData(Byte[] data, int offset, int count);
    public void AppendHashData(ReadOnlySpan`1<byte> source);
    public Byte[] FinalizeHashAndReset();
    public int FinalizeHashAndReset(Span`1<byte> destination);
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public int GetCurrentHash(Span`1<byte> destination);
    public void Reset();
    public void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public HMACMD5(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA1(Byte[] key);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HMACSHA1 always uses the algorithm implementation provided by the platform. Use a constructor without the useManagedSha1 parameter.")]
public HMACSHA1(Byte[] key, bool useManagedSha1);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA256(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_256 : HMAC {
    private HMACCommon _hMacCommon;
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_256(Byte[] key);
    private static HMACSHA3_256();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private static void CheckSha3Support();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_384 : HMAC {
    private HMACCommon _hMacCommon;
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_384(Byte[] key);
    private static HMACSHA3_384();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private static void CheckSha3Support();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA3_512 : HMAC {
    private HMACCommon _hMacCommon;
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    public Byte[] Key { get; public set; }
    public HMACSHA3_512(Byte[] key);
    private static HMACSHA3_512();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private static void CheckSha3Support();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA384(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA512(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICryptoTransform {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
internal interface System.Security.Cryptography.ILiteHash {
    public int HashSizeInBytes { get; }
    public abstract virtual int get_HashSizeInBytes();
    public abstract virtual void Append(ReadOnlySpan`1<byte> data);
    public abstract virtual int Finalize(Span`1<byte> destination);
}
internal interface System.Security.Cryptography.ILiteSymmetricCipher {
    public int BlockSizeInBytes { get; }
    public int PaddingSizeInBytes { get; }
    public abstract virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual void Reset(ReadOnlySpan`1<byte> iv);
    public abstract virtual int get_BlockSizeInBytes();
    public abstract virtual int get_PaddingSizeInBytes();
}
public class System.Security.Cryptography.IncrementalHash : object {
    private HashAlgorithmName _algorithmName;
    private HashProvider _hash;
    private HMACCommon _hmac;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private int <HashLengthInBytes>k__BackingField;
    public int HashLengthInBytes { get; }
    public HashAlgorithmName AlgorithmName { get; }
    private IncrementalHash(HashAlgorithmName name, HashProvider hash);
    private IncrementalHash(HashAlgorithmName name, HMACCommon hmac);
    [CompilerGeneratedAttribute]
public int get_HashLengthInBytes();
    public HashAlgorithmName get_AlgorithmName();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data, int offset, int count);
    public void AppendData(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset();
    public int GetHashAndReset(Span`1<byte> destination);
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    private int GetHashAndResetCore(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash();
    public int GetCurrentHash(Span`1<byte> destination);
    public bool TryGetCurrentHash(Span`1<byte> destination, Int32& bytesWritten);
    private int GetCurrentHashCore(Span`1<byte> destination);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> key);
    private static void CheckSha3Support(string hashAlgorithmName);
}
internal interface System.Security.Cryptography.IRuntimeAlgorithm {
}
internal static class System.Security.Cryptography.KdfWorkLimiter : object {
    [ThreadStaticAttribute]
private static State t_state;
    internal static void SetIterationLimit(ulong workLimit);
    internal static bool WasWorkLimitExceeded();
    internal static void ResetIterationLimit();
    internal static void RecordIterations(int workCount);
    internal static void RecordIterations(long workCount);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory, int length);
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory);
    [ExtensionAttribute]
internal static Byte[] ExportKeyParameter(BigInteger value, int length);
    [ExtensionAttribute]
internal static void WriteKeyParameterInteger(AsnWriter writer, ReadOnlySpan`1<byte> integer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static KeyedHashAlgorithm Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static KeyedHashAlgorithm Create(string algName);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter, AsnWriter attributesWriter);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
public class System.Security.Cryptography.KeySizes : object {
    [CompilerGeneratedAttribute]
private int <MinSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipSize>k__BackingField;
    public int MinSize { get; private set; }
    public int MaxSize { get; private set; }
    public int SkipSize { get; private set; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    [CompilerGeneratedAttribute]
public int get_MinSize();
    [CompilerGeneratedAttribute]
private void set_MinSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSize();
    [CompilerGeneratedAttribute]
private void set_MaxSize(int value);
    [CompilerGeneratedAttribute]
public int get_SkipSize();
    [CompilerGeneratedAttribute]
private void set_SkipSize(int value);
}
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.LiteHash : ValueType {
    private SafeEvpMdCtxHandle _ctx;
    private IntPtr _algorithm;
    private int _hashSizeInBytes;
    public int HashSizeInBytes { get; }
    internal LiteHash(IntPtr algorithm);
    public sealed virtual int get_HashSizeInBytes();
    public sealed virtual void Append(ReadOnlySpan`1<byte> data);
    public sealed virtual int Finalize(Span`1<byte> destination);
    public void Reset();
    public int Current(Span`1<byte> destination);
    public sealed virtual void Dispose();
    private static void Check(int result);
}
internal static class System.Security.Cryptography.LiteHashProvider : object {
    internal static int HashStream(string hashAlgorithmId, Stream source, Span`1<byte> destination);
    internal static Byte[] HashStream(string hashAlgorithmId, int hashSizeInBytes, Stream source);
    internal static ValueTask`1<int> HashStreamAsync(string hashAlgorithmId, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static ValueTask`1<Byte[]> HashStreamAsync(string hashAlgorithmId, Stream source, CancellationToken cancellationToken);
    internal static int HmacStream(string hashAlgorithmId, ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    internal static Byte[] HmacStream(string hashAlgorithmId, int hashSizeInBytes, ReadOnlySpan`1<byte> key, Stream source);
    internal static ValueTask`1<int> HmacStreamAsync(string hashAlgorithmId, ReadOnlySpan`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static ValueTask`1<Byte[]> HmacStreamAsync(string hashAlgorithmId, ReadOnlySpan`1<byte> key, Stream source, CancellationToken cancellationToken);
    private static int ProcessStream(T hash, Stream source, Span`1<byte> destination);
    [AsyncStateMachineAttribute("System.Security.Cryptography.LiteHashProvider/<ProcessStreamAsync>d__9`1")]
private static ValueTask`1<int> ProcessStreamAsync(T hash, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.LiteHashProvider/<ProcessStreamAsync>d__10`1")]
private static ValueTask`1<Byte[]> ProcessStreamAsync(T hash, int outputLength, Stream source, CancellationToken cancellationToken);
    internal static void XofStream(string hashAlgorithmId, Stream source, Span`1<byte> destination);
    internal static Byte[] XofStream(string hashAlgorithmId, int outputLength, Stream source);
    internal static ValueTask XofStreamAsync(string hashAlgorithmId, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static ValueTask`1<Byte[]> XofStreamAsync(string hashAlgorithmId, int outputLength, Stream source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.LiteHashProvider/<ProcessStreamXofAsync>d__15`1")]
private static ValueTask ProcessStreamXofAsync(T hash, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static LiteHash CreateHash(string hashAlgorithmId);
    internal static LiteHmac CreateHmac(string hashAlgorithmId, ReadOnlySpan`1<byte> key);
    internal static LiteXof CreateXof(string hashAlgorithmId);
}
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.LiteHmac : ValueType {
    private SafeHmacCtxHandle _ctx;
    private int _hashSizeInBytes;
    public int HashSizeInBytes { get; }
    internal LiteHmac(IntPtr algorithm, ReadOnlySpan`1<byte> key);
    public sealed virtual int get_HashSizeInBytes();
    public sealed virtual void Append(ReadOnlySpan`1<byte> data);
    public int Current(Span`1<byte> destination);
    public sealed virtual int Finalize(Span`1<byte> destination);
    public void Reset();
    public sealed virtual void Dispose();
    private static void Check(int result);
}
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.LiteXof : ValueType {
    private SafeEvpMdCtxHandle _ctx;
    private IntPtr _algorithm;
    public int HashSizeInBytes { get; }
    internal LiteXof(IntPtr algorithm);
    public sealed virtual int get_HashSizeInBytes();
    public sealed virtual void Append(ReadOnlySpan`1<byte> data);
    public void Reset();
    public sealed virtual int Finalize(Span`1<byte> destination);
    public void Current(Span`1<byte> destination);
    public sealed virtual void Dispose();
    private static void Check(int result);
}
internal class System.Security.Cryptography.ManagedAsnFormatter : AsnFormatter {
    protected virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
    private static string FormatSubjectAlternativeName(Byte[] rawData);
}
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static MD5 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static MD5 Create(string algName);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Oid : object {
    private string _value;
    private string _friendlyName;
    private bool _hasInitializedFriendlyName;
    private OidGroup _group;
    public string Value { get; public set; }
    public string FriendlyName { get; public set; }
    [NullableContextAttribute("1")]
public Oid(string oid);
    public Oid(string value, string friendlyName);
    [NullableContextAttribute("1")]
public Oid(Oid oid);
    private Oid(string value, string friendlyName, OidGroup group);
    [NullableContextAttribute("1")]
public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    [NullableContextAttribute("1")]
public static Oid FromOidValue(string oidValue, OidGroup group);
    public string get_Value();
    public void set_Value(string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    private Oid[] _oids;
    private int _count;
    public Oid Item { get; }
    [NullableAttribute("2")]
public Oid Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Add(Oid oid);
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual int get_Count();
    public OidEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Oid[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.OidEnumerator : object {
    private OidCollection _oids;
    private int _current;
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OidEnumerator(OidCollection oids);
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
internal static class System.Security.Cryptography.OidLookup : object {
    private static ConcurrentDictionary`2<string, string> s_lateBoundOidToFriendlyName;
    private static ConcurrentDictionary`2<string, string> s_lateBoundFriendlyNameToOid;
    private static Dictionary`2<string, string> s_friendlyNameToOid;
    private static Dictionary`2<string, string> s_oidToFriendlyName;
    private static Dictionary`2<string, string> s_compatOids;
    private static Dictionary`2<string, string> s_extraFriendlyNameToOid;
    private static Dictionary`2<string, string> s_extraOidToFriendlyName;
    private static OidLookup();
    public static string ToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    public static string ToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    private static void InitializeLookupDictionaries();
    private static bool ShouldUseCache(OidGroup oidGroup);
    private static string NativeOidToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    private static string NativeFriendlyNameToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    private static Dictionary`2<string, string> InvertWithDefaultComparer(Dictionary`2<string, string> source);
    [CompilerGeneratedAttribute]
internal static void <InitializeLookupDictionaries>g__AddEntry|10_0(string oid, string primaryFriendlyName, String[] additionalFriendlyNames);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.Oids : object {
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_ecPublicKeyOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp256R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp384R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp521R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_pkcs9ExtensionRequestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_basicConstraints2Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_enhancedKeyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_keyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_subjectAltNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_subjectKeyIdentifierOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_authorityKeyIdentifierOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_authorityInformationAccessOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_crlNumberOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_crlDistributionPointOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_commonNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_countryOrRegionOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_localityNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_stateOrProvinceNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_organizationOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_organizationalUnitOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_emailAddressOid;
    internal static Oid StateOrProvinceNameOid;
    internal static Oid OrganizationOid;
    internal static Oid OrganizationalUnitOid;
    internal static Oid EmailAddressOid;
    internal static Oid RsaOid { get; }
    internal static Oid EcPublicKeyOid { get; }
    internal static Oid secp256r1Oid { get; }
    internal static Oid secp384r1Oid { get; }
    internal static Oid secp521r1Oid { get; }
    internal static Oid Pkcs9ExtensionRequestOid { get; }
    internal static Oid BasicConstraints2Oid { get; }
    internal static Oid EnhancedKeyUsageOid { get; }
    internal static Oid KeyUsageOid { get; }
    internal static Oid AuthorityKeyIdentifierOid { get; }
    internal static Oid SubjectKeyIdentifierOid { get; }
    internal static Oid SubjectAltNameOid { get; }
    internal static Oid AuthorityInformationAccessOid { get; }
    internal static Oid CrlNumberOid { get; }
    internal static Oid CrlDistributionPointsOid { get; }
    internal static Oid CommonNameOid { get; }
    internal static Oid CountryOrRegionNameOid { get; }
    internal static Oid LocalityNameOid { get; }
    private static Oids();
    internal static Oid get_RsaOid();
    internal static Oid get_EcPublicKeyOid();
    internal static Oid get_secp256r1Oid();
    internal static Oid get_secp384r1Oid();
    internal static Oid get_secp521r1Oid();
    internal static Oid get_Pkcs9ExtensionRequestOid();
    internal static Oid get_BasicConstraints2Oid();
    internal static Oid get_EnhancedKeyUsageOid();
    internal static Oid get_KeyUsageOid();
    internal static Oid get_AuthorityKeyIdentifierOid();
    internal static Oid get_SubjectKeyIdentifierOid();
    internal static Oid get_SubjectAltNameOid();
    internal static Oid get_AuthorityInformationAccessOid();
    internal static Oid get_CrlNumberOid();
    internal static Oid get_CrlDistributionPointsOid();
    internal static Oid get_CommonNameOid();
    internal static Oid get_CountryOrRegionNameOid();
    internal static Oid get_LocalityNameOid();
    private static Oid InitializeOid(string oidValue);
    internal static Oid GetSharedOrNewOid(AsnValueReader& asnValueReader);
    internal static Oid GetSharedOrNullOid(AsnValueReader& asnValueReader, Nullable`1<Asn1Tag> expectedTag);
    [ExtensionAttribute]
internal static bool ValueEquals(Oid oid, Oid other);
}
internal class System.Security.Cryptography.OpenSslCipher : BasicSymmetricCipher {
    private OpenSslCipherLite _cipherLite;
    public OpenSslCipher(IntPtr algorithm, CipherMode cipherMode, int blockSizeInBytes, int paddingSizeInBytes, Byte[] key, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal class System.Security.Cryptography.OpenSslCipherLite : object {
    private SafeEvpCipherCtxHandle _ctx;
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    public int BlockSizeInBytes { get; }
    public int PaddingSizeInBytes { get; }
    public OpenSslCipherLite(IntPtr algorithm, int blockSizeInBytes, int paddingSizeInBytes, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, bool encrypting);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PaddingSizeInBytes();
    public sealed virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Reset(ReadOnlySpan`1<byte> iv);
    public sealed virtual void Dispose();
    private int CipherUpdate(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    private static void CheckBoolReturn(bool returnValue);
}
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, AsnWriter source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<int> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount, Nullable`1<int> iterationLimit);
    private static RC2 CreateRC2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    private int _extraCount;
    private int _prefix;
    private int _iterations;
    private Byte[] _baseValue;
    private Byte[] _extra;
    private Byte[] _salt;
    private Byte[] _password;
    private string _hashName;
    private HashAlgorithm _hash;
    private CspParameters _cspParams;
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    [NullableAttribute("2")]
public Byte[] Salt { get; public set; }
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("1", "System.Security.Cryptography.SHA1CryptoServiceProvider")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("1", "System.Security.Cryptography.SHA1CryptoServiceProvider")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    [NullableContextAttribute("2")]
public Byte[] get_Salt();
    [NullableContextAttribute("2")]
public void set_Salt(Byte[] value);
    [ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    private Byte[] ComputeBaseValue();
    private Byte[] ComputeBytes(int cb);
    private void HashPrefix(CryptoStream cs);
    [SupportedOSPlatformAttribute("windows")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
}
public enum System.Security.Cryptography.PbeEncryptionAlgorithm : Enum {
    public int value__;
    public static PbeEncryptionAlgorithm Unknown;
    public static PbeEncryptionAlgorithm Aes128Cbc;
    public static PbeEncryptionAlgorithm Aes192Cbc;
    public static PbeEncryptionAlgorithm Aes256Cbc;
    public static PbeEncryptionAlgorithm TripleDes3KeyPkcs12;
}
public class System.Security.Cryptography.PbeParameters : object {
    [CompilerGeneratedAttribute]
private PbeEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationCount>k__BackingField;
    public PbeEncryptionAlgorithm EncryptionAlgorithm { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; }
    public PbeParameters(PbeEncryptionAlgorithm encryptionAlgorithm, HashAlgorithmName hashAlgorithm, int iterationCount);
    [CompilerGeneratedAttribute]
public PbeEncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public int get_IterationCount();
}
internal static class System.Security.Cryptography.Pbkdf2Implementation : object {
    public static void Fill(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithmName, Span`1<byte> destination);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.PemEncoding : object {
    public static PemFields Find(ReadOnlySpan`1<char> pemData);
    public static bool TryFind(ReadOnlySpan`1<char> pemData, PemFields& fields);
    [ExtensionAttribute]
private static int IndexOfByOffset(ReadOnlySpan`1<char> str, ReadOnlySpan`1<char> value, int startPosition);
    private static bool IsValidLabel(ReadOnlySpan`1<char> data);
    private static bool TryCountBase64(ReadOnlySpan`1<char> str, Int32& base64Start, Int32& base64End, Int32& base64DecodedSize);
    private static bool IsWhiteSpaceCharacter(char ch);
    public static int GetEncodedSize(int labelLength, int dataLength);
    public static bool TryWrite(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data, Span`1<char> destination, Int32& charsWritten);
    private static int WriteCore(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data, Span`1<char> destination);
    public static Char[] Write(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
    public static string WriteString(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<char> <TryFind>g__WritePostEB|5_0(ReadOnlySpan`1<char> label, Span`1<char> destination);
    [CompilerGeneratedAttribute]
internal static bool <IsValidLabel>g__IsLabelChar|7_0(char c);
    [CompilerGeneratedAttribute]
internal static int <WriteCore>g__Write|12_0(ReadOnlySpan`1<char> str, Span`1<char> dest, int offset);
    [CompilerGeneratedAttribute]
internal static int <WriteCore>g__WriteBase64|12_1(ReadOnlySpan`1<byte> bytes, Span`1<char> dest, int offset);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.PemEnumerator : ValueType {
    private ReadOnlySpan`1<char> _contents;
    public PemEnumerator(ReadOnlySpan`1<char> contents);
    public Enumerator GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Security.Cryptography.PemFields : ValueType {
    [CompilerGeneratedAttribute]
private Range <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Range <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Range <Base64Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DecodedDataLength>k__BackingField;
    public Range Location { get; }
    public Range Label { get; }
    public Range Base64Data { get; }
    public int DecodedDataLength { get; }
    internal PemFields(Range label, Range base64data, Range location, int decodedDataLength);
    [CompilerGeneratedAttribute]
public Range get_Location();
    [CompilerGeneratedAttribute]
public Range get_Label();
    [CompilerGeneratedAttribute]
public Range get_Base64Data();
    [CompilerGeneratedAttribute]
public int get_DecodedDataLength();
}
internal static class System.Security.Cryptography.PemKeyHelpers : object {
    public static bool TryExportToEncryptedPem(T arg, ReadOnlySpan`1<TPassword> password, PbeParameters pbeParameters, TryExportEncryptedKeyAction`2<T, TPassword> exporter, Span`1<char> destination, Int32& charsWritten);
    public static bool TryExportToPem(T arg, string label, TryExportKeyAction`1<T> exporter, Span`1<char> destination, Int32& charsWritten);
    public static void ImportEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<TPass> password, ImportEncryptedKeyAction`1<TPass> importAction);
    public static void ImportPem(ReadOnlySpan`1<char> input, FindImportActionFunc callback);
}
internal class System.Security.Cryptography.PinAndClear : ValueType {
    private Byte[] _data;
    private GCHandle _gcHandle;
    internal static PinAndClear Track(Byte[] data);
    public sealed virtual void Dispose();
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static ValueTuple`3[] s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveMacKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    private string _hashNameValue;
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
    [NullableContextAttribute("0")]
public static void Fill(Span`1<byte> data);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public static int GetInt32(int toExclusive);
    public static Byte[] GetBytes(int count);
    [NullableContextAttribute("2")]
public static void GetItems(ReadOnlySpan`1<T> choices, Span`1<T> destination);
    public static T[] GetItems(ReadOnlySpan`1<T> choices, int length);
    [NullableContextAttribute("0")]
public static string GetString(ReadOnlySpan`1<char> choices, int length);
    [NullableContextAttribute("0")]
public static void GetHexString(Span`1<char> destination, bool lowercase);
    public static string GetHexString(int stringLength, bool lowercase);
    [NullableContextAttribute("2")]
public static void Shuffle(Span`1<T> values);
    private static void GetHexStringCore(Span`1<char> destination, bool lowercase);
    private static void GetItemsCore(ReadOnlySpan`1<T> choices, Span`1<T> destination);
    internal static void VerifyGetBytes(Byte[] data, int offset, int count);
}
internal class System.Security.Cryptography.RandomNumberGeneratorImplementation : RandomNumberGenerator {
    internal static RandomNumberGeneratorImplementation s_singleton;
    private static RandomNumberGeneratorImplementation();
    internal static void FillSpan(Span`1<byte> data);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    internal static void FillNonZeroBytes(Span`1<byte> data);
    private static void GetBytes(Byte* pbBuffer, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public int KeySize { get; public set; }
    public int EffectiveKeySize { get; public set; }
    private static RC2();
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
public static RC2 Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RC2 Create(string AlgName);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    private RC2 _impl;
    private static KeySizes[] s_legalKeySizes;
    public int BlockSize { get; public set; }
    public int EffectiveKeySize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public bool UseSalt { get; public set; }
    private static RC2CryptoServiceProvider();
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public bool get_UseSalt();
    [SupportedOSPlatformAttribute("windows")]
public void set_UseSalt(bool value);
}
internal class System.Security.Cryptography.RC2Implementation : RC2 {
    public int EffectiveKeySize { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private UniversalCryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private int GetPaddingSize();
    private bool ValidKeySize(int keySizeBytes);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int feedbackSizeInBytes, int paddingSize, bool encrypting);
    private static ILiteSymmetricCipher CreateLiteCipher(CipherMode cipherMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int paddingSize, bool encrypting);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    private Byte[] _salt;
    private UInt32 _iterations;
    private IncrementalHash _hmac;
    private int _blockSize;
    private Byte[] _buffer;
    private UInt32 _block;
    private int _startIndex;
    private int _endIndex;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    private static UTF8Encoding s_throwingUtf8Encoding;
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    internal Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, bool clearPassword);
    internal Rfc2898DeriveBytes(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm);
    private static Rfc2898DeriveBytes();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    internal void GetBytes(Span`1<byte> destination);
    [ObsoleteAttribute("Rfc2898DeriveBytes.CryptDeriveKey is obsolete and is not supported. Use PasswordDeriveBytes.CryptDeriveKey instead.")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    public virtual void Reset();
    private IncrementalHash OpenHmac(ReadOnlySpan`1<byte> password);
    [MemberNotNullAttribute("_buffer")]
private void Initialize();
    private void Func();
    public static Byte[] Pbkdf2(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    public static Byte[] Pbkdf2(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void Pbkdf2Core(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void Pbkdf2Core(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void ValidateHashAlgorithm(HashAlgorithmName hashAlgorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Rijndael();
    [UnsupportedOSPlatformAttribute("browser")]
public static Rijndael Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static Rijndael Create(string algName);
}
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
internal class System.Security.Cryptography.RijndaelImplementation : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
[EditorBrowsableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("RNGCryptoServiceProvider is obsolete. To generate a random number, use one of the RandomNumberGenerator static methods instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    private RandomNumberGenerator _impl;
    public RNGCryptoServiceProvider(string str);
    public RNGCryptoServiceProvider(Byte[] rgb);
    [NullableContextAttribute("2")]
public RNGCryptoServiceProvider(CspParameters cspParams);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RSA Create(string algName);
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(int keySizeInBits);
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(RSAParameters parameters);
    public int GetMaxOutputSize();
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public Byte[] Encrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Encrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    public Byte[] Decrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Decrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    private static NotImplementedException DerivedClassMustOverride();
    [ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
[EditorBrowsableAttribute("1")]
public virtual Byte[] DecryptValue(Byte[] rgb);
    [ObsoleteAttribute("RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.")]
[EditorBrowsableAttribute("1")]
public virtual Byte[] EncryptValue(Byte[] rgb);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] ExportRSAPrivateKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportRSAPublicKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8PrivateKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs1PublicKey();
    private AsnWriter WritePkcs1PrivateKey();
    [NullableContextAttribute("0")]
public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public string ExportRSAPrivateKeyPem();
    public string ExportRSAPublicKeyPem();
    [NullableContextAttribute("0")]
public bool TryExportRSAPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public bool TryExportRSAPublicKeyPem(Span`1<char> destination, Int32& charsWritten);
    private static void ClearPrivateParameters(RSAParameters& rsaParameters);
    private Byte[] TryWithKeyBuffer(ReadOnlySpan`1<byte> input, TState state, TryFunc`1<TState> callback, bool tryKeySizeFirst);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    [CompilerGeneratedAttribute]
internal static bool <Encrypt>g__TryWithEncrypt|15_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <Decrypt>g__TryWithDecrypt|17_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <SignData>g__TryWithSignData|29_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, ValueTuple`2<HashAlgorithmName, RSASignaturePadding> state, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <SignHash>g__TryWithSignHash|31_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, ValueTuple`2<HashAlgorithmName, RSASignaturePadding> state, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__54_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportRSAPrivateKeyPem>g__Export|59_0(RSA alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportRSAPublicKeyPem>g__Export|60_0(RSA alg, Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSACng : RSA {
    public CngKey Key { get; }
    [SupportedOSPlatformAttribute("windows")]
public RSACng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public RSACng(CngKey key);
    public CngKey get_Key();
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    private RSA _impl;
    private bool _publicOnly;
    [CompilerGeneratedAttribute]
private bool <PersistKeyInCsp>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseMachineKeyStore>k__BackingField;
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public RSACryptoServiceProvider(int dwKeySize);
    [SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    [SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(CspParameters parameters);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void FromXmlString(string xmlString);
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(RSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    [CompilerGeneratedAttribute]
public bool get_PersistKeyInCsp();
    [CompilerGeneratedAttribute]
public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public virtual string ToXmlString(bool includePrivateParameters);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    [CompilerGeneratedAttribute]
public static bool get_UseMachineKeyStore();
    [CompilerGeneratedAttribute]
public static void set_UseMachineKeyStore(bool value);
    private static CryptographicException PaddingModeNotSupported();
    private static bool IsPublic(Byte[] keyBlob);
    private static void CheckSHA3HashAlgorithm(HashAlgorithmName hashAlgorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <Pkcs1>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA1>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA256>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA384>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA512>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA3_256>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA3_384>k__BackingField;
    [CompilerGeneratedAttribute]
private static RSAEncryptionPadding <OaepSHA3_512>k__BackingField;
    private RSAEncryptionPaddingMode _mode;
    private HashAlgorithmName _oaepHashAlgorithm;
    public static RSAEncryptionPadding Pkcs1 { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public static RSAEncryptionPadding OaepSHA3_256 { get; }
    public static RSAEncryptionPadding OaepSHA3_384 { get; }
    public static RSAEncryptionPadding OaepSHA3_512 { get; }
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    private RSAEncryptionPadding(RSAEncryptionPaddingMode mode, HashAlgorithmName oaepHashAlgorithm);
    private static RSAEncryptionPadding();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_Pkcs1();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA1();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA256();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA384();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA512();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA3_256();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA3_384();
    [CompilerGeneratedAttribute]
public static RSAEncryptionPadding get_OaepSHA3_512();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public virtual int GetHashCode();
    private static int CombineHashCodes(int h1, int h2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSAEncryptionPadding other);
    [NullableContextAttribute("2")]
public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Pkcs1;
    public static RSAEncryptionPaddingMode Oaep;
}
internal static class System.Security.Cryptography.RSAImplementation : object {
}
internal static class System.Security.Cryptography.RSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static RSAKeyFormatHelper();
    internal static void FromPkcs1PrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static void ReadRsaPublicKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ReadOnlySpan`1<byte> pkcs1PublicKey);
    internal static AsnWriter WritePkcs8PrivateKey(ReadOnlySpan`1<byte> pkcs1PrivateKey, AsnWriter copyFrom);
    private static void WriteAlgorithmIdentifier(AsnWriter writer);
    internal static AsnWriter WritePkcs1PublicKey(RSAParameters& rsaParameters);
    internal static AsnWriter WritePkcs1PrivateKey(RSAParameters& rsaParameters);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, RSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, RSAParameters& key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    [NullableAttribute("2")]
public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    [NullableContextAttribute("2")]
public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private Byte[] ParameterValue;
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    [NullableContextAttribute("1")]
public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOpenSsl : RSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(RSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
}
internal static class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static ReadOnlySpan`1<byte> DigestInfoMD5 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha1 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha256 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha384 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha512 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha3_256 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha3_384 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha3_512 { get; }
    private static ReadOnlySpan`1<byte> EightZeros { get; }
    private static ReadOnlySpan`1<byte> get_DigestInfoMD5();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha1();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha256();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha384();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha512();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha3_256();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha3_384();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha3_512();
    private static ReadOnlySpan`1<byte> get_EightZeros();
    private static ReadOnlySpan`1<byte> GetDigestInfoForAlgorithm(HashAlgorithmName hashAlgorithmName, Int32& digestLengthInBytes);
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    internal static int HashLength(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Signature(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal static void EncodePss(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> mHash, Span`1<byte> destination, int keySize);
    internal static bool VerifyPss(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> mHash, ReadOnlySpan`1<byte> em, int keySize);
    private static void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public RandomNumberGenerator RNG { get; public set; }
    public string Parameters { get; public set; }
    [NullableContextAttribute("1")]
public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    [NullableContextAttribute("1")]
public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public string Parameters { get; }
    [NullableAttribute("2")]
public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public RandomNumberGenerator get_Rng();
    [NullableContextAttribute("2")]
public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSASignaturePadding : object {
    private static RSASignaturePadding s_pkcs1;
    private static RSASignaturePadding s_pss;
    private RSASignaturePaddingMode _mode;
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode Mode { get; }
    private RSASignaturePadding(RSASignaturePaddingMode mode);
    private static RSASignaturePadding();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    public RSASignaturePaddingMode get_Mode();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSASignaturePadding other);
    [NullableContextAttribute("2")]
public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
internal class System.Security.Cryptography.SafeBignumHandle : SafeJObjectHandle {
}
internal class System.Security.Cryptography.SafeDsaHandle : SafeKeyHandle {
    internal SafeDsaHandle(IntPtr ptr);
    protected virtual bool ReleaseHandle();
    internal static SafeDsaHandle DuplicateHandle(IntPtr handle);
    [PreserveBaseOverridesAttribute]
internal virtual override SafeDsaHandle DuplicateHandle();
}
internal class System.Security.Cryptography.SafeEcKeyHandle : SafeKeyHandle {
    internal SafeEcKeyHandle(IntPtr ptr);
    protected virtual bool ReleaseHandle();
    internal static SafeEcKeyHandle DuplicateHandle(IntPtr handle);
    [PreserveBaseOverridesAttribute]
internal virtual override SafeEcKeyHandle DuplicateHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.SafeEvpPKeyHandle : SafeHandle {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static long OpenSslVersion { get; }
    public bool IsInvalid { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle);
    public static long get_OpenSslVersion();
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static SafeEvpPKeyHandle OpenPrivateKeyFromEngine(string engineName, string keyId);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static SafeEvpPKeyHandle OpenPublicKeyFromEngine(string engineName, string keyId);
    public SafeEvpPKeyHandle DuplicateHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Security.Cryptography.SafeKeyHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    internal abstract virtual SafeKeyHandle DuplicateHandle();
}
internal class System.Security.Cryptography.SafeRsaHandle : SafeKeyHandle {
    public SafeRsaHandle(IntPtr ptr);
    protected virtual bool ReleaseHandle();
    [PreserveBaseOverridesAttribute]
internal virtual override SafeRsaHandle DuplicateHandle();
    internal static SafeRsaHandle DuplicateHandle(IntPtr handle);
}
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA1 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA1 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA256 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA256 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA3_256 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static SHA3_256();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_256 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    private static void CheckSha3Support();
}
public abstract class System.Security.Cryptography.SHA3_384 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static SHA3_384();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_384 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    private static void CheckSha3Support();
}
public abstract class System.Security.Cryptography.SHA3_512 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static SHA3_512();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public static SHA3_512 Create();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    private static void CheckSha3Support();
}
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA384 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA384 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA512 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA512 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.Shake128 : object {
    private LiteXof _hashProvider;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static Shake128();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    public void AppendData(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset(int outputLength);
    public void GetHashAndReset(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash(int outputLength);
    public void GetCurrentHash(Span`1<byte> destination);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source, int outputLength);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source, int outputLength);
    public static void HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source, int outputLength);
    public static void HashData(Stream source, Span`1<byte> destination);
    public static ValueTask HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, int outputLength, CancellationToken cancellationToken);
    private static void HashDataCore(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    private static void CheckPlatformSupport();
    private void CheckDisposed();
}
public class System.Security.Cryptography.Shake256 : object {
    private LiteXof _hashProvider;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    public static bool IsSupported { get; }
    private static Shake256();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    public void AppendData(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset(int outputLength);
    public void GetHashAndReset(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash(int outputLength);
    public void GetCurrentHash(Span`1<byte> destination);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source, int outputLength);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source, int outputLength);
    public static void HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source, int outputLength);
    public static void HashData(Stream source, Span`1<byte> destination);
    public static ValueTask HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, int outputLength, CancellationToken cancellationToken);
    private static void HashDataCore(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    private static void CheckPlatformSupport();
    private void CheckDisposed();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.SignatureDescription : object {
    [CompilerGeneratedAttribute]
private string <KeyAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatterAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeformatterAlgorithm>k__BackingField;
    public string KeyAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string DeformatterAlgorithm { get; public set; }
    [NullableContextAttribute("1")]
public SignatureDescription(SecurityElement el);
    [CompilerGeneratedAttribute]
public string get_KeyAlgorithm();
    [CompilerGeneratedAttribute]
public void set_KeyAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_FormatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_FormatterAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DeformatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DeformatterAlgorithm(string value);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateDeformatter is not trim compatible because the algorithm implementation referenced by DeformatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateFormatter is not trim compatible because the algorithm implementation referenced by FormatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
    [RequiresUnreferencedCodeAttribute("CreateDigest is not trim compatible because the algorithm implementation referenced by DigestAlgorithm might be removed.")]
public virtual HashAlgorithm CreateDigest();
}
public class System.Security.Cryptography.SP800108HmacCounterKdf : object {
    private SP800108HmacCounterKdfImplementationBase _implementation;
    public SP800108HmacCounterKdf(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public SP800108HmacCounterKdf(Byte[] key, HashAlgorithmName hashAlgorithm);
    private static SP800108HmacCounterKdfImplementationBase CreateImplementation(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public static Byte[] DeriveBytes(Byte[] key, HashAlgorithmName hashAlgorithm, Byte[] label, Byte[] context, int derivedKeyLengthInBytes);
    [NullableContextAttribute("1")]
public static Byte[] DeriveBytes(Byte[] key, HashAlgorithmName hashAlgorithm, string label, string context, int derivedKeyLengthInBytes);
    public static Byte[] DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, int derivedKeyLengthInBytes);
    public static void DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    public static Byte[] DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, int derivedKeyLengthInBytes);
    public static void DeriveBytes(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] DeriveKey(Byte[] label, Byte[] context, int derivedKeyLengthInBytes);
    public Byte[] DeriveKey(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, int derivedKeyLengthInBytes);
    public void DeriveKey(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    public Byte[] DeriveKey(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, int derivedKeyLengthInBytes);
    public void DeriveKey(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] DeriveKey(string label, string context, int derivedKeyLengthInBytes);
    public sealed virtual void Dispose();
    private static void CheckHashAlgorithm(HashAlgorithmName hashAlgorithm);
    private static Byte[] DeriveBytesCore(Byte[] key, HashAlgorithmName hashAlgorithm, Byte[] label, Byte[] context, int derivedKeyLengthInBytes);
    private static void DeriveBytesCore(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    private static void DeriveBytesCore(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    private void DeriveKeyCore(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    private void DeriveKeyCore(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    private static void CheckPrfOutputLength(int length, string paramName);
}
internal abstract class System.Security.Cryptography.SP800108HmacCounterKdfImplementationBase : object {
    internal abstract virtual void DeriveBytes(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    internal abstract virtual void DeriveBytes(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    public abstract virtual void Dispose();
}
internal class System.Security.Cryptography.SP800108HmacCounterKdfImplementationManaged : SP800108HmacCounterKdfImplementationBase {
    private Byte[] _key;
    private int _keyReferenceCount;
    private int _disposed;
    private HashAlgorithmName _hashAlgorithm;
    public SP800108HmacCounterKdfImplementationManaged(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm);
    internal virtual void DeriveBytes(ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    internal virtual void DeriveBytes(ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
    public virtual void Dispose();
    private Byte[] IncrementAndAcquireKey();
    public void ReleaseKey();
    private void ZeroKey();
    internal static void DeriveBytesOneShot(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> label, ReadOnlySpan`1<byte> context, Span`1<byte> destination);
    internal static void DeriveBytesOneShot(ReadOnlySpan`1<byte> key, HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<char> label, ReadOnlySpan`1<char> context, Span`1<byte> destination);
}
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    [NullableAttribute("2")]
protected Byte[] KeyValue;
    [NullableAttribute("2")]
protected Byte[] IVValue;
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    protected int KeySizeValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalBlockSizesValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    [NullableAttribute("1")]
public Byte[] IV { get; public set; }
    [NullableAttribute("1")]
public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalBlockSizes { get; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static SymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SymmetricAlgorithm Create(string algName);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_IV();
    [NullableContextAttribute("1")]
public virtual void set_IV(Byte[] value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_Key();
    [NullableContextAttribute("1")]
public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalBlockSizes();
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateDecryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateEncryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GenerateIV();
    public abstract virtual void GenerateKey();
    public bool ValidKeySize(int bitLength);
    public int GetCiphertextLengthEcb(int plaintextLength, PaddingMode paddingMode);
    public int GetCiphertextLengthCbc(int plaintextLength, PaddingMode paddingMode);
    private int GetCiphertextLengthBlockAligned(int plaintextLength, PaddingMode paddingMode);
    public int GetCiphertextLengthCfb(int plaintextLength, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] DecryptEcb(Byte[] ciphertext, PaddingMode paddingMode);
    public Byte[] DecryptEcb(ReadOnlySpan`1<byte> ciphertext, PaddingMode paddingMode);
    public int DecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryDecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public Byte[] EncryptEcb(Byte[] plaintext, PaddingMode paddingMode);
    public Byte[] EncryptEcb(ReadOnlySpan`1<byte> plaintext, PaddingMode paddingMode);
    public int EncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryEncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public Byte[] DecryptCbc(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryDecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] EncryptCbc(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryEncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] DecryptCfb(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    public bool TryDecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] EncryptCfb(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    public bool TryEncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void CheckPaddingMode(PaddingMode paddingMode);
    private void CheckInitializationVectorSize(ReadOnlySpan`1<byte> iv);
    private void CheckFeedbackSize(int feedbackSizeInBits);
}
internal static class System.Security.Cryptography.SymmetricPadding : object {
    public static int GetCiphertextLength(int plaintextLength, int paddingSizeInBytes, PaddingMode paddingMode);
    public static int PadBlock(ReadOnlySpan`1<byte> block, Span`1<byte> destination, int paddingSizeInBytes, PaddingMode paddingMode);
    public static bool DepaddingRequired(PaddingMode padding);
    public static int GetPaddingLength(ReadOnlySpan`1<byte> block, PaddingMode paddingMode, int blockSize);
}
internal static class System.Security.Cryptography.ThrowHelper : object {
    public static void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [DoesNotReturnAttribute]
public static void ThrowArgumentNull(ExceptionArgument argument);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRange(ExceptionArgument argument);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOffLen();
    [DoesNotReturnAttribute]
public static void ThrowBase64FormatException();
}
public class System.Security.Cryptography.ToBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static TripleDES();
    [UnsupportedOSPlatformAttribute("browser")]
public static TripleDES Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static TripleDES Create(string str);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    private static bool EqualBytes(Byte[] rgbKey, int start1, int start2, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    private TripleDES _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateDecryptor();
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.TripleDesImplementation : TripleDES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private UniversalCryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
    private static OpenSslCipherLite CreateLiteCipher(CipherMode cipherMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
    private static IntPtr GetAlgorithm(CipherMode cipherMode, int feedbackSizeInBytes);
}
internal class System.Security.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
}
internal class System.Security.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal static class System.Security.Cryptography.UniversalCryptoOneShot : object {
    public static bool OneShotDecrypt(ILiteSymmetricCipher cipher, PaddingMode paddingMode, ReadOnlySpan`1<byte> input, Span`1<byte> output, Int32& bytesWritten);
    public static bool OneShotEncrypt(ILiteSymmetricCipher cipher, PaddingMode paddingMode, ReadOnlySpan`1<byte> input, Span`1<byte> output, Int32& bytesWritten);
}
internal abstract class System.Security.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    protected int PaddingSizeBytes { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static UniversalCryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    protected int get_PaddingSizeBytes();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.Utf8DataEncoding : ValueType {
    [CompilerGeneratedAttribute]
private static Encoding <ThrowingUtf8Encoding>k__BackingField;
    private Byte[] _rented;
    private Span`1<byte> _buffer;
    internal static Encoding ThrowingUtf8Encoding { get; }
    internal ReadOnlySpan`1<byte> Utf8Bytes { get; }
    internal Utf8DataEncoding(ReadOnlySpan`1<char> data, Span`1<byte> stackBuffer);
    private static Utf8DataEncoding();
    [CompilerGeneratedAttribute]
internal static Encoding get_ThrowingUtf8Encoding();
    internal ReadOnlySpan`1<byte> get_Utf8Bytes();
    internal void Dispose();
}
internal class System.Security.Cryptography.X509Certificates.AndroidCertificatePal : object {
    private SafeX509Handle _cert;
    private SafeKeyHandle _privateKey;
    private CertificateData _certData;
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    internal SafeX509Handle SafeHandle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SubjectPublicKeyInfo { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    internal SafeKeyHandle PrivateKeyHandle { get; }
    internal AndroidCertificatePal(SafeX509Handle handle);
    internal AndroidCertificatePal(SafeX509Handle handle, SafeKeyHandle privateKey);
    public static ICertificatePal FromHandle(IntPtr handle);
    public static ICertificatePal FromOtherCert(X509Certificate cert);
    private static ICertificatePal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, bool readingFromFile, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static bool TryReadX509(ReadOnlySpan`1<byte> rawData, ICertificatePal& handle);
    private static AndroidCertificatePal ReadPkcs12(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, bool ephemeralSpecified);
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual IntPtr get_Handle();
    internal SafeX509Handle get_SafeHandle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual string get_LegacyIssuer();
    public sealed virtual string get_LegacySubject();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    public sealed virtual Byte[] get_PublicKeyValue();
    public Byte[] get_SubjectPublicKeyInfo();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual int get_Version();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual PolicyData GetPolicyData();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    internal void SetPrivateKey(SafeKeyHandle privateKey);
    internal SafeKeyHandle get_PrivateKeyHandle();
    public sealed virtual RSA GetRSAPrivateKey();
    public sealed virtual DSA GetDSAPrivateKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    public sealed virtual ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public sealed virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDiffieHellman privateKey);
    public sealed virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private void EnsureCertificateData();
    private AndroidCertificatePal CopyWithPrivateKeyHandle(SafeKeyHandle privateKey);
}
internal class System.Security.Cryptography.X509Certificates.AndroidPkcs12Reader : UnixPkcs12Reader {
    internal AndroidPkcs12Reader(ReadOnlySpan`1<byte> data);
    public static bool IsPkcs12(ReadOnlySpan`1<byte> data);
    protected virtual ICertificatePalCore ReadX509Der(ReadOnlyMemory`1<byte> data);
    protected virtual AsymmetricAlgorithm LoadKey(ReadOnlyMemory`1<byte> pkcs8);
    internal static SafeKeyHandle GetPrivateKey(AsymmetricAlgorithm key);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.AccessDescriptionAsn : ValueType {
    internal string AccessMethod;
    internal GeneralNameAsn AccessLocation;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.BasicConstraintsAsn : ValueType {
    internal bool CA;
    internal Nullable`1<int> PathLengthConstraint;
    private static ReadOnlySpan`1<byte> DefaultCA { get; }
    private static ReadOnlySpan`1<byte> get_DefaultCA();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static BasicConstraintsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static BasicConstraintsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, BasicConstraintsAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificateAsn : ValueType {
    internal TbsCertificateAsn TbsCertificate;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CertificateAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertificateAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertificateAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificateAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificateAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificatePolicyMappingAsn : ValueType {
    internal string IssuerDomainPolicy;
    internal string SubjectDomainPolicy;
    internal static void Decode(AsnValueReader& reader, CertificatePolicyMappingAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, CertificatePolicyMappingAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, CertificatePolicyMappingAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificateTemplateAsn : ValueType {
    internal string TemplateID;
    internal int TemplateMajorVersion;
    internal Nullable`1<int> TemplateMinorVersion;
    internal static CertificateTemplateAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertificateTemplateAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, CertificateTemplateAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestAsn : ValueType {
    internal CertificationRequestInfoAsn CertificationRequestInfo;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestInfoAsn : ValueType {
    internal BigInteger Version;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
}
[FlagsAttribute]
internal enum System.Security.Cryptography.X509Certificates.Asn1.KeyUsageFlagsAsn : Enum {
    public int value__;
    public static KeyUsageFlagsAsn None;
    public static KeyUsageFlagsAsn DigitalSignature;
    public static KeyUsageFlagsAsn NonRepudiation;
    public static KeyUsageFlagsAsn KeyEncipherment;
    public static KeyUsageFlagsAsn DataEncipherment;
    public static KeyUsageFlagsAsn KeyAgreement;
    public static KeyUsageFlagsAsn KeyCertSign;
    public static KeyUsageFlagsAsn CrlSign;
    public static KeyUsageFlagsAsn EncipherOnly;
    public static KeyUsageFlagsAsn DecipherOnly;
}
internal class System.Security.Cryptography.X509Certificates.Asn1.PolicyConstraintsAsn : ValueType {
    internal Nullable`1<int> RequireExplicitPolicyDepth;
    internal Nullable`1<int> InhibitMappingDepth;
    internal static PolicyConstraintsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PolicyConstraintsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, PolicyConstraintsAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.PolicyInformationAsn : ValueType {
    internal string PolicyIdentifier;
    internal Nullable`1<ReadOnlyMemory`1<byte>> PolicyQualifiers;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PolicyInformationAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyInformationAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PolicyInformationAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TbsCertificateAsn : ValueType {
    internal int Version;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> Issuer;
    internal ValidityAsn Validity;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IssuerUniqueId;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectUniqueId;
    internal X509ExtensionAsn[] Extensions;
    private static ReadOnlySpan`1<byte> DefaultVersion { get; }
    private static ReadOnlySpan`1<byte> get_DefaultVersion();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
    public void ValidateVersion();
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TimeAsn : ValueType {
    internal Nullable`1<DateTimeOffset> UtcTime;
    internal Nullable`1<DateTimeOffset> GeneralTime;
    public TimeAsn(DateTimeOffset dateTimeOffset);
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, TimeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, TimeAsn& decoded);
    public DateTimeOffset GetValue();
}
internal class System.Security.Cryptography.X509Certificates.Asn1.ValidityAsn : ValueType {
    internal TimeAsn NotBefore;
    internal TimeAsn NotAfter;
    public ValidityAsn(DateTimeOffset notBefore, DateTimeOffset notAfter);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ValidityAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ValidityAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ValidityAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.CertificateData : ValueType {
    private CertificateAsn certificate;
    internal Byte[] RawData;
    internal Byte[] SubjectPublicKeyInfo;
    internal X500DistinguishedName Issuer;
    internal X500DistinguishedName Subject;
    internal List`1<X509Extension> Extensions;
    internal string IssuerName;
    internal string SubjectName;
    internal int Version { get; }
    internal Byte[] SerialNumber { get; }
    internal DateTime NotBefore { get; }
    internal DateTime NotAfter { get; }
    internal AlgorithmIdentifier PublicKeyAlgorithm { get; }
    internal Byte[] PublicKey { get; }
    internal AlgorithmIdentifier SignatureAlgorithm { get; }
    internal CertificateData(Byte[] rawData);
    internal int get_Version();
    internal Byte[] get_SerialNumber();
    internal DateTime get_NotBefore();
    internal DateTime get_NotAfter();
    internal AlgorithmIdentifier get_PublicKeyAlgorithm();
    internal Byte[] get_PublicKey();
    internal AlgorithmIdentifier get_SignatureAlgorithm();
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    private static string GetSimpleNameInfo(X500DistinguishedName name);
    private static string FindAltNameMatch(Byte[] extensionBytes, GeneralNameType matchType, string otherOid);
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.CertificateData/<ReadReverseRdns>d__33")]
private static IEnumerable`1<KeyValuePair`2<string, string>> ReadReverseRdns(X500DistinguishedName name);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.X509Certificates.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal static class System.Security.Cryptography.X509Certificates.CertificatePal : object {
    internal static ICertificatePal FromHandle(IntPtr handle);
    internal static ICertificatePal FromOtherCert(X509Certificate copyFrom);
    internal static ICertificatePal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static ICertificatePal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
}
internal class System.Security.Cryptography.X509Certificates.CertificatePolicy : object {
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredCertificatePolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredApplicationPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitAnyDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CertificatePolicyMappingAsn> <PolicyMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitMappingDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RequireExplicitPolicyDepth>k__BackingField;
    public bool ImplicitAnyCertificatePolicy { get; public set; }
    public bool SpecifiedAnyCertificatePolicy { get; public set; }
    public ISet`1<string> DeclaredCertificatePolicies { get; public set; }
    public bool ImplicitAnyApplicationPolicy { get; public set; }
    public bool SpecifiedAnyApplicationPolicy { get; public set; }
    public ISet`1<string> DeclaredApplicationPolicies { get; public set; }
    public Nullable`1<int> InhibitAnyDepth { get; public set; }
    public List`1<CertificatePolicyMappingAsn> PolicyMapping { get; public set; }
    public Nullable`1<int> InhibitMappingDepth { get; public set; }
    public Nullable`1<int> RequireExplicitPolicyDepth { get; public set; }
    public bool AllowsAnyCertificatePolicy { get; }
    public bool AllowsAnyApplicationPolicy { get; }
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredCertificatePolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredCertificatePolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredApplicationPolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredApplicationPolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitAnyDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitAnyDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<CertificatePolicyMappingAsn> get_PolicyMapping();
    [CompilerGeneratedAttribute]
public void set_PolicyMapping(List`1<CertificatePolicyMappingAsn> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitMappingDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitMappingDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RequireExplicitPolicyDepth();
    [CompilerGeneratedAttribute]
public void set_RequireExplicitPolicyDepth(Nullable`1<int> value);
    public bool get_AllowsAnyCertificatePolicy();
    public bool get_AllowsAnyApplicationPolicy();
}
internal class System.Security.Cryptography.X509Certificates.CertificatePolicyChain : object {
    private CertificatePolicy[] _policies;
    private bool _failAllCertificatePolicies;
    public CertificatePolicyChain(List`1<X509Certificate2> chain);
    internal bool MatchesCertificatePolicies(OidCollection policyOids);
    internal bool MatchesCertificatePolicies(Oid policyOid);
    internal bool MatchesApplicationPolicies(OidCollection policyOids);
    internal bool MatchesApplicationPolicies(Oid policyOid);
    private void ReadPolicies(List`1<X509Certificate2> chain);
    private static void ApplyRestriction(Int32& restriction, Nullable`1<int> policyRestriction);
    private static CertificatePolicy ReadPolicy(X509Certificate2 cert);
    private static bool CheckExplicitAnyPolicy(ISet`1<string> declaredPolicies);
    private static int ReadInhibitAnyPolicyExtension(Byte[] rawData);
    private static void ReadCertPolicyConstraintsExtension(Byte[] rawData, CertificatePolicy policy);
    private static HashSet`1<string> ReadExtendedKeyUsageExtension(Byte[] rawData);
    internal static HashSet`1<string> ReadCertPolicyExtension(Byte[] rawData);
    private static List`1<CertificatePolicyMappingAsn> ReadCertPolicyMappingsExtension(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    private AsymmetricAlgorithm _key;
    private X509SignatureGenerator _generator;
    private RSASignaturePadding _rsaPadding;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X509Extension> <CertificateExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AsnEncodedData> <OtherRequestAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public X500DistinguishedName SubjectName { get; }
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public Collection`1<AsnEncodedData> OtherRequestAttributes { get; }
    public PublicKey PublicKey { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_SubjectName();
    [CompilerGeneratedAttribute]
public Collection`1<X509Extension> get_CertificateExtensions();
    [CompilerGeneratedAttribute]
public Collection`1<AsnEncodedData> get_OtherRequestAttributes();
    [CompilerGeneratedAttribute]
public PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
    public string CreateSigningRequestPem();
    public string CreateSigningRequestPem(X509SignatureGenerator signatureGenerator);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    private static ArraySegment`1<byte> NormalizeSerialNumber(ReadOnlySpan`1<byte> serialNumber);
    public static CertificateRequest LoadSigningRequestPem(string pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequestPem(ReadOnlySpan`1<char> pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    public static CertificateRequest LoadSigningRequest(Byte[] pkcs10, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequest(ReadOnlySpan`1<byte> pkcs10, HashAlgorithmName signerHashAlgorithm, Int32& bytesConsumed, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    private static CertificateRequest LoadSigningRequest(ReadOnlySpan`1<byte> pkcs10, bool permitTrailingData, HashAlgorithmName signerHashAlgorithm, Int32& bytesConsumed, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    private static bool VerifyX509Signature(ReadOnlySpan`1<byte> toBeSigned, ReadOnlySpan`1<byte> signature, PublicKey publicKey, AlgorithmIdentifierAsn algorithmIdentifier);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.CertificateRequestLoadOptions : Enum {
    public int value__;
    public static CertificateRequestLoadOptions Default;
    public static CertificateRequestLoadOptions SkipSignatureValidation;
    public static CertificateRequestLoadOptions UnsafeLoadCertificateExtensions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.CertificateRevocationListBuilder : object {
    private List`1<RevokedCertificate> _revoked;
    private AsnWriter _writer;
    private CertificateRevocationListBuilder(List`1<RevokedCertificate> revoked);
    public void AddEntry(X509Certificate2 certificate, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public void AddEntry(Byte[] serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    [NullableContextAttribute("0")]
public void AddEntry(ReadOnlySpan`1<byte> serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public bool RemoveEntry(Byte[] serialNumber);
    [NullableContextAttribute("0")]
public bool RemoveEntry(ReadOnlySpan`1<byte> serialNumber);
    private static DateTimeOffset ReadX509Time(AsnValueReader& reader);
    private static Nullable`1<DateTimeOffset> ReadX509TimeOpt(AsnValueReader& reader);
    private static void WriteX509Time(AsnWriter writer, DateTimeOffset time);
    public Byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding, Nullable`1<DateTimeOffset> thisUpdate);
    private Byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, DateTimeOffset thisUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding);
    public Byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier, Nullable`1<DateTimeOffset> thisUpdate);
    private Byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, DateTimeOffset thisUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier);
    public static X509Extension BuildCrlDistributionPointExtension(IEnumerable`1<string> uris, bool critical);
    public static CertificateRevocationListBuilder Load(Byte[] currentCrl, BigInteger& currentCrlNumber);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder Load(ReadOnlySpan`1<byte> currentCrl, BigInteger& currentCrlNumber, Int32& bytesConsumed);
    public static CertificateRevocationListBuilder LoadPem(string currentCrl, BigInteger& currentCrlNumber);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder LoadPem(ReadOnlySpan`1<char> currentCrl, BigInteger& currentCrlNumber);
}
internal class System.Security.Cryptography.X509Certificates.ChainPal : object {
    internal static IChainPal FromHandle(IntPtr chainContext);
    internal static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    internal static IChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, X509Certificate2Collection customTrustStore, X509ChainTrustMode trustMode, DateTime verificationTime, TimeSpan timeout, bool disableAia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
}
internal class System.Security.Cryptography.X509Certificates.ECDsaX509SignatureGenerator : X509SignatureGenerator {
    private ECDsa _key;
    internal ECDsaX509SignatureGenerator(ECDsa key);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.FindPal : object {
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private static FindPal();
    private static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
}
internal enum System.Security.Cryptography.X509Certificates.GeneralNameType : Enum {
    public int value__;
    public static GeneralNameType OtherName;
    public static GeneralNameType Rfc822Name;
    public static GeneralNameType Email;
    public static GeneralNameType DnsName;
    public static GeneralNameType X400Address;
    public static GeneralNameType DirectoryName;
    public static GeneralNameType EdiPartyName;
    public static GeneralNameType UniformResourceIdentifier;
    public static GeneralNameType IPAddress;
    public static GeneralNameType RegisteredId;
}
internal interface System.Security.Cryptography.X509Certificates.ICertificatePal {
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual DSA GetDSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public abstract virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDiffieHellman privateKey);
    public abstract virtual PolicyData GetPolicyData();
}
internal interface System.Security.Cryptography.X509Certificates.ICertificatePalCore {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual string get_LegacyIssuer();
    public abstract virtual string get_LegacySubject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface System.Security.Cryptography.X509Certificates.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface System.Security.Cryptography.X509Certificates.IExportPal {
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface System.Security.Cryptography.X509Certificates.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface System.Security.Cryptography.X509Certificates.ILoaderPal {
    public abstract virtual void MoveTo(X509Certificate2Collection collection);
}
internal interface System.Security.Cryptography.X509Certificates.IStorePal {
    public SafeHandle SafeHandle { get; }
    public abstract virtual void CloneTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
    public abstract virtual SafeHandle get_SafeHandle();
}
internal interface System.Security.Cryptography.X509Certificates.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual ECDsa DecodeECDsaPublicKey(ICertificatePal certificatePal);
    public abstract virtual ECDiffieHellman DecodeECDiffieHellmanPublicKey(ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
internal abstract class System.Security.Cryptography.X509Certificates.ManagedCertificateFinder : object {
    private X509Certificate2Collection _findFrom;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    internal ManagedCertificateFinder(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbprint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    private static DateTime NormalizeDateTime(DateTime dateTime);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    protected abstract virtual Byte[] GetSubjectPublicKeyInfo(X509Certificate2 cert);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static X509Extension FindExtension(X509Certificate2 cert, string extensionOid);
    protected abstract virtual X509Certificate2 CloneCertificate(X509Certificate2 cert);
    private void FindCore(TState state, Func`3<TState, X509Certificate2, bool> predicate);
    private static bool IsCertValid(X509Certificate2 cert);
    [CompilerGeneratedAttribute]
internal static bool <FindByThumbprint>g__FindPredicate|5_0(Byte[] thumbprint, X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
private bool <FindBySubjectKeyIdentifier>b__21_0(Byte[] keyIdentifier, X509Certificate2 cert);
}
internal class System.Security.Cryptography.X509Certificates.ManagedX509ExtensionProcessor : object {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    public virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    internal static Byte[] DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded);
    public virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    private static byte ReverseBitOrder(byte b);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
internal class System.Security.Cryptography.X509Certificates.Pkcs10CertificationRequestInfo : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X501Attribute> <Attributes>k__BackingField;
    internal X500DistinguishedName Subject { get; internal set; }
    internal PublicKey PublicKey { get; internal set; }
    internal Collection`1<X501Attribute> Attributes { get; }
    internal Pkcs10CertificationRequestInfo(X500DistinguishedName subject, PublicKey publicKey, IEnumerable`1<X501Attribute> attributes);
    [CompilerGeneratedAttribute]
internal X500DistinguishedName get_Subject();
    [CompilerGeneratedAttribute]
internal void set_Subject(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
internal PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
internal void set_PublicKey(PublicKey value);
    [CompilerGeneratedAttribute]
internal Collection`1<X501Attribute> get_Attributes();
    internal Byte[] ToPkcs10Request(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.Pkcs9ExtensionRequest : X501Attribute {
    internal Pkcs9ExtensionRequest(IEnumerable`1<X509Extension> extensions);
    private static Byte[] EncodeAttribute(IEnumerable`1<X509Extension> extensions);
}
internal class System.Security.Cryptography.X509Certificates.PolicyData : ValueType {
    internal Byte[] ApplicationCertPolicies;
    internal Byte[] CertPolicies;
    internal Byte[] CertPolicyMappings;
    internal Byte[] CertPolicyConstraints;
    internal Byte[] EnhancedKeyUsage;
    internal Byte[] InhibitAnyPolicyExtension;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    private Oid _oid;
    private AsymmetricAlgorithm _key;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    [ObsoleteAttribute("PublicKey.Key is obsolete. Use the appropriate method to get the public key, such as GetRSAPublicKey.")]
public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    public PublicKey(AsymmetricAlgorithm key);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
    [NullableContextAttribute("0")]
public bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] ExportSubjectPublicKeyInfo();
    [NullableContextAttribute("0")]
public static PublicKey CreateFromSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public RSA GetRSAPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSA GetDSAPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDsa GetECDsaPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    private AsnWriter EncodeSubjectPublicKeyInfo();
    private static int DecodeSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Oid& oid, AsnEncodedData& parameters, AsnEncodedData& keyValue);
    internal static PublicKey DecodeSubjectPublicKeyInfo(SubjectPublicKeyInfoAsn& spki);
    private static void DecodeSubjectPublicKeyInfo(SubjectPublicKeyInfoAsn& spki, Oid& oid, AsnEncodedData& parameters, AsnEncodedData& keyValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
}
internal class System.Security.Cryptography.X509Certificates.RSAPkcs1X509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    internal RSAPkcs1X509SignatureGenerator(RSA key);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
    internal static PublicKey BuildPublicKey(RSA rsa);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.RSAPssX509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    private RSASignaturePadding _padding;
    internal RSAPssX509SignatureGenerator(RSA key, RSASignaturePadding padding);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.SafeX509ChainContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class System.Security.Cryptography.X509Certificates.SafeX509Handle : SafeJObjectHandle {
    internal SafeX509Handle(IntPtr ptr);
}
internal class System.Security.Cryptography.X509Certificates.SafeX509StoreHandle : SafeJObjectHandle {
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
internal class System.Security.Cryptography.X509Certificates.StorePal : object {
    internal static IStorePal FromHandle(IntPtr storeHandle);
    internal static ILoaderPal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static ILoaderPal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static IExportPal FromCertificate(ICertificatePalCore cert);
    internal static IExportPal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    internal static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    private static AndroidCertLoader FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, bool readingFromFile, X509KeyStorageFlags keyStorageFlags);
    private static ICertificatePal[] ReadPkcs12Collection(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, bool ephemeralSpecified);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    private static IdnMapping s_idnMapping;
    private List`1<Byte[]> _encodedNames;
    private static SubjectAlternativeNameBuilder();
    public void AddEmailAddress(string emailAddress);
    public void AddDnsName(string dnsName);
    public void AddUri(Uri uri);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
    private void AddGeneralName(GeneralNameAsn generalName);
}
internal static class System.Security.Cryptography.X509Certificates.UnixChainVerifier : object {
    public static bool Verify(X509ChainElement[] chainElements, X509VerificationFlags flags);
    private static bool HasUnsuppressedError(X509VerificationFlags flags, X509ChainElement element, bool isEndEntity);
    private static bool IsSelfSigned(X509Certificate2 cert);
    private static Nullable`1<X509VerificationFlags> GetSuppressionFlag(X509ChainStatusFlags status);
}
internal abstract class System.Security.Cryptography.X509Certificates.UnixExportProvider : object {
    private static Asn1Tag s_contextSpecific0;
    internal static PbeParameters s_windowsPbe;
    protected ICertificatePalCore _singleCertPal;
    protected X509Certificate2Collection _certs;
    internal UnixExportProvider(ICertificatePalCore singleCertPal);
    internal UnixExportProvider(X509Certificate2Collection certs);
    private static UnixExportProvider();
    public sealed virtual void Dispose();
    protected abstract virtual Byte[] ExportPkcs7();
    protected abstract virtual Byte[] ExportPkcs8(ICertificatePalCore certificatePal, ReadOnlySpan`1<char> password);
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private Byte[] ExportX509Der();
    private Byte[] ExportPfx(SafePasswordHandle password);
    private void BuildBags(ICertificatePalCore certPal, ReadOnlySpan`1<char> passwordSpan, AsnWriter tmpWriter, CertBagAsn[] certBags, AttributeAsn[] certAttrs, SafeBagAsn[] keyBags, Int32& certIdx, Int32& keyIdx);
    private static ArraySegment`1<byte> EncodeAuthSafe(AsnWriter tmpWriter, SafeBagAsn[] keyBags, int keyCount, CertBagAsn[] certBags, AttributeAsn[] certAttrs, int certIdx, ReadOnlySpan`1<char> passwordSpan);
    private static ArraySegment`1<byte> EncodeKeys(AsnWriter tmpWriter, SafeBagAsn[] keyBags, int keyCount);
    private static ArraySegment`1<byte> EncodeCerts(AsnWriter tmpWriter, CertBagAsn[] certBags, AttributeAsn[] certAttrs, int certCount, Span`1<byte> salt, ReadOnlySpan`1<char> passwordSpan, Span`1<byte> certContentsIv, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    private static ArraySegment`1<byte> EncodeAuthSafe(AsnWriter tmpWriter, ReadOnlyMemory`1<byte> encodedKeyContents, ReadOnlyMemory`1<byte> encodedCertContents, bool isPkcs12, string hmacOid, string encryptionAlgorithmOid, Span`1<byte> salt, Span`1<byte> certContentsIv);
    private static Byte[] MacAndEncode(AsnWriter tmpWriter, ReadOnlyMemory`1<byte> encodedAuthSafe, ReadOnlySpan`1<char> passwordSpan);
}
internal abstract class System.Security.Cryptography.X509Certificates.UnixPkcs12Reader : object {
    private PfxAsn _pfxAsn;
    private ContentInfoAsn[] _safeContentsValues;
    private CertAndKey[] _certs;
    private int _certCount;
    private Memory`1<byte> _tmpMemory;
    private bool _allowDoubleBind;
    protected abstract virtual ICertificatePalCore ReadX509Der(ReadOnlyMemory`1<byte> data);
    protected abstract virtual AsymmetricAlgorithm LoadKey(ReadOnlyMemory`1<byte> safeBagBagValue);
    protected void ParsePkcs12(ReadOnlySpan`1<byte> data);
    internal CertAndKey GetSingleCert();
    internal int GetCertCount();
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.UnixPkcs12Reader/<EnumerateAll>d__13")]
internal IEnumerable`1<CertAndKey> EnumerateAll();
    public sealed virtual void Dispose();
    private static void ReturnRentedContentInfos(ContentInfoAsn[] rentedContents);
    public void Decrypt(SafePasswordHandle password, bool ephemeralSpecified);
    private void VerifyAndDecrypt(ReadOnlySpan`1<char> password, ReadOnlyMemory`1<byte> authSafeContents);
    private void Decrypt(ReadOnlySpan`1<char> password, ReadOnlyMemory`1<byte> authSafeContents);
    private static ContentInfoAsn[] DecodeSafeContents(ReadOnlyMemory`1<byte> authSafeContents);
    private void DecryptAndProcessSafeContents(ReadOnlySpan`1<char> password, CertBagAsn[]& certBags, AttributeAsn[][]& certBagAttrs, Int32& certBagIdx, SafeBagAsn[]& keyBags, Int32& keyBagIdx);
    private void ExtractPrivateKeys(ReadOnlySpan`1<char> password, SafeBagAsn[] keyBags, int keyBagIdx, AsymmetricAlgorithm[] keys, RentedSubjectPublicKeyInfo[] publicKeyInfos);
    private void BuildCertsWithKeys(ReadOnlySpan`1<char> password, CertBagAsn[] certBags, AttributeAsn[][] certBagAttrs, CertAndKey[] certs, int certBagIdx, SafeBagAsn[] keyBags, RentedSubjectPublicKeyInfo[] publicKeyInfos, AsymmetricAlgorithm[] keys, int keyBagIdx);
    private static bool PublicKeyMatches(string algorithm, Byte[] keyParams, Byte[] keyValue, SubjectPublicKeyInfoAsn& publicKeyInfo);
    private static int FindMatchingKey(SafeBagAsn[] keyBags, int keyBagCount, ReadOnlySpan`1<byte> localKeyId);
    private static void DecryptSafeContents(ReadOnlySpan`1<char> password, ContentInfoAsn& safeContentsAsn);
    private static void ProcessSafeContents(ContentInfoAsn& safeContentsAsn, CertBagAsn[]& certBags, AttributeAsn[][]& certBagAttrs, Int32& certBagIdx, SafeBagAsn[]& keyBags, Int32& keyBagIdx);
    private AsymmetricAlgorithm LoadKey(SafeBagAsn safeBag, ReadOnlySpan`1<char> password);
    private static void GrowIfNeeded(T[]& array, int idx);
}
internal class System.Security.Cryptography.X509Certificates.UnsupportedDisallowedStore : object {
    private bool _readOnly;
    [CompilerGeneratedAttribute]
private SafeHandle <System.Security.Cryptography.X509Certificates.IStorePal.SafeHandle>k__BackingField;
    private SafeHandle System.Security.Cryptography.X509Certificates.IStorePal.SafeHandle { get; }
    internal UnsupportedDisallowedStore(OpenFlags openFlags);
    public sealed virtual void Dispose();
    public sealed virtual void CloneTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal cert);
    public sealed virtual void Remove(ICertificatePal cert);
    [CompilerGeneratedAttribute]
private sealed virtual override SafeHandle System.Security.Cryptography.X509Certificates.IStorePal.get_SafeHandle();
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.X509Certificates.X500DirectoryStringHelper : object {
    [ExtensionAttribute]
internal static string ReadAnyAsnString(AsnReader tavReader);
    [ExtensionAttribute]
internal static string ReadAnyAsnString(AsnValueReader& tavReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    private List`1<X500RelativeDistinguishedName> _parsedAttributes;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    [NullableContextAttribute("0")]
public X500DistinguishedName(ReadOnlySpan`1<byte> encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    public IEnumerable`1<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(bool reversed);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X500DistinguishedName/<EnumerateRelativeDistinguishedNames>d__15")]
private static IEnumerable`1<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(List`1<X500RelativeDistinguishedName> parsedAttributes, bool reversed);
    private static List`1<X500RelativeDistinguishedName> ParseAttributes(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedNameBuilder : object {
    private List`1<Byte[]> _encodedComponents;
    private AsnWriter _writer;
    public void Add(string oidValue, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void Add(Oid oid, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void AddEmailAddress(string emailAddress);
    public void AddCommonName(string commonName);
    public void AddLocalityName(string localityName);
    public void AddCountryOrRegion(string twoLetterCode);
    public void AddOrganizationName(string organizationName);
    public void AddOrganizationalUnitName(string organizationalUnitName);
    public void AddStateOrProvinceName(string stateOrProvinceName);
    public void AddDomainComponent(string domainComponent);
    public X500DistinguishedName Build();
    private void EncodeComponent(string oid, ReadOnlySpan`1<char> value, UniversalTagNumber stringEncodingType, string paramName);
    private static UniversalTagNumber GetAndValidateTagNumber(Nullable`1<UniversalTagNumber> stringEncodingType);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
internal static class System.Security.Cryptography.X509Certificates.X500NameEncoder : object {
    private static SearchValues`1<char> s_needsQuotingChars;
    private static X500NameEncoder();
    internal static string X500DistinguishedNameDecode(Byte[] encodedName, bool printOid, X500DistinguishedNameFlags flags, bool addTrailingDelimiter);
    internal static Byte[] X500DistinguishedNameEncode(string stringForm, X500DistinguishedNameFlags flags);
    private static bool NeedsQuoting(ReadOnlySpan`1<char> rdnValue);
    private static bool IsQuotableWhitespace(char c);
    private static void AppendOid(ValueStringBuilder& decodedName, string oidValue);
    private static List`1<Byte[]> ParseDistinguishedName(string stringForm, string dnSeparators, bool noQuotes, bool forceUtf8Encoding);
    private static ReadOnlySpan`1<char> ParseOid(ReadOnlySpan`1<char> str);
    private static Byte[] ParseRdn(ReadOnlySpan`1<char> tagOid, ReadOnlySpan`1<char> chars, bool hadEscapedQuote, bool forceUtf8Encoding);
    private static int ExtractValue(ReadOnlySpan`1<char> chars, Span`1<char> destination);
    private static string X500DistinguishedNameDecode(Byte[] encodedName, bool printOid, bool reverse, bool quoteIfNeeded, string dnSeparator, string multiValueSeparator, bool addTrailingDelimiter);
    private static string ReadAttributeValue(AsnReader tavReader, Boolean& binaryFallback);
    [CompilerGeneratedAttribute]
internal static string <ReadAttributeValue>g__BinaryEncode|17_0(ReadOnlyMemory`1<byte> data);
}
public class System.Security.Cryptography.X509Certificates.X500RelativeDistinguishedName : object {
    private Oid _singleElementType;
    private ReadOnlyMemory`1<byte> _singleElementValue;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <RawData>k__BackingField;
    public ReadOnlyMemory`1<byte> RawData { get; }
    public bool HasMultipleElements { get; }
    internal X500RelativeDistinguishedName(ReadOnlyMemory`1<byte> rawData);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_RawData();
    public bool get_HasMultipleElements();
    [NullableContextAttribute("1")]
public Oid GetSingleElementType();
    [NullableContextAttribute("2")]
public string GetSingleElementValue();
}
internal class System.Security.Cryptography.X509Certificates.X501Attribute : AsnEncodedData {
    internal X501Attribute(string oid, Byte[] rawData);
    internal X501Attribute(Oid oid, Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509AuthorityInformationAccessExtension : X509Extension {
    private AccessDescriptionAsn[] _decoded;
    public X509AuthorityInformationAccessExtension(Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509AuthorityInformationAccessExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public X509AuthorityInformationAccessExtension(IEnumerable`1<string> ocspUris, IEnumerable`1<string> caIssuersUris, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateUris(string accessMethodOid);
    public IEnumerable`1<string> EnumerateUris(Oid accessMethodOid);
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509AuthorityInformationAccessExtension/<EnumerateUrisCore>d__8")]
private IEnumerable`1<string> EnumerateUrisCore(string accessMethodOid);
    public IEnumerable`1<string> EnumerateCAIssuersUris();
    public IEnumerable`1<string> EnumerateOcspUris();
    private static AccessDescriptionAsn[] Decode(Byte[] authorityInfoAccessSyntax);
    private static Byte[] Encode(IEnumerable`1<string> ocspUris, IEnumerable`1<string> caIssuersUris);
    [CompilerGeneratedAttribute]
internal static string <EnumerateUrisCore>g__GetUri|8_0(string accessMethodOid, AccessDescriptionAsn& desc);
    [CompilerGeneratedAttribute]
internal static void <Encode>g__WriteAccessMethod|12_0(AsnWriter writer, string oid, string value);
}
public class System.Security.Cryptography.X509Certificates.X509AuthorityKeyIdentifierExtension : X509Extension {
    private bool _decoded;
    private X500DistinguishedName _simpleIssuer;
    private Nullable`1<ReadOnlyMemory`1<byte>> _keyIdentifier;
    private Nullable`1<ReadOnlyMemory`1<byte>> _rawIssuer;
    private Nullable`1<ReadOnlyMemory`1<byte>> _serialNumber;
    public Nullable`1<ReadOnlyMemory`1<byte>> KeyIdentifier { get; }
    [NullableAttribute("2")]
public X500DistinguishedName NamedIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> RawIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> SerialNumber { get; }
    [NullableContextAttribute("1")]
public X509AuthorityKeyIdentifierExtension(Byte[] rawData, bool critical);
    public X509AuthorityKeyIdentifierExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    [NullableContextAttribute("1")]
public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public Nullable`1<ReadOnlyMemory`1<byte>> get_KeyIdentifier();
    [NullableContextAttribute("2")]
public X500DistinguishedName get_NamedIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_RawIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_SerialNumber();
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(X509SubjectKeyIdentifierExtension subjectKeyIdentifier);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(Byte[] subjectKeyIdentifier);
    public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, Byte[] serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension Create(Byte[] keyIdentifier, X500DistinguishedName issuerName, Byte[] serialNumber);
    public static X509AuthorityKeyIdentifierExtension Create(ReadOnlySpan`1<byte> keyIdentifier, X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromCertificate(X509Certificate2 certificate, bool includeKeyIdentifier, bool includeIssuerAndSerial);
    private void Decode(ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public static X509BasicConstraintsExtension CreateForCertificateAuthority(Nullable`1<int> pathLengthConstraint);
    public static X509BasicConstraintsExtension CreateForEndEntity(bool critical);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    [CompilerGeneratedAttribute]
private ICertificatePalCore <Pal>k__BackingField;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SerialNumberBytes { get; }
    [NullableAttribute("2")]
internal ICertificatePalCore Pal { get; private set; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] data);
    private protected X509Certificate(ReadOnlySpan`1<byte> data);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    private protected X509Certificate(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePalCore pal);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private protected X509Certificate(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(X509Certificate cert);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public X509Certificate(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromCertFile(string filename);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromSignedFile(string filename);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    private static Byte[] GetCertHash(HashAlgorithmName hashAlgorithm, ICertificatePalCore certPal);
    [NullableContextAttribute("0")]
public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    internal static string GetCertHashString(HashAlgorithmName hashAlgorithm, ICertificatePalCore certPal);
    private Byte[] GetRawCertHash();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SerialNumberBytes();
    public virtual string GetSerialNumberString();
    private Byte[] GetRawSerialNumber();
    [ObsoleteAttribute("X509Certificate.GetName has been deprecated. Use the Subject property instead.")]
public virtual string GetName();
    [ObsoleteAttribute("X509Certificate.GetIssuerName has been deprecated. Use the Issuer property instead.")]
public virtual string GetIssuerName();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [CompilerGeneratedAttribute]
internal ICertificatePalCore get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePalCore value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    [MemberNotNullAttribute("Pal")]
internal void ThrowIfInvalid();
    protected static string FormatDate(DateTime date);
    internal static void ValidateKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private static void VerifyContentType(X509ContentType contentType);
    internal static void EnforceIterationCountLimit(ReadOnlySpan`1& pkcs12, bool readingFromFile, bool passwordProvided);
    internal static ulong GetIterationCount(ReadOnlySpan`1<byte> pkcs12, Int32& bytesConsumed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuerName;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPrivateKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    private static String[] s_EcPublicKeyPrivateKeyLabels;
    private static String[] s_RsaPublicKeyPrivateKeyLabels;
    private static String[] s_DsaPublicKeyPrivateKeyLabels;
    internal ICertificatePal Pal { get; }
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("X509Certificate2.PrivateKey is obsolete. Use the appropriate method to get the private key, such as GetRSAPrivateKey, or use the CopyWithPrivateKey method to create a new instance with a private key.")]
public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> RawDataMemory { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(X509Certificate certificate);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected X509Certificate2(SerializationInfo info, StreamingContext context);
    private static X509Certificate2();
    public virtual void Reset();
    internal ICertificatePal get_Pal();
    public bool get_Archived();
    [SupportedOSPlatformAttribute("windows")]
public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    [SupportedOSPlatformAttribute("windows")]
public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    [NullableContextAttribute("2")]
public AsymmetricAlgorithm get_PrivateKey();
    [NullableContextAttribute("2")]
public void set_PrivateKey(AsymmetricAlgorithm value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_RawDataMemory();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(Byte[] rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public bool Verify();
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public X509Certificate2 CopyWithPrivateKey(ECDiffieHellman privateKey);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string keyPemFilePath);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan`1<char> password, string keyPemFilePath);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem, ReadOnlySpan`1<char> password);
    private static bool IsECDsa(X509Certificate2 certificate);
    private static bool IsECDiffieHellman(X509Certificate2 certificate);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem);
    public string ExportCertificatePem();
    [NullableContextAttribute("0")]
public bool TryExportCertificatePem(Span`1<char> destination, Int32& charsWritten);
    public bool MatchesHostname(string hostname, bool allowWildcards, bool allowCommonName);
    private static X509Certificate2 ExtractKeyFromPem(ReadOnlySpan`1<char> keyPem, String[] labels, Func`1<TAlg> factory, Func`2<TAlg, X509Certificate2> import);
    private static X509Certificate2 ExtractKeyFromEncryptedPem(ReadOnlySpan`1<char> keyPem, ReadOnlySpan`1<char> password, Func`1<TAlg> factory, Func`2<TAlg, X509Certificate2> import);
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
    internal static X509Extension CreateCustomExtensionIfAny(string oidValue);
    private static bool HasECDiffieHellmanKeyUsage(X509Certificate2 certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<X509Certificate2> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate2>.GetEnumerator();
    public void Import(Byte[] rawData);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
    public void ImportFromPemFile(string certPemFilePath);
    [NullableContextAttribute("0")]
public void ImportFromPem(ReadOnlySpan`1<char> certPem);
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public string ExportPkcs7Pem();
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public bool TryExportPkcs7Pem(Span`1<char> destination, Int32& charsWritten);
    public string ExportCertificatePems();
    [NullableContextAttribute("0")]
public bool TryExportCertificatePems(Span`1<char> destination, Int32& charsWritten);
    private int GetCertificatePemsSize();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private IEnumerator _enumerator;
    [NullableAttribute("1")]
public X509Certificate2 Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    [NullableContextAttribute("1")]
public sealed virtual X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    protected virtual void OnValidate(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private bool _useMachineContext;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public IntPtr ChainContext { get; }
    [NullableAttribute("2")]
public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    [SupportedOSPlatformAttribute("windows")]
public X509Chain(IntPtr chainContext);
    public static X509Chain Create();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public IntPtr get_ChainContext();
    [NullableContextAttribute("2")]
public SafeX509ChainHandle get_SafeHandle();
    [UnsupportedOSPlatformAttribute("browser")]
public bool Build(X509Certificate2 certificate);
    internal bool Build(X509Certificate2 certificate, bool throwOnException);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<X509ChainElement> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509ChainElement>.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    [NullableAttribute("1")]
public X509ChainElement Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    [NullableContextAttribute("1")]
public sealed virtual X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    private X509ChainTrustMode _trustMode;
    private DateTime _verificationTime;
    internal OidCollection _applicationPolicy;
    internal OidCollection _certificatePolicy;
    internal X509Certificate2Collection _extraStore;
    internal X509Certificate2Collection _customTrustStore;
    [CompilerGeneratedAttribute]
private bool <DisableCertificateDownloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerificationTimeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    public bool DisableCertificateDownloads { get; public set; }
    public bool VerificationTimeIgnored { get; public set; }
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection ExtraStore { get; }
    public X509Certificate2Collection CustomTrustStore { get; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public X509ChainTrustMode TrustMode { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableCertificateDownloads();
    [CompilerGeneratedAttribute]
public void set_DisableCertificateDownloads(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerificationTimeIgnored();
    [CompilerGeneratedAttribute]
public void set_VerificationTimeIgnored(bool value);
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_ExtraStore();
    public X509Certificate2Collection get_CustomTrustStore();
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public X509ChainTrustMode get_TrustMode();
    public void set_TrustMode(X509ChainTrustMode value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    public void Reset();
    public X509ChainPolicy Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ChainTrustMode : Enum {
    public int value__;
    public static X509ChainTrustMode System;
    public static X509ChainTrustMode CustomRootTrust;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(Oid oid, ReadOnlySpan`1<byte> rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(string oid, ReadOnlySpan`1<byte> rawData, bool critical);
    internal X509Extension(Oid oid, Byte[] rawData, bool critical, bool skipCopy);
    internal X509Extension(Oid oid);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509Extension Item { get; }
    [NullableAttribute("2")]
public X509Extension Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<X509Extension> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Extension>.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    [NullableAttribute("1")]
public X509Extension Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    [NullableContextAttribute("1")]
public sealed virtual X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
internal class System.Security.Cryptography.X509Certificates.X509IterationCountExceededException : Exception {
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
internal static class System.Security.Cryptography.X509Certificates.X509Pal : object {
    [CompilerGeneratedAttribute]
private static IX509Pal <Instance>k__BackingField;
    internal static IX509Pal Instance { get; }
    private static X509Pal();
    [CompilerGeneratedAttribute]
internal static IX509Pal get_Instance();
    private static IX509Pal BuildSingleton();
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationReason : Enum {
    public int value__;
    public static X509RevocationReason Unspecified;
    public static X509RevocationReason KeyCompromise;
    public static X509RevocationReason CACompromise;
    public static X509RevocationReason AffiliationChanged;
    public static X509RevocationReason Superseded;
    public static X509RevocationReason CessationOfOperation;
    public static X509RevocationReason CertificateHold;
    public static X509RevocationReason RemoveFromCrl;
    public static X509RevocationReason PrivilegeWithdrawn;
    public static X509RevocationReason AACompromise;
    public static X509RevocationReason WeakAlgorithmOrKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    private PublicKey _publicKey;
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    private IStorePal _storePal;
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IntPtr StoreHandle { get; }
    public StoreLocation Location { get; private set; }
    [NullableAttribute("2")]
public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(IntPtr storeHandle);
    public IntPtr get_StoreHandle();
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public sealed virtual void Dispose();
    public void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension : X509Extension {
    private List`1<GeneralNameAsn> _decoded;
    public X509SubjectAlternativeNameExtension(Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectAlternativeNameExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateDnsNames();
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension/<EnumerateDnsNames>d__6")]
private static IEnumerable`1<string> EnumerateDnsNames(List`1<GeneralNameAsn> decoded);
    public IEnumerable`1<IPAddress> EnumerateIPAddresses();
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension/<EnumerateIPAddresses>d__8")]
private static IEnumerable`1<IPAddress> EnumerateIPAddresses(List`1<GeneralNameAsn> decoded);
    private static List`1<GeneralNameAsn> Decode(ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private Byte[] _subjectKeyIdentifierBytes;
    private string _subjectKeyIdentifierString;
    private bool _decoded;
    [NullableAttribute("2")]
public string SubjectKeyIdentifier { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SubjectKeyIdentifierBytes { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("2")]
public string get_SubjectKeyIdentifier();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SubjectKeyIdentifierBytes();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private void Decode(Byte[] rawData);
    private static Byte[] EncodeExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.Security.Cryptography.XmlKeyHelper : object {
    internal static ParseState ParseDocument(string xmlString);
    internal static bool HasElement(ParseState& state, string name);
    internal static Byte[] ReadCryptoBinary(ParseState& state, string name, int sizeHint);
    internal static int ReadCryptoBinaryInt32(Byte[] buf);
    internal static void WriteCryptoBinary(string name, int value, StringBuilder builder);
    internal static void WriteCryptoBinary(string name, ReadOnlySpan`1<byte> value, StringBuilder builder);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EmptySpan { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidType { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_Asn1_InvalidCharacterString { get; }
    internal static string Argument_Asn1_InvalidStringContents { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_EmptyString { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidHostnameOrIPAddress { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidRandomRange { get; }
    internal static string Argument_InvalidSerialNumberBytes { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_BitsMustBeWholeBytes { get; }
    internal static string Argument_PemEncoding_NoPemFound { get; }
    internal static string Argument_PemEncoding_InvalidLabel { get; }
    internal static string Argument_PemEncoding_EncodedSizeTooLarge { get; }
    internal static string Argument_PemImport_NoPemFound { get; }
    internal static string Argument_PemImport_AmbiguousPem { get; }
    internal static string Argument_PemImport_EncryptedPem { get; }
    internal static string Argument_X500_EmailTooLong { get; }
    internal static string Argument_X500_InvalidCountryOrRegion { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_KOut_Too_Large { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Chain_EmptyCustomTrustNotSupported { get; }
    internal static string Chain_NoPolicyMatch { get; }
    internal static string Chain_PartialChain { get; }
    internal static string Chain_RevocationStatusUnknown { get; }
    internal static string CryptoConfigNotSupported { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_AlgorithmNotSupported { get; }
    internal static string Cryptography_AlgorithmTypesMustBeVisible { get; }
    internal static string Cryptography_ArgECDHKeySizeMismatch { get; }
    internal static string Cryptography_AuthTagMismatch { get; }
    internal static string Cryptography_CAPI_Required { get; }
    internal static string Cryptography_Cert_AlreadyHasPrivateKey { get; }
    internal static string Cryptography_CertReq_AlgorithmMustMatch { get; }
    internal static string Cryptography_CertReq_BasicConstraintsRequired { get; }
    internal static string Cryptography_CertReq_DatesReversed { get; }
    internal static string Cryptography_CertReq_DuplicateExtension { get; }
    internal static string Cryptography_CertReq_ExtensionRequestInOtherAttributes { get; }
    internal static string Cryptography_CertReq_IssuerBasicConstraintsInvalid { get; }
    internal static string Cryptography_CertReq_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CertReq_IssuerRequiresPrivateKey { get; }
    internal static string Cryptography_CertReq_Load_DuplicateExtensionRequests { get; }
    internal static string Cryptography_CertReq_Load_VersionTooNew { get; }
    internal static string Cryptography_CertReq_MissingOidInCollection { get; }
    internal static string Cryptography_CertReq_NullValueInCollection { get; }
    internal static string Cryptography_CertReq_NoKeyProvided { get; }
    internal static string Cryptography_CertReq_NotAfterNotNested { get; }
    internal static string Cryptography_CertReq_NotBeforeNotNested { get; }
    internal static string Cryptography_CertReq_RSAPaddingRequired { get; }
    internal static string Cryptography_CertReq_SignatureVerificationFailed { get; }
    internal static string Cryptography_CipherModeFeedbackNotSupported { get; }
    internal static string Cryptography_CipherModeNotSupported { get; }
    internal static string Cryptography_Config_EncodedOIDError { get; }
    internal static string Cryptography_CRLBuilder_DatesReversed { get; }
    internal static string Cryptography_CRLBuilder_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CRLBuilder_ReasonNotSupported { get; }
    internal static string Cryptography_CryptoStream_FlushFinalBlockTwice { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_CustomTrustCertsInSystemMode { get; }
    internal static string Cryptography_DefaultAlgorithm_NotSupported { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_ECXmlSerializationFormatRequired { get; }
    internal static string Cryptography_EncryptedIncorrectLength { get; }
    internal static string Cryptography_ExceedKdfExtractLimit { get; }
    internal static string Cryptography_FormatterMissingAlgorithm { get; }
    internal static string Cryptography_FormatterMissingKey { get; }
    internal static string Cryptography_FromXmlParseError { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_HashNotYetFinalized { get; }
    internal static string Cryptography_IncorrectTagLength { get; }
    internal static string Cryptography_InvalidBlockSize { get; }
    internal static string Cryptography_InvalidCipherMode { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidCurveKeyParameters { get; }
    internal static string Cryptography_InvalidCurveOid { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidECCharacteristic2Curve { get; }
    internal static string Cryptography_InvalidECPrimeCurve { get; }
    internal static string Cryptography_InvalidECNamedCurve { get; }
    internal static string Cryptography_InvalidFeedbackSize { get; }
    internal static string Cryptography_InvalidFromXmlString { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidHashAlgorithmOid { get; }
    internal static string Cryptography_InvalidHashSize { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidKey_SemiWeak { get; }
    internal static string Cryptography_InvalidKey_Weak { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidNonceLength { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_InvalidOperation { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidPaddingMode { get; }
    internal static string Cryptography_InvalidTagLength { get; }
    internal static string Cryptography_InvalidTrustCertificate { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_Invalid_X500Name { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_MatchBlockSize { get; }
    internal static string Cryptography_MatchFeedbackSize { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_NoPemOfLabel { get; }
    internal static string Cryptography_NotValidPrivateKey { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_Oid_InvalidName { get; }
    internal static string Cryptography_Oid_InvalidValue { get; }
    internal static string Cryptography_Oid_SetOnceFriendlyName { get; }
    internal static string Cryptography_Oid_SetOnceValue { get; }
    internal static string Cryptography_Okm_TooLarge { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_PasswordDerivedBytes_TooManyBytes { get; }
    internal static string Cryptography_PasswordDerivedBytes_ValuesFixed { get; }
    internal static string Cryptography_Pfx_BadKeyReference { get; }
    internal static string Cryptography_Pfx_BadPassword { get; }
    internal static string Cryptography_Pfx_NoCertificates { get; }
    internal static string Cryptography_Pkcs_InvalidSignatureParameters { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfNotSupported { get; }
    internal static string Cryptography_Pkcs_PssParametersSaltMismatch { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_PlaintextCiphertextLengthMismatch { get; }
    internal static string Cryptography_PlaintextTooLarge { get; }
    internal static string Cryptography_PrivateKey_DoesNotMatch { get; }
    internal static string Cryptography_PrivateKey_WrongAlgorithm { get; }
    internal static string Cryptography_Prk_TooSmall { get; }
    internal static string Cryptography_RC2_EKS40 { get; }
    internal static string Cryptography_RC2_EKSKS { get; }
    internal static string Cryptography_RC2_EKSKS2 { get; }
    internal static string Cryptography_Rijndael_BlockSize { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_RSAPrivateKey_VersionTooNew { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_TlsRequires64ByteSeed { get; }
    internal static string Cryptography_Unix_X509_MachineStoresReadOnly { get; }
    internal static string Cryptography_Unix_X509_NoDisallowedStore { get; }
    internal static string Cryptography_Unix_X509_PropertyNotSettable { get; }
    internal static string Cryptography_Unix_X509_SerializedExport { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownCertContentType { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownKeyAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string Cryptography_UnknownSignatureFormat { get; }
    internal static string Cryptography_X500_MultiValued { get; }
    internal static string Cryptography_X509_AIA_MustNotBuildEmpty { get; }
    internal static string Cryptography_X509_AIA_NullValue { get; }
    internal static string Cryptography_X509_AKID_NoSKID { get; }
    internal static string Cryptography_X509_CDP_MustNotBuildEmpty { get; }
    internal static string Cryptography_X509_CDP_NullValue { get; }
    internal static string Cryptography_X509_ExportFailed { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_InvalidFlagCombination { get; }
    internal static string Cryptography_X509_NoOrMismatchedPemKey { get; }
    internal static string Cryptography_X509_NoPemCertificate { get; }
    internal static string Cryptography_X509_PKCS7_NoSigner { get; }
    internal static string Cryptography_X509_PKCS12_PersistKeySetNotSupported { get; }
    internal static string Cryptography_X509_SAN_UnknownIPAddressSize { get; }
    internal static string Cryptography_X509_StoreAddFailure { get; }
    internal static string Cryptography_X509_StoreCannotCreate { get; }
    internal static string Cryptography_X509_StoreDSAPrivateKeyNotSupported { get; }
    internal static string Cryptography_X509_StoreEnumerateFailure { get; }
    internal static string Cryptography_X509_StoreNotFound { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string Cryptography_X509_StoreReadOnly { get; }
    internal static string Cryptography_X509_StoreRemoveFailure { get; }
    internal static string Cryptography_X509_TooManySANs { get; }
    internal static string HashNameMultipleSetNotSupported { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_IncorrectImplementation { get; }
    internal static string InvalidOperation_UnsupportedBlockSize { get; }
    internal static string NotSupported_ImmutableX509Certificate { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_LegacyBasicConstraints { get; }
    internal static string NotSupported_Method { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string PlatformNotSupported_CryptographyCng { get; }
    internal static string PlatformNotSupported_CryptographyOpenSSL { get; }
    internal static string Security_AccessDenied { get; }
    internal static string Cryptography_X509_PfxWithoutPassword_MaxAllowedIterationsExceeded { get; }
    internal static string Cryptography_X509_PfxWithoutPassword_ProblemFound { get; }
    internal static string Cryptography_X509_ChainBuildingFailed { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EmptySpan();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidType();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_Asn1_InvalidCharacterString();
    internal static string get_Argument_Asn1_InvalidStringContents();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_EmptyString();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidHostnameOrIPAddress();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidRandomRange();
    internal static string get_Argument_InvalidSerialNumberBytes();
    internal static string get_Argument_InvalidValue();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_BitsMustBeWholeBytes();
    internal static string get_Argument_PemEncoding_NoPemFound();
    internal static string get_Argument_PemEncoding_InvalidLabel();
    internal static string get_Argument_PemEncoding_EncodedSizeTooLarge();
    internal static string get_Argument_PemImport_NoPemFound();
    internal static string get_Argument_PemImport_AmbiguousPem();
    internal static string get_Argument_PemImport_EncryptedPem();
    internal static string get_Argument_X500_EmailTooLong();
    internal static string get_Argument_X500_InvalidCountryOrRegion();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_KOut_Too_Large();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Chain_EmptyCustomTrustNotSupported();
    internal static string get_Chain_NoPolicyMatch();
    internal static string get_Chain_PartialChain();
    internal static string get_Chain_RevocationStatusUnknown();
    internal static string get_CryptoConfigNotSupported();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_AlgorithmNotSupported();
    internal static string get_Cryptography_AlgorithmTypesMustBeVisible();
    internal static string get_Cryptography_ArgECDHKeySizeMismatch();
    internal static string get_Cryptography_AuthTagMismatch();
    internal static string get_Cryptography_CAPI_Required();
    internal static string get_Cryptography_Cert_AlreadyHasPrivateKey();
    internal static string get_Cryptography_CertReq_AlgorithmMustMatch();
    internal static string get_Cryptography_CertReq_BasicConstraintsRequired();
    internal static string get_Cryptography_CertReq_DatesReversed();
    internal static string get_Cryptography_CertReq_DuplicateExtension();
    internal static string get_Cryptography_CertReq_ExtensionRequestInOtherAttributes();
    internal static string get_Cryptography_CertReq_IssuerBasicConstraintsInvalid();
    internal static string get_Cryptography_CertReq_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CertReq_IssuerRequiresPrivateKey();
    internal static string get_Cryptography_CertReq_Load_DuplicateExtensionRequests();
    internal static string get_Cryptography_CertReq_Load_VersionTooNew();
    internal static string get_Cryptography_CertReq_MissingOidInCollection();
    internal static string get_Cryptography_CertReq_NullValueInCollection();
    internal static string get_Cryptography_CertReq_NoKeyProvided();
    internal static string get_Cryptography_CertReq_NotAfterNotNested();
    internal static string get_Cryptography_CertReq_NotBeforeNotNested();
    internal static string get_Cryptography_CertReq_RSAPaddingRequired();
    internal static string get_Cryptography_CertReq_SignatureVerificationFailed();
    internal static string get_Cryptography_CipherModeFeedbackNotSupported();
    internal static string get_Cryptography_CipherModeNotSupported();
    internal static string get_Cryptography_Config_EncodedOIDError();
    internal static string get_Cryptography_CRLBuilder_DatesReversed();
    internal static string get_Cryptography_CRLBuilder_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CRLBuilder_ReasonNotSupported();
    internal static string get_Cryptography_CryptoStream_FlushFinalBlockTwice();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_CustomTrustCertsInSystemMode();
    internal static string get_Cryptography_DefaultAlgorithm_NotSupported();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_ECXmlSerializationFormatRequired();
    internal static string get_Cryptography_EncryptedIncorrectLength();
    internal static string get_Cryptography_ExceedKdfExtractLimit();
    internal static string get_Cryptography_FormatterMissingAlgorithm();
    internal static string get_Cryptography_FormatterMissingKey();
    internal static string get_Cryptography_FromXmlParseError();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_HashNotYetFinalized();
    internal static string get_Cryptography_IncorrectTagLength();
    internal static string get_Cryptography_InvalidBlockSize();
    internal static string get_Cryptography_InvalidCipherMode();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidCurveKeyParameters();
    internal static string get_Cryptography_InvalidCurveOid();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidECCharacteristic2Curve();
    internal static string get_Cryptography_InvalidECPrimeCurve();
    internal static string get_Cryptography_InvalidECNamedCurve();
    internal static string get_Cryptography_InvalidFeedbackSize();
    internal static string get_Cryptography_InvalidFromXmlString();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidHashAlgorithmOid();
    internal static string get_Cryptography_InvalidHashSize();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidKey_SemiWeak();
    internal static string get_Cryptography_InvalidKey_Weak();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidNonceLength();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_InvalidOperation();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidPaddingMode();
    internal static string get_Cryptography_InvalidTagLength();
    internal static string get_Cryptography_InvalidTrustCertificate();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_Invalid_X500Name();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_MatchBlockSize();
    internal static string get_Cryptography_MatchFeedbackSize();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_NoPemOfLabel();
    internal static string get_Cryptography_NotValidPrivateKey();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_Oid_InvalidName();
    internal static string get_Cryptography_Oid_InvalidValue();
    internal static string get_Cryptography_Oid_SetOnceFriendlyName();
    internal static string get_Cryptography_Oid_SetOnceValue();
    internal static string get_Cryptography_Okm_TooLarge();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_PasswordDerivedBytes_TooManyBytes();
    internal static string get_Cryptography_PasswordDerivedBytes_ValuesFixed();
    internal static string get_Cryptography_Pfx_BadKeyReference();
    internal static string get_Cryptography_Pfx_BadPassword();
    internal static string get_Cryptography_Pfx_NoCertificates();
    internal static string get_Cryptography_Pkcs_InvalidSignatureParameters();
    internal static string get_Cryptography_Pkcs_PssParametersMgfHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfNotSupported();
    internal static string get_Cryptography_Pkcs_PssParametersSaltMismatch();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_PlaintextCiphertextLengthMismatch();
    internal static string get_Cryptography_PlaintextTooLarge();
    internal static string get_Cryptography_PrivateKey_DoesNotMatch();
    internal static string get_Cryptography_PrivateKey_WrongAlgorithm();
    internal static string get_Cryptography_Prk_TooSmall();
    internal static string get_Cryptography_RC2_EKS40();
    internal static string get_Cryptography_RC2_EKSKS();
    internal static string get_Cryptography_RC2_EKSKS2();
    internal static string get_Cryptography_Rijndael_BlockSize();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_RSAPrivateKey_VersionTooNew();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_TlsRequires64ByteSeed();
    internal static string get_Cryptography_Unix_X509_MachineStoresReadOnly();
    internal static string get_Cryptography_Unix_X509_NoDisallowedStore();
    internal static string get_Cryptography_Unix_X509_PropertyNotSettable();
    internal static string get_Cryptography_Unix_X509_SerializedExport();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownCertContentType();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownKeyAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_Cryptography_UnknownSignatureFormat();
    internal static string get_Cryptography_X500_MultiValued();
    internal static string get_Cryptography_X509_AIA_MustNotBuildEmpty();
    internal static string get_Cryptography_X509_AIA_NullValue();
    internal static string get_Cryptography_X509_AKID_NoSKID();
    internal static string get_Cryptography_X509_CDP_MustNotBuildEmpty();
    internal static string get_Cryptography_X509_CDP_NullValue();
    internal static string get_Cryptography_X509_ExportFailed();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_InvalidFlagCombination();
    internal static string get_Cryptography_X509_NoOrMismatchedPemKey();
    internal static string get_Cryptography_X509_NoPemCertificate();
    internal static string get_Cryptography_X509_PKCS7_NoSigner();
    internal static string get_Cryptography_X509_PKCS12_PersistKeySetNotSupported();
    internal static string get_Cryptography_X509_SAN_UnknownIPAddressSize();
    internal static string get_Cryptography_X509_StoreAddFailure();
    internal static string get_Cryptography_X509_StoreCannotCreate();
    internal static string get_Cryptography_X509_StoreDSAPrivateKeyNotSupported();
    internal static string get_Cryptography_X509_StoreEnumerateFailure();
    internal static string get_Cryptography_X509_StoreNotFound();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_Cryptography_X509_StoreReadOnly();
    internal static string get_Cryptography_X509_StoreRemoveFailure();
    internal static string get_Cryptography_X509_TooManySANs();
    internal static string get_HashNameMultipleSetNotSupported();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_IncorrectImplementation();
    internal static string get_InvalidOperation_UnsupportedBlockSize();
    internal static string get_NotSupported_ImmutableX509Certificate();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_LegacyBasicConstraints();
    internal static string get_NotSupported_Method();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_PlatformNotSupported_CryptographyCng();
    internal static string get_PlatformNotSupported_CryptographyOpenSSL();
    internal static string get_Security_AccessDenied();
    internal static string get_Cryptography_X509_PfxWithoutPassword_MaxAllowedIterationsExceeded();
    internal static string get_Cryptography_X509_PfxWithoutPassword_ProblemFound();
    internal static string get_Cryptography_X509_ChainBuildingFailed();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public virtual string ToString();
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
