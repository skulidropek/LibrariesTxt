internal static class FxResources.System.Text.RegularExpressions.SR : object {
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; public set; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void set_Length(int value);
    public T& get_Item(int index);
    public void Append(T item);
    private void AddWithResize(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow(int additionalCapacityRequired);
    public T Pop();
}
[ExtensionAttribute]
internal static class System.Collections.HashtableExtensions : object {
    [ExtensionAttribute]
public static bool TryGetValue(Hashtable table, object key, T& value);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string AlternationHasNamedCapture { get; }
    internal static string AlternationHasComment { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string ShorthandClassInCharacterRange { get; }
    internal static string BeginIndexNotNegative { get; }
    internal static string QuantifierOrCaptureGroupOutOfRange { get; }
    internal static string CaptureGroupOfZero { get; }
    internal static string CountTooSmall { get; }
    internal static string EnumNotStarted { get; }
    internal static string AlternationHasMalformedCondition { get; }
    internal static string IllegalDefaultRegexMatchTimeoutInAppDomain { get; }
    internal static string UnescapedEndingBackslash { get; }
    internal static string ReversedQuantifierRange { get; }
    internal static string InvalidUnicodePropertyEscape { get; }
    internal static string CaptureGroupNameInvalid { get; }
    internal static string LengthNotNegative { get; }
    internal static string MalformedNamedReference { get; }
    internal static string AlternationHasMalformedReference { get; }
    internal static string MalformedUnicodePropertyEscape { get; }
    internal static string MakeException { get; }
    internal static string MissingControlCharacter { get; }
    internal static string NestedQuantifiersNotParenthesized { get; }
    internal static string NoResultOnFailed { get; }
    internal static string InsufficientClosingParentheses { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string PlatformNotSupported_CompileToAssembly { get; }
    internal static string QuantifierAfterNothing { get; }
    internal static string RegexMatchTimeoutException_Occurred { get; }
    internal static string ReversedCharacterRange { get; }
    internal static string ExclusionGroupNotLast { get; }
    internal static string InsufficientOrInvalidHexDigits { get; }
    internal static string AlternationHasTooManyConditions { get; }
    internal static string InsufficientOpeningParentheses { get; }
    internal static string UndefinedNumberedReference { get; }
    internal static string UndefinedNamedReference { get; }
    internal static string AlternationHasUndefinedReference { get; }
    internal static string UnrecognizedUnicodeProperty { get; }
    internal static string UnrecognizedControlCharacter { get; }
    internal static string UnrecognizedEscape { get; }
    internal static string InvalidGroupingConstruct { get; }
    internal static string UnterminatedBracket { get; }
    internal static string UnterminatedComment { get; }
    internal static string NotSupported_NonBacktrackingConflictingExpression { get; }
    internal static string NotSupported_NonBacktrackingUnsafeSize { get; }
    internal static string ExpressionDescription_Backreference { get; }
    internal static string ExpressionDescription_Conditional { get; }
    internal static string ExpressionDescription_PositiveLookaround { get; }
    internal static string ExpressionDescription_NegativeLookaround { get; }
    internal static string ExpressionDescription_ContiguousMatches { get; }
    internal static string ExpressionDescription_AtomicSubexpressions { get; }
    internal static string ExpressionDescription_IfThenElse { get; }
    internal static string ExpressionDescription_BalancingGroup { get; }
    internal static string UsingSpanAPIsWithCompiledToAssembly { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_AlternationHasNamedCapture();
    internal static string get_AlternationHasComment();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_ShorthandClassInCharacterRange();
    internal static string get_BeginIndexNotNegative();
    internal static string get_QuantifierOrCaptureGroupOutOfRange();
    internal static string get_CaptureGroupOfZero();
    internal static string get_CountTooSmall();
    internal static string get_EnumNotStarted();
    internal static string get_AlternationHasMalformedCondition();
    internal static string get_IllegalDefaultRegexMatchTimeoutInAppDomain();
    internal static string get_UnescapedEndingBackslash();
    internal static string get_ReversedQuantifierRange();
    internal static string get_InvalidUnicodePropertyEscape();
    internal static string get_CaptureGroupNameInvalid();
    internal static string get_LengthNotNegative();
    internal static string get_MalformedNamedReference();
    internal static string get_AlternationHasMalformedReference();
    internal static string get_MalformedUnicodePropertyEscape();
    internal static string get_MakeException();
    internal static string get_MissingControlCharacter();
    internal static string get_NestedQuantifiersNotParenthesized();
    internal static string get_NoResultOnFailed();
    internal static string get_InsufficientClosingParentheses();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_PlatformNotSupported_CompileToAssembly();
    internal static string get_QuantifierAfterNothing();
    internal static string get_RegexMatchTimeoutException_Occurred();
    internal static string get_ReversedCharacterRange();
    internal static string get_ExclusionGroupNotLast();
    internal static string get_InsufficientOrInvalidHexDigits();
    internal static string get_AlternationHasTooManyConditions();
    internal static string get_InsufficientOpeningParentheses();
    internal static string get_UndefinedNumberedReference();
    internal static string get_UndefinedNamedReference();
    internal static string get_AlternationHasUndefinedReference();
    internal static string get_UnrecognizedUnicodeProperty();
    internal static string get_UnrecognizedControlCharacter();
    internal static string get_UnrecognizedEscape();
    internal static string get_InvalidGroupingConstruct();
    internal static string get_UnterminatedBracket();
    internal static string get_UnterminatedComment();
    internal static string get_NotSupported_NonBacktrackingConflictingExpression();
    internal static string get_NotSupported_NonBacktrackingUnsafeSize();
    internal static string get_ExpressionDescription_Backreference();
    internal static string get_ExpressionDescription_Conditional();
    internal static string get_ExpressionDescription_PositiveLookaround();
    internal static string get_ExpressionDescription_NegativeLookaround();
    internal static string get_ExpressionDescription_ContiguousMatches();
    internal static string get_ExpressionDescription_AtomicSubexpressions();
    internal static string get_ExpressionDescription_IfThenElse();
    internal static string get_ExpressionDescription_BalancingGroup();
    internal static string get_UsingSpanAPIsWithCompiledToAssembly();
}
internal class System.Text.RegularExpressions.AnalysisResults : object {
    internal bool _complete;
    internal HashSet`1<RegexNode> _isAtomicByAncestor;
    internal HashSet`1<RegexNode> _containsCapture;
    internal HashSet`1<RegexNode> _mayBacktrack;
    internal HashSet`1<RegexNode> _inLoops;
    internal bool _hasIgnoreCase;
    internal bool _hasRightToLeft;
    [CompilerGeneratedAttribute]
private RegexTree <RegexTree>k__BackingField;
    public bool HasRightToLeft { get; }
    internal AnalysisResults(RegexTree regexTree);
    public bool IsAtomicByAncestor(RegexNode node);
    public bool MayContainCapture(RegexNode node);
    public bool MayBacktrack(RegexNode node);
    public bool IsInLoop(RegexNode node);
    public bool get_HasRightToLeft();
}
public class System.Text.RegularExpressions.Capture : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public int Index { get; private protected set; }
    public int Length { get; private protected set; }
    [NullableAttribute("2")]
internal string Text { get; internal set; }
    [NullableAttribute("1")]
public string Value { get; }
    public ReadOnlySpan`1<char> ValueSpan { get; }
    internal Capture(string text, int index, int length);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private protected void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private protected void set_Length(int value);
    [CompilerGeneratedAttribute]
internal string get_Text();
    [CompilerGeneratedAttribute]
internal void set_Text(string value);
    [NullableContextAttribute("1")]
public string get_Value();
    public ReadOnlySpan`1<char> get_ValueSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal ReadOnlyMemory`1<char> GetLeftSubstring();
    internal ReadOnlyMemory`1<char> GetRightSubstring();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Capture>")]
public class System.Text.RegularExpressions.CaptureCollection : object {
    private Group _group;
    private int _capcount;
    private Capture[] _captures;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Capture Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    internal CaptureCollection(Group group);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Capture get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Capture> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Capture>.GetEnumerator();
    private Capture GetCapture(int i);
    internal void ForceInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Capture[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.IndexOf(Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Insert(int index, Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.RemoveAt(int index);
    private sealed virtual override Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.set_Item(int index, Capture value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Add(Capture item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Contains(Capture item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Remove(Capture item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
internal class System.Text.RegularExpressions.CollectionDebuggerProxy`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebuggerProxy`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
    private ScanDelegate _scanMethod;
    private SearchValues`1[] _searchValues;
    private CultureInfo _culture;
    private RegexCaseBehavior _caseBehavior;
    public CompiledRegexRunner(ScanDelegate scan, SearchValues`1[] searchValues, CultureInfo culture);
    protected internal virtual void Scan(ReadOnlySpan`1<char> text);
}
internal class System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
    private DynamicMethod _scanMethod;
    private SearchValues`1[] _searchValues;
    private CultureInfo _culture;
    private ScanDelegate _scan;
    public CompiledRegexRunnerFactory(DynamicMethod scanMethod, SearchValues`1[] searchValues, CultureInfo culture);
    protected internal virtual RegexRunner CreateInstance();
}
internal enum System.Text.RegularExpressions.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument assemblyname;
    public static ExceptionArgument array;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument count;
    public static ExceptionArgument evaluator;
    public static ExceptionArgument i;
    public static ExceptionArgument inner;
    public static ExceptionArgument input;
    public static ExceptionArgument length;
    public static ExceptionArgument matchTimeout;
    public static ExceptionArgument name;
    public static ExceptionArgument options;
    public static ExceptionArgument pattern;
    public static ExceptionArgument replacement;
    public static ExceptionArgument startat;
    public static ExceptionArgument str;
    public static ExceptionArgument value;
}
internal enum System.Text.RegularExpressions.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource BeginIndexNotNegative;
    public static ExceptionResource CountTooSmall;
    public static ExceptionResource LengthNotNegative;
}
internal enum System.Text.RegularExpressions.FindNextStartingPositionMode : Enum {
    public int value__;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_Beginning;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_Start;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_EndZ;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_End;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_Beginning;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_Start;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_EndZ;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_End;
    public static FindNextStartingPositionMode TrailingAnchor_FixedLength_LeftToRight_End;
    public static FindNextStartingPositionMode TrailingAnchor_FixedLength_LeftToRight_EndZ;
    public static FindNextStartingPositionMode LeadingString_LeftToRight;
    public static FindNextStartingPositionMode LeadingString_RightToLeft;
    public static FindNextStartingPositionMode LeadingString_OrdinalIgnoreCase_LeftToRight;
    public static FindNextStartingPositionMode LeadingSet_LeftToRight;
    public static FindNextStartingPositionMode LeadingSet_RightToLeft;
    public static FindNextStartingPositionMode LeadingChar_RightToLeft;
    public static FindNextStartingPositionMode FixedDistanceChar_LeftToRight;
    public static FindNextStartingPositionMode FixedDistanceString_LeftToRight;
    public static FindNextStartingPositionMode FixedDistanceSets_LeftToRight;
    public static FindNextStartingPositionMode LiteralAfterLoop_LeftToRight;
    public static FindNextStartingPositionMode NoSearch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Text.RegularExpressions.GeneratedRegexAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchTimeoutMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    public string Pattern { get; }
    public RegexOptions Options { get; }
    public int MatchTimeoutMilliseconds { get; }
    public string CultureName { get; }
    public GeneratedRegexAttribute(string pattern);
    public GeneratedRegexAttribute(string pattern, RegexOptions options);
    public GeneratedRegexAttribute(string pattern, RegexOptions options, string cultureName);
    public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds);
    public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds, string cultureName);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    [CompilerGeneratedAttribute]
public int get_MatchTimeoutMilliseconds();
    [CompilerGeneratedAttribute]
public string get_CultureName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.RegularExpressions.Group : Capture {
    internal static Group s_emptyGroup;
    internal Int32[] _caps;
    internal int _capcount;
    internal CaptureCollection _capcoll;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Success { get; }
    public string Name { get; }
    public CaptureCollection Captures { get; }
    internal Group(string text, Int32[] caps, int capcount, string name);
    private static Group();
    public bool get_Success();
    [CompilerGeneratedAttribute]
public string get_Name();
    public CaptureCollection get_Captures();
    public static Group Synchronized(Group inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Group>")]
public class System.Text.RegularExpressions.GroupCollection : object {
    private Match _match;
    private Hashtable _captureMap;
    private Group[] _groups;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Group Item { get; }
    public Group Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<Group> Values { get; }
    internal GroupCollection(Match match, Hashtable caps);
    internal void Reset();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Group get_Item(int groupnum);
    public sealed virtual Group get_Item(string groupname);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Group> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group>.GetEnumerator();
    private Group GetGroup(int groupnum);
    private Group GetGroupImpl(int groupnum);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Group[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.IndexOf(Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Insert(int index, Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.RemoveAt(int index);
    private sealed virtual override Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.set_Item(int index, Group value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Add(Group item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Contains(Group item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Remove(Group item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, Group>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Text.RegularExpressions.Group>>.GetEnumerator();
    public sealed virtual bool TryGetValue(string key, Group& value);
    public sealed virtual bool ContainsKey(string key);
    [IteratorStateMachineAttribute("System.Text.RegularExpressions.GroupCollection/<get_Keys>d__49")]
public sealed virtual IEnumerable`1<string> get_Keys();
    [IteratorStateMachineAttribute("System.Text.RegularExpressions.GroupCollection/<get_Values>d__51")]
public sealed virtual IEnumerable`1<Group> get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.RegularExpressions.Match : Group {
    internal GroupCollection _groupcoll;
    internal Regex _regex;
    internal int _textbeg;
    internal int _textpos;
    internal int _textend;
    internal Int32[][] _matches;
    internal Int32[] _matchcount;
    internal bool _balancing;
    [CompilerGeneratedAttribute]
private static Match <Empty>k__BackingField;
    public static Match Empty { get; }
    internal bool FoundMatch { get; }
    public GroupCollection Groups { get; }
    internal Match(Regex regex, int capcount, string text, int textLength);
    private static Match();
    [CompilerGeneratedAttribute]
public static Match get_Empty();
    internal void Reset(string text, int textLength);
    internal bool get_FoundMatch();
    public virtual GroupCollection get_Groups();
    public Match NextMatch();
    public virtual string Result(string replacement);
    internal ReadOnlyMemory`1<char> GroupToStringImpl(int groupnum);
    internal ReadOnlyMemory`1<char> LastGroupToStringImpl();
    public static Match Synchronized(Match inner);
    internal void AddMatch(int cap, int start, int len);
    internal void BalanceMatch(int cap);
    internal void RemoveMatch(int cap);
    internal bool IsMatched(int cap);
    internal int MatchIndex(int cap);
    internal int MatchLength(int cap);
    internal void Tidy(int textpos, int beginningOfSpanSlice, RegexRunnerMode mode);
    private void TidyBalancing();
}
internal class System.Text.RegularExpressions.MatchCallback`1 : MulticastDelegate {
    public MatchCallback`1(object object, IntPtr method);
    public virtual bool Invoke(TState& state, Match match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Match>")]
public class System.Text.RegularExpressions.MatchCollection : object {
    private Regex _regex;
    private List`1<Match> _matches;
    private string _input;
    private int _startat;
    private int _prevlen;
    private bool _done;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Match Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    internal MatchCollection(Regex regex, string input, int startat);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public virtual Match get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Match> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Match>.GetEnumerator();
    private Match GetMatch(int i);
    private void EnsureInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Match[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.IndexOf(Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Insert(int index, Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.RemoveAt(int index);
    private sealed virtual override Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.set_Item(int index, Match value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Add(Match item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Contains(Match item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Remove(Match item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
    public MatchEvaluator(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(Match match);
    public virtual IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class System.Text.RegularExpressions.MatchSparse : Match {
    private Hashtable _caps;
    public GroupCollection Groups { get; }
    internal MatchSparse(Regex regex, Hashtable caps, int capcount, string text, int textLength);
    public virtual GroupCollection get_Groups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.RegularExpressions.Regex : object {
    [NullableAttribute("2")]
[StringSyntaxAttribute("Regex")]
protected internal string pattern;
    protected internal RegexOptions roptions;
    [NullableAttribute("2")]
protected internal RegexRunnerFactory factory;
    [NullableAttribute("2")]
protected internal Hashtable caps;
    [NullableAttribute("2")]
protected internal Hashtable capnames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected internal String[] capslist;
    protected internal int capsize;
    private WeakReference`1<RegexReplacement> _replref;
    private RegexRunner modreq(System.Runtime.CompilerServices.IsVolatile) _runner;
    public static TimeSpan InfiniteMatchTimeout;
    internal static TimeSpan s_defaultMatchTimeout;
    protected internal TimeSpan internalMatchTimeout;
    [NullableAttribute("2")]
[CLSCompliantAttribute("False")]
protected IDictionary Caps { get; protected set; }
    [NullableAttribute("2")]
[CLSCompliantAttribute("False")]
protected IDictionary CapNames { get; protected set; }
    public RegexOptions Options { get; }
    public bool RightToLeft { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal WeakReference`1<RegexReplacement> RegexReplacementWeakReference { get; }
    public static int CacheSize { get; public set; }
    public TimeSpan MatchTimeout { get; }
    public Regex(string pattern);
    public Regex(string pattern, RegexOptions options);
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
    internal Regex(string pattern, CultureInfo culture);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
internal Regex(string pattern, RegexOptions options, TimeSpan matchTimeout, CultureInfo culture);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected Regex(SerializationInfo info, StreamingContext context);
    private static Regex();
    private RegexTree Init(string pattern, RegexOptions options, TimeSpan matchTimeout, CultureInfo& culture);
    internal static void ValidatePattern(string pattern);
    internal static void ValidateOptions(RegexOptions options);
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    [NullableContextAttribute("2")]
protected IDictionary get_Caps();
    [NullableContextAttribute("2")]
protected void set_Caps(IDictionary value);
    [NullableContextAttribute("2")]
protected IDictionary get_CapNames();
    [NullableContextAttribute("2")]
protected void set_CapNames(IDictionary value);
    [RequiresDynamicCodeAttribute("Compiling a RegEx requires dynamic code.")]
private static RegexRunnerFactory Compile(string pattern, RegexTree regexTree, RegexOptions options, bool hasTimeout);
    [ObsoleteAttribute("Regex.CompileToAssembly is obsolete and not supported. Use the GeneratedRegexAttribute with the regular expression source generator instead.")]
public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);
    [ObsoleteAttribute("Regex.CompileToAssembly is obsolete and not supported. Use the GeneratedRegexAttribute with the regular expression source generator instead.")]
public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes);
    [ObsoleteAttribute("Regex.CompileToAssembly is obsolete and not supported. Use the GeneratedRegexAttribute with the regular expression source generator instead.")]
public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile);
    public static string Escape(string str);
    public static string Unescape(string str);
    public RegexOptions get_Options();
    public bool get_RightToLeft();
    public virtual string ToString();
    public String[] GetGroupNames();
    public Int32[] GetGroupNumbers();
    public string GroupNameFromNumber(int i);
    public int GroupNumberFromName(string name);
    internal WeakReference`1<RegexReplacement> get_RegexReplacementWeakReference();
    [ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
[EditorBrowsableAttribute("1")]
protected void InitializeReferences();
    internal Match RunSingleMatch(RegexRunnerMode mode, int prevlen, string input, int beginning, int length, int startat);
    internal ValueTuple`4<bool, int, int, int> RunSingleMatch(RegexRunnerMode mode, int prevlen, ReadOnlySpan`1<char> input, int startat);
    internal void RunAllMatchesWithCallback(string input, int startat, TState& state, MatchCallback`1<TState> callback, RegexRunnerMode mode, bool reuseMatchObject);
    internal void RunAllMatchesWithCallback(ReadOnlySpan`1<char> input, int startat, TState& state, MatchCallback`1<TState> callback, RegexRunnerMode mode, bool reuseMatchObject);
    private void RunAllMatchesWithCallback(string inputString, ReadOnlySpan`1<char> inputSpan, int startat, TState& state, MatchCallback`1<TState> callback, RegexRunnerMode mode, bool reuseMatchObject);
    private static Match ScanInternal(RegexRunnerMode mode, bool reuseMatchObject, string input, int beginning, RegexRunner runner, ReadOnlySpan`1<char> span, bool returnNullIfReuseMatchObject);
    private RegexRunner CreateRunner();
    [ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
[EditorBrowsableAttribute("1")]
protected bool UseOptionC();
    [ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
[EditorBrowsableAttribute("1")]
protected bool UseOptionR();
    public static int get_CacheSize();
    public static void set_CacheSize(int value);
    public int Count(string input);
    [NullableContextAttribute("0")]
public int Count(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("0")]
public int Count(ReadOnlySpan`1<char> input, int startat);
    public static int Count(string input, string pattern);
    public static int Count(string input, string pattern, RegexOptions options);
    public static int Count(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    [NullableContextAttribute("0")]
public static int Count(ReadOnlySpan`1<char> input, string pattern);
    [NullableContextAttribute("0")]
public static int Count(ReadOnlySpan`1<char> input, string pattern, RegexOptions options);
    [NullableContextAttribute("0")]
public static int Count(ReadOnlySpan`1<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public static bool IsMatch(string input, string pattern);
    [NullableContextAttribute("0")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    [NullableContextAttribute("0")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    [NullableContextAttribute("0")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public bool IsMatch(string input);
    public bool IsMatch(string input, int startat);
    [NullableContextAttribute("0")]
public bool IsMatch(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("0")]
public bool IsMatch(ReadOnlySpan`1<char> input, int startat);
    public static Match Match(string input, string pattern);
    public static Match Match(string input, string pattern, RegexOptions options);
    public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public Match Match(string input);
    public Match Match(string input, int startat);
    public Match Match(string input, int beginning, int length);
    public static MatchCollection Matches(string input, string pattern);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public MatchCollection Matches(string input);
    public MatchCollection Matches(string input, int startat);
    public static string Replace(string input, string pattern, string replacement);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, string replacement);
    public string Replace(string input, string replacement, int count);
    public string Replace(string input, string replacement, int count, int startat);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, MatchEvaluator evaluator);
    public string Replace(string input, MatchEvaluator evaluator, int count);
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
    private static string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat);
    internal static string SegmentsToStringAndDispose(StructListBuilder`1& segments);
    public static String[] Split(string input, string pattern);
    public static String[] Split(string input, string pattern, RegexOptions options);
    public static String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public String[] Split(string input);
    public String[] Split(string input, int count);
    public String[] Split(string input, int count, int startat);
    private static String[] Split(Regex regex, string input, int count, int startat);
    [NullableContextAttribute("0")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern);
    [NullableContextAttribute("0")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern, RegexOptions options);
    [NullableContextAttribute("0")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    [NullableContextAttribute("0")]
public ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("0")]
public ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, int startat);
    public TimeSpan get_MatchTimeout();
    private static TimeSpan InitDefaultMatchTimeout();
}
internal class System.Text.RegularExpressions.RegexCache : object {
    private static Node modreq(System.Runtime.CompilerServices.IsVolatile) s_lastAccessed;
    private static ConcurrentDictionary`2<Key, Node> s_cacheDictionary;
    private static List`1<Node> s_cacheList;
    private static Random s_random;
    private static int s_maxCacheSize;
    private static object SyncObj { get; }
    public static int MaxCacheSize { get; public set; }
    private static RegexCache();
    private static object get_SyncObj();
    public static int get_MaxCacheSize();
    public static void set_MaxCacheSize(int value);
    public static Regex GetOrAdd(string pattern);
    public static Regex GetOrAdd(string pattern, RegexOptions options, TimeSpan matchTimeout);
    private static Regex Get(Key key);
    private static void Add(Key key, Regex regex);
}
internal enum System.Text.RegularExpressions.RegexCaseBehavior : Enum {
    public int value__;
    public static RegexCaseBehavior NotSet;
    public static RegexCaseBehavior Invariant;
    public static RegexCaseBehavior NonTurkish;
    public static RegexCaseBehavior Turkish;
}
internal static class System.Text.RegularExpressions.RegexCaseEquivalences : object {
    private static ReadOnlySpan`1<char> EquivalenceCasingValues { get; }
    private static ReadOnlySpan`1<ushort> EquivalenceFirstLevelLookup { get; }
    private static ReadOnlySpan`1<ushort> EquivalenceCasingMap { get; }
    private static ReadOnlySpan`1<char> get_EquivalenceCasingValues();
    private static ReadOnlySpan`1<ushort> get_EquivalenceFirstLevelLookup();
    private static ReadOnlySpan`1<ushort> get_EquivalenceCasingMap();
    public static bool TryFindCaseEquivalencesForCharWithIBehavior(char c, CultureInfo culture, RegexCaseBehavior& mappingBehavior, ReadOnlySpan`1& equivalences);
    public static RegexCaseBehavior GetRegexBehavior(CultureInfo culture);
    private static bool TryFindCaseEquivalencesForChar(char c, ReadOnlySpan`1& equivalences);
    [CompilerGeneratedAttribute]
internal static bool <GetRegexBehavior>g__IsTurkishOrAzeri|8_0(string cultureName);
}
internal class System.Text.RegularExpressions.RegexCharClass : object {
    private static Dictionary`2<string, string> s_definedCategories;
    private static String[][] s_propTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<char, char>> _rangelist;
    private StringBuilder _categories;
    private RegexCharClass _subtractor;
    private bool _negate;
    private RegexCaseBehavior _caseBehavior;
    private static String[] s_asciiStrings;
    private static String[] s_asciiLetterPairStrings;
    public bool CanMerge { get; }
    unknown bool Negate {public set; }
    private static ReadOnlySpan`1<byte> WordCharAsciiLookup { get; }
    private RegexCharClass(bool negate, List`1<ValueTuple`2<char, char>> ranges, StringBuilder categories, RegexCharClass subtraction);
    private static RegexCharClass();
    public bool get_CanMerge();
    public void set_Negate(bool value);
    public void AddChar(char c);
    public void AddCharClass(RegexCharClass cc);
    public bool TryAddCharClass(RegexCharClass cc);
    private StringBuilder EnsureCategories();
    private List`1<ValueTuple`2<char, char>> EnsureRangeList();
    private void AddRanges(ReadOnlySpan`1<char> set);
    public void AddSubtraction(RegexCharClass sub);
    public void AddRange(char first, char last);
    public void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern, int currentPos);
    private void AddCategory(string category);
    public void AddCaseEquivalences(CultureInfo culture);
    private void AddCaseEquivalenceRange(char chMin, char chMax, CultureInfo culture);
    public void AddWord(bool ecma, bool negate);
    public void AddSpace(bool ecma, bool negate);
    public void AddDigit(bool ecma, bool negate, string pattern, int currentPos);
    public static string ConvertOldStringsToClass(string set, string category);
    public static char SingletonChar(string set);
    public static bool IsMergeable(string charClass);
    public static bool IsEmpty(string charClass);
    public static bool IsSingleton(string set);
    public static bool IsSingletonInverse(string set);
    public static bool TryGetOnlyCategories(string set, Span`1<UnicodeCategory> categories, Int32& numCategories, Boolean& negated);
    public static bool TryGetSingleRange(string set, Char& lowInclusive, Char& highInclusive);
    public static bool TryGetDoubleRange(string set, ValueTuple`2& range0, ValueTuple`2& range1);
    public static int GetSetChars(string set, Span`1<char> chars);
    public static bool TryGetAsciiSetChars(string set, Char[]& asciiChars);
    public static bool MayOverlap(string set1, string set2);
    public static bool ParticipatesInCaseConversion(int comparison);
    public static bool ParticipatesInCaseConversion(ReadOnlySpan`1<char> s);
    public static bool IsAscii(ReadOnlySpan`1<char> s);
    private static bool CanEasilyEnumerateSetContents(string set);
    private static bool CanEasilyEnumerateSetContents(string set, Boolean& hasSubtraction);
    internal static CharClassAnalysisResults Analyze(string set);
    internal static bool IsSubtraction(string charClass);
    internal static bool IsNegated(string set);
    internal static bool IsNegated(string set, int setOffset);
    public static bool IsECMAWordChar(char ch);
    private static ReadOnlySpan`1<byte> get_WordCharAsciiLookup();
    public static bool IsWordChar(char ch);
    public static bool IsBoundaryWordChar(char ch);
    public static bool DifferByOneBit(char a, char b, Int32& mask);
    public static bool CharInClass(char ch, string set, UInt32[]& asciiLazyCache);
    public static bool CharInClass(char ch, string set);
    private static bool CharInClassRecursive(char ch, string set, int start);
    private static bool CharInClassInternal(char ch, string set, int start, int setLength, int categoryLength);
    private static bool CharInCategory(char ch, ReadOnlySpan`1<char> categorySetSegment);
    private static bool CharInCategoryGroup(UnicodeCategory chcategory, ReadOnlySpan`1<char> category, Int32& i);
    public static RegexCharClass Parse(string charClass);
    private static RegexCharClass ParseRecursive(string charClass, int start);
    public static List`1<ValueTuple`2<char, char>> ComputeRanges(ReadOnlySpan`1<char> set);
    public static string OneToStringClass(char c);
    internal static string CharsToStringClass(ReadOnlySpan`1<char> chars);
    public string ToStringClass();
    private void ToStringClass(ValueStringBuilder& vsb);
    private void Canonicalize();
    private static ReadOnlySpan`1<char> RangesFromProperty(string capname, bool invert, string pattern, int currentPos);
    [CompilerGeneratedAttribute]
internal static bool <MayOverlap>g__KnownDistinctSets|107_0(string set1, string set2);
    [CompilerGeneratedAttribute]
internal static bool <MayOverlap>g__MayOverlapByEnumeration|107_1(string set1, string set2);
    [CompilerGeneratedAttribute]
internal static bool <CharInClass>g__InitializeValue|125_0(char ch, string set, UInt32[]& asciiLazyCache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Regex.CompileToAssembly is obsolete and not supported. Use the GeneratedRegexAttribute with the regular expression source generator instead.")]
public class System.Text.RegularExpressions.RegexCompilationInfo : object {
    private string _pattern;
    private string _name;
    private string _nspace;
    private TimeSpan _matchTimeout;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    public bool IsPublic { get; public set; }
    public TimeSpan MatchTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public RegexOptions Options { get; public set; }
    public string Pattern { get; public set; }
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic);
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    public TimeSpan get_MatchTimeout();
    public void set_MatchTimeout(TimeSpan value);
    public string get_Name();
    [MemberNotNullAttribute("_name")]
public void set_Name(string value);
    public string get_Namespace();
    [MemberNotNullAttribute("_nspace")]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(RegexOptions value);
    public string get_Pattern();
    [MemberNotNullAttribute("_pattern")]
public void set_Pattern(string value);
}
[RequiresDynamicCodeAttribute("Compiling a RegEx requires dynamic code.")]
internal abstract class System.Text.RegularExpressions.RegexCompiler : object {
    private static FieldInfo s_runtextstartField;
    private static FieldInfo s_runtextposField;
    private static FieldInfo s_runtrackposField;
    private static FieldInfo s_runstackField;
    private static FieldInfo s_cultureField;
    private static FieldInfo s_caseBehaviorField;
    private static FieldInfo s_searchValuesArrayField;
    private static MethodInfo s_captureMethod;
    private static MethodInfo s_transferCaptureMethod;
    private static MethodInfo s_uncaptureMethod;
    private static MethodInfo s_isMatchedMethod;
    private static MethodInfo s_matchLengthMethod;
    private static MethodInfo s_matchIndexMethod;
    private static MethodInfo s_isBoundaryMethod;
    private static MethodInfo s_isWordCharMethod;
    private static MethodInfo s_isECMABoundaryMethod;
    private static MethodInfo s_crawlposMethod;
    private static MethodInfo s_charInClassMethod;
    private static MethodInfo s_checkTimeoutMethod;
    private static MethodInfo s_regexCaseEquivalencesTryFindCaseEquivalencesForCharWithIBehaviorMethod;
    private static MethodInfo s_charIsDigitMethod;
    private static MethodInfo s_charIsWhiteSpaceMethod;
    private static MethodInfo s_charIsControlMethod;
    private static MethodInfo s_charIsLetterMethod;
    private static MethodInfo s_charIsAsciiDigitMethod;
    private static MethodInfo s_charIsAsciiLetterMethod;
    private static MethodInfo s_charIsAsciiLetterLowerMethod;
    private static MethodInfo s_charIsAsciiLetterUpperMethod;
    private static MethodInfo s_charIsAsciiLetterOrDigitMethod;
    private static MethodInfo s_charIsAsciiHexDigitMethod;
    private static MethodInfo s_charIsAsciiHexDigitLowerMethod;
    private static MethodInfo s_charIsAsciiHexDigitUpperMethod;
    private static MethodInfo s_charIsLetterOrDigitMethod;
    private static MethodInfo s_charIsLowerMethod;
    private static MethodInfo s_charIsUpperMethod;
    private static MethodInfo s_charIsNumberMethod;
    private static MethodInfo s_charIsPunctuationMethod;
    private static MethodInfo s_charIsSeparatorMethod;
    private static MethodInfo s_charIsSymbolMethod;
    private static MethodInfo s_charGetUnicodeInfo;
    private static MethodInfo s_spanGetItemMethod;
    private static MethodInfo s_spanGetLengthMethod;
    private static MethodInfo s_spanIndexOfChar;
    private static MethodInfo s_spanIndexOfSpan;
    private static MethodInfo s_spanIndexOfSpanStringComparison;
    private static MethodInfo s_spanIndexOfAnyCharChar;
    private static MethodInfo s_spanIndexOfAnyCharCharChar;
    private static MethodInfo s_spanIndexOfAnySpan;
    private static MethodInfo s_spanIndexOfAnySearchValues;
    private static MethodInfo s_spanIndexOfAnyExceptChar;
    private static MethodInfo s_spanIndexOfAnyExceptCharChar;
    private static MethodInfo s_spanIndexOfAnyExceptCharCharChar;
    private static MethodInfo s_spanIndexOfAnyExceptSpan;
    private static MethodInfo s_spanIndexOfAnyExceptSearchValues;
    private static MethodInfo s_spanIndexOfAnyInRange;
    private static MethodInfo s_spanIndexOfAnyExceptInRange;
    private static MethodInfo s_spanLastIndexOfChar;
    private static MethodInfo s_spanLastIndexOfAnyCharChar;
    private static MethodInfo s_spanLastIndexOfAnyCharCharChar;
    private static MethodInfo s_spanLastIndexOfAnySpan;
    private static MethodInfo s_spanLastIndexOfAnySearchValues;
    private static MethodInfo s_spanLastIndexOfSpan;
    private static MethodInfo s_spanLastIndexOfAnyExceptChar;
    private static MethodInfo s_spanLastIndexOfAnyExceptCharChar;
    private static MethodInfo s_spanLastIndexOfAnyExceptCharCharChar;
    private static MethodInfo s_spanLastIndexOfAnyExceptSpan;
    private static MethodInfo s_spanLastIndexOfAnyExceptSearchValues;
    private static MethodInfo s_spanLastIndexOfAnyInRange;
    private static MethodInfo s_spanLastIndexOfAnyExceptInRange;
    private static MethodInfo s_spanSliceIntMethod;
    private static MethodInfo s_spanSliceIntIntMethod;
    private static MethodInfo s_spanStartsWithSpan;
    private static MethodInfo s_spanStartsWithSpanComparison;
    private static MethodInfo s_stringAsSpanMethod;
    private static MethodInfo s_stringGetCharsMethod;
    private static MethodInfo s_arrayResize;
    private static MethodInfo s_mathMinIntInt;
    private static MethodInfo s_memoryMarshalGetArrayDataReferenceSearchValues;
    private static MethodInfo s_unsafeAs;
    protected ILGenerator _ilg;
    protected RegexOptions _options;
    protected RegexTree _regexTree;
    protected bool _hasTimeout;
    protected List`1<SearchValues`1<char>> _searchValues;
    private Stack`1<LocalBuilder> _int32LocalsPool;
    private Stack`1<LocalBuilder> _readOnlySpanCharLocalsPool;
    private static RegexCompiler();
    private static FieldInfo RegexRunnerField(string fieldname);
    private static MethodInfo RegexRunnerMethod(string methname);
    internal static RegexRunnerFactory Compile(string pattern, RegexTree regexTree, RegexOptions options, bool hasTimeout);
    private Label DefineLabel();
    private void MarkLabel(Label l);
    protected void Ldstr(string str);
    protected void Ldc(int i);
    protected void LdcI8(long i);
    protected void Ret();
    protected void Dup();
    private void Ceq();
    private void CgtUn();
    private void CltUn();
    private void Pop();
    private void Add();
    private void Sub();
    private void Mul();
    private void And();
    private void Or();
    private void Shl();
    private void Shr();
    private void Ldloc(LocalBuilder lt);
    private void Ldloca(LocalBuilder lt);
    private void LdindU2();
    private void Stloc(LocalBuilder lt);
    protected void Ldthis();
    private void Ldarg_1();
    protected void Ldthisfld(FieldInfo ft);
    protected void Ldthisflda(FieldInfo ft);
    private void Ldarga_s(int position);
    private void Mvfldloc(FieldInfo ft, LocalBuilder lt);
    protected void Stfld(FieldInfo ft);
    protected void Call(MethodInfo mt);
    private void Brfalse(Label l);
    private void BrfalseFar(Label l);
    private void BrtrueFar(Label l);
    private void BrFar(Label l);
    private void BleFar(Label l);
    private void BltFar(Label l);
    private void BltUnFar(Label l);
    private void BgeFar(Label l);
    private void BgeUnFar(Label l);
    private void BneFar(Label l);
    private void BeqFar(Label l);
    private void Brtrue(Label l);
    private void Br(Label l);
    private void Ble(Label l);
    private void Blt(Label l);
    private void Bge(Label l);
    private void BgeUn(Label l);
    private void Bgt(Label l);
    private void Bne(Label l);
    private void Beq(Label l);
    private void Ldlen();
    private void LdelemI4();
    private void StelemI4();
    private void Switch(Label[] table);
    private LocalBuilder DeclareInt32();
    private LocalBuilder DeclareReadOnlySpanChar();
    private RentedLocalBuilder RentInt32Local();
    private RentedLocalBuilder RentReadOnlySpanCharLocal();
    protected void EmitTryFindNextPossibleStartingPosition();
    protected void EmitTryMatchAtCurrentPosition();
    protected void EmitScan(RegexOptions options, DynamicMethod tryFindNextStartingPositionMethod, DynamicMethod tryMatchAtCurrentPositionMethod);
    private void EmitMatchCharacterClass(string charClass);
    private void NegateIf(bool condition);
    private void EmitTimeoutCheckIfNeeded();
    private void LoadSearchValues(ReadOnlySpan`1<char> chars);
    [CompilerGeneratedAttribute]
private bool <EmitTryFindNextPossibleStartingPosition>g__EmitAnchors|156_0(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
private void <EmitTryFindNextPossibleStartingPosition>g__EmitIndexOf_LeftToRight|156_1(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
private void <EmitTryFindNextPossibleStartingPosition>g__EmitIndexOf_RightToLeft|156_2(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
private void <EmitTryFindNextPossibleStartingPosition>g__EmitFixedSet_LeftToRight|156_3(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
private void <EmitTryFindNextPossibleStartingPosition>g__EmitFixedSet_RightToLeft|156_4(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
private void <EmitTryFindNextPossibleStartingPosition>g__EmitLiteralAfterAtomicLoop|156_5(<>c__DisplayClass156_0& );
    [CompilerGeneratedAttribute]
internal static RegexNode <EmitTryMatchAtCurrentPosition>g__GetSubsequent|157_41(int index, RegexNode node, RegexNode subsequent);
    [CompilerGeneratedAttribute]
internal static bool <EmitTryMatchAtCurrentPosition>g__CanEmitIndexOf|157_29(RegexNode node, Int32& literalLength);
    [CompilerGeneratedAttribute]
private void <EmitMatchCharacterClass>g__EmitCharInClass|159_0(<>c__DisplayClass159_0& );
    [CompilerGeneratedAttribute]
private void <EmitMatchCharacterClass>g__EmitContainsNoAscii|159_1(<>c__DisplayClass159_0& );
    [CompilerGeneratedAttribute]
private void <EmitMatchCharacterClass>g__EmitAllAsciiContained|159_2(<>c__DisplayClass159_0& );
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
internal static MethodInfo <LoadSearchValues>g__MakeUnsafeAs|162_0(Type type);
}
internal class System.Text.RegularExpressions.RegexFindOptimizations : object {
    private bool _rightToLeft;
    private UInt32[][] _asciiLookups;
    [CompilerGeneratedAttribute]
private FindNextStartingPositionMode <FindMode>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexNodeKind <LeadingAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexNodeKind <TrailingAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinRequiredLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPossibleLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeadingPrefix>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`3<char, string, int> <FixedDistanceLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FixedDistanceSet> <FixedDistanceSets>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> <LiteralAfterLoop>k__BackingField;
    public bool IsUseful { get; }
    public FindNextStartingPositionMode FindMode { get; }
    public RegexNodeKind LeadingAnchor { get; }
    public RegexNodeKind TrailingAnchor { get; }
    public int MinRequiredLength { get; }
    public Nullable`1<int> MaxPossibleLength { get; }
    public string LeadingPrefix { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3<char, string, int> FixedDistanceLiteral { get; }
    public List`1<FixedDistanceSet> FixedDistanceSets { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> LiteralAfterLoop { get; }
    public RegexFindOptimizations(RegexNode root, RegexOptions options);
    public bool get_IsUseful();
    [CompilerGeneratedAttribute]
public FindNextStartingPositionMode get_FindMode();
    [CompilerGeneratedAttribute]
public RegexNodeKind get_LeadingAnchor();
    [CompilerGeneratedAttribute]
public RegexNodeKind get_TrailingAnchor();
    [CompilerGeneratedAttribute]
public int get_MinRequiredLength();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPossibleLength();
    [CompilerGeneratedAttribute]
public string get_LeadingPrefix();
    [CompilerGeneratedAttribute]
public ValueTuple`3<char, string, int> get_FixedDistanceLiteral();
    [CompilerGeneratedAttribute]
public List`1<FixedDistanceSet> get_FixedDistanceSets();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> get_LiteralAfterLoop();
    private static Nullable`1<ValueTuple`2<string, int>> FindFixedDistanceString(List`1<FixedDistanceSet> fixedDistanceSets);
    public bool TryFindNextStartingPositionRightToLeft(ReadOnlySpan`1<char> textSpan, Int32& pos, int start);
    public bool TryFindNextStartingPositionLeftToRight(ReadOnlySpan`1<char> textSpan, Int32& pos, int start);
}
internal class System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
    private RegexInterpreterCode _code;
    private CultureInfo _culture;
    private RegexCaseBehavior _caseBehavior;
    private RegexOpcode _operator;
    private int _codepos;
    private bool _rightToLeft;
    public RegexInterpreter(RegexInterpreterCode code, CultureInfo culture);
    protected virtual void InitTrackCount();
    private void Advance(int i);
    private void Goto(int newpos);
    private void Trackto(int newpos);
    private int Trackpos();
    private void TrackPush();
    private void TrackPush(int i1);
    private void TrackPush(int i1, int i2);
    private void TrackPush(int i1, int i2, int i3);
    private void TrackPush2(int i1);
    private void TrackPush2(int i1, int i2);
    private void Backtrack();
    private void SetOperator(RegexOpcode op);
    private void TrackPop();
    private void TrackPop(int framesize);
    private int TrackPeek();
    private int TrackPeek(int i);
    private void StackPush(int i1);
    private void StackPush(int i1, int i2);
    private void StackPop();
    private void StackPop(int framesize);
    private int StackPeek();
    private int StackPeek(int i);
    private int Operand(int i);
    private int Bump();
    private int Forwardchars();
    private char Forwardcharnext(ReadOnlySpan`1<char> inputSpan);
    private bool MatchString(string str, ReadOnlySpan`1<char> inputSpan);
    private bool MatchRef(int index, int length, ReadOnlySpan`1<char> inputSpan, bool caseInsensitive);
    private void Backwardnext();
    protected internal virtual void Scan(ReadOnlySpan`1<char> text);
    private bool TryMatchAtCurrentPosition(ReadOnlySpan`1<char> inputSpan);
}
internal class System.Text.RegularExpressions.RegexInterpreterCode : object {
    public RegexFindOptimizations FindOptimizations;
    public RegexOptions Options;
    public Int32[] Codes;
    public String[] Strings;
    public UInt32[][] StringsAsciiLookup;
    public int TrackCount;
    public RegexInterpreterCode(RegexFindOptimizations findOptimizations, RegexOptions options, Int32[] codes, String[] strings, int trackcount);
    public static bool OpcodeBacktracks(RegexOpcode opcode);
}
internal class System.Text.RegularExpressions.RegexInterpreterFactory : RegexRunnerFactory {
    private RegexInterpreterCode _code;
    private CultureInfo _culture;
    public RegexInterpreterFactory(RegexTree tree);
    protected internal virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
    private static bool s_includePatternInName;
    private static Type[] s_paramTypes;
    private static int s_regexCount;
    private static RegexLWCGCompiler();
    [RequiresDynamicCodeAttribute("Compiling a RegEx requires dynamic code.")]
public RegexRunnerFactory FactoryInstanceFromCode(string pattern, RegexTree regexTree, RegexOptions options, bool hasTimeout);
    [RequiresDynamicCodeAttribute("Compiling a RegEx requires dynamic code.")]
private DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType, Type[] paramTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MatchTimeout>k__BackingField;
    public string Input { get; }
    public string Pattern { get; }
    public TimeSpan MatchTimeout { get; }
    public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
    public RegexMatchTimeoutException(string message);
    public RegexMatchTimeoutException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected RegexMatchTimeoutException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Input();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public TimeSpan get_MatchTimeout();
}
internal class System.Text.RegularExpressions.RegexNode : object {
    private object Children;
    [CompilerGeneratedAttribute]
private RegexNodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Str>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Ch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <M>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    public RegexOptions Options;
    public RegexNode Parent;
    public RegexNodeKind Kind { get; private set; }
    public string Str { get; private set; }
    public char Ch { get; private set; }
    public int M { get; private set; }
    public int N { get; private set; }
    [MemberNotNullWhenAttribute("True", "Str")]
public bool IsSetFamily { get; }
    public bool IsOneFamily { get; }
    public bool IsNotoneFamily { get; }
    public RegexNode(RegexNodeKind kind, RegexOptions options);
    public RegexNode(RegexNodeKind kind, RegexOptions options, char ch);
    public RegexNode(RegexNodeKind kind, RegexOptions options, string str);
    public RegexNode(RegexNodeKind kind, RegexOptions options, int m);
    public RegexNode(RegexNodeKind kind, RegexOptions options, int m, int n);
    [CompilerGeneratedAttribute]
public RegexNodeKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(RegexNodeKind value);
    [CompilerGeneratedAttribute]
public string get_Str();
    [CompilerGeneratedAttribute]
private void set_Str(string value);
    [CompilerGeneratedAttribute]
public char get_Ch();
    [CompilerGeneratedAttribute]
private void set_Ch(char value);
    [CompilerGeneratedAttribute]
public int get_M();
    [CompilerGeneratedAttribute]
private void set_M(int value);
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
private void set_N(int value);
    public static RegexNode CreateOneWithCaseConversion(char ch, RegexOptions options, CultureInfo culture, RegexCaseBehavior& caseBehavior);
    public RegexNode ReverseConcatenationIfRightToLeft();
    private void MakeRep(RegexNodeKind kind, int min, int max);
    private void MakeLoopAtomic();
    internal RegexNode FinalOptimize();
    private void EliminateEndingBacktracking();
    internal RegexNode Reduce();
    private RegexNode ReplaceNodeIfUnnecessary();
    private RegexNode ReduceGroup();
    private RegexNode ReduceAtomic();
    private RegexNode ReduceLoops();
    private RegexNode ReduceSet();
    private RegexNode ReduceAlternation();
    public RegexNode FindBranchOneOrMultiStart();
    public char FirstCharOfOneOrMulti();
    public RegexNode FindStartingLiteralNode();
    public Nullable`1<StartingLiteralData> FindStartingLiteral(int maxSetCharacters);
    private RegexNode ReduceConcatenation();
    private void ReduceConcatenationWithAdjacentStrings();
    private void ReduceConcatenationWithAdjacentLoops();
    private void FindAndMakeLoopsAtomic();
    private RegexNode FindLastExpressionInLoopForAutoAtomic();
    private RegexNode ReduceLookaround();
    private RegexNode ReduceBackreferenceConditional();
    private RegexNode ReduceExpressionConditional();
    private static bool CanBeMadeAtomic(RegexNode node, RegexNode subsequent, bool iterateNullableSubsequent, bool allowLazy);
    public int ComputeMinLength();
    public Nullable`1<int> ComputeMaxLength();
    public bool TryGetOrdinalCaseInsensitiveString(int childIndex, int exclusiveChildBound, Int32& nodesConsumed, String& caseInsensitiveString, bool consumeZeroWidthNodes);
    public bool TryGetJoinableLengthCheckChildRange(int childIndex, Int32& requiredLength, Int32& exclusiveEnd);
    public RegexNode MakeQuantifier(bool lazy, int min, int max);
    public void AddChild(RegexNode newChild);
    public void InsertChild(int index, RegexNode newChild);
    public void ReplaceChild(int index, RegexNode newChild);
    public RegexNode Child(int i);
    public int ChildCount();
    internal bool SupportsCompilation(String& reason);
    [MemberNotNullWhenAttribute("True", "Str")]
public bool get_IsSetFamily();
    public bool get_IsOneFamily();
    public bool get_IsNotoneFamily();
    [CompilerGeneratedAttribute]
private void <ReduceAlternation>g__ReduceSingleLetterAndNestedAlternations|41_0();
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__ExtractCommonPrefixOneNotoneSet|41_1(RegexNode alternation);
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__RemoveRedundantEmptiesAndNothings|41_2(RegexNode node);
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__ExtractCommonPrefixText|41_3(RegexNode alternation);
    [CompilerGeneratedAttribute]
internal static void <ReduceAlternation>g__ProcessOneOrMulti|41_4(RegexNode node, ReadOnlySpan`1<char> startingSpan);
    [CompilerGeneratedAttribute]
internal static bool <ReduceConcatenationWithAdjacentLoops>g__CanCombineCounts|50_0(int nodeMin, int nodeMax, int nextMin, int nextMax);
    [CompilerGeneratedAttribute]
internal static void <FindAndMakeLoopsAtomic>g__ProcessNode|51_0(RegexNode node, RegexNode subsequent);
    [CompilerGeneratedAttribute]
internal static bool <TryGetJoinableLengthCheckChildRange>g__CanJoinLengthCheck|60_0(RegexNode node);
    [CompilerGeneratedAttribute]
internal static bool <SupportsCompilation>g__ExceedsMaxDepthAllowedDepth|67_0(RegexNode node, int allowedDepth);
}
internal enum System.Text.RegularExpressions.RegexNodeKind : Enum {
    public byte value__;
    public static RegexNodeKind Unknown;
    public static RegexNodeKind One;
    public static RegexNodeKind Notone;
    public static RegexNodeKind Set;
    public static RegexNodeKind Multi;
    public static RegexNodeKind Oneloop;
    public static RegexNodeKind Notoneloop;
    public static RegexNodeKind Setloop;
    public static RegexNodeKind Onelazy;
    public static RegexNodeKind Notonelazy;
    public static RegexNodeKind Setlazy;
    public static RegexNodeKind Oneloopatomic;
    public static RegexNodeKind Notoneloopatomic;
    public static RegexNodeKind Setloopatomic;
    public static RegexNodeKind Backreference;
    public static RegexNodeKind Bol;
    public static RegexNodeKind Eol;
    public static RegexNodeKind Boundary;
    public static RegexNodeKind NonBoundary;
    public static RegexNodeKind ECMABoundary;
    public static RegexNodeKind NonECMABoundary;
    public static RegexNodeKind Beginning;
    public static RegexNodeKind Start;
    public static RegexNodeKind EndZ;
    public static RegexNodeKind End;
    public static RegexNodeKind UpdateBumpalong;
    public static RegexNodeKind Nothing;
    public static RegexNodeKind Empty;
    public static RegexNodeKind Alternate;
    public static RegexNodeKind Concatenate;
    public static RegexNodeKind Loop;
    public static RegexNodeKind Lazyloop;
    public static RegexNodeKind Capture;
    public static RegexNodeKind Group;
    public static RegexNodeKind Atomic;
    public static RegexNodeKind PositiveLookaround;
    public static RegexNodeKind NegativeLookaround;
    public static RegexNodeKind BackreferenceConditional;
    public static RegexNodeKind ExpressionConditional;
}
internal enum System.Text.RegularExpressions.RegexOpcode : Enum {
    public int value__;
    public static RegexOpcode Onerep;
    public static RegexOpcode Notonerep;
    public static RegexOpcode Setrep;
    public static RegexOpcode Oneloop;
    public static RegexOpcode Notoneloop;
    public static RegexOpcode Setloop;
    public static RegexOpcode Onelazy;
    public static RegexOpcode Notonelazy;
    public static RegexOpcode Setlazy;
    public static RegexOpcode One;
    public static RegexOpcode Notone;
    public static RegexOpcode Set;
    public static RegexOpcode Multi;
    public static RegexOpcode Backreference;
    public static RegexOpcode Bol;
    public static RegexOpcode Eol;
    public static RegexOpcode Boundary;
    public static RegexOpcode NonBoundary;
    public static RegexOpcode Beginning;
    public static RegexOpcode Start;
    public static RegexOpcode EndZ;
    public static RegexOpcode End;
    public static RegexOpcode Nothing;
    public static RegexOpcode ECMABoundary;
    public static RegexOpcode NonECMABoundary;
    public static RegexOpcode Oneloopatomic;
    public static RegexOpcode Notoneloopatomic;
    public static RegexOpcode Setloopatomic;
    public static RegexOpcode UpdateBumpalong;
    public static RegexOpcode Lazybranch;
    public static RegexOpcode Branchmark;
    public static RegexOpcode Lazybranchmark;
    public static RegexOpcode Nullcount;
    public static RegexOpcode Setcount;
    public static RegexOpcode Branchcount;
    public static RegexOpcode Lazybranchcount;
    public static RegexOpcode Nullmark;
    public static RegexOpcode Setmark;
    public static RegexOpcode Capturemark;
    public static RegexOpcode Getmark;
    public static RegexOpcode Setjump;
    public static RegexOpcode Backjump;
    public static RegexOpcode Forejump;
    public static RegexOpcode TestBackreference;
    public static RegexOpcode Goto;
    public static RegexOpcode Stop;
    public static RegexOpcode OperatorMask;
    public static RegexOpcode RightToLeft;
    public static RegexOpcode Backtracking;
    public static RegexOpcode BacktrackingSecond;
    public static RegexOpcode CaseInsensitive;
}
[FlagsAttribute]
public enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions None;
    public static RegexOptions IgnoreCase;
    public static RegexOptions Multiline;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions Compiled;
    public static RegexOptions Singleline;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions RightToLeft;
    public static RegexOptions ECMAScript;
    public static RegexOptions CultureInvariant;
    public static RegexOptions NonBacktracking;
}
public enum System.Text.RegularExpressions.RegexParseError : Enum {
    public int value__;
    public static RegexParseError Unknown;
    public static RegexParseError AlternationHasTooManyConditions;
    public static RegexParseError AlternationHasMalformedCondition;
    public static RegexParseError InvalidUnicodePropertyEscape;
    public static RegexParseError MalformedUnicodePropertyEscape;
    public static RegexParseError UnrecognizedEscape;
    public static RegexParseError UnrecognizedControlCharacter;
    public static RegexParseError MissingControlCharacter;
    public static RegexParseError InsufficientOrInvalidHexDigits;
    public static RegexParseError QuantifierOrCaptureGroupOutOfRange;
    public static RegexParseError UndefinedNamedReference;
    public static RegexParseError UndefinedNumberedReference;
    public static RegexParseError MalformedNamedReference;
    public static RegexParseError UnescapedEndingBackslash;
    public static RegexParseError UnterminatedComment;
    public static RegexParseError InvalidGroupingConstruct;
    public static RegexParseError AlternationHasNamedCapture;
    public static RegexParseError AlternationHasComment;
    public static RegexParseError AlternationHasMalformedReference;
    public static RegexParseError AlternationHasUndefinedReference;
    public static RegexParseError CaptureGroupNameInvalid;
    public static RegexParseError CaptureGroupOfZero;
    public static RegexParseError UnterminatedBracket;
    public static RegexParseError ExclusionGroupNotLast;
    public static RegexParseError ReversedCharacterRange;
    public static RegexParseError ShorthandClassInCharacterRange;
    public static RegexParseError InsufficientClosingParentheses;
    public static RegexParseError ReversedQuantifierRange;
    public static RegexParseError NestedQuantifiersNotParenthesized;
    public static RegexParseError QuantifierAfterNothing;
    public static RegexParseError InsufficientOpeningParentheses;
    public static RegexParseError UnrecognizedUnicodeProperty;
}
public class System.Text.RegularExpressions.RegexParseException : ArgumentException {
    [CompilerGeneratedAttribute]
private RegexParseError <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public RegexParseError Error { get; }
    public int Offset { get; }
    internal RegexParseException(RegexParseError error, int offset, string message);
    [CompilerGeneratedAttribute]
public RegexParseError get_Error();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Text.RegularExpressions.RegexParser : ValueType {
    private RegexNode _stack;
    private RegexNode _group;
    private RegexNode _alternation;
    private RegexNode _concatenation;
    private RegexNode _unit;
    private string _pattern;
    private int _pos;
    private CultureInfo _culture;
    private RegexCaseBehavior _caseBehavior;
    private bool _hasIgnoreCaseBackreferenceNodes;
    private int _autocap;
    private int _capcount;
    private int _captop;
    private int _capsize;
    private Hashtable _caps;
    private Hashtable _capnames;
    private Int32[] _capnumlist;
    private List`1<string> _capnamelist;
    private RegexOptions _options;
    private ValueListBuilder`1<int> _optionsStack;
    private bool _ignoreNextParen;
    private static SearchValues`1<char> s_metachars;
    private static ReadOnlySpan`1<byte> Category { get; }
    private RegexParser(string pattern, RegexOptions options, CultureInfo culture, Hashtable caps, int capsize, Hashtable capnames, Span`1<int> optionSpan);
    private static RegexParser();
    internal static CultureInfo GetTargetCulture(RegexOptions options);
    public static RegexTree Parse(string pattern, RegexOptions options, CultureInfo culture);
    public static RegexReplacement ParseReplacement(string pattern, RegexOptions options, Hashtable caps, int capsize, Hashtable capnames);
    public static string Escape(string input);
    private static string EscapeImpl(ReadOnlySpan`1<char> input, int indexOfMetachar);
    public static string Unescape(string input);
    private static string UnescapeImpl(string input, int i);
    private void Reset(RegexOptions options);
    public void Dispose();
    private RegexNode ScanRegex();
    private RegexNode ScanReplacement();
    private RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
    private RegexNode ScanGroupOpen();
    private void ScanBlank();
    private RegexNode ScanBackslash(bool scanOnly);
    private RegexNode ScanBasicBackslash(bool scanOnly);
    private RegexNode ScanDollar();
    private string ScanCapname();
    private char ScanOctal();
    private int ScanDecimal();
    private char ScanHex(int c);
    private char ScanControl();
    private void ScanOptions();
    private char ScanCharEscape();
    private string ParseProperty();
    [IsReadOnlyAttribute]
private RegexNodeKind TypeFromCode(char ch);
    private void CountCaptures(RegexOptions& optionsFoundInPattern);
    private void NoteCaptureSlot(int i, int pos);
    private void NoteCaptureName(string name, int pos);
    private void AssignNameSlots();
    [IsReadOnlyAttribute]
private bool IsCaptureSlot(int i);
    internal static int MapCaptureNumber(int capnum, Hashtable caps);
    private static ReadOnlySpan`1<byte> get_Category();
    private static int IndexOfMetachar(ReadOnlySpan`1<char> input);
    private static bool IsSpecial(char ch);
    private static bool IsSpecialOrSpace(char ch);
    private static bool IsQuantifier(char ch);
    private static bool IsSpace(char ch);
    [IsReadOnlyAttribute]
private bool IsTrueQuantifier();
    private void AddToConcatenate(int pos, int cch, bool isReplacement);
    private void PushGroup();
    private void PopGroup();
    private void StartGroup(RegexNode openGroup);
    private void AddAlternate();
    private void AddGroup();
    [IsReadOnlyAttribute]
private RegexParseException MakeException(RegexParseError error, string message);
    internal static string GroupNameFromNumber(Hashtable caps, String[] capslist, int capsize, int i);
}
internal static class System.Text.RegularExpressions.RegexPrefixAnalyzer : object {
    private static ReadOnlySpan`1<float> Frequency { get; }
    public static string FindPrefix(RegexNode node);
    public static string FindPrefixOrdinalCaseInsensitive(RegexNode node);
    public static List`1<FixedDistanceSet> FindFixedDistanceSets(RegexNode root, bool thorough);
    public static void SortFixedDistanceSetsByQuality(List`1<FixedDistanceSet> results);
    public static string FindFirstCharClass(RegexNode root);
    public static Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> FindLiteralFollowingLeadingLoop(RegexNode node);
    public static RegexNodeKind FindLeadingAnchor(RegexNode node);
    public static RegexNodeKind FindTrailingAnchor(RegexNode node);
    private static RegexNodeKind FindLeadingOrTrailingAnchor(RegexNode node, bool leading);
    private static ReadOnlySpan`1<float> get_Frequency();
    [CompilerGeneratedAttribute]
internal static bool <FindPrefix>g__Process|0_0(RegexNode node, ValueStringBuilder& vsb);
    [CompilerGeneratedAttribute]
internal static bool <FindFixedDistanceSets>g__TryFindRawFixedSets|2_0(RegexNode node, List`1<FixedDistanceSet> results, Int32& distance, bool thorough);
    [CompilerGeneratedAttribute]
internal static float <SortFixedDistanceSetsByQuality>g__SumFrequencies|3_2(Char[] chars);
    [CompilerGeneratedAttribute]
internal static int <SortFixedDistanceSetsByQuality>g__GetRangeLength|3_1(ValueTuple`2<char, char> range, bool negated);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <FindFirstCharClass>g__TryFindFirstCharClass|4_0(RegexNode node, RegexCharClass& cc);
}
internal class System.Text.RegularExpressions.RegexReplacement : object {
    private String[] _strings;
    private Int32[] _rules;
    private bool _hasBackreferences;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public RegexReplacement(string rep, RegexNode concat, Hashtable _caps);
    public static RegexReplacement GetOrCreate(WeakReference`1<RegexReplacement> replRef, string replacement, Hashtable caps, int capsize, Hashtable capnames, RegexOptions roptions);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public void ReplacementImpl(StructListBuilder`1& segments, Match match);
    public void ReplacementImplRTL(StructListBuilder`1& segments, Match match);
    public string Replace(Regex regex, string input, int count, int startat);
    private static string ReplaceSimpleText(Regex regex, string input, string replacement, int count, int startat);
    private string ReplaceNonSimpleText(Regex regex, string input, int count, int startat);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunner : object {
    protected internal int runtextbeg;
    protected internal int runtextend;
    protected internal int runtextstart;
    protected internal string runtext;
    protected internal int runtextpos;
    protected internal Int32[] runtrack;
    protected internal int runtrackpos;
    protected internal Int32[] runstack;
    protected internal int runstackpos;
    protected internal Int32[] runcrawl;
    protected internal int runcrawlpos;
    protected internal int runtrackcount;
    protected internal Match runmatch;
    protected internal Regex runregex;
    private protected RegexRunnerMode _mode;
    private int _timeout;
    private bool _checkTimeout;
    private long _timeoutOccursAt;
    [NullableContextAttribute("0")]
protected internal virtual void Scan(ReadOnlySpan`1<char> text);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
protected Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
    private Match InternalScan(Regex regex, int textbeg, int textend);
    internal void InitializeForScan(Regex regex, ReadOnlySpan`1<char> text, int textstart, RegexRunnerMode mode);
    internal void InitializeTimeout(TimeSpan timeout);
    protected internal void CheckTimeout();
    protected virtual void Go();
    protected virtual bool FindFirstChar();
    protected virtual void InitTrackCount();
    protected void EnsureStorage();
    protected bool IsBoundary(int index, int startpos, int endpos);
    internal static bool IsBoundary(ReadOnlySpan`1<char> inputSpan, int index);
    internal static bool IsWordChar(char ch);
    protected bool IsECMABoundary(int index, int startpos, int endpos);
    internal static bool IsECMABoundary(ReadOnlySpan`1<char> inputSpan, int index);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete mechanisms for Regex extensibility. It is not supported.")]
protected static bool CharInSet(char ch, string set, string category);
    [NullableContextAttribute("1")]
public static bool CharInClass(char ch, string charClass);
    protected void DoubleTrack();
    protected void DoubleStack();
    protected void DoubleCrawl();
    protected void Crawl(int i);
    protected int Popcrawl();
    protected int Crawlpos();
    protected void Capture(int capnum, int start, int end);
    protected void TransferCapture(int capnum, int uncapnum, int start, int end);
    protected void Uncapture();
    protected bool IsMatched(int cap);
    protected int MatchIndex(int cap);
    protected int MatchLength(int cap);
    [CompilerGeneratedAttribute]
private void <InitializeTimeout>g__ConfigureTimeout|24_0(TimeSpan timeout);
    [CompilerGeneratedAttribute]
private void <CheckTimeout>g__ThrowRegexTimeout|25_0();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunnerFactory : object {
    [NullableContextAttribute("1")]
protected internal abstract virtual RegexRunner CreateInstance();
}
internal enum System.Text.RegularExpressions.RegexRunnerMode : Enum {
    public int value__;
    public static RegexRunnerMode ExistenceRequired;
    public static RegexRunnerMode BoundsRequired;
    public static RegexRunnerMode FullMatchRequired;
}
internal class System.Text.RegularExpressions.RegexTree : object {
    public RegexOptions Options;
    public RegexNode Root;
    public RegexFindOptimizations FindOptimizations;
    public int CaptureCount;
    public CultureInfo Culture;
    public String[] CaptureNames;
    public Hashtable CaptureNameToNumberMapping;
    public Hashtable CaptureNumberSparseMapping;
    internal RegexTree(RegexNode root, int captureCount, String[] captureNames, Hashtable captureNameToNumberMapping, Hashtable captureNumberSparseMapping, RegexOptions options, CultureInfo culture);
}
internal static class System.Text.RegularExpressions.RegexTreeAnalyzer : object {
    public static AnalysisResults Analyze(RegexTree regexTree);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__TryAnalyze|0_0(RegexNode node, AnalysisResults results, bool isAtomicByAncestor, bool isInLoop);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Text.RegularExpressions.RegexWriter : ValueType {
    private RegexTree _tree;
    private Dictionary`2<string, int> _stringTable;
    private ValueListBuilder`1<int> _emitted;
    private ValueListBuilder`1<int> _intStack;
    private int _trackCount;
    private RegexWriter(RegexTree tree, Span`1<int> emittedSpan, Span`1<int> intStackSpan);
    public void Dispose();
    public static RegexInterpreterCode Write(RegexTree tree);
    private RegexInterpreterCode EmitCode();
    private void PatchJump(int offset, int jumpDest);
    private void Emit(RegexOpcode op);
    private void Emit(RegexOpcode op, int opd1);
    private void Emit(RegexOpcode op, int opd1, int opd2);
    private int StringCode(string str);
    private void EmitFragment(RegexNodeKind nodeType, RegexNode node, int curIndex);
}
internal class System.Text.RegularExpressions.Symbolic.BDD : object {
    public static BDD True;
    public static BDD False;
    public BDD One;
    public BDD Zero;
    public int Ordinal;
    private int _hashcode;
    [MemberNotNullWhenAttribute("False", "One")]
[MemberNotNullWhenAttribute("False", "Zero")]
public bool IsLeaf { get; }
    public bool IsFull { get; }
    public bool IsEmpty { get; }
    internal BDD(int ordinal, BDD one, BDD zero);
    private static BDD();
    [MemberNotNullWhenAttribute("False", "One")]
[MemberNotNullWhenAttribute("False", "Zero")]
public bool get_IsLeaf();
    public bool get_IsFull();
    public bool get_IsEmpty();
    public ulong GetMin();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BDD bdd);
    public static BDD Deserialize(ReadOnlySpan`1<byte> bytes);
    private static void BitLayout(int ordinal_bits, int node_bits, Int32& zero_node_shift, Int32& one_node_shift, Int32& ordinal_shift);
    public int Find(int input);
    public bool IsEssentiallyBoolean(BDD& terminalActingAsTrue);
    public sealed virtual int CompareTo(BDD other);
    [CompilerGeneratedAttribute]
internal static long <Deserialize>g__Get|19_0(int bytesPerLong, ReadOnlySpan`1<byte> bytes, int i);
}
[DefaultMemberAttribute("Item")]
internal class System.Text.RegularExpressions.Symbolic.BitVector : ValueType {
    private UInt64[] _blocks;
    public int Length;
    private Nullable`1<int> _hashcode;
    private BitVector(int length);
    private BitVector(int length, UInt64[] blocks);
    public static BitVector CreateFalse(int length);
    public static BitVector CreateTrue(int length);
    public static BitVector CreateSingleBit(int length, int i);
    private void Set(int i);
    public static BitVector And(BitVector x, BitVector y);
    public static BitVector Or(BitVector x, BitVector y);
    public static BitVector Or(ReadOnlySpan`1<BitVector> bitVectors);
    public static BitVector Not(BitVector x);
    private void ClearRemainderBits();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BitVector other);
    public sealed virtual int CompareTo(BitVector other);
}
internal class System.Text.RegularExpressions.Symbolic.BitVectorSolver : object {
    private BDD[] _minterms;
    internal MintermClassifier _classifier;
    private BitVector[] _mintermVectors;
    [CompilerGeneratedAttribute]
private BitVector <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private BitVector <Full>k__BackingField;
    public BitVector Empty { get; }
    public BitVector Full { get; }
    public BitVectorSolver(BDD[] minterms, CharSetSolver solver);
    [CompilerGeneratedAttribute]
public sealed virtual BitVector get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual BitVector get_Full();
    public sealed virtual bool IsFull(BitVector set);
    public sealed virtual bool IsEmpty(BitVector set);
    public sealed virtual BitVector And(BitVector set1, BitVector set2);
    public sealed virtual BitVector Not(BitVector set);
    public sealed virtual BitVector Or(ReadOnlySpan`1<BitVector> sets);
    public sealed virtual BitVector Or(BitVector set1, BitVector set2);
    public sealed virtual BitVector ConvertFromBDD(BDD set, CharSetSolver solver);
    public sealed virtual BitVector[] GetMinterms();
}
internal static class System.Text.RegularExpressions.Symbolic.CharKind : object {
    internal static UInt32 Prev(UInt32 context);
    internal static UInt32 Next(UInt32 context);
    internal static UInt32 Context(UInt32 prevKind, UInt32 nextKind);
}
internal class System.Text.RegularExpressions.Symbolic.CharSetSolver : object {
    private static BDD[] s_asciiCache;
    private static BDD s_nonAscii;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`3<int, BDD, BDD>, BDD> _bddCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`3<int, BDD, BDD>, BDD> _operationCache;
    public BDD NonAscii { get; }
    public BDD Full { get; }
    public BDD Empty { get; }
    private static CharSetSolver();
    public BDD get_NonAscii();
    public BDD CreateBDDFromChar(char c);
    public sealed virtual BDD ConvertFromBDD(BDD set, CharSetSolver _);
    private sealed virtual override BDD[] System.Text.RegularExpressions.Symbolic.ISolver<System.Text.RegularExpressions.Symbolic.BDD>.GetMinterms();
    public sealed virtual BDD Or(BDD set1, BDD set2);
    public sealed virtual BDD Or(ReadOnlySpan`1<BDD> sets);
    public sealed virtual BDD And(BDD a, BDD b);
    public BDD And(ReadOnlySpan`1<BDD> sets);
    public sealed virtual BDD Not(BDD set);
    private BDD ApplyBinaryOp(BooleanOperation op, BDD set1, BDD set2);
    public sealed virtual BDD get_Full();
    public sealed virtual BDD get_Empty();
    public sealed virtual bool IsFull(BDD set);
    public sealed virtual bool IsEmpty(BDD set);
    public BDD CreateBDDFromRange(char lower, char upper);
    public BDD ReplaceTrue(BDD bdd, int terminal);
    private BDD GetOrCreateBDD(int ordinal, BDD one, BDD zero);
    [CompilerGeneratedAttribute]
private BDD <CreateBDDFromChar>g__CreateBdd|6_0(ushort c);
    [CompilerGeneratedAttribute]
private BDD <CreateBDDFromRange>g__CreateBDDFromRangeImpl|21_0(UInt32 lower, UInt32 upper, int maxBit);
    [CompilerGeneratedAttribute]
private BDD <ReplaceTrue>g__ReplaceTrueImpl|22_0(BDD bdd, BDD leaf, Dictionary`2<BDD, BDD> cache);
}
[IsReadOnlyAttribute]
internal class System.Text.RegularExpressions.Symbolic.DerivativeEffect : ValueType {
    [CompilerGeneratedAttribute]
private DerivativeEffectKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaptureNumber>k__BackingField;
    public DerivativeEffectKind Kind { get; }
    public int CaptureNumber { get; }
    public DerivativeEffect(DerivativeEffectKind kind, int captureNumber);
    [CompilerGeneratedAttribute]
public DerivativeEffectKind get_Kind();
    [CompilerGeneratedAttribute]
public int get_CaptureNumber();
}
internal enum System.Text.RegularExpressions.Symbolic.DerivativeEffectKind : Enum {
    public int value__;
    public static DerivativeEffectKind CaptureStart;
    public static DerivativeEffectKind CaptureEnd;
}
internal class System.Text.RegularExpressions.Symbolic.DoublyLinkedList`1 : object {
    private Node<T> _first;
    private Node<T> _last;
    private int _size;
    public int Count { get; }
    internal T FirstElement { get; }
    public int get_Count();
    internal T get_FirstElement();
    public void AddLast(DoublyLinkedList`1<T> other);
    public void AddLast(T elem);
    public void AddFirst(T elem);
    [IteratorStateMachineAttribute("System.Text.RegularExpressions.Symbolic.DoublyLinkedList`1/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface System.Text.RegularExpressions.Symbolic.ISolver`1 {
    public TSet Full { get; }
    public TSet Empty { get; }
    public abstract virtual TSet ConvertFromBDD(BDD set, CharSetSolver solver);
    public abstract virtual TSet[] GetMinterms();
    public abstract virtual TSet get_Full();
    public abstract virtual TSet get_Empty();
    public abstract virtual TSet And(TSet set1, TSet set2);
    public abstract virtual TSet Or(TSet set1, TSet set2);
    public abstract virtual TSet Or(ReadOnlySpan`1<TSet> sets);
    public abstract virtual TSet Not(TSet set);
    public abstract virtual bool IsEmpty(TSet set);
    public abstract virtual bool IsFull(TSet set);
}
internal class System.Text.RegularExpressions.Symbolic.MatchingState`1 : object {
    [CompilerGeneratedAttribute]
private SymbolicRegexNode`1<TSet> <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PrevCharKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    internal SymbolicRegexNode`1<TSet> Node { get; }
    internal UInt32 PrevCharKind { get; }
    internal int Id { get; internal set; }
    internal bool StartsWithLineAnchor { get; }
    internal MatchingState`1(SymbolicRegexNode`1<TSet> node, UInt32 prevCharKind);
    [CompilerGeneratedAttribute]
internal SymbolicRegexNode`1<TSet> get_Node();
    [CompilerGeneratedAttribute]
internal UInt32 get_PrevCharKind();
    [CompilerGeneratedAttribute]
internal int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    internal bool IsDeadend(ISolver`1<TSet> solver);
    internal int FixedLength(UInt32 nextCharKind);
    internal bool get_StartsWithLineAnchor();
    internal SymbolicRegexNode`1<TSet> Next(SymbolicRegexBuilder`1<TSet> builder, TSet minterm, UInt32 nextCharKind);
    internal List`1<ValueTuple`2<SymbolicRegexNode`1<TSet>, DerivativeEffect[]>> NfaNextWithEffects(SymbolicRegexBuilder`1<TSet> builder, TSet minterm, UInt32 nextCharKind);
    internal bool IsNullableFor(UInt32 nextCharKind);
    internal StateFlags BuildStateFlags(ISolver`1<TSet> solver, bool isInitial);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Text.RegularExpressions.Symbolic.MintermClassifier : object {
    private static Int32[] AllAsciiIsZeroMintermArray;
    private Int32[] _ascii;
    private BDD _nonAscii;
    public MintermClassifier(BDD[] minterms, CharSetSolver solver);
    private static MintermClassifier();
    public int GetMintermID(int c);
}
internal static class System.Text.RegularExpressions.Symbolic.MintermGenerator`1 : object {
    public static List`1<TSet> GenerateMinterms(ISolver`1<TSet> solver, HashSet`1<TSet> sets);
}
internal class System.Text.RegularExpressions.Symbolic.RegexNodeConverter : object {
    private Hashtable _captureSparseMapping;
    internal SymbolicRegexBuilder`1<BDD> _builder;
    private Dictionary`2<string, BDD> _setBddCache;
    public RegexNodeConverter(SymbolicRegexBuilder`1<BDD> builder, Hashtable captureSparseMapping);
    internal SymbolicRegexNode`1<BDD> ConvertToSymbolicRegexNode(RegexNode root);
    private BDD CreateBDDFromSetString(string set);
    [CompilerGeneratedAttribute]
internal static string <ConvertToSymbolicRegexNode>g__UnexpectedNodeType|4_4(RegexNode node);
    [CompilerGeneratedAttribute]
private void <ConvertToSymbolicRegexNode>g__EnsureNewlinePredicateInitialized|4_0();
    [CompilerGeneratedAttribute]
private void <ConvertToSymbolicRegexNode>g__EnsureWordLetterPredicateInitialized|4_1();
    [CompilerGeneratedAttribute]
private SymbolicRegexNode`1<BDD> <ConvertToSymbolicRegexNode>g__ConvertSet|4_2(RegexNode node);
    [CompilerGeneratedAttribute]
internal static DoublyLinkedList`1[] <ConvertToSymbolicRegexNode>g__CreateChildResultArray|4_3(int k);
    [CompilerGeneratedAttribute]
private BDD <CreateBDDFromSetString>g__Compute|5_0(string set);
    [CompilerGeneratedAttribute]
internal static BDD <CreateBDDFromSetString>g__MapCategoryCodeSetToCondition|5_1(Span`1<bool> catCodes, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static BDD <CreateBDDFromSetString>g__MapCategoryCodeToCondition|5_2(UnicodeCategory code);
}
internal class System.Text.RegularExpressions.Symbolic.SparseIntMap`1 : object {
    private List`1<KeyValuePair`2<int, T>> _dense;
    private Int32[] _sparse;
    public int Count { get; }
    public List`1<KeyValuePair`2<int, T>> Values { get; }
    public void Clear();
    public int get_Count();
    public List`1<KeyValuePair`2<int, T>> get_Values();
    public bool Add(int key, Int32& index);
    public bool Add(int key, T value);
    public void Update(int index, int key, T value);
    private bool GrowAndAdd(int key, Int32& index);
}
[FlagsAttribute]
internal enum System.Text.RegularExpressions.Symbolic.StateFlags : Enum {
    public byte value__;
    public static StateFlags IsInitialFlag;
    public static StateFlags IsDeadendFlag;
    public static StateFlags IsNullableFlag;
    public static StateFlags CanBeNullableFlag;
    public static StateFlags SimulatesBacktrackingFlag;
}
[ExtensionAttribute]
internal static class System.Text.RegularExpressions.Symbolic.StateFlagsExtensions : object {
    [ExtensionAttribute]
internal static bool IsInitial(StateFlags info);
    [ExtensionAttribute]
internal static bool IsDeadend(StateFlags info);
    [ExtensionAttribute]
internal static bool IsNullable(StateFlags info);
    [ExtensionAttribute]
internal static bool CanBeNullable(StateFlags info);
    [ExtensionAttribute]
internal static bool SimulatesBacktracking(StateFlags info);
}
[IsReadOnlyAttribute]
internal class System.Text.RegularExpressions.Symbolic.SymbolicMatch : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <CaptureStarts>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <CaptureEnds>k__BackingField;
    internal static SymbolicMatch NoMatch { get; }
    internal static SymbolicMatch MatchExists { get; }
    public int Index { get; }
    public int Length { get; }
    public bool Success { get; }
    public Int32[] CaptureStarts { get; }
    public Int32[] CaptureEnds { get; }
    public SymbolicMatch(int index, int length, Int32[] captureStarts, Int32[] captureEnds);
    internal static SymbolicMatch get_NoMatch();
    internal static SymbolicMatch get_MatchExists();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_Success();
    [CompilerGeneratedAttribute]
public Int32[] get_CaptureStarts();
    [CompilerGeneratedAttribute]
public Int32[] get_CaptureEnds();
}
internal class System.Text.RegularExpressions.Symbolic.SymbolicRegexBuilder`1 : object {
    internal CharSetSolver _charSetSolver;
    internal ISolver`1<TSet> _solver;
    internal SymbolicRegexNode`1<TSet> _nothing;
    internal SymbolicRegexNode`1<TSet> _anyChar;
    internal SymbolicRegexNode`1<TSet> _anyStar;
    internal SymbolicRegexNode`1<TSet> _anyStarLazy;
    private SymbolicRegexNode`1<TSet> _epsilon;
    private SymbolicRegexNode`1<TSet> _beginningAnchor;
    private SymbolicRegexNode`1<TSet> _endAnchor;
    private SymbolicRegexNode`1<TSet> _endAnchorZ;
    private SymbolicRegexNode`1<TSet> _endAnchorZReverse;
    private SymbolicRegexNode`1<TSet> _bolAnchor;
    private SymbolicRegexNode`1<TSet> _eolAnchor;
    private SymbolicRegexNode`1<TSet> _wbAnchor;
    private SymbolicRegexNode`1<TSet> _nwbAnchor;
    internal TSet _wordLetterForBoundariesSet;
    internal TSet _newLineSet;
    private Dictionary`2<TSet, SymbolicRegexNode`1<TSet>> _singletonCache;
    internal Dictionary`2<NodeCacheKey<TSet>, SymbolicRegexNode`1<TSet>> _nodeCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<ValueTuple`3<SymbolicRegexNode`1<TSet>, TSet, UInt32>, SymbolicRegexNode`1<TSet>> _derivativeCache;
    internal Dictionary`2<ValueTuple`2<SymbolicRegexNode`1<TSet>, UInt32>, SymbolicRegexNode`1<TSet>> _pruneLowerPriorityThanNullabilityCache;
    internal Dictionary`2<ValueTuple`2<SymbolicRegexNode`1<TSet>, SymbolicRegexNode`1<TSet>>, bool> _subsumptionCache;
    internal SymbolicRegexNode`1<TSet> Epsilon { get; }
    internal SymbolicRegexNode`1<TSet> BeginningAnchor { get; }
    internal SymbolicRegexNode`1<TSet> EndAnchor { get; }
    internal SymbolicRegexNode`1<TSet> EndAnchorZ { get; }
    internal SymbolicRegexNode`1<TSet> EndAnchorZReverse { get; }
    internal SymbolicRegexNode`1<TSet> BolAnchor { get; }
    internal SymbolicRegexNode`1<TSet> EolAnchor { get; }
    internal SymbolicRegexNode`1<TSet> BoundaryAnchor { get; }
    internal SymbolicRegexNode`1<TSet> NonBoundaryAnchor { get; }
    internal SymbolicRegexBuilder`1(ISolver`1<TSet> solver, CharSetSolver charSetSolver);
    internal SymbolicRegexNode`1<TSet> get_Epsilon();
    internal SymbolicRegexNode`1<TSet> get_BeginningAnchor();
    internal SymbolicRegexNode`1<TSet> get_EndAnchor();
    internal SymbolicRegexNode`1<TSet> get_EndAnchorZ();
    internal SymbolicRegexNode`1<TSet> get_EndAnchorZReverse();
    internal SymbolicRegexNode`1<TSet> get_BolAnchor();
    internal SymbolicRegexNode`1<TSet> get_EolAnchor();
    internal SymbolicRegexNode`1<TSet> get_BoundaryAnchor();
    internal SymbolicRegexNode`1<TSet> get_NonBoundaryAnchor();
    internal SymbolicRegexNode`1<TSet> Alternate(List`1<SymbolicRegexNode`1<TSet>> nodes);
    internal SymbolicRegexNode`1<TSet> CreateConcatAlreadyReversed(IEnumerable`1<SymbolicRegexNode`1<TSet>> nodes);
    internal SymbolicRegexNode`1<TSet> CreateConcat(SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right);
    internal SymbolicRegexNode`1<TSet> CreateLoop(SymbolicRegexNode`1<TSet> node, bool isLazy, int lower, int upper);
    internal SymbolicRegexNode`1<TSet> CreateSingleton(TSet set);
    internal SymbolicRegexNode`1<TSet> CreateFixedLengthMarker(int length);
    internal SymbolicRegexNode`1<TSet> CreateEffect(SymbolicRegexNode`1<TSet> node, SymbolicRegexNode`1<TSet> effectNode);
    internal SymbolicRegexNode`1<TSet> CreateCaptureStart(int captureNum);
    internal SymbolicRegexNode`1<TSet> CreateCaptureEnd(int captureNum);
    internal SymbolicRegexNode`1<TSet> CreateDisableBacktrackingSimulation(SymbolicRegexNode`1<TSet> child);
    internal SymbolicRegexNode`1<TNewSet> Transform(SymbolicRegexNode`1<TSet> node, SymbolicRegexBuilder`1<TNewSet> builder, Func`3<SymbolicRegexBuilder`1<TNewSet>, TSet, TNewSet> setTransformer);
}
[IsReadOnlyAttribute]
internal class System.Text.RegularExpressions.Symbolic.SymbolicRegexInfo : ValueType {
    private UInt32 _info;
    public bool IsNullable { get; }
    public bool CanBeNullable { get; }
    public bool StartsWithLineAnchor { get; }
    public bool ContainsLineAnchor { get; }
    public bool StartsWithSomeAnchor { get; }
    public bool ContainsSomeAnchor { get; }
    public bool IsLazyLoop { get; }
    public bool IsHighPriorityNullable { get; }
    public bool ContainsEffect { get; }
    private SymbolicRegexInfo(UInt32 i);
    private static SymbolicRegexInfo Create(bool isAlwaysNullable, bool canBeNullable, bool startsWithLineAnchor, bool containsLineAnchor, bool startsWithSomeAnchor, bool containsSomeAnchor, bool isHighPriorityNullable, bool containsEffect);
    public bool get_IsNullable();
    public bool get_CanBeNullable();
    public bool get_StartsWithLineAnchor();
    public bool get_ContainsLineAnchor();
    public bool get_StartsWithSomeAnchor();
    public bool get_ContainsSomeAnchor();
    public bool get_IsLazyLoop();
    public bool get_IsHighPriorityNullable();
    public bool get_ContainsEffect();
    public static SymbolicRegexInfo Epsilon();
    public static SymbolicRegexInfo Anchor(bool isLineAnchor);
    public static SymbolicRegexInfo Alternate(SymbolicRegexInfo left_info, SymbolicRegexInfo right_info);
    public static SymbolicRegexInfo Concat(SymbolicRegexInfo left_info, SymbolicRegexInfo right_info);
    public static SymbolicRegexInfo Loop(SymbolicRegexInfo body_info, int lowerBound, bool isLazy);
    public static SymbolicRegexInfo Effect(SymbolicRegexInfo childInfo);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolicRegexInfo other);
    public virtual int GetHashCode();
}
internal abstract class System.Text.RegularExpressions.Symbolic.SymbolicRegexMatcher : object {
}
internal class System.Text.RegularExpressions.Symbolic.SymbolicRegexMatcher`1 : SymbolicRegexMatcher {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<SymbolicRegexNode`1<TSet>, UInt32>, MatchingState`1<TSet>> _stateCache;
    private MatchingState`1[] _stateArray;
    private StateFlags[] _stateFlagsArray;
    private Int32[] _dfaDelta;
    private Int32[] _nfaCoreIdArray;
    private Dictionary`2<int, int> _nfaIdByCoreId;
    private Int32[][] _nfaDelta;
    private ValueTuple`2[][] _capturingNfaDelta;
    internal SymbolicRegexBuilder`1<TSet> _builder;
    private MintermClassifier _mintermClassifier;
    internal SymbolicRegexNode`1<TSet> _dotStarredPattern;
    internal SymbolicRegexNode`1<TSet> _pattern;
    internal SymbolicRegexNode`1<TSet> _reversePattern;
    private bool _checkTimeout;
    private int _timeout;
    private RegexFindOptimizations _findOpts;
    private MatchingState`1[] _initialStates;
    private MatchingState`1[] _dotstarredInitialStates;
    private MatchingState`1[] _reverseInitialStates;
    private TSet[] _minterms;
    private UInt32[] _positionKinds;
    private int _mintermsLog;
    private int _capsize;
    internal bool HasSubcaptures { get; }
    private ISolver`1<TSet> Solver { get; }
    private SymbolicRegexMatcher`1(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> rootNode, int captureCount, RegexFindOptimizations findOptimizations, TimeSpan matchTimeout);
    private static void ArrayResizeAndVolatilePublish(T[]& array, int newSize);
    private int DeltaOffset(int stateId, int mintermId);
    private MatchingState`1<TSet> GetOrCreateState(SymbolicRegexNode`1<TSet> node, UInt32 prevCharKind);
    private MatchingState`1<TSet> GetOrCreateState_NoLock(SymbolicRegexNode`1<TSet> node, UInt32 prevCharKind, bool isInitialState);
    private Nullable`1<int> CreateNfaState(SymbolicRegexNode`1<TSet> node, UInt32 prevCharKind);
    private MatchingState`1<TSet> GetState(int stateId);
    private int GetCoreStateId(int nfaStateId);
    private bool TryCreateNewTransition(MatchingState`1<TSet> sourceState, int mintermId, int offset, bool checkThreshold, MatchingState`1& nextState);
    private Int32[] CreateNewNfaTransition(int nfaStateId, int mintermId, int nfaOffset);
    private ValueTuple`2[] CreateNewCapturingTransition(int nfaStateId, int mintermId, int offset);
    private void ForEachNfaState(SymbolicRegexNode`1<TSet> node, UInt32 prevCharKind, T arg, Action`2<int, T> action);
    internal bool get_HasSubcaptures();
    private ISolver`1<TSet> get_Solver();
    public static SymbolicRegexMatcher`1<TSet> Create(int captureCount, RegexFindOptimizations findOptimizations, SymbolicRegexBuilder`1<BDD> bddBuilder, SymbolicRegexNode`1<BDD> rootBddNode, ISolver`1<TSet> solver, TimeSpan matchTimeout);
    internal PerThreadData<TSet> CreatePerThreadData();
    private UInt32 GetPositionKind(int positionId);
    internal TSet GetMintermFromId(int mintermId);
    private UInt32 GetCharKind(ReadOnlySpan`1<char> input, int i);
    private void CheckTimeout(long timeoutOccursAt);
    public SymbolicMatch FindMatch(RegexRunnerMode mode, ReadOnlySpan`1<char> input, int startat, PerThreadData<TSet> perThreadData);
    private int FindEndPosition(ReadOnlySpan`1<char> input, int pos, long timeoutOccursAt, RegexRunnerMode mode, Int32& initialStatePos, Int32& matchLength, PerThreadData<TSet> perThreadData);
    private bool FindEndPositionDeltas(ReadOnlySpan`1<char> input, int length, RegexRunnerMode mode, Int32& posRef, CurrentState& state, Int32& endPosRef, Int32& endStateIdRef, Int32& initialStatePosRef, Int32& initialStatePosCandidateRef);
    private int FindStartPosition(ReadOnlySpan`1<char> input, int i, int matchStartBoundary, PerThreadData<TSet> perThreadData);
    private bool FindStartPositionDeltas(ReadOnlySpan`1<char> input, Int32& i, int startThreshold, CurrentState& state, Int32& lastStart);
    private Registers<TSet> FindSubcaptures(ReadOnlySpan`1<char> input, int i, int iEnd, PerThreadData<TSet> perThreadData);
    [CompilerGeneratedAttribute]
private UInt32 <.ctor>g__CalculateMintermIdKind|44_0(int mintermId);
}
internal class System.Text.RegularExpressions.Symbolic.SymbolicRegexNode`1 : object {
    internal SymbolicRegexNodeKind _kind;
    internal int _lower;
    internal int _upper;
    internal TSet _set;
    internal SymbolicRegexNode`1<TSet> _left;
    internal SymbolicRegexNode`1<TSet> _right;
    internal SymbolicRegexInfo _info;
    private Byte[] _nullabilityCache;
    internal bool IsLazy { get; }
    internal bool IsNullable { get; }
    internal bool CanBeNullable { get; }
    public bool IsStar { get; }
    public bool IsEpsilon { get; }
    internal SymbolicRegexNodeKind Kind { get; }
    private SymbolicRegexNode`1(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNodeKind kind, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, int lower, int upper, TSet set, SymbolicRegexInfo info);
    private static SymbolicRegexNode`1<TSet> Create(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNodeKind kind, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, int lower, int upper, TSet set, SymbolicRegexInfo info);
    internal bool get_IsLazy();
    internal bool IsHighPriorityNullableFor(UInt32 context);
    private static bool IsHighPriorityNullableFor(SymbolicRegexNode`1<TSet> node, UInt32 context);
    internal bool get_IsNullable();
    internal bool get_CanBeNullable();
    public List`1<SymbolicRegexNode`1<TSet>> ToList(List`1<SymbolicRegexNode`1<TSet>> list, SymbolicRegexNodeKind listKind);
    internal bool IsNullableFor(UInt32 context);
    public bool IsAnyStar(ISolver`1<TSet> solver);
    public bool IsNothing(ISolver`1<TSet> solver);
    public bool get_IsStar();
    public bool get_IsEpsilon();
    internal SymbolicRegexNodeKind get_Kind();
    internal static SymbolicRegexNode`1<TSet> CreateFalse(SymbolicRegexBuilder`1<TSet> builder);
    internal static SymbolicRegexNode`1<TSet> CreateTrue(SymbolicRegexBuilder`1<TSet> builder);
    internal static SymbolicRegexNode`1<TSet> CreateFixedLengthMarker(SymbolicRegexBuilder`1<TSet> builder, int length);
    internal static SymbolicRegexNode`1<TSet> CreateEpsilon(SymbolicRegexBuilder`1<TSet> builder);
    internal static SymbolicRegexNode`1<TSet> CreateAnchor(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNodeKind kind);
    internal static SymbolicRegexNode`1<TSet> CreateSingleton(SymbolicRegexBuilder`1<TSet> builder, TSet set);
    internal static SymbolicRegexNode`1<TSet> CreateLoop(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> body, int lower, int upper, bool isLazy);
    internal static SymbolicRegexNode`1<TSet> CreateEffect(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> node, SymbolicRegexNode`1<TSet> effectNode);
    internal static SymbolicRegexNode`1<TSet> CreateCaptureStart(SymbolicRegexBuilder`1<TSet> builder, int captureNum);
    internal static SymbolicRegexNode`1<TSet> CreateCaptureEnd(SymbolicRegexBuilder`1<TSet> builder, int captureNum);
    internal static SymbolicRegexNode`1<TSet> CreateDisableBacktrackingSimulation(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> child);
    internal static SymbolicRegexNode`1<TSet> CreateConcat(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right);
    internal static SymbolicRegexNode`1<TSet> CreateAlternate(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, bool deduplicated, bool hintRightLikelySubsumes);
    internal bool Subsumes(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> other, int depth);
    private SymbolicRegexNode`1<TSet> UnwrapEffects();
    private static bool TryFoldAlternation(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, SymbolicRegexNode`1& result, SymbolicRegexNode`1<TSet> rightEffects);
    public int GetFixedLength();
    public SymbolicRegexNode`1<TSet> AddFixedLengthMarkers(SymbolicRegexBuilder`1<TSet> builder, int lengthSoFar);
    internal SymbolicRegexNode`1<TSet> CreateDerivativeWithoutEffects(SymbolicRegexBuilder`1<TSet> builder, TSet elem, UInt32 context);
    internal List`1<ValueTuple`2<SymbolicRegexNode`1<TSet>, DerivativeEffect[]>> CreateNfaDerivativeWithEffects(SymbolicRegexBuilder`1<TSet> builder, TSet elem, UInt32 context);
    private SymbolicRegexNode`1<TSet> CreateDerivativeWrapper(SymbolicRegexBuilder`1<TSet> builder, TSet elem, UInt32 context);
    private SymbolicRegexNode`1<TSet> PruneLowerPriorityThanNullability(SymbolicRegexBuilder`1<TSet> builder, UInt32 context);
    private SymbolicRegexNode`1<TSet> CreateLoopContinuation(SymbolicRegexBuilder`1<TSet> builder);
    private SymbolicRegexNode`1<TSet> CreateDerivative(SymbolicRegexBuilder`1<TSet> builder, TSet elem, UInt32 context);
    internal SymbolicRegexNode`1<TSet> StripEffects(SymbolicRegexBuilder`1<TSet> builder);
    internal void StripAndMapEffects(SymbolicRegexBuilder`1<TSet> builder, UInt32 context, List`1<ValueTuple`2<SymbolicRegexNode`1<TSet>, DerivativeEffect[]>> alternativesAndEffects, List`1<DerivativeEffect> currentEffects);
    internal void ApplyEffects(Action`2<DerivativeEffect, TArg> apply, UInt32 context, TArg arg);
    public HashSet`1<TSet> GetSets(SymbolicRegexBuilder`1<TSet> builder);
    private void CollectSets(SymbolicRegexBuilder`1<TSet> builder, HashSet`1<TSet> sets);
    public TSet[] ComputeMinterms(SymbolicRegexBuilder`1<TSet> builder);
    public SymbolicRegexNode`1<TSet> Reverse(SymbolicRegexBuilder`1<TSet> builder);
    private static TSet ComputeStartSet(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNodeKind kind, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right);
    internal SymbolicRegexNode`1<TSet> PruneAnchors(SymbolicRegexBuilder`1<TSet> builder, UInt32 prevKind);
    private SymbolicRegexNode`1<TSet> PruneAnchorsImpl(SymbolicRegexBuilder`1<TSet> builder, UInt32 prevKind, bool contWithWL, bool contWithNWL);
    internal int ResolveFixedLength(UInt32 context);
    [IteratorStateMachineAttribute("System.Text.RegularExpressions.Symbolic.SymbolicRegexNode`1/<EnumerateAlternationBranches>d__73")]
internal IEnumerable`1<SymbolicRegexNode`1<TSet>> EnumerateAlternationBranches(SymbolicRegexBuilder`1<TSet> builder);
    internal int EstimateNfaSize();
    internal int CountSingletons();
    private static int Sum(int m, int n);
    private static int Times(int m, int n);
    [CompilerGeneratedAttribute]
internal static void <ToList>g__AppendToList|25_0(SymbolicRegexNode`1<TSet> concat, List`1<SymbolicRegexNode`1<TSet>> list, SymbolicRegexNodeKind listKind);
    [CompilerGeneratedAttribute]
private bool <IsNullableFor>g__WithCache|26_0(UInt32 context);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <Subsumes>g__ApplySubsumptionRules|50_0(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, int depth);
    [CompilerGeneratedAttribute]
internal static bool <Subsumes>g__TrySkipPrefix|50_1(SymbolicRegexNode`1<TSet> node, SymbolicRegexNode`1<TSet> prefix, SymbolicRegexNode`1& tail);
    [CompilerGeneratedAttribute]
internal static bool <TryFoldAlternation>g__TrySplitConcatSubsumption|52_0(SymbolicRegexBuilder`1<TSet> builder, SymbolicRegexNode`1<TSet> left, SymbolicRegexNode`1<TSet> right, SymbolicRegexNode`1& prefix);
    [CompilerGeneratedAttribute]
internal static SymbolicRegexNode`1<TSet> <PruneLowerPriorityThanNullability>g__PruneLoop|58_0(SymbolicRegexBuilder`1<TSet> builder, UInt32 context, SymbolicRegexNode`1<TSet> loop, SymbolicRegexNode`1<TSet> tail);
}
internal enum System.Text.RegularExpressions.Symbolic.SymbolicRegexNodeKind : Enum {
    public int value__;
    public static SymbolicRegexNodeKind Epsilon;
    public static SymbolicRegexNodeKind Singleton;
    public static SymbolicRegexNodeKind Concat;
    public static SymbolicRegexNodeKind Loop;
    public static SymbolicRegexNodeKind Alternate;
    public static SymbolicRegexNodeKind BeginningAnchor;
    public static SymbolicRegexNodeKind EndAnchor;
    public static SymbolicRegexNodeKind EndAnchorZ;
    public static SymbolicRegexNodeKind EndAnchorZReverse;
    public static SymbolicRegexNodeKind BOLAnchor;
    public static SymbolicRegexNodeKind EOLAnchor;
    public static SymbolicRegexNodeKind BoundaryAnchor;
    public static SymbolicRegexNodeKind NonBoundaryAnchor;
    public static SymbolicRegexNodeKind FixedLengthMarker;
    public static SymbolicRegexNodeKind Effect;
    public static SymbolicRegexNodeKind CaptureStart;
    public static SymbolicRegexNodeKind CaptureEnd;
    public static SymbolicRegexNodeKind DisableBacktrackingSimulation;
}
internal class System.Text.RegularExpressions.Symbolic.SymbolicRegexRunnerFactory : RegexRunnerFactory {
    internal SymbolicRegexMatcher _matcher;
    public SymbolicRegexRunnerFactory(RegexTree regexTree, RegexOptions options, TimeSpan matchTimeout);
    protected internal virtual RegexRunner CreateInstance();
}
internal static class System.Text.RegularExpressions.Symbolic.SymbolicRegexThresholds : object {
    internal static int GetSymbolicRegexSafeSizeThreshold();
}
internal class System.Text.RegularExpressions.Symbolic.UInt64Solver : object {
    private BDD[] _minterms;
    internal MintermClassifier _classifier;
    [CompilerGeneratedAttribute]
private ulong <Full>k__BackingField;
    public ulong Empty { get; }
    public ulong Full { get; }
    public UInt64Solver(BDD[] minterms, CharSetSolver solver);
    public sealed virtual ulong get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Full();
    public sealed virtual bool IsFull(ulong set);
    public sealed virtual bool IsEmpty(ulong set);
    public sealed virtual ulong And(ulong set1, ulong set2);
    public sealed virtual ulong Not(ulong set);
    public sealed virtual ulong Or(ReadOnlySpan`1<ulong> sets);
    public sealed virtual ulong Or(ulong set1, ulong set2);
    public sealed virtual ulong ConvertFromBDD(BDD set, CharSetSolver solver);
    public sealed virtual UInt64[] GetMinterms();
}
internal static class System.Text.RegularExpressions.Symbolic.UnicodeCategoryConditions : object {
    private static BDD[] s_categories;
    private static BDD modreq(System.Runtime.CompilerServices.IsVolatile) s_whiteSpace;
    private static BDD modreq(System.Runtime.CompilerServices.IsVolatile) s_wordLetter;
    private static BDD modreq(System.Runtime.CompilerServices.IsVolatile) s_wordLetterForAnchors;
    public static BDD WhiteSpace { get; }
    private static UnicodeCategoryConditions();
    public static BDD GetCategory(UnicodeCategory category);
    public static BDD get_WhiteSpace();
    public static BDD WordLetter(CharSetSolver solver);
    public static BDD WordLetterForAnchors(CharSetSolver solver);
}
internal static class System.Text.RegularExpressions.Symbolic.UnicodeCategoryRanges : object {
    public static ReadOnlySpan`1<byte> SerializedWhitespaceBDD { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory0_UppercaseLetter { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory1_LowercaseLetter { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory2_TitlecaseLetter { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory3_ModifierLetter { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory4_OtherLetter { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory5_NonSpacingMark { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory6_SpacingCombiningMark { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory7_EnclosingMark { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory8_DecimalDigitNumber { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory9_LetterNumber { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory10_OtherNumber { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory11_SpaceSeparator { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory12_LineSeparator { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory13_ParagraphSeparator { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory14_Control { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory15_Format { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory16_Surrogate { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory17_PrivateUse { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory18_ConnectorPunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory19_DashPunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory20_OpenPunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory21_ClosePunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory22_InitialQuotePunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory23_FinalQuotePunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory24_OtherPunctuation { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory25_MathSymbol { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory26_CurrencySymbol { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory27_ModifierSymbol { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory28_OtherSymbol { get; }
    private static ReadOnlySpan`1<byte> SerializedCategory29_OtherNotAssigned { get; }
    public static ReadOnlySpan`1<byte> get_SerializedWhitespaceBDD();
    public static ReadOnlySpan`1<byte> GetSerializedCategory(UnicodeCategory category);
    private static ReadOnlySpan`1<byte> get_SerializedCategory0_UppercaseLetter();
    private static ReadOnlySpan`1<byte> get_SerializedCategory1_LowercaseLetter();
    private static ReadOnlySpan`1<byte> get_SerializedCategory2_TitlecaseLetter();
    private static ReadOnlySpan`1<byte> get_SerializedCategory3_ModifierLetter();
    private static ReadOnlySpan`1<byte> get_SerializedCategory4_OtherLetter();
    private static ReadOnlySpan`1<byte> get_SerializedCategory5_NonSpacingMark();
    private static ReadOnlySpan`1<byte> get_SerializedCategory6_SpacingCombiningMark();
    private static ReadOnlySpan`1<byte> get_SerializedCategory7_EnclosingMark();
    private static ReadOnlySpan`1<byte> get_SerializedCategory8_DecimalDigitNumber();
    private static ReadOnlySpan`1<byte> get_SerializedCategory9_LetterNumber();
    private static ReadOnlySpan`1<byte> get_SerializedCategory10_OtherNumber();
    private static ReadOnlySpan`1<byte> get_SerializedCategory11_SpaceSeparator();
    private static ReadOnlySpan`1<byte> get_SerializedCategory12_LineSeparator();
    private static ReadOnlySpan`1<byte> get_SerializedCategory13_ParagraphSeparator();
    private static ReadOnlySpan`1<byte> get_SerializedCategory14_Control();
    private static ReadOnlySpan`1<byte> get_SerializedCategory15_Format();
    private static ReadOnlySpan`1<byte> get_SerializedCategory16_Surrogate();
    private static ReadOnlySpan`1<byte> get_SerializedCategory17_PrivateUse();
    private static ReadOnlySpan`1<byte> get_SerializedCategory18_ConnectorPunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory19_DashPunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory20_OpenPunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory21_ClosePunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory22_InitialQuotePunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory23_FinalQuotePunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory24_OtherPunctuation();
    private static ReadOnlySpan`1<byte> get_SerializedCategory25_MathSymbol();
    private static ReadOnlySpan`1<byte> get_SerializedCategory26_CurrencySymbol();
    private static ReadOnlySpan`1<byte> get_SerializedCategory27_ModifierSymbol();
    private static ReadOnlySpan`1<byte> get_SerializedCategory28_OtherSymbol();
    private static ReadOnlySpan`1<byte> get_SerializedCategory29_OtherNotAssigned();
}
internal static class System.Text.RegularExpressions.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument arg);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument arg);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument arg, ExceptionResource resource);
    private static string GetStringForExceptionArgument(ExceptionArgument arg);
    private static string GetStringForExceptionResource(ExceptionResource resource);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class System.Text.RegularExpressions.ValueMatch : ValueType {
    private int _index;
    private int _length;
    public int Index { get; }
    public int Length { get; }
    internal ValueMatch(int index, int length);
    public int get_Index();
    public int get_Length();
}
[DebuggerDisplayAttribute("Count = {_count}")]
internal class System.Text.StructListBuilder`1 : ValueType {
    private T[] _array;
    private int _count;
    public int Count { get; }
    public int get_Count();
    public Span`1<T> AsSpan();
    public void Add(T item);
    public void Dispose();
    private void GrowAndAdd(T item);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public Char& Item { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public Char& get_Item(int index);
    public virtual string ToString();
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
internal static class System.Threading.StackHelper : object {
    public static bool TryEnsureSufficientExecutionStack();
    public static void CallOnEmptyStack(Action`2<TArg1, TArg2> action, TArg1 arg1, TArg2 arg2);
    public static void CallOnEmptyStack(Action`3<TArg1, TArg2, TArg3> action, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static void CallOnEmptyStack(Action`4<TArg1, TArg2, TArg3, TArg4> action, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
    public static TResult CallOnEmptyStack(Func`1<TResult> func);
    public static TResult CallOnEmptyStack(Func`2<TArg1, TResult> func, TArg1 arg1);
    public static TResult CallOnEmptyStack(Func`3<TArg1, TArg2, TResult> func, TArg1 arg1, TArg2 arg2);
    public static TResult CallOnEmptyStack(Func`4<TArg1, TArg2, TArg3, TResult> func, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static TResult CallOnEmptyStack(Func`5<TArg1, TArg2, TArg3, TArg4, TResult> func, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
}
