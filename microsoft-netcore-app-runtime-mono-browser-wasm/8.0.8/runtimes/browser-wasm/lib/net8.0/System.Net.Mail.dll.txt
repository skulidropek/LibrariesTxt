internal static class FxResources.System.Net.Mail.SR : object {
}
internal static class System.HexConverter : object {
    public static char ToCharUpper(int value);
}
internal class System.Net.Base64Stream : DelegatedStream {
    private Base64WriteStateInfo _writeState;
    private ReadStateInfo _readState;
    private Base64Encoder _encoder;
    private static ReadOnlySpan`1<byte> Base64DecodeMap { get; }
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal Base64Stream(Base64WriteStateInfo writeStateInfo);
    private static ReadOnlySpan`1<byte> get_Base64DecodeMap();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<FlushAsync>d__23")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void FlushInternal();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<<ReadAsync>g__ReadAsyncCore|26_0>d")]
[CompilerGeneratedAttribute]
private Task`1<int> <ReadAsync>g__ReadAsyncCore|26_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<<WriteAsync>g__WriteAsyncCore|28_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|28_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__2(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal abstract class System.Net.DelegatedStream : Stream {
    private Stream _stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.AlternateView : AttachmentBase {
    private LinkedResourceCollection _linkedResources;
    public LinkedResourceCollection LinkedResources { get; }
    [NullableAttribute("2")]
public Uri BaseUri { get; public set; }
    public AlternateView(string fileName);
    public AlternateView(string fileName, string mediaType);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(Stream contentStream, ContentType contentType);
    public LinkedResourceCollection get_LinkedResources();
    [NullableContextAttribute("2")]
public Uri get_BaseUri();
    [NullableContextAttribute("2")]
public void set_BaseUri(Uri value);
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, AlternateView item);
    protected virtual void InsertItem(int index, AlternateView item);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Mail.Attachment : AttachmentBase {
    private string _name;
    private Encoding _nameEncoding;
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public ContentDisposition ContentDisposition { get; }
    [NullableContextAttribute("1")]
public Attachment(string fileName);
    [NullableContextAttribute("1")]
public Attachment(string fileName, string mediaType);
    [NullableContextAttribute("1")]
public Attachment(string fileName, ContentType contentType);
    [NullableContextAttribute("1")]
public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    [NullableContextAttribute("1")]
public Attachment(Stream contentStream, ContentType contentType);
    internal void SetContentTypeName(bool allowUnicode);
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public ContentDisposition get_ContentDisposition();
    [NullableContextAttribute("1")]
public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
    [NullableContextAttribute("1")]
public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Mail.AttachmentBase : object {
    internal bool disposed;
    private MimePart _part;
    public Stream ContentStream { get; }
    public string ContentId { get; public set; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    [NullableAttribute("2")]
internal Uri ContentLocation { get; internal set; }
    internal MimePart MimePart { get; }
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, string mediaType);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, string mediaType);
    internal AttachmentBase(Stream contentStream, string name, string mediaType);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void SetContentFromFile(string fileName, ContentType contentType);
    internal void SetContentFromFile(string fileName, string mediaType);
    internal void SetContentFromString(string content, ContentType contentType);
    internal void SetContentFromString(string content, Encoding encoding, string mediaType);
    public Stream get_ContentStream();
    public string get_ContentId();
    public void set_ContentId(string value);
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    internal Uri get_ContentLocation();
    internal void set_ContentLocation(Uri value);
    internal MimePart get_MimePart();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, Attachment item);
    protected virtual void InsertItem(int index, Attachment item);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnSuccess;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
}
internal static class System.Net.Mail.DomainLiteralReader : object {
    internal static bool TryReadReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
internal static class System.Net.Mail.DotAtomReader : object {
    internal static bool TryReadReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.LinkedResource : AttachmentBase {
    [NullableAttribute("2")]
public Uri ContentLink { get; public set; }
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, string mediaType);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, string mediaType);
    public LinkedResource(Stream contentStream, ContentType contentType);
    [NullableContextAttribute("2")]
public Uri get_ContentLink();
    [NullableContextAttribute("2")]
public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, LinkedResource item);
    protected virtual void InsertItem(int index, LinkedResource item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.MailAddress : object {
    [CompilerGeneratedAttribute]
private static bool <EnableFullDomainLiterals>k__BackingField;
    private Encoding _displayNameEncoding;
    private string _displayName;
    private string _userName;
    private string _host;
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public string Address { get; }
    private string SmtpAddress { get; }
    internal MailAddress(string displayName, string userName, string domain, Encoding displayNameEncoding);
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    [NullableContextAttribute("2")]
public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    private static MailAddress();
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, MailAddress& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, string displayName, MailAddress& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, string displayName, Encoding displayNameEncoding, MailAddress& result);
    private static bool TryParse(string address, string displayName, Encoding displayNameEncoding, ValueTuple`4& parsedData, bool throwExceptionIfFail);
    public string get_DisplayName();
    public string get_User();
    public string get_Host();
    public string get_Address();
    private string get_SmtpAddress();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void SetItem(int index, MailAddress item);
    protected virtual void InsertItem(int index, MailAddress item);
    internal void ParseValue(string addresses);
    public virtual string ToString();
}
internal static class System.Net.Mail.MailAddressParser : object {
    internal static bool TryParseAddress(string data, ParseAddressInfo& parsedAddress, bool throwExceptionIfFail);
    internal static List`1<MailAddress> ParseMultipleAddresses(string data);
    private static bool TryParseAddress(string data, bool expectMultipleAddresses, Int32& index, ParseAddressInfo& parseAddressInfo, bool throwExceptionIfFail);
    private static bool TryReadCfwsAndThrowIfIncomplete(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
    private static bool TryParseDomain(string data, Int32& index, String& domain, bool throwExceptionIfFail);
    private static bool TryParseLocalPart(string data, Int32& index, bool expectAngleBracket, bool expectMultipleAddresses, String& localPart, bool throwExceptionIfFail);
    private static bool TryParseDisplayName(string data, Int32& index, bool expectMultipleAddresses, String& displayName, bool throwExceptionIfFail);
    internal static bool TryNormalizeOrThrow(string input, String& normalizedString, bool throwExceptionIfFail);
}
internal enum System.Net.Mail.MailHeaderID : Enum {
    public int value__;
    public static MailHeaderID Bcc;
    public static MailHeaderID Cc;
    public static MailHeaderID Comments;
    public static MailHeaderID ContentDescription;
    public static MailHeaderID ContentDisposition;
    public static MailHeaderID ContentID;
    public static MailHeaderID ContentLocation;
    public static MailHeaderID ContentTransferEncoding;
    public static MailHeaderID ContentType;
    public static MailHeaderID Date;
    public static MailHeaderID From;
    public static MailHeaderID Importance;
    public static MailHeaderID InReplyTo;
    public static MailHeaderID Keywords;
    public static MailHeaderID Max;
    public static MailHeaderID MessageID;
    public static MailHeaderID MimeVersion;
    public static MailHeaderID Priority;
    public static MailHeaderID References;
    public static MailHeaderID ReplyTo;
    public static MailHeaderID ResentBcc;
    public static MailHeaderID ResentCc;
    public static MailHeaderID ResentDate;
    public static MailHeaderID ResentFrom;
    public static MailHeaderID ResentMessageID;
    public static MailHeaderID ResentSender;
    public static MailHeaderID ResentTo;
    public static MailHeaderID Sender;
    public static MailHeaderID Subject;
    public static MailHeaderID To;
    public static MailHeaderID XPriority;
    public static MailHeaderID XReceiver;
    public static MailHeaderID XSender;
    public static MailHeaderID ZMaxEnumValue;
    public static MailHeaderID Unknown;
}
internal static class System.Net.Mail.MailHeaderInfo : object {
    private static HeaderInfo[] s_headerInfo;
    private static Dictionary`2<string, int> s_headerDictionary;
    private static MailHeaderInfo();
    private static Dictionary`2<string, int> CreateHeaderDictionary();
    internal static string GetString(MailHeaderID id);
    internal static bool IsSingleton(string name);
    internal static string NormalizeCase(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.MailMessage : object {
    private AlternateViewCollection _views;
    private AttachmentCollection _attachments;
    private AlternateView _bodyView;
    private string _body;
    private Encoding _bodyEncoding;
    private TransferEncoding _bodyTransferEncoding;
    private bool _isBodyHtml;
    private bool _disposed;
    private Message _message;
    private DeliveryNotificationOptions _deliveryStatusNotification;
    [NullableAttribute("2")]
public MailAddress From { get; public set; }
    [NullableAttribute("2")]
public MailAddress Sender { get; public set; }
    [NullableAttribute("2")]
[ObsoleteAttribute("ReplyTo has been deprecated. Use ReplyToList instead, which can accept multiple addresses.")]
public MailAddress ReplyTo { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    public MailAddressCollection To { get; }
    public MailAddressCollection Bcc { get; }
    public MailAddressCollection CC { get; }
    public MailPriority Priority { get; public set; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public string Subject { get; public set; }
    [NullableAttribute("2")]
public Encoding SubjectEncoding { get; public set; }
    public NameValueCollection Headers { get; }
    [NullableAttribute("2")]
public Encoding HeadersEncoding { get; public set; }
    public string Body { get; public set; }
    [NullableAttribute("2")]
public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public AttachmentCollection Attachments { get; }
    public AlternateViewCollection AlternateViews { get; }
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    public MailMessage(MailAddress from, MailAddress to);
    [NullableContextAttribute("2")]
public MailAddress get_From();
    [NullableContextAttribute("2")]
public void set_From(MailAddress value);
    [NullableContextAttribute("2")]
public MailAddress get_Sender();
    [NullableContextAttribute("2")]
public void set_Sender(MailAddress value);
    [NullableContextAttribute("2")]
public MailAddress get_ReplyTo();
    [NullableContextAttribute("2")]
public void set_ReplyTo(MailAddress value);
    public MailAddressCollection get_ReplyToList();
    public MailAddressCollection get_To();
    public MailAddressCollection get_Bcc();
    public MailAddressCollection get_CC();
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public string get_Subject();
    public void set_Subject(string value);
    [NullableContextAttribute("2")]
public Encoding get_SubjectEncoding();
    [NullableContextAttribute("2")]
public void set_SubjectEncoding(Encoding value);
    public NameValueCollection get_Headers();
    [NullableContextAttribute("2")]
public Encoding get_HeadersEncoding();
    [NullableContextAttribute("2")]
public void set_HeadersEncoding(Encoding value);
    public string get_Body();
    public void set_Body(string value);
    [NullableContextAttribute("2")]
public Encoding get_BodyEncoding();
    [NullableContextAttribute("2")]
public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public AttachmentCollection get_Attachments();
    public AlternateViewCollection get_AlternateViews();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority Normal;
    public static MailPriority Low;
    public static MailPriority High;
}
internal class System.Net.Mail.Message : object {
    private MailAddress _from;
    private MailAddress _sender;
    private MailAddressCollection _replyToList;
    private MailAddress _replyTo;
    private MailAddressCollection _to;
    private MailAddressCollection _cc;
    private MailAddressCollection _bcc;
    private HeaderCollection _headers;
    private string _subject;
    private Encoding _subjectEncoding;
    private Encoding _headersEncoding;
    private MailPriority _priority;
    public MailPriority Priority { get; public set; }
    internal MailAddress From { get; internal set; }
    internal MailAddress Sender { get; internal set; }
    internal MailAddress ReplyTo { get; internal set; }
    internal MailAddressCollection ReplyToList { get; }
    internal MailAddressCollection To { get; }
    internal MailAddressCollection Bcc { get; }
    internal MailAddressCollection CC { get; }
    internal string Subject { get; internal set; }
    internal Encoding SubjectEncoding { get; internal set; }
    internal HeaderCollection Headers { get; }
    internal Encoding HeadersEncoding { get; internal set; }
    internal Message(string from, string to);
    internal Message(MailAddress from, MailAddress to);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    internal MailAddress get_From();
    internal void set_From(MailAddress value);
    internal MailAddress get_Sender();
    internal void set_Sender(MailAddress value);
    internal MailAddress get_ReplyTo();
    internal void set_ReplyTo(MailAddress value);
    internal MailAddressCollection get_ReplyToList();
    internal MailAddressCollection get_To();
    internal MailAddressCollection get_Bcc();
    internal MailAddressCollection get_CC();
    internal string get_Subject();
    internal void set_Subject(string value);
    internal Encoding get_SubjectEncoding();
    internal void set_SubjectEncoding(Encoding value);
    internal HeaderCollection get_Headers();
    internal Encoding get_HeadersEncoding();
    internal void set_HeadersEncoding(Encoding value);
}
[IsReadOnlyAttribute]
internal class System.Net.Mail.ParseAddressInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public ParseAddressInfo(string displayName, string userName, string domain);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public string get_Host();
}
internal static class System.Net.Mail.QuotedPairReader : object {
    internal static bool TryCountQuotedChars(string data, int index, bool permitUnicodeEscaping, Int32& outIndex, bool throwExceptionIfFail);
    private static int CountBackslashes(string data, int index);
}
internal static class System.Net.Mail.QuotedStringFormatReader : object {
    internal static bool TryReadReverseQuoted(string data, int index, bool permitUnicode, Int32& outIndex, bool throwExceptionIfFail);
    internal static bool TryReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter, Int32& outIndex, bool throwExceptionIfFail);
    private static bool IsValidQtext(bool allowUnicode, char ch);
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Net.Mail.SmtpClient : object {
    [CompilerGeneratedAttribute]
private SendCompletedEventHandler SendCompleted;
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public int Timeout { get; public set; }
    [NullableAttribute("1")]
public ServicePoint ServicePoint { get; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public bool EnableSsl { get; public set; }
    [NullableAttribute("1")]
public X509CertificateCollection ClientCertificates { get; }
    public string TargetName { get; public set; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    private static void Initialize();
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    public int get_Timeout();
    public void set_Timeout(int value);
    [NullableContextAttribute("1")]
public ServicePoint get_ServicePoint();
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    [NullableContextAttribute("1")]
public X509CertificateCollection get_ClientCertificates();
    public string get_TargetName();
    public void set_TargetName(string value);
    [NullableContextAttribute("1")]
public void Send(string from, string recipients, string subject, string body);
    [NullableContextAttribute("1")]
public void Send(MailMessage message);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    [NullableContextAttribute("1")]
public void SendAsync(MailMessage message, object userToken);
    public void SendAsyncCancel();
    [NullableContextAttribute("1")]
public Task SendMailAsync(string from, string recipients, string subject, string body);
    [NullableContextAttribute("1")]
public Task SendMailAsync(MailMessage message);
    [NullableContextAttribute("1")]
public Task SendMailAsync(string from, string recipients, string subject, string body, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task SendMailAsync(MailMessage message, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected void OnSendCompleted(AsyncCompletedEventArgs e);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat SevenBit;
    public static SmtpDeliveryFormat International;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpException : Exception {
    private SmtpStatusCode _statusCode;
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(SmtpStatusCode statusCode, string message);
    public SmtpException(string message);
    public SmtpException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal SmtpException(SmtpStatusCode statusCode, string serverMessage, bool _);
    private static string GetMessageForStatus(SmtpStatusCode statusCode, string serverResponse);
    private static string GetMessageForStatus(SmtpStatusCode statusCode);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    private string _failedRecipient;
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(string message);
    public SmtpFailedRecipientException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public string get_FailedRecipient();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    private SmtpFailedRecipientException[] _innerExceptions;
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    [NullableContextAttribute("2")]
public SmtpFailedRecipientsException(string message);
    [NullableContextAttribute("2")]
public SmtpFailedRecipientsException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode UserNotLocalWillForward;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode MustIssueStartTlsFirst;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode GeneralFailure;
}
internal static class System.Net.Mail.WhitespaceReader : object {
    internal static bool TryReadFwsReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
    internal static bool TryReadCfwsReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
internal class System.Net.Mime.Base64Encoder : ByteEncoder {
    private int _lineLength;
    private Base64WriteStateInfo _writeState;
    private static ReadOnlySpan`1<byte> Base64EncodeMap { get; }
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal Base64Encoder(Base64WriteStateInfo writeStateInfo, int lineLength);
    private static ReadOnlySpan`1<byte> get_Base64EncodeMap();
    internal virtual WriteStateInfoBase get_WriteState();
    protected virtual bool get_HasSpecialEncodingForCRLF();
    protected virtual void AppendEncodedCRLF();
    protected virtual bool LineBreakNeeded(byte b);
    protected virtual bool LineBreakNeeded(Byte[] bytes, int count);
    private bool LineBreakNeeded(int numberOfBytesToAppend);
    protected virtual int GetCodepointSize(string value, int i);
    public virtual void AppendPadding();
    protected virtual void ApppendEncodedByte(byte b);
}
internal class System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <LastBits>k__BackingField;
    internal int Padding { get; internal set; }
    internal byte LastBits { get; internal set; }
    internal Base64WriteStateInfo(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    [CompilerGeneratedAttribute]
internal int get_Padding();
    [CompilerGeneratedAttribute]
internal void set_Padding(int value);
    [CompilerGeneratedAttribute]
internal byte get_LastBits();
    [CompilerGeneratedAttribute]
internal void set_LastBits(byte value);
}
internal abstract class System.Net.Mime.ByteEncoder : object {
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal abstract virtual WriteStateInfoBase get_WriteState();
    protected abstract virtual bool get_HasSpecialEncodingForCRLF();
    public sealed virtual string GetEncodedString();
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    protected abstract virtual void AppendEncodedCRLF();
    protected abstract virtual bool LineBreakNeeded(byte b);
    protected abstract virtual bool LineBreakNeeded(Byte[] bytes, int count);
    protected abstract virtual int GetCodepointSize(string value, int i);
    public abstract virtual void AppendPadding();
    protected abstract virtual void ApppendEncodedByte(byte b);
    private void AppendEncodedCodepoint(Byte[] bytes, int count);
    protected static bool IsSurrogatePair(string value, int i);
    protected static bool IsCRLF(Byte[] bytes, int count);
    private static bool IsCRLF(Byte[] buffer, int i, int bufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mime.ContentDisposition : object {
    private TrackingValidationObjectDictionary _parameters;
    private string _disposition;
    private string _dispositionType;
    private bool _isChanged;
    private bool _isPersisted;
    private static ValidateAndParseValue s_dateParser;
    private static ValidateAndParseValue s_longParser;
    private static Dictionary`2<string, ValidateAndParseValue> s_validators;
    public string DispositionType { get; public set; }
    public StringDictionary Parameters { get; }
    [NullableAttribute("2")]
public string FileName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    internal bool IsChanged { get; }
    public ContentDisposition(string disposition);
    private static ContentDisposition();
    internal DateTime GetDateParameter(string parameterName);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public StringDictionary get_Parameters();
    [NullableContextAttribute("2")]
public string get_FileName();
    [NullableContextAttribute("2")]
public void set_FileName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    [MemberNotNullAttribute("_dispositionType")]
private void ParseValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mime.ContentType : object {
    private TrackingStringDictionary _parameters;
    private string _mediaType;
    private string _subType;
    private bool _isChanged;
    private string _type;
    private bool _isPersisted;
    [NullableAttribute("2")]
public string Boundary { get; public set; }
    [NullableAttribute("2")]
public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    internal bool IsChanged { get; }
    public ContentType(string contentType);
    [NullableContextAttribute("2")]
public string get_Boundary();
    [NullableContextAttribute("2")]
public void set_Boundary(string value);
    [NullableContextAttribute("2")]
public string get_CharSet();
    [NullableContextAttribute("2")]
public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    [MemberNotNullAttribute("_mediaType")]
[MemberNotNullAttribute("_subType")]
private void ParseValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Inline;
    public static string Attachment;
}
internal static class System.Net.Mime.EncodedStreamFactory : object {
    private static Byte[] s_footer;
    private static EncodedStreamFactory();
    internal static IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength);
    private static Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding);
}
internal class System.Net.Mime.HeaderCollection : NameValueCollection {
    public virtual void Remove(string name);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    internal void InternalRemove(string name);
    internal void InternalSet(string name, string value);
    internal void InternalAdd(string name, string value);
    public virtual void Set(string name, string value);
    public virtual void Add(string name, string value);
}
internal interface System.Net.Mime.IByteEncoder {
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public abstract virtual void AppendPadding();
    public abstract virtual int EncodeString(string value, Encoding encoding);
    public abstract virtual string GetEncodedString();
}
internal interface System.Net.Mime.IEncodableStream {
    public abstract virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeString(string value, Encoding encoding);
    public abstract virtual string GetEncodedString();
}
internal static class System.Net.Mime.MailBnfHelper : object {
    internal static Boolean[] Atext;
    internal static Boolean[] Qtext;
    internal static Boolean[] Dtext;
    internal static Boolean[] Ctext;
    private static SearchValues`1<char> s_charactersAllowedInHeaderNames;
    private static SearchValues`1<char> s_charactersAllowedInTokens;
    private static String[] s_months;
    private static MailBnfHelper();
    private static Boolean[] CreateCharactersAllowedInAtoms();
    private static Boolean[] CreateCharactersAllowedInQuotedStrings();
    private static Boolean[] CreateCharactersAllowedInDomainLiterals();
    private static Boolean[] CreateCharactersAllowedInComments();
    internal static bool SkipCFWS(string data, Int32& offset);
    internal static void ValidateHeaderName(string data);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName);
    internal static string ReadParameterAttribute(string data, Int32& offset);
    internal static string ReadToken(string data, Int32& offset);
    internal static void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode);
    private static bool CheckForUnicode(char ch, bool allowUnicode);
    internal static bool IsAllowedWhiteSpace(char c);
    internal static bool HasCROrLF(string data);
    internal static bool IsFWSAt(string data, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Net.Mime.MediaTypeNames : object {
}
internal class System.Net.Mime.MimeBasePart : object {
    protected ContentType _contentType;
    protected ContentDisposition _contentDisposition;
    private HeaderCollection _headers;
    private static Char[] s_headerValueSplitChars;
    internal string ContentID { get; internal set; }
    internal string ContentLocation { get; internal set; }
    internal NameValueCollection Headers { get; }
    internal ContentType ContentType { get; internal set; }
    private static MimeBasePart();
    internal static bool ShouldUseBase64Encoding(Encoding encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength);
    internal static string DecodeHeaderValue(string value);
    internal static Encoding DecodeEncoding(string value);
    internal static bool IsAscii(string value, bool permitCROrLF);
    internal string get_ContentID();
    internal void set_ContentID(string value);
    internal string get_ContentLocation();
    internal void set_ContentLocation(string value);
    internal NameValueCollection get_Headers();
    internal ContentType get_ContentType();
    internal void set_ContentType(ContentType value);
}
internal class System.Net.Mime.MimePart : MimeBasePart {
    private Stream _stream;
    private bool _streamSet;
    private bool _streamUsedOnce;
    internal Stream Stream { get; }
    internal ContentDisposition ContentDisposition { get; internal set; }
    internal TransferEncoding TransferEncoding { get; internal set; }
    public sealed virtual void Dispose();
    internal Stream get_Stream();
    internal ContentDisposition get_ContentDisposition();
    internal void set_ContentDisposition(ContentDisposition value);
    internal TransferEncoding get_TransferEncoding();
    internal void set_TransferEncoding(TransferEncoding value);
    internal void SetContent(Stream stream);
    internal void SetContent(Stream stream, string name, string mimeType);
    internal void SetContent(Stream stream, ContentType contentType);
}
internal class System.Net.Mime.QEncodedStream : DelegatedStream {
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private QEncoder _encoder;
    private static ReadOnlySpan`1<byte> HexDecodeMap { get; }
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QEncodedStream(WriteStateInfoBase wsi);
    private static ReadOnlySpan`1<byte> get_HexDecodeMap();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Net.Mime.QEncodedStream/<FlushAsync>d__18")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Mime.QEncodedStream/<<WriteAsync>g__WriteAsyncCore|21_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|21_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.Mime.QEncoder : ByteEncoder {
    private WriteStateInfoBase _writeState;
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal QEncoder(WriteStateInfoBase wsi);
    internal virtual WriteStateInfoBase get_WriteState();
    protected virtual bool get_HasSpecialEncodingForCRLF();
    protected virtual void AppendEncodedCRLF();
    protected virtual bool LineBreakNeeded(byte b);
    protected virtual bool LineBreakNeeded(Byte[] bytes, int count);
    protected virtual int GetCodepointSize(string value, int i);
    public virtual void AppendPadding();
    protected virtual void ApppendEncodedByte(byte b);
}
internal class System.Net.Mime.SmtpDateTime : object {
    internal static String[] s_validDateTimeFormats;
    internal static Dictionary`2<string, TimeSpan> s_timeZoneOffsetLookup;
    private DateTime _date;
    private TimeSpan _timeZone;
    private bool _unknownTimeZone;
    internal DateTime Date { get; }
    internal SmtpDateTime(DateTime value);
    internal SmtpDateTime(string value);
    private static SmtpDateTime();
    internal DateTime get_Date();
    public virtual string ToString();
    internal static void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes);
    internal static void ValidateTimeZoneShortHandValue(string value);
    internal static DateTime ParseValue(string data, String& timeZone);
    internal static bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone);
    internal static TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span);
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding Unknown;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding Base64;
    public static TransferEncoding SevenBit;
    public static TransferEncoding EightBit;
}
internal class System.Net.Mime.WriteStateInfoBase : object {
    protected Byte[] _header;
    protected Byte[] _footer;
    protected int _maxLineLength;
    protected Byte[] _buffer;
    protected int _currentLineLength;
    protected int _currentBufferUsed;
    internal int FooterLength { get; }
    internal Byte[] Footer { get; }
    internal Byte[] Header { get; }
    internal Byte[] Buffer { get; }
    internal int Length { get; }
    internal int CurrentLineLength { get; }
    internal int MaxLineLength { get; }
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    internal int get_FooterLength();
    internal Byte[] get_Footer();
    internal Byte[] get_Header();
    internal Byte[] get_Buffer();
    internal int get_Length();
    internal int get_CurrentLineLength();
    private void EnsureSpaceInBuffer(int moreBytes);
    internal void Append(byte aByte);
    internal void Append(ReadOnlySpan`1<byte> bytes);
    internal void AppendCRLF(bool includeSpace);
    internal void AppendHeader();
    internal void AppendFooter();
    internal int get_MaxLineLength();
    internal void Reset();
}
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingStringDictionary : StringDictionary {
    private bool _isReadOnly;
    private bool _isChanged;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingStringDictionary(bool isReadOnly);
    internal bool get_IsChanged();
    internal void set_IsChanged(bool value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingValidationObjectDictionary : StringDictionary {
    private Dictionary`2<string, ValidateAndParseValue> _validators;
    private Dictionary`2<string, object> _internalObjects;
    [CompilerGeneratedAttribute]
private bool <IsChanged>k__BackingField;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingValidationObjectDictionary(Dictionary`2<string, ValidateAndParseValue> validators);
    private void PersistValue(string key, string value, bool addValue);
    [CompilerGeneratedAttribute]
internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal void set_IsChanged(bool value);
    internal object InternalGet(string key);
    internal void InternalSet(string key, object value);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string MailBase64InvalidCharacter { get; }
    internal static string MailCollectionIsReadOnly { get; }
    internal static string MailDateInvalidFormat { get; }
    internal static string MailHeaderFieldMalformedHeader { get; }
    internal static string MimeTransferEncodingNotSupported { get; }
    internal static string InvalidHexDigit { get; }
    internal static string InvalidHeaderName { get; }
    internal static string ContentTypeInvalid { get; }
    internal static string ContentDispositionInvalid { get; }
    internal static string MediaTypeInvalid { get; }
    internal static string MailHeaderInvalidCID { get; }
    internal static string MailServerResponse { get; }
    internal static string SmtpBadCommandSequence { get; }
    internal static string SmtpClientNotPermitted { get; }
    internal static string SmtpCommandNotImplemented { get; }
    internal static string SmtpCommandParameterNotImplemented { get; }
    internal static string SmtpCommandUnrecognized { get; }
    internal static string SmtpExceededStorageAllocation { get; }
    internal static string SmtpHelpMessage { get; }
    internal static string SmtpInsufficientStorage { get; }
    internal static string SmtpLocalErrorInProcessing { get; }
    internal static string SmtpMailboxBusy { get; }
    internal static string SmtpMailboxNameNotAllowed { get; }
    internal static string SmtpMailboxUnavailable { get; }
    internal static string SmtpMustIssueStartTlsFirst { get; }
    internal static string SmtpOK { get; }
    internal static string SmtpServiceClosingTransmissionChannel { get; }
    internal static string SmtpServiceReady { get; }
    internal static string SmtpStartMailInput { get; }
    internal static string SmtpSyntaxError { get; }
    internal static string SmtpSystemStatus { get; }
    internal static string SmtpTransactionFailed { get; }
    internal static string SmtpUserNotLocalTryAlternatePath { get; }
    internal static string SmtpUserNotLocalWillForward { get; }
    internal static string MailHeaderFieldInvalidCharacter { get; }
    internal static string SeekNotSupported { get; }
    internal static string ReadNotSupported { get; }
    internal static string WriteNotSupported { get; }
    internal static string MailAddressInvalidFormat { get; }
    internal static string SmtpServiceNotAvailable { get; }
    internal static string MailSubjectInvalidFormat { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static ResourceManager get_ResourceManager();
    internal static string get_MailBase64InvalidCharacter();
    internal static string get_MailCollectionIsReadOnly();
    internal static string get_MailDateInvalidFormat();
    internal static string get_MailHeaderFieldMalformedHeader();
    internal static string get_MimeTransferEncodingNotSupported();
    internal static string get_InvalidHexDigit();
    internal static string get_InvalidHeaderName();
    internal static string get_ContentTypeInvalid();
    internal static string get_ContentDispositionInvalid();
    internal static string get_MediaTypeInvalid();
    internal static string get_MailHeaderInvalidCID();
    internal static string get_MailServerResponse();
    internal static string get_SmtpBadCommandSequence();
    internal static string get_SmtpClientNotPermitted();
    internal static string get_SmtpCommandNotImplemented();
    internal static string get_SmtpCommandParameterNotImplemented();
    internal static string get_SmtpCommandUnrecognized();
    internal static string get_SmtpExceededStorageAllocation();
    internal static string get_SmtpHelpMessage();
    internal static string get_SmtpInsufficientStorage();
    internal static string get_SmtpLocalErrorInProcessing();
    internal static string get_SmtpMailboxBusy();
    internal static string get_SmtpMailboxNameNotAllowed();
    internal static string get_SmtpMailboxUnavailable();
    internal static string get_SmtpMustIssueStartTlsFirst();
    internal static string get_SmtpOK();
    internal static string get_SmtpServiceClosingTransmissionChannel();
    internal static string get_SmtpServiceReady();
    internal static string get_SmtpStartMailInput();
    internal static string get_SmtpSyntaxError();
    internal static string get_SmtpSystemStatus();
    internal static string get_SmtpTransactionFailed();
    internal static string get_SmtpUserNotLocalTryAlternatePath();
    internal static string get_SmtpUserNotLocalWillForward();
    internal static string get_MailHeaderFieldInvalidCharacter();
    internal static string get_SeekNotSupported();
    internal static string get_ReadNotSupported();
    internal static string get_WriteNotSupported();
    internal static string get_MailAddressInvalidFormat();
    internal static string get_SmtpServiceNotAvailable();
    internal static string get_MailSubjectInvalidFormat();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
