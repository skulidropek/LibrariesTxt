internal static class FxResources.System.Collections.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.BitArray : object {
    private Int32[] m_array;
    private int m_length;
    private int _version;
    public bool Item { get; public set; }
    public int Length { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public BitArray(int length);
    public BitArray(int length, bool defaultValue);
    public BitArray(Byte[] bytes);
    public BitArray(Boolean[] values);
    public BitArray(Int32[] values);
    public BitArray(BitArray bits);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Get(int index);
    public void Set(int index, bool value);
    public void SetAll(bool value);
    public BitArray And(BitArray value);
    public BitArray Or(BitArray value);
    public BitArray Xor(BitArray value);
    public BitArray Not();
    public BitArray RightShift(int count);
    public BitArray LeftShift(int count);
    public int get_Length();
    public void set_Length(int value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    public sealed virtual object Clone();
    public sealed virtual IEnumerator GetEnumerator();
    private static int GetInt32ArrayLengthFromBitLength(int n);
    private static int GetInt32ArrayLengthFromByteLength(int n);
    private static int GetByteArrayLengthFromBitLength(int n);
    private static int Div32Rem(int number, Int32& remainder);
    private static int Div4Rem(int number, Int32& remainder);
    private static void ThrowArgumentOutOfRangeException(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Collections.Generic.BitHelper : ValueType {
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool Remove(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue& value);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> AsReadOnly(IList`1<T> list);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> dictionary);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.LinkedList`1 : object {
    internal LinkedListNode`1<T> head;
    internal int count;
    internal int version;
    private SerializationInfo _siInfo;
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LinkedListNode`1<T> First { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LinkedListNode`1<T> Last { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public LinkedList`1(IEnumerable`1<T> collection);
    protected LinkedList`1(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    public LinkedListNode`1<T> get_First();
    public LinkedListNode`1<T> get_Last();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value);
    public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value);
    public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddFirst(T value);
    public void AddFirst(LinkedListNode`1<T> node);
    public LinkedListNode`1<T> AddLast(T value);
    public void AddLast(LinkedListNode`1<T> node);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public LinkedListNode`1<T> Find(T value);
    public LinkedListNode`1<T> FindLast(T value);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual bool Remove(T value);
    public void Remove(LinkedListNode`1<T> node);
    public void RemoveFirst();
    public void RemoveLast();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode);
    internal void InternalRemoveNode(LinkedListNode`1<T> node);
    internal static void ValidateNewNode(LinkedListNode`1<T> node);
    internal void ValidateNode(LinkedListNode`1<T> node);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Collections.Generic.LinkedListNode`1 : object {
    internal LinkedList`1<T> list;
    internal LinkedListNode`1<T> next;
    internal LinkedListNode`1<T> prev;
    internal T item;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LinkedList`1<T> List { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LinkedListNode`1<T> Next { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LinkedListNode`1<T> Previous { get; }
    public T Value { get; public set; }
    public T& ValueRef { get; }
    public LinkedListNode`1(T value);
    internal LinkedListNode`1(LinkedList`1<T> list, T value);
    public LinkedList`1<T> get_List();
    public LinkedListNode`1<T> get_Next();
    public LinkedListNode`1<T> get_Previous();
    public T get_Value();
    public void set_Value(T value);
    public T& get_ValueRef();
    internal void Invalidate();
}
internal enum System.Collections.Generic.NodeColor : Enum {
    public byte value__;
    public static NodeColor Black;
    public static NodeColor Red;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.PriorityQueueDebugView`2")]
public class System.Collections.Generic.PriorityQueue`2 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _nodes;
    private IComparer`1<TPriority> _comparer;
    private UnorderedItemsCollection<TElement, TPriority> _unorderedItems;
    private int _size;
    private int _version;
    public int Count { get; }
    public IComparer`1<TPriority> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public UnorderedItemsCollection<TElement, TPriority> UnorderedItems { get; }
    public PriorityQueue`2(int initialCapacity);
    public PriorityQueue`2(IComparer`1<TPriority> comparer);
    public PriorityQueue`2(int initialCapacity, IComparer`1<TPriority> comparer);
    public PriorityQueue`2(IEnumerable`1<ValueTuple`2<TElement, TPriority>> items);
    public PriorityQueue`2(IEnumerable`1<ValueTuple`2<TElement, TPriority>> items, IComparer`1<TPriority> comparer);
    public int get_Count();
    public IComparer`1<TPriority> get_Comparer();
    public UnorderedItemsCollection<TElement, TPriority> get_UnorderedItems();
    public void Enqueue(TElement element, TPriority priority);
    public TElement Peek();
    public TElement Dequeue();
    public bool TryDequeue(TElement& element, TPriority& priority);
    public bool TryPeek(TElement& element, TPriority& priority);
    public TElement EnqueueDequeue(TElement element, TPriority priority);
    public void EnqueueRange(IEnumerable`1<ValueTuple`2<TElement, TPriority>> items);
    public void EnqueueRange(IEnumerable`1<TElement> elements, TPriority priority);
    public void Clear();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    private void Grow(int minCapacity);
    private void RemoveRootNode();
    private static int GetParentIndex(int index);
    private static int GetFirstChildIndex(int index);
    private void Heapify();
    private void MoveUpDefaultComparer(ValueTuple`2<TElement, TPriority> node, int nodeIndex);
    private void MoveUpCustomComparer(ValueTuple`2<TElement, TPriority> node, int nodeIndex);
    private void MoveDownDefaultComparer(ValueTuple`2<TElement, TPriority> node, int nodeIndex);
    private void MoveDownCustomComparer(ValueTuple`2<TElement, TPriority> node, int nodeIndex);
    private static IComparer`1<TPriority> InitializeComparer(IComparer`1<TPriority> comparer);
}
internal class System.Collections.Generic.PriorityQueueDebugView`2 : object {
    private PriorityQueue`2<TElement, TPriority> _queue;
    private bool _sort;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public ValueTuple`2[] Items { get; }
    public PriorityQueueDebugView`2(PriorityQueue`2<TElement, TPriority> queue);
    public PriorityQueueDebugView`2(UnorderedItemsCollection<TElement, TPriority> collection);
    public ValueTuple`2[] get_Items();
    [CompilerGeneratedAttribute]
private int <get_Items>b__5_0(ValueTuple`2<TElement, TPriority> i1, ValueTuple`2<TElement, TPriority> i2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.SortedDictionary`2 : object {
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set;
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public IComparer`1<TKey> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public IComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.SortedList`2 : object {
    private TKey[] keys;
    private TValue[] values;
    private int _size;
    private int version;
    private IComparer`1<TKey> comparer;
    private KeyList<TKey, TValue> keyList;
    private ValueList<TKey, TValue> valueList;
    public int Capacity { get; public set; }
    public IComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public IList`1<TKey> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public IList`1<TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TValue Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public SortedList`2(int capacity);
    public SortedList`2(IComparer`1<TKey> comparer);
    public SortedList`2(int capacity, IComparer`1<TKey> comparer);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public int get_Capacity();
    public void set_Capacity(int value);
    public IComparer`1<TKey> get_Comparer();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual int get_Count();
    public IList`1<TKey> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public IList`1<TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private KeyList<TKey, TValue> GetKeyListHelper();
    private ValueList<TKey, TValue> GetValueListHelper();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private void EnsureCapacity(int min);
    public TValue GetValueAtIndex(int index);
    public void SetValueAtIndex(int index, TValue value);
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public TKey GetKeyAtIndex(int index);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    private void Insert(int index, TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public void RemoveAt(int index);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public void TrimExcess();
    private static bool IsCompatibleKey(object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.SortedSet`1 : object {
    private Node<T> root;
    private IComparer`1<T> comparer;
    private int count;
    private int version;
    private SerializationInfo siInfo;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
public T Min { get; }
    [NullableAttribute("2")]
internal T MinInternal { get; }
    [NullableAttribute("2")]
public T Max { get; }
    [NullableAttribute("2")]
internal T MaxInternal { get; }
    public SortedSet`1(IComparer`1<T> comparer);
    public SortedSet`1(IEnumerable`1<T> collection);
    public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    protected SortedSet`1(SerializationInfo info, StreamingContext context);
    private void AddAllElements(IEnumerable`1<T> collection);
    private void RemoveAllElements(IEnumerable`1<T> collection);
    private bool ContainsAllElements(IEnumerable`1<T> collection);
    internal virtual bool InOrderTreeWalk(TreeWalkPredicate`1<T> action);
    internal virtual bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal virtual void VersionCheck(bool updateCount);
    internal virtual int TotalCount();
    internal virtual bool IsWithinRange(T item);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    internal virtual bool AddIfNotPresent(T item);
    public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int index);
    public void CopyTo(T[] array, int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent);
    private void ReplaceChildOrRoot(Node<T> parent, Node<T> child, Node<T> newChild);
    private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> successor, Node<T> parentOfSuccessor);
    internal virtual Node<T> FindNode(T item);
    internal virtual int InternalIndexOf(T item);
    internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive);
    internal void UpdateVersion();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer);
    internal static bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer);
    private bool HasEqualComparer(SortedSet`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private static Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode);
    public virtual void IntersectWith(IEnumerable`1<T> other);
    internal virtual void IntersectWithEnumerable(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private void SymmetricExceptWithSameComparer(SortedSet`1<T> other);
    private void SymmetricExceptWithSameComparer(T[] other, int count);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    private bool IsSubsetOfSortedSetWithSameComparer(SortedSet`1<T> asSorted);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    public int RemoveWhere(Predicate`1<T> match);
    [NullableContextAttribute("2")]
public T get_Min();
    internal virtual T get_MinInternal();
    [NullableContextAttribute("2")]
public T get_Max();
    internal virtual T get_MaxInternal();
    [IteratorStateMachineAttribute("System.Collections.Generic.SortedSet`1/<Reverse>d__84")]
public IEnumerable`1<T> Reverse();
    [NullableContextAttribute("2")]
public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("2")]
protected virtual void OnDeserialization(object sender);
    public bool TryGetValue(T equalValue, T& actualValue);
    private static int Log2(int value);
}
internal class System.Collections.Generic.SortedSetEqualityComparer`1 : object {
    private IComparer`1<T> _comparer;
    private IEqualityComparer`1<T> _memberEqualityComparer;
    public SortedSetEqualityComparer`1(IEqualityComparer`1<T> memberEqualityComparer);
    private SortedSetEqualityComparer`1(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual bool Equals(SortedSet`1<T> x, SortedSet`1<T> y);
    public sealed virtual int GetHashCode(SortedSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.StackDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Stack`1 : object {
    private T[] _array;
    private int _size;
    private int _version;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Stack`1(int capacity);
    public Stack`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public T Peek();
    public bool TryPeek(T& result);
    public T Pop();
    public bool TryPop(T& result);
    public void Push(T item);
    private void PushWithResize(T item);
    public int EnsureCapacity(int capacity);
    private void Grow(int capacity);
    public T[] ToArray();
    private void ThrowForEmptyStack();
}
internal class System.Collections.Generic.StackDebugView`1 : object {
    private Stack`1<T> _stack;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public StackDebugView`1(Stack`1<T> stack);
    public T[] get_Items();
}
internal enum System.Collections.Generic.TreeRotation : Enum {
    public byte value__;
    public static TreeRotation Left;
    public static TreeRotation LeftRight;
    public static TreeRotation Right;
    public static TreeRotation RightLeft;
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
    public TreeSet`1(IComparer`1<T> comparer);
    internal TreeSet`1(TreeSet`1<T> set, IComparer`1<T> comparer);
    private TreeSet`1(SerializationInfo siInfo, StreamingContext context);
    internal virtual bool AddIfNotPresent(T item);
}
internal class System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
    public TreeWalkPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(Node<T> node);
}
internal class System.Collections.StructuralComparer : object {
    public sealed virtual int Compare(object x, object y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Collections.StructuralComparisons : object {
    private static IComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralComparer;
    private static IEqualityComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralEqualityComparer;
    public static IComparer StructuralComparer { get; }
    public static IEqualityComparer StructuralEqualityComparer { get; }
    public static IComparer get_StructuralComparer();
    public static IEqualityComparer get_StructuralEqualityComparer();
}
internal class System.Collections.StructuralEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_WrongType { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string InvalidOperation_EmptyQueue { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EmptyStack { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_BitArrayTypeUnsupported { get; }
    internal static string Arg_InsufficientSpace { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_ArrayTooLarge { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLessOrEqual { get; }
    internal static string ExternalLinkedListNode { get; }
    internal static string LinkedListEmpty { get; }
    internal static string LinkedListNodeIsAttached { get; }
    internal static string NotSupported_SortedListNestedWrite { get; }
    internal static string SortedSet_LowerValueGreaterThanUpperValue { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_MismatchedCount { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_WrongType();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_InvalidOperation_EmptyQueue();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EmptyStack();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_BitArrayTypeUnsupported();
    internal static string get_Arg_InsufficientSpace();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_ArrayTooLarge();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_IndexMustBeLessOrEqual();
    internal static string get_ExternalLinkedListNode();
    internal static string get_LinkedListEmpty();
    internal static string get_LinkedListNodeIsAttached();
    internal static string get_NotSupported_SortedListNestedWrite();
    internal static string get_SortedSet_LowerValueGreaterThanUpperValue();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_MismatchedCount();
    internal static string get_Serialization_MissingValues();
    internal static string get_Arg_KeyNotFoundWithKey();
}
