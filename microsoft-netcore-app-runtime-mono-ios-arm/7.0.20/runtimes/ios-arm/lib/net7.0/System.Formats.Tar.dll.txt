internal static class FxResources.System.Formats.Tar.SR : object {
}
internal static class Interop : object {
    private static void ThrowExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirError);
    internal static long CheckIo(long result, string path, bool isDirError);
    internal static int CheckIo(int result, string path, bool isDirError);
    internal static Exception GetExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirError);
    internal static Exception GetIOException(ErrorInfo errorInfo, string path);
    [CompilerGeneratedAttribute]
internal static bool <GetExceptionForIoErrno>g__ParentDirectoryExists|7_0(string fullPath);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.GnuTarEntry : PosixTarEntry {
    public DateTimeOffset AccessTime { get; public set; }
    public DateTimeOffset ChangeTime { get; public set; }
    internal GnuTarEntry(TarHeader header, TarReader readerOfOrigin);
    public GnuTarEntry(TarEntryType entryType, string entryName);
    public GnuTarEntry(TarEntry other);
    public DateTimeOffset get_AccessTime();
    public void set_AccessTime(DateTimeOffset value);
    public DateTimeOffset get_ChangeTime();
    public void set_ChangeTime(DateTimeOffset value);
    internal virtual bool IsDataStreamSetterSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.PaxGlobalExtendedAttributesTarEntry : PosixTarEntry {
    private ReadOnlyDictionary`2<string, string> _readOnlyGlobalExtendedAttributes;
    public IReadOnlyDictionary`2<string, string> GlobalExtendedAttributes { get; }
    internal PaxGlobalExtendedAttributesTarEntry(TarHeader header, TarReader readerOfOrigin);
    public PaxGlobalExtendedAttributesTarEntry(IEnumerable`1<KeyValuePair`2<string, string>> globalExtendedAttributes);
    public IReadOnlyDictionary`2<string, string> get_GlobalExtendedAttributes();
    internal virtual bool IsDataStreamSetterSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.PaxTarEntry : PosixTarEntry {
    private ReadOnlyDictionary`2<string, string> _readOnlyExtendedAttributes;
    public IReadOnlyDictionary`2<string, string> ExtendedAttributes { get; }
    internal PaxTarEntry(TarHeader header, TarReader readerOfOrigin);
    public PaxTarEntry(TarEntryType entryType, string entryName);
    public PaxTarEntry(TarEntryType entryType, string entryName, IEnumerable`1<KeyValuePair`2<string, string>> extendedAttributes);
    public PaxTarEntry(TarEntry other);
    public IReadOnlyDictionary`2<string, string> get_ExtendedAttributes();
    internal virtual bool IsDataStreamSetterSupported();
    private void AddNewAccessAndChangeTimestampsIfNotExist(bool useMTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Formats.Tar.PosixTarEntry : TarEntry {
    public int DeviceMajor { get; public set; }
    public int DeviceMinor { get; public set; }
    public string GroupName { get; public set; }
    public string UserName { get; public set; }
    internal PosixTarEntry(TarHeader header, TarReader readerOfOrigin, TarEntryFormat format);
    internal PosixTarEntry(TarEntryType entryType, string entryName, TarEntryFormat format, bool isGea);
    internal PosixTarEntry(TarEntry other, TarEntryFormat format);
    public int get_DeviceMajor();
    public void set_DeviceMajor(int value);
    public int get_DeviceMinor();
    public void set_DeviceMinor(int value);
    public string get_GroupName();
    public void set_GroupName(string value);
    public string get_UserName();
    public void set_UserName(string value);
}
internal class System.Formats.Tar.SeekableSubReadStream : SubReadStream {
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public SeekableSubReadStream(Stream superStream, long startPosition, long maxLength);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Span`1<byte> destination);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    private void VerifyPositionInSuperStream();
}
internal class System.Formats.Tar.SubReadStream : Stream {
    protected bool _hasReachedEnd;
    protected long _startInSuperStream;
    protected long _positionInSuperStream;
    protected long _endInSuperStream;
    protected Stream _superStream;
    protected bool _isDisposed;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal bool HasReachedEnd { get; internal set; }
    public SubReadStream(Stream superStream, long startPosition, long maxLength);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    internal bool get_HasReachedEnd();
    internal void set_HasReachedEnd(bool value);
    protected void ThrowIfDisposed();
    private void ThrowIfBeyondEndOfStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Formats.Tar.SubReadStream/<ReadAsyncCore>d__28")]
protected ValueTask`1<int> ReadAsyncCore(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Formats.Tar.TarEntry : object {
    internal TarHeader _header;
    private TarReader _readerOfOrigin;
    public int Checksum { get; }
    public TarEntryType EntryType { get; }
    public TarEntryFormat Format { get; }
    public int Gid { get; public set; }
    public DateTimeOffset ModificationTime { get; public set; }
    public long Length { get; }
    public string LinkName { get; public set; }
    public UnixFileMode Mode { get; public set; }
    public string Name { get; public set; }
    public int Uid { get; public set; }
    [NullableAttribute("2")]
public Stream DataStream { get; public set; }
    internal TarEntry(TarHeader header, TarReader readerOfOrigin, TarEntryFormat format);
    internal TarEntry(TarEntryType entryType, string entryName, TarEntryFormat format, bool isGea);
    internal TarEntry(TarEntry other, TarEntryFormat format);
    public int get_Checksum();
    public TarEntryType get_EntryType();
    public TarEntryFormat get_Format();
    public int get_Gid();
    public void set_Gid(int value);
    public DateTimeOffset get_ModificationTime();
    public void set_ModificationTime(DateTimeOffset value);
    public long get_Length();
    public string get_LinkName();
    public void set_LinkName(string value);
    public UnixFileMode get_Mode();
    public void set_Mode(UnixFileMode value);
    public string get_Name();
    public void set_Name(string value);
    public int get_Uid();
    public void set_Uid(int value);
    public void ExtractToFile(string destinationFileName, bool overwrite);
    public Task ExtractToFileAsync(string destinationFileName, bool overwrite, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Stream get_DataStream();
    [NullableContextAttribute("2")]
public void set_DataStream(Stream value);
    public virtual string ToString();
    internal abstract virtual bool IsDataStreamSetterSupported();
    internal void ExtractRelativeToDirectory(string destinationDirectoryPath, bool overwrite, SortedDictionary`2<string, UnixFileMode> pendingModes);
    internal Task ExtractRelativeToDirectoryAsync(string destinationDirectoryPath, bool overwrite, SortedDictionary`2<string, UnixFileMode> pendingModes, CancellationToken cancellationToken);
    private ValueTuple`2<string, string> GetDestinationAndLinkPaths(string destinationDirectoryPath);
    private static string GetSanitizedFullPath(string destinationDirectoryFullPath, string path);
    private void ExtractToFileInternal(string filePath, string linkTargetPath, bool overwrite);
    private Task ExtractToFileInternalAsync(string filePath, string linkTargetPath, bool overwrite, CancellationToken cancellationToken);
    private void CreateNonRegularFile(string filePath, string linkTargetPath);
    private void VerifyPathsForEntryType(string filePath, string linkTargetPath, bool overwrite);
    private void ExtractAsRegularFile(string destinationFileName);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarEntry/<ExtractAsRegularFileAsync>d__47")]
private Task ExtractAsRegularFileAsync(string destinationFileName, CancellationToken cancellationToken);
    private static void AttemptSetLastWriteTime(string destinationFileName, DateTimeOffset lastWriteTime);
    private FileStreamOptions CreateFileStreamOptions(bool isAsync);
    private void ExtractAsBlockDevice(string destinationFileName);
    private void ExtractAsCharacterDevice(string destinationFileName);
    private void ExtractAsFifo(string destinationFileName);
    private void ExtractAsHardLink(string targetFilePath, string hardLinkFilePath);
}
public enum System.Formats.Tar.TarEntryFormat : Enum {
    public int value__;
    public static TarEntryFormat Unknown;
    public static TarEntryFormat V7;
    public static TarEntryFormat Ustar;
    public static TarEntryFormat Pax;
    public static TarEntryFormat Gnu;
}
public enum System.Formats.Tar.TarEntryType : Enum {
    public byte value__;
    public static TarEntryType RegularFile;
    public static TarEntryType HardLink;
    public static TarEntryType SymbolicLink;
    public static TarEntryType CharacterDevice;
    public static TarEntryType BlockDevice;
    public static TarEntryType Directory;
    public static TarEntryType Fifo;
    public static TarEntryType ContiguousFile;
    public static TarEntryType ExtendedAttributes;
    public static TarEntryType GlobalExtendedAttributes;
    public static TarEntryType DirectoryList;
    public static TarEntryType LongLink;
    public static TarEntryType LongPath;
    public static TarEntryType MultiVolume;
    public static TarEntryType V7RegularFile;
    public static TarEntryType RenamedOrSymlinked;
    public static TarEntryType SparseFile;
    public static TarEntryType TapeVolume;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Formats.Tar.TarFile : object {
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, bool includeBaseDirectory);
    public static Task CreateFromDirectoryAsync(string sourceDirectoryName, Stream destination, bool includeBaseDirectory, CancellationToken cancellationToken);
    public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory);
    public static Task CreateFromDirectoryAsync(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory, CancellationToken cancellationToken);
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles);
    public static Task ExtractToDirectoryAsync(Stream source, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken);
    public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, bool overwriteFiles);
    public static Task ExtractToDirectoryAsync(string sourceFileName, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken);
    private static void CreateFromDirectoryInternal(string sourceDirectoryName, Stream destination, bool includeBaseDirectory, bool leaveOpen);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarFile/<CreateFromDirectoryInternalAsync>d__9")]
private static Task CreateFromDirectoryInternalAsync(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarFile/<CreateFromDirectoryInternalAsync>d__10")]
private static Task CreateFromDirectoryInternalAsync(string sourceDirectoryName, Stream destination, bool includeBaseDirectory, bool leaveOpen, CancellationToken cancellationToken);
    private static IEnumerable`1<FileSystemInfo> GetFileSystemEnumerationForCreation(string sourceDirectoryName);
    private static string GetBasePathForCreateFromDirectory(DirectoryInfo di, bool includeBaseDirectory);
    private static string GetEntryNameForFileSystemInfo(FileSystemInfo file, int basePathLength);
    private static string GetEntryNameForBaseDirectory(string name);
    private static void ExtractToDirectoryInternal(Stream source, string destinationDirectoryPath, bool overwriteFiles, bool leaveOpen);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarFile/<ExtractToDirectoryInternalAsync>d__16")]
private static Task ExtractToDirectoryInternalAsync(string sourceFileName, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarFile/<ExtractToDirectoryInternalAsync>d__17")]
private static Task ExtractToDirectoryInternalAsync(Stream source, string destinationDirectoryPath, bool overwriteFiles, bool leaveOpen, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetFileSystemEnumerationForCreation>g__IsNotADirectorySymlink|11_0(FileSystemEntry& entry);
}
internal class System.Formats.Tar.TarHeader : object {
    internal Stream _dataStream;
    internal long _endOfHeaderAndDataAndBlockAlignment;
    internal TarEntryFormat _format;
    internal string _name;
    internal int _mode;
    internal int _uid;
    internal int _gid;
    internal long _size;
    internal DateTimeOffset _mTime;
    internal int _checksum;
    internal TarEntryType _typeFlag;
    internal string _linkName;
    internal string _magic;
    internal string _version;
    internal string _gName;
    internal string _uName;
    internal int _devMajor;
    internal int _devMinor;
    internal string _prefix;
    private Dictionary`2<string, string> _ea;
    internal DateTimeOffset _aTime;
    internal DateTimeOffset _cTime;
    internal Byte[] _gnuUnusedBytes;
    internal Dictionary`2<string, string> ExtendedAttributes { get; }
    private static ReadOnlySpan`1<byte> UstarMagicBytes { get; }
    private static ReadOnlySpan`1<byte> UstarVersionBytes { get; }
    private static ReadOnlySpan`1<byte> GnuMagicBytes { get; }
    private static ReadOnlySpan`1<byte> GnuVersionBytes { get; }
    internal TarHeader(TarEntryFormat format, string name, int mode, DateTimeOffset mTime, TarEntryType typeFlag);
    internal TarHeader(TarEntryFormat format, TarEntryType typeFlag, TarHeader other);
    internal Dictionary`2<string, string> get_ExtendedAttributes();
    internal void InitializeExtendedAttributesWithExisting(IEnumerable`1<KeyValuePair`2<string, string>> existing);
    private static string GetMagicForFormat(TarEntryFormat format);
    private static string GetVersionForFormat(TarEntryFormat format);
    internal static TarHeader TryGetNextHeader(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<TryGetNextHeaderAsync>d__50")]
internal static ValueTask`1<TarHeader> TryGetNextHeaderAsync(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock, CancellationToken cancellationToken);
    private static TarHeader TryReadAttributes(TarEntryFormat initialFormat, Span`1<byte> buffer);
    internal void ReplaceNormalAttributesWithExtended(Dictionary`2<string, string> dictionaryFromExtendedAttributesHeader);
    internal void ProcessDataBlock(Stream archiveStream, bool copyData);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<ProcessDataBlockAsync>d__54")]
private Task ProcessDataBlockAsync(Stream archiveStream, bool copyData, CancellationToken cancellationToken);
    private Stream GetDataStream(Stream archiveStream, bool copyData);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<GetDataStreamAsync>d__56")]
private static ValueTask`1<Stream> GetDataStreamAsync(Stream archiveStream, bool copyData, long size, CancellationToken cancellationToken);
    private static TarHeader TryReadCommonAttributes(Span`1<byte> buffer, TarEntryFormat initialFormat);
    private void ReadMagicAttribute(Span`1<byte> buffer);
    private void ReadVersionAttribute(Span`1<byte> buffer);
    private void ReadPosixAndGnuSharedAttributes(Span`1<byte> buffer);
    private void ReadGnuAttributes(Span`1<byte> buffer);
    private void ReadUstarAttributes(Span`1<byte> buffer);
    private void ReadExtendedAttributesBlock(Stream archiveStream);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<ReadExtendedAttributesBlockAsync>d__64")]
private ValueTask ReadExtendedAttributesBlockAsync(Stream archiveStream, CancellationToken cancellationToken);
    private void ValidateSize();
    private void ReadExtendedAttributesFromBuffer(ReadOnlySpan`1<byte> buffer, string name);
    private void ReadGnuLongPathDataBlock(Stream archiveStream);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<ReadGnuLongPathDataBlockAsync>d__68")]
private ValueTask ReadGnuLongPathDataBlockAsync(Stream archiveStream, CancellationToken cancellationToken);
    private void ReadGnuLongPathDataFromBuffer(ReadOnlySpan`1<byte> buffer);
    private static bool TryGetNextExtendedAttribute(ReadOnlySpan`1& buffer, String& key, String& value);
    private static ReadOnlySpan`1<byte> get_UstarMagicBytes();
    private static ReadOnlySpan`1<byte> get_UstarVersionBytes();
    private static ReadOnlySpan`1<byte> get_GnuMagicBytes();
    private static ReadOnlySpan`1<byte> get_GnuVersionBytes();
    internal void WriteAsV7(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsV7Async>d__82")]
internal Task WriteAsV7Async(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteV7FieldsToBuffer(Span`1<byte> buffer);
    internal void WriteAsUstar(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsUstarAsync>d__85")]
internal Task WriteAsUstarAsync(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteUstarFieldsToBuffer(Span`1<byte> buffer);
    internal void WriteAsPaxGlobalExtendedAttributes(Stream archiveStream, Span`1<byte> buffer, int globalExtendedAttributesEntryNumber);
    internal Task WriteAsPaxGlobalExtendedAttributesAsync(Stream archiveStream, Memory`1<byte> buffer, int globalExtendedAttributesEntryNumber, CancellationToken cancellationToken);
    private void VerifyGlobalExtendedAttributesDataIsValid(int globalExtendedAttributesEntryNumber);
    internal void WriteAsPax(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsPaxAsync>d__91")]
internal Task WriteAsPaxAsync(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    internal void WriteAsGnu(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsGnuAsync>d__93")]
internal Task WriteAsGnuAsync(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    private static TarHeader GetGnuLongMetadataHeader(TarEntryType entryType, string longText);
    internal void WriteAsGnuInternal(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsGnuInternalAsync>d__96")]
internal Task WriteAsGnuInternalAsync(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteAsGnuSharedInternal(Span`1<byte> buffer);
    private void WriteAsPaxExtendedAttributes(Stream archiveStream, Span`1<byte> buffer, Dictionary`2<string, string> extendedAttributes, bool isGea, int globalExtendedAttributesEntryNumber);
    private Task WriteAsPaxExtendedAttributesAsync(Stream archiveStream, Memory`1<byte> buffer, Dictionary`2<string, string> extendedAttributes, bool isGea, int globalExtendedAttributesEntryNumber, CancellationToken cancellationToken);
    private void WriteAsPaxExtendedAttributesShared(bool isGea, int globalExtendedAttributesEntryNumber, Dictionary`2<string, string> extendedAttributes);
    private void WriteAsPaxInternal(Stream archiveStream, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteAsPaxInternalAsync>d__102")]
private Task WriteAsPaxInternalAsync(Stream archiveStream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteAsPaxSharedInternal(Span`1<byte> buffer);
    private int WriteName(Span`1<byte> buffer);
    private int WriteUstarName(Span`1<byte> buffer);
    private int WriteCommonFields(Span`1<byte> buffer, TarEntryType actualEntryType);
    private long GetTotalDataBytesToWrite();
    private static int WritePosixMagicAndVersion(Span`1<byte> buffer);
    private static int WriteGnuMagicAndVersion(Span`1<byte> buffer);
    private int WritePosixAndGnuSharedFields(Span`1<byte> buffer);
    private int WriteGnuFields(Span`1<byte> buffer);
    private static void WriteData(Stream archiveStream, Stream dataStream, long actualLength);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHeader/<WriteDataAsync>d__113")]
private static Task WriteDataAsync(Stream archiveStream, Stream dataStream, long actualLength, CancellationToken cancellationToken);
    private static Stream GenerateExtendedAttributesDataStream(Dictionary`2<string, string> extendedAttributes);
    private void CollectExtendedAttributesFromStandardFieldsIfNeeded();
    internal static int WriteChecksum(int checksum, Span`1<byte> buffer);
    private static int WriteLeftAlignedBytesAndGetChecksum(ReadOnlySpan`1<byte> bytesToWrite, Span`1<byte> destination);
    private static int WriteRightAlignedBytesAndGetChecksum(ReadOnlySpan`1<byte> bytesToWrite, Span`1<byte> destination);
    private static int Checksum(ReadOnlySpan`1<byte> bytes);
    internal static int FormatOctal(long value, Span`1<byte> destination);
    private static int WriteAsTimestamp(DateTimeOffset timestamp, Span`1<byte> destination);
    private static int WriteAsUtf8String(ReadOnlySpan`1<char> text, Span`1<byte> buffer);
    private string GenerateExtendedAttributeName();
    private static string GenerateGlobalExtendedAttributeName(int globalExtendedAttributesEntryNumber);
    private static int GetUtf8TextLength(ReadOnlySpan`1<char> text);
    private static int GetUtf16TruncatedTextLength(ReadOnlySpan`1<char> text, int utf8MaxLength);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
private void <ValidateSize>g__ThrowSizeFieldTooLarge|65_0();
    [CompilerGeneratedAttribute]
internal static int <GenerateExtendedAttributesDataStream>g__CountDigits|114_0(int value);
    [CompilerGeneratedAttribute]
internal static void <CollectExtendedAttributesFromStandardFieldsIfNeeded>g__TryAddStringField|115_0(Dictionary`2<string, string> extendedAttributes, string key, string value, int maxLength);
}
internal static class System.Formats.Tar.TarHelpers : object {
    private static Lazy`1<UnixFileMode> s_umask;
    private static ReverseStringComparer s_reverseStringComparer;
    private static UnixFileMode UMask { get; }
    private static TarHelpers();
    internal static int GetDefaultMode(TarEntryType type);
    internal static void AdvanceStream(Stream archiveStream, long bytesToDiscard);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHelpers/<AdvanceStreamAsync>d__8")]
internal static ValueTask AdvanceStreamAsync(Stream archiveStream, long bytesToDiscard, CancellationToken cancellationToken);
    internal static void CopyBytes(Stream origin, Stream destination, long bytesToCopy);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHelpers/<CopyBytesAsync>d__10")]
internal static ValueTask CopyBytesAsync(Stream origin, Stream destination, long bytesToCopy, CancellationToken cancellationToken);
    internal static int CalculatePadding(long size);
    internal static bool IsAllNullBytes(Span`1<byte> buffer);
    internal static DateTimeOffset GetDateTimeOffsetFromSecondsSinceEpoch(long secondsSinceUnixEpoch);
    private static DateTimeOffset GetDateTimeOffsetFromSecondsSinceEpoch(decimal secondsSinceUnixEpoch);
    private static decimal GetSecondsSinceEpochFromDateTimeOffset(DateTimeOffset dateTimeOffset);
    internal static bool TryGetDateTimeOffsetFromTimestampString(Dictionary`2<string, string> dict, string fieldName, DateTimeOffset& dateTimeOffset);
    internal static string GetTimestampStringFromDateTimeOffset(DateTimeOffset timestamp);
    internal static bool TryGetStringAsBaseTenInteger(IReadOnlyDictionary`2<string, string> dict, string fieldName, Int32& baseTenInteger);
    internal static bool TryGetStringAsBaseTenLong(IReadOnlyDictionary`2<string, string> dict, string fieldName, Int64& baseTenLong);
    internal static TarEntryType GetCorrectTypeFlagForFormat(TarEntryFormat format, TarEntryType entryType);
    internal static T ParseOctal(ReadOnlySpan`1<byte> buffer);
    [DoesNotReturnAttribute]
private static void ThrowInvalidNumber();
    private static string GetTrimmedString(ReadOnlySpan`1<byte> buffer, Encoding encoding);
    internal static ReadOnlySpan`1<byte> TrimEndingNullsAndSpaces(ReadOnlySpan`1<byte> buffer);
    private static ReadOnlySpan`1<byte> TrimLeadingNullsAndSpaces(ReadOnlySpan`1<byte> buffer);
    internal static string GetTrimmedUtf8String(ReadOnlySpan`1<byte> buffer);
    internal static int SkipBlockAlignmentPadding(Stream archiveStream, long size);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarHelpers/<SkipBlockAlignmentPaddingAsync>d__29")]
internal static ValueTask`1<int> SkipBlockAlignmentPaddingAsync(Stream archiveStream, long size, CancellationToken cancellationToken);
    internal static void ThrowIfEntryTypeNotSupported(TarEntryType entryType, TarEntryFormat archiveFormat, string paramName);
    private static UnixFileMode DetermineUMask();
    private static UnixFileMode get_UMask();
    internal static SortedDictionary`2<string, UnixFileMode> CreatePendingModesDictionary();
    internal static void CreateDirectory(string fullPath, Nullable`1<UnixFileMode> mode, SortedDictionary`2<string, UnixFileMode> pendingModes);
    internal static void SetPendingModes(SortedDictionary`2<string, UnixFileMode> pendingModes);
    internal static string EntryFromPath(ReadOnlySpan`1<char> path, bool appendPathSeparator);
}
public class System.Formats.Tar.TarReader : object {
    private bool _isDisposed;
    private bool _leaveOpen;
    private TarEntry _previouslyReadEntry;
    private List`1<Stream> _dataStreamsToDispose;
    private bool _reachedEndMarkers;
    internal Stream _archiveStream;
    [NullableContextAttribute("1")]
public TarReader(Stream archiveStream, bool leaveOpen);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
public TarEntry GetNextEntry(bool copyData);
    public ValueTask`1<TarEntry> GetNextEntryAsync(bool copyData, CancellationToken cancellationToken);
    internal void AdvanceDataStreamIfNeeded();
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<AdvanceDataStreamIfNeededAsync>d__12")]
internal ValueTask AdvanceDataStreamIfNeededAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<GetNextEntryInternalAsync>d__13")]
private ValueTask`1<TarEntry> GetNextEntryInternalAsync(bool copyData, CancellationToken cancellationToken);
    private TarHeader TryGetNextEntryHeader(bool copyData);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<TryGetNextEntryHeaderAsync>d__15")]
private ValueTask`1<TarHeader> TryGetNextEntryHeaderAsync(bool copyData, CancellationToken cancellationToken);
    private bool TryProcessExtendedAttributesHeader(TarHeader extendedAttributesHeader, bool copyData, TarHeader& actualHeader);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<TryProcessExtendedAttributesHeaderAsync>d__17")]
private ValueTask`1<TarHeader> TryProcessExtendedAttributesHeaderAsync(TarHeader extendedAttributesHeader, bool copyData, CancellationToken cancellationToken);
    private bool TryProcessGnuMetadataHeader(TarHeader header, bool copyData, TarHeader& finalHeader);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarReader/<TryProcessGnuMetadataHeaderAsync>d__19")]
private ValueTask`1<TarHeader> TryProcessGnuMetadataHeaderAsync(TarHeader header, bool copyData, CancellationToken cancellationToken);
    private void PreserveDataStreamForDisposalIfNeeded(TarEntry entry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.TarWriter : object {
    private bool _wroteEntries;
    private bool _isDisposed;
    private bool _leaveOpen;
    private Stream _archiveStream;
    private int _nextGlobalExtendedAttributesEntryNumber;
    [CompilerGeneratedAttribute]
private TarEntryFormat <Format>k__BackingField;
    private Dictionary`2<UInt32, string> _userIdentifiers;
    private Dictionary`2<UInt32, string> _groupIdentifiers;
    public TarEntryFormat Format { get; private set; }
    public TarWriter(Stream archiveStream);
    public TarWriter(Stream archiveStream, bool leaveOpen);
    public TarWriter(Stream archiveStream, TarEntryFormat format, bool leaveOpen);
    [CompilerGeneratedAttribute]
public TarEntryFormat get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(TarEntryFormat value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Formats.Tar.TarWriter/<DisposeAsync>d__13")]
public sealed virtual ValueTask DisposeAsync();
    public void WriteEntry(string fileName, string entryName);
    public Task WriteEntryAsync(string fileName, string entryName, CancellationToken cancellationToken);
    private void ReadFileFromDiskAndWriteToArchiveStreamAsEntry(string fullPath, string entryName);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarWriter/<ReadFileFromDiskAndWriteToArchiveStreamAsEntryAsync>d__17")]
private Task ReadFileFromDiskAndWriteToArchiveStreamAsEntryAsync(string fullPath, string entryName, CancellationToken cancellationToken);
    public void WriteEntry(TarEntry entry);
    public Task WriteEntryAsync(TarEntry entry, CancellationToken cancellationToken);
    private void WriteEntryInternal(TarEntry entry);
    [AsyncStateMachineAttribute("System.Formats.Tar.TarWriter/<WriteEntryAsyncInternal>d__21")]
private Task WriteEntryAsyncInternal(TarEntry entry, CancellationToken cancellationToken);
    private void WriteFinalRecords();
    [AsyncStateMachineAttribute("System.Formats.Tar.TarWriter/<WriteFinalRecordsAsync>d__23")]
private ValueTask WriteFinalRecordsAsync();
    private ValueTuple`2<string, string> ValidateWriteEntryArguments(string fileName, string entryName);
    private static void ValidateEntryLinkName(TarEntryType entryType, string linkName);
    private TarEntry ConstructEntryForWriting(string fullPath, string entryName, FileOptions fileOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.UstarTarEntry : PosixTarEntry {
    internal UstarTarEntry(TarHeader header, TarReader readerOfOrigin);
    public UstarTarEntry(TarEntryType entryType, string entryName);
    public UstarTarEntry(TarEntry other);
    internal virtual bool IsDataStreamSetterSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Formats.Tar.V7TarEntry : TarEntry {
    internal V7TarEntry(TarHeader header, TarReader readerOfOrigin);
    public V7TarEntry(TarEntryType entryType, string entryName);
    public V7TarEntry(TarEntry other);
    internal virtual bool IsDataStreamSetterSupported();
}
internal static class System.IO.ArchivingUtils : object {
    internal static string SanitizeEntryFilePath(string entryPath);
}
internal static class System.IO.PathInternal : object {
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    internal static ReadOnlySpan`1<byte> Utf8DirectorySeparators { get; }
    internal static string EnsureTrailingSeparator(string path);
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    internal static ReadOnlySpan`1<byte> get_Utf8DirectorySeparators();
    internal static bool IsDirectorySeparator(char c);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_NotSupported_UnreadableStream { get; }
    internal static string IO_NotSupported_UnseekableStream { get; }
    internal static string IO_NotSupported_UnwritableStream { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_StreamDisposed { get; }
    internal static string TarCannotConvertPaxGlobalExtendedAttributesEntry { get; }
    internal static string TarDuplicateExtendedAttribute { get; }
    internal static string TarEntryBlockOrCharacterExpected { get; }
    internal static string TarEntryDoesNotSupportDataStream { get; }
    internal static string TarEntryHardLinkOrSymLinkExpected { get; }
    internal static string TarEntryHardLinkOrSymlinkLinkNameEmpty { get; }
    internal static string TarEntryTypeNotSupported { get; }
    internal static string TarEntryTypeNotSupportedInFormat { get; }
    internal static string TarEntryTypeNotSupportedForExtracting { get; }
    internal static string TarExtractingResultsFileOutside { get; }
    internal static string TarExtractingResultsLinkOutside { get; }
    internal static string TarGnuFormatExpected { get; }
    internal static string TarHardLinkTargetNotExists { get; }
    internal static string TarHardLinkToDirectoryNotAllowed { get; }
    internal static string TarInvalidFormat { get; }
    internal static string TarPosixFormatExpected { get; }
    internal static string TarSizeFieldNegative { get; }
    internal static string TarSizeFieldTooLargeForEntryType { get; }
    internal static string TarSymbolicLinkTargetNotExists { get; }
    internal static string TarUnexpectedMetadataEntry { get; }
    internal static string TarUnsupportedFile { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string TarInvalidNumber { get; }
    internal static string TarEntryFieldExceedsMaxLength { get; }
    internal static string TarSizeFieldTooLargeForEntryFormat { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_NotSupported_UnreadableStream();
    internal static string get_IO_NotSupported_UnseekableStream();
    internal static string get_IO_NotSupported_UnwritableStream();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_StreamDisposed();
    internal static string get_TarCannotConvertPaxGlobalExtendedAttributesEntry();
    internal static string get_TarDuplicateExtendedAttribute();
    internal static string get_TarEntryBlockOrCharacterExpected();
    internal static string get_TarEntryDoesNotSupportDataStream();
    internal static string get_TarEntryHardLinkOrSymLinkExpected();
    internal static string get_TarEntryHardLinkOrSymlinkLinkNameEmpty();
    internal static string get_TarEntryTypeNotSupported();
    internal static string get_TarEntryTypeNotSupportedInFormat();
    internal static string get_TarEntryTypeNotSupportedForExtracting();
    internal static string get_TarExtractingResultsFileOutside();
    internal static string get_TarExtractingResultsLinkOutside();
    internal static string get_TarGnuFormatExpected();
    internal static string get_TarHardLinkTargetNotExists();
    internal static string get_TarHardLinkToDirectoryNotAllowed();
    internal static string get_TarInvalidFormat();
    internal static string get_TarPosixFormatExpected();
    internal static string get_TarSizeFieldNegative();
    internal static string get_TarSizeFieldTooLargeForEntryType();
    internal static string get_TarSymbolicLinkTargetNotExists();
    internal static string get_TarUnexpectedMetadataEntry();
    internal static string get_TarUnsupportedFile();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_TarInvalidNumber();
    internal static string get_TarEntryFieldExceedsMaxLength();
    internal static string get_TarSizeFieldTooLargeForEntryFormat();
}
