internal static class FxResources.System.Net.Mail.SR : object {
}
internal static class System.HexConverter : object {
    public static char ToCharUpper(int value);
}
internal class System.Net.Base64Stream : DelegatedStream {
    private Base64WriteStateInfo _writeState;
    private ReadStateInfo _readState;
    private Base64Encoder _encoder;
    private static ReadOnlySpan`1<byte> Base64DecodeMap { get; }
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal Base64Stream(Stream stream, Base64WriteStateInfo writeStateInfo);
    internal Base64Stream(Base64WriteStateInfo writeStateInfo);
    private static ReadOnlySpan`1<byte> get_Base64DecodeMap();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<FlushAsync>d__23")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void FlushInternal();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<<ReadAsync>g__ReadAsyncCore|26_0>d")]
[CompilerGeneratedAttribute]
private Task`1<int> <ReadAsync>g__ReadAsyncCore|26_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Base64Stream/<<WriteAsync>g__WriteAsyncCore|28_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|28_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__2(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.Net.BufferedReadStream : DelegatedStream {
    private Byte[] _storedBuffer;
    private int _storedLength;
    private int _storedOffset;
    private bool _readMore;
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    internal BufferedReadStream(Stream stream);
    internal BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.BufferedReadStream/<ReadMoreAsync>d__14")]
private Task`1<int> ReadMoreAsync(int bytesAlreadyRead, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    internal void Push(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__0(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.Net.ClosableStream : DelegatedStream {
    private EventHandler _onClose;
    private int _closed;
    internal ClosableStream(Stream stream, EventHandler onClose);
    public virtual void Close();
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    internal ExecutionContext ContextCopy { get; }
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
}
internal abstract class System.Net.DelegatedStream : Stream {
    private Stream _stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.AlternateView : AttachmentBase {
    private LinkedResourceCollection _linkedResources;
    public LinkedResourceCollection LinkedResources { get; }
    [NullableAttribute("2")]
public Uri BaseUri { get; public set; }
    public AlternateView(string fileName);
    public AlternateView(string fileName, string mediaType);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(Stream contentStream, ContentType contentType);
    public LinkedResourceCollection get_LinkedResources();
    [NullableContextAttribute("2")]
public Uri get_BaseUri();
    [NullableContextAttribute("2")]
public void set_BaseUri(Uri value);
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, AlternateView item);
    protected virtual void InsertItem(int index, AlternateView item);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Mail.Attachment : AttachmentBase {
    private string _name;
    private Encoding _nameEncoding;
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public ContentDisposition ContentDisposition { get; }
    [NullableContextAttribute("1")]
public Attachment(string fileName);
    [NullableContextAttribute("1")]
public Attachment(string fileName, string mediaType);
    [NullableContextAttribute("1")]
public Attachment(string fileName, ContentType contentType);
    [NullableContextAttribute("1")]
public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    [NullableContextAttribute("1")]
public Attachment(Stream contentStream, ContentType contentType);
    internal void SetContentTypeName(bool allowUnicode);
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public ContentDisposition get_ContentDisposition();
    internal virtual void PrepareForSending(bool allowUnicode);
    [NullableContextAttribute("1")]
public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
    [NullableContextAttribute("1")]
public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Mail.AttachmentBase : object {
    internal bool disposed;
    private MimePart _part;
    public Stream ContentStream { get; }
    public string ContentId { get; public set; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    [NullableAttribute("2")]
internal Uri ContentLocation { get; internal set; }
    internal MimePart MimePart { get; }
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, string mediaType);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, string mediaType);
    internal AttachmentBase(Stream contentStream, string name, string mediaType);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void SetContentFromFile(string fileName, ContentType contentType);
    internal void SetContentFromFile(string fileName, string mediaType);
    internal void SetContentFromString(string content, ContentType contentType);
    internal void SetContentFromString(string content, Encoding encoding, string mediaType);
    internal virtual void PrepareForSending(bool allowUnicode);
    public Stream get_ContentStream();
    public string get_ContentId();
    public void set_ContentId(string value);
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    internal Uri get_ContentLocation();
    internal void set_ContentLocation(Uri value);
    internal MimePart get_MimePart();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, Attachment item);
    protected virtual void InsertItem(int index, Attachment item);
}
internal static class System.Net.Mail.AuthCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string type, string message, AsyncCallback callback, object state);
    internal static IAsyncResult BeginSend(SmtpConnection conn, string message, AsyncCallback callback, object state);
    private static LineInfo CheckResponse(LineInfo[] lines);
    internal static LineInfo EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string type, string message);
    private static void PrepareCommand(SmtpConnection conn, string message);
    internal static LineInfo Send(SmtpConnection conn, string type, string message);
    internal static LineInfo Send(SmtpConnection conn, string message);
}
internal class System.Net.Mail.BufferBuilder : object {
    private Byte[] _buffer;
    private int _offset;
    internal int Length { get; }
    internal BufferBuilder(int initialSize);
    private void EnsureBuffer(int count);
    internal void Append(byte value);
    internal void Append(ReadOnlySpan`1<byte> value);
    internal void Append(string value);
    internal void Append(string value, bool allowUnicode);
    internal void Append(string value, int offset, int count, bool allowUnicode);
    internal void Append(string value, int offset, int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
}
internal static class System.Net.Mail.CheckCommand : object {
    private static AsyncCallback s_onReadLine;
    private static AsyncCallback s_onWrite;
    private static CheckCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static object EndSend(IAsyncResult result, String& response);
    private static void OnReadLine(IAsyncResult result);
    private static void OnWrite(IAsyncResult result);
    internal static SmtpStatusCode Send(SmtpConnection conn, String& response);
}
internal static class System.Net.Mail.DataCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
internal static class System.Net.Mail.DataStopCommand : object {
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnSuccess;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
}
internal static class System.Net.Mail.DomainLiteralReader : object {
    internal static bool TryReadReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
internal static class System.Net.Mail.DotAtomReader : object {
    internal static bool TryReadReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
internal static class System.Net.Mail.EHelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    private static String[] CheckResponse(LineInfo[] lines);
    internal static String[] EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string domain);
    internal static String[] Send(SmtpConnection conn, string domain);
}
internal static class System.Net.Mail.HelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string domain);
    internal static void Send(SmtpConnection conn, string domain);
}
internal interface System.Net.Mail.ISmtpAuthenticationModule {
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, NetworkCredential credentials, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public abstract virtual string get_AuthenticationType();
    public abstract virtual void CloseContext(object sessionCookie);
}
[IsReadOnlyAttribute]
internal class System.Net.Mail.LineInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private SmtpStatusCode <StatusCode>k__BackingField;
    internal string Line { get; }
    internal SmtpStatusCode StatusCode { get; }
    internal LineInfo(SmtpStatusCode statusCode, string line);
    [CompilerGeneratedAttribute]
internal string get_Line();
    [CompilerGeneratedAttribute]
internal SmtpStatusCode get_StatusCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.LinkedResource : AttachmentBase {
    [NullableAttribute("2")]
public Uri ContentLink { get; public set; }
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, string mediaType);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, string mediaType);
    public LinkedResource(Stream contentStream, ContentType contentType);
    [NullableContextAttribute("2")]
public Uri get_ContentLink();
    [NullableContextAttribute("2")]
public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, LinkedResource item);
    protected virtual void InsertItem(int index, LinkedResource item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.MailAddress : object {
    [CompilerGeneratedAttribute]
private static bool <EnableFullDomainLiterals>k__BackingField;
    private Encoding _displayNameEncoding;
    private string _displayName;
    private string _userName;
    private string _host;
    private static bool EnableFullDomainLiterals { get; }
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public string Address { get; }
    private string SmtpAddress { get; }
    internal MailAddress(string displayName, string userName, string domain, Encoding displayNameEncoding);
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    [NullableContextAttribute("2")]
public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    private static MailAddress();
    [CompilerGeneratedAttribute]
private static bool get_EnableFullDomainLiterals();
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, MailAddress& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, string displayName, MailAddress& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(string address, string displayName, Encoding displayNameEncoding, MailAddress& result);
    private static bool TryParse(string address, string displayName, Encoding displayNameEncoding, ValueTuple`4& parsedData, bool throwExceptionIfFail);
    public string get_DisplayName();
    public string get_User();
    private string GetUser(bool allowUnicode);
    public string get_Host();
    private string GetHost(bool allowUnicode);
    public string get_Address();
    private string GetAddress(bool allowUnicode);
    private string get_SmtpAddress();
    internal string GetSmtpAddress(bool allowUnicode);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void SetItem(int index, MailAddress item);
    protected virtual void InsertItem(int index, MailAddress item);
    internal void ParseValue(string addresses);
    public virtual string ToString();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
internal static class System.Net.Mail.MailAddressParser : object {
    internal static bool TryParseAddress(string data, ParseAddressInfo& parsedAddress, bool throwExceptionIfFail);
    internal static List`1<MailAddress> ParseMultipleAddresses(string data);
    private static bool TryParseAddress(string data, bool expectMultipleAddresses, Int32& index, ParseAddressInfo& parseAddressInfo, bool throwExceptionIfFail);
    private static bool TryReadCfwsAndThrowIfIncomplete(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
    private static bool TryParseDomain(string data, Int32& index, String& domain, bool throwExceptionIfFail);
    private static bool TryParseLocalPart(string data, Int32& index, bool expectAngleBracket, bool expectMultipleAddresses, String& localPart, bool throwExceptionIfFail);
    private static bool TryParseDisplayName(string data, Int32& index, bool expectMultipleAddresses, String& displayName, bool throwExceptionIfFail);
    internal static bool TryNormalizeOrThrow(string input, String& normalizedString, bool throwExceptionIfFail);
}
internal static class System.Net.Mail.MailCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, ReadOnlySpan`1<byte> command, MailAddress from, bool allowUnicode, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string response);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, ReadOnlySpan`1<byte> command, MailAddress from, bool allowUnicode);
    internal static void Send(SmtpConnection conn, ReadOnlySpan`1<byte> command, MailAddress from, bool allowUnicode);
}
internal enum System.Net.Mail.MailHeaderID : Enum {
    public int value__;
    public static MailHeaderID Bcc;
    public static MailHeaderID Cc;
    public static MailHeaderID Comments;
    public static MailHeaderID ContentDescription;
    public static MailHeaderID ContentDisposition;
    public static MailHeaderID ContentID;
    public static MailHeaderID ContentLocation;
    public static MailHeaderID ContentTransferEncoding;
    public static MailHeaderID ContentType;
    public static MailHeaderID Date;
    public static MailHeaderID From;
    public static MailHeaderID Importance;
    public static MailHeaderID InReplyTo;
    public static MailHeaderID Keywords;
    public static MailHeaderID Max;
    public static MailHeaderID MessageID;
    public static MailHeaderID MimeVersion;
    public static MailHeaderID Priority;
    public static MailHeaderID References;
    public static MailHeaderID ReplyTo;
    public static MailHeaderID ResentBcc;
    public static MailHeaderID ResentCc;
    public static MailHeaderID ResentDate;
    public static MailHeaderID ResentFrom;
    public static MailHeaderID ResentMessageID;
    public static MailHeaderID ResentSender;
    public static MailHeaderID ResentTo;
    public static MailHeaderID Sender;
    public static MailHeaderID Subject;
    public static MailHeaderID To;
    public static MailHeaderID XPriority;
    public static MailHeaderID XReceiver;
    public static MailHeaderID XSender;
    public static MailHeaderID ZMaxEnumValue;
    public static MailHeaderID Unknown;
}
internal static class System.Net.Mail.MailHeaderInfo : object {
    private static HeaderInfo[] s_headerInfo;
    private static Dictionary`2<string, int> s_headerDictionary;
    private static MailHeaderInfo();
    private static Dictionary`2<string, int> CreateHeaderDictionary();
    internal static string GetString(MailHeaderID id);
    internal static bool IsUserSettable(string name);
    internal static bool IsSingleton(string name);
    internal static string NormalizeCase(string name);
    internal static bool AllowsUnicode(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mail.MailMessage : object {
    private AlternateViewCollection _views;
    private AttachmentCollection _attachments;
    private AlternateView _bodyView;
    private string _body;
    private Encoding _bodyEncoding;
    private TransferEncoding _bodyTransferEncoding;
    private bool _isBodyHtml;
    private bool _disposed;
    private Message _message;
    private DeliveryNotificationOptions _deliveryStatusNotification;
    [NullableAttribute("2")]
public MailAddress From { get; public set; }
    [NullableAttribute("2")]
public MailAddress Sender { get; public set; }
    [NullableAttribute("2")]
[ObsoleteAttribute("ReplyTo has been deprecated. Use ReplyToList instead, which can accept multiple addresses.")]
public MailAddress ReplyTo { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    public MailAddressCollection To { get; }
    public MailAddressCollection Bcc { get; }
    public MailAddressCollection CC { get; }
    public MailPriority Priority { get; public set; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public string Subject { get; public set; }
    [NullableAttribute("2")]
public Encoding SubjectEncoding { get; public set; }
    public NameValueCollection Headers { get; }
    [NullableAttribute("2")]
public Encoding HeadersEncoding { get; public set; }
    public string Body { get; public set; }
    [NullableAttribute("2")]
public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public AttachmentCollection Attachments { get; }
    public AlternateViewCollection AlternateViews { get; }
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    public MailMessage(MailAddress from, MailAddress to);
    [NullableContextAttribute("2")]
public MailAddress get_From();
    [NullableContextAttribute("2")]
public void set_From(MailAddress value);
    [NullableContextAttribute("2")]
public MailAddress get_Sender();
    [NullableContextAttribute("2")]
public void set_Sender(MailAddress value);
    [NullableContextAttribute("2")]
public MailAddress get_ReplyTo();
    [NullableContextAttribute("2")]
public void set_ReplyTo(MailAddress value);
    public MailAddressCollection get_ReplyToList();
    public MailAddressCollection get_To();
    public MailAddressCollection get_Bcc();
    public MailAddressCollection get_CC();
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public string get_Subject();
    public void set_Subject(string value);
    [NullableContextAttribute("2")]
public Encoding get_SubjectEncoding();
    [NullableContextAttribute("2")]
public void set_SubjectEncoding(Encoding value);
    public NameValueCollection get_Headers();
    [NullableContextAttribute("2")]
public Encoding get_HeadersEncoding();
    [NullableContextAttribute("2")]
public void set_HeadersEncoding(Encoding value);
    public string get_Body();
    public void set_Body(string value);
    [NullableContextAttribute("2")]
public Encoding get_BodyEncoding();
    [NullableContextAttribute("2")]
public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public AttachmentCollection get_Attachments();
    public AlternateViewCollection get_AlternateViews();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void SetContent(bool allowUnicode);
    internal void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal IAsyncResult BeginSend(BaseWriter writer, bool allowUnicode, AsyncCallback callback, object state);
    internal void EndSend(IAsyncResult asyncResult);
    internal string BuildDeliveryStatusNotificationString();
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority Normal;
    public static MailPriority Low;
    public static MailPriority High;
}
internal class System.Net.Mail.MailWriter : BaseWriter {
    internal MailWriter(Stream stream, bool encodeForTransport);
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal virtual void Close();
    protected virtual void OnClose(object sender, EventArgs args);
}
internal class System.Net.Mail.Message : object {
    private MailAddress _from;
    private MailAddress _sender;
    private MailAddressCollection _replyToList;
    private MailAddress _replyTo;
    private MailAddressCollection _to;
    private MailAddressCollection _cc;
    private MailAddressCollection _bcc;
    private MimeBasePart _content;
    private HeaderCollection _headers;
    private HeaderCollection _envelopeHeaders;
    private string _subject;
    private Encoding _subjectEncoding;
    private Encoding _headersEncoding;
    private MailPriority _priority;
    public MailPriority Priority { get; public set; }
    internal MailAddress From { get; internal set; }
    internal MailAddress Sender { get; internal set; }
    internal MailAddress ReplyTo { get; internal set; }
    internal MailAddressCollection ReplyToList { get; }
    internal MailAddressCollection To { get; }
    internal MailAddressCollection Bcc { get; }
    internal MailAddressCollection CC { get; }
    internal string Subject { get; internal set; }
    internal Encoding SubjectEncoding { get; internal set; }
    internal HeaderCollection Headers { get; }
    internal Encoding HeadersEncoding { get; internal set; }
    internal HeaderCollection EnvelopeHeaders { get; }
    internal MimeBasePart Content { get; internal set; }
    internal Message(string from, string to);
    internal Message(MailAddress from, MailAddress to);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    internal MailAddress get_From();
    internal void set_From(MailAddress value);
    internal MailAddress get_Sender();
    internal void set_Sender(MailAddress value);
    internal MailAddress get_ReplyTo();
    internal void set_ReplyTo(MailAddress value);
    internal MailAddressCollection get_ReplyToList();
    internal MailAddressCollection get_To();
    internal MailAddressCollection get_Bcc();
    internal MailAddressCollection get_CC();
    internal string get_Subject();
    internal void set_Subject(string value);
    internal Encoding get_SubjectEncoding();
    internal void set_SubjectEncoding(Encoding value);
    internal HeaderCollection get_Headers();
    internal Encoding get_HeadersEncoding();
    internal void set_HeadersEncoding(Encoding value);
    internal HeaderCollection get_EnvelopeHeaders();
    internal MimeBasePart get_Content();
    internal void set_Content(MimeBasePart value);
    internal void EmptySendCallback(IAsyncResult result);
    internal IAsyncResult BeginSend(BaseWriter writer, bool allowUnicode, AsyncCallback callback, object state);
    internal void EndSend(IAsyncResult asyncResult);
    internal void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal void PrepareEnvelopeHeaders(bool allowUnicode);
    internal void PrepareHeaders(bool allowUnicode);
    internal void EncodeHeaders(HeaderCollection headers, bool allowUnicode);
    private bool IsHeaderSet(string headerName);
}
[IsReadOnlyAttribute]
internal class System.Net.Mail.ParseAddressInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public ParseAddressInfo(string displayName, string userName, string domain);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public string get_Host();
}
internal static class System.Net.Mail.QuitCommand : object {
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
internal static class System.Net.Mail.QuotedPairReader : object {
    internal static bool TryCountQuotedChars(string data, int index, bool permitUnicodeEscaping, Int32& outIndex, bool throwExceptionIfFail);
    private static int CountBackslashes(string data, int index);
}
internal static class System.Net.Mail.QuotedStringFormatReader : object {
    internal static bool TryReadReverseQuoted(string data, int index, bool permitUnicode, Int32& outIndex, bool throwExceptionIfFail);
    internal static bool TryReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter, Int32& outIndex, bool throwExceptionIfFail);
    private static bool IsValidQtext(bool allowUnicode, char ch);
}
internal static class System.Net.Mail.ReadLinesCommand : object {
    private static AsyncCallback s_onReadLines;
    private static AsyncCallback s_onWrite;
    private static ReadLinesCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static LineInfo[] EndSend(IAsyncResult result);
    private static void OnReadLines(IAsyncResult result);
    private static void OnWrite(IAsyncResult result);
    internal static LineInfo[] Send(SmtpConnection conn);
}
internal static class System.Net.Mail.RecipientCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string to, AsyncCallback callback, object state);
    private static bool CheckResponse(SmtpStatusCode statusCode, string response);
    internal static bool EndSend(IAsyncResult result, String& response);
    private static void PrepareCommand(SmtpConnection conn, string to);
    internal static bool Send(SmtpConnection conn, string to, String& response);
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.Mail.SendMailAsyncResult : LazyAsyncResult {
    private SmtpConnection _connection;
    private MailAddress _from;
    private string _deliveryNotify;
    private static AsyncCallback s_sendMailFromCompleted;
    private static AsyncCallback s_sendToCollectionCompleted;
    private static AsyncCallback s_sendDataCompleted;
    private List`1<SmtpFailedRecipientException> _failedRecipientExceptions;
    private Stream _stream;
    private MailAddressCollection _toCollection;
    private int _toIndex;
    private bool _allowUnicode;
    internal SendMailAsyncResult(SmtpConnection connection, MailAddress from, MailAddressCollection toCollection, bool allowUnicode, string deliveryNotify, AsyncCallback callback, object state);
    private static SendMailAsyncResult();
    internal void Send();
    internal static MailWriter End(IAsyncResult result);
    private void SendMailFrom();
    private static void SendMailFromCompleted(IAsyncResult result);
    private void SendToCollection();
    private static void SendToCollectionCompleted(IAsyncResult result);
    private void SendData();
    private static void SendDataCompleted(IAsyncResult result);
    internal SmtpFailedRecipientException GetFailedRecipientException();
}
internal static class System.Net.Mail.SmtpAuthenticationManager : object {
    private static List`1<ISmtpAuthenticationModule> s_modules;
    private static SmtpAuthenticationManager();
    internal static void Register(ISmtpAuthenticationModule module);
    internal static ISmtpAuthenticationModule[] GetModules();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Net.Mail.SmtpClient : object {
    private string _host;
    private int _port;
    private int _timeout;
    private bool _inCall;
    private bool _cancelled;
    private bool _timedOut;
    private string _targetName;
    private SmtpDeliveryMethod _deliveryMethod;
    private SmtpDeliveryFormat _deliveryFormat;
    private string _pickupDirectoryLocation;
    private SmtpTransport _transport;
    private MailMessage _message;
    private MailWriter _writer;
    private MailAddressCollection _recipients;
    private SendOrPostCallback _onSendCompletedDelegate;
    private Timer _timer;
    private ContextAwareResult _operationCompletedResult;
    private AsyncOperation _asyncOp;
    private static AsyncCallback s_contextSafeCompleteCallback;
    internal string _clientDomain;
    private bool _disposed;
    private ServicePoint _servicePoint;
    private SmtpFailedRecipientException _failedRecipientException;
    [CompilerGeneratedAttribute]
private SendCompletedEventHandler SendCompleted;
    private bool _useDefaultCredentials;
    private ICredentialsByHost _customCredentials;
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public int Timeout { get; public set; }
    [NullableAttribute("1")]
public ServicePoint ServicePoint { get; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public bool EnableSsl { get; public set; }
    [NullableAttribute("1")]
public X509CertificateCollection ClientCertificates { get; }
    public string TargetName { get; public set; }
    private bool ServerSupportsEai { get; }
    internal bool InCall { get; internal set; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    private static SmtpClient();
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    [MemberNotNullAttribute("_transport")]
[MemberNotNullAttribute("_onSendCompletedDelegate")]
[MemberNotNullAttribute("_clientDomain")]
private void Initialize();
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    private void UpdateTransportCredentials();
    public int get_Timeout();
    public void set_Timeout(int value);
    [NullableContextAttribute("1")]
public ServicePoint get_ServicePoint();
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    [NullableContextAttribute("1")]
public X509CertificateCollection get_ClientCertificates();
    public string get_TargetName();
    public void set_TargetName(string value);
    private bool get_ServerSupportsEai();
    private bool IsUnicodeSupported();
    internal MailWriter GetFileMailWriter(string pickupDirectory);
    [NullableContextAttribute("1")]
protected void OnSendCompleted(AsyncCompletedEventArgs e);
    private void SendCompletedWaitCallback(object operationState);
    [NullableContextAttribute("1")]
public void Send(string from, string recipients, string subject, string body);
    [NullableContextAttribute("1")]
public void Send(MailMessage message);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    [NullableContextAttribute("1")]
public void SendAsync(MailMessage message, object userToken);
    private static bool IsSystemNetworkCredentialInCache(CredentialCache cache);
    public void SendAsyncCancel();
    [NullableContextAttribute("1")]
public Task SendMailAsync(string from, string recipients, string subject, string body);
    [NullableContextAttribute("1")]
public Task SendMailAsync(MailMessage message);
    [NullableContextAttribute("1")]
public Task SendMailAsync(string from, string recipients, string subject, string body, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task SendMailAsync(MailMessage message, CancellationToken cancellationToken);
    internal bool get_InCall();
    internal void set_InCall(bool value);
    private void CheckHostAndPort();
    private void TimeOutCallback(object state);
    private void Complete(Exception exception, object result);
    private static void ContextSafeCompleteCallback(IAsyncResult ar);
    private void SendMessageCallback(IAsyncResult result);
    private void SendMailCallback(IAsyncResult result);
    private void ConnectCallback(IAsyncResult result);
    private void SendMailAsync(object state);
    private static void ValidateUnicodeRequirement(MailMessage message, MailAddressCollection recipients, bool allowUnicode);
    private void GetConnection();
    private void Abort();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal static class System.Net.Mail.SmtpCommands : object {
    internal static ReadOnlySpan`1<byte> Auth { get; }
    internal static ReadOnlySpan`1<byte> CRLF { get; }
    internal static ReadOnlySpan`1<byte> Data { get; }
    internal static ReadOnlySpan`1<byte> DataStop { get; }
    internal static ReadOnlySpan`1<byte> EHello { get; }
    internal static ReadOnlySpan`1<byte> Hello { get; }
    internal static ReadOnlySpan`1<byte> Mail { get; }
    internal static ReadOnlySpan`1<byte> Quit { get; }
    internal static ReadOnlySpan`1<byte> Recipient { get; }
    internal static ReadOnlySpan`1<byte> StartTls { get; }
    internal static ReadOnlySpan`1<byte> get_Auth();
    internal static ReadOnlySpan`1<byte> get_CRLF();
    internal static ReadOnlySpan`1<byte> get_Data();
    internal static ReadOnlySpan`1<byte> get_DataStop();
    internal static ReadOnlySpan`1<byte> get_EHello();
    internal static ReadOnlySpan`1<byte> get_Hello();
    internal static ReadOnlySpan`1<byte> get_Mail();
    internal static ReadOnlySpan`1<byte> get_Quit();
    internal static ReadOnlySpan`1<byte> get_Recipient();
    internal static ReadOnlySpan`1<byte> get_StartTls();
}
internal class System.Net.Mail.SmtpConnection : object {
    private static ContextCallback s_AuthenticateCallback;
    private BufferBuilder _bufferBuilder;
    private bool _isConnected;
    private bool _isClosed;
    private bool _isStreamOpen;
    private EventHandler _onCloseHandler;
    internal SmtpTransport _parent;
    private SmtpClient _client;
    private NetworkStream _networkStream;
    internal TcpClient _tcpClient;
    private SmtpReplyReaderFactory _responseReader;
    private ICredentialsByHost _credentials;
    private String[] _extensions;
    private bool _enableSsl;
    private X509CertificateCollection _clientCertificates;
    private bool _serverSupportsEai;
    private bool _dsnEnabled;
    private bool _serverSupportsStartTls;
    private bool _sawNegotiate;
    private SupportedAuth _supportedAuth;
    private ISmtpAuthenticationModule[] _authenticationModules;
    private static Char[] s_authExtensionSplitters;
    internal BufferBuilder BufferBuilder { get; }
    internal bool IsConnected { get; }
    internal bool IsStreamOpen { get; }
    internal SmtpReplyReaderFactory Reader { get; }
    internal bool EnableSsl { get; internal set; }
    unknown X509CertificateCollection ClientCertificates {internal set; }
    internal bool DSNEnabled { get; }
    internal bool ServerSupportsEai { get; }
    internal SmtpConnection(SmtpTransport parent, SmtpClient client, ICredentialsByHost credentials, ISmtpAuthenticationModule[] authenticationModules);
    private static SmtpConnection();
    internal BufferBuilder get_BufferBuilder();
    internal bool get_IsConnected();
    internal bool get_IsStreamOpen();
    internal SmtpReplyReaderFactory get_Reader();
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal void set_ClientCertificates(X509CertificateCollection value);
    internal void InitializeConnection(string host, int port);
    internal IAsyncResult BeginInitializeConnection(string host, int port, AsyncCallback callback, object state);
    internal void EndInitializeConnection(IAsyncResult result);
    internal IAsyncResult BeginGetConnection(ContextAwareResult outerResult, AsyncCallback callback, object state, string host, int port);
    internal IAsyncResult BeginFlush(AsyncCallback callback, object state);
    internal void EndFlush(IAsyncResult result);
    internal void Flush();
    private void ShutdownConnection(bool isAbort);
    internal void ReleaseConnection();
    internal void Abort();
    internal void GetConnection(string host, int port);
    private Authorization SetContextAndTryAuthenticate(ISmtpAuthenticationModule module, NetworkCredential credential, ContextAwareResult context);
    private static void AuthenticateCallback(object state);
    internal static void EndGetConnection(IAsyncResult result);
    internal Stream GetClosableStream();
    private void OnClose(object sender, EventArgs args);
    internal bool get_DSNEnabled();
    internal bool get_ServerSupportsEai();
    internal void ParseExtensions(String[] extensions);
    internal bool AuthSupported(ISmtpAuthenticationModule module);
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat SevenBit;
    public static SmtpDeliveryFormat International;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpException : Exception {
    private SmtpStatusCode _statusCode;
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(SmtpStatusCode statusCode, string message);
    public SmtpException(string message);
    public SmtpException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal SmtpException(SmtpStatusCode statusCode, string serverMessage, bool _);
    internal SmtpException(string message, string serverResponse);
    private static string GetMessageForStatus(SmtpStatusCode statusCode, string serverResponse);
    private static string GetMessageForStatus(SmtpStatusCode statusCode);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    private string _failedRecipient;
    internal bool fatal;
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(string message);
    public SmtpFailedRecipientException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public string get_FailedRecipient();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    private SmtpFailedRecipientException[] _innerExceptions;
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    [NullableContextAttribute("2")]
public SmtpFailedRecipientsException(string message);
    [NullableContextAttribute("2")]
public SmtpFailedRecipientsException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    internal SmtpFailedRecipientsException(List`1<SmtpFailedRecipientException> innerExceptions, bool allFailed);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.Mail.SmtpLoginAuthenticationModule : object {
    private Dictionary`2<object, NetworkCredential> _sessions;
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpNegotiateAuthenticationModule : object {
    private static Byte[] s_saslNoSecurtyLayerToken;
    private Dictionary`2<object, NegotiateAuthentication> _sessions;
    public string AuthenticationType { get; }
    private static SmtpNegotiateAuthenticationModule();
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
    private static string GetSecurityLayerOutgoingBlob(string challenge, NegotiateAuthentication clientContext);
}
internal class System.Net.Mail.SmtpNtlmAuthenticationModule : object {
    private Dictionary`2<object, NegotiateAuthentication> _sessions;
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpReplyReader : object {
    private SmtpReplyReaderFactory _reader;
    internal SmtpReplyReader(SmtpReplyReaderFactory reader);
    internal IAsyncResult BeginReadLines(AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(AsyncCallback callback, object state);
    public void Close();
    internal static LineInfo[] EndReadLines(IAsyncResult result);
    internal static LineInfo EndReadLine(IAsyncResult result);
    internal LineInfo[] ReadLines();
    internal LineInfo ReadLine();
}
internal class System.Net.Mail.SmtpReplyReaderFactory : object {
    private BufferedReadStream _bufferedStream;
    private Byte[] _byteBuffer;
    private SmtpReplyReader _currentReader;
    private ReadState _readState;
    private SmtpStatusCode _statusCode;
    internal SmtpStatusCode StatusCode { get; }
    internal SmtpReplyReaderFactory(Stream stream);
    internal SmtpStatusCode get_StatusCode();
    internal IAsyncResult BeginReadLines(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal void Close(SmtpReplyReader caller);
    internal static LineInfo[] EndReadLines(IAsyncResult result);
    internal static LineInfo EndReadLine(IAsyncResult result);
    internal SmtpReplyReader GetNextReplyReader();
    private int ProcessRead(Byte[] buffer, int offset, int read, bool readLine);
    internal int Read(SmtpReplyReader caller, Byte[] buffer, int offset, int count);
    internal LineInfo ReadLine(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller, bool oneLine);
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode UserNotLocalWillForward;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode MustIssueStartTlsFirst;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode GeneralFailure;
}
internal class System.Net.Mail.SmtpTransport : object {
    private ISmtpAuthenticationModule[] _authenticationModules;
    private SmtpConnection _connection;
    private SmtpClient _client;
    private ICredentialsByHost _credentials;
    private List`1<SmtpFailedRecipientException> _failedRecipientExceptions;
    private bool _identityRequired;
    private bool _shouldAbort;
    private bool _enableSsl;
    private X509CertificateCollection _clientCertificates;
    internal ICredentialsByHost Credentials { get; internal set; }
    internal bool IdentityRequired { get; internal set; }
    internal bool IsConnected { get; }
    internal bool EnableSsl { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; }
    internal bool ServerSupportsEai { get; }
    internal SmtpTransport(SmtpClient client);
    internal SmtpTransport(SmtpClient client, ISmtpAuthenticationModule[] authenticationModules);
    internal ICredentialsByHost get_Credentials();
    internal void set_Credentials(ICredentialsByHost value);
    internal bool get_IdentityRequired();
    internal void set_IdentityRequired(bool value);
    internal bool get_IsConnected();
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal X509CertificateCollection get_ClientCertificates();
    internal bool get_ServerSupportsEai();
    internal void GetConnection(string host, int port);
    internal IAsyncResult BeginGetConnection(ContextAwareResult outerResult, AsyncCallback callback, object state, string host, int port);
    internal static void EndGetConnection(IAsyncResult result);
    internal IAsyncResult BeginSendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, AsyncCallback callback, object state);
    internal void ReleaseConnection();
    internal void Abort();
    internal static MailWriter EndSendMail(IAsyncResult result);
    internal MailWriter SendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, SmtpFailedRecipientException& exception);
}
internal static class System.Net.Mail.StartTlsCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string response);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
internal enum System.Net.Mail.SupportedAuth : Enum {
    public int value__;
    public static SupportedAuth None;
    public static SupportedAuth Login;
    public static SupportedAuth NTLM;
    public static SupportedAuth GSSAPI;
}
internal static class System.Net.Mail.WhitespaceReader : object {
    internal static bool TryReadFwsReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
    internal static bool TryReadCfwsReverse(string data, int index, Int32& outIndex, bool throwExceptionIfFail);
}
internal class System.Net.Mime.Base64Encoder : ByteEncoder {
    private int _lineLength;
    private Base64WriteStateInfo _writeState;
    private static ReadOnlySpan`1<byte> Base64EncodeMap { get; }
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal Base64Encoder(Base64WriteStateInfo writeStateInfo, int lineLength);
    private static ReadOnlySpan`1<byte> get_Base64EncodeMap();
    internal virtual WriteStateInfoBase get_WriteState();
    protected virtual bool get_HasSpecialEncodingForCRLF();
    protected virtual void AppendEncodedCRLF();
    protected virtual bool LineBreakNeeded(byte b);
    protected virtual bool LineBreakNeeded(Byte[] bytes, int count);
    private bool LineBreakNeeded(int numberOfBytesToAppend);
    protected virtual int GetCodepointSize(string value, int i);
    public virtual void AppendPadding();
    protected virtual void ApppendEncodedByte(byte b);
}
internal class System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <LastBits>k__BackingField;
    internal int Padding { get; internal set; }
    internal byte LastBits { get; internal set; }
    internal Base64WriteStateInfo(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    [CompilerGeneratedAttribute]
internal int get_Padding();
    [CompilerGeneratedAttribute]
internal void set_Padding(int value);
    [CompilerGeneratedAttribute]
internal byte get_LastBits();
    [CompilerGeneratedAttribute]
internal void set_LastBits(byte value);
}
internal abstract class System.Net.Mime.BaseWriter : object {
    private static AsyncCallback s_onWrite;
    protected BufferBuilder _bufferBuilder;
    protected Stream _stream;
    private EventHandler _onCloseHandler;
    private bool _shouldEncodeLeadingDots;
    private int _lineLength;
    protected Stream _contentStream;
    protected bool _isInContent;
    protected BaseWriter(Stream stream, bool shouldEncodeLeadingDots);
    private static BaseWriter();
    internal abstract virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal void WriteHeader(string name, string value, bool allowUnicode);
    private void WriteAndFold(string value, int charsAlreadyOnLine, bool allowUnicode);
    internal Stream GetContentStream();
    private ClosableStream GetContentStream(MultiAsyncResult multiResult);
    internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state);
    internal static Stream EndGetContentStream(IAsyncResult result);
    protected void Flush(MultiAsyncResult multiResult);
    protected static void OnWrite(IAsyncResult result);
    internal abstract virtual void Close();
    protected abstract virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
internal abstract class System.Net.Mime.ByteEncoder : object {
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal abstract virtual WriteStateInfoBase get_WriteState();
    protected abstract virtual bool get_HasSpecialEncodingForCRLF();
    public sealed virtual string GetEncodedString();
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    protected abstract virtual void AppendEncodedCRLF();
    protected abstract virtual bool LineBreakNeeded(byte b);
    protected abstract virtual bool LineBreakNeeded(Byte[] bytes, int count);
    protected abstract virtual int GetCodepointSize(string value, int i);
    public abstract virtual void AppendPadding();
    protected abstract virtual void ApppendEncodedByte(byte b);
    private void AppendEncodedCodepoint(Byte[] bytes, int count);
    protected static bool IsSurrogatePair(string value, int i);
    protected static bool IsCRLF(Byte[] bytes, int count);
    private static bool IsCRLF(Byte[] buffer, int i, int bufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mime.ContentDisposition : object {
    private TrackingValidationObjectDictionary _parameters;
    private string _disposition;
    private string _dispositionType;
    private bool _isChanged;
    private bool _isPersisted;
    private static ValidateAndParseValue s_dateParser;
    private static ValidateAndParseValue s_longParser;
    private static Dictionary`2<string, ValidateAndParseValue> s_validators;
    public string DispositionType { get; public set; }
    public StringDictionary Parameters { get; }
    [NullableAttribute("2")]
public string FileName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    internal bool IsChanged { get; }
    public ContentDisposition(string disposition);
    private static ContentDisposition();
    internal DateTime GetDateParameter(string parameterName);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public StringDictionary get_Parameters();
    [NullableContextAttribute("2")]
public string get_FileName();
    [NullableContextAttribute("2")]
public void set_FileName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    [MemberNotNullAttribute("_dispositionType")]
private void ParseValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Mime.ContentType : object {
    private TrackingStringDictionary _parameters;
    private string _mediaType;
    private string _subType;
    private bool _isChanged;
    private string _type;
    private bool _isPersisted;
    [NullableAttribute("2")]
public string Boundary { get; public set; }
    [NullableAttribute("2")]
public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    internal bool IsChanged { get; }
    public ContentType(string contentType);
    [NullableContextAttribute("2")]
public string get_Boundary();
    [NullableContextAttribute("2")]
public void set_Boundary(string value);
    [NullableContextAttribute("2")]
public string get_CharSet();
    [NullableContextAttribute("2")]
public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    [MemberNotNullAttribute("_mediaType")]
[MemberNotNullAttribute("_subType")]
private void ParseValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Inline;
    public static string Attachment;
}
internal class System.Net.Mime.EightBitStream : DelegatedStream {
    private WriteStateInfoBase _writeState;
    private bool _shouldEncodeLeadingDots;
    private WriteStateInfoBase WriteState { get; }
    internal EightBitStream(Stream stream);
    internal EightBitStream(Stream stream, bool shouldEncodeLeadingDots);
    private WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void EncodeLines(Byte[] buffer, int offset, int count);
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
}
internal static class System.Net.Mime.EncodedStreamFactory : object {
    private static Byte[] s_footer;
    private static EncodedStreamFactory();
    internal static IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength);
    private static Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding);
}
internal class System.Net.Mime.HeaderCollection : NameValueCollection {
    public virtual void Remove(string name);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    internal void InternalRemove(string name);
    internal void InternalSet(string name, string value);
    internal void InternalAdd(string name, string value);
    public virtual void Set(string name, string value);
    public virtual void Add(string name, string value);
}
internal interface System.Net.Mime.IByteEncoder {
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public abstract virtual void AppendPadding();
    public abstract virtual int EncodeString(string value, Encoding encoding);
    public abstract virtual string GetEncodedString();
}
internal interface System.Net.Mime.IEncodableStream {
    public abstract virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeString(string value, Encoding encoding);
    public abstract virtual string GetEncodedString();
}
internal static class System.Net.Mime.MailBnfHelper : object {
    internal static Boolean[] Atext;
    internal static Boolean[] Qtext;
    internal static Boolean[] Dtext;
    internal static Boolean[] Ctext;
    private static SearchValues`1<char> s_charactersAllowedInHeaderNames;
    private static SearchValues`1<char> s_charactersAllowedInTokens;
    private static String[] s_months;
    private static MailBnfHelper();
    private static Boolean[] CreateCharactersAllowedInAtoms();
    private static Boolean[] CreateCharactersAllowedInQuotedStrings();
    private static Boolean[] CreateCharactersAllowedInDomainLiterals();
    private static Boolean[] CreateCharactersAllowedInComments();
    internal static bool SkipCFWS(string data, Int32& offset);
    internal static void ValidateHeaderName(string data);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName);
    internal static string ReadParameterAttribute(string data, Int32& offset);
    internal static string ReadToken(string data, Int32& offset);
    internal static string GetDateTimeString(DateTime value, StringBuilder builder);
    internal static void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode);
    private static bool CheckForUnicode(char ch, bool allowUnicode);
    internal static bool IsAllowedWhiteSpace(char c);
    internal static bool HasCROrLF(string data);
    internal static bool IsFWSAt(string data, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Net.Mime.MediaTypeNames : object {
}
internal class System.Net.Mime.MimeBasePart : object {
    protected ContentType _contentType;
    protected ContentDisposition _contentDisposition;
    private HeaderCollection _headers;
    private static Char[] s_headerValueSplitChars;
    internal string ContentID { get; internal set; }
    internal string ContentLocation { get; internal set; }
    internal NameValueCollection Headers { get; }
    internal ContentType ContentType { get; internal set; }
    private static MimeBasePart();
    internal static bool ShouldUseBase64Encoding(Encoding encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength);
    internal static string DecodeHeaderValue(string value);
    internal static Encoding DecodeEncoding(string value);
    internal static bool IsAscii(string value, bool permitCROrLF);
    internal string get_ContentID();
    internal void set_ContentID(string value);
    internal string get_ContentLocation();
    internal void set_ContentLocation(string value);
    internal NameValueCollection get_Headers();
    internal ContentType get_ContentType();
    internal void set_ContentType(ContentType value);
    internal void PrepareHeaders(bool allowUnicode);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal void EndSend(IAsyncResult asyncResult);
}
internal class System.Net.Mime.MimeMultiPart : MimeBasePart {
    private Collection`1<MimeBasePart> _parts;
    private static int s_boundary;
    private AsyncCallback _mimePartSentCallback;
    private bool _allowUnicode;
    unknown MimeMultiPartType MimeMultiPartType {internal set; }
    internal Collection`1<MimeBasePart> Parts { get; }
    internal MimeMultiPart(MimeMultiPartType type);
    internal void set_MimeMultiPartType(MimeMultiPartType value);
    private void SetType(MimeMultiPartType type);
    internal Collection`1<MimeBasePart> get_Parts();
    internal static void Complete(IAsyncResult result, Exception e);
    internal void MimeWriterCloseCallback(IAsyncResult result);
    private static void MimeWriterCloseCallbackHandler(IAsyncResult result);
    internal void MimePartSentCallback(IAsyncResult result);
    private void MimePartSentCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    private void ContentStreamCallbackHandler(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal static string GetNextBoundary();
}
internal enum System.Net.Mime.MimeMultiPartType : Enum {
    public int value__;
    public static MimeMultiPartType Mixed;
    public static MimeMultiPartType Alternative;
    public static MimeMultiPartType Parallel;
    public static MimeMultiPartType Related;
    public static MimeMultiPartType Unknown;
}
internal class System.Net.Mime.MimePart : MimeBasePart {
    private Stream _stream;
    private bool _streamSet;
    private bool _streamUsedOnce;
    private AsyncCallback _readCallback;
    private AsyncCallback _writeCallback;
    internal Stream Stream { get; }
    internal ContentDisposition ContentDisposition { get; internal set; }
    internal TransferEncoding TransferEncoding { get; internal set; }
    public sealed virtual void Dispose();
    internal Stream get_Stream();
    internal ContentDisposition get_ContentDisposition();
    internal void set_ContentDisposition(ContentDisposition value);
    internal TransferEncoding get_TransferEncoding();
    internal void set_TransferEncoding(TransferEncoding value);
    internal void SetContent(Stream stream);
    internal void SetContent(Stream stream, string name, string mimeType);
    internal void SetContent(Stream stream, ContentType contentType);
    internal static void Complete(IAsyncResult result, Exception e);
    internal void ReadCallback(IAsyncResult result);
    internal void ReadCallbackHandler(IAsyncResult result);
    internal void WriteCallback(IAsyncResult result);
    internal void WriteCallbackHandler(IAsyncResult result);
    internal Stream GetEncodedStream(Stream stream);
    internal void ContentStreamCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal void ResetStream();
}
internal class System.Net.Mime.MimeWriter : BaseWriter {
    private Byte[] _boundaryBytes;
    private bool _writeBoundary;
    internal MimeWriter(Stream stream, string boundary);
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal IAsyncResult BeginClose(AsyncCallback callback, object state);
    internal void EndClose(IAsyncResult result);
    internal virtual void Close();
    private void Close(MultiAsyncResult multiResult);
    protected virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
internal class System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
    private object _context;
    private int _outstanding;
    internal object Context { get; }
    internal MultiAsyncResult(object context, AsyncCallback callback, object state);
    internal object get_Context();
    internal void Enter();
    internal void Leave();
    internal void Leave(object result);
    private void Decrement();
    private void Increment();
    internal void CompleteSequence();
    internal static object End(IAsyncResult result);
}
internal class System.Net.Mime.QEncodedStream : DelegatedStream {
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private QEncoder _encoder;
    private static ReadOnlySpan`1<byte> HexDecodeMap { get; }
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QEncodedStream(WriteStateInfoBase wsi);
    private static ReadOnlySpan`1<byte> get_HexDecodeMap();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Net.Mime.QEncodedStream/<FlushAsync>d__18")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Mime.QEncodedStream/<<WriteAsync>g__WriteAsyncCore|21_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|21_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.Mime.QEncoder : ByteEncoder {
    private WriteStateInfoBase _writeState;
    internal WriteStateInfoBase WriteState { get; }
    protected bool HasSpecialEncodingForCRLF { get; }
    internal QEncoder(WriteStateInfoBase wsi);
    internal virtual WriteStateInfoBase get_WriteState();
    protected virtual bool get_HasSpecialEncodingForCRLF();
    protected virtual void AppendEncodedCRLF();
    protected virtual bool LineBreakNeeded(byte b);
    protected virtual bool LineBreakNeeded(Byte[] bytes, int count);
    protected virtual int GetCodepointSize(string value, int i);
    public virtual void AppendPadding();
    protected virtual void ApppendEncodedByte(byte b);
}
internal class System.Net.Mime.QuotedPrintableStream : DelegatedStream {
    private bool _encodeCRLF;
    private int _lineLength;
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private static ReadOnlySpan`1<byte> HexDecodeMap { get; }
    private static ReadOnlySpan`1<byte> HexEncodeMap { get; }
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QuotedPrintableStream(Stream stream, int lineLength);
    internal QuotedPrintableStream(Stream stream, bool encodeCRLF);
    private static ReadOnlySpan`1<byte> get_HexDecodeMap();
    private static ReadOnlySpan`1<byte> get_HexEncodeMap();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeString(string value, Encoding encoding);
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Net.Mime.QuotedPrintableStream/<FlushAsync>d__26")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Mime.QuotedPrintableStream/<<WriteAsync>g__WriteAsyncCore|29_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|29_0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.Mime.SmtpDateTime : object {
    internal static String[] s_validDateTimeFormats;
    internal static Dictionary`2<string, TimeSpan> s_timeZoneOffsetLookup;
    private DateTime _date;
    private TimeSpan _timeZone;
    private bool _unknownTimeZone;
    internal DateTime Date { get; }
    internal SmtpDateTime(DateTime value);
    internal SmtpDateTime(string value);
    private static SmtpDateTime();
    internal DateTime get_Date();
    public virtual string ToString();
    internal static void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes);
    internal static void ValidateTimeZoneShortHandValue(string value);
    internal static DateTime ParseValue(string data, String& timeZone);
    internal static bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone);
    internal static TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span);
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding Unknown;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding Base64;
    public static TransferEncoding SevenBit;
    public static TransferEncoding EightBit;
}
internal class System.Net.Mime.WriteStateInfoBase : object {
    protected Byte[] _header;
    protected Byte[] _footer;
    protected int _maxLineLength;
    protected Byte[] _buffer;
    protected int _currentLineLength;
    protected int _currentBufferUsed;
    internal int FooterLength { get; }
    internal Byte[] Footer { get; }
    internal Byte[] Header { get; }
    internal Byte[] Buffer { get; }
    internal int Length { get; }
    internal int CurrentLineLength { get; }
    internal int MaxLineLength { get; }
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength);
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    internal int get_FooterLength();
    internal Byte[] get_Footer();
    internal Byte[] get_Header();
    internal Byte[] get_Buffer();
    internal int get_Length();
    internal int get_CurrentLineLength();
    private void EnsureSpaceInBuffer(int moreBytes);
    internal void Append(byte aByte);
    internal void Append(ReadOnlySpan`1<byte> bytes);
    internal void AppendCRLF(bool includeSpace);
    internal void AppendHeader();
    internal void AppendFooter();
    internal int get_MaxLineLength();
    internal void Reset();
    internal void BufferFlushed();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
}
internal class System.Net.TlsStream : NetworkStream {
    private SslStream _sslStream;
    private string _host;
    private X509CertificateCollection _clientCertificates;
    public TlsStream(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates);
    public void AuthenticateAsClient();
    public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state);
    public void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Close();
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingStringDictionary : StringDictionary {
    private bool _isReadOnly;
    private bool _isChanged;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingStringDictionary(bool isReadOnly);
    internal bool get_IsChanged();
    internal void set_IsChanged(bool value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingValidationObjectDictionary : StringDictionary {
    private Dictionary`2<string, ValidateAndParseValue> _validators;
    private Dictionary`2<string, object> _internalObjects;
    [CompilerGeneratedAttribute]
private bool <IsChanged>k__BackingField;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingValidationObjectDictionary(Dictionary`2<string, ValidateAndParseValue> validators);
    private void PersistValue(string key, string value, bool addValue);
    [CompilerGeneratedAttribute]
internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal void set_IsChanged(bool value);
    internal object InternalGet(string key);
    internal void InternalSet(string key, object value);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string MailBase64InvalidCharacter { get; }
    internal static string MailCollectionIsReadOnly { get; }
    internal static string MailDateInvalidFormat { get; }
    internal static string MailHeaderFieldMalformedHeader { get; }
    internal static string MailWriterIsInContent { get; }
    internal static string MimeTransferEncodingNotSupported { get; }
    internal static string InvalidHexDigit { get; }
    internal static string InvalidHeaderName { get; }
    internal static string ContentTypeInvalid { get; }
    internal static string ContentDispositionInvalid { get; }
    internal static string MimePartCantResetStream { get; }
    internal static string MediaTypeInvalid { get; }
    internal static string InvalidPort { get; }
    internal static string MailHeaderInvalidCID { get; }
    internal static string MailServerResponse { get; }
    internal static string net_inasync { get; }
    internal static string net_timeout { get; }
    internal static string SmtpAllRecipientsFailed { get; }
    internal static string SmtpBadCommandSequence { get; }
    internal static string SmtpClientNotPermitted { get; }
    internal static string SmtpCommandNotImplemented { get; }
    internal static string SmtpCommandParameterNotImplemented { get; }
    internal static string SmtpCommandUnrecognized { get; }
    internal static string SmtpExceededStorageAllocation { get; }
    internal static string SmtpFromRequired { get; }
    internal static string SmtpHelpMessage { get; }
    internal static string SmtpInsufficientStorage { get; }
    internal static string SmtpInvalidHostName { get; }
    internal static string SmtpInvalidOperationDuringSend { get; }
    internal static string SmtpLocalErrorInProcessing { get; }
    internal static string SmtpMailboxBusy { get; }
    internal static string SmtpMailboxNameNotAllowed { get; }
    internal static string SmtpMailboxUnavailable { get; }
    internal static string SmtpMustIssueStartTlsFirst { get; }
    internal static string SmtpNeedAbsolutePickupDirectory { get; }
    internal static string SmtpNonAsciiUserNotSupported { get; }
    internal static string SmtpOK { get; }
    internal static string SmtpPickupDirectoryDoesnotSupportSsl { get; }
    internal static string SmtpRecipientFailed { get; }
    internal static string SmtpRecipientRequired { get; }
    internal static string SmtpSendMailFailure { get; }
    internal static string SmtpServiceClosingTransmissionChannel { get; }
    internal static string SmtpServiceReady { get; }
    internal static string SmtpStartMailInput { get; }
    internal static string SmtpSyntaxError { get; }
    internal static string SmtpSystemStatus { get; }
    internal static string SmtpTransactionFailed { get; }
    internal static string SmtpUserNotLocalTryAlternatePath { get; }
    internal static string SmtpUserNotLocalWillForward { get; }
    internal static string UnspecifiedHost { get; }
    internal static string SmtpAlreadyConnected { get; }
    internal static string SmtpAuthenticationFailed { get; }
    internal static string net_completed_result { get; }
    internal static string MailHeaderFieldInvalidCharacter { get; }
    internal static string SeekNotSupported { get; }
    internal static string ReadNotSupported { get; }
    internal static string WriteNotSupported { get; }
    internal static string MailAddressInvalidFormat { get; }
    internal static string SmtpAuthResponseInvalid { get; }
    internal static string net_webstatus_ServerProtocolViolation { get; }
    internal static string SmtpDataStreamOpen { get; }
    internal static string SmtpEhloResponseInvalid { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string SmtpInvalidResponse { get; }
    internal static string SmtpServiceNotAvailable { get; }
    internal static string MailSubjectInvalidFormat { get; }
    internal static string MailServerDoesNotSupportStartTls { get; }
    internal static string MailHostNotFound { get; }
    internal static string SmtpGetIisPickupDirectoryNotSupported { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_MailBase64InvalidCharacter();
    internal static string get_MailCollectionIsReadOnly();
    internal static string get_MailDateInvalidFormat();
    internal static string get_MailHeaderFieldMalformedHeader();
    internal static string get_MailWriterIsInContent();
    internal static string get_MimeTransferEncodingNotSupported();
    internal static string get_InvalidHexDigit();
    internal static string get_InvalidHeaderName();
    internal static string get_ContentTypeInvalid();
    internal static string get_ContentDispositionInvalid();
    internal static string get_MimePartCantResetStream();
    internal static string get_MediaTypeInvalid();
    internal static string get_InvalidPort();
    internal static string get_MailHeaderInvalidCID();
    internal static string get_MailServerResponse();
    internal static string get_net_inasync();
    internal static string get_net_timeout();
    internal static string get_SmtpAllRecipientsFailed();
    internal static string get_SmtpBadCommandSequence();
    internal static string get_SmtpClientNotPermitted();
    internal static string get_SmtpCommandNotImplemented();
    internal static string get_SmtpCommandParameterNotImplemented();
    internal static string get_SmtpCommandUnrecognized();
    internal static string get_SmtpExceededStorageAllocation();
    internal static string get_SmtpFromRequired();
    internal static string get_SmtpHelpMessage();
    internal static string get_SmtpInsufficientStorage();
    internal static string get_SmtpInvalidHostName();
    internal static string get_SmtpInvalidOperationDuringSend();
    internal static string get_SmtpLocalErrorInProcessing();
    internal static string get_SmtpMailboxBusy();
    internal static string get_SmtpMailboxNameNotAllowed();
    internal static string get_SmtpMailboxUnavailable();
    internal static string get_SmtpMustIssueStartTlsFirst();
    internal static string get_SmtpNeedAbsolutePickupDirectory();
    internal static string get_SmtpNonAsciiUserNotSupported();
    internal static string get_SmtpOK();
    internal static string get_SmtpPickupDirectoryDoesnotSupportSsl();
    internal static string get_SmtpRecipientFailed();
    internal static string get_SmtpRecipientRequired();
    internal static string get_SmtpSendMailFailure();
    internal static string get_SmtpServiceClosingTransmissionChannel();
    internal static string get_SmtpServiceReady();
    internal static string get_SmtpStartMailInput();
    internal static string get_SmtpSyntaxError();
    internal static string get_SmtpSystemStatus();
    internal static string get_SmtpTransactionFailed();
    internal static string get_SmtpUserNotLocalTryAlternatePath();
    internal static string get_SmtpUserNotLocalWillForward();
    internal static string get_UnspecifiedHost();
    internal static string get_SmtpAlreadyConnected();
    internal static string get_SmtpAuthenticationFailed();
    internal static string get_net_completed_result();
    internal static string get_MailHeaderFieldInvalidCharacter();
    internal static string get_SeekNotSupported();
    internal static string get_ReadNotSupported();
    internal static string get_WriteNotSupported();
    internal static string get_MailAddressInvalidFormat();
    internal static string get_SmtpAuthResponseInvalid();
    internal static string get_net_webstatus_ServerProtocolViolation();
    internal static string get_SmtpDataStreamOpen();
    internal static string get_SmtpEhloResponseInvalid();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_SmtpInvalidResponse();
    internal static string get_SmtpServiceNotAvailable();
    internal static string get_MailSubjectInvalidFormat();
    internal static string get_MailServerDoesNotSupportStartTls();
    internal static string get_MailHostNotFound();
    internal static string get_SmtpGetIisPickupDirectoryNotSupported();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
