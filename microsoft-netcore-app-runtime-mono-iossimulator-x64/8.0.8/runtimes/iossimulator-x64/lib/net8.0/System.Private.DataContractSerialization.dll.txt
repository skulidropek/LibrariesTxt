internal static class FxResources.System.Private.DataContractSerialization.SR : object {
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
internal class System.Runtime.Serialization.ArgBuilder : object {
    internal int Index;
    internal Type ArgType;
    internal ArgBuilder(int index, Type argType);
}
internal class System.Runtime.Serialization.AttributeData : object {
    public string prefix;
    public string ns;
    public string localName;
    public string value;
}
internal class System.Runtime.Serialization.Attributes : object {
    private static XmlDictionaryString[] s_serializationLocalNames;
    private static XmlDictionaryString[] s_schemaInstanceLocalNames;
    internal string Id;
    internal string Ref;
    internal string XsiTypeName;
    internal string XsiTypeNamespace;
    internal string XsiTypePrefix;
    internal bool XsiNil;
    internal string ClrAssembly;
    internal string ClrType;
    internal int ArraySZSize;
    internal string FactoryTypeName;
    internal string FactoryTypeNamespace;
    internal string FactoryTypePrefix;
    internal bool UnrecognizedAttributesFound;
    private static Attributes();
    internal void Read(XmlReaderDelegator reader);
    internal void Reset();
    private void ReadId(XmlReaderDelegator reader);
    private void ReadRef(XmlReaderDelegator reader);
    private void ReadXsiNil(XmlReaderDelegator reader);
    private void ReadArraySize(XmlReaderDelegator reader);
    private void ReadXsiType(XmlReaderDelegator reader);
    private void ReadFactoryType(XmlReaderDelegator reader);
}
internal class System.Runtime.Serialization.BitFlagsGenerator : object {
    private int _bitCount;
    private CodeGenerator _ilg;
    private LocalBuilder[] _locals;
    public BitFlagsGenerator(int bitCount, CodeGenerator ilg);
    public static bool IsBitSet(Byte[] bytes, int bitIndex);
    public static void SetBit(Byte[] bytes, int bitIndex);
    public int GetBitCount();
    public LocalBuilder GetLocal(int i);
    public int GetLocalCount();
    public void Load(int bitIndex);
    public void LoadArray();
    public void Store(int bitIndex, bool value);
    private static byte GetBitValue(int bitIndex);
    private static int GetByteIndex(int bitIndex);
}
internal class System.Runtime.Serialization.ClassDataNode : DataNode`1<object> {
    private IList`1<ExtensionDataMember> _members;
    internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
    public virtual void Clear();
}
internal enum System.Runtime.Serialization.Cmp : Enum {
    public int value__;
    public static Cmp LessThan;
    public static Cmp EqualTo;
    public static Cmp LessThanOrEqualTo;
    public static Cmp GreaterThan;
    public static Cmp NotEqualTo;
    public static Cmp GreaterThanOrEqualTo;
}
internal class System.Runtime.Serialization.CodeGenerator : object {
    private static MethodInfo s_getTypeFromHandle;
    private static MethodInfo s_objectEquals;
    private static MethodInfo s_arraySetValue;
    private static MethodInfo s_objectToString;
    private static MethodInfo s_stringFormat;
    private Type _delegateType;
    private static Module s_serializationModule;
    private DynamicMethod _dynamicMethod;
    private ILGenerator _ilGen;
    private List`1<ArgBuilder> _argList;
    private Stack`1<object> _blockStack;
    private Label _methodEndLabel;
    private LocalBuilder _stringFormatArray;
    private static MethodInfo s_stringLength;
    private static MethodInfo GetTypeFromHandle { get; }
    private static MethodInfo ObjectEquals { get; }
    private static MethodInfo ArraySetValue { get; }
    private static MethodInfo ObjectToString { get; }
    private static MethodInfo StringFormat { get; }
    private static Module SerializationModule { get; }
    internal MethodInfo CurrentMethod { get; }
    private static CodeGenerator();
    private static MethodInfo get_GetTypeFromHandle();
    private static MethodInfo get_ObjectEquals();
    private static MethodInfo get_ArraySetValue();
    private static MethodInfo get_ObjectToString();
    private static MethodInfo get_StringFormat();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static MethodInfo GetInvokeMethod(Type delegateType);
    private static Module get_SerializationModule();
    internal void BeginMethod(DynamicMethod dynamicMethod, Type delegateType, Type[] argTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
internal void BeginMethod(string methodName, Type delegateType, bool allowPrivateMemberAccess);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
private void BeginMethod(Type returnType, string methodName, Type[] argTypes, bool allowPrivateMemberAccess);
    private void InitILGeneration(Type[] argTypes);
    internal Delegate EndMethod();
    internal MethodInfo get_CurrentMethod();
    internal ArgBuilder GetArg(int index);
    internal static Type GetVariableType(object var);
    internal LocalBuilder DeclareLocal(Type type, object initialValue);
    internal LocalBuilder DeclareLocal(Type type);
    internal LocalBuilder DeclareLocal(Type type, bool isPinned);
    internal void Set(LocalBuilder local, object value);
    internal object For(LocalBuilder local, object start, object end);
    internal void EndFor();
    internal void Break(object forState);
    internal void IfFalseBreak(object forState);
    internal void InternalBreakFor(object userForState, OpCode branchInstruction);
    internal void ForEach(LocalBuilder local, Type elementType, LocalBuilder enumerator, MethodInfo getCurrentMethod);
    internal void EndForEach(MethodInfo moveNextMethod);
    internal void IfNotDefaultValue(object value);
    internal void If();
    internal void IfNot();
    private static OpCode GetBranchCode(Cmp cmp);
    internal void If(Cmp cmpOp);
    internal void If(object value1, Cmp cmpOp, object value2);
    internal void Else();
    internal void ElseIf(object value1, Cmp cmpOp, object value2);
    internal void EndIf();
    internal static void VerifyParameterCount(MethodInfo methodInfo, int expectedCount);
    internal void Call(object thisObj, MethodInfo methodInfo);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1, object param2);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1, object param2, object param3);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1, object param2, object param3, object param4);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1, object param2, object param3, object param4, object param5);
    internal void Call(object thisObj, MethodInfo methodInfo, object param1, object param2, object param3, object param4, object param5, object param6);
    internal void Call(MethodInfo methodInfo);
    internal void Call(ConstructorInfo ctor);
    internal void New(ConstructorInfo constructorInfo);
    internal void InitObj(Type valueType);
    internal void NewArray(Type elementType, object len);
    internal void LoadArrayElement(object obj, object arrayIndex);
    internal void StoreArrayElement(object obj, object arrayIndex, object value);
    private static bool IsStruct(Type objType);
    internal Type LoadMember(MemberInfo memberInfo);
    internal void StoreMember(MemberInfo memberInfo);
    internal void LoadDefaultValue(Type type);
    internal void Load(object obj);
    internal void Store(object var);
    internal void Dec(object var);
    internal void LoadAddress(object obj);
    internal void ConvertAddress(Type source, Type target);
    internal void ConvertValue(Type source, Type target);
    internal void Castclass(Type target);
    internal void Box(Type type);
    internal void Unbox(Type type);
    private static OpCode GetLdindOpCode(TypeCode typeCode);
    internal void Ldobj(Type type);
    internal void Stobj(Type type);
    internal void Ceq();
    internal void Throw();
    internal void Ldtoken(Type t);
    internal void Ldc(object o);
    internal void Ldc(bool boolVar);
    internal void Ldc(int intVar);
    internal void Ldc(long l);
    internal void Ldc(float f);
    internal void Ldc(double d);
    internal void Ldstr(string strVar);
    internal void LdlocAddress(LocalBuilder localBuilder);
    internal void Ldloc(LocalBuilder localBuilder);
    internal void Stloc(LocalBuilder local);
    internal void Ldloca(LocalBuilder localBuilder);
    internal void LdargAddress(ArgBuilder argBuilder);
    internal void Ldarg(ArgBuilder arg);
    internal void Starg(ArgBuilder arg);
    internal void Ldarg(int slot);
    internal void Starg(int slot);
    internal void Ldarga(ArgBuilder argBuilder);
    internal void Ldarga(int slot);
    internal void Ldlen();
    private static OpCode GetLdelemOpCode(TypeCode typeCode);
    internal void Ldelem(Type arrayElementType);
    internal void Ldelema(Type arrayElementType);
    private static OpCode GetStelemOpCode(TypeCode typeCode);
    internal void Stelem(Type arrayElementType);
    internal Label DefineLabel();
    internal void MarkLabel(Label label);
    internal void Add();
    internal void Subtract();
    internal void And();
    internal void Or();
    internal void Not();
    internal void Ret();
    internal void Br(Label label);
    internal void Blt(Label label);
    internal void Brfalse(Label label);
    internal void Brtrue(Label label);
    internal void Pop();
    internal void Dup();
    private void LoadThis(object thisObj, MethodInfo methodInfo);
    private void LoadParam(object arg, int oneBasedArgIndex, MethodInfo methodInfo);
    private void InternalIf(bool negate);
    private static OpCode GetConvOpCode(TypeCode typeCode);
    private void InternalConvert(Type source, Type target, bool isAddress);
    private IfState PopIfState();
    [DoesNotReturnAttribute]
private static void ThrowMismatchException(object expected);
    internal Label[] Switch(int labelCount);
    internal void Case(Label caseLabel1);
    internal void EndCase();
    internal void EndSwitch();
    internal void ElseIfIsEmptyString(LocalBuilder strLocal);
    internal void IfNotIsEmptyString(LocalBuilder strLocal);
    internal void BeginWhileCondition();
    internal void BeginWhileBody(Cmp cmpOp);
    internal void EndWhile();
    internal void CallStringFormat(string msg, Object[] values);
    internal void ToString(Type type);
}
internal class System.Runtime.Serialization.CodeObject : object {
    private IDictionary _userData;
    public IDictionary UserData { get; }
    public IDictionary get_UserData();
}
internal class System.Runtime.Serialization.CodeTypeReference : CodeObject {
    private string _baseType;
    private bool _isInterface;
    private CodeTypeReferenceCollection _typeArguments;
    private bool _needsFixup;
    [CompilerGeneratedAttribute]
private CodeTypeReference <ArrayElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeTypeReferenceOptions <Options>k__BackingField;
    public CodeTypeReference ArrayElementType { get; public set; }
    public int ArrayRank { get; public set; }
    internal int NestedArrayDepth { get; }
    public string BaseType { get; public set; }
    public CodeTypeReferenceOptions Options { get; public set; }
    public CodeTypeReferenceCollection TypeArguments { get; }
    internal bool IsInterface { get; }
    public CodeTypeReference(Type type);
    public CodeTypeReference(Type type, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName);
    public CodeTypeReference(string typeName, CodeTypeReference[] typeArguments);
    public CodeTypeReference(string baseType, int rank);
    public CodeTypeReference(CodeTypeReference arrayType, int rank);
    private void InitializeFromType(Type type);
    private void Initialize(string typeName);
    private void Initialize(string typeName, CodeTypeReferenceOptions options);
    [CompilerGeneratedAttribute]
public CodeTypeReference get_ArrayElementType();
    [CompilerGeneratedAttribute]
public void set_ArrayElementType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
public void set_ArrayRank(int value);
    internal int get_NestedArrayDepth();
    public string get_BaseType();
    public void set_BaseType(string value);
    [CompilerGeneratedAttribute]
public CodeTypeReferenceOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(CodeTypeReferenceOptions value);
    public CodeTypeReferenceCollection get_TypeArguments();
    internal bool get_IsInterface();
    private static string RipOffAssemblyInformationFromTypeName(string typeName);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.CodeTypeReferenceCollection : CollectionBase {
    public CodeTypeReference Item { get; public set; }
    public CodeTypeReferenceCollection(CodeTypeReferenceCollection value);
    public CodeTypeReferenceCollection(CodeTypeReference[] value);
    public CodeTypeReference get_Item(int index);
    public void set_Item(int index, CodeTypeReference value);
    public int Add(CodeTypeReference value);
    public void Add(string value);
    public void Add(Type value);
    public void AddRange(CodeTypeReference[] value);
    public void AddRange(CodeTypeReferenceCollection value);
    public bool Contains(CodeTypeReference value);
    public void CopyTo(CodeTypeReference[] array, int index);
    public int IndexOf(CodeTypeReference value);
    public void Insert(int index, CodeTypeReference value);
    public void Remove(CodeTypeReference value);
}
[FlagsAttribute]
internal enum System.Runtime.Serialization.CodeTypeReferenceOptions : Enum {
    public int value__;
    public static CodeTypeReferenceOptions GlobalReference;
    public static CodeTypeReferenceOptions GenericTypeParameter;
}
internal class System.Runtime.Serialization.CollectionDataNode : DataNode`1<Array> {
    private IList`1<IDataNode> _items;
    private string _itemName;
    private string _itemNamespace;
    private int _size;
    internal IList`1<IDataNode> Items { get; internal set; }
    internal string ItemName { get; internal set; }
    internal string ItemNamespace { get; internal set; }
    internal int Size { get; internal set; }
    internal IList`1<IDataNode> get_Items();
    internal void set_Items(IList`1<IDataNode> value);
    internal string get_ItemName();
    internal void set_ItemName(string value);
    internal string get_ItemNamespace();
    internal void set_ItemNamespace(string value);
    internal int get_Size();
    internal void set_Size(int value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
internal enum System.Runtime.Serialization.CollectionKind : Enum {
    public byte value__;
    public static CollectionKind None;
    public static CollectionKind GenericDictionary;
    public static CollectionKind Dictionary;
    public static CollectionKind GenericList;
    public static CollectionKind GenericCollection;
    public static CollectionKind List;
    public static CollectionKind GenericEnumerable;
    public static CollectionKind Collection;
    public static CollectionKind Enumerable;
    public static CollectionKind Array;
}
internal class System.Runtime.Serialization.ContextAwareDataContractIndex : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _contracts;
    private ConditionalWeakTable`2<Type, DataContract> _keepAlive;
    public int Length { get; }
    public ContextAwareDataContractIndex(int size);
    public int get_Length();
    public DataContract GetItem(int index);
    public void SetItem(int index, DataContract dataContract);
    public void Resize(int newSize);
}
internal class System.Runtime.Serialization.ContextAwareDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _fastDictionary;
    private ConditionalWeakTable`2<TKey, TValue> _collectibleTable;
    internal TValue GetOrAdd(TKey t, Func`2<TKey, TValue> f);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.DataContractResolver : object {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
internal class System.Runtime.Serialization.DataContracts.AsmxCharDataContract : CharDataContract {
}
internal class System.Runtime.Serialization.DataContracts.AsmxGuidDataContract : GuidDataContract {
}
internal class System.Runtime.Serialization.DataContracts.BooleanDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.ByteArrayDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.CharDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal CharDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.ClassDataContract : DataContract {
    internal static string ContractTypeString;
    public XmlDictionaryString[] ContractNamespaces;
    public XmlDictionaryString[] MemberNames;
    internal XmlDictionaryString[] MemberNamespaces;
    private XmlDictionaryString[] _childElementNamespaces;
    private ClassDataContractCriticalHelper _helper;
    private ConstructorInfo _nonAttributedTypeConstructor;
    private Func`1<object> _makeNewInstance;
    public string ContractType { get; }
    public DataContract BaseContract { get; }
    internal ClassDataContract BaseClassContract { get; internal set; }
    internal List`1<DataMember> Members { get; internal set; }
    public ReadOnlyCollection`1<DataMember> DataMembers { get; }
    internal XmlDictionaryString[] ChildElementNamespaces { get; }
    internal MethodInfo OnSerializing { get; }
    internal MethodInfo OnSerialized { get; }
    internal MethodInfo OnDeserializing { get; }
    internal MethodInfo OnDeserialized { get; }
    internal MethodInfo ExtensionDataSetMethod { get; }
    public Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    public bool IsISerializable { get; internal set; }
    internal bool IsNonAttributedType { get; }
    internal bool HasExtensionData { get; }
    internal string SerializationExceptionMessage { get; }
    internal string DeserializationExceptionMessage { get; }
    internal bool IsReadOnlyContract { get; }
    [UnconditionalSuppressMessageAttribute("AOT Analysis", "IL3050:RequiresDynamicCodeAttribute")]
private Func`1<object> MakeNewInstance { get; }
    internal XmlFormatClassWriterDelegate XmlFormatWriterDelegate { get; }
    internal XmlFormatClassReaderDelegate XmlFormatReaderDelegate { get; }
    internal Type ObjectType { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal ClassDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ClassDataContract(Type type, XmlDictionaryString ns, String[] memberNames);
    public virtual string get_ContractType();
    [MemberNotNullAttribute("_helper")]
private void InitClassDataContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual DataContract get_BaseContract();
    internal ClassDataContract get_BaseClassContract();
    internal void set_BaseClassContract(ClassDataContract value);
    internal List`1<DataMember> get_Members();
    internal void set_Members(List`1<DataMember> value);
    public virtual ReadOnlyCollection`1<DataMember> get_DataMembers();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlDictionaryString[] get_ChildElementNamespaces();
    internal MethodInfo get_OnSerializing();
    internal MethodInfo get_OnSerialized();
    internal MethodInfo get_OnDeserializing();
    internal MethodInfo get_OnDeserialized();
    internal MethodInfo get_ExtensionDataSetMethod();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    public virtual bool get_IsISerializable();
    internal virtual void set_IsISerializable(bool value);
    internal bool get_IsNonAttributedType();
    internal bool get_HasExtensionData();
    internal string get_SerializationExceptionMessage();
    internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    internal ConstructorInfo GetISerializableConstructor();
    internal ConstructorInfo GetNonAttributedTypeConstructor();
    private Func`1<object> get_MakeNewInstance();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
internal bool CreateNewInstanceViaDefaultConstructor(Object& obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlFormatClassWriterDelegate CreateXmlFormatWriterDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatClassWriterDelegate get_XmlFormatWriterDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlFormatClassReaderDelegate CreateXmlFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatClassReaderDelegate get_XmlFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static ClassDataContract CreateClassDataContractForKeyValue(Type type, XmlDictionaryString ns, String[] memberNames);
    internal static void CheckAndAddMember(List`1<DataMember> members, DataMember memberContract, Dictionary`2<string, DataMember> memberNamesTable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlDictionaryString GetChildNamespaceToDeclare(DataContract dataContract, Type childType, XmlDictionary dictionary);
    private static bool IsArraySegment(Type t);
    internal static bool IsNonAttributedTypeValidForSerialization(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlDictionaryString[] CreateChildElementNamespaces();
    private void EnsureMethodsImported();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    internal bool RequiresMemberAccessForRead(SecurityException securityException);
    internal bool RequiresMemberAccessForWrite(SecurityException securityException);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    [UnconditionalSuppressMessageAttribute("AOT Analysis", "IL3050:RequiresDynamicCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
    private static bool IsEveryDataMemberOptional(IEnumerable`1<DataMember> dataMembers);
    public virtual int GetHashCode();
    internal Type get_ObjectType();
}
internal class System.Runtime.Serialization.DataContracts.CollectionDataContract : DataContract {
    internal static string ContractTypeString;
    private XmlDictionaryString _collectionItemName;
    private XmlDictionaryString _childElementNamespace;
    private DataContract _itemContract;
    private CollectionDataContractCriticalHelper _helper;
    public string ContractType { get; }
    private static Type[] KnownInterfaces { get; }
    internal CollectionKind Kind { get; }
    internal Type ItemType { get; }
    internal DataContract ItemContract { get; internal set; }
    internal DataContract SharedTypeContract { get; }
    internal string ItemName { get; internal set; }
    internal XmlDictionaryString CollectionItemName { get; }
    internal string KeyName { get; internal set; }
    internal string ValueName { get; internal set; }
    public DataContract BaseContract { get; }
    internal bool IsDictionary { get; }
    internal XmlDictionaryString ChildElementNamespace { get; }
    internal bool IsItemTypeNullable { get; internal set; }
    internal bool IsConstructorCheckRequired { get; internal set; }
    internal MethodInfo GetEnumeratorMethod { get; }
    internal MethodInfo AddMethod { get; }
    internal ConstructorInfo Constructor { get; }
    public Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    internal string InvalidCollectionInSharedContractMessage { get; }
    internal string SerializationExceptionMessage { get; }
    internal string DeserializationExceptionMessage { get; }
    internal bool IsReadOnlyContract { get; }
    private bool ItemNameSetExplicit { get; }
    internal XmlFormatCollectionWriterDelegate XmlFormatWriterDelegate { get; }
    internal XmlFormatCollectionReaderDelegate XmlFormatReaderDelegate { get; }
    internal XmlFormatGetOnlyCollectionReaderDelegate XmlFormatGetOnlyCollectionReaderDelegate { get; internal set; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal CollectionDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal CollectionDataContract(Type type, DataContract itemContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal CollectionDataContract(Type type, CollectionKind kind);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, string serializationExceptionMessage, string deserializationExceptionMessage);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor, bool isConstructorCheckRequired);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataContract(Type type, string invalidCollectionInSharedContractMessage);
    public virtual string get_ContractType();
    [MemberNotNullAttribute("_helper")]
[MemberNotNullAttribute("_collectionItemName")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void InitCollectionDataContract(DataContract sharedTypeContract);
    private static Type[] get_KnownInterfaces();
    internal CollectionKind get_Kind();
    internal Type get_ItemType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataContract get_ItemContract();
    internal void set_ItemContract(DataContract value);
    internal DataContract get_SharedTypeContract();
    internal string get_ItemName();
    internal void set_ItemName(string value);
    internal XmlDictionaryString get_CollectionItemName();
    internal string get_KeyName();
    internal void set_KeyName(string value);
    internal string get_ValueName();
    internal void set_ValueName(string value);
    public virtual bool IsDictionaryLike(String& keyName, String& valueName, String& itemName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual DataContract get_BaseContract();
    internal bool get_IsDictionary();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlDictionaryString get_ChildElementNamespace();
    internal bool get_IsItemTypeNullable();
    internal void set_IsItemTypeNullable(bool value);
    internal bool get_IsConstructorCheckRequired();
    internal void set_IsConstructorCheckRequired(bool value);
    internal MethodInfo get_GetEnumeratorMethod();
    internal MethodInfo get_AddMethod();
    internal ConstructorInfo get_Constructor();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    internal string get_InvalidCollectionInSharedContractMessage();
    internal string get_SerializationExceptionMessage();
    internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    private bool get_ItemNameSetExplicit();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlFormatCollectionWriterDelegate CreateXmlFormatWriterDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatCollectionWriterDelegate get_XmlFormatWriterDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlFormatCollectionReaderDelegate CreateXmlFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatCollectionReaderDelegate get_XmlFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlFormatGetOnlyCollectionReaderDelegate CreateXmlFormatGetOnlyCollectionReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatGetOnlyCollectionReaderDelegate get_XmlFormatGetOnlyCollectionReaderDelegate();
    internal void set_XmlFormatGetOnlyCollectionReaderDelegate(XmlFormatGetOnlyCollectionReaderDelegate value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
internal void IncrementCollectionCount(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
internal IEnumerator GetEnumeratorForCollection(object obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal Type GetCollectionElementType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract GetSharedTypeContract(Type type);
    internal static bool IsCollectionInterface(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsCollection(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsCollection(Type type, Type& itemType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsCollection(Type type, bool constructorRequired, bool skipIfReadOnlyContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool IsCollectionHelper(Type type, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool TryCreate(Type type, DataContract& dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool TryCreateGetOnlyCollectionDataContract(Type type, DataContract& dataContract);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:GetMethod")]
internal static MethodInfo GetTargetMethodWithName(string name, Type type, Type interfaceType);
    private static bool IsArraySegment(Type t);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool IsCollectionOrTryCreate(Type type, bool tryCreate, DataContract& dataContract, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    internal static bool IsCollectionDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool HandleIfInvalidCollection(Type type, bool tryCreate, bool hasCollectionDataContract, bool createContractWithException, string message, string param, DataContract& dataContract);
    private static void GetReadOnlyCollectionExceptionMessages(Type type, bool hasCollectionDataContract, string message, string param, String& serializationExceptionMessage, String& deserializationExceptionMessage);
    private static string GetInvalidCollectionMessage(string message, string nestedMessage, string param);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:GetMethod")]
private static void FindCollectionMethodsOnInterface(Type type, Type interfaceType, MethodInfo& addMethod, MethodInfo& getEnumeratorMethod);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static void GetCollectionMethods(Type type, Type interfaceType, Type[] addMethodTypeArray, bool addMethodOnInterface, MethodInfo& getEnumeratorMethod, MethodInfo& addMethod);
    private static MethodInfo GetIEnumerableGetEnumeratorMethod(Type type, Type ienumerableInterface);
    private static bool IsKnownInterface(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(bool verifyConstructor);
    private void CheckConstructor();
    internal virtual bool IsValidContract();
    internal bool RequiresMemberAccessForRead(SecurityException securityException);
    internal bool RequiresMemberAccessForWrite(SecurityException securityException);
    [UnconditionalSuppressMessageAttribute("AOT Analysis", "IL3050:RequiresDynamicCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
    public virtual int GetHashCode();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.DataContracts.CreateXmlSerializableDelegate : MulticastDelegate {
    public CreateXmlSerializableDelegate(object object, IntPtr method);
    public virtual IXmlSerializable Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IXmlSerializable EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.DataContracts.DataContract : object {
    internal static string SerializerTrimmerWarning;
    internal static string SerializerAOTWarning;
    internal static DynamicallyAccessedMemberTypes DataContractPreserveMemberTypes;
    private XmlDictionaryString _name;
    private XmlDictionaryString _ns;
    private DataContractCriticalHelper _helper;
    [NullableAttribute("2")]
public string ContractType { get; }
    [NullableAttribute("2")]
internal MethodInfo ParseMethod { get; }
    internal DataContractCriticalHelper Helper { get; }
    [DynamicallyAccessedMembersAttribute("575")]
public Type UnderlyingType { get; }
    public Type OriginalUnderlyingType { get; }
    public bool IsBuiltInDataContract { get; }
    internal Type TypeForInitialization { get; }
    public bool IsValueType { get; internal set; }
    public bool IsReference { get; internal set; }
    public XmlQualifiedName XmlName { get; internal set; }
    [NullableAttribute("2")]
public DataContract BaseContract { get; }
    [NullableAttribute("2")]
internal GenericInfo GenericInfo { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    public bool IsISerializable { get; internal set; }
    internal XmlDictionaryString Name { get; }
    internal XmlDictionaryString Namespace { get; }
    internal bool HasRoot { get; internal set; }
    [NullableAttribute("2")]
public XmlDictionaryString TopLevelElementName { get; internal set; }
    [NullableAttribute("2")]
public XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    public ReadOnlyCollection`1<DataMember> DataMembers { get; }
    internal DataContract(DataContractCriticalHelper helper);
    [NullableContextAttribute("2")]
public virtual string get_ContractType();
    internal MethodInfo get_ParseMethod();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContract(RuntimeTypeHandle typeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetGetOnlyCollectionDataContract(int id, RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetGetOnlyCollectionDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    internal static DataContract GetDataContractForInitialization(int id);
    internal static int GetIdForInitialization(ClassDataContract classContract);
    internal static int GetId(RuntimeTypeHandle typeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetBuiltInDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static DataContract GetBuiltInDataContract(string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetBuiltInDataContract(string typeName);
    internal static string GetNamespace(string key);
    internal static XmlDictionaryString GetClrTypeString(string key);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidDataContractException(string message, Type type);
    internal DataContractCriticalHelper get_Helper();
    public virtual Type get_UnderlyingType();
    public virtual Type get_OriginalUnderlyingType();
    public virtual bool get_IsBuiltInDataContract();
    internal Type get_TypeForInitialization();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual object ReadXmlElement(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    public virtual bool get_IsValueType();
    internal virtual void set_IsValueType(bool value);
    public virtual bool get_IsReference();
    internal virtual void set_IsReference(bool value);
    public virtual XmlQualifiedName get_XmlName();
    internal virtual void set_XmlName(XmlQualifiedName value);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual DataContract get_BaseContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal GenericInfo get_GenericInfo();
    internal void set_GenericInfo(GenericInfo value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    public virtual bool get_IsISerializable();
    internal virtual void set_IsISerializable(bool value);
    internal XmlDictionaryString get_Name();
    internal virtual XmlDictionaryString get_Namespace();
    internal virtual bool get_HasRoot();
    internal virtual void set_HasRoot(bool value);
    [NullableContextAttribute("2")]
public virtual XmlDictionaryString get_TopLevelElementName();
    internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    [NullableContextAttribute("2")]
public virtual XmlDictionaryString get_TopLevelElementNamespace();
    internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    [NullableContextAttribute("2")]
public virtual bool IsDictionaryLike(String& keyName, String& valueName, String& itemName);
    public virtual ReadOnlyCollection`1<DataMember> get_DataMembers();
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(bool verifyConstructor);
    internal virtual bool IsValidContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsTypeSerializable(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool IsTypeSerializable(Type type, HashSet`1<Type> previousCollectionTypes);
    private static void ValidatePreviousCollectionTypes(Type collectionType, Type itemType, HashSet`1<Type> previousCollectionTypes);
    internal static Type UnwrapRedundantNullableType(Type type);
    internal static Type UnwrapNullableType(Type type);
    private static bool IsAsciiLocalName(string localName);
    internal static string EncodeLocalName(string localName);
    internal static bool IsValidNCName(string name);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static XmlQualifiedName GetXmlName(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlQualifiedName GetXmlName(Type type, Boolean& hasDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlQualifiedName GetXmlName(Type type, HashSet`1<Type> previousCollectionTypes, Boolean& hasDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static XmlQualifiedName GetDCTypeXmlName(Type type, DataContractAttribute dataContractAttribute);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static XmlQualifiedName GetNonDCTypeXmlName(Type type, HashSet`1<Type> previousCollectionTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool TryGetBuiltInXmlAndArrayTypeXmlName(Type type, HashSet`1<Type> previousCollectionTypes, XmlQualifiedName& xmlName);
    internal static bool TryGetDCAttribute(Type type, DataContractAttribute& dataContractAttribute);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlQualifiedName GetCollectionXmlName(Type type, Type itemType, CollectionDataContractAttribute& collectionContractAttribute);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlQualifiedName GetCollectionXmlName(Type type, Type itemType, HashSet`1<Type> previousCollectionTypes, CollectionDataContractAttribute& collectionContractAttribute);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static string GetArrayPrefix(Type& itemType);
    internal static string GetCollectionNamespace(string elementNs);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual XmlQualifiedName GetArrayTypeName(bool isNullable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static XmlQualifiedName GetDefaultXmlName(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static string GetDefaultXmlLocalName(Type type);
    private static string GetDefaultDataContractNamespace(Type type);
    internal static List`1<int> GetDataContractNameForGenericName(string typeName, StringBuilder localName);
    internal static bool IsBuiltInNamespace(string ns);
    internal static string GetDefaultXmlNamespace(Type type);
    internal static XmlQualifiedName CreateQualifiedName(string localName, string ns);
    internal static string GetDefaultXmlNamespace(string clrNs);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static void GetDefaultXmlName(string fullTypeName, String& localName, String& ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static void GetDefaultName(CodeTypeReference typeReference, String& localName, String& ns);
    private static void CheckExplicitDataContractNamespaceUri(string dataContractNs, Type type);
    internal static string GetClrTypeFullName(Type type);
    internal static void GetClrNameAndNamespace(string fullTypeName, String& localName, String& ns);
    internal static string GetDataContractNamespaceFromUri(string uriString);
    private static string GetGlobalDataContractNamespace(string clrNs, Object[] nsAttributes);
    private static string GetNamespacesDigest(string namespaces);
    private static Byte[] ComputeHash(Byte[] namespaces);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static string ExpandGenericParameters(string format, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static string ExpandGenericParameters(string format, IGenericNameProvider genericNameProvider);
    internal static bool IsTypeNullable(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Dictionary`2<XmlQualifiedName, DataContract> ImportKnownTypeAttributes(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static void ImportKnownTypeAttributes(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& knownDataContracts);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static void CheckAndAdd(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& nameToDataContractTable);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
    internal bool IsEqualOrChecked(object other, HashSet`1<DataContractPairKey> checkedContracts);
    public virtual int GetHashCode();
    internal static bool IsTypeVisible(Type t);
    internal static bool IsTypeAndDeclaringTypeVisible(Type t);
    internal static bool ConstructorRequiresMemberAccess(ConstructorInfo ctor);
    internal static bool MethodRequiresMemberAccess(MethodInfo method);
    internal static bool FieldRequiresMemberAccess(FieldInfo field);
    private static bool IsTypeVisibleInSerializationModule(Type type);
    private static bool IsMemberVisibleInSerializationModule(MemberInfo member);
    internal static bool IsAssemblyFriendOfSerialization(Assembly assembly);
    internal static string SanitizeTypeName(string typeName);
}
internal class System.Runtime.Serialization.DataContracts.DataContractPairKey : object {
    private object _object1;
    private object _object2;
    internal DataContractPairKey(object object1, object object2);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.DataContractSet : object {
    private Dictionary`2<XmlQualifiedName, DataContract> _contracts;
    private Dictionary`2<DataContract, object> _processedContracts;
    private ISerializationSurrogateProvider _surrogateProvider;
    private ISerializationSurrogateProvider2 _extendedSurrogateProvider;
    private Hashtable _surrogateData;
    private Dictionary`2<XmlQualifiedName, DataContract> _knownTypesForObject;
    private List`1<Type> _referencedTypes;
    private List`1<Type> _referencedCollectionTypes;
    private Dictionary`2<XmlQualifiedName, object> _referencedTypesDictionary;
    private Dictionary`2<XmlQualifiedName, object> _referencedCollectionTypesDictionary;
    public Dictionary`2<XmlQualifiedName, DataContract> Contracts { get; }
    public Dictionary`2<DataContract, object> ProcessedContracts { get; }
    public Hashtable SurrogateData { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<XmlQualifiedName, DataContract> KnownTypesForObject { get; internal set; }
    [NullableAttribute("2")]
internal ISerializationSurrogateProvider2 SerializationExtendedSurrogateProvider { get; }
    [NullableContextAttribute("2")]
public DataContractSet(ISerializationSurrogateProvider dataContractSurrogate, IEnumerable`1<Type> referencedTypes, IEnumerable`1<Type> referencedCollectionTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractSet(DataContractSet dataContractSet);
    public Dictionary`2<XmlQualifiedName, DataContract> get_Contracts();
    public Dictionary`2<DataContract, object> get_ProcessedContracts();
    public Hashtable get_SurrogateData();
    public Dictionary`2<XmlQualifiedName, DataContract> get_KnownTypesForObject();
    internal void set_KnownTypesForObject(Dictionary`2<XmlQualifiedName, DataContract> value);
    internal static void EnsureTypeNotGeneric(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void Add(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void Add(DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void Add(XmlQualifiedName name, DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void InternalAdd(XmlQualifiedName name, DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddClassDataContract(ClassDataContract classDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddCollectionDataContract(CollectionDataContract collectionDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddXmlDataContract(XmlDataContract xmlDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddKnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlQualifiedName GetXmlName(Type clrType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract GetDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract GetDataContract(XmlQualifiedName key);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataContract GetMemberTypeDataContract(DataMember dataMember);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataContract GetItemTypeDataContract(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool Remove(XmlQualifiedName key);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private Dictionary`2<XmlQualifiedName, object> GetReferencedTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private Dictionary`2<XmlQualifiedName, object> GetReferencedCollectionTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddReferencedType(Dictionary`2<XmlQualifiedName, object> referencedTypes, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool IsTypeReferenceable(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public Type GetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, DataContract& referencedContract, Object[]& genericParameters, Nullable`1<bool> supportGenericTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private Type GetReferencedGenericTypeInternal(GenericInfo genInfo, DataContract& referencedContract, Object[]& genericParameters);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private Type GetReferencedTypeInternal(XmlQualifiedName xmlName, DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool TryGetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, Type& type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool TryGetReferencedCollectionType(XmlQualifiedName xmlName, DataContract dataContract, Type& type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private bool TryGetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, bool useReferencedCollectionTypes, Type& type);
    internal ISerializationSurrogateProvider2 get_SerializationExtendedSurrogateProvider();
    internal object GetSurrogateData(object key);
    internal void SetSurrogateData(object key, object surrogateData);
    internal bool IsContractProcessed(DataContract dataContract);
    internal void SetContractProcessed(DataContract dataContract);
    internal IEnumerator`1<KeyValuePair`2<XmlQualifiedName, DataContract>> GetEnumerator();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable`1<XmlQualifiedName> typeNames, bool importXmlDataType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public List`1<XmlQualifiedName> ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable`1<XmlSchemaElement> elements, bool importXmlDataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.DataMember : object {
    private CriticalHelper _helper;
    private Getter _getter;
    private Setter _setter;
    internal MemberInfo MemberInfo { get; }
    public string Name { get; internal set; }
    public long Order { get; internal set; }
    public bool IsRequired { get; internal set; }
    public bool EmitDefaultValue { get; internal set; }
    public bool IsNullable { get; internal set; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal Type MemberType { get; }
    public DataContract MemberTypeContract { get; }
    [NullableAttribute("2")]
internal PrimitiveDataContract MemberPrimitiveContract { get; }
    internal bool HasConflictingNameAndType { get; internal set; }
    [NullableAttribute("2")]
internal DataMember ConflictingMember { get; internal set; }
    internal Getter Getter { get; }
    internal Setter Setter { get; }
    internal DataMember(MemberInfo memberInfo);
    internal DataMember(DataContract memberTypeContract, string name, bool isNullable, bool isRequired, bool emitDefaultValue, long order);
    internal MemberInfo get_MemberInfo();
    public string get_Name();
    internal void set_Name(string value);
    public long get_Order();
    internal void set_Order(long value);
    public bool get_IsRequired();
    internal void set_IsRequired(bool value);
    public bool get_EmitDefaultValue();
    internal void set_EmitDefaultValue(bool value);
    public bool get_IsNullable();
    internal void set_IsNullable(bool value);
    internal bool get_IsGetOnlyCollection();
    internal void set_IsGetOnlyCollection(bool value);
    internal Type get_MemberType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract get_MemberTypeContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal PrimitiveDataContract get_MemberPrimitiveContract();
    internal bool get_HasConflictingNameAndType();
    internal void set_HasConflictingNameAndType(bool value);
    internal DataMember get_ConflictingMember();
    internal void set_ConflictingMember(DataMember value);
    internal Getter get_Getter();
    internal Setter get_Setter();
    internal bool RequiresMemberAccessForGet();
    internal bool RequiresMemberAccessForSet();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataMember BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
}
internal class System.Runtime.Serialization.DataContracts.DateDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.DateTimeDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.DecimalDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.DoubleDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.ENTITIESDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.ENTITYDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.EnumDataContract : DataContract {
    internal static string ContractTypeString;
    private EnumDataContractCriticalHelper _helper;
    public string ContractType { get; }
    public DataContract BaseContract { get; }
    internal XmlQualifiedName BaseContractName { get; internal set; }
    internal List`1<DataMember> Members { get; internal set; }
    public ReadOnlyCollection`1<DataMember> DataMembers { get; }
    internal List`1<long> Values { get; internal set; }
    internal bool IsFlags { get; internal set; }
    internal bool IsULong { get; }
    internal XmlDictionaryString[] ChildElementNames { get; }
    internal bool CanContainReferences { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal EnumDataContract(Type type);
    public virtual string get_ContractType();
    internal static Type GetBaseType(XmlQualifiedName baseContractName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual DataContract get_BaseContract();
    internal XmlQualifiedName get_BaseContractName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void set_BaseContractName(XmlQualifiedName value);
    internal List`1<DataMember> get_Members();
    internal void set_Members(List`1<DataMember> value);
    public virtual ReadOnlyCollection`1<DataMember> get_DataMembers();
    internal List`1<long> get_Values();
    internal void set_Values(List`1<long> value);
    internal bool get_IsFlags();
    internal void set_IsFlags(bool value);
    internal bool get_IsULong();
    internal XmlDictionaryString[] get_ChildElementNames();
    internal virtual bool get_CanContainReferences();
    internal void WriteEnumValue(XmlWriterDelegator writer, object value);
    internal object ReadEnumValue(XmlReaderDelegator reader);
    private long ReadEnumValue(string value, int index, int count);
    internal string GetStringFromEnumValue(long value);
    internal long GetEnumValueFromString(string value);
    internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.DataContracts.FloatDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.GDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.GenericInfo : object {
    private string _genericTypeName;
    private XmlQualifiedName _xmlName;
    private List`1<GenericInfo> _paramGenericInfos;
    private List`1<int> _nestedParamCounts;
    public XmlQualifiedName XmlName { get; }
    public IList`1<GenericInfo> Parameters { get; }
    private bool System.Runtime.Serialization.DataContracts.IGenericNameProvider.ParametersFromBuiltInNamespaces { get; }
    internal GenericInfo(XmlQualifiedName xmlName, string genericTypeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlQualifiedName GetExpandedXmlName();
    public XmlQualifiedName get_XmlName();
    public IList`1<GenericInfo> get_Parameters();
    internal void Add(GenericInfo actualParamInfo);
    internal void AddToLevel(int level, int count);
    internal string GetXmlNamespace();
    private sealed virtual override int System.Runtime.Serialization.DataContracts.IGenericNameProvider.GetParameterCount();
    private sealed virtual override IList`1<int> System.Runtime.Serialization.DataContracts.IGenericNameProvider.GetNestedParameterCounts();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private sealed virtual override string System.Runtime.Serialization.DataContracts.IGenericNameProvider.GetParameterName(int paramIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private sealed virtual override string System.Runtime.Serialization.DataContracts.IGenericNameProvider.GetNamespaces();
    private sealed virtual override string System.Runtime.Serialization.DataContracts.IGenericNameProvider.GetGenericTypeName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private sealed virtual override bool System.Runtime.Serialization.DataContracts.IGenericNameProvider.get_ParametersFromBuiltInNamespaces();
}
internal class System.Runtime.Serialization.DataContracts.GenericNameProvider : object {
    private string _genericTypeName;
    private Object[] _genericParams;
    private IList`1<int> _nestedParamCounts;
    public bool ParametersFromBuiltInNamespaces { get; }
    internal GenericNameProvider(Type type);
    internal GenericNameProvider(string genericTypeName, Object[] genericParams);
    public sealed virtual int GetParameterCount();
    public sealed virtual IList`1<int> GetNestedParameterCounts();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public sealed virtual string GetParameterName(int paramIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public sealed virtual string GetNamespaces();
    public sealed virtual string GetGenericTypeName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public sealed virtual bool get_ParametersFromBuiltInNamespaces();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlQualifiedName GetXmlName(int i);
}
internal class System.Runtime.Serialization.DataContracts.GenericParameterDataContract : DataContract {
    private GenericParameterDataContractCriticalHelper _helper;
    internal int ParameterPosition { get; }
    public bool IsBuiltInDataContract { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal GenericParameterDataContract(Type type);
    internal int get_ParameterPosition();
    public virtual bool get_IsBuiltInDataContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
}
internal class System.Runtime.Serialization.DataContracts.GMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.GMonthDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.GuidDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal GuidDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.GYearDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.GYearMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.HexBinaryDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.IDDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.IDREFDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.IDREFSDataContract : StringDataContract {
}
internal interface System.Runtime.Serialization.DataContracts.IGenericNameProvider {
    public bool ParametersFromBuiltInNamespaces { get; }
    public abstract virtual int GetParameterCount();
    public abstract virtual IList`1<int> GetNestedParameterCounts();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual string GetParameterName(int paramIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual string GetNamespaces();
    public abstract virtual string GetGenericTypeName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual bool get_ParametersFromBuiltInNamespaces();
}
internal class System.Runtime.Serialization.DataContracts.IntDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.IntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.DataContracts.LanguageDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.LongDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal LongDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.NameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NCNameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NegativeIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NMTOKENDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NMTOKENSDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NonNegativeIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NonPositiveIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NormalizedStringDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.NullPrimitiveDataContract : PrimitiveDataContract {
    internal string ReadMethodName { get; }
    internal string WriteMethodName { get; }
    internal virtual string get_ReadMethodName();
    internal virtual string get_WriteMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.ObjectDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
}
internal class System.Runtime.Serialization.DataContracts.PositiveIntegerDataContract : LongDataContract {
}
internal abstract class System.Runtime.Serialization.DataContracts.PrimitiveDataContract : DataContract {
    internal static string ContractTypeString;
    internal static PrimitiveDataContract NullContract;
    private PrimitiveDataContractCriticalHelper _helper;
    public string ContractType { get; }
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    public XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    internal bool CanContainReferences { get; }
    internal bool IsPrimitive { get; }
    public bool IsBuiltInDataContract { get; }
    internal MethodInfo XmlFormatWriterMethod { get; }
    internal MethodInfo XmlFormatContentWriterMethod { get; }
    internal MethodInfo XmlFormatReaderMethod { get; }
    protected PrimitiveDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    private static PrimitiveDataContract();
    public virtual string get_ContractType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static PrimitiveDataContract GetPrimitiveDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static PrimitiveDataContract GetPrimitiveDataContract(string name, string ns);
    internal abstract virtual string get_WriteMethodName();
    internal abstract virtual string get_ReadMethodName();
    public virtual XmlDictionaryString get_TopLevelElementNamespace();
    internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    public virtual bool get_IsBuiltInDataContract();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal MethodInfo get_XmlFormatWriterMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal MethodInfo get_XmlFormatContentWriterMethod();
    internal MethodInfo get_XmlFormatReaderMethod();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    protected static object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected static bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
}
internal class System.Runtime.Serialization.DataContracts.QNameDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    internal virtual bool get_IsPrimitive();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.ShortDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.SignedByteDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.SpecialTypeDataContract : DataContract {
    private SpecialTypeDataContractCriticalHelper _helper;
    public bool IsBuiltInDataContract { get; }
    public SpecialTypeDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual bool get_IsBuiltInDataContract();
}
internal class System.Runtime.Serialization.DataContracts.StringDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal StringDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.TimeDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.TimeSpanDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal TimeSpanDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.TokenDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DataContracts.UnsignedByteDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.UnsignedIntDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.UnsignedLongDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.UnsignedShortDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.DataContracts.UriDataContract : PrimitiveDataContract {
    internal string WriteMethodName { get; }
    internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlElement(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context, XmlDictionaryString name, XmlDictionaryString ns);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.XmlDataContract : DataContract {
    internal static string ContractTypeString;
    private XmlDataContractCriticalHelper _helper;
    public string ContractType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    public XmlSchemaType XsdType { get; internal set; }
    public bool IsAnonymous { get; }
    public bool IsValueType { get; public set; }
    public bool HasRoot { get; internal set; }
    public XmlDictionaryString TopLevelElementName { get; internal set; }
    public XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    public bool IsTopLevelElementNullable { get; internal set; }
    public bool IsTypeDefinedOnImport { get; public set; }
    [NullableAttribute("1")]
internal CreateXmlSerializableDelegate CreateXmlSerializableDelegate { get; }
    internal bool CanContainReferences { get; }
    public bool IsBuiltInDataContract { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlDataContract(Type type);
    public virtual string get_ContractType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    public XmlSchemaType get_XsdType();
    internal void set_XsdType(XmlSchemaType value);
    public bool get_IsAnonymous();
    public bool get_IsValueType();
    public void set_IsValueType(bool value);
    public bool get_HasRoot();
    internal void set_HasRoot(bool value);
    public virtual XmlDictionaryString get_TopLevelElementName();
    internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    public virtual XmlDictionaryString get_TopLevelElementNamespace();
    internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    public bool get_IsTopLevelElementNullable();
    internal void set_IsTopLevelElementNullable(bool value);
    public bool get_IsTypeDefinedOnImport();
    public void set_IsTypeDefinedOnImport(bool value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal CreateXmlSerializableDelegate get_CreateXmlSerializableDelegate();
    internal virtual bool get_CanContainReferences();
    public virtual bool get_IsBuiltInDataContract();
    private ConstructorInfo GetConstructor();
    internal void SetTopLevelElementName(XmlQualifiedName elementName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal CreateXmlSerializableDelegate GenerateCreateXmlSerializableDelegate();
    private bool RequiresMemberAccessForCreate(SecurityException securityException);
    internal IXmlSerializable ReflectionCreateXmlSerializable(Type type);
    internal virtual bool Equals(object other, HashSet`1<DataContractPairKey> checkedContracts);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [CompilerGeneratedAttribute]
private IXmlSerializable <get_CreateXmlSerializableDelegate>b__32_0();
}
internal class System.Runtime.Serialization.DataContracts.XsDurationDataContract : TimeSpanDataContract {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContractSerializer : XmlObjectSerializer {
    private Type _rootType;
    private DataContract _rootContract;
    private bool _needsContractNsAtRoot;
    private XmlDictionaryString _rootName;
    private XmlDictionaryString _rootNamespace;
    private int _maxItemsInObjectGraph;
    private bool _ignoreExtensionDataObject;
    private bool _preserveObjectReferences;
    private ReadOnlyCollection`1<Type> _knownTypeCollection;
    internal IList`1<Type> _knownTypeList;
    internal Dictionary`2<XmlQualifiedName, DataContract> _knownDataContracts;
    private DataContractResolver _dataContractResolver;
    private ISerializationSurrogateProvider _serializationSurrogateProvider;
    private bool _serializeReadOnlyTypes;
    private static SerializationOption s_option;
    private static bool s_optionAlreadySet;
    [CompilerGeneratedAttribute]
private static UTF8Encoding <UTF8NoBom>k__BackingField;
    [CompilerGeneratedAttribute]
private static UTF8Encoding <ValidatingUTF8>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnicodeEncoding <UTF16NoBom>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnicodeEncoding <BEUTF16NoBom>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnicodeEncoding <ValidatingUTF16>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnicodeEncoding <ValidatingBEUTF16>k__BackingField;
    [CompilerGeneratedAttribute]
private static Base64Encoding <Base64Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static BinHexEncoding <BinHexEncoding>k__BackingField;
    internal static UTF8Encoding UTF8NoBom { get; }
    internal static UTF8Encoding ValidatingUTF8 { get; }
    internal static UnicodeEncoding UTF16NoBom { get; }
    internal static UnicodeEncoding BEUTF16NoBom { get; }
    internal static UnicodeEncoding ValidatingUTF16 { get; }
    internal static UnicodeEncoding ValidatingBEUTF16 { get; }
    internal static Base64Encoding Base64Encoding { get; }
    internal static BinHexEncoding BinHexEncoding { get; }
    internal static SerializationOption Option { get; internal set; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    public int MaxItemsInObjectGraph { get; }
    [NullableAttribute("2")]
internal ISerializationSurrogateProvider SerializationSurrogateProvider { get; internal set; }
    public bool PreserveObjectReferences { get; }
    public bool IgnoreExtensionDataObject { get; }
    [NullableAttribute("2")]
public DataContractResolver DataContractResolver { get; }
    public bool SerializeReadOnlyTypes { get; }
    private DataContract RootContract { get; }
    public DataContractSerializer(Type type);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, string rootName, string rootNamespace);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes);
    internal DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes, bool ignoreExtensionDataObject, bool preserveObjectReferences);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes);
    internal DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences);
    public DataContractSerializer(Type type, DataContractSerializerSettings settings);
    private static DataContractSerializer();
    [CompilerGeneratedAttribute]
internal static UTF8Encoding get_UTF8NoBom();
    [CompilerGeneratedAttribute]
internal static UTF8Encoding get_ValidatingUTF8();
    [CompilerGeneratedAttribute]
internal static UnicodeEncoding get_UTF16NoBom();
    [CompilerGeneratedAttribute]
internal static UnicodeEncoding get_BEUTF16NoBom();
    [CompilerGeneratedAttribute]
internal static UnicodeEncoding get_ValidatingUTF16();
    [CompilerGeneratedAttribute]
internal static UnicodeEncoding get_ValidatingBEUTF16();
    [CompilerGeneratedAttribute]
internal static Base64Encoding get_Base64Encoding();
    [CompilerGeneratedAttribute]
internal static BinHexEncoding get_BinHexEncoding();
    internal static SerializationOption get_Option();
    internal static void set_Option(SerializationOption value);
    private static bool IsReflectionBackupAllowed();
    [MemberNotNullAttribute("_rootType")]
private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    [MemberNotNullAttribute("_rootType")]
private void Initialize(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    internal ISerializationSurrogateProvider get_SerializationSurrogateProvider();
    internal void set_SerializationSurrogateProvider(ISerializationSurrogateProvider value);
    public bool get_PreserveObjectReferences();
    public bool get_IgnoreExtensionDataObject();
    [NullableContextAttribute("2")]
public DataContractResolver get_DataContractResolver();
    public bool get_SerializeReadOnlyTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract get_RootContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlWriter writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlDictionaryWriter writer);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void WriteObject(XmlDictionaryWriter writer, object graph, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlDictionaryReader reader);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReadObject(XmlDictionaryReader reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void InternalWriteObjectContent(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object SurrogateToDataContractType(ISerializationSurrogateProvider serializationSurrogateProvider, object oldObj, Type surrogatedDeclaredType, Type& objType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Type GetSurrogatedType(ISerializationSurrogateProvider serializationSurrogateProvider, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Runtime.Serialization.DataContractSerializerExtensions : object {
    [ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractSerializer serializer);
    [ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractSerializer serializer, ISerializationSurrogateProvider provider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContractSerializerSettings : object {
    private int _maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <RootName>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveObjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private DataContractResolver <DataContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeReadOnlyTypes>k__BackingField;
    public XmlDictionaryString RootName { get; public set; }
    public XmlDictionaryString RootNamespace { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public bool PreserveObjectReferences { get; public set; }
    public DataContractResolver DataContractResolver { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveObjectReferences();
    [CompilerGeneratedAttribute]
public void set_PreserveObjectReferences(bool value);
    [CompilerGeneratedAttribute]
public DataContractResolver get_DataContractResolver();
    [CompilerGeneratedAttribute]
public void set_DataContractResolver(DataContractResolver value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
}
internal static class System.Runtime.Serialization.DataContractSurrogateCaller : object {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Type GetDataContractType(ISerializationSurrogateProvider surrogateProvider, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object GetObjectToSerialize(ISerializationSurrogateProvider surrogateProvider, object obj, Type objType, Type membertype);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object GetDeserializedObject(ISerializationSurrogateProvider surrogateProvider, object obj, Type objType, Type memberType);
    internal static object GetCustomDataToExport(ISerializationSurrogateProvider2 surrogateProvider, MemberInfo memberInfo, Type dataContractType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object GetCustomDataToExport(ISerializationSurrogateProvider2 surrogateProvider, Type clrType, Type dataContractType);
    internal static void GetKnownCustomDataTypes(ISerializationSurrogateProvider2 surrogateProvider, Collection`1<Type> customDataTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Type GetReferencedTypeOnImport(ISerializationSurrogateProvider2 surrogateProvider, string typeName, string typeNamespace, object customData);
}
internal class System.Runtime.Serialization.DataNode`1 : object {
    protected Type dataType;
    private T _value;
    private string _dataContractName;
    private string _dataContractNamespace;
    private string _clrTypeName;
    private string _clrAssemblyName;
    private string _id;
    private bool _isFinalValue;
    public Type DataType { get; }
    public object Value { get; public set; }
    private bool System.Runtime.Serialization.IDataNode.IsFinalValue { get; private set; }
    public string DataContractName { get; public set; }
    public string DataContractNamespace { get; public set; }
    public string ClrTypeName { get; public set; }
    public string ClrAssemblyName { get; public set; }
    public bool PreservesReferences { get; }
    public string Id { get; public set; }
    internal DataNode`1(T value);
    public sealed virtual Type get_DataType();
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    private sealed virtual override bool System.Runtime.Serialization.IDataNode.get_IsFinalValue();
    private sealed virtual override void System.Runtime.Serialization.IDataNode.set_IsFinalValue(bool value);
    public T GetValue();
    public sealed virtual string get_DataContractName();
    public sealed virtual void set_DataContractName(string value);
    public sealed virtual string get_DataContractNamespace();
    public sealed virtual void set_DataContractNamespace(string value);
    public sealed virtual string get_ClrTypeName();
    public sealed virtual void set_ClrTypeName(string value);
    public sealed virtual string get_ClrAssemblyName();
    public sealed virtual void set_ClrAssemblyName(string value);
    public sealed virtual bool get_PreservesReferences();
    public sealed virtual string get_Id();
    public sealed virtual void set_Id(string value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
    internal static void AddQualifiedNameAttribute(ElementData element, string elementPrefix, string elementName, string elementNs, string valueName, string valueNs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DateTimeFormat : object {
    private string _formatString;
    private IFormatProvider _formatProvider;
    private DateTimeStyles _dateTimeStyles;
    public string FormatString { get; }
    public IFormatProvider FormatProvider { get; }
    public DateTimeStyles DateTimeStyles { get; public set; }
    public DateTimeFormat(string formatString);
    public DateTimeFormat(string formatString, IFormatProvider formatProvider);
    public string get_FormatString();
    public IFormatProvider get_FormatProvider();
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
}
[DataContractAttribute]
internal class System.Runtime.Serialization.DateTimeOffsetAdapter : ValueType {
    private DateTime _utcDateTime;
    private short _offsetMinutes;
    [DataMemberAttribute]
public DateTime UtcDateTime { get; public set; }
    [DataMemberAttribute]
public short OffsetMinutes { get; public set; }
    public DateTimeOffsetAdapter(DateTime dateTime, short offsetMinutes);
    public DateTime get_UtcDateTime();
    public void set_UtcDateTime(DateTime value);
    public short get_OffsetMinutes();
    public void set_OffsetMinutes(short value);
    public static DateTimeOffset GetDateTimeOffset(DateTimeOffsetAdapter value);
    public static DateTimeOffsetAdapter GetDateTimeOffsetAdapter(DateTimeOffset value);
    public string ToString(IFormatProvider provider);
}
internal static class System.Runtime.Serialization.DictionaryGlobals : object {
    private static XmlDictionary s_dictionary;
    public static XmlDictionaryString SchemaInstanceNamespace;
    public static XmlDictionaryString SerializationNamespace;
    public static XmlDictionaryString SchemaNamespace;
    public static XmlDictionaryString XsiTypeLocalName;
    public static XmlDictionaryString XsiNilLocalName;
    public static XmlDictionaryString IdLocalName;
    public static XmlDictionaryString RefLocalName;
    public static XmlDictionaryString ArraySizeLocalName;
    public static XmlDictionaryString EmptyString;
    public static XmlDictionaryString ISerializableFactoryTypeLocalName;
    public static XmlDictionaryString XmlnsNamespace;
    public static XmlDictionaryString CharLocalName;
    public static XmlDictionaryString BooleanLocalName;
    public static XmlDictionaryString SignedByteLocalName;
    public static XmlDictionaryString UnsignedByteLocalName;
    public static XmlDictionaryString ShortLocalName;
    public static XmlDictionaryString UnsignedShortLocalName;
    public static XmlDictionaryString IntLocalName;
    public static XmlDictionaryString UnsignedIntLocalName;
    public static XmlDictionaryString LongLocalName;
    public static XmlDictionaryString UnsignedLongLocalName;
    public static XmlDictionaryString FloatLocalName;
    public static XmlDictionaryString DoubleLocalName;
    public static XmlDictionaryString DecimalLocalName;
    public static XmlDictionaryString DateTimeLocalName;
    public static XmlDictionaryString StringLocalName;
    public static XmlDictionaryString ByteArrayLocalName;
    public static XmlDictionaryString ObjectLocalName;
    public static XmlDictionaryString TimeSpanLocalName;
    public static XmlDictionaryString GuidLocalName;
    public static XmlDictionaryString UriLocalName;
    public static XmlDictionaryString QNameLocalName;
    public static XmlDictionaryString ClrTypeLocalName;
    public static XmlDictionaryString ClrAssemblyLocalName;
    public static XmlDictionaryString Space;
    public static XmlDictionaryString timeLocalName;
    public static XmlDictionaryString dateLocalName;
    public static XmlDictionaryString hexBinaryLocalName;
    public static XmlDictionaryString gYearMonthLocalName;
    public static XmlDictionaryString gYearLocalName;
    public static XmlDictionaryString gMonthDayLocalName;
    public static XmlDictionaryString gDayLocalName;
    public static XmlDictionaryString gMonthLocalName;
    public static XmlDictionaryString integerLocalName;
    public static XmlDictionaryString positiveIntegerLocalName;
    public static XmlDictionaryString negativeIntegerLocalName;
    public static XmlDictionaryString nonPositiveIntegerLocalName;
    public static XmlDictionaryString nonNegativeIntegerLocalName;
    public static XmlDictionaryString normalizedStringLocalName;
    public static XmlDictionaryString tokenLocalName;
    public static XmlDictionaryString languageLocalName;
    public static XmlDictionaryString NameLocalName;
    public static XmlDictionaryString NCNameLocalName;
    public static XmlDictionaryString XSDIDLocalName;
    public static XmlDictionaryString IDREFLocalName;
    public static XmlDictionaryString IDREFSLocalName;
    public static XmlDictionaryString ENTITYLocalName;
    public static XmlDictionaryString ENTITIESLocalName;
    public static XmlDictionaryString NMTOKENLocalName;
    public static XmlDictionaryString NMTOKENSLocalName;
    public static XmlDictionaryString AsmxTypesNamespace;
    private static DictionaryGlobals();
}
internal class System.Runtime.Serialization.ElementData : object {
    public string localName;
    public string ns;
    public string prefix;
    public int attributeCount;
    public AttributeData[] attributes;
    public IDataNode dataNode;
    public int childElementIndex;
    public void AddAttribute(string prefix, string ns, string name, string value);
    [MemberNotNullAttribute("attributes")]
private void GrowAttributesIfNeeded();
}
public enum System.Runtime.Serialization.EmitTypeInformation : Enum {
    public int value__;
    public static EmitTypeInformation AsNeeded;
    public static EmitTypeInformation Always;
    public static EmitTypeInformation Never;
}
internal static class System.Runtime.Serialization.ExceptionUtility : object {
    public static bool IsFatal(Exception exception);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.ExportOptions : object {
    private Collection`1<Type> _knownTypes;
    [CompilerGeneratedAttribute]
private ISerializationSurrogateProvider <DataContractSurrogate>k__BackingField;
    public ISerializationSurrogateProvider DataContractSurrogate { get; public set; }
    [NullableAttribute("1")]
public Collection`1<Type> KnownTypes { get; }
    [CompilerGeneratedAttribute]
public ISerializationSurrogateProvider get_DataContractSurrogate();
    [CompilerGeneratedAttribute]
public void set_DataContractSurrogate(ISerializationSurrogateProvider value);
    [NullableContextAttribute("1")]
public Collection`1<Type> get_KnownTypes();
}
internal class System.Runtime.Serialization.ExtensionDataMember : object {
    private IDataNode _value;
    private int _memberIndex;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public string Name { get; }
    public string Namespace { get; }
    public IDataNode Value { get; public set; }
    public int MemberIndex { get; public set; }
    public ExtensionDataMember(string name, string ns);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    public IDataNode get_Value();
    public void set_Value(IDataNode value);
    public int get_MemberIndex();
    public void set_MemberIndex(int value);
}
public class System.Runtime.Serialization.ExtensionDataObject : object {
    private IList`1<ExtensionDataMember> _members;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.ExtensionDataReader : XmlReader {
    private ElementData[] _elements;
    private ElementData _element;
    private ElementData _nextElement;
    private ReadState _readState;
    private ExtensionDataNodeType _internalNodeType;
    private XmlNodeType _nodeType;
    private int _depth;
    private string _localName;
    private string _ns;
    private string _prefix;
    private string _value;
    private int _attributeCount;
    private int _attributeIndex;
    private Hashtable _cache;
    private XmlNodeReader _xmlNodeReader;
    private Queue`1<IDataNode> _deserializedDataNodes;
    private static object s_prefixLock;
    private XmlObjectSerializerReadContext _context;
    private static Hashtable s_nsToPrefixTable;
    private static Hashtable s_prefixToNsTable;
    [MemberNotNullWhenAttribute("True", "_xmlNodeReader")]
[MemberNotNullWhenAttribute("False", "_element")]
private bool IsXmlDataNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public string Value { get; }
    public int Depth { get; }
    public int AttributeCount { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Name { get; }
    public bool HasValue { get; }
    public string BaseURI { get; }
    public XmlNameTable NameTable { get; }
    private static ExtensionDataReader();
    internal ExtensionDataReader(XmlObjectSerializerReadContext context);
    internal void SetDeserializedValue(object obj);
    internal IDataNode GetCurrentNode();
    internal void SetDataNode(IDataNode dataNode, string name, string ns);
    internal void Reset();
    [MemberNotNullWhenAttribute("True", "_xmlNodeReader")]
[MemberNotNullWhenAttribute("False", "_element")]
private bool get_IsXmlDataNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual int get_AttributeCount();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual void MoveToAttribute(int index);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual bool MoveToAttribute(string name, string namespaceURI);
    public virtual bool MoveToElement();
    private void SetElement();
    public virtual string LookupNamespace(string prefix);
    public virtual void Skip();
    private static bool IsElementNode(ExtensionDataNodeType nodeType);
    protected virtual void Dispose(bool disposing);
    public virtual bool Read();
    public virtual string get_Name();
    public virtual bool get_HasValue();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    private void MoveNext(IDataNode dataNode);
    private void SetNextElement(IDataNode node, string name, string ns, string prefix);
    private void AddDeserializedDataNode(IDataNode node);
    private bool CheckIfNodeHandled(IDataNode node);
    private void MoveNextInClass(ClassDataNode dataNode);
    private void MoveNextInCollection(CollectionDataNode dataNode);
    private void MoveNextInISerializable(ISerializableDataNode dataNode);
    private void MoveNextInXml(XmlDataNode dataNode);
    private void MoveToDeserializedObject(IDataNode dataNode);
    private bool MoveToText(Type type, IDataNode dataNode, bool isTypedNode);
    private void PushElement();
    private void PopElement();
    [MemberNotNullAttribute("_elements")]
private void GrowElementsIfNeeded();
    private ElementData GetNextElement();
    internal static string GetPrefix(string ns);
    private static void AddPrefix(string prefix, string ns);
}
internal static class System.Runtime.Serialization.FastInvokerBuilder : object {
    private static MethodInfo s_createGetterInternal;
    private static MethodInfo s_createSetterInternal;
    private static MethodInfo s_make;
    private static FastInvokerBuilder();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
public static Func`1<object> GetMakeNewInstanceFunc(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
public static Getter CreateGetter(MemberInfo memberInfo);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
public static Setter CreateSetter(MemberInfo memberInfo);
    private static object Make();
    private static Getter CreateGetterInternal(PropertyInfo propInfo);
    private static Setter CreateSetterInternal(PropertyInfo propInfo);
}
internal class System.Runtime.Serialization.ForState : object {
    private LocalBuilder _indexVar;
    private Label _beginLabel;
    private Label _testLabel;
    private Label _endLabel;
    private bool _requiresEndLabel;
    private object _end;
    internal LocalBuilder Index { get; }
    internal Label BeginLabel { get; }
    internal Label TestLabel { get; }
    internal Label EndLabel { get; internal set; }
    internal bool RequiresEndLabel { get; internal set; }
    internal object End { get; }
    internal ForState(LocalBuilder indexVar, Label beginLabel, Label testLabel, object end);
    internal LocalBuilder get_Index();
    internal Label get_BeginLabel();
    internal Label get_TestLabel();
    internal Label get_EndLabel();
    internal void set_EndLabel(Label value);
    internal bool get_RequiresEndLabel();
    internal void set_RequiresEndLabel(bool value);
    internal object get_End();
}
internal static class System.Runtime.Serialization.Globals : object {
    internal static BindingFlags ScanAllMembers;
    private static XmlQualifiedName s_idQualifiedName;
    private static XmlQualifiedName s_refQualifiedName;
    private static Type s_typeOfObject;
    private static Type s_typeOfValueType;
    private static Type s_typeOfArray;
    private static Type s_typeOfString;
    private static Type s_typeOfInt;
    private static Type s_typeOfULong;
    private static Type s_typeOfVoid;
    private static Type s_typeOfByteArray;
    private static Type s_typeOfTimeSpan;
    private static Type s_typeOfGuid;
    private static Type s_typeOfDateTimeOffset;
    private static Type s_typeOfDateTimeOffsetAdapter;
    private static Type s_typeOfMemoryStream;
    private static Type s_typeOfMemoryStreamAdapter;
    private static Type s_typeOfUri;
    private static Type s_typeOfTypeEnumerable;
    private static Type s_typeOfStreamingContext;
    private static Type s_typeOfISerializable;
    private static Type s_typeOfIDeserializationCallback;
    private static Type s_typeOfIObjectReference;
    private static Type s_typeOfXmlFormatClassWriterDelegate;
    private static Type s_typeOfXmlFormatCollectionWriterDelegate;
    private static Type s_typeOfXmlFormatClassReaderDelegate;
    private static Type s_typeOfXmlFormatCollectionReaderDelegate;
    private static Type s_typeOfXmlFormatGetOnlyCollectionReaderDelegate;
    private static Type s_typeOfKnownTypeAttribute;
    private static Type s_typeOfDataContractAttribute;
    private static Type s_typeOfDataMemberAttribute;
    private static Type s_typeOfEnumMemberAttribute;
    private static Type s_typeOfCollectionDataContractAttribute;
    private static Type s_typeOfOptionalFieldAttribute;
    private static Type s_typeOfObjectArray;
    private static Type s_typeOfOnSerializingAttribute;
    private static Type s_typeOfOnSerializedAttribute;
    private static Type s_typeOfOnDeserializingAttribute;
    private static Type s_typeOfOnDeserializedAttribute;
    private static Type s_typeOfFlagsAttribute;
    private static Type s_typeOfIXmlSerializable;
    private static Type s_typeOfXmlSchemaProviderAttribute;
    private static Type s_typeOfXmlRootAttribute;
    private static Type s_typeOfXmlQualifiedName;
    private static Type s_typeOfXmlSchemaType;
    private static Type s_typeOfIExtensibleDataObject;
    private static Type s_typeOfExtensionDataObject;
    private static Type s_typeOfISerializableDataNode;
    private static Type s_typeOfClassDataNode;
    private static Type s_typeOfCollectionDataNode;
    private static Type s_typeOfXmlDataNode;
    private static Type s_typeOfNullable;
    private static Type s_typeOfReflectionPointer;
    private static Type s_typeOfIDictionaryGeneric;
    private static Type s_typeOfIDictionary;
    private static Type s_typeOfIListGeneric;
    private static Type s_typeOfIList;
    private static Type s_typeOfICollectionGeneric;
    private static Type s_typeOfICollection;
    private static Type s_typeOfIEnumerableGeneric;
    private static Type s_typeOfIEnumerable;
    private static Type s_typeOfIEnumeratorGeneric;
    private static Type s_typeOfIEnumerator;
    private static Type s_typeOfKeyValuePair;
    private static Type s_typeOfKeyValue;
    private static Type s_typeOfIDictionaryEnumerator;
    private static Type s_typeOfDictionaryEnumerator;
    private static Type s_typeOfGenericDictionaryEnumerator;
    private static Type s_typeOfDictionaryGeneric;
    private static Type s_typeOfHashtable;
    private static Type s_typeOfXmlElement;
    private static Type s_typeOfXmlNodeArray;
    private static Type s_typeOfDBNull;
    [DynamicallyAccessedMembersAttribute("64")]
private static Type s_typeOfSchemaDefinedType;
    [DynamicallyAccessedMembersAttribute("64")]
private static Type s_typeOfSchemaDefinedEnum;
    private static MemberInfo s_schemaMemberInfoPlaceholder;
    private static Uri s_dataContractXsdBaseNamespaceUri;
    public static bool DefaultIsRequired;
    public static bool DefaultEmitDefaultValue;
    public static int DefaultOrder;
    public static bool DefaultIsReference;
    public static string NewObjectId;
    public static string NullObjectId;
    public static string FullSRSInternalsVisiblePattern;
    public static char SpaceChar;
    public static char OpenBracketChar;
    public static char CloseBracketChar;
    public static char CommaChar;
    public static string Space;
    public static string XsiPrefix;
    public static string XsdPrefix;
    public static string SerPrefix;
    public static string SerPrefixForSchema;
    public static string ElementPrefix;
    public static string DataContractXsdBaseNamespace;
    public static string DataContractXmlNamespace;
    public static string SchemaInstanceNamespace;
    public static string SchemaNamespace;
    public static string XsiNilLocalName;
    public static string XsiTypeLocalName;
    public static string TnsPrefix;
    public static string OccursUnbounded;
    public static string AnyTypeLocalName;
    public static string StringLocalName;
    public static string IntLocalName;
    public static string True;
    public static string False;
    public static string ArrayPrefix;
    public static string XmlnsNamespace;
    public static string XmlnsPrefix;
    public static string SchemaLocalName;
    public static string CollectionsNamespace;
    public static string DefaultClrNamespace;
    public static string DefaultTypeName;
    public static string DefaultGeneratedMember;
    public static string DefaultFieldSuffix;
    public static string DefaultPropertySuffix;
    public static string DefaultMemberSuffix;
    public static string NameProperty;
    public static string NamespaceProperty;
    public static string OrderProperty;
    public static string IsReferenceProperty;
    public static string IsRequiredProperty;
    public static string EmitDefaultValueProperty;
    public static string ClrNamespaceProperty;
    public static string ItemNameProperty;
    public static string KeyNameProperty;
    public static string ValueNameProperty;
    public static string SerializationInfoPropertyName;
    public static string SerializationInfoFieldName;
    public static string NodeArrayPropertyName;
    public static string NodeArrayFieldName;
    public static string ExportSchemaMethod;
    public static string IsAnyProperty;
    public static string ContextFieldName;
    public static string GetObjectDataMethodName;
    public static string GetEnumeratorMethodName;
    public static string MoveNextMethodName;
    public static string AddValueMethodName;
    public static string CurrentPropertyName;
    public static string ValueProperty;
    public static string EnumeratorFieldName;
    public static string SerializationEntryFieldName;
    public static string ExtensionDataSetMethod;
    public static string ExtensionDataSetExplicitMethod;
    public static string ExtensionDataObjectPropertyName;
    public static string ExtensionDataObjectFieldName;
    public static string AddMethodName;
    public static string GetCurrentMethodName;
    public static string SerializationNamespace;
    public static string ClrTypeLocalName;
    public static string ClrAssemblyLocalName;
    public static string IsValueTypeLocalName;
    public static string EnumerationValueLocalName;
    public static string SurrogateDataLocalName;
    public static string GenericTypeLocalName;
    public static string GenericParameterLocalName;
    public static string GenericNameAttribute;
    public static string GenericNamespaceAttribute;
    public static string GenericParameterNestedLevelAttribute;
    public static string IsDictionaryLocalName;
    public static string ActualTypeLocalName;
    public static string ActualTypeNameAttribute;
    public static string ActualTypeNamespaceAttribute;
    public static string DefaultValueLocalName;
    public static string EmitDefaultValueAttribute;
    public static string IdLocalName;
    public static string RefLocalName;
    public static string ArraySizeLocalName;
    public static string KeyLocalName;
    public static string ValueLocalName;
    public static string MscorlibAssemblyName;
    public static string ParseMethodName;
    public static string SafeSerializationManagerName;
    public static string SafeSerializationManagerNamespace;
    public static string ISerializableFactoryTypeLocalName;
    public static string SerializationSchema;
    internal static XmlQualifiedName IdQualifiedName { get; }
    internal static XmlQualifiedName RefQualifiedName { get; }
    internal static Type TypeOfObject { get; }
    internal static Type TypeOfValueType { get; }
    internal static Type TypeOfArray { get; }
    internal static Type TypeOfString { get; }
    internal static Type TypeOfInt { get; }
    internal static Type TypeOfULong { get; }
    internal static Type TypeOfVoid { get; }
    internal static Type TypeOfByteArray { get; }
    internal static Type TypeOfTimeSpan { get; }
    internal static Type TypeOfGuid { get; }
    internal static Type TypeOfDateTimeOffset { get; }
    internal static Type TypeOfDateTimeOffsetAdapter { get; }
    internal static Type TypeOfMemoryStream { get; }
    internal static Type TypeOfMemoryStreamAdapter { get; }
    internal static Type TypeOfUri { get; }
    internal static Type TypeOfTypeEnumerable { get; }
    internal static Type TypeOfStreamingContext { get; }
    internal static Type TypeOfISerializable { get; }
    internal static Type TypeOfIDeserializationCallback { get; }
    internal static Type TypeOfIObjectReference { get; }
    internal static Type TypeOfXmlFormatClassWriterDelegate { get; }
    internal static Type TypeOfXmlFormatCollectionWriterDelegate { get; }
    internal static Type TypeOfXmlFormatClassReaderDelegate { get; }
    internal static Type TypeOfXmlFormatCollectionReaderDelegate { get; }
    internal static Type TypeOfXmlFormatGetOnlyCollectionReaderDelegate { get; }
    internal static Type TypeOfKnownTypeAttribute { get; }
    internal static Type TypeOfDataContractAttribute { get; }
    internal static Type TypeOfDataMemberAttribute { get; }
    internal static Type TypeOfEnumMemberAttribute { get; }
    internal static Type TypeOfCollectionDataContractAttribute { get; }
    internal static Type TypeOfOptionalFieldAttribute { get; }
    internal static Type TypeOfObjectArray { get; }
    internal static Type TypeOfOnSerializingAttribute { get; }
    internal static Type TypeOfOnSerializedAttribute { get; }
    internal static Type TypeOfOnDeserializingAttribute { get; }
    internal static Type TypeOfOnDeserializedAttribute { get; }
    internal static Type TypeOfFlagsAttribute { get; }
    internal static Type TypeOfIXmlSerializable { get; }
    internal static Type TypeOfXmlSchemaProviderAttribute { get; }
    internal static Type TypeOfXmlRootAttribute { get; }
    internal static Type TypeOfXmlQualifiedName { get; }
    internal static Type TypeOfXmlSchemaType { get; }
    internal static Type TypeOfIExtensibleDataObject { get; }
    internal static Type TypeOfExtensionDataObject { get; }
    internal static Type TypeOfISerializableDataNode { get; }
    internal static Type TypeOfClassDataNode { get; }
    internal static Type TypeOfCollectionDataNode { get; }
    internal static Type TypeOfXmlDataNode { get; }
    internal static Type TypeOfNullable { get; }
    internal static Type TypeOfReflectionPointer { get; }
    internal static Type TypeOfIDictionaryGeneric { get; }
    internal static Type TypeOfIDictionary { get; }
    internal static Type TypeOfIListGeneric { get; }
    internal static Type TypeOfIList { get; }
    internal static Type TypeOfICollectionGeneric { get; }
    internal static Type TypeOfICollection { get; }
    internal static Type TypeOfIEnumerableGeneric { get; }
    internal static Type TypeOfIEnumerable { get; }
    internal static Type TypeOfIEnumeratorGeneric { get; }
    internal static Type TypeOfIEnumerator { get; }
    internal static Type TypeOfKeyValuePair { get; }
    internal static Type TypeOfKeyValue { get; }
    internal static Type TypeOfIDictionaryEnumerator { get; }
    internal static Type TypeOfDictionaryEnumerator { get; }
    internal static Type TypeOfGenericDictionaryEnumerator { get; }
    internal static Type TypeOfDictionaryGeneric { get; }
    internal static Type TypeOfHashtable { get; }
    internal static Type TypeOfXmlElement { get; }
    internal static Type TypeOfXmlNodeArray { get; }
    internal static Type TypeOfDBNull { get; }
    [DynamicallyAccessedMembersAttribute("64")]
internal static Type TypeOfSchemaDefinedType { get; }
    [DynamicallyAccessedMembersAttribute("64")]
internal static Type TypeOfSchemaDefinedEnum { get; }
    internal static MemberInfo SchemaMemberInfoPlaceholder { get; }
    internal static Uri DataContractXsdBaseNamespaceUri { get; }
    private static Globals();
    internal static XmlQualifiedName get_IdQualifiedName();
    internal static XmlQualifiedName get_RefQualifiedName();
    internal static Type get_TypeOfObject();
    internal static Type get_TypeOfValueType();
    internal static Type get_TypeOfArray();
    internal static Type get_TypeOfString();
    internal static Type get_TypeOfInt();
    internal static Type get_TypeOfULong();
    internal static Type get_TypeOfVoid();
    internal static Type get_TypeOfByteArray();
    internal static Type get_TypeOfTimeSpan();
    internal static Type get_TypeOfGuid();
    internal static Type get_TypeOfDateTimeOffset();
    internal static Type get_TypeOfDateTimeOffsetAdapter();
    internal static Type get_TypeOfMemoryStream();
    internal static Type get_TypeOfMemoryStreamAdapter();
    internal static Type get_TypeOfUri();
    internal static Type get_TypeOfTypeEnumerable();
    internal static Type get_TypeOfStreamingContext();
    internal static Type get_TypeOfISerializable();
    internal static Type get_TypeOfIDeserializationCallback();
    internal static Type get_TypeOfIObjectReference();
    internal static Type get_TypeOfXmlFormatClassWriterDelegate();
    internal static Type get_TypeOfXmlFormatCollectionWriterDelegate();
    internal static Type get_TypeOfXmlFormatClassReaderDelegate();
    internal static Type get_TypeOfXmlFormatCollectionReaderDelegate();
    internal static Type get_TypeOfXmlFormatGetOnlyCollectionReaderDelegate();
    internal static Type get_TypeOfKnownTypeAttribute();
    internal static Type get_TypeOfDataContractAttribute();
    internal static Type get_TypeOfDataMemberAttribute();
    internal static Type get_TypeOfEnumMemberAttribute();
    internal static Type get_TypeOfCollectionDataContractAttribute();
    internal static Type get_TypeOfOptionalFieldAttribute();
    internal static Type get_TypeOfObjectArray();
    internal static Type get_TypeOfOnSerializingAttribute();
    internal static Type get_TypeOfOnSerializedAttribute();
    internal static Type get_TypeOfOnDeserializingAttribute();
    internal static Type get_TypeOfOnDeserializedAttribute();
    internal static Type get_TypeOfFlagsAttribute();
    internal static Type get_TypeOfIXmlSerializable();
    internal static Type get_TypeOfXmlSchemaProviderAttribute();
    internal static Type get_TypeOfXmlRootAttribute();
    internal static Type get_TypeOfXmlQualifiedName();
    internal static Type get_TypeOfXmlSchemaType();
    internal static Type get_TypeOfIExtensibleDataObject();
    internal static Type get_TypeOfExtensionDataObject();
    internal static Type get_TypeOfISerializableDataNode();
    internal static Type get_TypeOfClassDataNode();
    internal static Type get_TypeOfCollectionDataNode();
    internal static Type get_TypeOfXmlDataNode();
    internal static Type get_TypeOfNullable();
    internal static Type get_TypeOfReflectionPointer();
    internal static Type get_TypeOfIDictionaryGeneric();
    internal static Type get_TypeOfIDictionary();
    internal static Type get_TypeOfIListGeneric();
    internal static Type get_TypeOfIList();
    internal static Type get_TypeOfICollectionGeneric();
    internal static Type get_TypeOfICollection();
    internal static Type get_TypeOfIEnumerableGeneric();
    internal static Type get_TypeOfIEnumerable();
    internal static Type get_TypeOfIEnumeratorGeneric();
    internal static Type get_TypeOfIEnumerator();
    internal static Type get_TypeOfKeyValuePair();
    internal static Type get_TypeOfKeyValue();
    internal static Type get_TypeOfIDictionaryEnumerator();
    internal static Type get_TypeOfDictionaryEnumerator();
    internal static Type get_TypeOfGenericDictionaryEnumerator();
    internal static Type get_TypeOfDictionaryGeneric();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Type get_TypeOfHashtable();
    internal static Type get_TypeOfXmlElement();
    internal static Type get_TypeOfXmlNodeArray();
    internal static Type get_TypeOfDBNull();
    internal static Type get_TypeOfSchemaDefinedType();
    internal static Type get_TypeOfSchemaDefinedEnum();
    internal static MemberInfo get_SchemaMemberInfoPlaceholder();
    internal static Uri get_DataContractXsdBaseNamespaceUri();
    [GeneratedRegexAttribute("^[\s]*System\.Runtime\.Serialization[\s]*,[\s]*PublicKey[\s]*=[\s]*(?i:00240000048000009400000006020000002400005253413100040000010001008d56c76f9e8649383049f383c44be0ec204181822a6c31cf5eb7ef486944d032188ea1d3920763712ccb12d75fb77e9811149e6148e5d32fbaab37611c1878ddc19e20ef135d0cb2cff2bfec3d115810c3d9069638fe4be215dbf795861920e5ab6f7db2e2ceef136ac23d5dd2bf031700aec232f6c6b1c785b4305c123b37ab)[\s]*$")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
public static Regex FullSRSInternalsVisibleRegex();
}
internal class System.Runtime.Serialization.HybridObjectCache : object {
    private Dictionary`2<string, object> _objectDictionary;
    private Dictionary`2<string, object> _referencedObjectDictionary;
    internal void Add(string id, object obj);
    internal void Remove(string id);
    internal object GetObject(string id);
    internal bool IsObjectReferenced(string id);
}
internal interface System.Runtime.Serialization.IDataNode {
    public Type DataType { get; }
    public object Value { get; public set; }
    public string DataContractName { get; public set; }
    public string DataContractNamespace { get; public set; }
    public string ClrTypeName { get; public set; }
    public string ClrAssemblyName { get; public set; }
    public string Id { get; public set; }
    public bool PreservesReferences { get; }
    public bool IsFinalValue { get; public set; }
    public abstract virtual Type get_DataType();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual string get_DataContractName();
    public abstract virtual void set_DataContractName(string value);
    public abstract virtual string get_DataContractNamespace();
    public abstract virtual void set_DataContractNamespace(string value);
    public abstract virtual string get_ClrTypeName();
    public abstract virtual void set_ClrTypeName(string value);
    public abstract virtual string get_ClrAssemblyName();
    public abstract virtual void set_ClrAssemblyName(string value);
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual bool get_PreservesReferences();
    public abstract virtual void GetData(ElementData element);
    public abstract virtual bool get_IsFinalValue();
    public abstract virtual void set_IsFinalValue(bool value);
    public abstract virtual void Clear();
}
[NullableContextAttribute("2")]
public interface System.Runtime.Serialization.IExtensibleDataObject {
    public ExtensionDataObject ExtensionData { get; public set; }
    public abstract virtual ExtensionDataObject get_ExtensionData();
    public abstract virtual void set_ExtensionData(ExtensionDataObject value);
}
internal class System.Runtime.Serialization.IfState : object {
    private Label _elseBegin;
    private Label _endIf;
    internal Label EndIf { get; internal set; }
    internal Label ElseBegin { get; internal set; }
    internal Label get_EndIf();
    internal void set_EndIf(Label value);
    internal Label get_ElseBegin();
    internal void set_ElseBegin(Label value);
}
internal interface System.Runtime.Serialization.IKeyValue {
    public object Key { get; public set; }
    public object Value { get; public set; }
    public abstract virtual object get_Key();
    public abstract virtual void set_Key(object value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal class System.Runtime.Serialization.ISerializableDataMember : object {
    private IDataNode _value;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; }
    internal IDataNode Value { get; internal set; }
    public ISerializableDataMember(string name);
    [CompilerGeneratedAttribute]
internal string get_Name();
    internal IDataNode get_Value();
    internal void set_Value(IDataNode value);
}
internal class System.Runtime.Serialization.ISerializableDataNode : DataNode`1<object> {
    private string _factoryTypeName;
    private string _factoryTypeNamespace;
    private IList`1<ISerializableDataMember> _members;
    internal string FactoryTypeName { get; internal set; }
    internal string FactoryTypeNamespace { get; internal set; }
    internal IList`1<ISerializableDataMember> Members { get; internal set; }
    internal string get_FactoryTypeName();
    internal void set_FactoryTypeName(string value);
    internal string get_FactoryTypeNamespace();
    internal void set_FactoryTypeNamespace(string value);
    internal IList`1<ISerializableDataMember> get_Members();
    internal void set_Members(IList`1<ISerializableDataMember> value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.Json.ByteArrayHelperWithString : ArrayHelper`2<string, byte> {
    public static ByteArrayHelperWithString Instance;
    private static ByteArrayHelperWithString();
    internal static void WriteArray(XmlWriter writer, Byte[] array, int offset, int count);
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Byte[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Byte[] array, int offset, int count);
    private static void ThrowConversionException(string value, string type);
    private static byte ToByte(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.Json.DataContractJsonSerializer : XmlObjectSerializer {
    internal IList`1<Type> knownTypeList;
    internal Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts;
    private EmitTypeInformation _emitTypeInformation;
    private ReadOnlyCollection`1<Type> _knownTypeCollection;
    private int _maxItemsInObjectGraph;
    private bool _serializeReadOnlyTypes;
    private DateTimeFormat _dateTimeFormat;
    private bool _useSimpleDictionaryFormat;
    private bool _ignoreExtensionDataObject;
    private DataContract _rootContract;
    private XmlDictionaryString _rootName;
    private bool _rootNameRequiresMapping;
    private Type _rootType;
    private ISerializationSurrogateProvider _serializationSurrogateProvider;
    [NullableAttribute("2")]
internal ISerializationSurrogateProvider SerializationSurrogateProvider { get; internal set; }
    public bool IgnoreExtensionDataObject { get; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    public int MaxItemsInObjectGraph { get; }
    [NullableAttribute("2")]
public DateTimeFormat DateTimeFormat { get; }
    public EmitTypeInformation EmitTypeInformation { get; }
    public bool SerializeReadOnlyTypes { get; }
    public bool UseSimpleDictionaryFormat { get; }
    private DataContract RootContract { get; }
    private XmlDictionaryString RootName { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, string rootName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, XmlDictionaryString rootName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractJsonSerializer(Type type, DataContractJsonSerializerSettings settings);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool alwaysEmitTypeInformation);
    internal ISerializationSurrogateProvider get_SerializationSurrogateProvider();
    internal void set_SerializationSurrogateProvider(ISerializationSurrogateProvider value);
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    [NullableContextAttribute("2")]
public DateTimeFormat get_DateTimeFormat();
    public EmitTypeInformation get_EmitTypeInformation();
    public bool get_SerializeReadOnlyTypes();
    public bool get_UseSimpleDictionaryFormat();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract get_RootContract();
    private XmlDictionaryString get_RootName();
    [NullableContextAttribute("2")]
public ISerializationSurrogateProvider GetSerializationSurrogateProvider();
    [NullableContextAttribute("2")]
public void SetSerializationSurrogateProvider(ISerializationSurrogateProvider provider);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlDictionaryReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(Stream stream);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlWriter writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlDictionaryWriter writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(Stream stream, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    internal static bool CheckIfJsonNameRequiresMapping(string jsonName);
    internal static bool CheckIfJsonNameRequiresMapping(XmlDictionaryString jsonName);
    internal static bool CheckIfXmlNameRequiresMapping(string xmlName);
    internal static bool CheckIfXmlNameRequiresMapping(XmlDictionaryString xmlName);
    internal static string ConvertXmlNameToJsonName(string xmlName);
    internal static XmlDictionaryString ConvertXmlNameToJsonName(XmlDictionaryString xmlName);
    internal static bool IsJsonLocalName(XmlReaderDelegator reader, string elementName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object ReadJsonValue(DataContract contract, XmlReaderDelegator reader, XmlObjectSerializerReadContextComplexJson context);
    internal static void WriteJsonNull(XmlWriterDelegator writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static void WriteJsonValue(JsonDataContract contract, XmlWriterDelegator writer, object graph, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal virtual Type GetDeserializeType();
    internal virtual Type GetSerializeType(object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddCollectionItemTypeToKnownTypes(Type knownType);
    [MemberNotNullAttribute("_rootType")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    [MemberNotNullAttribute("_rootType")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void Initialize(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    internal static void CheckIfTypeIsReference(DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Runtime.Serialization.Json.DataContractJsonSerializerExtensions : object {
    [ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractJsonSerializer serializer);
    [ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractJsonSerializer serializer, ISerializationSurrogateProvider provider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.Json.DataContractJsonSerializerSettings : object {
    private int _maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]
private string <RootName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitTypeInformation <EmitTypeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeFormat <DateTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeReadOnlyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSimpleDictionaryFormat>k__BackingField;
    public string RootName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public EmitTypeInformation EmitTypeInformation { get; public set; }
    public DateTimeFormat DateTimeFormat { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    public bool UseSimpleDictionaryFormat { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public EmitTypeInformation get_EmitTypeInformation();
    [CompilerGeneratedAttribute]
public void set_EmitTypeInformation(EmitTypeInformation value);
    [CompilerGeneratedAttribute]
public DateTimeFormat get_DateTimeFormat();
    [CompilerGeneratedAttribute]
public void set_DateTimeFormat(DateTimeFormat value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSimpleDictionaryFormat();
    [CompilerGeneratedAttribute]
public void set_UseSimpleDictionaryFormat(bool value);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.Json.IXmlJsonReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.Json.IXmlJsonWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
internal class System.Runtime.Serialization.Json.JsonByteArrayDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonByteArrayDataContract(ByteArrayDataContract traditionalByteArrayDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonClassDataContract : JsonDataContract {
    private JsonClassDataContractCriticalHelper _helper;
    internal JsonFormatClassReaderDelegate JsonFormatReaderDelegate { get; }
    internal JsonFormatClassWriterDelegate JsonFormatWriterDelegate { get; }
    internal XmlDictionaryString[] MemberNames { get; }
    internal string TypeName { get; }
    private ClassDataContract TraditionalClassDataContract { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonClassDataContract(ClassDataContract traditionalDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatClassReaderDelegate get_JsonFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatClassWriterDelegate get_JsonFormatWriterDelegate();
    internal XmlDictionaryString[] get_MemberNames();
    internal virtual string get_TypeName();
    private ClassDataContract get_TraditionalClassDataContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonCollectionDataContract : JsonDataContract {
    private JsonCollectionDataContractCriticalHelper _helper;
    internal JsonFormatCollectionReaderDelegate JsonFormatReaderDelegate { get; }
    internal JsonFormatGetOnlyCollectionReaderDelegate JsonFormatGetOnlyReaderDelegate { get; }
    internal JsonFormatCollectionWriterDelegate JsonFormatWriterDelegate { get; }
    private CollectionDataContract TraditionalCollectionDataContract { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonCollectionDataContract(CollectionDataContract traditionalDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatCollectionReaderDelegate get_JsonFormatReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatGetOnlyCollectionReaderDelegate get_JsonFormatGetOnlyReaderDelegate();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatCollectionWriterDelegate get_JsonFormatWriterDelegate();
    private CollectionDataContract get_TraditionalCollectionDataContract();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonDataContract : object {
    private JsonDataContractCriticalHelper _helper;
    internal string TypeName { get; }
    protected JsonDataContractCriticalHelper Helper { get; }
    protected DataContract TraditionalDataContract { get; }
    private Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected JsonDataContract(DataContract traditionalDataContract);
    protected JsonDataContract(JsonDataContractCriticalHelper helper);
    internal virtual string get_TypeName();
    protected JsonDataContractCriticalHelper get_Helper();
    protected DataContract get_TraditionalDataContract();
    private Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public static JsonReadWriteDelegates GetGeneratedReadWriteDelegates(DataContract c);
    internal static JsonReadWriteDelegates GetReadWriteDelegatesFromGeneratedAssembly(DataContract c);
    internal static JsonReadWriteDelegates TryGetReadWriteDelegatesFromGeneratedAssembly(DataContract c);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static JsonDataContract GetJsonDataContract(DataContract traditionalDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReadJsonValue(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void WriteJsonValue(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    protected static object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected static bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    protected void PopKnownDataContracts(XmlObjectSerializerContext context);
    protected void PushKnownDataContracts(XmlObjectSerializerContext context);
}
internal class System.Runtime.Serialization.Json.JsonEncodingStreamWrapper : Stream {
    private static int BufferLength;
    private int _byteCount;
    private int _byteOffset;
    private Byte[] _bytes;
    private Char[] _chars;
    private Decoder _dec;
    private Encoder _enc;
    private Encoding _encoding;
    private SupportedEncoding _encodingCode;
    private bool _isReading;
    private BufferedStream _stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public JsonEncodingStreamWrapper(Stream stream, Encoding encoding, bool isReader);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte b);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    private static SupportedEncoding ReadEncoding(byte b1, byte b2);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private void CleanupCharBreak();
    [MemberNotNullAttribute("_chars")]
[MemberNotNullAttribute("_bytes")]
private void EnsureBuffers();
    [MemberNotNullAttribute("_bytes")]
private void EnsureByteBuffer();
    private void FillBuffer(int count);
    private void InitForReading(Stream inputStream, Encoding expectedEncoding);
    private void InitForWriting(Stream outputStream, Encoding writeEncoding);
    private SupportedEncoding ReadEncoding();
}
internal class System.Runtime.Serialization.Json.JsonEnumDataContract : JsonDataContract {
    private JsonEnumDataContractCriticalHelper _helper;
    public bool IsULong { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonEnumDataContract(EnumDataContract traditionalDataContract);
    public bool get_IsULong();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassReaderDelegate : MulticastDelegate {
    public JsonFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassWriterDelegate : MulticastDelegate {
    public JsonFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionWriterDelegate : MulticastDelegate {
    public JsonFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatReaderGenerator : object {
    private CriticalHelper _helper;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.JsonFormatWriterGenerator : object {
    private CriticalHelper _helper;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal JsonFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
internal static class System.Runtime.Serialization.Json.JsonGlobals : object {
    public static char QuoteChar;
    public static string KeyString;
    public static string ValueString;
    public static string ServerTypeString;
    public static int DataContractXsdBaseNamespaceLength;
    public static long unixEpochTicks;
    public static SecurityException SecurityException;
    public static string PositiveInf;
    public static string NegativeInf;
    public static string typeString;
    public static string nullString;
    public static string arrayString;
    public static string booleanString;
    public static string stringString;
    public static string numberString;
    public static string objectString;
    public static string itemString;
    public static string rootString;
    public static string NameValueSeparatorString;
    public static string DateTimeEndGuardReader;
    public static string DateTimeEndGuardWriter;
    public static string DateTimeStartGuardReader;
    public static string DateTimeStartGuardWriter;
    public static string xmlnsPrefix;
    public static string xmlPrefix;
    public static byte EndCollectionByte;
    public static char EndCollectionChar;
    public static byte EndObjectByte;
    public static char EndObjectChar;
    public static byte MemberSeparatorByte;
    public static char MemberSeparatorChar;
    public static byte NameValueSeparatorByte;
    public static char NameValueSeparatorChar;
    public static byte QuoteByte;
    public static byte ObjectByte;
    public static char ObjectChar;
    public static byte CollectionByte;
    public static char CollectionChar;
    public static char WhitespaceChar;
    public static string serverTypeString;
    public static int maxScopeSize;
    public static XmlDictionaryString itemDictionaryString;
    public static XmlDictionaryString rootDictionaryString;
    private static JsonGlobals();
}
internal enum System.Runtime.Serialization.Json.JsonNodeType : Enum {
    public int value__;
    public static JsonNodeType None;
    public static JsonNodeType Object;
    public static JsonNodeType Element;
    public static JsonNodeType EndElement;
    public static JsonNodeType QuotedText;
    public static JsonNodeType StandaloneText;
    public static JsonNodeType Collection;
}
internal class System.Runtime.Serialization.Json.JsonObjectDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonObjectDataContract(DataContract traditionalDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal static object ParseJsonNumber(string value, TypeCode& objectTypeCode);
    private static object ParseJsonNumber(string value);
}
internal class System.Runtime.Serialization.Json.JsonQNameDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonQNameDataContract(QNameDataContract traditionalQNameDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonReaderDelegator : XmlReaderDelegator {
    private DateTimeFormat _dateTimeFormat;
    private DateTimeArrayJsonHelperWithString _dateTimeArrayHelper;
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; }
    private DateTimeArrayJsonHelperWithString DateTimeArrayHelper { get; }
    public JsonReaderDelegator(XmlReader reader);
    public JsonReaderDelegator(XmlReader reader, DateTimeFormat dateTimeFormat);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    private DateTimeArrayJsonHelperWithString get_DateTimeArrayHelper();
    internal static XmlQualifiedName ParseQualifiedName(string qname);
    internal virtual char ReadContentAsChar();
    internal virtual XmlQualifiedName ReadContentAsQName();
    internal virtual char ReadElementContentAsChar();
    public virtual Byte[] ReadContentAsBase64();
    internal virtual Byte[] ReadElementContentAsBase64();
    internal virtual DateTime ReadContentAsDateTime();
    internal static DateTime ParseJsonDate(string originalDateTimeValue, DateTimeFormat dateTimeFormat);
    internal static DateTime ParseJsonDateInDefaultFormat(string originalDateTimeValue);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal virtual bool TryReadDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal bool TryReadJsonDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal virtual ulong ReadContentAsUnsignedLong();
    internal virtual ulong ReadElementContentAsUnsignedLong();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.Json.JsonReaderWriterFactory : object {
    private static string DefaultIndentChars;
    public static XmlDictionaryReader CreateJsonReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent, string indentChars);
}
internal class System.Runtime.Serialization.Json.JsonReadWriteDelegates : object {
    private static Dictionary`2<DataContract, JsonReadWriteDelegates> s_jsonDelegates;
    [CompilerGeneratedAttribute]
private JsonFormatClassWriterDelegate <ClassWriterDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonFormatClassReaderDelegate <ClassReaderDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonFormatCollectionWriterDelegate <CollectionWriterDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonFormatCollectionReaderDelegate <CollectionReaderDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonFormatGetOnlyCollectionReaderDelegate <GetOnlyCollectionReaderDelegate>k__BackingField;
    public JsonFormatClassWriterDelegate ClassWriterDelegate { get; public set; }
    public JsonFormatClassReaderDelegate ClassReaderDelegate { get; public set; }
    public JsonFormatCollectionWriterDelegate CollectionWriterDelegate { get; public set; }
    public JsonFormatCollectionReaderDelegate CollectionReaderDelegate { get; public set; }
    public JsonFormatGetOnlyCollectionReaderDelegate GetOnlyCollectionReaderDelegate { get; public set; }
    private static JsonReadWriteDelegates();
    public static Dictionary`2<DataContract, JsonReadWriteDelegates> GetJsonDelegates();
    [CompilerGeneratedAttribute]
public JsonFormatClassWriterDelegate get_ClassWriterDelegate();
    [CompilerGeneratedAttribute]
public void set_ClassWriterDelegate(JsonFormatClassWriterDelegate value);
    [CompilerGeneratedAttribute]
public JsonFormatClassReaderDelegate get_ClassReaderDelegate();
    [CompilerGeneratedAttribute]
public void set_ClassReaderDelegate(JsonFormatClassReaderDelegate value);
    [CompilerGeneratedAttribute]
public JsonFormatCollectionWriterDelegate get_CollectionWriterDelegate();
    [CompilerGeneratedAttribute]
public void set_CollectionWriterDelegate(JsonFormatCollectionWriterDelegate value);
    [CompilerGeneratedAttribute]
public JsonFormatCollectionReaderDelegate get_CollectionReaderDelegate();
    [CompilerGeneratedAttribute]
public void set_CollectionReaderDelegate(JsonFormatCollectionReaderDelegate value);
    [CompilerGeneratedAttribute]
public JsonFormatGetOnlyCollectionReaderDelegate get_GetOnlyCollectionReaderDelegate();
    [CompilerGeneratedAttribute]
public void set_GetOnlyCollectionReaderDelegate(JsonFormatGetOnlyCollectionReaderDelegate value);
}
internal class System.Runtime.Serialization.Json.JsonStringDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonStringDataContract(StringDataContract traditionalStringDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonUriDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonUriDataContract(UriDataContract traditionalUriDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonWriterDelegator : XmlWriterDelegator {
    private DateTimeFormat _dateTimeFormat;
    public JsonWriterDelegator(XmlWriter writer);
    public JsonWriterDelegator(XmlWriter writer, DateTimeFormat dateTimeFormat);
    internal virtual void WriteChar(char value);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal virtual void WriteUnsignedLong(ulong value);
    internal virtual void WriteDecimal(decimal value);
    internal virtual void WriteDouble(double value);
    internal virtual void WriteFloat(float value);
    internal virtual void WriteLong(long value);
    internal virtual void WriteSignedByte(sbyte value);
    internal virtual void WriteUnsignedInt(UInt32 value);
    internal virtual void WriteUnsignedShort(ushort value);
    internal virtual void WriteUnsignedByte(byte value);
    internal virtual void WriteShort(short value);
    internal virtual void WriteBoolean(bool value);
    internal virtual void WriteInt(int value);
    internal void WriteJsonBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteDateTime(DateTime value);
    private void WriteDateTimeInDefaultFormat(DateTime value);
    internal void WriteJsonSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
}
internal class System.Runtime.Serialization.Json.JsonXmlDataContract : JsonDataContract {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public JsonXmlDataContract(XmlDataContract traditionalXmlDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    private static List`1<Type> GetKnownTypesFromContext(XmlObjectSerializerContext context, IList`1<Type> serializerKnownTypeList);
}
internal class System.Runtime.Serialization.Json.ReflectionJsonClassReader : object {
    private ClassDataContract _classContract;
    private ReflectionReader _reflectionReader;
    public ReflectionJsonClassReader(ClassDataContract classDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadClass(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString _, XmlDictionaryString[] memberNames);
}
internal class System.Runtime.Serialization.Json.ReflectionJsonClassWriter : ReflectionClassWriter {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual int ReflectionWriteMembers(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract, ClassDataContract derivedMostClassContract, int childElementIndex, XmlDictionaryString[] memberNames);
    public static void ReflectionWriteStartElement(XmlWriterDelegator xmlWriter, XmlDictionaryString name);
    public static void ReflectionWriteStartElement(XmlWriterDelegator xmlWriter, string name);
    public static void ReflectionWriteEndElement(XmlWriterDelegator xmlWriter);
}
internal class System.Runtime.Serialization.Json.ReflectionJsonCollectionReader : object {
    private ReflectionReader _reflectionReader;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionReadGetOnlyCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.ReflectionJsonFormatWriter : object {
    private ReflectionJsonClassWriter _reflectionClassWriter;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionWriteClass(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract classContract, XmlDictionaryString[] memberNames);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static void ReflectionWriteCollection(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract collectionContract);
    private static void ReflectionWriteObjectAttribute(XmlWriterDelegator xmlWriter);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool ReflectionTryWritePrimitiveArray(JsonWriterDelegator jsonWriter, object obj, Type itemType, XmlDictionaryString collectionItemName);
    private static void ReflectionWriteArrayAttribute(XmlWriterDelegator xmlWriter);
}
internal class System.Runtime.Serialization.Json.ReflectionJsonReader : ReflectionReader {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void ReflectionReadMembers(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, ClassDataContract classContract, Object& obj);
    protected virtual string GetClassContractNamespace(ClassDataContract classContract);
    protected virtual string GetCollectionContractItemName(CollectionDataContract collectionContract);
    protected virtual string GetCollectionContractNamespace(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual object ReflectionReadDictionaryItem(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual bool ReflectionReadSpecialCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract, object resultCollection);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ReadSimpleDictionary(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract, Type keyValueType, object dictionary);
}
internal class System.Runtime.Serialization.Json.XmlJsonReader : XmlBaseReader {
    private static int MaxTextChunk;
    private bool _buffered;
    private Byte[] _charactersToSkipOnNextRead;
    private JsonComplexTextMode _complexTextMode;
    private bool _expectingFirstElementInNonPrimitiveChild;
    private int _maxBytesPerRead;
    private OnXmlDictionaryReaderClose _onReaderClose;
    private bool _readServerTypeElement;
    private int _scopeDepth;
    private JsonNodeType[] _scopes;
    private static ReadOnlySpan`1<byte> CharTypes { get; }
    public bool CanCanonicalize { get; }
    public string Value { get; }
    private bool IsAttributeValue { get; }
    private bool IsReadingCollection { get; }
    private bool IsReadingComplexText { get; }
    private static ReadOnlySpan`1<byte> get_CharTypes();
    public virtual bool get_CanCanonicalize();
    public virtual string get_Value();
    private bool get_IsAttributeValue();
    private bool get_IsReadingCollection();
    private bool get_IsReadingComplexText();
    public virtual void Close();
    public virtual void EndCanonicalization();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool Read();
    public virtual decimal ReadContentAsDecimal();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    internal static void CheckArray(Array array, int offset, int count);
    private static int BreakText(Byte[] buffer, int offset, int length);
    private static int ComputeNumericalTextLength(Byte[] buffer, int offset, int offsetMax);
    private static int ComputeQuotedTextLengthUntilEndQuote(Byte[] buffer, int offset, int offsetMax, Boolean& escaped);
    private static bool IsWhitespace(byte ch);
    private static char ParseChar(ReadOnlySpan`1<char> value, NumberStyles style);
    private static int ParseInt(ReadOnlySpan`1<char> value, NumberStyles style);
    private void BufferElement();
    private void EnterJsonScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitJsonScope();
    private void MoveToEndElement();
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void ParseAndSetLocalName();
    private void ParseStartElement();
    private void ReadAttributes();
    private void ReadEscapedCharacter(bool moveToText);
    private void ReadNonExistentElementName(StringHandleConstStringType elementName);
    private int ReadNonFFFE();
    private void ReadNumericalText();
    private void ReadQuotedText(bool moveToText);
    private void ReadServerTypeAttribute(bool consumedObjectChar);
    private void ResetState();
    private void SetJsonNameWithMapping(XmlElementNode elementNode);
    private void SkipExpectedByteInBufferReader(byte characterToSkip);
    private void SkipWhitespaceInBufferReader();
    private bool TryGetByte(Byte& ch);
    private string UnescapeJsonString(string val);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal class System.Runtime.Serialization.Json.XmlJsonWriter : XmlDictionaryWriter {
    private static char BACK_SLASH;
    private static char FORWARD_SLASH;
    private static char HIGH_SURROGATE_START;
    private static char LOW_SURROGATE_END;
    private static char MAX_CHAR;
    private static char WHITESPACE;
    private static char CARRIAGE_RETURN;
    private static char NEWLINE;
    private static string xmlNamespace;
    private static string xmlnsNamespace;
    private static String[] s_escapedJsonStringTable;
    private string _attributeText;
    private JsonDataType _dataType;
    private int _depth;
    private bool _endElementBuffer;
    private bool _isWritingDataTypeAttribute;
    private bool _isWritingServerTypeAttribute;
    private bool _isWritingXmlnsAttribute;
    private bool _isWritingXmlnsAttributeDefaultNs;
    private NameState _nameState;
    private JsonNodeType _nodeType;
    private JsonNodeWriter _nodeWriter;
    private JsonNodeType[] _scopes;
    private string _serverTypeValue;
    private WriteState _writeState;
    private bool _wroteServerTypeAttribute;
    private bool _indent;
    private string _indentChars;
    private int _indentLevel;
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    private bool HasOpenAttribute { get; }
    private bool IsClosed { get; }
    private bool IsWritingCollection { get; }
    private bool IsWritingNameAttribute { get; }
    private bool IsWritingNameWithMapping { get; }
    private bool WrittenNameWithMapping { get; }
    public XmlJsonWriter(bool indent, string indentChars);
    private static XmlJsonWriter();
    public virtual XmlWriterSettings get_Settings();
    public virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    private bool get_HasOpenAttribute();
    private bool get_IsClosed();
    private bool get_IsWritingCollection();
    private bool get_IsWritingNameAttribute();
    private bool get_IsWritingNameWithMapping();
    private bool get_WrittenNameWithMapping();
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(object value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    internal static bool CharacterNeedsEscaping(char ch);
    private static void ThrowClosed();
    private void CheckText(JsonNodeType nextNodeType);
    private void EnterScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitScope();
    private void InitializeWriter();
    private static bool IsUnicodeNewlineCharacter(char c);
    private void StartText();
    private void ThrowIfServerTypeWritten(string dataTypeSpecified);
    private void ThrowInvalidAttributeContent();
    private bool TrySetWritingNameWithMapping(string localName, string ns);
    private void WriteDataTypeServerType();
    private void WriteEscapedJsonString(string str);
    private void WriteIndent();
    private void WriteNewLine();
    private void WriteJsonElementName(string localName);
    private void WriteJsonQuote();
    private void WritePrimitiveValue(object value);
    private void WriteServerTypeAttribute();
    private void WriteValue(ulong value);
    private void WriteValue(Array array);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson : XmlObjectSerializerReadContextComplex {
    private string _extensionDataValueType;
    private DateTimeFormat _dateTimeFormat;
    private bool _useSimpleDictionaryFormat;
    internal IList`1<Type> SerializerKnownTypeList { get; }
    public bool UseSimpleDictionaryFormat { get; }
    internal XmlObjectSerializerReadContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal static XmlObjectSerializerReadContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public int GetJsonMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, int memberIndex, ExtensionDataObject extensionData);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private static IDataNode ReadNumericalPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader);
    internal virtual int GetArraySize();
    internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    internal static string TrimNamespace(string serverTypeNamespace);
    internal static XmlQualifiedName ParseQualifiedName(string qname);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal static bool TryGetJsonLocalName(XmlReaderDelegator xmlReader, String& name);
    public static string GetJsonMemberName(XmlReaderDelegator xmlReader);
    public static void ThrowDuplicateMemberException(object obj, XmlDictionaryString[] memberNames, int memberIndex);
    public static void ThrowMissingRequiredMembers(object obj, XmlDictionaryString[] memberNames, Byte[] expectedElements, Byte[] requiredElements);
    private static bool IsBitSet(Byte[] bytes, int bitIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerWriteContextComplexJson : XmlObjectSerializerWriteContextComplex {
    private EmitTypeInformation _emitXsiType;
    private bool _perCallXsiTypeAlreadyEmitted;
    private bool _useSimpleDictionaryFormat;
    internal IList`1<Type> SerializerKnownTypeList { get; }
    public bool UseSimpleDictionaryFormat { get; }
    internal static XmlDictionaryString CollectionItemName { get; }
    internal XmlObjectSerializerWriteContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal static XmlObjectSerializerWriteContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    internal static string TruncateDefaultDataContractNamespace(string dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    private static bool RequiresJsonTypeInfo(DataContract contract);
    private static void WriteTypeInfo(XmlWriterDelegator writer, string typeInformation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    internal static XmlDictionaryString get_CollectionItemName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void HandleCollectionAssignedToObject(Type declaredType, DataContract& dataContract, Object& obj, Boolean& verifyKnownType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void VerifyType(DataContract dataContract, Type declaredType);
    internal static void WriteJsonNameWithMapping(XmlWriterDelegator xmlWriter, XmlDictionaryString[] memberNames, int index);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    internal static void VerifyObjectCompatibilityWithInterface(DataContract contract, object graph, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteJsonISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract GetRevisedItemContract(DataContract oldItemContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static DataContract ResolveJsonDataContractFromRootDataContract(XmlObjectSerializerContext context, XmlQualifiedName typeQName, DataContract rootTypeDataContract);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.JsonFormatGeneratorStatics : object {
    private static MethodInfo s_boxPointer;
    private static PropertyInfo s_collectionItemNameProperty;
    private static ConstructorInfo s_extensionDataObjectCtor;
    private static PropertyInfo s_extensionDataProperty;
    private static MethodInfo s_getItemContractMethod;
    private static MethodInfo s_getJsonDataContractMethod;
    private static MethodInfo s_getJsonMemberIndexMethod;
    private static MethodInfo s_getRevisedItemContractMethod;
    private static MethodInfo s_getUninitializedObjectMethod;
    private static MethodInfo s_ienumeratorGetCurrentMethod;
    private static MethodInfo s_ienumeratorMoveNextMethod;
    private static MethodInfo s_isStartElementMethod0;
    private static MethodInfo s_isStartElementMethod2;
    private static PropertyInfo s_localNameProperty;
    private static PropertyInfo s_namespaceProperty;
    private static MethodInfo s_moveToContentMethod;
    private static PropertyInfo s_nodeTypeProperty;
    private static MethodInfo s_onDeserializationMethod;
    private static MethodInfo s_readJsonValueMethod;
    private static ConstructorInfo s_serializationExceptionCtor;
    private static Type[] s_serInfoCtorArgs;
    private static MethodInfo s_throwDuplicateMemberExceptionMethod;
    private static MethodInfo s_throwMissingRequiredMembersMethod;
    private static PropertyInfo s_typeHandleProperty;
    private static MethodInfo s_unboxPointer;
    private static PropertyInfo s_useSimpleDictionaryFormatReadProperty;
    private static PropertyInfo s_useSimpleDictionaryFormatWriteProperty;
    private static MethodInfo s_writeAttributeStringMethod;
    private static MethodInfo s_writeEndElementMethod;
    private static MethodInfo s_writeJsonISerializableMethod;
    private static MethodInfo s_writeJsonNameWithMappingMethod;
    private static MethodInfo s_writeJsonValueMethod;
    private static MethodInfo s_writeStartElementMethod;
    private static MethodInfo s_writeStartElementStringMethod;
    private static MethodInfo s_parseEnumMethod;
    private static MethodInfo s_getJsonMemberNameMethod;
    public static MethodInfo BoxPointer { get; }
    public static PropertyInfo CollectionItemNameProperty { get; }
    public static ConstructorInfo ExtensionDataObjectCtor { get; }
    public static PropertyInfo ExtensionDataProperty { get; }
    public static MethodInfo GetCurrentMethod { get; }
    public static MethodInfo GetItemContractMethod { get; }
    public static MethodInfo GetJsonDataContractMethod { get; }
    public static MethodInfo GetJsonMemberIndexMethod { get; }
    public static MethodInfo GetRevisedItemContractMethod { get; }
    public static MethodInfo GetUninitializedObjectMethod { get; }
    public static MethodInfo IsStartElementMethod0 { get; }
    public static MethodInfo IsStartElementMethod2 { get; }
    public static PropertyInfo LocalNameProperty { get; }
    public static PropertyInfo NamespaceProperty { get; }
    public static MethodInfo MoveNextMethod { get; }
    public static MethodInfo MoveToContentMethod { get; }
    public static PropertyInfo NodeTypeProperty { get; }
    public static MethodInfo OnDeserializationMethod { get; }
    public static MethodInfo ReadJsonValueMethod { get; }
    public static ConstructorInfo SerializationExceptionCtor { get; }
    public static Type[] SerInfoCtorArgs { get; }
    public static MethodInfo ThrowDuplicateMemberExceptionMethod { get; }
    public static MethodInfo ThrowMissingRequiredMembersMethod { get; }
    public static PropertyInfo TypeHandleProperty { get; }
    public static MethodInfo UnboxPointer { get; }
    public static PropertyInfo UseSimpleDictionaryFormatReadProperty { get; }
    public static PropertyInfo UseSimpleDictionaryFormatWriteProperty { get; }
    public static MethodInfo WriteAttributeStringMethod { get; }
    public static MethodInfo WriteEndElementMethod { get; }
    public static MethodInfo WriteJsonISerializableMethod { get; }
    public static MethodInfo WriteJsonNameWithMappingMethod { get; }
    public static MethodInfo WriteJsonValueMethod { get; }
    public static MethodInfo WriteStartElementMethod { get; }
    public static MethodInfo WriteStartElementStringMethod { get; }
    public static MethodInfo ParseEnumMethod { get; }
    public static MethodInfo GetJsonMemberNameMethod { get; }
    public static MethodInfo get_BoxPointer();
    public static PropertyInfo get_CollectionItemNameProperty();
    public static ConstructorInfo get_ExtensionDataObjectCtor();
    public static PropertyInfo get_ExtensionDataProperty();
    public static MethodInfo get_GetCurrentMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_GetItemContractMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_GetJsonDataContractMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_GetJsonMemberIndexMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_GetRevisedItemContractMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_GetUninitializedObjectMethod();
    public static MethodInfo get_IsStartElementMethod0();
    public static MethodInfo get_IsStartElementMethod2();
    public static PropertyInfo get_LocalNameProperty();
    public static PropertyInfo get_NamespaceProperty();
    public static MethodInfo get_MoveNextMethod();
    public static MethodInfo get_MoveToContentMethod();
    public static PropertyInfo get_NodeTypeProperty();
    public static MethodInfo get_OnDeserializationMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_ReadJsonValueMethod();
    public static ConstructorInfo get_SerializationExceptionCtor();
    public static Type[] get_SerInfoCtorArgs();
    public static MethodInfo get_ThrowDuplicateMemberExceptionMethod();
    public static MethodInfo get_ThrowMissingRequiredMembersMethod();
    public static PropertyInfo get_TypeHandleProperty();
    public static MethodInfo get_UnboxPointer();
    public static PropertyInfo get_UseSimpleDictionaryFormatReadProperty();
    public static PropertyInfo get_UseSimpleDictionaryFormatWriteProperty();
    public static MethodInfo get_WriteAttributeStringMethod();
    public static MethodInfo get_WriteEndElementMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_WriteJsonISerializableMethod();
    public static MethodInfo get_WriteJsonNameWithMappingMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static MethodInfo get_WriteJsonValueMethod();
    public static MethodInfo get_WriteStartElementMethod();
    public static MethodInfo get_WriteStartElementStringMethod();
    public static MethodInfo get_ParseEnumMethod();
    public static MethodInfo get_GetJsonMemberNameMethod();
}
[DataContractAttribute]
internal class System.Runtime.Serialization.KeyValue`2 : ValueType {
    [CompilerGeneratedAttribute]
private K <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private V <Value>k__BackingField;
    [DataMemberAttribute]
public K Key { get; public set; }
    [DataMemberAttribute]
public V Value { get; public set; }
    private object System.Runtime.Serialization.IKeyValue.Key { get; private set; }
    private object System.Runtime.Serialization.IKeyValue.Value { get; private set; }
    internal KeyValue`2(K key, V value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public K get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(K value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public V get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(V value);
    private sealed virtual override object System.Runtime.Serialization.IKeyValue.get_Key();
    private sealed virtual override void System.Runtime.Serialization.IKeyValue.set_Key(object value);
    private sealed virtual override object System.Runtime.Serialization.IKeyValue.get_Value();
    private sealed virtual override void System.Runtime.Serialization.IKeyValue.set_Value(object value);
}
internal class System.Runtime.Serialization.KnownTypeDataContractResolver : DataContractResolver {
    private XmlObjectSerializerContext _context;
    internal KnownTypeDataContractResolver(XmlObjectSerializerContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
[DataContractAttribute]
internal abstract class System.Runtime.Serialization.MarshalByRefObjectAdapter : object {
    [DataMemberAttribute]
public object Identity { get; public set; }
    public object get_Identity();
    public void set_Identity(object value);
}
[DataContractAttribute]
internal class System.Runtime.Serialization.MemoryStreamAdapter : MarshalByRefObjectAdapter {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expandable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exposable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [DataMemberAttribute]
public Byte[] Buffer { get; public set; }
    [DataMemberAttribute]
public int Capacity { get; public set; }
    [DataMemberAttribute]
public bool Expandable { get; public set; }
    [DataMemberAttribute]
public bool Exposable { get; public set; }
    [DataMemberAttribute]
public bool IsOpen { get; public set; }
    [DataMemberAttribute]
public int Length { get; public set; }
    [DataMemberAttribute]
public int Origin { get; public set; }
    [DataMemberAttribute]
public int Position { get; public set; }
    [DataMemberAttribute]
public bool Writable { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    [CompilerGeneratedAttribute]
public void set_Capacity(int value);
    [CompilerGeneratedAttribute]
public bool get_Expandable();
    [CompilerGeneratedAttribute]
public void set_Expandable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exposable();
    [CompilerGeneratedAttribute]
public void set_Exposable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public void set_IsOpen(bool value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(int value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    public static MemoryStream GetMemoryStream(MemoryStreamAdapter value);
    public static MemoryStreamAdapter GetMemoryStreamAdapter(MemoryStream memoryStream);
}
internal class System.Runtime.Serialization.ObjectReferenceStack : ValueType {
    private static int MaximumArraySize;
    private static int InitialArraySize;
    private int _count;
    private Object[] _objectArray;
    private Boolean[] _isReferenceArray;
    private Dictionary`2<object, object> _objectDictionary;
    internal void Push(object obj);
    internal void EnsureSetAsIsReference(object obj);
    internal void Pop(object obj);
    internal bool Contains(object obj);
}
internal class System.Runtime.Serialization.ObjectToIdCache : object {
    internal int m_currentCount;
    internal Int32[] m_ids;
    internal Object[] m_objs;
    internal Boolean[] m_isWrapped;
    public int GetId(object obj, Boolean& newId);
    public int ReassignId(int oldObjId, object oldObj, object newObj);
    private int FindElement(object obj, Boolean& isEmpty, Boolean& isWrapped);
    private void RemoveAt(int position);
    private int ComputeStartPosition(object o);
    private void Rehash();
    private static int GetPrime(int min);
}
internal abstract class System.Runtime.Serialization.ReflectionClassWriter : object {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionWriteClass(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract, XmlDictionaryString[] memberNames);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static void ReflectionWriteValue(XmlWriterDelegator xmlWriter, XmlObjectSerializerWriteContext context, Type type, object value, bool writeXsiType, PrimitiveDataContract primitiveContractForParamType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected abstract virtual int ReflectionWriteMembers(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract, ClassDataContract derivedMostClassContract, int childElementIndex, XmlDictionaryString[] memberNames);
    protected static object ReflectionGetMemberValue(object obj, DataMember dataMember);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected static bool ReflectionTryWritePrimitive(XmlWriterDelegator xmlWriter, XmlObjectSerializerWriteContext context, object value, XmlDictionaryString name, XmlDictionaryString ns, PrimitiveDataContract primitiveContract);
    private static void InvokeOnSerializing(object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract);
    private static void InvokeOnSerialized(object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract);
    private static object ResolveAdapterType(object obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static void ReflectionInternalSerialize(XmlWriterDelegator xmlWriter, XmlObjectSerializerWriteContext context, object obj, bool isDeclaredType, bool writeXsiType, Type memberType, bool isNullableOfT);
}
internal abstract class System.Runtime.Serialization.ReflectionReader : object {
    private static MethodInfo s_getCollectionSetItemDelegateMethod;
    private static MethodInfo s_objectToKeyValuePairGetKey;
    private static MethodInfo s_objectToKeyValuePairGetValue;
    private static Type[] s_arrayConstructorParameters;
    private static Object[] s_arrayConstructorArguments;
    private static MethodInfo CollectionSetItemDelegateMethod { get; }
    private static ReflectionReader();
    private static MethodInfo get_CollectionSetItemDelegateMethod();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadClass(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionReadGetOnlyCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString collectionItemName, XmlDictionaryString collectionItemNamespace, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString collectionItemName, XmlDictionaryString collectionItemNamespace, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ReflectionReadCollectionCore(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString collectionItemName, XmlDictionaryString collectionItemNamespace, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionReadItemDelegate GetCollectionReadItemDelegate(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ReadCollectionItems(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString collectionItemName, XmlDictionaryString collectionItemNamespace, CollectionDataContract collectionContract, object resultCollection, bool isReadOnlyCollection);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected abstract virtual void ReflectionReadMembers(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, ClassDataContract classContract, Object& obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected abstract virtual object ReflectionReadDictionaryItem(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract);
    protected abstract virtual string GetCollectionContractItemName(CollectionDataContract collectionContract);
    protected abstract virtual string GetCollectionContractNamespace(CollectionDataContract collectionContract);
    protected abstract virtual string GetClassContractNamespace(ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual bool ReflectionReadSpecialCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract, object resultCollection);
    protected static int ReflectionGetMembers(ClassDataContract classContract, DataMember[] members);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected void ReflectionReadMember(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, ClassDataContract classContract, Object& obj, int memberIndex, DataMember[] members);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected object ReflectionReadValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, Type type, string name, string ns, PrimitiveDataContract primitiveContractForOriginalType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ReadItemOfPrimitiveType(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, Type type, string name, string ns, PrimitiveDataContract primitiveContract, int nullables);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
private static object ReadISerializable(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionReadItemDelegate GetReflectionReadValueDelegate(Type type);
    private static object ReflectionGetMemberValue(object obj, DataMember dataMember);
    private static void ReflectionSetMemberValue(Object& obj, object memberValue, DataMember dataMember);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ReflectionReadValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, DataMember dataMember, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ReflectionInternalDeserialize(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract, Type type, string name, string ns);
    private static void InvokeOnDeserializing(XmlObjectSerializerReadContext context, ClassDataContract classContract, object obj);
    private static void InvokeOnDeserialized(XmlObjectSerializerReadContext context, ClassDataContract classContract, object obj);
    private static void InvokeDeserializationCallback(object obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
private static object CreateObject(ClassDataContract classContract);
    private static object ResolveAdapterObject(object obj);
    private static bool IsArrayLikeInterface(CollectionDataContract collectionContract);
    private static bool IsArrayLikeCollection(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static object ReflectionCreateCollection(CollectionDataContract collectionContract);
    private static object ObjectToKeyValuePairGetKey(object o);
    private static object ObjectToKeyValuePairGetValue(object o);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
private static CollectionSetItemDelegate GetCollectionSetItemDelegate(CollectionDataContract collectionContract, object resultCollectionObject, bool isReadOnlyCollection);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool ReflectionTryReadPrimitiveArray(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString collectionItemName, XmlDictionaryString collectionItemNamespace, Type itemType, int arraySize, Object& resultArray);
    [CompilerGeneratedAttribute]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object <GetCollectionReadItemDelegate>g__GetReadDictionaryItemDelegate|13_0(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract, Type itemType, string itemName, string itemNs);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
internal static MethodInfo <GetCollectionSetItemDelegate>g__MakeGenericMethod|41_1(MethodInfo method, Type keyType, Type valueType);
}
internal class System.Runtime.Serialization.ReflectionXmlClassReader : object {
    private ClassDataContract _classContract;
    private ReflectionReader _reflectionReader;
    public ReflectionXmlClassReader(ClassDataContract classDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadClass(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
}
internal class System.Runtime.Serialization.ReflectionXmlClassWriter : ReflectionClassWriter {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual int ReflectionWriteMembers(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract, ClassDataContract derivedMostClassContract, int childElementIndex, XmlDictionaryString[] emptyStringArray);
    public static void ReflectionWriteStartElement(XmlWriterDelegator xmlWriter, Type type, XmlDictionaryString ns, string namespaceLocal, string nameLocal);
    public static void ReflectionWriteEndElement(XmlWriterDelegator xmlWriter);
    private static bool NeedsPrefix(Type type, XmlDictionaryString ns);
    private static bool CheckIfMemberHasConflict(DataMember member, ClassDataContract classContract, ClassDataContract derivedMostClassContract);
    private static bool CheckIfConflictingMembersHaveDifferentTypes(DataMember member);
}
internal class System.Runtime.Serialization.ReflectionXmlCollectionReader : object {
    private ReflectionReader _reflectionReader;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReflectionReadCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionReadGetOnlyCollection(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNs, CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.ReflectionXmlFormatWriter : object {
    private ReflectionXmlClassWriter _reflectionClassWriter;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ReflectionWriteClass(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static void ReflectionWriteCollection(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract collectionDataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool ReflectionTryWritePrimitiveArray(XmlWriterDelegator xmlWriter, object obj, Type itemType, XmlDictionaryString collectionItemName, XmlDictionaryString itemNamespace);
}
internal class System.Runtime.Serialization.ReflectionXmlReader : ReflectionReader {
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void ReflectionReadMembers(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, ClassDataContract classContract, Object& obj);
    protected virtual string GetClassContractNamespace(ClassDataContract classContract);
    protected virtual string GetCollectionContractItemName(CollectionDataContract collectionContract);
    protected virtual string GetCollectionContractNamespace(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual object ReflectionReadDictionaryItem(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, CollectionDataContract collectionContract);
    private static Boolean[] GetRequiredMembers(ClassDataContract contract, Int32& firstRequiredMember);
    private static int GetRequiredMembers(ClassDataContract contract, Boolean[] requiredMembers);
}
internal enum System.Runtime.Serialization.SchemaDefinedEnum : Enum {
    public int value__;
    public static SchemaDefinedEnum SchemaDefinedEnumValue;
}
internal class System.Runtime.Serialization.SchemaDefinedType : object {
    internal XmlQualifiedName _xmlName;
    public SchemaDefinedType(XmlQualifiedName xmlName);
}
internal class System.Runtime.Serialization.SchemaExporter : object {
    private XmlSchemaSet _schemas;
    private XmlDocument _xmlDoc;
    private DataContractSet _dataContractSet;
    private static XmlQualifiedName s_anytypeQualifiedName;
    private static XmlQualifiedName s_stringQualifiedName;
    private static XmlQualifiedName s_defaultEnumBaseTypeName;
    private static XmlQualifiedName s_enumerationValueAnnotationName;
    private static XmlQualifiedName s_surrogateDataAnnotationName;
    private static XmlQualifiedName s_defaultValueAnnotation;
    private static XmlQualifiedName s_actualTypeAnnotationName;
    private static XmlQualifiedName s_isDictionaryAnnotationName;
    private static XmlQualifiedName s_isValueTypeName;
    private XmlSchemaSet Schemas { get; }
    private XmlDocument XmlDoc { get; }
    internal static XmlSchemaSequence ISerializableSequence { get; }
    internal static XmlSchemaAny ISerializableWildcardElement { get; }
    internal static XmlQualifiedName AnytypeQualifiedName { get; }
    internal static XmlQualifiedName StringQualifiedName { get; }
    internal static XmlQualifiedName DefaultEnumBaseTypeName { get; }
    internal static XmlQualifiedName EnumerationValueAnnotationName { get; }
    internal static XmlQualifiedName SurrogateDataAnnotationName { get; }
    internal static XmlQualifiedName DefaultValueAnnotation { get; }
    internal static XmlQualifiedName ActualTypeAnnotationName { get; }
    internal static XmlQualifiedName IsDictionaryAnnotationName { get; }
    internal static XmlQualifiedName IsValueTypeName { get; }
    internal static XmlSchemaAttribute ISerializableFactoryTypeAttribute { get; }
    internal static XmlSchemaAttribute RefAttribute { get; }
    internal static XmlSchemaAttribute IdAttribute { get; }
    internal SchemaExporter(XmlSchemaSet schemas, DataContractSet dataContractSet);
    private XmlSchemaSet get_Schemas();
    private XmlDocument get_XmlDoc();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void Export();
    private void ExportSerializationSchema();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportDataContract(DataContract dataContract);
    private XmlSchemaElement ExportTopLevelElement(DataContract dataContract, XmlSchema schema);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportClassDataContract(ClassDataContract classDataContract, XmlSchema schema);
    private static void AddReferenceAttributes(XmlSchemaObjectCollection attributes, XmlSchema schema);
    private static void SetElementType(XmlSchemaElement element, DataContract dataContract, XmlSchema schema);
    private static bool CheckIfMemberHasConflict(DataMember dataMember);
    private XmlElement ExportEmitDefaultValue(DataMember dataMember);
    private XmlElement ExportActualType(XmlQualifiedName typeName);
    private static XmlElement ExportActualType(XmlQualifiedName typeName, XmlDocument xmlDoc);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlElement ExportGenericInfo(Type clrType, string elementName, string elementNs);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlElement ExportSurrogateData(object key);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportCollectionDataContract(CollectionDataContract collectionDataContract, XmlSchema schema);
    private XmlElement ExportIsDictionary();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportEnumDataContract(EnumDataContract enumDataContract, XmlSchema schema);
    internal static long GetDefaultEnumValue(bool isFlags, int index);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportISerializableDataContract(ClassDataContract dataContract, XmlSchema schema);
    private static XmlSchemaComplexContentExtension CreateTypeContent(XmlSchemaComplexType type, XmlQualifiedName baseTypeName, XmlSchema schema);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ExportXmlDataContract(XmlDataContract dataContract);
    private static void ReprocessAll(XmlSchemaSet schemas);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static void GetXmlTypeInfo(Type type, XmlQualifiedName& xmlName, XmlSchemaType& xsdType, Boolean& hasRoot);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static bool InvokeSchemaProviderMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName& xmlName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void InvokeGetSchemaMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName xmlName);
    internal static void AddDefaultXmlType(XmlSchemaSet schemas, string localName, string ns);
    private static XmlSchemaComplexType CreateAnyType();
    private static XmlSchemaComplexType CreateAnyElementType();
    internal static bool IsSpecialXmlType(Type type, XmlQualifiedName& typeName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void AddDefaultDatasetType(XmlSchemaSet schemas, string localName, string ns);
    private static void AddDefaultTypedDatasetType(XmlSchemaSet schemas, XmlSchema datasetSchema, string localName, string ns);
    private XmlSchemaAnnotation GetSchemaAnnotation(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private static XmlSchemaAnnotation GetSchemaAnnotation(XmlNode[] nodes);
    private XmlElement GetAnnotationMarkup(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private XmlSchema GetSchema(string ns);
    internal static XmlSchemaSequence get_ISerializableSequence();
    internal static XmlSchemaAny get_ISerializableWildcardElement();
    internal static XmlQualifiedName get_AnytypeQualifiedName();
    internal static XmlQualifiedName get_StringQualifiedName();
    internal static XmlQualifiedName get_DefaultEnumBaseTypeName();
    internal static XmlQualifiedName get_EnumerationValueAnnotationName();
    internal static XmlQualifiedName get_SurrogateDataAnnotationName();
    internal static XmlQualifiedName get_DefaultValueAnnotation();
    internal static XmlQualifiedName get_ActualTypeAnnotationName();
    internal static XmlQualifiedName get_IsDictionaryAnnotationName();
    internal static XmlQualifiedName get_IsValueTypeName();
    internal static XmlSchemaAttribute get_ISerializableFactoryTypeAttribute();
    internal static XmlSchemaAttribute get_RefAttribute();
    internal static XmlSchemaAttribute get_IdAttribute();
}
internal static class System.Runtime.Serialization.SchemaHelper : object {
    internal static bool NamespacesEqual(string ns1, string ns2);
    internal static XmlSchemaType GetSchemaType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName typeName);
    internal static XmlSchemaType GetSchemaType(XmlSchemaSet schemas, XmlQualifiedName typeQName, XmlSchema& outSchema);
    internal static XmlSchemaElement GetSchemaElement(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName elementName);
    internal static XmlSchemaElement GetSchemaElement(XmlSchemaSet schemas, XmlQualifiedName elementQName, XmlSchema& outSchema);
    internal static XmlSchema GetSchema(string ns, XmlSchemaSet schemas);
    private static XmlSchema CreateSchema(string ns, XmlSchemaSet schemas);
    internal static void AddElementForm(XmlSchemaElement element, XmlSchema schema);
    internal static void AddSchemaImport(string ns, XmlSchema schema);
    internal static XmlSchema GetSchemaWithType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlSchemaSet schemas, XmlQualifiedName typeName);
    internal static XmlSchema GetSchemaWithGlobalElementDeclaration(XmlSchemaElement element, XmlSchemaSet schemas);
    internal static XmlQualifiedName GetGlobalElementDeclaration(XmlSchemaSet schemas, XmlQualifiedName typeQName, Boolean& isNullable);
}
internal class System.Runtime.Serialization.SchemaImporter : object {
    private DataContractSet _dataContractSet;
    private XmlSchemaSet _schemaSet;
    private IEnumerable`1<XmlQualifiedName> _typeNames;
    private IEnumerable`1<XmlSchemaElement> _elements;
    private bool _importXmlDataType;
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> _schemaObjects;
    private List`1<XmlSchemaRedefine> _redefineList;
    private bool _needToImportKnownTypesForObject;
    private static Hashtable s_serializationSchemaElements;
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> SchemaObjects { get; }
    private List`1<XmlSchemaRedefine> RedefineList { get; }
    internal SchemaImporter(XmlSchemaSet schemas, IEnumerable`1<XmlQualifiedName> typeNames, IEnumerable`1<XmlSchemaElement> elements, DataContractSet dataContractSet, bool importXmlDataType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void Import(List`1& elementTypeNames);
    internal static void CompileSchemaSet(XmlSchemaSet schemaSet);
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> get_SchemaObjects();
    private List`1<XmlSchemaRedefine> get_RedefineList();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ImportKnownTypes(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsObjectContract(DataContract dataContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ImportKnownTypesForObject();
    internal Dictionary`2<XmlQualifiedName, SchemaObjectInfo> CreateSchemaObjects();
    private static XmlQualifiedName GetBaseTypeName(XmlSchemaType type);
    private List`1<XmlSchemaRedefine> CreateRedefineList();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportAnonymousGlobalElement(XmlSchemaElement element, XmlQualifiedName typeQName, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportAnonymousElement(XmlSchemaElement element, XmlQualifiedName typeQName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportType(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportType(XmlSchemaType type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportType(XmlSchemaType type, XmlQualifiedName typeName, bool isAnonymous);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void RemoveFailedContract(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private bool CheckIfEnum(XmlSchemaSimpleTypeRestriction restriction);
    private static bool CheckIfCollection(XmlSchemaSequence rootSequence);
    private static bool CheckIfISerializable(XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    private static void RemoveOptionalUnknownSerializationElements(XmlSchemaObjectCollection items);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportType(XmlQualifiedName typeName, XmlSchemaParticle rootParticle, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ClassDataContract ImportClass(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation, bool isReference);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportXmlDataType(XmlQualifiedName typeName, XmlSchemaType xsdType, bool isAnonymous);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private XmlDataContract ImportSpecialXmlDataType(XmlSchemaType xsdType, bool isAnonymous);
    private static bool IsXmlAnyElementType(XmlSchemaComplexType xsdType);
    private static bool IsXmlAnyType(XmlSchemaComplexType xsdType);
    private static bool IsValueType(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ClassDataContract ImportISerializable(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaObjectCollection attributes, XmlSchemaAnnotation annotation);
    private static void CheckISerializableBase(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    private static bool IsISerializableDerived(XmlSchemaSequence rootSequence);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ImportBaseContract(XmlQualifiedName baseTypeName, ClassDataContract dataContract);
    private void ImportTopLevelElement(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ImportClassMember(XmlSchemaElement element, ClassDataContract dataContract);
    private static Nullable`1<bool> ImportEmitDefaultValue(XmlSchemaAnnotation annotation, XmlQualifiedName typeName);
    internal static XmlQualifiedName ImportActualType(XmlSchemaAnnotation annotation, XmlQualifiedName defaultTypeName, XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataContract ImportCollection(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaAnnotation annotation, bool isReference);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static GenericInfo GetGenericInfoForDataMember(DataMember dataMember);
    private static bool IsDictionary(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private EnumDataContract ImportFlagsEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeList list, XmlSchemaAnnotation annotation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private EnumDataContract ImportEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction, bool isFlags, XmlSchemaAnnotation annotation);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ImportSimpleTypeRestriction(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void ImportDataContractExtension(XmlSchemaType type, DataContract dataContract);
    private static void ImportGenericInfo(XmlSchemaType type, DataContract dataContract);
    private static GenericInfo ImportGenericInfo(XmlElement typeElement, XmlSchemaType type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object ImportSurrogateData(XmlElement typeElement, string name, string ns);
    private static void CheckComplexType(XmlQualifiedName typeName, XmlSchemaComplexType type);
    private static void CheckIfElementUsesUnsupportedConstructs(XmlQualifiedName typeName, XmlSchemaElement element);
    private static void ImportAttributes(XmlQualifiedName typeName, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, Boolean& isReference);
    private static bool TryCheckIfAttribute(XmlQualifiedName typeName, XmlSchemaAttribute attribute, XmlQualifiedName refName, Boolean& foundAttribute);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddDataContract(DataContract dataContract);
    private static string GetInnerText(XmlQualifiedName typeName, XmlElement xmlElement);
    private static XmlElement ImportAnnotation(XmlSchemaAnnotation annotation, XmlQualifiedName annotationQualifiedName);
    [DoesNotReturnAttribute]
private static void ThrowTypeCannotBeImportedException(string name, string ns, string message);
    [DoesNotReturnAttribute]
private static void ThrowArrayTypeCannotBeImportedException(string name, string ns, string message);
    [DoesNotReturnAttribute]
private static void ThrowEnumTypeCannotBeImportedException(string name, string ns, string message);
    [DoesNotReturnAttribute]
private static void ThrowISerializableTypeCannotBeImportedException(string name, string ns, string message);
    [DoesNotReturnAttribute]
private static void ThrowTypeCannotBeImportedException(string message);
}
internal class System.Runtime.Serialization.SchemaObjectInfo : object {
    internal XmlSchemaType _type;
    internal XmlSchemaElement _element;
    internal XmlSchema _schema;
    internal List`1<XmlSchemaType> _knownTypes;
    internal SchemaObjectInfo(XmlSchemaType type, XmlSchemaElement element, XmlSchema schema, List`1<XmlSchemaType> knownTypes);
}
internal class System.Runtime.Serialization.ScopedKnownTypes : ValueType {
    internal Dictionary`2[] dataContractDictionaries;
    private int _count;
    internal void Push(Dictionary`2<XmlQualifiedName, DataContract> dataContractDictionary);
    internal void Pop();
    internal DataContract GetDataContract(XmlQualifiedName qname);
}
internal enum System.Runtime.Serialization.SerializationOption : Enum {
    public int value__;
    public static SerializationOption CodeGenOnly;
    public static SerializationOption ReflectionOnly;
    public static SerializationOption ReflectionAsBackup;
}
internal class System.Runtime.Serialization.SwitchState : object {
    private Label _defaultLabel;
    private Label _endOfSwitchLabel;
    private bool _defaultDefined;
    internal Label DefaultLabel { get; }
    internal Label EndOfSwitchLabel { get; }
    internal bool DefaultDefined { get; internal set; }
    internal SwitchState(Label defaultLabel, Label endOfSwitchLabel);
    internal Label get_DefaultLabel();
    internal Label get_EndOfSwitchLabel();
    internal bool get_DefaultDefined();
    internal void set_DefaultDefined(bool value);
}
internal class System.Runtime.Serialization.XmlDataNode : DataNode`1<object> {
    private IList`1<XmlAttribute> _xmlAttributes;
    private IList`1<XmlNode> _xmlChildNodes;
    private XmlDocument _ownerDocument;
    internal IList`1<XmlAttribute> XmlAttributes { get; internal set; }
    internal IList`1<XmlNode> XmlChildNodes { get; internal set; }
    internal XmlDocument OwnerDocument { get; internal set; }
    internal IList`1<XmlAttribute> get_XmlAttributes();
    internal void set_XmlAttributes(IList`1<XmlAttribute> value);
    internal IList`1<XmlNode> get_XmlChildNodes();
    internal void set_XmlChildNodes(IList`1<XmlNode> value);
    internal XmlDocument get_OwnerDocument();
    internal void set_OwnerDocument(XmlDocument value);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.XmlFormatClassReaderDelegate : MulticastDelegate {
    public XmlFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatClassWriterDelegate : MulticastDelegate {
    public XmlFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionWriterDelegate : MulticastDelegate {
    public XmlFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Runtime.Serialization.XmlFormatGeneratorStatics : object {
    private static MethodInfo s_writeStartElementMethod2;
    private static MethodInfo s_writeStartElementMethod3;
    private static MethodInfo s_writeEndElementMethod;
    private static MethodInfo s_writeNamespaceDeclMethod;
    private static PropertyInfo s_extensionDataProperty;
    private static MethodInfo s_boxPointer;
    private static ConstructorInfo s_dictionaryEnumeratorCtor;
    private static MethodInfo s_ienumeratorMoveNextMethod;
    private static MethodInfo s_ienumeratorGetCurrentMethod;
    private static MethodInfo s_getItemContractMethod;
    private static MethodInfo s_isStartElementMethod2;
    private static MethodInfo s_isStartElementMethod0;
    private static MethodInfo s_getUninitializedObjectMethod;
    private static MethodInfo s_onDeserializationMethod;
    private static MethodInfo s_unboxPointer;
    private static PropertyInfo s_nodeTypeProperty;
    private static ConstructorInfo s_serializationExceptionCtor;
    private static ConstructorInfo s_extensionDataObjectCtor;
    private static ConstructorInfo s_hashtableCtor;
    private static MethodInfo s_getStreamingContextMethod;
    private static MethodInfo s_getCollectionMemberMethod;
    private static MethodInfo s_storeCollectionMemberInfoMethod;
    private static MethodInfo s_resetCollectionMemberInfoMethod;
    private static MethodInfo s_storeIsGetOnlyCollectionMethod;
    private static MethodInfo s_resetIsGetOnlyCollection;
    private static MethodInfo s_throwNullValueReturnedForGetOnlyCollectionExceptionMethod;
    private static MethodInfo s_throwArrayExceededSizeExceptionMethod;
    private static MethodInfo s_incrementItemCountMethod;
    private static MethodInfo s_internalDeserializeMethod;
    private static MethodInfo s_moveToNextElementMethod;
    private static MethodInfo s_getMemberIndexMethod;
    private static MethodInfo s_getMemberIndexWithRequiredMembersMethod;
    private static MethodInfo s_throwRequiredMemberMissingExceptionMethod;
    private static MethodInfo s_skipUnknownElementMethod;
    private static MethodInfo s_readIfNullOrRefMethod;
    private static MethodInfo s_readAttributesMethod;
    private static MethodInfo s_resetAttributesMethod;
    private static MethodInfo s_getObjectIdMethod;
    private static MethodInfo s_getArraySizeMethod;
    private static MethodInfo s_addNewObjectMethod;
    private static MethodInfo s_addNewObjectWithIdMethod;
    private static MethodInfo s_replaceDeserializedObjectMethod;
    private static MethodInfo s_getExistingObjectMethod;
    private static MethodInfo s_getRealObjectMethod;
    private static MethodInfo s_ensureArraySizeMethod;
    private static MethodInfo s_trimArraySizeMethod;
    private static MethodInfo s_checkEndOfArrayMethod;
    private static MethodInfo s_getArrayLengthMethod;
    private static MethodInfo s_readSerializationInfoMethod;
    private static MethodInfo s_createUnexpectedStateExceptionMethod;
    private static MethodInfo s_internalSerializeReferenceMethod;
    private static MethodInfo s_internalSerializeMethod;
    private static MethodInfo s_writeNullMethod;
    private static MethodInfo s_incrementArrayCountMethod;
    private static MethodInfo s_incrementCollectionCountMethod;
    private static MethodInfo s_incrementCollectionCountGenericMethod;
    private static MethodInfo s_getDefaultValueMethod;
    private static MethodInfo s_getNullableValueMethod;
    private static MethodInfo s_throwRequiredMemberMustBeEmittedMethod;
    private static MethodInfo s_getHasValueMethod;
    private static MethodInfo s_writeISerializableMethod;
    private static MethodInfo s_writeExtensionDataMethod;
    private static MethodInfo s_writeXmlValueMethod;
    private static MethodInfo s_readXmlValueMethod;
    private static PropertyInfo s_namespaceProperty;
    private static FieldInfo s_contractNamespacesField;
    private static FieldInfo s_memberNamesField;
    private static MethodInfo s_extensionDataSetExplicitMethodInfo;
    private static PropertyInfo s_childElementNamespacesProperty;
    private static PropertyInfo s_collectionItemNameProperty;
    private static PropertyInfo s_childElementNamespaceProperty;
    private static MethodInfo s_getDateTimeOffsetMethod;
    private static MethodInfo s_getDateTimeOffsetAdapterMethod;
    private static MethodInfo s_getMemoryStreamMethod;
    private static MethodInfo s_getMemoryStreamAdapterMethod;
    private static MethodInfo s_getTypeHandleMethod;
    private static MethodInfo s_getTypeMethod;
    private static MethodInfo s_throwInvalidDataContractExceptionMethod;
    private static PropertyInfo s_serializeReadOnlyTypesProperty;
    private static PropertyInfo s_classSerializationExceptionMessageProperty;
    private static PropertyInfo s_collectionSerializationExceptionMessageProperty;
    internal static MethodInfo WriteStartElementMethod2 { get; }
    internal static MethodInfo WriteStartElementMethod3 { get; }
    internal static MethodInfo WriteEndElementMethod { get; }
    internal static MethodInfo WriteNamespaceDeclMethod { get; }
    internal static PropertyInfo ExtensionDataProperty { get; }
    internal static MethodInfo BoxPointer { get; }
    internal static ConstructorInfo DictionaryEnumeratorCtor { get; }
    internal static MethodInfo MoveNextMethod { get; }
    internal static MethodInfo GetCurrentMethod { get; }
    internal static MethodInfo GetItemContractMethod { get; }
    internal static MethodInfo IsStartElementMethod2 { get; }
    internal static MethodInfo IsStartElementMethod0 { get; }
    internal static MethodInfo GetUninitializedObjectMethod { get; }
    internal static MethodInfo OnDeserializationMethod { get; }
    internal static MethodInfo UnboxPointer { get; }
    internal static PropertyInfo NodeTypeProperty { get; }
    internal static ConstructorInfo SerializationExceptionCtor { get; }
    internal static ConstructorInfo ExtensionDataObjectCtor { get; }
    internal static ConstructorInfo HashtableCtor { get; }
    internal static MethodInfo GetStreamingContextMethod { get; }
    internal static MethodInfo GetCollectionMemberMethod { get; }
    internal static MethodInfo StoreCollectionMemberInfoMethod { get; }
    internal static MethodInfo ResetCollectionMemberInfoMethod { get; }
    internal static MethodInfo StoreIsGetOnlyCollectionMethod { get; }
    internal static MethodInfo ResetIsGetOnlyCollectionMethod { get; }
    internal static MethodInfo ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod { get; }
    internal static MethodInfo ThrowArrayExceededSizeExceptionMethod { get; }
    internal static MethodInfo IncrementItemCountMethod { get; }
    internal static MethodInfo InternalDeserializeMethod { get; }
    internal static MethodInfo MoveToNextElementMethod { get; }
    internal static MethodInfo GetMemberIndexMethod { get; }
    internal static MethodInfo GetMemberIndexWithRequiredMembersMethod { get; }
    internal static MethodInfo ThrowRequiredMemberMissingExceptionMethod { get; }
    internal static MethodInfo SkipUnknownElementMethod { get; }
    internal static MethodInfo ReadIfNullOrRefMethod { get; }
    internal static MethodInfo ReadAttributesMethod { get; }
    internal static MethodInfo ResetAttributesMethod { get; }
    internal static MethodInfo GetObjectIdMethod { get; }
    internal static MethodInfo GetArraySizeMethod { get; }
    internal static MethodInfo AddNewObjectMethod { get; }
    internal static MethodInfo AddNewObjectWithIdMethod { get; }
    internal static MethodInfo ReplaceDeserializedObjectMethod { get; }
    internal static MethodInfo GetExistingObjectMethod { get; }
    internal static MethodInfo GetRealObjectMethod { get; }
    internal static MethodInfo EnsureArraySizeMethod { get; }
    internal static MethodInfo TrimArraySizeMethod { get; }
    internal static MethodInfo CheckEndOfArrayMethod { get; }
    internal static MethodInfo GetArrayLengthMethod { get; }
    internal static MethodInfo ReadSerializationInfoMethod { get; }
    internal static MethodInfo CreateUnexpectedStateExceptionMethod { get; }
    internal static MethodInfo InternalSerializeReferenceMethod { get; }
    internal static MethodInfo InternalSerializeMethod { get; }
    internal static MethodInfo WriteNullMethod { get; }
    internal static MethodInfo IncrementArrayCountMethod { get; }
    internal static MethodInfo IncrementCollectionCountMethod { get; }
    internal static MethodInfo IncrementCollectionCountGenericMethod { get; }
    internal static MethodInfo GetDefaultValueMethod { get; }
    internal static MethodInfo GetNullableValueMethod { get; }
    internal static MethodInfo ThrowRequiredMemberMustBeEmittedMethod { get; }
    internal static MethodInfo GetHasValueMethod { get; }
    internal static MethodInfo WriteISerializableMethod { get; }
    internal static MethodInfo WriteExtensionDataMethod { get; }
    internal static MethodInfo WriteXmlValueMethod { get; }
    internal static MethodInfo ReadXmlValueMethod { get; }
    internal static PropertyInfo NamespaceProperty { get; }
    internal static FieldInfo ContractNamespacesField { get; }
    internal static FieldInfo MemberNamesField { get; }
    internal static MethodInfo ExtensionDataSetExplicitMethodInfo { get; }
    internal static PropertyInfo ChildElementNamespacesProperty { get; }
    internal static PropertyInfo CollectionItemNameProperty { get; }
    internal static PropertyInfo ChildElementNamespaceProperty { get; }
    internal static MethodInfo GetDateTimeOffsetMethod { get; }
    internal static MethodInfo GetDateTimeOffsetAdapterMethod { get; }
    internal static MethodInfo GetMemoryStreamMethod { get; }
    internal static MethodInfo GetMemoryStreamAdapterMethod { get; }
    internal static MethodInfo GetTypeHandleMethod { get; }
    internal static MethodInfo GetTypeMethod { get; }
    internal static MethodInfo ThrowInvalidDataContractExceptionMethod { get; }
    internal static PropertyInfo SerializeReadOnlyTypesProperty { get; }
    internal static PropertyInfo ClassSerializationExceptionMessageProperty { get; }
    internal static PropertyInfo CollectionSerializationExceptionMessageProperty { get; }
    internal static MethodInfo get_WriteStartElementMethod2();
    internal static MethodInfo get_WriteStartElementMethod3();
    internal static MethodInfo get_WriteEndElementMethod();
    internal static MethodInfo get_WriteNamespaceDeclMethod();
    internal static PropertyInfo get_ExtensionDataProperty();
    internal static MethodInfo get_BoxPointer();
    internal static ConstructorInfo get_DictionaryEnumeratorCtor();
    internal static MethodInfo get_MoveNextMethod();
    internal static MethodInfo get_GetCurrentMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_GetItemContractMethod();
    internal static MethodInfo get_IsStartElementMethod2();
    internal static MethodInfo get_IsStartElementMethod0();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_GetUninitializedObjectMethod();
    internal static MethodInfo get_OnDeserializationMethod();
    internal static MethodInfo get_UnboxPointer();
    internal static PropertyInfo get_NodeTypeProperty();
    internal static ConstructorInfo get_SerializationExceptionCtor();
    internal static ConstructorInfo get_ExtensionDataObjectCtor();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static ConstructorInfo get_HashtableCtor();
    internal static MethodInfo get_GetStreamingContextMethod();
    internal static MethodInfo get_GetCollectionMemberMethod();
    internal static MethodInfo get_StoreCollectionMemberInfoMethod();
    internal static MethodInfo get_ResetCollectionMemberInfoMethod();
    internal static MethodInfo get_StoreIsGetOnlyCollectionMethod();
    internal static MethodInfo get_ResetIsGetOnlyCollectionMethod();
    internal static MethodInfo get_ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod();
    internal static MethodInfo get_ThrowArrayExceededSizeExceptionMethod();
    internal static MethodInfo get_IncrementItemCountMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_InternalDeserializeMethod();
    internal static MethodInfo get_MoveToNextElementMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_GetMemberIndexMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_GetMemberIndexWithRequiredMembersMethod();
    internal static MethodInfo get_ThrowRequiredMemberMissingExceptionMethod();
    internal static MethodInfo get_SkipUnknownElementMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_ReadIfNullOrRefMethod();
    internal static MethodInfo get_ReadAttributesMethod();
    internal static MethodInfo get_ResetAttributesMethod();
    internal static MethodInfo get_GetObjectIdMethod();
    internal static MethodInfo get_GetArraySizeMethod();
    internal static MethodInfo get_AddNewObjectMethod();
    internal static MethodInfo get_AddNewObjectWithIdMethod();
    internal static MethodInfo get_ReplaceDeserializedObjectMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_GetExistingObjectMethod();
    internal static MethodInfo get_GetRealObjectMethod();
    internal static MethodInfo get_EnsureArraySizeMethod();
    internal static MethodInfo get_TrimArraySizeMethod();
    internal static MethodInfo get_CheckEndOfArrayMethod();
    internal static MethodInfo get_GetArrayLengthMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_ReadSerializationInfoMethod();
    internal static MethodInfo get_CreateUnexpectedStateExceptionMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_InternalSerializeReferenceMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_InternalSerializeMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_WriteNullMethod();
    internal static MethodInfo get_IncrementArrayCountMethod();
    internal static MethodInfo get_IncrementCollectionCountMethod();
    internal static MethodInfo get_IncrementCollectionCountGenericMethod();
    internal static MethodInfo get_GetDefaultValueMethod();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
internal static object GetDefaultValue(Type type);
    internal static MethodInfo get_GetNullableValueMethod();
    internal static MethodInfo get_ThrowRequiredMemberMustBeEmittedMethod();
    internal static MethodInfo get_GetHasValueMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_WriteISerializableMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_WriteExtensionDataMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_WriteXmlValueMethod();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static MethodInfo get_ReadXmlValueMethod();
    internal static PropertyInfo get_NamespaceProperty();
    internal static FieldInfo get_ContractNamespacesField();
    internal static FieldInfo get_MemberNamesField();
    internal static MethodInfo get_ExtensionDataSetExplicitMethodInfo();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static PropertyInfo get_ChildElementNamespacesProperty();
    internal static PropertyInfo get_CollectionItemNameProperty();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static PropertyInfo get_ChildElementNamespaceProperty();
    internal static MethodInfo get_GetDateTimeOffsetMethod();
    internal static MethodInfo get_GetDateTimeOffsetAdapterMethod();
    internal static MethodInfo get_GetMemoryStreamMethod();
    internal static MethodInfo get_GetMemoryStreamAdapterMethod();
    internal static MethodInfo get_GetTypeHandleMethod();
    internal static MethodInfo get_GetTypeMethod();
    internal static MethodInfo get_ThrowInvalidDataContractExceptionMethod();
    internal static PropertyInfo get_SerializeReadOnlyTypesProperty();
    internal static PropertyInfo get_ClassSerializationExceptionMessageProperty();
    internal static PropertyInfo get_CollectionSerializationExceptionMessageProperty();
}
internal class System.Runtime.Serialization.XmlFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatReaderGenerator : object {
    private CriticalHelper _helper;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
    internal static object UnsafeGetUninitializedObject(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object UnsafeGetUninitializedObject(int id);
}
internal class System.Runtime.Serialization.XmlFormatWriterGenerator : object {
    private CriticalHelper _helper;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal XmlFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.XmlObjectSerializer : object {
    private static IFormatterConverter s_formatterConverter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    internal static IFormatterConverter FormatterConverter { get; }
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteEndObject(XmlDictionaryWriter writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(Stream stream, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlWriter writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteStartObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteObjectContentHandleExceptions(XmlWriterDelegator writer, object graph);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteEndObjectHandleExceptions(XmlWriterDelegator writer);
    internal static void WriteRootElement(XmlWriterDelegator writer, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns, bool needsContractNsAtRoot);
    internal static bool CheckIfNeedsContractNsAtRoot(XmlDictionaryString name, XmlDictionaryString ns, DataContract contract);
    internal static void WriteNull(XmlWriterDelegator writer);
    internal static bool IsContractDeclared(DataContract contract, DataContract declaredContract);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(Stream stream);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual bool IsStartObject(XmlDictionaryReader reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool IsStartObjectHandleExceptions(XmlReaderDelegator reader);
    internal static bool IsRootXmlAny(XmlDictionaryString rootName, DataContract contract);
    internal static bool IsStartElement(XmlReaderDelegator reader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static bool IsRootElement(XmlReaderDelegator reader, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns);
    internal static string TryAddLineInfo(XmlReaderDelegator reader, string errorMessage);
    internal static Exception CreateSerializationExceptionWithReaderDetails(string errorMessage, XmlReaderDelegator reader);
    internal static SerializationException CreateSerializationException(string errorMessage);
    internal static SerializationException CreateSerializationException(string errorMessage, Exception innerException);
    internal static string GetTypeInfoError(string errorMessage, Type type, Exception innerException);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    internal static IFormatterConverter get_FormatterConverter();
}
internal class System.Runtime.Serialization.XmlObjectSerializerContext : object {
    protected XmlObjectSerializer serializer;
    protected DataContract rootTypeDataContract;
    internal ScopedKnownTypes scopedKnownTypes;
    protected Dictionary`2<XmlQualifiedName, DataContract> serializerKnownDataContracts;
    private bool _isSerializerKnownDataContractsSetExplicit;
    protected IList`1<Type> serializerKnownTypeList;
    private int _itemCount;
    private int _maxItemsInObjectGraph;
    private StreamingContext _streamingContext;
    private bool _ignoreExtensionDataObject;
    private DataContractResolver _dataContractResolver;
    private KnownTypeDataContractResolver _knownTypeResolver;
    internal bool IsGetOnlyCollection { get; internal set; }
    internal int RemainingItemCount { get; }
    internal bool IgnoreExtensionDataObject { get; }
    protected DataContractResolver DataContractResolver { get; }
    protected KnownTypeDataContractResolver KnownTypeResolver { get; }
    internal Dictionary`2<XmlQualifiedName, DataContract> SerializerKnownDataContracts { get; }
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal StreamingContext GetStreamingContext();
    internal void IncrementItemCount(int count);
    internal int get_RemainingItemCount();
    internal bool get_IgnoreExtensionDataObject();
    protected DataContractResolver get_DataContractResolver();
    protected KnownTypeDataContractResolver get_KnownTypeResolver();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal DataContract GetDataContract(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Type GetSurrogatedType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_SerializerKnownDataContracts();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract GetDataContractFromSerializerKnownTypes(XmlQualifiedName qname);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static Dictionary`2<XmlQualifiedName, DataContract> GetDataContractsForKnownTypes(IList`1<Type> knownTypeList);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool IsKnownType(DataContract dataContract, Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool IsKnownType(DataContract dataContract, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal Type ResolveNameFromKnownTypes(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private DataContract ResolveDataContractFromKnownTypes(XmlQualifiedName typeName);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected DataContract ResolveDataContractFromKnownTypes(string typeName, string typeNs, DataContract memberTypeContract, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContext : XmlObjectSerializerContext {
    internal Attributes attributes;
    private HybridObjectCache _deserializedObjects;
    private XmlSerializableReader _xmlSerializableReader;
    private XmlDocument _xmlDocument;
    private Attributes _attributesInXmlData;
    private XmlReaderDelegator _extensionDataReader;
    private object _getOnlyCollectionValue;
    private bool _isGetOnlyCollection;
    private HybridObjectCache DeserializedObjects { get; }
    private XmlDocument Document { get; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal XmlObjectSerializerReadContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerReadContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    private HybridObjectCache get_DeserializedObjects();
    private XmlDocument get_Document();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal object GetCollectionMember();
    internal void StoreCollectionMemberInfo(object collectionMember);
    internal void ResetCollectionMemberInfo();
    [DoesNotReturnAttribute]
internal static void ThrowNullValueReturnedForGetOnlyCollectionException(Type type);
    [DoesNotReturnAttribute]
internal static void ThrowArrayExceededSizeException(int arraySize, Type type);
    internal static XmlObjectSerializerReadContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int id, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected bool TryHandleNullOrRef(XmlReaderDelegator reader, string name, string ns, Type declaredType, Object& retObj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected object InternalDeserialize(XmlReaderDelegator reader, string name, string ns, Type declaredType, DataContract& dataContract);
    private bool ReplaceScopedKnownTypesTop(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, bool knownTypesAddedInCurrentScope);
    internal static bool MoveToNextElement(XmlReaderDelegator xmlReader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal int GetMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, ExtensionDataObject extensionData);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal int GetMemberIndexWithRequiredMembers(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, int requiredIndex, ExtensionDataObject extensionData);
    [DoesNotReturnAttribute]
internal static void ThrowRequiredMemberMissingException(XmlReaderDelegator xmlReader, int memberIndex, int requiredIndex, XmlDictionaryString[] memberNames);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected void HandleMemberNotFound(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void HandleUnknownElement(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    internal void SkipUnknownElement(XmlReaderDelegator xmlReader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal string ReadIfNullOrRef(XmlReaderDelegator xmlReader, Type memberType, bool isMemberTypeSerializable);
    [MemberNotNullAttribute("attributes")]
internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    internal void ResetAttributes();
    internal string GetObjectId();
    internal virtual int GetArraySize();
    internal void AddNewObject(object obj);
    internal void AddNewObjectWithId(string id, object obj);
    public void ReplaceDeserializedObject(string id, object oldObj, object newObj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal object GetExistingObject(string id, Type type, string name, string ns);
    private object GetExistingObjectOrExtensionData(string id);
    public object GetRealObject(IObjectReference obj, string id);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object DeserializeFromExtensionData(IDataNode dataNode, Type type, string name, string ns);
    internal static void Read(XmlReaderDelegator xmlReader);
    internal static void ParseQualifiedName(string qname, XmlReaderDelegator xmlReader, String& name, String& ns, String& prefix);
    internal static T[] EnsureArraySize(T[] array, int index);
    internal static T[] TrimArraySize(T[] array, int size);
    internal void CheckEndOfArray(XmlReaderDelegator xmlReader, int arraySize, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal object ReadIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object ReadRootIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal static object ReadIXmlSerializable(XmlSerializableReader xmlSerializableReader, XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public SerializationInfo ReadSerializationInfo(XmlReaderDelegator xmlReader, Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual DataContract ResolveDataContractFromTypeName();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ExtensionDataMember ReadExtensionDataMember(XmlReaderDelegator xmlReader, int memberIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected void InitializeExtensionDataNode(IDataNode dataNode, string dataContractName, string dataContractNamespace);
    private IDataNode ReadUnknownPrimitiveData(XmlReaderDelegator xmlReader, Type type, string dataContractName, string dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ClassDataNode ReadUnknownClassData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private CollectionDataNode ReadUnknownCollectionData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private ISerializableDataNode ReadUnknownISerializableData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private XmlDataNode ReadUnknownXmlData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private IDataNode ReadAndResolveUnknownXmlData(XmlReaderDelegator xmlReader, IDictionary`2<string, string> namespaces, string dataContractName, string dataContractNamespace);
    private static bool IsContentNode(XmlNodeType nodeType);
    internal XmlReaderDelegator CreateReaderOverChildNodes(IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes);
    internal static XmlElement CreateWrapperXmlElement(XmlDocument document, IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes, string prefix, string localName, string ns);
    private XmlAttribute AddNamespaceDeclaration(string prefix, string ns);
    internal static Exception CreateUnexpectedStateException(XmlNodeType expectedState, XmlReaderDelegator xmlReader);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContextComplex : XmlObjectSerializerReadContext {
    private bool _preserveObjectReferences;
    private ISerializationSurrogateProvider _serializationSurrogateProvider;
    internal XmlObjectSerializerReadContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerReadContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private object InternalDeserializeWithSurrogate(XmlReaderDelegator xmlReader, Type declaredType, DataContract surrogateDataContract, string name, string ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Type GetSurrogatedType(Type type);
    internal virtual int GetArraySize();
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContext : XmlObjectSerializerContext {
    private ObjectReferenceStack _byValObjectsInScope;
    private XmlSerializableWriter _xmlSerializableWriter;
    private static int depthToCheckCyclicReference;
    private ObjectToIdCache _serializedObjects;
    private bool _isGetOnlyCollection;
    private bool _unsafeTypeForwardingEnabled;
    protected bool serializeReadOnlyTypes;
    protected bool preserveObjectReferences;
    protected ObjectToIdCache SerializedObjects { get; }
    internal bool IsGetOnlyCollection { get; internal set; }
    internal bool SerializeReadOnlyTypes { get; }
    internal bool UnsafeTypeForwardingEnabled { get; }
    protected XmlObjectSerializerWriteContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver resolver);
    internal XmlObjectSerializerWriteContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal static XmlObjectSerializerWriteContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    protected ObjectToIdCache get_SerializedObjects();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal bool get_SerializeReadOnlyTypes();
    internal bool get_UnsafeTypeForwardingEnabled();
    internal void StoreIsGetOnlyCollection();
    internal void ResetIsGetOnlyCollection();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void InternalSerializeReference(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal bool OnHandleIsReference(XmlWriterDelegator xmlWriter, DataContract contract, object obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected void SerializeAndVerifyType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, bool verifyKnownType, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, SerializationInfo serInfo);
    internal virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    internal virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void HandleGraphAtTopLevel(XmlWriterDelegator writer, object obj, DataContract contract);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable, XmlDictionaryString name, XmlDictionaryString ns);
    internal void IncrementArrayCount(XmlWriterDelegator xmlWriter, Array array);
    internal void IncrementCollectionCount(XmlWriterDelegator xmlWriter, ICollection collection);
    internal void IncrementCollectionCountGeneric(XmlWriterDelegator xmlWriter, ICollection`1<T> collection);
    private void IncrementCollectionCount(XmlWriterDelegator xmlWriter, int size);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    internal static bool IsMemberTypeSameAsMemberValue(object obj, Type memberType);
    internal static T GetDefaultValue();
    internal static T GetNullableValue(Nullable`1<T> value);
    internal static void ThrowRequiredMemberMustBeEmitted(string memberName, Type type);
    internal static bool GetHasValue(Nullable`1<T> value);
    internal void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    internal static void WriteRootIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    private static void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj, XmlSerializableWriter xmlSerializableWriter);
    internal static void GetObjectData(ISerializable obj, SerializationInfo serInfo, StreamingContext context);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void WriteISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteSerializationInfo(XmlWriterDelegator xmlWriter, Type objType, SerializationInfo serInfo);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteResolvedTypeInfo(XmlWriterDelegator writer, Type objectType, Type declaredType);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private bool ResolveType(Type objectType, Type declaredType, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, XmlDictionaryString dataContractName, XmlDictionaryString dataContractNamespace);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void WriteExtensionData(XmlWriterDelegator xmlWriter, ExtensionDataObject extensionData, int memberIndex);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteExtensionDataMember(XmlWriterDelegator xmlWriter, ExtensionDataMember member);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal void WriteExtensionDataValue(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal bool TryWriteDeserializedExtensionData(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteExtensionClassData(XmlWriterDelegator xmlWriter, ClassDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteExtensionCollectionData(XmlWriterDelegator xmlWriter, CollectionDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteExtensionISerializableData(XmlWriterDelegator xmlWriter, ISerializableDataNode dataNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void WriteExtensionXmlData(XmlWriterDelegator xmlWriter, XmlDataNode dataNode);
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContextComplex : XmlObjectSerializerWriteContext {
    private ISerializationSurrogateProvider _serializationSurrogateProvider;
    internal XmlObjectSerializerWriteContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerWriteContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    internal virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
internal virtual Type GetSurrogatedType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void InternalSerializeWithSurrogate(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, RuntimeTypeHandle declaredTypeHandle);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
}
internal class System.Runtime.Serialization.XmlReaderDelegator : object {
    protected XmlReader reader;
    protected XmlDictionaryReader dictionaryReader;
    protected bool isEndOfEmptyElement;
    internal XmlReader UnderlyingReader { get; }
    internal ExtensionDataReader UnderlyingExtensionDataReader { get; }
    internal int AttributeCount { get; }
    internal bool IsEmptyElement { get; }
    internal XmlNodeType NodeType { get; }
    internal int LineNumber { get; }
    internal int LinePosition { get; }
    internal bool Normalized { get; internal set; }
    internal WhitespaceHandling WhitespaceHandling { get; internal set; }
    internal string Name { get; }
    internal string LocalName { get; }
    internal string NamespaceURI { get; }
    internal string Value { get; }
    internal Type ValueType { get; }
    internal int Depth { get; }
    internal bool EOF { get; }
    public XmlReaderDelegator(XmlReader reader);
    internal XmlReader get_UnderlyingReader();
    internal ExtensionDataReader get_UnderlyingExtensionDataReader();
    internal int get_AttributeCount();
    internal string GetAttribute(string name);
    internal string GetAttribute(string name, string namespaceUri);
    internal string GetAttribute(int i);
    internal bool get_IsEmptyElement();
    internal bool IsNamespaceURI(string ns);
    internal bool IsLocalName(string localName);
    internal bool IsNamespaceUri(XmlDictionaryString ns);
    internal bool IsLocalName(XmlDictionaryString localName);
    internal int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString ns);
    internal bool IsStartElement();
    internal bool IsStartElement(string localname, string ns);
    internal bool IsStartElement(XmlDictionaryString localname, XmlDictionaryString ns);
    internal bool MoveToAttribute(string name);
    internal bool MoveToAttribute(string name, string ns);
    internal void MoveToAttribute(int i);
    internal bool MoveToElement();
    internal bool MoveToFirstAttribute();
    internal bool MoveToNextAttribute();
    internal XmlNodeType get_NodeType();
    internal bool Read();
    internal XmlNodeType MoveToContent();
    internal bool ReadAttributeValue();
    internal void ReadEndElement();
    private static InvalidDataContractException CreateInvalidPrimitiveTypeException(Type type);
    public object ReadElementContentAsAnyType(Type valueType);
    internal object ReadContentAsAnyType(Type valueType);
    internal IDataNode ReadExtensionData(Type valueType);
    [DoesNotReturnAttribute]
private void ThrowConversionException(string value, string type);
    [DoesNotReturnAttribute]
private static void ThrowNotAtElement();
    internal virtual char ReadElementContentAsChar();
    internal virtual char ReadContentAsChar();
    private char ToChar(int value);
    internal string ReadElementContentAsString();
    internal string ReadContentAsString();
    internal bool ReadElementContentAsBoolean();
    internal bool ReadContentAsBoolean();
    internal float ReadElementContentAsFloat();
    internal float ReadContentAsSingle();
    internal double ReadElementContentAsDouble();
    internal double ReadContentAsDouble();
    internal decimal ReadElementContentAsDecimal();
    internal decimal ReadContentAsDecimal();
    internal virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadContentAsBase64();
    internal static Byte[] ReadContentAsBase64(string str);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal virtual DateTime ReadContentAsDateTime();
    internal int ReadElementContentAsInt();
    internal int ReadContentAsInt();
    internal long ReadElementContentAsLong();
    internal long ReadContentAsLong();
    internal short ReadElementContentAsShort();
    internal short ReadContentAsShort();
    private short ToShort(int value);
    internal byte ReadElementContentAsUnsignedByte();
    internal byte ReadContentAsUnsignedByte();
    private byte ToByte(int value);
    internal sbyte ReadElementContentAsSignedByte();
    internal sbyte ReadContentAsSignedByte();
    private sbyte ToSByte(int value);
    internal UInt32 ReadElementContentAsUnsignedInt();
    internal UInt32 ReadContentAsUnsignedInt();
    private UInt32 ToUInt32(long value);
    internal virtual ulong ReadElementContentAsUnsignedLong();
    internal virtual ulong ReadContentAsUnsignedLong();
    internal ushort ReadElementContentAsUnsignedShort();
    internal ushort ReadContentAsUnsignedShort();
    private ushort ToUInt16(int value);
    internal TimeSpan ReadElementContentAsTimeSpan();
    internal TimeSpan ReadContentAsTimeSpan();
    internal Guid ReadElementContentAsGuid();
    internal Guid ReadContentAsGuid();
    internal Uri ReadElementContentAsUri();
    internal Uri ReadContentAsUri();
    internal XmlQualifiedName ReadElementContentAsQName();
    internal virtual XmlQualifiedName ReadContentAsQName();
    private XmlQualifiedName ParseQualifiedName(string str);
    private static void CheckExpectedArrayLength(XmlObjectSerializerReadContext context, int arrayLength);
    protected int GetArrayLengthQuota(XmlObjectSerializerReadContext context);
    private static void CheckActualArrayLength(int expectedLength, int actualLength, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal bool TryReadBooleanArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Boolean[]& array);
    internal virtual bool TryReadDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal bool TryReadDecimalArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Decimal[]& array);
    internal bool TryReadInt32Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int32[]& array);
    internal bool TryReadInt64Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int64[]& array);
    internal bool TryReadSingleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Single[]& array);
    internal bool TryReadDoubleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Double[]& array);
    internal IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    internal bool HasLineInfo();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal bool get_Normalized();
    internal void set_Normalized(bool value);
    internal WhitespaceHandling get_WhitespaceHandling();
    internal void set_WhitespaceHandling(WhitespaceHandling value);
    internal string get_Name();
    internal string get_LocalName();
    internal string get_NamespaceURI();
    internal string get_Value();
    internal Type get_ValueType();
    internal int get_Depth();
    internal string LookupNamespace(string prefix);
    internal bool get_EOF();
    internal void Skip();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.XmlSerializableReader : XmlReader {
    private XmlReaderDelegator _xmlReader;
    private int _startDepth;
    private bool _isRootEmptyElement;
    private XmlReader _innerReader;
    private XmlReader InnerReader { get; }
    public XmlReaderSettings Settings { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public Type ValueType { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public XmlNameTable NameTable { get; }
    public bool CanResolveEntity { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool HasAttributes { get; }
    private bool System.Xml.Serialization.IXmlTextParser.Normalized { get; private set; }
    private WhitespaceHandling System.Xml.Serialization.IXmlTextParser.WhitespaceHandling { get; private set; }
    private int System.Xml.IXmlLineInfo.LineNumber { get; }
    private int System.Xml.IXmlLineInfo.LinePosition { get; }
    private XmlReader get_InnerReader();
    internal void BeginRead(XmlReaderDelegator xmlReader);
    internal void EndRead();
    public virtual bool Read();
    public virtual void Close();
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual XmlNameTable get_NameTable();
    public virtual bool get_CanResolveEntity();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_HasAttributes();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual string LookupNamespace(string prefix);
    public virtual bool ReadAttributeValue();
    public virtual void ResolveEntity();
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localname, string ns);
    public virtual XmlNodeType MoveToContent();
    public virtual object ReadContentAsObject();
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual string ReadContentAsString();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual string ReadString();
    private sealed virtual override bool System.Xml.Serialization.IXmlTextParser.get_Normalized();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_Normalized(bool value);
    private sealed virtual override WhitespaceHandling System.Xml.Serialization.IXmlTextParser.get_WhitespaceHandling();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_WhitespaceHandling(WhitespaceHandling value);
    private sealed virtual override bool System.Xml.IXmlLineInfo.HasLineInfo();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.XmlSerializableServices : object {
    internal static string AddDefaultSchemaMethodName;
    private static XmlSerializableServices();
    public static XmlNode[] ReadNodes(XmlReader xmlReader);
    private static bool IsValidAttribute(XmlReader xmlReader);
    public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
    public static void AddDefaultSchema(XmlSchemaSet schemas, XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlSerializableWriter : XmlWriter {
    private XmlWriter _xmlWriter;
    private int _depth;
    private object _obj;
    public WriteState WriteState { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    internal void BeginWrite(XmlWriter xmlWriter, object obj);
    internal void EndWrite();
    public virtual void WriteStartDocument();
    public virtual void WriteEndDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void Close();
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteCData(string text);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual WriteState get_WriteState();
    public virtual void Flush();
    public virtual void WriteName(string name);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual string LookupPrefix(string ns);
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual void WriteNmToken(string name);
}
internal class System.Runtime.Serialization.XmlWriterDelegator : object {
    protected XmlWriter writer;
    protected XmlDictionaryWriter dictionaryWriter;
    internal int depth;
    private int _prefixes;
    internal XmlWriter Writer { get; }
    internal WriteState WriteState { get; }
    internal string XmlLang { get; }
    internal XmlSpace XmlSpace { get; }
    public XmlWriterDelegator(XmlWriter writer);
    internal XmlWriter get_Writer();
    internal void Flush();
    internal string LookupPrefix(string ns);
    private void WriteEndAttribute();
    internal void WriteEndElement();
    internal void WriteRaw(Char[] buffer, int index, int count);
    internal void WriteRaw(string data);
    internal void WriteXmlnsAttribute(XmlDictionaryString ns);
    internal void WriteXmlnsAttribute(string ns);
    internal void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void WriteStartAttribute(string prefix, string localName, string ns);
    private void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteAttributeString(string prefix, string localName, string ns, string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string value);
    private void WriteAttributeStringValue(string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString value);
    private void WriteAttributeStringValue(XmlDictionaryString value);
    internal void WriteAttributeInt(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, int value);
    private void WriteAttributeIntValue(int value);
    internal void WriteAttributeBool(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, bool value);
    private void WriteAttributeBoolValue(bool value);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string name, string ns);
    private void WriteAttributeQualifiedNameValue(string name, string ns);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString name, XmlDictionaryString ns);
    private void WriteAttributeQualifiedNameValue(XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteStartElement(string localName, string ns);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
    internal void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElementPrimitive(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteEndElementPrimitive();
    internal WriteState get_WriteState();
    internal string get_XmlLang();
    internal XmlSpace get_XmlSpace();
    internal void WriteNamespaceDecl(XmlDictionaryString ns);
    private static InvalidDataContractException CreateInvalidPrimitiveTypeException(Type type);
    internal void WriteAnyType(object value);
    internal void WriteAnyType(object value, Type valueType);
    internal void WriteExtensionData(IDataNode dataNode);
    internal void WriteString(string value);
    internal virtual void WriteBoolean(bool value);
    internal void WriteBoolean(bool value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDateTime(DateTime value);
    internal void WriteDateTime(DateTime value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDecimal(decimal value);
    internal void WriteDecimal(decimal value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDouble(double value);
    internal void WriteDouble(double value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteInt(int value);
    internal void WriteInt(int value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteLong(long value);
    internal void WriteLong(long value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteFloat(float value);
    internal void WriteFloat(float value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteShort(short value);
    internal void WriteShort(short value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedByte(byte value);
    internal void WriteUnsignedByte(byte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteSignedByte(sbyte value);
    internal void WriteSignedByte(sbyte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedInt(UInt32 value);
    internal void WriteUnsignedInt(UInt32 value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedLong(ulong value);
    internal void WriteUnsignedLong(ulong value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedShort(ushort value);
    internal void WriteUnsignedShort(ushort value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteChar(char value);
    internal void WriteChar(char value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteTimeSpan(TimeSpan value);
    internal void WriteTimeSpan(TimeSpan value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteGuid(Guid value);
    internal void WriteGuid(Guid value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteUri(Uri value);
    internal void WriteUri(Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal void WriteQualifiedName(string localName, string ns);
    internal void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString ns);
    internal void WriteBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.XPathQueryGenerator : object {
    private static string XPathSeparator;
    private static string NsSeparator;
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, StringBuilder rootElementXpath, XmlNamespaceManager& namespaces);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static DataContract ProcessDataContract(DataContract contract, ExportContext context, MemberInfo memberNode);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private static DataContract ProcessClassDataContract(ClassDataContract contract, ExportContext context, MemberInfo memberNode);
    [IteratorStateMachineAttribute("System.Runtime.Serialization.XPathQueryGenerator/<GetDataMembers>d__6")]
private static IEnumerable`1<DataMember> GetDataMembers(ClassDataContract contract);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.XsdDataContractExporter : object {
    private ExportOptions _options;
    private XmlSchemaSet _schemas;
    private DataContractSet _dataContractSet;
    [NullableAttribute("2")]
public ExportOptions Options { get; public set; }
    public XmlSchemaSet Schemas { get; }
    private DataContractSet DataContractSet { get; }
    [NullableContextAttribute("2")]
public XsdDataContractExporter(XmlSchemaSet schemas);
    [NullableContextAttribute("2")]
public ExportOptions get_Options();
    [NullableContextAttribute("2")]
public void set_Options(ExportOptions value);
    public XmlSchemaSet get_Schemas();
    private XmlSchemaSet GetSchemaSet();
    private DataContractSet get_DataContractSet();
    private static void EnsureTypeNotGeneric(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(ICollection`1<Assembly> assemblies);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(ICollection`1<Type> types);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlQualifiedName GetSchemaTypeName(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlSchemaType GetSchemaType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlQualifiedName GetRootElementName(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private Type GetSurrogatedType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void CheckAndAddType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddType(Type type);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void Export();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
private void AddKnownTypes();
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(ICollection`1<Assembly> assemblies);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(ICollection`1<Type> types);
    [RequiresDynamicCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed.")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(Type type);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayExceededSize { get; }
    internal static string ArrayExceededSizeAttribute { get; }
    internal static string ArrayTypeIsNotSupported_GeneratingCode { get; }
    internal static string CannotDeserializeRefAtTopLevel { get; }
    internal static string CannotLoadMemberType { get; }
    internal static string CannotSerializeObjectWithCycles { get; }
    internal static string CanOnlyStoreIntoArgOrLocGot0 { get; }
    internal static string CharIsInvalidPrimitive { get; }
    internal static string CallbackMustReturnVoid { get; }
    internal static string CallbackParameterInvalid { get; }
    internal static string CallbacksCannotBeVirtualMethods { get; }
    internal static string CollectionMustHaveAddMethod { get; }
    internal static string CollectionMustHaveGetEnumeratorMethod { get; }
    internal static string CollectionMustHaveItemType { get; }
    internal static string CollectionTypeCannotBeBuiltIn { get; }
    internal static string CollectionTypeCannotHaveDataContract { get; }
    internal static string CollectionTypeDoesNotHaveAddMethod { get; }
    internal static string CollectionTypeDoesNotHaveDefaultCtor { get; }
    internal static string CollectionTypeHasMultipleDefinitionsOfInterface { get; }
    internal static string CollectionTypeIsNotIEnumerable { get; }
    internal static string DataContractCacheOverflow { get; }
    internal static string DataContractNamespaceAlreadySet { get; }
    internal static string DataContractNamespaceIsNotValid { get; }
    internal static string DataContractNamespaceReserved { get; }
    internal static string DataMemberOnEnumField { get; }
    internal static string DcTypeNotFoundOnDeserialize { get; }
    internal static string DcTypeNotFoundOnSerialize { get; }
    internal static string DcTypeNotResolvedOnDeserialize { get; }
    internal static string DeserializedObjectWithIdNotFound { get; }
    internal static string DupContractInKnownTypes { get; }
    internal static string DupKeyValueName { get; }
    internal static string DupEnumMemberValue { get; }
    internal static string DupMemberName { get; }
    internal static string DuplicateAttribute { get; }
    internal static string DuplicateCallback { get; }
    internal static string EncounteredWithNameNamespace { get; }
    internal static string EnumTypeCannotHaveIsReference { get; }
    internal static string ErrorDeserializing { get; }
    internal static string ErrorInLine { get; }
    internal static string ErrorIsStartObject { get; }
    internal static string ErrorSerializing { get; }
    internal static string ErrorTypeInfo { get; }
    internal static string ErrorWriteEndObject { get; }
    internal static string ErrorWriteStartObject { get; }
    internal static string ExceededMaxItemsQuota { get; }
    internal static string ExpectingElement { get; }
    internal static string ExpectingElementAtDeserialize { get; }
    internal static string ExpectingEnd { get; }
    internal static string ExpectingState { get; }
    internal static string GenericNameBraceMismatch { get; }
    internal static string GenericParameterNotValid { get; }
    internal static string InconsistentIsReference { get; }
    internal static string IndexedPropertyCannotBeSerialized { get; }
    internal static string InvalidCollectionContractItemName { get; }
    internal static string InvalidCollectionContractKeyName { get; }
    internal static string InvalidCollectionContractKeyNoDictionary { get; }
    internal static string InvalidCollectionContractName { get; }
    internal static string InvalidCollectionContractNamespace { get; }
    internal static string InvalidCollectionContractValueName { get; }
    internal static string InvalidCollectionContractValueNoDictionary { get; }
    internal static string InvalidCollectionDataContract { get; }
    internal static string InvalidCollectionType { get; }
    internal static string InvalidDataContractName { get; }
    internal static string InvalidDataContractNamespace { get; }
    internal static string InvalidDataMemberName { get; }
    internal static string InvalidDataNode { get; }
    internal static string InvalidEnumBaseType { get; }
    internal static string InvalidEnumMemberValue { get; }
    internal static string InvalidEnumValueOnRead { get; }
    internal static string InvalidEnumValueOnWrite { get; }
    internal static string InvalidGetSchemaMethod { get; }
    internal static string InvalidGlobalDataContractNamespace { get; }
    internal static string InvalidMember { get; }
    internal static string InvalidNonNullReturnValueByIsAny { get; }
    internal static string InvalidPrimitiveType_Serialization { get; }
    internal static string InvalidReturnTypeOnGetSchemaMethod { get; }
    internal static string InvalidSizeDefinition { get; }
    internal static string InvalidXmlDataContractName { get; }
    internal static string InvalidXsIdDefinition { get; }
    internal static string InvalidXsRefDefinition { get; }
    internal static string IsAnyCannotBeNull { get; }
    internal static string IsAnyCannotBeSerializedAsDerivedType { get; }
    internal static string IsAnyCannotHaveXmlRoot { get; }
    internal static string IsNotAssignableFrom { get; }
    internal static string IsRequiredDataMemberOnIsReferenceDataContractType { get; }
    internal static string IXmlSerializableCannotHaveCollectionDataContract { get; }
    internal static string IXmlSerializableCannotHaveDataContract { get; }
    internal static string IXmlSerializableIllegalOperation { get; }
    internal static string IXmlSerializableMissingEndElements { get; }
    internal static string IXmlSerializableMustHaveDefaultConstructor { get; }
    internal static string IXmlSerializableWritePastSubTree { get; }
    internal static string KnownTypeAttributeEmptyString { get; }
    internal static string KnownTypeAttributeUnknownMethod { get; }
    internal static string KnownTypeAttributeReturnType { get; }
    internal static string KnownTypeAttributeOneScheme { get; }
    internal static string KnownTypeAttributeValidMethodTypes { get; }
    internal static string KnownTypeAttributeNoData { get; }
    internal static string KnownTypeAttributeMethodNull { get; }
    internal static string MaxArrayLengthExceeded { get; }
    internal static string MissingGetSchemaMethod { get; }
    internal static string MultipleIdDefinition { get; }
    internal static string NoConversionPossibleTo { get; }
    internal static string NoGetMethodForProperty { get; }
    internal static string NoSetMethodForProperty { get; }
    internal static string NullKnownType { get; }
    internal static string NullValueReturnedForGetOnlyCollection { get; }
    internal static string ObjectTableOverflow { get; }
    internal static string ParameterCountMismatch { get; }
    internal static string PartialTrustCollectionContractAddMethodNotPublic { get; }
    internal static string PartialTrustCollectionContractNoPublicConstructor { get; }
    internal static string PartialTrustCollectionContractTypeNotPublic { get; }
    internal static string PartialTrustDataContractOnSerializingNotPublic { get; }
    internal static string PartialTrustDataContractOnSerializedNotPublic { get; }
    internal static string PartialTrustDataContractOnDeserializingNotPublic { get; }
    internal static string PartialTrustDataContractOnDeserializedNotPublic { get; }
    internal static string PartialTrustDataContractFieldGetNotPublic { get; }
    internal static string PartialTrustDataContractFieldSetNotPublic { get; }
    internal static string PartialTrustDataContractPropertyGetNotPublic { get; }
    internal static string PartialTrustDataContractPropertySetNotPublic { get; }
    internal static string PartialTrustDataContractTypeNotPublic { get; }
    internal static string PartialTrustNonAttributedSerializableTypeNoPublicConstructor { get; }
    internal static string PartialTrustIXmlSerializableTypeNotPublic { get; }
    internal static string PartialTrustIXmlSerialzableNoPublicConstructor { get; }
    internal static string NonAttributedSerializableTypesMustHaveDefaultConstructor { get; }
    internal static string AttributedTypesCannotInheritFromNonAttributedSerializableTypes { get; }
    internal static string QuotaIsReadOnly { get; }
    internal static string QuotaCopyReadOnly { get; }
    internal static string RequiredMemberMustBeEmitted { get; }
    internal static string ResolveTypeReturnedFalse { get; }
    internal static string ResolveTypeReturnedNull { get; }
    internal static string SupportForMultidimensionalArraysNotPresent { get; }
    internal static string TooManyCollectionContracts { get; }
    internal static string TooManyDataContracts { get; }
    internal static string TooManyDataMembers { get; }
    internal static string TooManyEnumMembers { get; }
    internal static string TooManyIgnoreDataMemberAttributes { get; }
    internal static string TypeNotSerializable { get; }
    internal static string UnexpectedContractType { get; }
    internal static string UnexpectedElementExpectingElements { get; }
    internal static string UnexpectedEndOfFile { get; }
    internal static string UnknownConstantType { get; }
    internal static string ValueTypeCannotBeNull { get; }
    internal static string ValueTypeCannotHaveBaseType { get; }
    internal static string ValueTypeCannotHaveId { get; }
    internal static string ValueTypeCannotHaveIsReference { get; }
    internal static string ValueTypeCannotHaveRef { get; }
    internal static string XmlElementAttributes { get; }
    internal static string XmlForObjectCannotHaveContent { get; }
    internal static string XmlInvalidConversion { get; }
    internal static string XmlInvalidConversionWithoutValue { get; }
    internal static string XmlStartElementExpected { get; }
    internal static string XmlWriterMustBeInElement { get; }
    internal static string NonOptionalFieldMemberOnIsReferenceSerializableType { get; }
    internal static string OffsetExceedsBufferSize { get; }
    internal static string SizeExceedsRemainingBufferSpace { get; }
    internal static string ValueMustBeInRange { get; }
    internal static string XmlArrayTooSmallOutput { get; }
    internal static string XmlAsyncIsRunningException { get; }
    internal static string XmlInvalidBase64Length { get; }
    internal static string XmlInvalidBase64Sequence { get; }
    internal static string XmlInvalidBinHexLength { get; }
    internal static string XmlInvalidBinHexSequence { get; }
    internal static string XmlInvalidHighSurrogate { get; }
    internal static string XmlInvalidLowSurrogate { get; }
    internal static string XmlInvalidSurrogate { get; }
    internal static string InvalidLocalNameEmpty { get; }
    internal static string XmlArrayTooSmall { get; }
    internal static string XmlArrayTooSmallInput { get; }
    internal static string XmlBadBOM { get; }
    internal static string XmlMaxNameTableCharCountExceeded { get; }
    internal static string XmlBase64DataExpected { get; }
    internal static string XmlCDATAInvalidAtTopLevel { get; }
    internal static string XmlCloseCData { get; }
    internal static string XmlConversionOverflow { get; }
    internal static string XmlDeclarationRequired { get; }
    internal static string XmlDeclMissingVersion { get; }
    internal static string XmlDeclMissing { get; }
    internal static string XmlDeclNotFirst { get; }
    internal static string XmlDictionaryStringIDRange { get; }
    internal static string XmlDictionaryStringIDUndefinedSession { get; }
    internal static string XmlDictionaryStringIDUndefinedStatic { get; }
    internal static string XmlDuplicateAttribute { get; }
    internal static string XmlEmptyNamespaceRequiresNullPrefix { get; }
    internal static string XmlEncodingMismatch { get; }
    internal static string XmlEncodingNotSupported { get; }
    internal static string XmlEndElementExpected { get; }
    internal static string XmlEndElementNoOpenNodes { get; }
    internal static string XmlExpectedEncoding { get; }
    internal static string XmlFoundCData { get; }
    internal static string XmlFoundComment { get; }
    internal static string XmlFoundElement { get; }
    internal static string XmlFoundEndElement { get; }
    internal static string XmlFoundEndOfFile { get; }
    internal static string XmlFoundNodeType { get; }
    internal static string XmlFoundText { get; }
    internal static string XmlFullStartElementExpected { get; }
    internal static string XmlFullStartElementLocalNameNsExpected { get; }
    internal static string XmlFullStartElementNameExpected { get; }
    internal static string XmlIDDefined { get; }
    internal static string XmlKeyAlreadyExists { get; }
    internal static string XmlIllegalOutsideRoot { get; }
    internal static string XmlInvalidBytes { get; }
    internal static string XmlInvalidCharRef { get; }
    internal static string XmlInvalidCommentChars { get; }
    internal static string XmlInvalidDeclaration { get; }
    internal static string XmlInvalidDepth { get; }
    internal static string XmlInvalidEncoding_UTF8 { get; }
    internal static string XmlInvalidFFFE { get; }
    internal static string XmlInvalidFormat { get; }
    internal static string XmlInvalidID { get; }
    internal static string XmlInvalidOperation { get; }
    internal static string XmlInvalidPrefixState { get; }
    internal static string XmlInvalidQualifiedName { get; }
    internal static string XmlInvalidRootData { get; }
    internal static string XmlInvalidStandalone { get; }
    internal static string XmlInvalidUniqueId { get; }
    internal static string XmlInvalidUTF8Bytes { get; }
    internal static string XmlInvalidVersion { get; }
    internal static string XmlInvalidWriteState { get; }
    internal static string XmlInvalidXmlByte { get; }
    internal static string XmlInvalidXmlSpace { get; }
    internal static string XmlLineInfo { get; }
    internal static string XmlMalformedDecl { get; }
    internal static string XmlMaxArrayLengthExceeded { get; }
    internal static string XmlMaxArrayLengthOrMaxItemsQuotaExceeded { get; }
    internal static string XmlMaxBytesPerReadExceeded { get; }
    internal static string XmlMaxDepthExceeded { get; }
    internal static string XmlMaxStringContentLengthExceeded { get; }
    internal static string XmlMethodNotSupported { get; }
    internal static string XmlMissingLowSurrogate { get; }
    internal static string XmlMultipleRootElements { get; }
    internal static string XmlNamespaceNotFound { get; }
    internal static string XmlNestedArraysNotSupported { get; }
    internal static string XmlNoRootElement { get; }
    internal static string XmlOnlyOneRoot { get; }
    internal static string XmlOnlyWhitespace { get; }
    internal static string XmlOnlySingleValue { get; }
    internal static string XmlPrefixBoundToNamespace { get; }
    internal static string XmlProcessingInstructionNotSupported { get; }
    internal static string XmlReservedPrefix { get; }
    internal static string XmlSpaceBetweenAttributes { get; }
    internal static string XmlSpecificBindingNamespace { get; }
    internal static string XmlSpecificBindingPrefix { get; }
    internal static string XmlStartElementLocalNameNsExpected { get; }
    internal static string XmlStartElementNameExpected { get; }
    internal static string XmlTagMismatch { get; }
    internal static string XmlTokenExpected { get; }
    internal static string XmlUndefinedPrefix { get; }
    internal static string XmlUnexpectedEndElement { get; }
    internal static string XmlUnexpectedEndOfFile { get; }
    internal static string XmlWriterClosed { get; }
    internal static string XmlObjectAssignedToIncompatibleInterface { get; }
    internal static string CollectionAssignedToIncompatibleInterface { get; }
    internal static string JsonInvalidBytes { get; }
    internal static string JsonDuplicateMemberNames { get; }
    internal static string JsonUnsupportedForIsReference { get; }
    internal static string SerializationCodeIsMissingForType { get; }
    internal static string InvalidXmlDeserializingExtensionData { get; }
    internal static string InvalidStateInExtensionDataReader { get; }
    internal static string JsonTypeNotSupportedByDataContractJsonSerializer { get; }
    internal static string GetOnlyCollectionMustHaveAddMethod { get; }
    internal static string JsonUnexpectedAttributeValue { get; }
    internal static string JsonInvalidDateTimeString { get; }
    internal static string GenericCallbackException { get; }
    internal static string JsonEncounteredUnexpectedCharacter { get; }
    internal static string JsonOffsetExceedsBufferSize { get; }
    internal static string JsonSizeExceedsRemainingBufferSpace { get; }
    internal static string InvalidCharacterEncountered { get; }
    internal static string JsonInvalidFFFE { get; }
    internal static string JsonDateTimeOutOfRange { get; }
    internal static string JsonWriteArrayNotSupported { get; }
    internal static string JsonMethodNotSupported { get; }
    internal static string JsonNoMatchingStartAttribute { get; }
    internal static string JsonNamespaceMustBeEmpty { get; }
    internal static string JsonEndElementNoOpenNodes { get; }
    internal static string JsonOpenAttributeMustBeClosedFirst { get; }
    internal static string JsonMustSpecifyDataType { get; }
    internal static string JsonXmlProcessingInstructionNotSupported { get; }
    internal static string JsonXmlInvalidDeclaration { get; }
    internal static string JsonInvalidLocalNameEmpty { get; }
    internal static string JsonPrefixMustBeNullOrEmpty { get; }
    internal static string JsonAttributeMustHaveElement { get; }
    internal static string JsonAttributeAlreadyWritten { get; }
    internal static string JsonServerTypeSpecifiedForInvalidDataType { get; }
    internal static string JsonUnexpectedAttributeLocalName { get; }
    internal static string JsonInvalidWriteState { get; }
    internal static string JsonMultipleRootElementsNotAllowedOnWriter { get; }
    internal static string JsonInvalidRootElementName { get; }
    internal static string JsonNodeTypeArrayOrObjectNotSpecified { get; }
    internal static string JsonInvalidItemNameForArrayElement { get; }
    internal static string JsonInvalidStartElementCall { get; }
    internal static string JsonOnlyWhitespace { get; }
    internal static string JsonWriterClosed { get; }
    internal static string JsonCannotWriteStandaloneTextAfterQuotedText { get; }
    internal static string JsonMustUseWriteStringForWritingAttributeValues { get; }
    internal static string JsonInvalidDataTypeSpecifiedForServerType { get; }
    internal static string JsonInvalidMethodBetweenStartEndAttribute { get; }
    internal static string JsonCannotWriteTextAfterNonTextAttribute { get; }
    internal static string JsonNestedArraysNotSupported { get; }
    internal static string JsonEncodingNotSupported { get; }
    internal static string JsonExpectedEncoding { get; }
    internal static string JsonUnexpectedEndOfFile { get; }
    internal static string AssemblyNotFound { get; }
    internal static string ClrTypeNotFound { get; }
    internal static string AttributeNotFound { get; }
    internal static string JsonDuplicateMemberInInput { get; }
    internal static string JsonRequiredMembersNotFound { get; }
    internal static string JsonOneRequiredMemberNotFound { get; }
    internal static string EnumTypeNotSupportedByDataContractJsonSerializer { get; }
    internal static string KeyTypeCannotBeParsedInSimpleDictionary { get; }
    internal static string SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser { get; }
    internal static string FactoryObjectContainsSelfReference { get; }
    internal static string RecursiveCollectionType { get; }
    internal static string UnknownXmlType { get; }
    internal static string DupContractInDataContractSet { get; }
    internal static string DupTypeContractInDataContractSet { get; }
    internal static string GenericTypeNameMismatch { get; }
    internal static string GenericTypeNotExportable { get; }
    internal static string CannotExportNullAssembly { get; }
    internal static string CannotExportNullKnownType { get; }
    internal static string CannotExportNullType { get; }
    internal static string QueryGeneratorPathToMemberNotFound { get; }
    internal static string XmlInvalidStream { get; }
    internal static string ISerializableAssemblyNameSetToZero { get; }
    internal static string RequiresClassDataContractToSetIsISerializable { get; }
    internal static string ISerializableCannotHaveDataContract { get; }
    internal static string SerializationInfo_ConstructorNotFound { get; }
    internal static string ChangingFullTypeNameNotSupported { get; }
    internal static string InterfaceTypeCannotBeCreated { get; }
    internal static string ArraySizeAttributeIncorrect { get; }
    internal static string DuplicateExtensionDataSetMethod { get; }
    internal static string ExtensionDataSetMustReturnVoid { get; }
    internal static string ExtensionDataSetParameterInvalid { get; }
    internal static string OnlyDataContractTypesCanHaveExtensionData { get; }
    internal static string ParseJsonNumberReturnInvalidNumber { get; }
    internal static string CouldNotReadSerializationSchema { get; }
    internal static string MissingSchemaType { get; }
    internal static string InvalidReturnSchemaOnGetSchemaMethod { get; }
    internal static string PlatformNotSupported_MtomEncoding { get; }
    internal static string PlatformNotSupported_NetDataContractSerializer { get; }
    internal static string PlatformNotSupported_IDataContractSurrogate { get; }
    internal static string PlatformNotSupported_SchemaImporter { get; }
    internal static string FactoryTypeNotISerializable { get; }
    internal static string XmlCanonicalizationStarted { get; }
    internal static string XmlCanonicalizationNotStarted { get; }
    internal static string CombinedPrefixNSLength { get; }
    internal static string InvalidInclusivePrefixListCollection { get; }
    internal static string CannotSetTwice { get; }
    internal static string MustBeGreaterThanZero { get; }
    internal static string ReadOnlyClassDeserialization { get; }
    internal static string ReadOnlyCollectionDeserialization { get; }
    internal static string UnknownNullType { get; }
    internal static string AmbiguousReferencedTypes1 { get; }
    internal static string AmbiguousReferencedTypes3 { get; }
    internal static string AmbiguousReferencedCollectionTypes1 { get; }
    internal static string AmbiguousReferencedCollectionTypes3 { get; }
    internal static string ReferencedCollectionTypesCannotContainNull { get; }
    internal static string ReferencedTypeMatchingMessage { get; }
    internal static string ReferencedTypeNotMatchingMessage { get; }
    internal static string ReferencedTypesCannotContainNull { get; }
    internal static string SurrogatesWithGetOnlyCollectionsNotSupported { get; }
    internal static string AbstractElementNotSupported { get; }
    internal static string AbstractTypeNotSupported { get; }
    internal static string AnnotationAttributeNotFound { get; }
    internal static string AnonymousTypeNotSupported { get; }
    internal static string AnyAttributeNotSupported { get; }
    internal static string ArrayItemFormMustBe { get; }
    internal static string ArrayTypeCannotBeImported { get; }
    internal static string BaseTypeNotISerializable { get; }
    internal static string CannotComputeUniqueName { get; }
    internal static string CannotHaveDuplicateAttributeNames { get; }
    internal static string CannotHaveDuplicateElementNames { get; }
    internal static string CannotImportInvalidSchemas { get; }
    internal static string CannotImportNullDataContractName { get; }
    internal static string CannotImportNullSchema { get; }
    internal static string ComplexTypeRestrictionNotSupported { get; }
    internal static string DefaultOnElementNotSupported { get; }
    internal static string DerivedTypeNotISerializable { get; }
    internal static string ElementMaxOccursMustBe { get; }
    internal static string ElementMinOccursMustBe { get; }
    internal static string ElementRefOnLocalElementNotSupported { get; }
    internal static string EnumEnumerationFacetsMustHaveValue { get; }
    internal static string EnumListInAnonymousTypeNotSupported { get; }
    internal static string EnumListMustContainAnonymousType { get; }
    internal static string EnumOnlyEnumerationFacetsSupported { get; }
    internal static string EnumRestrictionInvalid { get; }
    internal static string EnumTypeCannotBeImported { get; }
    internal static string EnumUnionInAnonymousTypeNotSupported { get; }
    internal static string FixedOnElementNotSupported { get; }
    internal static string FormMustBeQualified { get; }
    internal static string GenericAnnotationAttributeNotFound { get; }
    internal static string GenericAnnotationForNestedLevelMustBeIncreasing { get; }
    internal static string GenericAnnotationHasInvalidAttributeValue { get; }
    internal static string GenericAnnotationHasInvalidElement { get; }
    internal static string InvalidAnnotationExpectingText { get; }
    internal static string InvalidClassDerivation { get; }
    internal static string InvalidEmitDefaultAnnotation { get; }
    internal static string InvalidISerializableDerivation { get; }
    internal static string InvalidKeyValueType { get; }
    internal static string InvalidKeyValueTypeNamespace { get; }
    internal static string IsDictionaryFormattedIncorrectly { get; }
    internal static string IsValueTypeFormattedIncorrectly { get; }
    internal static string ISerializableContainsMoreThanOneItems { get; }
    internal static string ISerializableDerivedContainsOneOrMoreItems { get; }
    internal static string ISerializableDoesNotContainAny { get; }
    internal static string ISerializableMustRefFactoryTypeAttribute { get; }
    internal static string ISerializableTypeCannotBeImported { get; }
    internal static string ISerializableWildcardMaxOccursMustBe { get; }
    internal static string ISerializableWildcardMinOccursMustBe { get; }
    internal static string ISerializableWildcardNamespaceInvalid { get; }
    internal static string ISerializableWildcardProcessContentsInvalid { get; }
    internal static string MixedContentNotSupported { get; }
    internal static string MustContainOnlyLocalElements { get; }
    internal static string RedefineNotSupported { get; }
    internal static string RootParticleMustBeSequence { get; }
    internal static string RootSequenceMaxOccursMustBe { get; }
    internal static string RootSequenceMustBeRequired { get; }
    internal static string SimpleContentNotSupported { get; }
    internal static string SimpleTypeRestrictionDoesNotSpecifyBase { get; }
    internal static string SimpleTypeUnionNotSupported { get; }
    internal static string SpecifiedTypeNotFoundInSchema { get; }
    internal static string SubstitutionGroupOnElementNotSupported { get; }
    internal static string TopLevelElementRepresentsDifferentType { get; }
    internal static string TypeCannotBeImported { get; }
    internal static string TypeCannotBeImportedHowToFix { get; }
    internal static string TypeShouldNotContainAttributes { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayExceededSize();
    internal static string get_ArrayExceededSizeAttribute();
    internal static string get_ArrayTypeIsNotSupported_GeneratingCode();
    internal static string get_CannotDeserializeRefAtTopLevel();
    internal static string get_CannotLoadMemberType();
    internal static string get_CannotSerializeObjectWithCycles();
    internal static string get_CanOnlyStoreIntoArgOrLocGot0();
    internal static string get_CharIsInvalidPrimitive();
    internal static string get_CallbackMustReturnVoid();
    internal static string get_CallbackParameterInvalid();
    internal static string get_CallbacksCannotBeVirtualMethods();
    internal static string get_CollectionMustHaveAddMethod();
    internal static string get_CollectionMustHaveGetEnumeratorMethod();
    internal static string get_CollectionMustHaveItemType();
    internal static string get_CollectionTypeCannotBeBuiltIn();
    internal static string get_CollectionTypeCannotHaveDataContract();
    internal static string get_CollectionTypeDoesNotHaveAddMethod();
    internal static string get_CollectionTypeDoesNotHaveDefaultCtor();
    internal static string get_CollectionTypeHasMultipleDefinitionsOfInterface();
    internal static string get_CollectionTypeIsNotIEnumerable();
    internal static string get_DataContractCacheOverflow();
    internal static string get_DataContractNamespaceAlreadySet();
    internal static string get_DataContractNamespaceIsNotValid();
    internal static string get_DataContractNamespaceReserved();
    internal static string get_DataMemberOnEnumField();
    internal static string get_DcTypeNotFoundOnDeserialize();
    internal static string get_DcTypeNotFoundOnSerialize();
    internal static string get_DcTypeNotResolvedOnDeserialize();
    internal static string get_DeserializedObjectWithIdNotFound();
    internal static string get_DupContractInKnownTypes();
    internal static string get_DupKeyValueName();
    internal static string get_DupEnumMemberValue();
    internal static string get_DupMemberName();
    internal static string get_DuplicateAttribute();
    internal static string get_DuplicateCallback();
    internal static string get_EncounteredWithNameNamespace();
    internal static string get_EnumTypeCannotHaveIsReference();
    internal static string get_ErrorDeserializing();
    internal static string get_ErrorInLine();
    internal static string get_ErrorIsStartObject();
    internal static string get_ErrorSerializing();
    internal static string get_ErrorTypeInfo();
    internal static string get_ErrorWriteEndObject();
    internal static string get_ErrorWriteStartObject();
    internal static string get_ExceededMaxItemsQuota();
    internal static string get_ExpectingElement();
    internal static string get_ExpectingElementAtDeserialize();
    internal static string get_ExpectingEnd();
    internal static string get_ExpectingState();
    internal static string get_GenericNameBraceMismatch();
    internal static string get_GenericParameterNotValid();
    internal static string get_InconsistentIsReference();
    internal static string get_IndexedPropertyCannotBeSerialized();
    internal static string get_InvalidCollectionContractItemName();
    internal static string get_InvalidCollectionContractKeyName();
    internal static string get_InvalidCollectionContractKeyNoDictionary();
    internal static string get_InvalidCollectionContractName();
    internal static string get_InvalidCollectionContractNamespace();
    internal static string get_InvalidCollectionContractValueName();
    internal static string get_InvalidCollectionContractValueNoDictionary();
    internal static string get_InvalidCollectionDataContract();
    internal static string get_InvalidCollectionType();
    internal static string get_InvalidDataContractName();
    internal static string get_InvalidDataContractNamespace();
    internal static string get_InvalidDataMemberName();
    internal static string get_InvalidDataNode();
    internal static string get_InvalidEnumBaseType();
    internal static string get_InvalidEnumMemberValue();
    internal static string get_InvalidEnumValueOnRead();
    internal static string get_InvalidEnumValueOnWrite();
    internal static string get_InvalidGetSchemaMethod();
    internal static string get_InvalidGlobalDataContractNamespace();
    internal static string get_InvalidMember();
    internal static string get_InvalidNonNullReturnValueByIsAny();
    internal static string get_InvalidPrimitiveType_Serialization();
    internal static string get_InvalidReturnTypeOnGetSchemaMethod();
    internal static string get_InvalidSizeDefinition();
    internal static string get_InvalidXmlDataContractName();
    internal static string get_InvalidXsIdDefinition();
    internal static string get_InvalidXsRefDefinition();
    internal static string get_IsAnyCannotBeNull();
    internal static string get_IsAnyCannotBeSerializedAsDerivedType();
    internal static string get_IsAnyCannotHaveXmlRoot();
    internal static string get_IsNotAssignableFrom();
    internal static string get_IsRequiredDataMemberOnIsReferenceDataContractType();
    internal static string get_IXmlSerializableCannotHaveCollectionDataContract();
    internal static string get_IXmlSerializableCannotHaveDataContract();
    internal static string get_IXmlSerializableIllegalOperation();
    internal static string get_IXmlSerializableMissingEndElements();
    internal static string get_IXmlSerializableMustHaveDefaultConstructor();
    internal static string get_IXmlSerializableWritePastSubTree();
    internal static string get_KnownTypeAttributeEmptyString();
    internal static string get_KnownTypeAttributeUnknownMethod();
    internal static string get_KnownTypeAttributeReturnType();
    internal static string get_KnownTypeAttributeOneScheme();
    internal static string get_KnownTypeAttributeValidMethodTypes();
    internal static string get_KnownTypeAttributeNoData();
    internal static string get_KnownTypeAttributeMethodNull();
    internal static string get_MaxArrayLengthExceeded();
    internal static string get_MissingGetSchemaMethod();
    internal static string get_MultipleIdDefinition();
    internal static string get_NoConversionPossibleTo();
    internal static string get_NoGetMethodForProperty();
    internal static string get_NoSetMethodForProperty();
    internal static string get_NullKnownType();
    internal static string get_NullValueReturnedForGetOnlyCollection();
    internal static string get_ObjectTableOverflow();
    internal static string get_ParameterCountMismatch();
    internal static string get_PartialTrustCollectionContractAddMethodNotPublic();
    internal static string get_PartialTrustCollectionContractNoPublicConstructor();
    internal static string get_PartialTrustCollectionContractTypeNotPublic();
    internal static string get_PartialTrustDataContractOnSerializingNotPublic();
    internal static string get_PartialTrustDataContractOnSerializedNotPublic();
    internal static string get_PartialTrustDataContractOnDeserializingNotPublic();
    internal static string get_PartialTrustDataContractOnDeserializedNotPublic();
    internal static string get_PartialTrustDataContractFieldGetNotPublic();
    internal static string get_PartialTrustDataContractFieldSetNotPublic();
    internal static string get_PartialTrustDataContractPropertyGetNotPublic();
    internal static string get_PartialTrustDataContractPropertySetNotPublic();
    internal static string get_PartialTrustDataContractTypeNotPublic();
    internal static string get_PartialTrustNonAttributedSerializableTypeNoPublicConstructor();
    internal static string get_PartialTrustIXmlSerializableTypeNotPublic();
    internal static string get_PartialTrustIXmlSerialzableNoPublicConstructor();
    internal static string get_NonAttributedSerializableTypesMustHaveDefaultConstructor();
    internal static string get_AttributedTypesCannotInheritFromNonAttributedSerializableTypes();
    internal static string get_QuotaIsReadOnly();
    internal static string get_QuotaCopyReadOnly();
    internal static string get_RequiredMemberMustBeEmitted();
    internal static string get_ResolveTypeReturnedFalse();
    internal static string get_ResolveTypeReturnedNull();
    internal static string get_SupportForMultidimensionalArraysNotPresent();
    internal static string get_TooManyCollectionContracts();
    internal static string get_TooManyDataContracts();
    internal static string get_TooManyDataMembers();
    internal static string get_TooManyEnumMembers();
    internal static string get_TooManyIgnoreDataMemberAttributes();
    internal static string get_TypeNotSerializable();
    internal static string get_UnexpectedContractType();
    internal static string get_UnexpectedElementExpectingElements();
    internal static string get_UnexpectedEndOfFile();
    internal static string get_UnknownConstantType();
    internal static string get_ValueTypeCannotBeNull();
    internal static string get_ValueTypeCannotHaveBaseType();
    internal static string get_ValueTypeCannotHaveId();
    internal static string get_ValueTypeCannotHaveIsReference();
    internal static string get_ValueTypeCannotHaveRef();
    internal static string get_XmlElementAttributes();
    internal static string get_XmlForObjectCannotHaveContent();
    internal static string get_XmlInvalidConversion();
    internal static string get_XmlInvalidConversionWithoutValue();
    internal static string get_XmlStartElementExpected();
    internal static string get_XmlWriterMustBeInElement();
    internal static string get_NonOptionalFieldMemberOnIsReferenceSerializableType();
    internal static string get_OffsetExceedsBufferSize();
    internal static string get_SizeExceedsRemainingBufferSpace();
    internal static string get_ValueMustBeInRange();
    internal static string get_XmlArrayTooSmallOutput();
    internal static string get_XmlAsyncIsRunningException();
    internal static string get_XmlInvalidBase64Length();
    internal static string get_XmlInvalidBase64Sequence();
    internal static string get_XmlInvalidBinHexLength();
    internal static string get_XmlInvalidBinHexSequence();
    internal static string get_XmlInvalidHighSurrogate();
    internal static string get_XmlInvalidLowSurrogate();
    internal static string get_XmlInvalidSurrogate();
    internal static string get_InvalidLocalNameEmpty();
    internal static string get_XmlArrayTooSmall();
    internal static string get_XmlArrayTooSmallInput();
    internal static string get_XmlBadBOM();
    internal static string get_XmlMaxNameTableCharCountExceeded();
    internal static string get_XmlBase64DataExpected();
    internal static string get_XmlCDATAInvalidAtTopLevel();
    internal static string get_XmlCloseCData();
    internal static string get_XmlConversionOverflow();
    internal static string get_XmlDeclarationRequired();
    internal static string get_XmlDeclMissingVersion();
    internal static string get_XmlDeclMissing();
    internal static string get_XmlDeclNotFirst();
    internal static string get_XmlDictionaryStringIDRange();
    internal static string get_XmlDictionaryStringIDUndefinedSession();
    internal static string get_XmlDictionaryStringIDUndefinedStatic();
    internal static string get_XmlDuplicateAttribute();
    internal static string get_XmlEmptyNamespaceRequiresNullPrefix();
    internal static string get_XmlEncodingMismatch();
    internal static string get_XmlEncodingNotSupported();
    internal static string get_XmlEndElementExpected();
    internal static string get_XmlEndElementNoOpenNodes();
    internal static string get_XmlExpectedEncoding();
    internal static string get_XmlFoundCData();
    internal static string get_XmlFoundComment();
    internal static string get_XmlFoundElement();
    internal static string get_XmlFoundEndElement();
    internal static string get_XmlFoundEndOfFile();
    internal static string get_XmlFoundNodeType();
    internal static string get_XmlFoundText();
    internal static string get_XmlFullStartElementExpected();
    internal static string get_XmlFullStartElementLocalNameNsExpected();
    internal static string get_XmlFullStartElementNameExpected();
    internal static string get_XmlIDDefined();
    internal static string get_XmlKeyAlreadyExists();
    internal static string get_XmlIllegalOutsideRoot();
    internal static string get_XmlInvalidBytes();
    internal static string get_XmlInvalidCharRef();
    internal static string get_XmlInvalidCommentChars();
    internal static string get_XmlInvalidDeclaration();
    internal static string get_XmlInvalidDepth();
    internal static string get_XmlInvalidEncoding_UTF8();
    internal static string get_XmlInvalidFFFE();
    internal static string get_XmlInvalidFormat();
    internal static string get_XmlInvalidID();
    internal static string get_XmlInvalidOperation();
    internal static string get_XmlInvalidPrefixState();
    internal static string get_XmlInvalidQualifiedName();
    internal static string get_XmlInvalidRootData();
    internal static string get_XmlInvalidStandalone();
    internal static string get_XmlInvalidUniqueId();
    internal static string get_XmlInvalidUTF8Bytes();
    internal static string get_XmlInvalidVersion();
    internal static string get_XmlInvalidWriteState();
    internal static string get_XmlInvalidXmlByte();
    internal static string get_XmlInvalidXmlSpace();
    internal static string get_XmlLineInfo();
    internal static string get_XmlMalformedDecl();
    internal static string get_XmlMaxArrayLengthExceeded();
    internal static string get_XmlMaxArrayLengthOrMaxItemsQuotaExceeded();
    internal static string get_XmlMaxBytesPerReadExceeded();
    internal static string get_XmlMaxDepthExceeded();
    internal static string get_XmlMaxStringContentLengthExceeded();
    internal static string get_XmlMethodNotSupported();
    internal static string get_XmlMissingLowSurrogate();
    internal static string get_XmlMultipleRootElements();
    internal static string get_XmlNamespaceNotFound();
    internal static string get_XmlNestedArraysNotSupported();
    internal static string get_XmlNoRootElement();
    internal static string get_XmlOnlyOneRoot();
    internal static string get_XmlOnlyWhitespace();
    internal static string get_XmlOnlySingleValue();
    internal static string get_XmlPrefixBoundToNamespace();
    internal static string get_XmlProcessingInstructionNotSupported();
    internal static string get_XmlReservedPrefix();
    internal static string get_XmlSpaceBetweenAttributes();
    internal static string get_XmlSpecificBindingNamespace();
    internal static string get_XmlSpecificBindingPrefix();
    internal static string get_XmlStartElementLocalNameNsExpected();
    internal static string get_XmlStartElementNameExpected();
    internal static string get_XmlTagMismatch();
    internal static string get_XmlTokenExpected();
    internal static string get_XmlUndefinedPrefix();
    internal static string get_XmlUnexpectedEndElement();
    internal static string get_XmlUnexpectedEndOfFile();
    internal static string get_XmlWriterClosed();
    internal static string get_XmlObjectAssignedToIncompatibleInterface();
    internal static string get_CollectionAssignedToIncompatibleInterface();
    internal static string get_JsonInvalidBytes();
    internal static string get_JsonDuplicateMemberNames();
    internal static string get_JsonUnsupportedForIsReference();
    internal static string get_SerializationCodeIsMissingForType();
    internal static string get_InvalidXmlDeserializingExtensionData();
    internal static string get_InvalidStateInExtensionDataReader();
    internal static string get_JsonTypeNotSupportedByDataContractJsonSerializer();
    internal static string get_GetOnlyCollectionMustHaveAddMethod();
    internal static string get_JsonUnexpectedAttributeValue();
    internal static string get_JsonInvalidDateTimeString();
    internal static string get_GenericCallbackException();
    internal static string get_JsonEncounteredUnexpectedCharacter();
    internal static string get_JsonOffsetExceedsBufferSize();
    internal static string get_JsonSizeExceedsRemainingBufferSpace();
    internal static string get_InvalidCharacterEncountered();
    internal static string get_JsonInvalidFFFE();
    internal static string get_JsonDateTimeOutOfRange();
    internal static string get_JsonWriteArrayNotSupported();
    internal static string get_JsonMethodNotSupported();
    internal static string get_JsonNoMatchingStartAttribute();
    internal static string get_JsonNamespaceMustBeEmpty();
    internal static string get_JsonEndElementNoOpenNodes();
    internal static string get_JsonOpenAttributeMustBeClosedFirst();
    internal static string get_JsonMustSpecifyDataType();
    internal static string get_JsonXmlProcessingInstructionNotSupported();
    internal static string get_JsonXmlInvalidDeclaration();
    internal static string get_JsonInvalidLocalNameEmpty();
    internal static string get_JsonPrefixMustBeNullOrEmpty();
    internal static string get_JsonAttributeMustHaveElement();
    internal static string get_JsonAttributeAlreadyWritten();
    internal static string get_JsonServerTypeSpecifiedForInvalidDataType();
    internal static string get_JsonUnexpectedAttributeLocalName();
    internal static string get_JsonInvalidWriteState();
    internal static string get_JsonMultipleRootElementsNotAllowedOnWriter();
    internal static string get_JsonInvalidRootElementName();
    internal static string get_JsonNodeTypeArrayOrObjectNotSpecified();
    internal static string get_JsonInvalidItemNameForArrayElement();
    internal static string get_JsonInvalidStartElementCall();
    internal static string get_JsonOnlyWhitespace();
    internal static string get_JsonWriterClosed();
    internal static string get_JsonCannotWriteStandaloneTextAfterQuotedText();
    internal static string get_JsonMustUseWriteStringForWritingAttributeValues();
    internal static string get_JsonInvalidDataTypeSpecifiedForServerType();
    internal static string get_JsonInvalidMethodBetweenStartEndAttribute();
    internal static string get_JsonCannotWriteTextAfterNonTextAttribute();
    internal static string get_JsonNestedArraysNotSupported();
    internal static string get_JsonEncodingNotSupported();
    internal static string get_JsonExpectedEncoding();
    internal static string get_JsonUnexpectedEndOfFile();
    internal static string get_AssemblyNotFound();
    internal static string get_ClrTypeNotFound();
    internal static string get_AttributeNotFound();
    internal static string get_JsonDuplicateMemberInInput();
    internal static string get_JsonRequiredMembersNotFound();
    internal static string get_JsonOneRequiredMemberNotFound();
    internal static string get_EnumTypeNotSupportedByDataContractJsonSerializer();
    internal static string get_KeyTypeCannotBeParsedInSimpleDictionary();
    internal static string get_SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser();
    internal static string get_FactoryObjectContainsSelfReference();
    internal static string get_RecursiveCollectionType();
    internal static string get_UnknownXmlType();
    internal static string get_DupContractInDataContractSet();
    internal static string get_DupTypeContractInDataContractSet();
    internal static string get_GenericTypeNameMismatch();
    internal static string get_GenericTypeNotExportable();
    internal static string get_CannotExportNullAssembly();
    internal static string get_CannotExportNullKnownType();
    internal static string get_CannotExportNullType();
    internal static string get_QueryGeneratorPathToMemberNotFound();
    internal static string get_XmlInvalidStream();
    internal static string get_ISerializableAssemblyNameSetToZero();
    internal static string get_RequiresClassDataContractToSetIsISerializable();
    internal static string get_ISerializableCannotHaveDataContract();
    internal static string get_SerializationInfo_ConstructorNotFound();
    internal static string get_ChangingFullTypeNameNotSupported();
    internal static string get_InterfaceTypeCannotBeCreated();
    internal static string get_ArraySizeAttributeIncorrect();
    internal static string get_DuplicateExtensionDataSetMethod();
    internal static string get_ExtensionDataSetMustReturnVoid();
    internal static string get_ExtensionDataSetParameterInvalid();
    internal static string get_OnlyDataContractTypesCanHaveExtensionData();
    internal static string get_ParseJsonNumberReturnInvalidNumber();
    internal static string get_CouldNotReadSerializationSchema();
    internal static string get_MissingSchemaType();
    internal static string get_InvalidReturnSchemaOnGetSchemaMethod();
    internal static string get_PlatformNotSupported_MtomEncoding();
    internal static string get_PlatformNotSupported_NetDataContractSerializer();
    internal static string get_PlatformNotSupported_IDataContractSurrogate();
    internal static string get_PlatformNotSupported_SchemaImporter();
    internal static string get_FactoryTypeNotISerializable();
    internal static string get_XmlCanonicalizationStarted();
    internal static string get_XmlCanonicalizationNotStarted();
    internal static string get_CombinedPrefixNSLength();
    internal static string get_InvalidInclusivePrefixListCollection();
    internal static string get_CannotSetTwice();
    internal static string get_MustBeGreaterThanZero();
    internal static string get_ReadOnlyClassDeserialization();
    internal static string get_ReadOnlyCollectionDeserialization();
    internal static string get_UnknownNullType();
    internal static string get_AmbiguousReferencedTypes1();
    internal static string get_AmbiguousReferencedTypes3();
    internal static string get_AmbiguousReferencedCollectionTypes1();
    internal static string get_AmbiguousReferencedCollectionTypes3();
    internal static string get_ReferencedCollectionTypesCannotContainNull();
    internal static string get_ReferencedTypeMatchingMessage();
    internal static string get_ReferencedTypeNotMatchingMessage();
    internal static string get_ReferencedTypesCannotContainNull();
    internal static string get_SurrogatesWithGetOnlyCollectionsNotSupported();
    internal static string get_AbstractElementNotSupported();
    internal static string get_AbstractTypeNotSupported();
    internal static string get_AnnotationAttributeNotFound();
    internal static string get_AnonymousTypeNotSupported();
    internal static string get_AnyAttributeNotSupported();
    internal static string get_ArrayItemFormMustBe();
    internal static string get_ArrayTypeCannotBeImported();
    internal static string get_BaseTypeNotISerializable();
    internal static string get_CannotComputeUniqueName();
    internal static string get_CannotHaveDuplicateAttributeNames();
    internal static string get_CannotHaveDuplicateElementNames();
    internal static string get_CannotImportInvalidSchemas();
    internal static string get_CannotImportNullDataContractName();
    internal static string get_CannotImportNullSchema();
    internal static string get_ComplexTypeRestrictionNotSupported();
    internal static string get_DefaultOnElementNotSupported();
    internal static string get_DerivedTypeNotISerializable();
    internal static string get_ElementMaxOccursMustBe();
    internal static string get_ElementMinOccursMustBe();
    internal static string get_ElementRefOnLocalElementNotSupported();
    internal static string get_EnumEnumerationFacetsMustHaveValue();
    internal static string get_EnumListInAnonymousTypeNotSupported();
    internal static string get_EnumListMustContainAnonymousType();
    internal static string get_EnumOnlyEnumerationFacetsSupported();
    internal static string get_EnumRestrictionInvalid();
    internal static string get_EnumTypeCannotBeImported();
    internal static string get_EnumUnionInAnonymousTypeNotSupported();
    internal static string get_FixedOnElementNotSupported();
    internal static string get_FormMustBeQualified();
    internal static string get_GenericAnnotationAttributeNotFound();
    internal static string get_GenericAnnotationForNestedLevelMustBeIncreasing();
    internal static string get_GenericAnnotationHasInvalidAttributeValue();
    internal static string get_GenericAnnotationHasInvalidElement();
    internal static string get_InvalidAnnotationExpectingText();
    internal static string get_InvalidClassDerivation();
    internal static string get_InvalidEmitDefaultAnnotation();
    internal static string get_InvalidISerializableDerivation();
    internal static string get_InvalidKeyValueType();
    internal static string get_InvalidKeyValueTypeNamespace();
    internal static string get_IsDictionaryFormattedIncorrectly();
    internal static string get_IsValueTypeFormattedIncorrectly();
    internal static string get_ISerializableContainsMoreThanOneItems();
    internal static string get_ISerializableDerivedContainsOneOrMoreItems();
    internal static string get_ISerializableDoesNotContainAny();
    internal static string get_ISerializableMustRefFactoryTypeAttribute();
    internal static string get_ISerializableTypeCannotBeImported();
    internal static string get_ISerializableWildcardMaxOccursMustBe();
    internal static string get_ISerializableWildcardMinOccursMustBe();
    internal static string get_ISerializableWildcardNamespaceInvalid();
    internal static string get_ISerializableWildcardProcessContentsInvalid();
    internal static string get_MixedContentNotSupported();
    internal static string get_MustContainOnlyLocalElements();
    internal static string get_RedefineNotSupported();
    internal static string get_RootParticleMustBeSequence();
    internal static string get_RootSequenceMaxOccursMustBe();
    internal static string get_RootSequenceMustBeRequired();
    internal static string get_SimpleContentNotSupported();
    internal static string get_SimpleTypeRestrictionDoesNotSpecifyBase();
    internal static string get_SimpleTypeUnionNotSupported();
    internal static string get_SpecifiedTypeNotFoundInSchema();
    internal static string get_SubstitutionGroupOnElementNotSupported();
    internal static string get_TopLevelElementRepresentsDifferentType();
    internal static string get_TypeCannotBeImported();
    internal static string get_TypeCannotBeImportedHowToFix();
    internal static string get_TypeShouldNotContainAttributes();
}
internal class System.Text.Base64Encoding : Encoding {
    private static string Val2Char;
    private static ReadOnlySpan`1<byte> Char2val { get; }
    private static ReadOnlySpan`1<byte> Val2byte { get; }
    private static ReadOnlySpan`1<byte> get_Char2val();
    private static ReadOnlySpan`1<byte> get_Val2byte();
    public virtual int GetMaxByteCount(int charCount);
    private static bool IsValidLeadBytes(int v1, int v2, int v3, int v4);
    private static bool IsValidTailBytes(int v3, int v4);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public int GetBytes(Byte[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Byte[] chars, int charIndex);
}
internal class System.Text.BinHexEncoding : Encoding {
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F6DD43EEA644F37FBD420BF6C4F76D7CBF00A201A3A5DFAA2DE4DAED4B5EFB477__FullSRSInternalsVisibleRegex_0 : Regex {
    internal static <RegexGenerator_g>F6DD43EEA644F37FBD420BF6C4F76D7CBF00A201A3A5DFAA2DE4DAED4B5EFB477__FullSRSInternalsVisibleRegex_0 Instance;
    private static <RegexGenerator_g>F6DD43EEA644F37FBD420BF6C4F76D7CBF00A201A3A5DFAA2DE4DAED4B5EFB477__FullSRSInternalsVisibleRegex_0();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F6DD43EEA644F37FBD420BF6C4F76D7CBF00A201A3A5DFAA2DE4DAED4B5EFB477__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    private static <RegexGenerator_g>F6DD43EEA644F37FBD420BF6C4F76D7CBF00A201A3A5DFAA2DE4DAED4B5EFB477__Utilities();
}
[IsReadOnlyAttribute]
internal class System.Text.SurrogateChar : ValueType {
    private char _lowChar;
    private char _highChar;
    public static int MinValue;
    public static int MaxValue;
    private static char surHighMin;
    private static char surHighMax;
    private static char surLowMin;
    private static char surLowMax;
    public char LowChar { get; }
    public char HighChar { get; }
    public int Char { get; }
    public SurrogateChar(int ch);
    public SurrogateChar(char lowChar, char highChar);
    public char get_LowChar();
    public char get_HighChar();
    public int get_Char();
}
internal abstract class System.Xml.ArrayHelper`2 : object {
    public TArray[] ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, int maxArrayLength);
    public void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, XmlDictionaryReader reader);
    protected abstract virtual int ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
    protected abstract virtual void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, bool> {
    public static BooleanArrayHelperWithDictionaryString Instance;
    private static BooleanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithString : ArrayHelper`2<string, bool> {
    public static BooleanArrayHelperWithString Instance;
    private static BooleanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
}
[IsReadOnlyAttribute]
internal class System.Xml.BytesWithOffset : ValueType {
    private Byte[] _bytes;
    private int _offset;
    public Byte[] Bytes { get; }
    public int Offset { get; }
    public BytesWithOffset(Byte[] bytes, int offset);
    public Byte[] get_Bytes();
    public int get_Offset();
}
internal class System.Xml.DateTimeArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, DateTime> {
    public static DateTimeArrayHelperWithDictionaryString Instance;
    private static DateTimeArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DateTimeArrayHelperWithString : ArrayHelper`2<string, DateTime> {
    public static DateTimeArrayHelperWithString Instance;
    private static DateTimeArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, decimal> {
    public static DecimalArrayHelperWithDictionaryString Instance;
    private static DecimalArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithString : ArrayHelper`2<string, decimal> {
    public static DecimalArrayHelperWithString Instance;
    private static DecimalArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, double> {
    public static DoubleArrayHelperWithDictionaryString Instance;
    private static DoubleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithString : ArrayHelper`2<string, double> {
    public static DoubleArrayHelperWithString Instance;
    private static DoubleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.EncodingStreamWrapper : Stream {
    private static int BufferLength;
    private static Byte[] s_encodingUTF8;
    private static Byte[] s_encodingUnicode;
    private static Byte[] s_encodingUnicodeLE;
    private static Byte[] s_encodingUnicodeBE;
    private SupportedEncoding _encodingCode;
    private Encoding _encoding;
    private Encoder _enc;
    private Decoder _dec;
    private bool _isReading;
    private Stream _stream;
    private Char[] _chars;
    private Byte[] _bytes;
    private int _byteOffset;
    private int _byteCount;
    private Byte[] _byteBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public EncodingStreamWrapper(Stream stream, Encoding encoding);
    public EncodingStreamWrapper(Stream stream, Encoding encoding, bool emitBOM);
    private static EncodingStreamWrapper();
    [MemberNotNullAttribute("_encoding")]
private void SetReadDocumentEncoding(SupportedEncoding e);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static Encoding GetSafeEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    [MemberNotNullAttribute("_bytes")]
private SupportedEncoding ReadBOMEncoding(bool notOutOfBand);
    private static SupportedEncoding ReadBOMEncoding(byte b1, byte b2, byte b3, byte b4, bool notOutOfBand, Int32& preserve);
    private void FillBuffer(int count);
    [MemberNotNullAttribute("_bytes")]
[MemberNotNullAttribute("_chars")]
private void EnsureBuffers();
    [MemberNotNullAttribute("_bytes")]
private void EnsureByteBuffer();
    private static void CheckUTF8DeclarationEncoding(Byte[] buffer, int offset, int count, SupportedEncoding e, SupportedEncoding expectedEnc);
    private static bool CompareCaseInsensitive(Byte[] key, Byte[] buffer, int offset);
    private static bool IsWhitespace(byte ch);
    internal static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private static void ThrowEncodingMismatch(string declEnc, SupportedEncoding enc);
    private static void ThrowEncodingMismatch(string declEnc, string docEnc);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    private void CleanupCharBreak();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void SetLength(long value);
}
internal class System.Xml.GuidArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, Guid> {
    public static GuidArrayHelperWithDictionaryString Instance;
    private static GuidArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
}
internal class System.Xml.GuidArrayHelperWithString : ArrayHelper`2<string, Guid> {
    public static GuidArrayHelperWithString Instance;
    private static GuidArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
}
[NullableContextAttribute("1")]
public interface System.Xml.IFragmentCapableXmlDictionaryWriter {
    public bool CanFragment { get; }
    public abstract virtual bool get_CanFragment();
    public abstract virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public abstract virtual void EndFragment();
    public abstract virtual void WriteFragment(Byte[] buffer, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, short> {
    public static Int16ArrayHelperWithDictionaryString Instance;
    private static Int16ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithString : ArrayHelper`2<string, short> {
    public static Int16ArrayHelperWithString Instance;
    private static Int16ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, int> {
    public static Int32ArrayHelperWithDictionaryString Instance;
    private static Int32ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithString : ArrayHelper`2<string, int> {
    public static Int32ArrayHelperWithString Instance;
    private static Int32ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, long> {
    public static Int64ArrayHelperWithDictionaryString Instance;
    private static Int64ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithString : ArrayHelper`2<string, long> {
    public static Int64ArrayHelperWithString Instance;
    private static Int64ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
}
[NullableContextAttribute("1")]
public interface System.Xml.IStreamProvider {
    public abstract virtual Stream GetStream();
    public abstract virtual void ReleaseStream(Stream stream);
}
[NullableContextAttribute("2")]
public interface System.Xml.IXmlBinaryReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
}
[NullableContextAttribute("2")]
public interface System.Xml.IXmlBinaryWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlDictionary {
    public abstract virtual bool TryLookup(string value, XmlDictionaryString& result);
    [NullableContextAttribute("2")]
public abstract virtual bool TryLookup(int key, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlTextReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlTextWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
public class System.Xml.OnXmlDictionaryReaderClose : MulticastDelegate {
    public OnXmlDictionaryReaderClose(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(XmlDictionaryReader reader);
    public virtual IAsyncResult BeginInvoke(XmlDictionaryReader reader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xml.PrefixHandle : object {
    private XmlBufferReader _bufferReader;
    private PrefixHandleType _type;
    private int _offset;
    private int _length;
    private static String[] s_prefixStrings;
    private static Byte[] s_prefixBuffer;
    public bool IsEmpty { get; }
    public bool IsXmlns { get; }
    public bool IsXml { get; }
    public PrefixHandle(XmlBufferReader bufferReader);
    private static PrefixHandle();
    public void SetValue(PrefixHandleType type);
    public void SetValue(PrefixHandle prefix);
    public void SetValue(int offset, int length);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public bool get_IsXml();
    public bool TryGetShortPrefix(PrefixHandleType& type);
    public static string GetString(PrefixHandleType type);
    public static PrefixHandleType GetAlphaPrefix(int index);
    public static Byte[] GetString(PrefixHandleType type, Int32& offset, Int32& length);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public int CompareTo(PrefixHandle that);
    public sealed virtual bool Equals(PrefixHandle prefix2);
    private bool Equals2(string prefix2);
    private bool Equals2(XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, string prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, string prefix2);
    public static bool op_Equality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, PrefixHandle prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, PrefixHandle prefix2);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal enum System.Xml.PrefixHandleType : Enum {
    public int value__;
    public static PrefixHandleType Empty;
    public static PrefixHandleType A;
    public static PrefixHandleType B;
    public static PrefixHandleType C;
    public static PrefixHandleType D;
    public static PrefixHandleType E;
    public static PrefixHandleType F;
    public static PrefixHandleType G;
    public static PrefixHandleType H;
    public static PrefixHandleType I;
    public static PrefixHandleType J;
    public static PrefixHandleType K;
    public static PrefixHandleType L;
    public static PrefixHandleType M;
    public static PrefixHandleType N;
    public static PrefixHandleType O;
    public static PrefixHandleType P;
    public static PrefixHandleType Q;
    public static PrefixHandleType R;
    public static PrefixHandleType S;
    public static PrefixHandleType T;
    public static PrefixHandleType U;
    public static PrefixHandleType V;
    public static PrefixHandleType W;
    public static PrefixHandleType X;
    public static PrefixHandleType Y;
    public static PrefixHandleType Z;
    public static PrefixHandleType Buffer;
    public static PrefixHandleType Max;
}
internal class System.Xml.SingleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, float> {
    public static SingleArrayHelperWithDictionaryString Instance;
    private static SingleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.SingleArrayHelperWithString : ArrayHelper`2<string, float> {
    public static SingleArrayHelperWithString Instance;
    private static SingleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.StringHandle : object {
    private XmlBufferReader _bufferReader;
    private StringHandleType _type;
    private int _key;
    private int _offset;
    private int _length;
    private static String[] s_constStrings;
    public bool IsEmpty { get; }
    public bool IsXmlns { get; }
    public StringHandle(XmlBufferReader bufferReader);
    private static StringHandle();
    public void SetValue(int offset, int length);
    public void SetConstantValue(StringHandleConstStringType constStringType);
    public void SetValue(int offset, int length, bool escaped);
    public void SetValue(int key);
    public void SetValue(StringHandle value);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public void ToPrefixHandle(PrefixHandle prefix);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public virtual string ToString();
    private bool Equals2(int key2, XmlBufferReader bufferReader2);
    private bool Equals2(XmlDictionaryString xmlString2);
    private bool Equals2(string s2);
    private bool Equals2(int offset2, int length2, XmlBufferReader bufferReader2);
    public sealed virtual bool Equals(StringHandle other);
    public static bool op_Equality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Inequality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Equality(StringHandle s1, string s2);
    public static bool op_Inequality(StringHandle s1, string s2);
    public static bool op_Equality(StringHandle s1, StringHandle s2);
    public static bool op_Inequality(StringHandle s1, StringHandle s2);
    public int CompareTo(StringHandle that);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum System.Xml.StringHandleConstStringType : Enum {
    public int value__;
    public static StringHandleConstStringType Type;
    public static StringHandleConstStringType Root;
    public static StringHandleConstStringType Item;
}
internal class System.Xml.TimeSpanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, TimeSpan> {
    public static TimeSpanArrayHelperWithDictionaryString Instance;
    private static TimeSpanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
internal class System.Xml.TimeSpanArrayHelperWithString : ArrayHelper`2<string, TimeSpan> {
    public static TimeSpanArrayHelperWithString Instance;
    private static TimeSpanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.UniqueId : object {
    private long _idLow;
    private long _idHigh;
    private string _s;
    private static int guidLength;
    private static int uuidLength;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<short> Char2val { get; }
    public int CharArrayLength { get; }
    public bool IsGuid { get; }
    public UniqueId(Guid guid);
    public UniqueId(Byte[] guid);
    public UniqueId(Byte[] guid, int offset);
    public UniqueId(string value);
    public UniqueId(Char[] chars, int offset, int count);
    private static ReadOnlySpan`1<short> get_Char2val();
    public int get_CharArrayLength();
    private int UnsafeDecode(Int16* char2val, char ch1, char ch2);
    private static void UnsafeEncode(byte b, Char* pch);
    public bool get_IsGuid();
    private void UnsafeParse(Char* chars, int charCount);
    public int ToCharArray(Char[] chars, int offset);
    private void ToSpan(Span`1<char> chars);
    public bool TryGetGuid(Guid& guid);
    public bool TryGetGuid(Byte[] buffer, int offset);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(UniqueId id1, UniqueId id2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(UniqueId id1, UniqueId id2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private long UnsafeGetInt64(Byte* pb);
    private int UnsafeGetInt32(Byte* pb);
    private void UnsafeSetInt64(long value, Byte* pb);
    private void UnsafeSetInt32(int value, Byte* pb);
}
internal class System.Xml.ValueHandle : object {
    private XmlBufferReader _bufferReader;
    private ValueHandleType _type;
    private int _offset;
    private int _length;
    private static String[] s_constStrings;
    public ValueHandle(XmlBufferReader bufferReader);
    private static ValueHandle();
    public void SetConstantValue(ValueHandleConstStringType constStringType);
    public void SetValue(ValueHandleType type);
    public void SetDictionaryValue(int key);
    public void SetCharValue(int ch);
    public void SetQNameValue(int prefix, int key);
    public void SetValue(ValueHandleType type, int offset, int length);
    public bool IsWhitespace();
    public Type ToType();
    public bool ToBoolean();
    public int ToInt();
    public long ToLong();
    public ulong ToULong();
    public float ToSingle();
    public double ToDouble();
    public decimal ToDecimal();
    public DateTime ToDateTime();
    public UniqueId ToUniqueId();
    public TimeSpan ToTimeSpan();
    public Guid ToGuid();
    public virtual string ToString();
    public Byte[] ToByteArray();
    public string GetString();
    public bool Equals2(string str, bool checkLower);
    public void Sign(XmlSigningNodeWriter writer);
    public Object[] ToList();
    public object ToObject();
    public bool TryReadBase64(Byte[] buffer, int offset, int count, Int32& actual);
    public bool TryReadChars(Char[] chars, int offset, int count, Int32& actual);
    private bool TryReadUnicodeChars(Char[] chars, int offset, int count, Int32& actual);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public bool TryGetByteArrayLength(Int32& length);
    private string GetCharsText();
    private string GetUnicodeCharsText();
    private string GetEscapedCharsText();
    private string GetCharText();
    private int GetChar();
    private int GetInt8();
    private int GetInt16();
    private int GetInt32();
    private long GetInt64();
    private ulong GetUInt64();
    private float GetSingle();
    private double GetDouble();
    private decimal GetDecimal();
    private UniqueId GetUniqueId();
    private Guid GetGuid();
    private void GetBase64(Byte[] buffer, int offset, int count);
    private XmlDictionaryString GetDictionaryString();
    private string GetQNameDictionaryText();
}
internal enum System.Xml.ValueHandleConstStringType : Enum {
    public int value__;
    public static ValueHandleConstStringType String;
    public static ValueHandleConstStringType Number;
    public static ValueHandleConstStringType Array;
    public static ValueHandleConstStringType Object;
    public static ValueHandleConstStringType Boolean;
    public static ValueHandleConstStringType Null;
}
internal static class System.Xml.ValueHandleLength : object {
    public static int Int8;
    public static int Int16;
    public static int Int32;
    public static int Int64;
    public static int UInt64;
    public static int Single;
    public static int Double;
    public static int Decimal;
    public static int DateTime;
    public static int TimeSpan;
    public static int Guid;
    public static int UniqueId;
}
internal enum System.Xml.ValueHandleType : Enum {
    public int value__;
    public static ValueHandleType Empty;
    public static ValueHandleType True;
    public static ValueHandleType False;
    public static ValueHandleType Zero;
    public static ValueHandleType One;
    public static ValueHandleType Int8;
    public static ValueHandleType Int16;
    public static ValueHandleType Int32;
    public static ValueHandleType Int64;
    public static ValueHandleType UInt64;
    public static ValueHandleType Single;
    public static ValueHandleType Double;
    public static ValueHandleType Decimal;
    public static ValueHandleType DateTime;
    public static ValueHandleType TimeSpan;
    public static ValueHandleType Guid;
    public static ValueHandleType UniqueId;
    public static ValueHandleType UTF8;
    public static ValueHandleType EscapedUTF8;
    public static ValueHandleType Base64;
    public static ValueHandleType Dictionary;
    public static ValueHandleType List;
    public static ValueHandleType Char;
    public static ValueHandleType Unicode;
    public static ValueHandleType QName;
    public static ValueHandleType ConstString;
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Xml.XmlBaseReader : XmlDictionaryReader {
    private XmlBufferReader _bufferReader;
    private XmlNode _node;
    private NamespaceManager _nsMgr;
    private XmlElementNode[] _elementNodes;
    private XmlAttributeNode[] _attributeNodes;
    private XmlAtomicTextNode _atomicTextNode;
    private int _depth;
    private int _attributeCount;
    private int _attributeStart;
    private XmlDictionaryReaderQuotas _quotas;
    private QuotaNameTable _nameTable;
    private XmlDeclarationNode _declarationNode;
    private XmlComplexTextNode _complexTextNode;
    private XmlWhitespaceTextNode _whitespaceTextNode;
    private XmlCDataNode _cdataNode;
    private XmlCommentNode _commentNode;
    private XmlElementNode _rootElementNode;
    private int _attributeIndex;
    private Char[] _chars;
    private string _prefix;
    private string _localName;
    private string _ns;
    private string _value;
    private int _trailCharCount;
    private int _trailByteCount;
    private Char[] _trailChars;
    private Byte[] _trailBytes;
    private bool _rootElement;
    private bool _readingElement;
    private AttributeSorter _attributeSorter;
    private static XmlInitialNode s_initialNode;
    private static XmlEndOfFileNode s_endOfFileNode;
    private static XmlClosedNode s_closedNode;
    private static string xmlns;
    private static string xml;
    private static string xmlnsNamespace;
    private static string xmlNamespace;
    private XmlSigningNodeWriter _signingWriter;
    private bool _signing;
    protected XmlBufferReader BufferReader { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    protected XmlNode Node { get; }
    protected XmlElementNode ElementNode { get; }
    protected bool OutsideRootElement { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public string BaseURI { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public int AttributeCount { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public bool CanCanonicalize { get; }
    protected bool Signing { get; }
    private static XmlBaseReader();
    protected XmlBufferReader get_BufferReader();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    protected XmlNode get_Node();
    protected void MoveToNode(XmlNode node);
    protected void MoveToInitial(XmlDictionaryReaderQuotas quotas);
    protected XmlDeclarationNode MoveToDeclaration();
    private bool CheckStandalone(int attr);
    private bool CheckDeclAttribute(int index, string localName, string value, bool checkLower, string valueSR);
    protected XmlCommentNode MoveToComment();
    protected XmlCDataNode MoveToCData();
    protected XmlAtomicTextNode MoveToAtomicText();
    protected XmlComplexTextNode MoveToComplexText();
    protected XmlTextNode MoveToWhitespaceText();
    protected XmlElementNode get_ElementNode();
    protected void MoveToEndElement();
    protected void MoveToEndOfFile();
    protected XmlElementNode EnterScope();
    protected void ExitScope();
    private XmlAttributeNode AddAttribute(QNameType qnameType, bool isAtomicValue);
    protected Namespace AddNamespace();
    protected XmlAttributeNode AddAttribute();
    protected XmlAttributeNode AddXmlAttribute();
    protected XmlAttributeNode AddXmlnsAttribute(Namespace ns);
    protected void FixXmlAttribute(XmlAttributeNode attributeNode);
    protected bool get_OutsideRootElement();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual string get_BaseURI();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string localName, string namespaceUri);
    public virtual int get_AttributeCount();
    public virtual void Close();
    public sealed virtual int get_Depth();
    public virtual bool get_EOF();
    private XmlAttributeNode GetAttributeNode(int index);
    private XmlAttributeNode GetAttributeNode(string name);
    private XmlAttributeNode GetAttributeNode(string localName, string namespaceUri);
    private XmlAttributeNode GetAttributeNode(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public sealed virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string prefix);
    protected Namespace LookupNamespace(PrefixHandleType prefix);
    protected Namespace LookupNamespace(PrefixHandle prefix);
    protected void ProcessAttributes();
    private void ProcessAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    private void CheckAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceUri);
    public virtual bool MoveToElement();
    public virtual XmlNodeType MoveToContent();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public sealed virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localName, string namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual string ReadElementContentAsString();
    public virtual string ReadElementString();
    public virtual string ReadElementString(string name);
    public virtual string ReadElementString(string localName, string namespaceUri);
    public virtual void ReadStartElement();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localName, string namespaceUri);
    public virtual void ReadEndElement();
    public virtual bool ReadAttributeValue();
    public virtual ReadState get_ReadState();
    private void SkipValue(XmlNode node);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBinHex();
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    private int ReadBytes(Encoding encoding, int byteBlock, int charBlock, Byte[] buffer, int offset, int byteCount, bool readContent);
    public virtual string ReadContentAsString();
    public virtual bool ReadContentAsBoolean();
    public virtual long ReadContentAsLong();
    public virtual int ReadContentAsInt();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual float ReadContentAsFloat();
    public virtual decimal ReadContentAsDecimal();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual Guid ReadContentAsGuid();
    public virtual object ReadContentAsObject();
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual void ResolveEntity();
    public virtual void Skip();
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public string GetOpenElements();
    private Char[] GetCharBuffer(int count);
    private void SignStartElement(XmlSigningNodeWriter writer);
    private static void SignAttribute(XmlSigningNodeWriter writer, XmlAttributeNode attributeNode);
    private void SignEndElement(XmlSigningNodeWriter writer);
    private void SignNode(XmlSigningNodeWriter writer);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    protected void SignNode();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal abstract class System.Xml.XmlBaseWriter : XmlDictionaryWriter {
    private XmlNodeWriter _writer;
    private NamespaceManager _nsMgr;
    private Element[] _elements;
    private int _depth;
    private string _attributeLocalName;
    private string _attributeValue;
    private bool _isXmlAttribute;
    private bool _isXmlnsAttribute;
    private WriteState _writeState;
    private DocumentState _documentState;
    private Byte[] _trailBytes;
    private int _trailByteCount;
    private XmlStreamNodeWriter _nodeWriter;
    private XmlSigningNodeWriter _signingWriter;
    private XmlUTF8NodeWriter _textFragmentWriter;
    private XmlNodeWriter _oldWriter;
    private Stream _oldStream;
    private int _oldNamespaceBoundary;
    private bool _inList;
    private static string xmlnsNamespace;
    private static string xmlNamespace;
    private static String[] s_prefixes;
    protected bool IsClosed { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public WriteState WriteState { get; }
    protected int NamespaceBoundary { get; protected set; }
    public bool CanCanonicalize { get; }
    protected bool Signing { get; }
    public bool CanFragment { get; }
    private static XmlBaseWriter();
    protected void SetOutput(XmlStreamNodeWriter writer);
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual void Close();
    protected bool get_IsClosed();
    [DoesNotReturnAttribute]
protected static void ThrowClosed();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual WriteState get_WriteState();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void StartAttribute(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartAttribute(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndAttribute();
    protected virtual Task WriteEndAttributeAsync();
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<WriteEndAttributeAsyncImpl>d__43")]
private Task WriteEndAttributeAsyncImpl();
    public virtual void WriteComment(string text);
    public virtual void WriteFullEndElement();
    public virtual void WriteCData(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    private void StartElement(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    private void PreStartElementAsyncCheck(string localName);
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<StartElementAndWriteStartElementAsync>d__50")]
private Task StartElementAndWriteStartElementAsync(string prefix, string localName, string namespaceUri);
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<StartElementAsync>d__51")]
private Task`1<string> StartElementAsync(string prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartElement(string prefix, string localName, string namespaceUri);
    public virtual Task WriteStartElementAsync(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndElement();
    public virtual Task WriteEndElementAsync();
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<WriteEndElementAsyncImpl>d__57")]
private Task WriteEndElementAsyncImpl();
    private Element EnterScope();
    private void ExitScope();
    protected void FlushElement();
    private Task FlushElementAsync();
    protected void StartComment();
    protected static void EndComment();
    protected void StartContent();
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<StartContentAsync>d__65")]
protected Task StartContentAsync();
    protected void StartContent(char ch);
    protected void StartContent(string s);
    protected void StartContent(Char[] chars, int offset, int count);
    private static void VerifyWhitespace(char ch);
    private static void VerifyWhitespace(string s);
    private static void VerifyWhitespace(Char[] chars, int offset, int count);
    protected static void EndContent();
    private void AutoComplete(WriteState writeState);
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<AutoCompleteAsync>d__74")]
private Task AutoCompleteAsync(WriteState writeState);
    private void EndStartElement();
    private Task EndStartElementAsync();
    public virtual string LookupPrefix(string ns);
    private string GetQualifiedNamePrefix(string namespaceUri, XmlDictionaryString xNs);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteProcessingInstruction(string name, string text);
    private void FinishDocument();
    public virtual void WriteEndDocument();
    protected int get_NamespaceBoundary();
    protected void set_NamespaceBoundary(int value);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteString(string value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteChars(Char[] chars, int offset, int count);
    public virtual void WriteRaw(string value);
    public virtual void WriteRaw(Char[] chars, int offset, int count);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(object value);
    protected void WritePrimitiveValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    private void WriteValue(ulong value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    private static void EnsureBufferBounds(Byte[] buffer, int offset, int count);
    public virtual void WriteBinHex(Byte[] buffer, int offset, int count);
    public virtual void WriteBase64(Byte[] buffer, int offset, int count);
    public virtual Task WriteBase64Async(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<WriteBase64AsyncImpl>d__119")]
private Task WriteBase64AsyncImpl(Byte[] buffer, int offset, int count);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public virtual bool get_CanFragment();
    public sealed virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public sealed virtual void EndFragment();
    public sealed virtual void WriteFragment(Byte[] buffer, int offset, int count);
    private void FlushBase64();
    private Task FlushBase64Async();
    private void FlushTrailBytes();
    [AsyncStateMachineAttribute("System.Xml.XmlBaseWriter/<FlushTrailBytesAsync>d__135")]
private Task FlushTrailBytesAsync();
    private void WriteValue(Object[] array);
    private void WriteValue(Array array);
    protected void StartArray(int count);
    private string GeneratePrefix(string ns, XmlDictionaryString xNs);
    protected void SignScope(XmlCanonicalWriter signingWriter);
    private void WriteAttributeText(string value);
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    public int value__;
    public static XmlBinaryNodeType EndElement;
    public static XmlBinaryNodeType Comment;
    public static XmlBinaryNodeType Array;
    public static XmlBinaryNodeType MinAttribute;
    public static XmlBinaryNodeType ShortAttribute;
    public static XmlBinaryNodeType Attribute;
    public static XmlBinaryNodeType ShortDictionaryAttribute;
    public static XmlBinaryNodeType DictionaryAttribute;
    public static XmlBinaryNodeType ShortXmlnsAttribute;
    public static XmlBinaryNodeType XmlnsAttribute;
    public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    public static XmlBinaryNodeType PrefixAttributeA;
    public static XmlBinaryNodeType PrefixAttributeB;
    public static XmlBinaryNodeType PrefixAttributeC;
    public static XmlBinaryNodeType PrefixAttributeD;
    public static XmlBinaryNodeType PrefixAttributeE;
    public static XmlBinaryNodeType PrefixAttributeF;
    public static XmlBinaryNodeType PrefixAttributeG;
    public static XmlBinaryNodeType PrefixAttributeH;
    public static XmlBinaryNodeType PrefixAttributeI;
    public static XmlBinaryNodeType PrefixAttributeJ;
    public static XmlBinaryNodeType PrefixAttributeK;
    public static XmlBinaryNodeType PrefixAttributeL;
    public static XmlBinaryNodeType PrefixAttributeM;
    public static XmlBinaryNodeType PrefixAttributeN;
    public static XmlBinaryNodeType PrefixAttributeO;
    public static XmlBinaryNodeType PrefixAttributeP;
    public static XmlBinaryNodeType PrefixAttributeQ;
    public static XmlBinaryNodeType PrefixAttributeR;
    public static XmlBinaryNodeType PrefixAttributeS;
    public static XmlBinaryNodeType PrefixAttributeT;
    public static XmlBinaryNodeType PrefixAttributeU;
    public static XmlBinaryNodeType PrefixAttributeV;
    public static XmlBinaryNodeType PrefixAttributeW;
    public static XmlBinaryNodeType PrefixAttributeX;
    public static XmlBinaryNodeType PrefixAttributeY;
    public static XmlBinaryNodeType PrefixAttributeZ;
    public static XmlBinaryNodeType MaxAttribute;
    public static XmlBinaryNodeType MinElement;
    public static XmlBinaryNodeType ShortElement;
    public static XmlBinaryNodeType Element;
    public static XmlBinaryNodeType ShortDictionaryElement;
    public static XmlBinaryNodeType DictionaryElement;
    public static XmlBinaryNodeType PrefixDictionaryElementA;
    public static XmlBinaryNodeType PrefixDictionaryElementB;
    public static XmlBinaryNodeType PrefixDictionaryElementC;
    public static XmlBinaryNodeType PrefixDictionaryElementD;
    public static XmlBinaryNodeType PrefixDictionaryElementE;
    public static XmlBinaryNodeType PrefixDictionaryElementF;
    public static XmlBinaryNodeType PrefixDictionaryElementG;
    public static XmlBinaryNodeType PrefixDictionaryElementH;
    public static XmlBinaryNodeType PrefixDictionaryElementI;
    public static XmlBinaryNodeType PrefixDictionaryElementJ;
    public static XmlBinaryNodeType PrefixDictionaryElementK;
    public static XmlBinaryNodeType PrefixDictionaryElementL;
    public static XmlBinaryNodeType PrefixDictionaryElementM;
    public static XmlBinaryNodeType PrefixDictionaryElementN;
    public static XmlBinaryNodeType PrefixDictionaryElementO;
    public static XmlBinaryNodeType PrefixDictionaryElementP;
    public static XmlBinaryNodeType PrefixDictionaryElementQ;
    public static XmlBinaryNodeType PrefixDictionaryElementR;
    public static XmlBinaryNodeType PrefixDictionaryElementS;
    public static XmlBinaryNodeType PrefixDictionaryElementT;
    public static XmlBinaryNodeType PrefixDictionaryElementU;
    public static XmlBinaryNodeType PrefixDictionaryElementV;
    public static XmlBinaryNodeType PrefixDictionaryElementW;
    public static XmlBinaryNodeType PrefixDictionaryElementX;
    public static XmlBinaryNodeType PrefixDictionaryElementY;
    public static XmlBinaryNodeType PrefixDictionaryElementZ;
    public static XmlBinaryNodeType PrefixElementA;
    public static XmlBinaryNodeType PrefixElementB;
    public static XmlBinaryNodeType PrefixElementC;
    public static XmlBinaryNodeType PrefixElementD;
    public static XmlBinaryNodeType PrefixElementE;
    public static XmlBinaryNodeType PrefixElementF;
    public static XmlBinaryNodeType PrefixElementG;
    public static XmlBinaryNodeType PrefixElementH;
    public static XmlBinaryNodeType PrefixElementI;
    public static XmlBinaryNodeType PrefixElementJ;
    public static XmlBinaryNodeType PrefixElementK;
    public static XmlBinaryNodeType PrefixElementL;
    public static XmlBinaryNodeType PrefixElementM;
    public static XmlBinaryNodeType PrefixElementN;
    public static XmlBinaryNodeType PrefixElementO;
    public static XmlBinaryNodeType PrefixElementP;
    public static XmlBinaryNodeType PrefixElementQ;
    public static XmlBinaryNodeType PrefixElementR;
    public static XmlBinaryNodeType PrefixElementS;
    public static XmlBinaryNodeType PrefixElementT;
    public static XmlBinaryNodeType PrefixElementU;
    public static XmlBinaryNodeType PrefixElementV;
    public static XmlBinaryNodeType PrefixElementW;
    public static XmlBinaryNodeType PrefixElementX;
    public static XmlBinaryNodeType PrefixElementY;
    public static XmlBinaryNodeType PrefixElementZ;
    public static XmlBinaryNodeType MaxElement;
    public static XmlBinaryNodeType MinText;
    public static XmlBinaryNodeType ZeroText;
    public static XmlBinaryNodeType OneText;
    public static XmlBinaryNodeType FalseText;
    public static XmlBinaryNodeType TrueText;
    public static XmlBinaryNodeType Int8Text;
    public static XmlBinaryNodeType Int16Text;
    public static XmlBinaryNodeType Int32Text;
    public static XmlBinaryNodeType Int64Text;
    public static XmlBinaryNodeType FloatText;
    public static XmlBinaryNodeType DoubleText;
    public static XmlBinaryNodeType DecimalText;
    public static XmlBinaryNodeType DateTimeText;
    public static XmlBinaryNodeType Chars8Text;
    public static XmlBinaryNodeType Chars16Text;
    public static XmlBinaryNodeType Chars32Text;
    public static XmlBinaryNodeType Bytes8Text;
    public static XmlBinaryNodeType Bytes16Text;
    public static XmlBinaryNodeType Bytes32Text;
    public static XmlBinaryNodeType StartListText;
    public static XmlBinaryNodeType EndListText;
    public static XmlBinaryNodeType EmptyText;
    public static XmlBinaryNodeType DictionaryText;
    public static XmlBinaryNodeType UniqueIdText;
    public static XmlBinaryNodeType TimeSpanText;
    public static XmlBinaryNodeType GuidText;
    public static XmlBinaryNodeType UInt64Text;
    public static XmlBinaryNodeType BoolText;
    public static XmlBinaryNodeType UnicodeChars8Text;
    public static XmlBinaryNodeType UnicodeChars16Text;
    public static XmlBinaryNodeType UnicodeChars32Text;
    public static XmlBinaryNodeType QNameDictionaryText;
    public static XmlBinaryNodeType ZeroTextWithEndElement;
    public static XmlBinaryNodeType OneTextWithEndElement;
    public static XmlBinaryNodeType FalseTextWithEndElement;
    public static XmlBinaryNodeType TrueTextWithEndElement;
    public static XmlBinaryNodeType Int8TextWithEndElement;
    public static XmlBinaryNodeType Int16TextWithEndElement;
    public static XmlBinaryNodeType Int32TextWithEndElement;
    public static XmlBinaryNodeType Int64TextWithEndElement;
    public static XmlBinaryNodeType FloatTextWithEndElement;
    public static XmlBinaryNodeType DoubleTextWithEndElement;
    public static XmlBinaryNodeType DecimalTextWithEndElement;
    public static XmlBinaryNodeType DateTimeTextWithEndElement;
    public static XmlBinaryNodeType Chars8TextWithEndElement;
    public static XmlBinaryNodeType Chars16TextWithEndElement;
    public static XmlBinaryNodeType Chars32TextWithEndElement;
    public static XmlBinaryNodeType Bytes8TextWithEndElement;
    public static XmlBinaryNodeType Bytes16TextWithEndElement;
    public static XmlBinaryNodeType Bytes32TextWithEndElement;
    public static XmlBinaryNodeType StartListTextWithEndElement;
    public static XmlBinaryNodeType EndListTextWithEndElement;
    public static XmlBinaryNodeType EmptyTextWithEndElement;
    public static XmlBinaryNodeType DictionaryTextWithEndElement;
    public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    public static XmlBinaryNodeType GuidTextWithEndElement;
    public static XmlBinaryNodeType UInt64TextWithEndElement;
    public static XmlBinaryNodeType BoolTextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    public static XmlBinaryNodeType MaxText;
}
internal class System.Xml.XmlBinaryNodeWriter : XmlStreamNodeWriter {
    private IXmlDictionary _dictionary;
    private XmlBinaryWriterSession _session;
    private bool _inAttribute;
    private bool _inList;
    private bool _wroteAttributeValue;
    private AttributeValue _attributeValue;
    private static int maxBytesPerChar;
    private int _textNodeOffset;
    public void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    private void WriteNode(XmlBinaryNodeType nodeType);
    private void WroteAttributeValue();
    private void WriteTextNode(XmlBinaryNodeType nodeType);
    private Byte[] GetTextNodeBuffer(int size, Int32& offset);
    private void WriteTextNodeWithLength(XmlBinaryNodeType nodeType, int length);
    private void WriteTextNodeRaw(XmlBinaryNodeType nodeType, T value);
    private void WriteRaw(T value);
    private void WriteTextNodeWithInt8(XmlBinaryNodeType nodeType, byte value);
    private void WriteTextNodeWithInt16(XmlBinaryNodeType nodeType, short value);
    private void WriteTextNodeWithInt32(XmlBinaryNodeType nodeType, int value);
    private void WriteTextNodeWithInt64(XmlBinaryNodeType nodeType, long value);
    public virtual void WriteDeclaration();
    public virtual void WriteStartElement(string prefix, string localName);
    private void WritePrefixNode(XmlBinaryNodeType nodeType, int ch);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    private void WriteEndElement();
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private bool TryGetKey(XmlDictionaryString s, Int32& key);
    private void WriteDictionaryString(int key);
    private void WriteName(string s);
    private void UnsafeWriteName(Char* chars, int charCount);
    private void WriteMultiByteInt32(int i);
    public virtual void WriteComment(string value);
    public virtual void WriteCData(string value);
    private void WriteEmptyText();
    public virtual void WriteBoolText(bool value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    private void WriteInt64(long value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] base64Buffer, int base64Offset, int base64Count);
    public virtual void WriteText(XmlDictionaryString value);
    public virtual void WriteText(string value);
    public virtual void WriteText(Char[] chars, int offset, int count);
    private void WriteTextImpl(string value);
    private void WriteTextImpl(ReadOnlySpan`1<char> chars);
    public virtual void WriteText(Byte[] chars, int charOffset, int charCount);
    private void UnsafeWriteText(Char* chars, int charCount);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteCharEntity(int ch);
    public virtual void WriteFloatText(float f);
    public virtual void WriteDoubleText(double d);
    public virtual void WriteDecimalText(decimal d);
    public virtual void WriteDateTimeText(DateTime dt);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteGuidText(Guid guid);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public void WriteArrayNode();
    private void WriteArrayInfo(XmlBinaryNodeType nodeType, int count);
    public void WriteArray(XmlBinaryNodeType nodeType, int count, ReadOnlySpan`1<byte> bytes);
    public void WriteBoolArray(ReadOnlySpan`1<bool> items);
    public void WriteInt16Array(ReadOnlySpan`1<short> items);
    public void WriteInt32Array(ReadOnlySpan`1<int> items);
    public void WriteInt64Array(ReadOnlySpan`1<long> items);
    public void WriteFloatArray(ReadOnlySpan`1<float> items);
    public void WriteDoubleArray(ReadOnlySpan`1<double> items);
    public void WriteDecimalArray(ReadOnlySpan`1<decimal> items);
    public void WriteDateTimeArray(ReadOnlySpan`1<DateTime> items);
    public void WriteGuidArray(ReadOnlySpan`1<Guid> items);
    public void WriteTimeSpanArray(ReadOnlySpan`1<TimeSpan> items);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
    protected virtual void FlushBuffer();
    public virtual void Close();
}
internal class System.Xml.XmlBinaryReader : XmlBaseReader {
    private bool _isTextWithEndElement;
    private bool _buffered;
    private ArrayState _arrayState;
    private int _arrayCount;
    private int _maxBytesPerRead;
    private XmlBinaryNodeType _arrayNodeType;
    private OnXmlDictionaryReaderClose _onClose;
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    private bool CanOptimizeReadElementContent();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Guid ReadElementContentAsGuid();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual bool TryGetBase64ContentLength(Int32& length);
    private void ReadTextWithEndElement();
    private XmlAtomicTextNode MoveToAtomicTextWithEndElement();
    public virtual bool Read();
    private bool ReadNode();
    private void VerifyWhitespace();
    private void ReadAttributes();
    private void ReadAttributes2();
    private void ReadText(XmlTextNode textNode, ValueHandleType type, int length);
    private void ReadBinaryText(XmlTextNode textNode, int length);
    private void ReadPartialUTF8Text(bool withEndElement, int length);
    private void ReadUnicodeText(bool withEndElement, int length);
    private void ReadPartialUnicodeText(bool withEndElement, int length);
    private void ReadPartialBinaryText(bool withEndElement, int length);
    private void InsertNode(XmlBinaryNodeType nodeType, int length);
    private void ReadAttributeText(XmlAttributeTextNode textNode);
    private void ReadName(ValueHandle value);
    private void ReadName(StringHandle handle);
    private void ReadName(PrefixHandle prefix);
    private void ReadDictionaryName(StringHandle s);
    private XmlBinaryNodeType GetNodeType();
    private void SkipNodeType();
    private int ReadDictionaryKey();
    private int ReadMultiByteUInt31();
    private int ReadUInt8();
    private int ReadUInt16();
    private int ReadUInt31();
    private static bool IsValidArrayType(XmlBinaryNodeType nodeType);
    private void ReadArray();
    private void MoveToArrayElement();
    private void SkipArrayElements(int count);
    public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    private bool IsStartArray(string localName, string namespaceUri, XmlBinaryNodeType nodeType);
    private bool IsStartArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType);
    private static void CheckArray(Array array, int offset, int count);
    private int ReadArray(Boolean[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    private int ReadArray(Int16[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    private int ReadArray(Int32[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    private int ReadArray(Int64[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    private int ReadArray(Single[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    private int ReadArray(Double[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    private int ReadArray(Decimal[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    private int ReadArray(DateTime[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    private int ReadArray(Guid[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    private int ReadArray(TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlBinaryReaderSession : object {
    private static int MaxArrayEntries;
    private XmlDictionaryString[] _strings;
    private Dictionary`2<int, XmlDictionaryString> _stringDict;
    public XmlDictionaryString Add(int id, string value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryLookup(int key, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(string value, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
    public void Clear();
}
internal class System.Xml.XmlBinaryWriter : XmlBaseWriter {
    private XmlBinaryNodeWriter _writer;
    private Char[] _chars;
    private Byte[] _bytes;
    public sealed virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    private void WriteStartArray(string prefix, string localName, string namespaceUri, int count);
    private void WriteStartArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, int count);
    private void WriteArray(string prefix, string localName, string namespaceUri, XmlBinaryNodeType nodeType, int count, ReadOnlySpan`1<byte> bytes);
    private void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType, int count, ReadOnlySpan`1<byte> bytes);
    private static void CheckArray(Array array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.XmlBinaryWriterSession : object {
    private PriorityDictionary`2<string, int> _strings;
    private PriorityDictionary`2<IXmlDictionary, IntArray> _maps;
    private int _nextKey;
    [NullableContextAttribute("1")]
public virtual bool TryAdd(XmlDictionaryString value, Int32& key);
    private int Add(string s);
    private IntArray AddKeys(IXmlDictionary dictionary, int minCount);
    public void Reset();
    internal bool TryLookup(XmlDictionaryString s, Int32& key);
}
internal class System.Xml.XmlBufferReader : object {
    private XmlDictionaryReader _reader;
    private Stream _stream;
    private Byte[] _streamBuffer;
    private Byte[] _buffer;
    private int _offsetMin;
    private int _offsetMax;
    private IXmlDictionary _dictionary;
    private XmlBinaryReaderSession _session;
    private int _offset;
    private static int maxBytesPerChar;
    private Char[] _chars;
    private int _windowOffset;
    private int _windowOffsetMax;
    private ValueHandle _listValue;
    private static XmlBufferReader s_empty;
    public static XmlBufferReader Empty { get; }
    public Byte[] Buffer { get; }
    public bool IsStreamed { get; }
    public bool EndOfFile { get; }
    public int Offset { get; public set; }
    public XmlBufferReader(XmlDictionaryReader reader);
    public XmlBufferReader(Byte[] buffer);
    private static XmlBufferReader();
    public static XmlBufferReader get_Empty();
    public Byte[] get_Buffer();
    public bool get_IsStreamed();
    public void SetBuffer(Stream stream, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void SetBuffer(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    private void SetBuffer(Stream stream, Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void Close();
    public bool get_EndOfFile();
    public byte GetByte();
    public void SkipByte();
    private byte GetByteHard();
    public Byte[] GetBuffer(int count, Int32& offset);
    public Byte[] GetBuffer(int count, Int32& offset, Int32& offsetMax);
    public Byte[] GetBuffer(Int32& offset, Int32& offsetMax);
    private Byte[] GetBufferHard(int count, Int32& offset);
    private void EnsureByte();
    private bool TryEnsureByte();
    private void EnsureBytes(int count);
    private bool TryEnsureBytes(int count);
    public void Advance(int count);
    public void InsertBytes(Byte[] buffer, int offset, int count);
    public void SetWindow(int windowOffset, int windowLength);
    public int get_Offset();
    public void set_Offset(int value);
    public int ReadBytes(int count);
    public int ReadMultiByteUInt31();
    public int ReadUInt8();
    public int ReadInt8();
    public int ReadUInt16();
    public int ReadInt16();
    public int ReadInt32();
    public int ReadUInt31();
    public long ReadInt64();
    public float ReadSingle();
    public double ReadDouble();
    public decimal ReadDecimal();
    public UniqueId ReadUniqueId();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public Guid ReadGuid();
    public string ReadUTF8String(int length);
    public void ReadRawArrayBytes(Span`1<T> dst);
    public void ReadRawArrayBytes(Span`1<byte> dst);
    private Char[] GetCharBuffer(int count);
    private int GetChars(int offset, int length, Char[] chars);
    private int GetChars(int offset, int length, Char[] chars, int charOffset);
    public string GetString(int offset, int length);
    public string GetUnicodeString(int offset, int length);
    public string GetString(int offset, int length, XmlNameTable nameTable);
    public int GetEscapedChars(int offset, int length, Char[] chars);
    private static bool IsAttrChar(int ch);
    public string GetEscapedString(int offset, int length);
    public string GetEscapedString(int offset, int length, XmlNameTable nameTable);
    private int GetLessThanCharEntity(int offset, int length);
    private int GetGreaterThanCharEntity(int offset, int length);
    private int GetQuoteCharEntity(int offset, int length);
    private int GetAmpersandCharEntity(int offset, int length);
    private int GetApostropheCharEntity(int offset, int length);
    private int GetDecimalCharEntity(int offset, int length);
    private int GetHexCharEntity(int offset, int length);
    public int GetCharEntity(int offset, int length);
    public bool IsWhitespaceKey(int key);
    public bool IsWhitespaceUTF8(int offset, int length);
    public bool IsWhitespaceUnicode(int offset, int length);
    public bool Equals2(int key1, int key2, XmlBufferReader bufferReader2);
    public bool Equals2(int key1, XmlDictionaryString xmlString2);
    public bool Equals2(int offset1, int length1, Byte[] buffer2);
    public bool Equals2(int offset1, int length1, XmlBufferReader bufferReader2, int offset2, int length2);
    public bool Equals2(int offset1, int length1, int offset2, int length2);
    public bool Equals2(int offset1, int length1, string s2);
    public int Compare(int offset1, int length1, int offset2, int length2);
    public byte GetByte(int offset);
    public int GetInt8(int offset);
    private T ReadRawBytes();
    private T ReadRawBytes(int offset);
    public int GetInt16(int offset);
    public int GetInt32(int offset);
    public long GetInt64(int offset);
    public ulong GetUInt64(int offset);
    public float GetSingle(int offset);
    public double GetDouble(int offset);
    public decimal GetDecimal(int offset);
    public UniqueId GetUniqueId(int offset);
    public Guid GetGuid(int offset);
    public void GetBase64(int srcOffset, Byte[] buffer, int dstOffset, int count);
    public XmlBinaryNodeType GetNodeType();
    public void SkipNodeType();
    public Object[] GetList(int offset, int count);
    public XmlDictionaryString GetDictionaryString(int key);
    public int ReadDictionaryKey();
    public void ReadValue(XmlBinaryNodeType nodeType, ValueHandle value);
    private void ReadValue(ValueHandle value, ValueHandleType type, int length);
    private void ReadUnicodeValue(ValueHandle value, int length);
    private void ReadList(ValueHandle value);
    public void ReadQName(ValueHandle value);
    public Int32[] GetRows();
}
internal class System.Xml.XmlCanonicalWriter : object {
    private XmlUTF8NodeWriter _writer;
    private MemoryStream _elementStream;
    private Byte[] _elementBuffer;
    private XmlUTF8NodeWriter _elementWriter;
    private bool _inStartElement;
    private int _depth;
    private Scope[] _scopes;
    private int _xmlnsAttributeCount;
    private XmlnsAttribute[] _xmlnsAttributes;
    private int _attributeCount;
    private Attribute[] _attributes;
    private Attribute _attribute;
    private Element _element;
    private Byte[] _xmlnsBuffer;
    private int _xmlnsOffset;
    private static int maxBytesPerChar;
    private int _xmlnsStartOffset;
    private bool _includeComments;
    private String[] _inclusivePrefixes;
    private static string xmlnsNamespace;
    private static Boolean[] s_isEscapedAttributeChar;
    private static Boolean[] s_isEscapedElementChar;
    private static XmlCanonicalWriter();
    public void SetOutput(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public void Flush();
    public void Close();
    public void WriteDeclaration();
    public void WriteComment(string value);
    [MemberNotNullAttribute("_scopes")]
private void StartElement();
    private void EndElement();
    public void WriteStartElement(string prefix, string localName);
    public void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private bool IsInclusivePrefix(XmlnsAttribute& xmlnsAttribute);
    public void WriteEndStartElement(bool isEmpty);
    public void WriteEndElement(string prefix, string localName);
    [MemberNotNullAttribute("_xmlnsBuffer")]
private void EnsureXmlnsBuffer(int byteCount);
    [MemberNotNullAttribute("_xmlnsAttributes")]
public void WriteXmlnsAttribute(string prefix, string ns);
    [MemberNotNullAttribute("_xmlnsAttributes")]
public void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public void WriteStartAttribute(string prefix, string localName);
    public void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public void WriteEndAttribute();
    public void WriteCharEntity(int ch);
    public void WriteEscapedText(string value);
    public void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteEscapedText(Char[] chars, int offset, int count);
    public void WriteText(int ch);
    public void WriteText(Byte[] chars, int offset, int count);
    public void WriteText(string value);
    public void WriteText(Char[] chars, int offset, int count);
    private void ThrowIfClosed();
    private void WriteXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void SortAttributes();
    private void AddAttribute(Attribute& attribute);
    [MemberNotNullAttribute("_xmlnsAttributes")]
private void AddXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void ResolvePrefix(int prefixOffset, int prefixLength, Int32& nsOffset, Int32& nsLength);
    private void ResolvePrefix(Attribute& attribute);
    private void ResolvePrefixes();
    private int Compare(XmlnsAttribute& xmlnsAttribute1, XmlnsAttribute& xmlnsAttribute2);
    private int Compare(Attribute& attribute1, Attribute& attribute2);
    private static int Compare(Byte[] buffer, int offset1, int length1, int offset2, int length2);
    private static int Compare(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
    private static bool Equals(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
}
internal static class System.Xml.XmlConverter : object {
    public static int MaxDateTimeChars;
    public static int MaxInt32Chars;
    public static int MaxInt64Chars;
    public static int MaxBoolChars;
    public static int MaxFloatChars;
    public static int MaxDoubleChars;
    public static int MaxDecimalChars;
    public static int MaxUInt64Chars;
    public static int MaxPrimitiveChars;
    private static SearchValues`1<char> s_whitespaceChars;
    private static SearchValues`1<byte> s_whitespaceBytes;
    private static XmlConverter();
    public static bool ToBoolean(string value);
    public static bool ToBoolean(Byte[] buffer, int offset, int count);
    public static int ToInt32(string value);
    public static int ToInt32(Byte[] buffer, int offset, int count);
    public static long ToInt64(string value);
    public static long ToInt64(Byte[] buffer, int offset, int count);
    public static float ToSingle(string value);
    public static float ToSingle(Byte[] buffer, int offset, int count);
    public static double ToDouble(string value);
    public static double ToDouble(Byte[] buffer, int offset, int count);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(Byte[] buffer, int offset, int count);
    public static DateTime ToDateTime(long value);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(Byte[] buffer, int offset, int count);
    public static UniqueId ToUniqueId(string value);
    public static UniqueId ToUniqueId(Byte[] buffer, int offset, int count);
    public static TimeSpan ToTimeSpan(string value);
    public static TimeSpan ToTimeSpan(Byte[] buffer, int offset, int count);
    public static Guid ToGuid(string value);
    public static Guid ToGuid(Byte[] buffer, int offset, int count);
    public static ulong ToUInt64(string value);
    public static ulong ToUInt64(Byte[] buffer, int offset, int count);
    public static string ToString(Byte[] buffer, int offset, int count);
    public static string ToStringUnicode(Byte[] buffer, int offset, int count);
    public static Byte[] ToBytes(string value);
    public static int ToChars(Byte[] buffer, int offset, int count, Char[] chars, int charOffset);
    public static string ToString(bool value);
    public static string ToString(int value);
    public static string ToString(long value);
    public static string ToString(float value);
    public static string ToString(double value);
    public static string ToString(decimal value);
    public static string ToString(TimeSpan value);
    public static string ToString(UniqueId value);
    public static string ToString(Guid value);
    public static string ToString(ulong value);
    public static string ToString(DateTime value);
    private static string ToString(object value);
    public static string ToString(Object[] objects);
    public static void ToQualifiedName(string qname, String& prefix, String& localName);
    private static bool TryParseInt32(Byte[] chars, int offset, int count, Int32& result);
    private static bool TryParseInt64(Byte[] chars, int offset, int count, Int64& result);
    private static bool TryParseSingle(Byte[] chars, int offset, int count, Single& result);
    private static bool TryParseDouble(Byte[] chars, int offset, int count, Double& result);
    public static int ToChars(int value, Byte[] chars, int offset);
    public static int ToChars(long value, Byte[] chars, int offset);
    public static int ToCharsR(long value, Byte[] chars, int offset);
    private static bool IsNegativeZero(float value);
    private static bool IsNegativeZero(double value);
    private static int ToInfinity(bool isNegative, Byte[] buffer, int offset);
    private static int ToZero(bool isNegative, Byte[] buffer, int offset);
    public static int ToChars(double value, Byte[] buffer, int offset);
    public static int ToChars(float value, Byte[] buffer, int offset);
    public static int ToChars(decimal value, Byte[] buffer, int offset);
    public static int ToChars(ulong value, Byte[] buffer, int offset);
    private static int ToAsciiChars(string s, Byte[] buffer, int offset);
    public static int ToChars(bool value, Byte[] buffer, int offset);
    private static int ToInt32D2(Byte[] chars, int offset);
    private static int ToInt32D4(Byte[] chars, int offset, int count);
    private static int ToInt32D7(Byte[] chars, int offset, int count);
    private static bool TryParseDateTime(Byte[] chars, int offset, int count, DateTime& result);
    public static int ToCharsR(int value, Byte[] chars, int offset);
    private static int ToCharsD2(int value, Byte[] chars, int offset);
    private static int ToCharsD4(int value, Byte[] chars, int offset);
    private static int ToCharsD7(int value, Byte[] chars, int offset);
    public static int ToChars(DateTime value, Byte[] chars, int offset);
    public static bool IsWhitespace(ReadOnlySpan`1<char> chars);
    public static bool IsWhitespace(ReadOnlySpan`1<byte> bytes);
    public static bool IsWhitespace(char ch);
    public static int StripWhitespace(Span`1<char> chars);
    public static string StripWhitespace(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionary : object {
    private static IXmlDictionary s_empty;
    private Dictionary`2<string, XmlDictionaryString> _lookup;
    private XmlDictionaryString[] _strings;
    private int _nextId;
    public static IXmlDictionary Empty { get; }
    public XmlDictionary(int capacity);
    public static IXmlDictionary get_Empty();
    public virtual XmlDictionaryString Add(string value);
    public virtual bool TryLookup(string value, XmlDictionaryString& result);
    [NullableContextAttribute("2")]
public virtual bool TryLookup(int key, XmlDictionaryString& result);
    public virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
internal class System.Xml.XmlDictionaryAsyncCheckWriter : XmlDictionaryWriter {
    private XmlDictionaryWriter _coreWriter;
    private Task _lastTask;
    internal XmlDictionaryWriter CoreWriter { get; }
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public bool CanCanonicalize { get; }
    public XmlDictionaryAsyncCheckWriter(XmlDictionaryWriter writer);
    internal XmlDictionaryWriter get_CoreWriter();
    private void CheckAsync();
    private Task SetLastTask(Task task);
    public virtual XmlWriterSettings get_Settings();
    public virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual string LookupPrefix(string ns);
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual Task WriteAttributesAsync(XmlReader reader, bool defattr);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual Task WriteBinHexAsync(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual Task WriteCDataAsync(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual Task WriteCharEntityAsync(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual Task WriteCharsAsync(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual Task WriteCommentAsync(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual Task WriteDocTypeAsync(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual Task WriteEndDocumentAsync();
    public virtual void WriteEndElement();
    public virtual Task WriteEndElementAsync();
    public virtual void WriteEntityRef(string name);
    public virtual Task WriteEntityRefAsync(string name);
    public virtual void WriteFullEndElement();
    public virtual Task WriteFullEndElementAsync();
    public virtual void WriteName(string name);
    public virtual Task WriteNameAsync(string name);
    public virtual void WriteNmToken(string name);
    public virtual Task WriteNmTokenAsync(string name);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual Task WriteNodeAsync(XmlReader reader, bool defattr);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual Task WriteProcessingInstructionAsync(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual Task WriteQualifiedNameAsync(string localName, string ns);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual Task WriteRawAsync(string data);
    public virtual Task WriteRawAsync(Char[] buffer, int index, int count);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual Task WriteStartDocumentAsync();
    public virtual Task WriteStartDocumentAsync(bool standalone);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual Task WriteStartElementAsync(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual Task WriteStringAsync(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual Task WriteSurrogateCharEntityAsync(char lowChar, char highChar);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(bool value);
    public virtual void WriteWhitespace(string ws);
    public virtual Task WriteWhitespaceAsync(string ws);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual bool get_CanCanonicalize();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Xml.XmlDictionaryReader : XmlReader {
    internal static int MaxInitialArrayLength;
    public bool CanCanonicalize { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public virtual bool get_CanCanonicalize();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    public virtual void MoveToStartElement();
    public virtual void MoveToStartElement(string name);
    public virtual void MoveToStartElement(string localName, string namespaceUri);
    public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public virtual void ReadFullStartElement();
    public virtual void ReadFullStartElement(string name);
    public virtual void ReadFullStartElement(string localName, string namespaceUri);
    public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBase64();
    internal Byte[] ReadContentAsBase64(int maxByteArrayContentLength, int maxInitialCount);
    public virtual string ReadContentAsString();
    protected string ReadContentAsString(int maxStringContentLength);
    public virtual string ReadString();
    protected string ReadString(int maxStringContentLength);
    public virtual Byte[] ReadContentAsBinHex();
    protected Byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
    private Byte[] ReadContentAsBytes(bool base64, int maxByteArrayContentLength);
    protected bool IsTextNode(XmlNodeType nodeType);
    public virtual int ReadContentAsChars(Char[] chars, int offset, int count);
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual string ReadContentAsString(String[] strings, Int32& index);
    public virtual string ReadContentAsString(XmlDictionaryString[] strings, Int32& index);
    public virtual decimal ReadContentAsDecimal();
    public virtual float ReadContentAsFloat();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual Guid ReadContentAsGuid();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual void ReadContentAsQualifiedName(String& localName, String& namespaceUri);
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    public virtual long ReadElementContentAsLong();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual Guid ReadElementContentAsGuid();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadElementContentAsBinHex();
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    [NullableContextAttribute("2")]
public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    [NullableContextAttribute("2")]
public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& namespaceUri);
    [NullableContextAttribute("2")]
public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    private static void CheckArray(Array array, int offset, int count);
    [NullableContextAttribute("2")]
public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    public virtual Boolean[] ReadBooleanArray(string localName, string namespaceUri);
    public virtual Boolean[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionaryReaderQuotas : object {
    private bool _readOnly;
    private int _maxStringContentLength;
    private int _maxArrayLength;
    private int _maxDepth;
    private int _maxNameTableCharCount;
    private int _maxBytesPerRead;
    private XmlDictionaryReaderQuotaTypes _modifiedQuotas;
    private static int DefaultMaxDepth;
    private static int DefaultMaxStringContentLength;
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxBytesPerRead;
    private static int DefaultMaxNameTableCharCount;
    private static XmlDictionaryReaderQuotas s_maxQuota;
    public static XmlDictionaryReaderQuotas Max { get; }
    [DefaultValueAttribute("8192")]
public int MaxStringContentLength { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxArrayLength { get; public set; }
    [DefaultValueAttribute("4096")]
public int MaxBytesPerRead { get; public set; }
    [DefaultValueAttribute("32")]
public int MaxDepth { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxNameTableCharCount { get; public set; }
    public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
    private XmlDictionaryReaderQuotas(int maxDepth, int maxStringContentLength, int maxArrayLength, int maxBytesPerRead, int maxNameTableCharCount, XmlDictionaryReaderQuotaTypes modifiedQuotas);
    private static XmlDictionaryReaderQuotas();
    public static XmlDictionaryReaderQuotas get_Max();
    public void CopyTo(XmlDictionaryReaderQuotas quotas);
    internal void InternalCopyTo(XmlDictionaryReaderQuotas quotas);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    public XmlDictionaryReaderQuotaTypes get_ModifiedQuotas();
    internal void MakeReadOnly();
}
[FlagsAttribute]
public enum System.Xml.XmlDictionaryReaderQuotaTypes : Enum {
    public int value__;
    public static XmlDictionaryReaderQuotaTypes MaxDepth;
    public static XmlDictionaryReaderQuotaTypes MaxStringContentLength;
    public static XmlDictionaryReaderQuotaTypes MaxArrayLength;
    public static XmlDictionaryReaderQuotaTypes MaxBytesPerRead;
    public static XmlDictionaryReaderQuotaTypes MaxNameTableCharCount;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionaryString : object {
    internal static int MinKey;
    internal static int MaxKey;
    private IXmlDictionary _dictionary;
    private string _value;
    private int _key;
    private Byte[] _buffer;
    private static EmptyStringDictionary s_emptyStringDictionary;
    public static XmlDictionaryString Empty { get; }
    public IXmlDictionary Dictionary { get; }
    public int Key { get; }
    public string Value { get; }
    public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
    private static XmlDictionaryString();
    internal static string GetString(XmlDictionaryString s);
    public static XmlDictionaryString get_Empty();
    public IXmlDictionary get_Dictionary();
    public int get_Key();
    public string get_Value();
    internal Byte[] ToUTF8();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Xml.XmlDictionaryWriter : XmlWriter {
    public bool CanCanonicalize { get; }
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    [NullableContextAttribute("2")]
public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    [NullableContextAttribute("2")]
public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    [NullableContextAttribute("2")]
public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    [NullableContextAttribute("2")]
public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    public virtual bool get_CanCanonicalize();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    private void WriteElementNode(XmlDictionaryReader reader, bool defattr);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, string localName, string namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, Type type);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    private static void CheckArray(Array array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
}
internal static class System.Xml.XmlExceptionHelper : object {
    [DoesNotReturnAttribute]
private static void ThrowXmlException(XmlDictionaryReader reader, string res);
    [DoesNotReturnAttribute]
public static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1);
    [DoesNotReturnAttribute]
private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2);
    [DoesNotReturnAttribute]
private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2, string arg3);
    [DoesNotReturnAttribute]
public static void ThrowXmlException(XmlDictionaryReader reader, XmlException exception);
    private static string GetName(string prefix, string localName);
    private static string GetWhatWasFound(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowStartElementExpected(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowStartElementExpected(XmlDictionaryReader reader, string name);
    [DoesNotReturnAttribute]
public static void ThrowStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    [DoesNotReturnAttribute]
public static void ThrowStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    [DoesNotReturnAttribute]
public static void ThrowFullStartElementExpected(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string name);
    [DoesNotReturnAttribute]
public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    [DoesNotReturnAttribute]
public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    [DoesNotReturnAttribute]
public static void ThrowEndElementExpected(XmlDictionaryReader reader, string localName, string ns);
    [DoesNotReturnAttribute]
public static void ThrowMaxArrayLengthExceeded(XmlDictionaryReader reader, int maxArrayLength);
    [DoesNotReturnAttribute]
public static void ThrowMaxArrayLengthOrMaxItemsQuotaExceeded(XmlDictionaryReader reader, int maxQuota);
    [DoesNotReturnAttribute]
public static void ThrowMaxBytesPerReadExceeded(XmlDictionaryReader reader, int maxBytesPerRead);
    [DoesNotReturnAttribute]
public static void ThrowMaxDepthExceeded(XmlDictionaryReader reader, int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowMaxStringContentLengthExceeded(XmlDictionaryReader reader, int maxStringContentLength);
    [DoesNotReturnAttribute]
public static void ThrowMaxNameTableCharCountExceeded(XmlDictionaryReader reader, int maxNameTableCharCount);
    [DoesNotReturnAttribute]
public static void ThrowBase64DataExpected(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowUndefinedPrefix(XmlDictionaryReader reader, string prefix);
    [DoesNotReturnAttribute]
public static void ThrowProcessingInstructionNotSupported(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowInvalidXml(XmlDictionaryReader reader, byte b);
    [DoesNotReturnAttribute]
public static void ThrowUnexpectedEndOfFile(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowUnexpectedEndElement(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, char found);
    [DoesNotReturnAttribute]
public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, string found);
    [DoesNotReturnAttribute]
public static void ThrowInvalidCharRef(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowTagMismatch(XmlDictionaryReader reader, string expectedPrefix, string expectedLocalName, string foundPrefix, string foundLocalName);
    [DoesNotReturnAttribute]
public static void ThrowDuplicateXmlnsAttribute(XmlDictionaryReader reader, string localName, string ns);
    [DoesNotReturnAttribute]
public static void ThrowDuplicateAttribute(XmlDictionaryReader reader, string prefix1, string prefix2, string localName, string ns);
    [DoesNotReturnAttribute]
public static void ThrowInvalidBinaryFormat(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowInvalidRootData(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowMultipleRootElements(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowDeclarationNotFirst(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowConversionOverflow(XmlDictionaryReader reader, string value, string type);
    [DoesNotReturnAttribute]
public static void ThrowXmlDictionaryStringIDOutOfRange(XmlDictionaryReader reader);
    [DoesNotReturnAttribute]
public static void ThrowXmlDictionaryStringIDUndefinedStatic(XmlDictionaryReader reader, int key);
    [DoesNotReturnAttribute]
public static void ThrowXmlDictionaryStringIDUndefinedSession(XmlDictionaryReader reader, int key);
    [DoesNotReturnAttribute]
public static void ThrowEmptyNamespace(XmlDictionaryReader reader);
    public static XmlException CreateConversionException(string type, Exception exception);
    public static XmlException CreateConversionException(string value, string type, Exception exception);
    public static XmlException CreateEncodingException(Byte[] buffer, int offset, int count, Exception exception);
    public static XmlException CreateEncodingException(string value, Exception exception);
}
internal abstract class System.Xml.XmlNodeWriter : object {
    private static XmlNodeWriter s_nullNodeWriter;
    public static XmlNodeWriter Null { get; }
    public static XmlNodeWriter get_Null();
    public abstract virtual void Flush();
    public virtual Task FlushAsync();
    public abstract virtual void Close();
    public abstract virtual void WriteDeclaration();
    public abstract virtual void WriteComment(string text);
    public abstract virtual void WriteCData(string text);
    public abstract virtual void WriteStartElement(string prefix, string localName);
    public virtual Task WriteStartElementAsync(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndStartElement(bool isEmpty);
    public virtual Task WriteEndStartElementAsync(bool isEmpty);
    public abstract virtual void WriteEndElement(string prefix, string localName);
    public virtual Task WriteEndElementAsync(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public abstract virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndAttribute();
    public virtual Task WriteEndAttributeAsync();
    public abstract virtual void WriteCharEntity(int ch);
    public abstract virtual void WriteEscapedText(string value);
    public abstract virtual void WriteEscapedText(XmlDictionaryString value);
    public abstract virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public abstract virtual void WriteEscapedText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteText(string value);
    public abstract virtual void WriteText(XmlDictionaryString value);
    public abstract virtual void WriteText(Char[] chars, int offset, int count);
    public abstract virtual void WriteText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteInt32Text(int value);
    public abstract virtual void WriteInt64Text(long value);
    public abstract virtual void WriteBoolText(bool value);
    public abstract virtual void WriteUInt64Text(ulong value);
    public abstract virtual void WriteFloatText(float value);
    public abstract virtual void WriteDoubleText(double value);
    public abstract virtual void WriteDecimalText(decimal value);
    public abstract virtual void WriteDateTimeText(DateTime value);
    public abstract virtual void WriteUniqueIdText(UniqueId value);
    public abstract virtual void WriteTimeSpanText(TimeSpan value);
    public abstract virtual void WriteGuidText(Guid value);
    public abstract virtual void WriteStartListText();
    public abstract virtual void WriteListSeparator();
    public abstract virtual void WriteEndListText();
    public abstract virtual void WriteBase64Text(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count);
    public virtual Task WriteBase64TextAsync(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count);
    public abstract virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlSigningNodeWriter : XmlNodeWriter {
    private XmlNodeWriter _writer;
    private XmlCanonicalWriter _signingWriter;
    private Byte[] _chars;
    private Byte[] _base64Chars;
    private bool _text;
    public XmlNodeWriter NodeWriter { get; public set; }
    public XmlCanonicalWriter CanonicalWriter { get; }
    public XmlSigningNodeWriter(bool text);
    public void SetOutput(XmlNodeWriter writer, Stream stream, bool includeComments, String[] inclusivePrefixes);
    public XmlNodeWriter get_NodeWriter();
    public void set_NodeWriter(XmlNodeWriter value);
    public XmlCanonicalWriter get_CanonicalWriter();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteDeclaration();
    public virtual void WriteComment(string text);
    public virtual void WriteCData(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteCharEntity(int ch);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    public virtual void WriteText(XmlDictionaryString value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void WriteBase64Text(Byte[] buffer, int offset, int count);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal abstract class System.Xml.XmlStreamNodeWriter : XmlNodeWriter {
    private Byte[] _buffer;
    private int _offset;
    private bool _ownsStream;
    private static int bufferLength;
    private static int maxBytesPerChar;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private Stream <OutputStream>k__BackingField;
    public Stream OutputStream { get; public set; }
    public Byte[] StreamBuffer { get; }
    public int BufferOffset { get; }
    public int Position { get; }
    protected void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    [CompilerGeneratedAttribute]
public Stream get_OutputStream();
    [CompilerGeneratedAttribute]
public void set_OutputStream(Stream value);
    public Byte[] get_StreamBuffer();
    public int get_BufferOffset();
    public int get_Position();
    protected Byte[] GetBuffer(int count, Int32& offset);
    [AsyncStateMachineAttribute("System.Xml.XmlStreamNodeWriter/<GetBufferAsync>d__19")]
protected Task`1<BytesWithOffset> GetBufferAsync(int count);
    protected void Advance(int count);
    private void EnsureByte();
    protected void WriteByte(byte b);
    protected Task WriteByteAsync(byte b);
    [AsyncStateMachineAttribute("System.Xml.XmlStreamNodeWriter/<FlushBufferAndWriteByteAsync>d__24")]
private Task FlushBufferAndWriteByteAsync(byte b);
    protected void WriteByte(char ch);
    protected Task WriteByteAsync(char ch);
    protected void WriteBytes(byte b1, byte b2);
    protected Task WriteBytesAsync(byte b1, byte b2);
    [AsyncStateMachineAttribute("System.Xml.XmlStreamNodeWriter/<FlushAndWriteBytesAsync>d__29")]
private Task FlushAndWriteBytesAsync(byte b1, byte b2);
    protected void WriteBytes(char ch1, char ch2);
    protected Task WriteBytesAsync(char ch1, char ch2);
    public void WriteBytes(Byte[] byteBuffer, int byteOffset, int byteCount);
    protected void WriteBytes(ReadOnlySpan`1<byte> bytes);
    protected void WriteUTF8Char(int ch);
    protected void WriteUTF8Chars(string value);
    protected void WriteUTF8Bytes(ReadOnlySpan`1<byte> value);
    protected void UnsafeWriteUTF8Chars(Char* chars, int charCount);
    protected void UnsafeWriteUnicodeChars(Char* chars, int charCount);
    protected static int UnsafeGetUnicodeChars(Char* chars, int charCount, Byte[] buffer, int offset);
    protected int UnsafeGetUTF8Length(Char* chars, int charCount);
    protected int UnsafeGetUTF8Chars(Char* chars, int charCount, Byte[] buffer, int offset);
    protected virtual void FlushBuffer();
    protected virtual Task FlushBufferAsync();
    public virtual void Flush();
    [AsyncStateMachineAttribute("System.Xml.XmlStreamNodeWriter/<FlushAsync>d__45")]
public virtual Task FlushAsync();
    public virtual void Close();
}
internal class System.Xml.XmlUTF8NodeWriter : XmlStreamNodeWriter {
    private Byte[] _entityChars;
    private Boolean[] _isEscapedAttributeChar;
    private Boolean[] _isEscapedElementChar;
    private bool _inAttribute;
    private static int bufferLength;
    private static int maxEntityLength;
    private Encoding _encoding;
    private Char[] _chars;
    private static Boolean[] s_defaultIsEscapedAttributeChar;
    private static Boolean[] s_defaultIsEscapedElementChar;
    private static ReadOnlySpan`1<byte> Digits { get; }
    public Encoding Encoding { get; }
    public XmlUTF8NodeWriter(Boolean[] isEscapedAttributeChar, Boolean[] isEscapedElementChar);
    private static XmlUTF8NodeWriter();
    private static ReadOnlySpan`1<byte> get_Digits();
    public void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    public Encoding get_Encoding();
    private Byte[] GetCharEntityBuffer();
    private Char[] GetCharBuffer(int charCount);
    public virtual void WriteDeclaration();
    public virtual void WriteCData(string text);
    private void WriteStartComment();
    private void WriteEndComment();
    public virtual void WriteComment(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<WriteStartElementAsync>d__25")]
public virtual Task WriteStartElementAsync(string prefix, string localName);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndStartElement(bool isEmpty);
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<WriteEndStartElementAsync>d__29")]
public virtual Task WriteEndStartElementAsync(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<WriteEndElementAsync>d__31")]
public virtual Task WriteEndElementAsync(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private void WriteStartXmlnsAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndAttribute();
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<WriteEndAttributeAsync>d__41")]
public virtual Task WriteEndAttributeAsync();
    private void WritePrefix(string prefix);
    private void WritePrefix(Byte[] prefixBuffer, int prefixOffset, int prefixLength);
    private void WriteLocalName(string localName);
    private void WriteLocalName(Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEscapedText(XmlDictionaryString s);
    public virtual void WriteEscapedText(string s);
    public virtual void WriteEscapedText(Char[] s, int offset, int count);
    private void UnsafeWriteEscapedText(Char* chars, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteText(int ch);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(XmlDictionaryString value);
    public void WriteLessThanCharEntity();
    public void WriteGreaterThanCharEntity();
    public void WriteAmpersandCharEntity();
    public void WriteApostropheCharEntity();
    public void WriteQuoteCharEntity();
    private void WriteHexCharEntity(int ch);
    public virtual void WriteCharEntity(int ch);
    private static int ToBase16(Byte[] chars, int offset, UInt32 value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<WriteBase64TextAsync>d__75")]
public virtual Task WriteBase64TextAsync(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void InternalWriteBase64Text(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Xml.XmlUTF8NodeWriter/<InternalWriteBase64TextAsync>d__77")]
private Task InternalWriteBase64TextAsync(Byte[] buffer, int offset, int count);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlUTF8TextReader : XmlBaseReader {
    private static int MaxTextChunk;
    private PrefixHandle _prefix;
    private StringHandle _localName;
    private Int32[] _rowOffsets;
    private OnXmlDictionaryReaderClose _onClose;
    private bool _buffered;
    private int _maxBytesPerRead;
    private static ReadOnlySpan`1<byte> CharTypeMap { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    private static ReadOnlySpan`1<byte> get_CharTypeMap();
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    private void SkipWhitespace();
    private void ReadDeclaration();
    private void VerifyNCName(string s);
    private void ReadQualifiedName(PrefixHandle prefix, StringHandle localName);
    private static int ReadAttributeText(Byte[] buffer, int offset, int offsetMax);
    private void ReadAttributes();
    private static bool IsNextCharacterNonFFFE(Byte[] buffer, int offset);
    private void ReadNonFFFE();
    private void BufferElement();
    private void ReadStartElement();
    private void ReadEndElement();
    private void ReadComment();
    private void ReadCData();
    private int ReadCharRef();
    private void ReadWhitespace();
    private static int ReadWhitespace(Byte[] buffer, int offset, int offsetMax);
    private static int ReadText(Byte[] buffer, int offset, int offsetMax);
    private int ReadTextAndWatchForInvalidCharacters(Byte[] buffer, int offset, int offsetMax);
    private static int BreakText(Byte[] buffer, int offset, int length);
    private void ReadText(bool hasLeadingByteOf0xEF);
    private void ReadEscapedText();
    public virtual bool Read();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    private void GetPosition(Int32& row, Int32& column);
}
internal class System.Xml.XmlUTF8TextWriter : XmlBaseWriter {
    private XmlUTF8NodeWriter _writer;
    public bool CanFragment { get; }
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual bool get_CanFragment();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
