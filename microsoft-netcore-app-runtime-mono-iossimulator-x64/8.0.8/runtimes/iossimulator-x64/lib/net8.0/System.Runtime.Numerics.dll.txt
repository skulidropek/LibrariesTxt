internal static class FxResources.System.Runtime.Numerics.SR : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Globalization.FormatProvider : object {
    internal static void FormatBigInteger(ValueStringBuilder& sb, int precision, int scale, bool sign, ReadOnlySpan`1<char> format, NumberFormatInfo numberFormatInfo, Char[] digits, int startIndex);
    internal static bool TryStringToBigInteger(ReadOnlySpan`1<char> s, NumberStyles styles, NumberFormatInfo numberFormatInfo, StringBuilder receiver, Int32& precision, Int32& scale, Boolean& sign);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("System.Numerics, Version=4.0.0.0, PublicKeyToken=b77a5c561934e089")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Numerics.BigInteger : ValueType {
    internal int _sign;
    [NullableAttribute("2")]
internal UInt32[] _bits;
    private static BigInteger s_bnMinInt;
    private static BigInteger s_bnOneInt;
    private static BigInteger s_bnZeroInt;
    private static BigInteger s_bnMinusOneInt;
    public static BigInteger Zero { get; }
    public static BigInteger One { get; }
    public static BigInteger MinusOne { get; }
    internal static int MaxLength { get; }
    public bool IsPowerOfTwo { get; }
    public bool IsZero { get; }
    public bool IsOne { get; }
    public bool IsEven { get; }
    public int Sign { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    private static BigInteger System.Numerics.IAdditiveIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.AdditiveIdentity { get; }
    private static BigInteger System.Numerics.IBinaryNumber<System.Numerics.BigInteger>.AllBitsSet { get; }
    private static BigInteger System.Numerics.IMultiplicativeIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.MultiplicativeIdentity { get; }
    private static int System.Numerics.INumberBase<System.Numerics.BigInteger>.Radix { get; }
    private static BigInteger System.Numerics.ISignedNumber<System.Numerics.BigInteger>.NegativeOne { get; }
    public BigInteger(int value);
    [CLSCompliantAttribute("False")]
public BigInteger(UInt32 value);
    public BigInteger(long value);
    [CLSCompliantAttribute("False")]
public BigInteger(ulong value);
    public BigInteger(float value);
    public BigInteger(double value);
    public BigInteger(decimal value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public BigInteger(Byte[] value);
    public BigInteger(ReadOnlySpan`1<byte> value, bool isUnsigned, bool isBigEndian);
    [NullableContextAttribute("2")]
internal BigInteger(int n, UInt32[] rgu);
    private BigInteger(ReadOnlySpan`1<UInt32> value, bool negative);
    private BigInteger(Span`1<UInt32> value);
    private static BigInteger();
    public static override BigInteger get_Zero();
    public static override BigInteger get_One();
    public static BigInteger get_MinusOne();
    internal static int get_MaxLength();
    public bool get_IsPowerOfTwo();
    public bool get_IsZero();
    public bool get_IsOne();
    public bool get_IsEven();
    public int get_Sign();
    [NullableContextAttribute("1")]
public static BigInteger Parse(string value);
    [NullableContextAttribute("1")]
public static BigInteger Parse(string value, NumberStyles style);
    [NullableContextAttribute("1")]
public static override BigInteger Parse(string value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override BigInteger Parse(string value, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string value, BigInteger& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string value, NumberStyles style, IFormatProvider provider, BigInteger& result);
    public static override BigInteger Parse(ReadOnlySpan`1<char> value, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> value, BigInteger& result);
    public static override bool TryParse(ReadOnlySpan`1<char> value, NumberStyles style, IFormatProvider provider, BigInteger& result);
    public static int Compare(BigInteger left, BigInteger right);
    public static override BigInteger Abs(BigInteger value);
    public static BigInteger Add(BigInteger left, BigInteger right);
    public static BigInteger Subtract(BigInteger left, BigInteger right);
    public static BigInteger Multiply(BigInteger left, BigInteger right);
    public static BigInteger Divide(BigInteger dividend, BigInteger divisor);
    public static BigInteger Remainder(BigInteger dividend, BigInteger divisor);
    public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, BigInteger& remainder);
    public static BigInteger Negate(BigInteger value);
    public static double Log(BigInteger value);
    public static double Log(BigInteger value, double baseValue);
    public static double Log10(BigInteger value);
    public static BigInteger GreatestCommonDivisor(BigInteger left, BigInteger right);
    private static BigInteger GreatestCommonDivisor(ReadOnlySpan`1<UInt32> leftBits, ReadOnlySpan`1<UInt32> rightBits);
    public static override BigInteger Max(BigInteger left, BigInteger right);
    public static override BigInteger Min(BigInteger left, BigInteger right);
    public static BigInteger ModPow(BigInteger value, BigInteger exponent, BigInteger modulus);
    public static BigInteger Pow(BigInteger value, int exponent);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(long other);
    [CLSCompliantAttribute("False")]
public bool Equals(ulong other);
    public sealed virtual bool Equals(BigInteger other);
    public int CompareTo(long other);
    [CLSCompliantAttribute("False")]
public int CompareTo(ulong other);
    public sealed virtual int CompareTo(BigInteger other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    [NullableContextAttribute("1")]
public Byte[] ToByteArray();
    [NullableContextAttribute("1")]
public Byte[] ToByteArray(bool isUnsigned, bool isBigEndian);
    public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten, bool isUnsigned, bool isBigEndian);
    internal bool TryWriteOrCountBytes(Span`1<byte> destination, Int32& bytesWritten, bool isUnsigned, bool isBigEndian);
    public int GetByteCount(bool isUnsigned);
    private Byte[] TryGetBytes(GetBytesMode mode, Span`1<byte> destination, bool isUnsigned, bool isBigEndian, Int32& bytesWritten);
    private int WriteTo(Span`1<UInt32> buffer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private string get_DebuggerDisplay();
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static BigInteger Add(ReadOnlySpan`1<UInt32> leftBits, int leftSign, ReadOnlySpan`1<UInt32> rightBits, int rightSign);
    public static override BigInteger op_Subtraction(BigInteger left, BigInteger right);
    private static BigInteger Subtract(ReadOnlySpan`1<UInt32> leftBits, int leftSign, ReadOnlySpan`1<UInt32> rightBits, int rightSign);
    public static byte op_Explicit(BigInteger value);
    public static char op_Explicit(BigInteger value);
    public static decimal op_Explicit(BigInteger value);
    public static double op_Explicit(BigInteger value);
    public static Half op_Explicit(BigInteger value);
    public static short op_Explicit(BigInteger value);
    public static int op_Explicit(BigInteger value);
    public static long op_Explicit(BigInteger value);
    public static Int128 op_Explicit(BigInteger value);
    public static IntPtr op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(BigInteger value);
    public static float op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(BigInteger value);
    public static BigInteger op_Explicit(decimal value);
    public static BigInteger op_Explicit(double value);
    public static BigInteger op_Explicit(Half value);
    public static BigInteger op_Explicit(Complex value);
    public static BigInteger op_Explicit(float value);
    public static BigInteger op_Implicit(byte value);
    public static BigInteger op_Implicit(char value);
    public static BigInteger op_Implicit(short value);
    public static BigInteger op_Implicit(int value);
    public static BigInteger op_Implicit(long value);
    public static BigInteger op_Implicit(Int128 value);
    public static BigInteger op_Implicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static BigInteger op_Implicit(UIntPtr value);
    public static override BigInteger op_BitwiseAnd(BigInteger left, BigInteger right);
    public static override BigInteger op_BitwiseOr(BigInteger left, BigInteger right);
    public static override BigInteger op_ExclusiveOr(BigInteger left, BigInteger right);
    public static override BigInteger op_LeftShift(BigInteger value, int shift);
    public static override BigInteger op_RightShift(BigInteger value, int shift);
    public static override BigInteger op_OnesComplement(BigInteger value);
    public static override BigInteger op_UnaryNegation(BigInteger value);
    public static override BigInteger op_UnaryPlus(BigInteger value);
    public static override BigInteger op_Increment(BigInteger value);
    public static override BigInteger op_Decrement(BigInteger value);
    public static override BigInteger op_Addition(BigInteger left, BigInteger right);
    public static override BigInteger op_Multiply(BigInteger left, BigInteger right);
    private static BigInteger Multiply(ReadOnlySpan`1<UInt32> left, int leftSign, ReadOnlySpan`1<UInt32> right, int rightSign);
    public static override BigInteger op_Division(BigInteger dividend, BigInteger divisor);
    public static override BigInteger op_Modulus(BigInteger dividend, BigInteger divisor);
    public static override bool op_LessThan(BigInteger left, BigInteger right);
    public static override bool op_LessThanOrEqual(BigInteger left, BigInteger right);
    public static override bool op_GreaterThan(BigInteger left, BigInteger right);
    public static override bool op_GreaterThanOrEqual(BigInteger left, BigInteger right);
    public static override bool op_Equality(BigInteger left, BigInteger right);
    public static override bool op_Inequality(BigInteger left, BigInteger right);
    public static bool op_LessThan(BigInteger left, long right);
    public static bool op_LessThanOrEqual(BigInteger left, long right);
    public static bool op_GreaterThan(BigInteger left, long right);
    public static bool op_GreaterThanOrEqual(BigInteger left, long right);
    public static bool op_Equality(BigInteger left, long right);
    public static bool op_Inequality(BigInteger left, long right);
    public static bool op_LessThan(long left, BigInteger right);
    public static bool op_LessThanOrEqual(long left, BigInteger right);
    public static bool op_GreaterThan(long left, BigInteger right);
    public static bool op_GreaterThanOrEqual(long left, BigInteger right);
    public static bool op_Equality(long left, BigInteger right);
    public static bool op_Inequality(long left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThan(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThanOrEqual(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThan(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThanOrEqual(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_Equality(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_Inequality(BigInteger left, ulong right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThan(ulong left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_LessThanOrEqual(ulong left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThan(ulong left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_GreaterThanOrEqual(ulong left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_Equality(ulong left, BigInteger right);
    [CLSCompliantAttribute("False")]
public static bool op_Inequality(ulong left, BigInteger right);
    public long GetBitLength();
    private bool GetPartsForBitManipulation(Span`1<UInt32> xd);
    [NullableContextAttribute("1")]
internal static int GetDiffLength(UInt32[] rgu1, UInt32[] rgu2, int cu);
    private static override BigInteger System.Numerics.IAdditiveIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.get_AdditiveIdentity();
    public static override ValueTuple`2<BigInteger, BigInteger> DivRem(BigInteger left, BigInteger right);
    public static override BigInteger LeadingZeroCount(BigInteger value);
    public static override BigInteger PopCount(BigInteger value);
    public static override BigInteger RotateLeft(BigInteger value, int rotateAmount);
    public static override BigInteger RotateRight(BigInteger value, int rotateAmount);
    public static override BigInteger TrailingZeroCount(BigInteger value);
    private static override bool System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, BigInteger& value);
    private static override bool System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, BigInteger& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Numerics.BigInteger>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private int GetGenericMathByteCount();
    private static override BigInteger System.Numerics.IBinaryNumber<System.Numerics.BigInteger>.get_AllBitsSet();
    public static override bool IsPow2(BigInteger value);
    public static override BigInteger Log2(BigInteger value);
    private static override BigInteger System.Numerics.IMultiplicativeIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.get_MultiplicativeIdentity();
    public static override BigInteger Clamp(BigInteger value, BigInteger min, BigInteger max);
    public static override BigInteger CopySign(BigInteger value, BigInteger sign);
    private static override BigInteger System.Numerics.INumber<System.Numerics.BigInteger>.MaxNumber(BigInteger x, BigInteger y);
    private static override BigInteger System.Numerics.INumber<System.Numerics.BigInteger>.MinNumber(BigInteger x, BigInteger y);
    private static override int System.Numerics.INumber<System.Numerics.BigInteger>.Sign(BigInteger value);
    private static override int System.Numerics.INumberBase<System.Numerics.BigInteger>.get_Radix();
    [NullableContextAttribute("1")]
public static override BigInteger CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override BigInteger CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override BigInteger CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsCanonical(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsComplexNumber(BigInteger value);
    public static override bool IsEvenInteger(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsFinite(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsImaginaryNumber(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsInfinity(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsInteger(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsNaN(BigInteger value);
    public static override bool IsNegative(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsNegativeInfinity(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsNormal(BigInteger value);
    public static override bool IsOddInteger(BigInteger value);
    public static override bool IsPositive(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsPositiveInfinity(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsRealNumber(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsSubnormal(BigInteger value);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.IsZero(BigInteger value);
    public static override BigInteger MaxMagnitude(BigInteger x, BigInteger y);
    private static override BigInteger System.Numerics.INumberBase<System.Numerics.BigInteger>.MaxMagnitudeNumber(BigInteger x, BigInteger y);
    public static override BigInteger MinMagnitude(BigInteger x, BigInteger y);
    private static override BigInteger System.Numerics.INumberBase<System.Numerics.BigInteger>.MinMagnitudeNumber(BigInteger x, BigInteger y);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertFromChecked(TOther value, BigInteger& result);
    private static bool TryConvertFromChecked(TOther value, BigInteger& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertFromSaturating(TOther value, BigInteger& result);
    private static bool TryConvertFromSaturating(TOther value, BigInteger& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertFromTruncating(TOther value, BigInteger& result);
    private static bool TryConvertFromTruncating(TOther value, BigInteger& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertToChecked(BigInteger value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertToSaturating(BigInteger value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.BigInteger>.TryConvertToTruncating(BigInteger value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, BigInteger& result);
    public static override BigInteger op_UnsignedRightShift(BigInteger value, int shiftAmount);
    private static override BigInteger System.Numerics.ISignedNumber<System.Numerics.BigInteger>.get_NegativeOne();
    public static override BigInteger Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, BigInteger& result);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <Clamp>g__ThrowMinMaxException|199_0(T min, T max);
}
internal static class System.Numerics.BigIntegerCalculator : object {
    internal static int StackAllocThreshold;
    private static void CopyTail(ReadOnlySpan`1<UInt32> source, Span`1<UInt32> dest, int start);
    public static void Add(ReadOnlySpan`1<UInt32> left, UInt32 right, Span`1<UInt32> bits);
    public static void Add(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> bits);
    private static void AddSelf(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right);
    public static void Subtract(ReadOnlySpan`1<UInt32> left, UInt32 right, Span`1<UInt32> bits);
    public static void Subtract(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> bits);
    private static void SubtractSelf(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right);
    private static void Add(ReadOnlySpan`1<UInt32> left, Span`1<UInt32> bits, UInt32& resultPtr, int startIndex, long initialCarry);
    private static void Subtract(ReadOnlySpan`1<UInt32> left, Span`1<UInt32> bits, UInt32& resultPtr, int startIndex, long initialCarry);
    public static void Divide(ReadOnlySpan`1<UInt32> left, UInt32 right, Span`1<UInt32> quotient, UInt32& remainder);
    public static void Divide(ReadOnlySpan`1<UInt32> left, UInt32 right, Span`1<UInt32> quotient);
    public static UInt32 Remainder(ReadOnlySpan`1<UInt32> left, UInt32 right);
    public static void Divide(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> quotient, Span`1<UInt32> remainder);
    public static void Divide(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> quotient);
    public static void Remainder(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> remainder);
    private static void Divide(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> bits);
    private static UInt32 AddDivisor(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right);
    private static UInt32 SubtractDivisor(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right, ulong q);
    private static bool DivideGuessTooBig(ulong q, ulong valHi, UInt32 valLo, UInt32 divHi, UInt32 divLo);
    public static UInt32 Gcd(UInt32 left, UInt32 right);
    public static ulong Gcd(ulong left, ulong right);
    public static UInt32 Gcd(ReadOnlySpan`1<UInt32> left, UInt32 right);
    public static void Gcd(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> result);
    private static void Gcd(Span`1<UInt32> left, Span`1<UInt32> right);
    private static int Overwrite(Span`1<UInt32> buffer, ulong value);
    private static void ExtractDigits(ReadOnlySpan`1<UInt32> xBuffer, ReadOnlySpan`1<UInt32> yBuffer, UInt64& x, UInt64& y);
    private static int LehmerCore(Span`1<UInt32> x, Span`1<UInt32> y, long a, long b, long c, long d);
    private static int Refresh(Span`1<UInt32> bits, int maxLength);
    public static void Pow(UInt32 value, UInt32 power, Span`1<UInt32> bits);
    public static void Pow(ReadOnlySpan`1<UInt32> value, UInt32 power, Span`1<UInt32> bits);
    private static Span`1<UInt32> PowCore(Span`1<UInt32> value, int valueLength, Span`1<UInt32> temp, UInt32 power, Span`1<UInt32> result);
    private static int MultiplySelf(Span`1& left, int leftLength, ReadOnlySpan`1<UInt32> right, Span`1& temp);
    private static int SquareSelf(Span`1& value, int valueLength, Span`1& temp);
    public static int PowBound(UInt32 power, int valueLength);
    public static UInt32 Pow(UInt32 value, UInt32 power, UInt32 modulus);
    public static UInt32 Pow(ReadOnlySpan`1<UInt32> value, UInt32 power, UInt32 modulus);
    public static UInt32 Pow(UInt32 value, ReadOnlySpan`1<UInt32> power, UInt32 modulus);
    public static UInt32 Pow(ReadOnlySpan`1<UInt32> value, ReadOnlySpan`1<UInt32> power, UInt32 modulus);
    private static UInt32 PowCore(ulong value, ReadOnlySpan`1<UInt32> power, UInt32 modulus, ulong result);
    private static UInt32 PowCore(ulong value, UInt32 power, UInt32 modulus, ulong result);
    public static void Pow(UInt32 value, UInt32 power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> bits);
    public static void Pow(ReadOnlySpan`1<UInt32> value, UInt32 power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> bits);
    public static void Pow(UInt32 value, ReadOnlySpan`1<UInt32> power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> bits);
    public static void Pow(ReadOnlySpan`1<UInt32> value, ReadOnlySpan`1<UInt32> power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> bits);
    private static void PowCore(Span`1<UInt32> value, int valueLength, ReadOnlySpan`1<UInt32> power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> temp, Span`1<UInt32> bits);
    private static void PowCore(Span`1<UInt32> value, int valueLength, UInt32 power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> temp, Span`1<UInt32> bits);
    private static Span`1<UInt32> PowCore(Span`1<UInt32> value, int valueLength, ReadOnlySpan`1<UInt32> power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> result, int resultLength, Span`1<UInt32> temp);
    private static Span`1<UInt32> PowCore(Span`1<UInt32> value, int valueLength, UInt32 power, ReadOnlySpan`1<UInt32> modulus, Span`1<UInt32> result, int resultLength, Span`1<UInt32> temp);
    private static Span`1<UInt32> PowCore(Span`1<UInt32> value, int valueLength, ReadOnlySpan`1<UInt32> power, FastReducer& reducer, Span`1<UInt32> result, int resultLength, Span`1<UInt32> temp);
    private static Span`1<UInt32> PowCore(Span`1<UInt32> value, int valueLength, UInt32 power, FastReducer& reducer, Span`1<UInt32> result, int resultLength, Span`1<UInt32> temp);
    public static void Square(ReadOnlySpan`1<UInt32> value, Span`1<UInt32> bits);
    public static void Multiply(ReadOnlySpan`1<UInt32> left, UInt32 right, Span`1<UInt32> bits);
    public static void Multiply(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> bits);
    private static void SubtractCore(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right, Span`1<UInt32> core);
    public static int Compare(ReadOnlySpan`1<UInt32> left, ReadOnlySpan`1<UInt32> right);
    private static int ActualLength(ReadOnlySpan`1<UInt32> value);
    private static int Reduce(Span`1<UInt32> bits, ReadOnlySpan`1<UInt32> modulus);
}
internal static class System.Numerics.BigNumber : object {
    private static int s_naiveThreshold;
    private static ReadOnlySpan`1<UInt32> UInt32PowersOfTen { get; }
    private static BigNumber();
    private static ReadOnlySpan`1<UInt32> get_UInt32PowersOfTen();
    [DoesNotReturnAttribute]
internal static void ThrowOverflowOrFormatException(ParsingStatus status);
    private static Exception GetException(ParsingStatus status);
    [NullableContextAttribute("2")]
internal static bool TryValidateParseStyleInteger(NumberStyles style, ArgumentException& e);
    [NullableContextAttribute("1")]
internal static ParsingStatus TryParseBigInteger(string value, NumberStyles style, NumberFormatInfo info, BigInteger& result);
    internal static ParsingStatus TryParseBigInteger(ReadOnlySpan`1<char> value, NumberStyles style, NumberFormatInfo info, BigInteger& result);
    [NullableContextAttribute("1")]
internal static BigInteger ParseBigInteger(string value, NumberStyles style, NumberFormatInfo info);
    internal static BigInteger ParseBigInteger(ReadOnlySpan`1<char> value, NumberStyles style, NumberFormatInfo info);
    private static ParsingStatus HexNumberToBigInteger(BigNumberBuffer& number, BigInteger& result);
    private static ParsingStatus NumberToBigInteger(BigNumberBuffer& number, BigInteger& result);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    private static string FormatBigIntegerToHex(bool targetSpan, BigInteger value, char format, int digits, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten, Boolean& spanSuccess);
    [NullableContextAttribute("1")]
internal static string FormatBigInteger(BigInteger value, string format, NumberFormatInfo info);
    internal static bool TryFormatBigInteger(BigInteger value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatBigInteger(bool targetSpan, BigInteger value, string formatString, ReadOnlySpan`1<char> formatSpan, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten, Boolean& spanSuccess);
    [CompilerGeneratedAttribute]
internal static ParsingStatus <NumberToBigInteger>g__Naive|14_0(BigNumberBuffer& number, BigInteger& result, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static bool <NumberToBigInteger>g__ProcessChunk|14_4(ReadOnlySpan`1<char> chunkDigits, Span`1& currentBuffer, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [CompilerGeneratedAttribute]
internal static ParsingStatus <NumberToBigInteger>g__DivideAndConquer|14_1(BigNumberBuffer& number, BigInteger& result, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static BigInteger <NumberToBigInteger>g__NumberBufferToBigInteger|14_2(Span`1<UInt32> currentBuffer, bool signa, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static void <NumberToBigInteger>g__MultiplyAdd|14_3(Span`1& currentBuffer, UInt32 multiplier, UInt32 addValue, <>c__DisplayClass14_0& );
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Numerics.Complex : ValueType {
    public static Complex Zero;
    public static Complex One;
    public static Complex ImaginaryOne;
    public static Complex NaN;
    public static Complex Infinity;
    private static double s_sqrtRescaleThreshold;
    private static double s_asinOverflowThreshold;
    private static double s_log2;
    private double m_real;
    private double m_imaginary;
    public double Real { get; }
    public double Imaginary { get; }
    public double Magnitude { get; }
    public double Phase { get; }
    private static Complex System.Numerics.IAdditiveIdentity<System.Numerics.Complex,System.Numerics.Complex>.AdditiveIdentity { get; }
    private static Complex System.Numerics.IMultiplicativeIdentity<System.Numerics.Complex,System.Numerics.Complex>.MultiplicativeIdentity { get; }
    private static Complex System.Numerics.INumberBase<System.Numerics.Complex>.One { get; }
    private static int System.Numerics.INumberBase<System.Numerics.Complex>.Radix { get; }
    private static Complex System.Numerics.INumberBase<System.Numerics.Complex>.Zero { get; }
    private static Complex System.Numerics.ISignedNumber<System.Numerics.Complex>.NegativeOne { get; }
    public Complex(double real, double imaginary);
    private static Complex();
    public double get_Real();
    public double get_Imaginary();
    public double get_Magnitude();
    public double get_Phase();
    public static Complex FromPolarCoordinates(double magnitude, double phase);
    public static Complex Negate(Complex value);
    public static Complex Add(Complex left, Complex right);
    public static Complex Add(Complex left, double right);
    public static Complex Add(double left, Complex right);
    public static Complex Subtract(Complex left, Complex right);
    public static Complex Subtract(Complex left, double right);
    public static Complex Subtract(double left, Complex right);
    public static Complex Multiply(Complex left, Complex right);
    public static Complex Multiply(Complex left, double right);
    public static Complex Multiply(double left, Complex right);
    public static Complex Divide(Complex dividend, Complex divisor);
    public static Complex Divide(Complex dividend, double divisor);
    public static Complex Divide(double dividend, Complex divisor);
    public static override Complex op_UnaryNegation(Complex value);
    public static override Complex op_Addition(Complex left, Complex right);
    public static Complex op_Addition(Complex left, double right);
    public static Complex op_Addition(double left, Complex right);
    public static override Complex op_Subtraction(Complex left, Complex right);
    public static Complex op_Subtraction(Complex left, double right);
    public static Complex op_Subtraction(double left, Complex right);
    public static override Complex op_Multiply(Complex left, Complex right);
    public static Complex op_Multiply(Complex left, double right);
    public static Complex op_Multiply(double left, Complex right);
    public static override Complex op_Division(Complex left, Complex right);
    public static Complex op_Division(Complex left, double right);
    public static Complex op_Division(double left, Complex right);
    public static double Abs(Complex value);
    private static double Hypot(double a, double b);
    private static double Log1P(double x);
    public static Complex Conjugate(Complex value);
    public static Complex Reciprocal(Complex value);
    public static override bool op_Equality(Complex left, Complex right);
    public static override bool op_Inequality(Complex left, Complex right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Complex value);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Complex Sin(Complex value);
    public static Complex Sinh(Complex value);
    public static Complex Asin(Complex value);
    public static Complex Cos(Complex value);
    public static Complex Cosh(Complex value);
    public static Complex Acos(Complex value);
    public static Complex Tan(Complex value);
    public static Complex Tanh(Complex value);
    public static Complex Atan(Complex value);
    private static void Asin_Internal(double x, double y, Double& b, Double& bPrime, Double& v);
    public static override bool IsFinite(Complex value);
    public static override bool IsInfinity(Complex value);
    public static override bool IsNaN(Complex value);
    public static Complex Log(Complex value);
    public static Complex Log(Complex value, double baseValue);
    public static Complex Log10(Complex value);
    public static Complex Exp(Complex value);
    public static Complex Sqrt(Complex value);
    public static Complex Pow(Complex value, Complex power);
    public static Complex Pow(Complex value, double power);
    private static Complex Scale(Complex value, double factor);
    public static Complex op_Explicit(decimal value);
    public static Complex op_Explicit(Int128 value);
    public static Complex op_Explicit(BigInteger value);
    [CLSCompliantAttribute("False")]
public static Complex op_Explicit(UInt128 value);
    public static Complex op_Implicit(byte value);
    public static Complex op_Implicit(char value);
    public static Complex op_Implicit(double value);
    public static Complex op_Implicit(Half value);
    public static Complex op_Implicit(short value);
    public static Complex op_Implicit(int value);
    public static Complex op_Implicit(long value);
    public static Complex op_Implicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(sbyte value);
    public static Complex op_Implicit(float value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static Complex op_Implicit(UIntPtr value);
    private static override Complex System.Numerics.IAdditiveIdentity<System.Numerics.Complex,System.Numerics.Complex>.get_AdditiveIdentity();
    public static override Complex op_Decrement(Complex value);
    public static override Complex op_Increment(Complex value);
    private static override Complex System.Numerics.IMultiplicativeIdentity<System.Numerics.Complex,System.Numerics.Complex>.get_MultiplicativeIdentity();
    private static override Complex System.Numerics.INumberBase<System.Numerics.Complex>.get_One();
    private static override int System.Numerics.INumberBase<System.Numerics.Complex>.get_Radix();
    private static override Complex System.Numerics.INumberBase<System.Numerics.Complex>.get_Zero();
    private static override Complex System.Numerics.INumberBase<System.Numerics.Complex>.Abs(Complex value);
    [NullableContextAttribute("1")]
public static override Complex CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override Complex CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override Complex CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.IsCanonical(Complex value);
    public static override bool IsComplexNumber(Complex value);
    public static override bool IsEvenInteger(Complex value);
    public static override bool IsImaginaryNumber(Complex value);
    public static override bool IsInteger(Complex value);
    public static override bool IsNegative(Complex value);
    public static override bool IsNegativeInfinity(Complex value);
    public static override bool IsNormal(Complex value);
    public static override bool IsOddInteger(Complex value);
    public static override bool IsPositive(Complex value);
    public static override bool IsPositiveInfinity(Complex value);
    public static override bool IsRealNumber(Complex value);
    public static override bool IsSubnormal(Complex value);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.IsZero(Complex value);
    public static override Complex MaxMagnitude(Complex x, Complex y);
    private static override Complex System.Numerics.INumberBase<System.Numerics.Complex>.MaxMagnitudeNumber(Complex x, Complex y);
    public static override Complex MinMagnitude(Complex x, Complex y);
    private static override Complex System.Numerics.INumberBase<System.Numerics.Complex>.MinMagnitudeNumber(Complex x, Complex y);
    public static override Complex Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override Complex Parse(string s, NumberStyles style, IFormatProvider provider);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertFromChecked(TOther value, Complex& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertFromSaturating(TOther value, Complex& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertFromTruncating(TOther value, Complex& result);
    private static bool TryConvertFrom(TOther value, Complex& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertToChecked(Complex value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertToSaturating(Complex value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Numerics.Complex>.TryConvertToTruncating(Complex value, TOther& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Complex& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Complex& result);
    [NullableContextAttribute("1")]
public static override Complex Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Complex& result);
    private static override Complex System.Numerics.ISignedNumber<System.Numerics.Complex>.get_NegativeOne();
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private bool TryFormatCore(Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override Complex Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Complex& result);
    public static override Complex op_UnaryPlus(Complex value);
    [CompilerGeneratedAttribute]
internal static void <TryParse>g__ValidateParseStyleFloatingPoint|145_0(NumberStyles style);
    [CompilerGeneratedAttribute]
internal static void <TryParse>g__ThrowInvalid|145_1(NumberStyles value);
}
internal static class System.Numerics.NumericsHelpers : object {
    public static void GetDoubleParts(double dbl, Int32& sign, Int32& exp, UInt64& man, Boolean& fFinite);
    public static double GetDoubleFromParts(int sign, int exp, ulong man);
    public static void DangerousMakeTwosComplement(Span`1<UInt32> d);
    public static ulong MakeUInt64(UInt32 uHi, UInt32 uLo);
    public static UInt32 Abs(int a);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_HexStyleNotSupported { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidHexStyle { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MustBeBigInt { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Format_TooLarge { get; }
    internal static string Overflow_BigIntInfinity { get; }
    internal static string Overflow_NotANumber { get; }
    internal static string Overflow_ParseBigInteger { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_Int128 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string Overflow_UInt128 { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Negative_Unsigned { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_HexStyleNotSupported();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidHexStyle();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MustBeBigInt();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Format_TooLarge();
    internal static string get_Overflow_BigIntInfinity();
    internal static string get_Overflow_NotANumber();
    internal static string get_Overflow_ParseBigInteger();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_Int128();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_Overflow_UInt128();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Negative_Unsigned();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    [NullableContextAttribute("2")]
public void Insert(int index, string s);
    public void Append(char c);
    [NullableContextAttribute("2")]
public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException();
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException();
    [DoesNotReturnAttribute]
internal static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
}
