internal static class FxResources.System.Net.HttpListener.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
internal enum System.Net.BoundaryType : Enum {
    public int value__;
    public static BoundaryType ContentLength;
    public static BoundaryType Chunked;
    public static BoundaryType Multipart;
    public static BoundaryType None;
    public static BoundaryType Invalid;
}
internal class System.Net.CaseInsensitiveAscii : object {
    internal static ReadOnlySpan`1<byte> AsciiToLower { get; }
    internal static ReadOnlySpan`1<byte> get_AsciiToLower();
    public sealed virtual int GetHashCode(object myObject);
    public sealed virtual int Compare(object firstObject, object secondObject);
    private static int FastGetHashCode(string myString);
    public sealed virtual bool Equals(object firstObject, object secondObject);
}
internal class System.Net.ChunkedInputStream : HttpRequestStream {
    private ChunkStream _decoder;
    private HttpListenerContext _context;
    private bool _no_more_data;
    public ChunkedInputStream(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length);
    protected virtual int ReadCore(Byte[] buffer, int offset, int count);
    protected virtual IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    private void OnRead(IAsyncResult base_ares);
    public virtual int EndRead(IAsyncResult asyncResult);
}
internal class System.Net.ChunkStream : object {
    internal WebHeaderCollection _headers;
    private int _chunkSize;
    private int _chunkRead;
    private int _totalWritten;
    private State _state;
    private StringBuilder _saved;
    private bool _sawCR;
    private bool _gotit;
    private int _trailerState;
    private List`1<Chunk> _chunks;
    public bool WantMore { get; }
    public int ChunkLeft { get; }
    public ChunkStream(WebHeaderCollection headers);
    public int Read(Byte[] buffer, int offset, int size);
    private int ReadFromChunks(Byte[] buffer, int offset, int size);
    public void Write(Byte[] buffer, int offset, int size);
    private void InternalWrite(Byte[] buffer, Int32& offset, int size);
    public bool get_WantMore();
    public int get_ChunkLeft();
    private State ReadBody(Byte[] buffer, Int32& offset, int size);
    private State GetChunkSize(Byte[] buffer, Int32& offset, int size);
    private static string RemoveChunkExtension(string input);
    private State ReadCRLF(Byte[] buffer, Int32& offset, int size);
    private State ReadTrailer(Byte[] buffer, Int32& offset, int size);
    private static void ThrowProtocolViolation(string message);
}
[ExtensionAttribute]
internal static class System.Net.CookieCollectionExtensions : object {
    private static Func`4<CookieCollection, Cookie, bool, int> s_internalAddFunc;
    [ExtensionAttribute]
public static int InternalAdd(CookieCollection cookieCollection, Cookie cookie, bool isStrict);
}
[ExtensionAttribute]
internal static class System.Net.CookieExtensions : object {
    private static Func`2<Cookie, string> s_toServerStringFunc;
    private static Func`2<Cookie, Cookie> s_cloneFunc;
    private static Func`2<Cookie, CookieVariant> s_getVariantFunc;
    [ExtensionAttribute]
public static string ToServerString(Cookie cookie);
    [ExtensionAttribute]
public static Cookie Clone(Cookie cookie);
    [ExtensionAttribute]
public static bool IsRfc2965Variant(Cookie cookie);
}
internal class System.Net.CookieParser : ValueType {
    private CookieTokenizer _tokenizer;
    private Cookie _savedCookie;
    private static Func`3<Cookie, string, bool> s_internalSetNameMethod;
    private static FieldInfo s_isQuotedDomainField;
    private static Func`3<Cookie, string, bool> InternalSetNameMethod { get; }
    private static FieldInfo IsQuotedDomainField { get; }
    internal CookieParser(string cookieString);
    private static Func`3<Cookie, string, bool> get_InternalSetNameMethod();
    private static FieldInfo get_IsQuotedDomainField();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : ValueType {
    private bool _eofCookie;
    private int _index;
    private int _length;
    private string _name;
    private bool _quoted;
    private int _start;
    private CookieToken _token;
    private int _tokenLength;
    private string _tokenStream;
    private string _value;
    private int _cookieStartIndex;
    private int _cookieLength;
    private static RecognizedAttribute[] s_recognizedAttributes;
    private static RecognizedAttribute[] s_recognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.EntitySendFormat : Enum {
    public int value__;
    public static EntitySendFormat ContentLength;
    public static EntitySendFormat Chunked;
}
internal class System.Net.HttpConnection : object {
    private static AsyncCallback s_onreadCallback;
    private Socket _socket;
    private Stream _stream;
    private HttpEndPointListener _epl;
    private MemoryStream _memoryStream;
    private Byte[] _buffer;
    private HttpListenerContext _context;
    private StringBuilder _currentLine;
    private ListenerPrefix _prefix;
    private HttpRequestStream _requestStream;
    private HttpResponseStream _responseStream;
    private bool _chunked;
    private int _reuses;
    private bool _contextBound;
    private bool _secure;
    private X509Certificate _cert;
    private int _timeout;
    private Timer _timer;
    private IPEndPoint _localEndPoint;
    private HttpListener _lastListener;
    private Int32[] _clientCertErrors;
    private X509Certificate2 _clientCert;
    private SslStream _sslStream;
    private InputState _inputState;
    private LineState _lineState;
    private int _position;
    internal Int32[] ClientCertificateErrors { get; }
    internal X509Certificate2 ClientCertificate { get; }
    public Stream ConnectedStream { get; }
    public int Reuses { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public bool IsSecure { get; }
    unknown ListenerPrefix Prefix {public set; }
    public HttpConnection(Socket sock, HttpEndPointListener epl, bool secure, X509Certificate cert);
    private static HttpConnection();
    internal Int32[] get_ClientCertificateErrors();
    internal X509Certificate2 get_ClientCertificate();
    [MemberNotNullAttribute("_memoryStream")]
[MemberNotNullAttribute("_context")]
private void Init();
    public Stream get_ConnectedStream();
    public int get_Reuses();
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    public bool get_IsSecure();
    public void set_Prefix(ListenerPrefix value);
    private void OnTimeout(object unused);
    public void BeginReadRequest();
    public HttpRequestStream GetRequestStream(bool chunked, long contentlength);
    public HttpResponseStream GetResponseStream();
    private static void OnRead(IAsyncResult ares);
    private void OnReadInternal(IAsyncResult ares);
    private void RemoveConnection();
    private bool ProcessInput(MemoryStream ms);
    private string ReadLine(Byte[] buffer, int offset, int len, Int32& used);
    public void SendError(string msg, int status);
    public void SendError();
    private void Unbind();
    private void CloseSocket();
    internal void Close(bool force);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__27_0(object t, X509Certificate c, X509Chain ch, SslPolicyErrors e);
}
internal class System.Net.HttpEndPointListener : object {
    private HttpListener _listener;
    private IPEndPoint _endpoint;
    private Socket _socket;
    private Dictionary`2<HttpConnection, HttpConnection> _unregisteredConnections;
    private Dictionary`2<ListenerPrefix, HttpListener> _prefixes;
    private List`1<ListenerPrefix> _unhandledPrefixes;
    private List`1<ListenerPrefix> _allPrefixes;
    private X509Certificate _cert;
    private bool _secure;
    public HttpEndPointListener(HttpListener listener, IPAddress addr, int port, bool secure);
    private void Accept(SocketAsyncEventArgs e);
    private static void ProcessAccept(SocketAsyncEventArgs args);
    private static void OnAccept(object sender, SocketAsyncEventArgs e);
    internal void RemoveConnection(HttpConnection conn);
    public bool BindContext(HttpListenerContext context);
    public static void UnbindContext(HttpListenerContext context);
    private HttpListener SearchListener(Uri uri, ListenerPrefix& prefix);
    private static HttpListener MatchFromList(string host, string path, List`1<ListenerPrefix> list, ListenerPrefix& prefix);
    private static void AddSpecial(List`1<ListenerPrefix> list, ListenerPrefix prefix);
    private static bool RemoveSpecial(List`1<ListenerPrefix> list, ListenerPrefix prefix);
    private void CheckIfRemove();
    public void Close();
    public void AddPrefix(ListenerPrefix prefix, HttpListener listener);
    public void RemovePrefix(ListenerPrefix prefix, HttpListener listener);
}
internal class System.Net.HttpEndPointManager : object {
    private static Dictionary`2<IPAddress, Dictionary`2<int, HttpEndPointListener>> s_ipEndPoints;
    private static HttpEndPointManager();
    public static void AddListener(HttpListener listener);
    public static void AddPrefix(string prefix, HttpListener listener);
    private static void AddPrefixInternal(string p, HttpListener listener);
    private static HttpEndPointListener GetEPListener(string host, int port, HttpListener listener, bool secure);
    public static void RemoveEndPoint(HttpEndPointListener epl, IPEndPoint ep);
    public static void RemoveListener(HttpListener listener);
    public static void RemovePrefix(string prefix, HttpListener listener);
    private static void RemovePrefixInternal(string prefix, HttpListener listener);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListener : object {
    private object _internalLock;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private HttpListenerPrefixCollection _prefixes;
    internal Hashtable _uriPrefixes;
    private bool _ignoreWriteExceptions;
    private ServiceNameStore _defaultServiceNames;
    private HttpListenerTimeoutManager _timeoutManager;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private AuthenticationSchemeSelector _authenticationDelegate;
    private AuthenticationSchemes _authenticationScheme;
    private ExtendedProtectionSelector _extendedProtectionSelectorDelegate;
    private string _realm;
    private Dictionary`2<HttpListenerContext, HttpListenerContext> _listenerContexts;
    private List`1<HttpListenerContext> _contextQueue;
    private List`1<ListenerAsyncResult> _asyncWaitQueue;
    private Dictionary`2<HttpConnection, HttpConnection> _connections;
    private bool _unsafeConnectionNtlmAuthentication;
    internal ICollection PrefixCollection { get; }
    [NullableAttribute("2")]
public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    [NullableAttribute("2")]
public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    [NullableAttribute("2")]
public string Realm { get; public set; }
    public bool IsListening { get; }
    public bool IgnoreWriteExceptions { get; public set; }
    public static bool IsSupported { get; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    internal ICollection get_PrefixCollection();
    [NullableContextAttribute("2")]
public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    [NullableContextAttribute("2")]
public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    [NullableContextAttribute("2")]
public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    [NullableContextAttribute("2")]
public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public HttpListenerPrefixCollection get_Prefixes();
    internal void AddPrefix(string uriPrefix);
    internal bool ContainsPrefix(string uriPrefix);
    internal bool RemovePrefix(string uriPrefix);
    internal void RemoveAll(bool clear);
    [NullableContextAttribute("2")]
public string get_Realm();
    [NullableContextAttribute("2")]
public void set_Realm(string value);
    public bool get_IsListening();
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public Task`1<HttpListenerContext> GetContextAsync();
    public void Close();
    internal void CheckDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
    public static bool get_IsSupported();
    public HttpListenerTimeoutManager get_TimeoutManager();
    private void AddPrefixCore(string uriPrefix);
    private void RemovePrefixCore(string uriPrefix);
    public void Start();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public void Stop();
    public void Abort();
    private void Dispose();
    private void Close(bool force);
    internal void UnregisterContext(HttpListenerContext context);
    internal void AddConnection(HttpConnection cnc);
    internal void RemoveConnection(HttpConnection cnc);
    internal void RegisterContext(HttpListenerContext context);
    private void Cleanup(bool close_existing);
    private HttpListenerContext GetContextFromQueue();
    [NullableContextAttribute("2")]
public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context);
    public HttpListenerContext GetContext();
    internal static SslStream CreateSslStream(Stream innerStream, bool ownsStream, RemoteCertificateValidationCallback callback);
    internal static X509Certificate LoadCertificateAndKey(IPAddress addr, int port);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    [CompilerGeneratedAttribute]
public virtual string get_Password();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerContext : object {
    internal HttpListener _listener;
    private HttpListenerResponse _response;
    private IPrincipal _user;
    [CompilerGeneratedAttribute]
private HttpListenerRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationSchemes <AuthenticationSchemes>k__BackingField;
    private HttpConnection _connection;
    [CompilerGeneratedAttribute]
private int <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public HttpListenerRequest Request { get; }
    [NullableAttribute("2")]
public IPrincipal User { get; }
    internal AuthenticationSchemes AuthenticationSchemes { get; internal set; }
    public HttpListenerResponse Response { get; }
    internal int ErrorStatus { get; internal set; }
    [NullableAttribute("2")]
internal string ErrorMessage { get; internal set; }
    internal bool HaveError { get; }
    internal HttpConnection Connection { get; }
    internal HttpListenerContext(HttpConnection connection);
    [CompilerGeneratedAttribute]
public HttpListenerRequest get_Request();
    [NullableContextAttribute("2")]
public IPrincipal get_User();
    [CompilerGeneratedAttribute]
internal AuthenticationSchemes get_AuthenticationSchemes();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationSchemes(AuthenticationSchemes value);
    public HttpListenerResponse get_Response();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    [CompilerGeneratedAttribute]
internal int get_ErrorStatus();
    [CompilerGeneratedAttribute]
internal void set_ErrorStatus(int value);
    [CompilerGeneratedAttribute]
internal string get_ErrorMessage();
    [CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
    internal bool get_HaveError();
    internal HttpConnection get_Connection();
    internal void ParseAuthentication(AuthenticationSchemes expectedSchemes);
    internal static IPrincipal ParseBasicAuthentication(string authData);
    internal static bool IsBasicHeader(string header);
    internal static bool TryParseBasicAuth(string headerValue, HttpStatusCode& errorCode, String& username, String& password);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [NullableContextAttribute("0")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerPrefixCollection : object {
    private HttpListener _httpListener;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual int get_Count();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual bool Contains(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    public sealed virtual void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerRequest : object {
    private CookieCollection _cookies;
    private Nullable`1<bool> _keepAlive;
    private string _rawUrl;
    private Uri _requestUri;
    private Version _version;
    [CompilerGeneratedAttribute]
private ListenerClientCertState <ClientCertState>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCertificate>k__BackingField;
    private long _contentLength;
    private bool _clSet;
    private WebHeaderCollection _headers;
    private string _method;
    private Stream _inputStream;
    private HttpListenerContext _context;
    private bool _isChunked;
    private static Byte[] s_100continue;
    [CompilerGeneratedAttribute]
private Guid <RequestTraceIdentifier>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AcceptTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] UserLanguages { get; }
    public CookieCollection Cookies { get; }
    public Encoding ContentEncoding { get; }
    [NullableAttribute("2")]
public string ContentType { get; }
    public bool IsLocal { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public NameValueCollection QueryString { get; }
    [NullableAttribute("2")]
public string RawUrl { get; }
    private string RequestScheme { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    [NullableAttribute("2")]
public Uri UrlReferrer { get; }
    [NullableAttribute("2")]
public Uri Url { get; }
    public Version ProtocolVersion { get; }
    internal ListenerClientCertState ClientCertState { get; internal set; }
    [NullableAttribute("2")]
internal X509Certificate2 ClientCertificate { get; internal set; }
    public int ClientCertificateError { get; }
    public long ContentLength64 { get; }
    public bool HasEntityBody { get; }
    public NameValueCollection Headers { get; }
    [NullableAttribute("2")]
public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsSecureConnection { get; }
    [NullableAttribute("2")]
public IPEndPoint LocalEndPoint { get; }
    [NullableAttribute("2")]
public IPEndPoint RemoteEndPoint { get; }
    public Guid RequestTraceIdentifier { get; }
    [NullableAttribute("2")]
public string ServiceName { get; }
    public TransportContext TransportContext { get; }
    [NullableAttribute("2")]
private Uri RequestUri { get; }
    internal HttpListenerRequest(HttpListenerContext context);
    private static HttpListenerRequest();
    public String[] get_AcceptTypes();
    public String[] get_UserLanguages();
    private CookieCollection ParseCookies(Uri uri, string setCookieHeader);
    public CookieCollection get_Cookies();
    public Encoding get_ContentEncoding();
    [NullableContextAttribute("2")]
public string get_ContentType();
    public bool get_IsLocal();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public NameValueCollection get_QueryString();
    [NullableContextAttribute("2")]
public string get_RawUrl();
    private string get_RequestScheme();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    [NullableContextAttribute("2")]
public Uri get_UrlReferrer();
    [NullableContextAttribute("2")]
public Uri get_Url();
    public Version get_ProtocolVersion();
    [NullableContextAttribute("2")]
public X509Certificate2 GetClientCertificate();
    [NullableContextAttribute("2")]
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public Task`1<X509Certificate2> GetClientCertificateAsync();
    [CompilerGeneratedAttribute]
internal ListenerClientCertState get_ClientCertState();
    [CompilerGeneratedAttribute]
internal void set_ClientCertState(ListenerClientCertState value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_ClientCertificate();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificate(X509Certificate2 value);
    public int get_ClientCertificateError();
    internal void SetRequestLine(string req);
    private static bool MaybeUri(string s);
    private static bool IsPredefinedScheme(string scheme);
    internal void FinishInitialization();
    internal void AddHeader(string header);
    internal bool FlushInput();
    private X509Certificate2 GetClientCertificateCore();
    private int GetClientCertificateErrorCore();
    public long get_ContentLength64();
    public bool get_HasEntityBody();
    public NameValueCollection get_Headers();
    [NullableContextAttribute("2")]
public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsSecureConnection();
    [NullableContextAttribute("2")]
public IPEndPoint get_LocalEndPoint();
    [NullableContextAttribute("2")]
public IPEndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public Guid get_RequestTraceIdentifier();
    private IAsyncResult BeginGetClientCertificateCore(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    [NullableContextAttribute("2")]
public string get_ServiceName();
    public TransportContext get_TransportContext();
    private Uri get_RequestUri();
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_ansiEncoding;
    private string _rawUri;
    private string _cookedUriScheme;
    private string _cookedUriHost;
    private string _cookedUriPath;
    private string _cookedUriQuery;
    private StringBuilder _requestUriString;
    private List`1<byte> _rawOctets;
    private string _rawPath;
    private Uri _requestUri;
    private HttpListenerRequestUriBuilder(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private static HttpListenerRequestUriBuilder();
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private Uri Build();
    private void BuildRequestUriUsingCookedPath();
    private void BuildRequestUriUsingRawPath();
    private static Encoding GetEncoding(EncodingType type);
    private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding);
    private ParsingResult ParseRawPath(Encoding encoding);
    private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint);
    private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter);
    private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding);
    private static void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets);
    private static string GetOctetsAsString(List`1<byte> octets);
    private static string GetPath(string uriString);
    private static string AddSlashToAsteriskOnlyPath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerResponse : object {
    private BoundaryType _boundaryType;
    private CookieCollection _cookies;
    private HttpListenerContext _httpContext;
    private bool _keepAlive;
    private HttpResponseStream _responseStream;
    private string _statusDescription;
    private WebHeaderCollection _webHeaders;
    [CompilerGeneratedAttribute]
private Encoding <ContentEncoding>k__BackingField;
    private long _contentLength;
    private Version _version;
    private int _statusCode;
    internal object _headersLock;
    private bool _forceCloseChunked;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SentHeaders>k__BackingField;
    public WebHeaderCollection Headers { get; public set; }
    [NullableAttribute("2")]
public Encoding ContentEncoding { get; public set; }
    [NullableAttribute("2")]
public string ContentType { get; public set; }
    private HttpListenerContext HttpListenerContext { get; }
    private HttpListenerRequest HttpListenerRequest { get; }
    internal EntitySendFormat EntitySendFormat { get; internal set; }
    public bool SendChunked { get; public set; }
    public long ContentLength64 { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    [NullableAttribute("2")]
public string RedirectLocation { get; public set; }
    public string StatusDescription { get; public set; }
    internal bool ForceCloseChunked { get; }
    public Version ProtocolVersion { get; public set; }
    public int StatusCode { get; public set; }
    private bool Disposed { get; private set; }
    internal bool SentHeaders { get; internal set; }
    internal HttpListenerResponse(HttpListenerContext context);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Encoding get_ContentEncoding();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ContentEncoding(Encoding value);
    [NullableContextAttribute("2")]
public string get_ContentType();
    [NullableContextAttribute("2")]
public void set_ContentType(string value);
    private HttpListenerContext get_HttpListenerContext();
    private HttpListenerRequest get_HttpListenerRequest();
    internal EntitySendFormat get_EntitySendFormat();
    internal void set_EntitySendFormat(EntitySendFormat value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    private static bool CanSendResponseBody(int responseCode);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    [NullableContextAttribute("2")]
public string get_RedirectLocation();
    [NullableContextAttribute("2")]
public void set_RedirectLocation(string value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public void AddHeader(string name, string value);
    public void AppendHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    private void ComputeCookies();
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
    private void CheckDisposed();
    private void CheckSentHeaders();
    internal bool get_ForceCloseChunked();
    private void EnsureResponseStream();
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    private void Dispose();
    public void Close();
    public void Abort();
    private void Close(bool force);
    public void Close(Byte[] responseEntity, bool willBlock);
    public void CopyFrom(HttpListenerResponse templateResponse);
    internal void SendHeaders(bool closing, MemoryStream ms, bool isWebSocketHandshake);
    private static bool HeaderCanHaveEmptyValue(string name);
    private static string FormatHeaders(WebHeaderCollection headers);
    [CompilerGeneratedAttribute]
private bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SentHeaders();
    [CompilerGeneratedAttribute]
internal void set_SentHeaders(bool value);
}
public class System.Net.HttpListenerTimeoutManager : object {
    private TimeSpan _drainEntityBody;
    private TimeSpan _idleConnection;
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    internal HttpListenerTimeoutManager(HttpListener listener);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_EntityBody();
    [SupportedOSPlatformAttribute("windows")]
public void set_EntityBody(TimeSpan value);
    public TimeSpan get_HeaderWait();
    [SupportedOSPlatformAttribute("windows")]
public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    [SupportedOSPlatformAttribute("windows")]
public void set_MinSendBytesPerSecond(long value);
    public TimeSpan get_RequestQueue();
    [SupportedOSPlatformAttribute("windows")]
public void set_RequestQueue(TimeSpan value);
    private static void ValidateTimeout(TimeSpan value);
}
internal class System.Net.HttpRequestStream : Stream {
    private Byte[] _buffer;
    private int _offset;
    private int _length;
    private long _remainingBody;
    protected bool _closed;
    private Stream _stream;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpRequestStream(Stream stream, Byte[] buffer, int offset, int length);
    internal HttpRequestStream(Stream stream, Byte[] buffer, int offset, int length, long contentlength);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    private int FillFromBuffer(Byte[] buffer, int offset, int count);
    protected virtual int ReadCore(Byte[] buffer, int offset, int size);
    protected virtual IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
}
internal class System.Net.HttpResponseStream : Stream {
    private bool _closed;
    private HttpListenerResponse _response;
    private bool _ignore_errors;
    private bool _trailer_sent;
    private Stream _stream;
    private static Byte[] s_crlf;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpResponseStream(Stream stream, HttpListenerResponse response, bool ignore_errors);
    private static HttpResponseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    private void DisposeCore();
    [AsyncStateMachineAttribute("System.Net.HttpResponseStream/<WriteWebSocketHandshakeHeadersAsync>d__31")]
internal Task WriteWebSocketHandshakeHeadersAsync();
    private MemoryStream GetHeaders(bool closing, bool isWebSocketHandshake);
    private static Byte[] GetChunkSizeBytes(int size, bool final);
    internal void InternalWrite(Byte[] buffer, int offset, int count);
    internal Task InternalWriteAsync(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Net.HttpResponseStream/<InternalWriteIgnoreErrorsAsync>d__37")]
private Task InternalWriteIgnoreErrorsAsync(Byte[] buffer, int offset, int count);
    private void WriteCore(Byte[] buffer, int offset, int size);
    private IAsyncResult BeginWriteCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    private void EndWriteCore(IAsyncResult asyncResult);
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.HttpStreamAsyncResult : object {
    private object _locker;
    private ManualResetEvent _handle;
    private bool _completed;
    internal object _parent;
    internal Byte[] _buffer;
    internal int _offset;
    internal int _count;
    internal AsyncCallback _callback;
    internal object _state;
    internal int _synchRead;
    internal Exception _error;
    internal bool _endCalled;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal HttpStreamAsyncResult(object parent);
    public void Complete(Exception e);
    public void Complete();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void <Complete>b__14_0();
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; }
    internal bool EndCalled { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
}
internal class System.Net.ListenerAsyncResult : object {
    private ManualResetEvent _handle;
    private bool _synch;
    private bool _completed;
    private AsyncCallback _cb;
    private object _state;
    private Exception _exception;
    private HttpListenerContext _context;
    private object _locker;
    private ListenerAsyncResult _forward;
    internal HttpListener _parent;
    internal bool _endCalled;
    internal bool _inGet;
    private static WaitCallback s_invokeCB;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public ListenerAsyncResult(HttpListener parent, AsyncCallback cb, object state);
    private static ListenerAsyncResult();
    internal void Complete(Exception exc);
    private static void InvokeCallback(object o);
    internal void Complete(HttpListenerContext context);
    internal void Complete(HttpListenerContext context, bool synch);
    internal HttpListenerContext GetContext();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal enum System.Net.ListenerClientCertState : Enum {
    public int value__;
    public static ListenerClientCertState NotInitialized;
    public static ListenerClientCertState InProgress;
    public static ListenerClientCertState Completed;
}
internal class System.Net.ListenerPrefix : object {
    private string _original;
    private string _host;
    private ushort _port;
    private string _path;
    private bool _secure;
    internal HttpListener _listener;
    public bool Secure { get; }
    public string Host { get; }
    public int Port { get; }
    public string Path { get; }
    public ListenerPrefix(string prefix);
    public virtual string ToString();
    public bool get_Secure();
    public string get_Host();
    public int get_Port();
    public string get_Path();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private void Parse(string uri);
}
internal class System.Net.ListenerPrefixEnumerator : object {
    private IEnumerator _enumerator;
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListenerPrefixEnumerator(IEnumerator enumerator);
    public sealed virtual string get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
}
internal class System.Net.ServiceNameStore : object {
    private List`1<string> _serviceNames;
    private ServiceNameCollection _serviceNameCollection;
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    private static string NormalizeServiceName(string inputServiceName);
    private bool AddSingleServiceName(string spn);
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    private bool Contains(string newServiceName);
    public void Clear();
    private static string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings);
    public static string BuildSimpleServiceName(string uriPrefix);
    public static String[] BuildServiceNames(string uriPrefix);
}
internal static class System.Net.WebHeaderEncoding : object {
    internal static void GetBytes(string myString, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    internal static Byte[] GetBytes(string myString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private Uri _requestUri;
    private NameValueCollection _headers;
    private CookieCollection _cookieCollection;
    private IPrincipal _user;
    private bool _isAuthenticated;
    private bool _isLocal;
    private bool _isSecureConnection;
    private string _origin;
    private IEnumerable`1<string> _secWebSocketProtocols;
    private string _secWebSocketVersion;
    private string _secWebSocketKey;
    private WebSocket _webSocket;
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
    private static IPrincipal CopyPrincipal(IPrincipal user);
}
internal static class System.Net.WebSockets.HttpWebSocket : object {
    internal static string GetSecWebSocketAcceptString(string secWebSocketKey);
    internal static bool ProcessWebSocketProtocolHeader(string clientSecWebSocketProtocol, string subProtocol, String& acceptProtocol);
    internal static void ValidateOptions(string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval);
    private static void ValidateWebSocketHeaders(HttpListenerContext context);
    [AsyncStateMachineAttribute("System.Net.WebSockets.HttpWebSocket/<AcceptWebSocketAsyncCore>d__12")]
internal static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsyncCore(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, Nullable`1<ArraySegment`1<byte>> internalBuffer);
}
internal static class System.Net.WebSockets.WebSocketValidate : object {
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_listener_cannot_set_custom_cbt { get; }
    internal static string net_listener_scheme { get; }
    internal static string net_listener_host { get; }
    internal static string net_listener_not_supported { get; }
    internal static string net_listener_mustcall { get; }
    internal static string net_listener_slash { get; }
    internal static string net_listener_already { get; }
    internal static string net_log_listener_spn_add { get; }
    internal static string net_log_listener_spn_not_add { get; }
    internal static string net_log_listener_spn_remove { get; }
    internal static string net_log_listener_spn_not_remove { get; }
    internal static string net_array_too_small { get; }
    internal static string net_listener_mustcompletecall { get; }
    internal static string net_listener_invalid_cbt_type { get; }
    internal static string net_listener_callinprogress { get; }
    internal static string net_log_listener_cant_create_uri { get; }
    internal static string net_log_listener_cant_convert_raw_path { get; }
    internal static string net_log_listener_cant_convert_percent_value { get; }
    internal static string net_log_listener_cant_convert_to_utf8 { get; }
    internal static string net_log_listener_cant_convert_bytes { get; }
    internal static string net_invalidstatus { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_rspsubmitted { get; }
    internal static string net_nochunkuploadonhttp10 { get; }
    internal static string net_cookie_exists { get; }
    internal static string net_clsmall { get; }
    internal static string net_wrongversion { get; }
    internal static string net_noseek { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_WebSockets_ClientAcceptingNoProtocols { get; }
    internal static string net_WebSockets_AcceptUnsupportedProtocol { get; }
    internal static string net_WebSockets_AcceptNotAWebSocket { get; }
    internal static string net_WebSockets_AcceptHeaderNotFound { get; }
    internal static string net_WebSockets_AcceptUnsupportedWebSocketVersion { get; }
    internal static string net_WebSockets_InvalidEmptySubProtocol { get; }
    internal static string net_WebSockets_InvalidCharInProtocolString { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooSmall { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooBig { get; }
    internal static string net_readonlystream { get; }
    internal static string net_io_operation_aborted { get; }
    internal static string net_invalid_path { get; }
    internal static string net_listener_auth_errors { get; }
    internal static string net_listener_close { get; }
    internal static string net_invalid_port { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_listener_cannot_set_custom_cbt();
    internal static string get_net_listener_scheme();
    internal static string get_net_listener_host();
    internal static string get_net_listener_not_supported();
    internal static string get_net_listener_mustcall();
    internal static string get_net_listener_slash();
    internal static string get_net_listener_already();
    internal static string get_net_log_listener_spn_add();
    internal static string get_net_log_listener_spn_not_add();
    internal static string get_net_log_listener_spn_remove();
    internal static string get_net_log_listener_spn_not_remove();
    internal static string get_net_array_too_small();
    internal static string get_net_listener_mustcompletecall();
    internal static string get_net_listener_invalid_cbt_type();
    internal static string get_net_listener_callinprogress();
    internal static string get_net_log_listener_cant_create_uri();
    internal static string get_net_log_listener_cant_convert_raw_path();
    internal static string get_net_log_listener_cant_convert_percent_value();
    internal static string get_net_log_listener_cant_convert_to_utf8();
    internal static string get_net_log_listener_cant_convert_bytes();
    internal static string get_net_invalidstatus();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_rspsubmitted();
    internal static string get_net_nochunkuploadonhttp10();
    internal static string get_net_cookie_exists();
    internal static string get_net_clsmall();
    internal static string get_net_wrongversion();
    internal static string get_net_noseek();
    internal static string get_net_writeonlystream();
    internal static string get_net_WebSockets_ClientAcceptingNoProtocols();
    internal static string get_net_WebSockets_AcceptUnsupportedProtocol();
    internal static string get_net_WebSockets_AcceptNotAWebSocket();
    internal static string get_net_WebSockets_AcceptHeaderNotFound();
    internal static string get_net_WebSockets_AcceptUnsupportedWebSocketVersion();
    internal static string get_net_WebSockets_InvalidEmptySubProtocol();
    internal static string get_net_WebSockets_InvalidCharInProtocolString();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooSmall();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooBig();
    internal static string get_net_readonlystream();
    internal static string get_net_io_operation_aborted();
    internal static string get_net_invalid_path();
    internal static string get_net_listener_auth_errors();
    internal static string get_net_listener_close();
    internal static string get_net_invalid_port();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
