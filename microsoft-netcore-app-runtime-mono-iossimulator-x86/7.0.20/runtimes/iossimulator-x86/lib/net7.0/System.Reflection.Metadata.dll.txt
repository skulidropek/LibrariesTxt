internal static class FxResources.System.Reflection.Metadata.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Reflection.AssemblyFlags : Enum {
    public int value__;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags WindowsRuntime;
    public static AssemblyFlags ContentTypeMask;
    public static AssemblyFlags DisableJitCompileOptimizer;
    public static AssemblyFlags EnableJitCompileTracking;
}
public enum System.Reflection.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm Sha1;
    public static AssemblyHashAlgorithm Sha256;
    public static AssemblyHashAlgorithm Sha384;
    public static AssemblyHashAlgorithm Sha512;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Reflection.BlobUtilities : object {
    public static int SizeOfSerializedDecimal;
    public static int SizeOfGuid;
    [NullableContextAttribute("0")]
public static Byte[] ReadBytes(Byte* buffer, int byteCount);
    [NullableContextAttribute("0")]
public static ImmutableArray`1<byte> ReadImmutableBytes(Byte* buffer, int byteCount);
    [ExtensionAttribute]
public static void WriteBytes(Byte[] buffer, int start, byte value, int byteCount);
    [ExtensionAttribute]
public static void WriteDouble(Byte[] buffer, int start, double value);
    [ExtensionAttribute]
public static void WriteSingle(Byte[] buffer, int start, float value);
    [ExtensionAttribute]
public static void WriteByte(Byte[] buffer, int start, byte value);
    [ExtensionAttribute]
public static void WriteUInt16(Byte[] buffer, int start, ushort value);
    [ExtensionAttribute]
public static void WriteUInt16BE(Byte[] buffer, int start, ushort value);
    [ExtensionAttribute]
public static void WriteUInt32BE(Byte[] buffer, int start, UInt32 value);
    [ExtensionAttribute]
public static void WriteUInt32(Byte[] buffer, int start, UInt32 value);
    [ExtensionAttribute]
public static void WriteUInt64(Byte[] buffer, int start, ulong value);
    [ExtensionAttribute]
public static void WriteDecimal(Byte[] buffer, int start, decimal value);
    [ExtensionAttribute]
public static void WriteGuid(Byte[] buffer, int start, Guid value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteUTF8(Byte[] buffer, int start, Char* charPtr, int charCount, int byteCount, bool allowUnpairedSurrogates);
    internal static int GetUTF8ByteCount(string str);
    [NullableContextAttribute("0")]
internal static int GetUTF8ByteCount(Char* str, int charCount);
    [NullableContextAttribute("0")]
internal static int GetUTF8ByteCount(Char* str, int charCount, int byteLimit, Char*& remainder);
    internal static bool IsSurrogateChar(int c);
    internal static bool IsHighSurrogateChar(int c);
    internal static bool IsLowSurrogateChar(int c);
    internal static void ValidateRange(int bufferLength, int start, int byteCount, string byteCountParameterName);
    internal static int GetUserStringByteLength(int characterCount);
    internal static byte GetUserStringTrailingByte(string str);
}
public enum System.Reflection.DeclarativeSecurityAction : Enum {
    public short value__;
    public static DeclarativeSecurityAction None;
    public static DeclarativeSecurityAction Demand;
    public static DeclarativeSecurityAction Assert;
    public static DeclarativeSecurityAction Deny;
    public static DeclarativeSecurityAction PermitOnly;
    public static DeclarativeSecurityAction LinkDemand;
    public static DeclarativeSecurityAction InheritanceDemand;
    public static DeclarativeSecurityAction RequestMinimum;
    public static DeclarativeSecurityAction RequestOptional;
    public static DeclarativeSecurityAction RequestRefuse;
}
internal abstract class System.Reflection.Internal.AbstractMemoryBlock : object {
    public Byte* Pointer { get; }
    public int Size { get; }
    public abstract virtual Byte* get_Pointer();
    public abstract virtual int get_Size();
    public BlobReader GetReader();
    public virtual ImmutableArray`1<byte> GetContentUnchecked(int start, int length);
    public abstract virtual void Dispose();
}
internal static class System.Reflection.Internal.BitArithmetic : object {
    internal static int CountBits(int v);
    internal static int CountBits(UInt32 v);
    internal static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
internal class System.Reflection.Internal.ByteArrayMemoryBlock : AbstractMemoryBlock {
    private ByteArrayMemoryProvider _provider;
    private int _start;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    [NullableContextAttribute("1")]
internal ByteArrayMemoryBlock(ByteArrayMemoryProvider provider, int start, int size);
    public virtual void Dispose();
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
    public virtual ImmutableArray`1<byte> GetContentUnchecked(int start, int length);
}
internal class System.Reflection.Internal.ByteArrayMemoryProvider : MemoryBlockProvider {
    private ImmutableArray`1<byte> _array;
    private PinnedObject _pinned;
    public int Size { get; }
    public ImmutableArray`1<byte> Array { get; }
    internal Byte* Pointer { get; }
    public ByteArrayMemoryProvider(ImmutableArray`1<byte> array);
    protected virtual void Dispose(bool disposing);
    public virtual int get_Size();
    public ImmutableArray`1<byte> get_Array();
    [NullableContextAttribute("1")]
protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    [NullableContextAttribute("1")]
public virtual Stream GetStream(StreamConstraints& constraints);
    internal Byte* get_Pointer();
}
internal class System.Reflection.Internal.ByteSequenceComparer : object {
    [NullableAttribute("1")]
internal static ByteSequenceComparer Instance;
    private static ByteSequenceComparer();
    internal static bool Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    [NullableContextAttribute("1")]
internal static bool Equals(Byte[] left, int leftStart, Byte[] right, int rightStart, int length);
    [NullableContextAttribute("2")]
internal static bool Equals(Byte[] left, Byte[] right);
    [NullableContextAttribute("1")]
internal static int GetHashCode(Byte[] x);
    internal static int GetHashCode(ImmutableArray`1<byte> x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Byte[]>.Equals(Byte[] x, Byte[] y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Byte[]>.GetHashCode(Byte[] x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.GetHashCode(ImmutableArray`1<byte> x);
}
internal abstract class System.Reflection.Internal.CriticalDisposableObject : CriticalFinalizerObject {
    protected abstract virtual void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
[ExtensionAttribute]
internal static class System.Reflection.Internal.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
internal static class System.Reflection.Internal.EncodingHelper : object {
    [NullableContextAttribute("1")]
public static string DecodeUtf8(Byte* bytes, int byteCount, Byte[] prefix, MetadataStringDecoder utf8Decoder);
    private static string DecodeUtf8Prefixed(Byte* bytes, int byteCount, Byte[] prefix, MetadataStringDecoder utf8Decoder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Reflection.Internal.EnumerableExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> collection, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("System.Reflection.Internal.EnumerableExtensions/<Select>d__1`2")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static T Last(Builder<T> source);
    [IteratorStateMachineAttribute("System.Reflection.Internal.EnumerableExtensions/<OrderBy>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(List`1<T> source, Comparison`1<T> comparison);
}
internal static class System.Reflection.Internal.ExceptionUtilities : object {
    [NullableContextAttribute("1")]
internal static Exception UnexpectedValue(object value);
}
internal class System.Reflection.Internal.ExternalMemoryBlock : AbstractMemoryBlock {
    private object _memoryOwner;
    private Byte* _buffer;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    public ExternalMemoryBlock(object memoryOwner, Byte* buffer, int size);
    public virtual void Dispose();
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
}
internal class System.Reflection.Internal.ExternalMemoryBlockProvider : MemoryBlockProvider {
    private Byte* _memory;
    private int _size;
    public int Size { get; }
    public Byte* Pointer { get; }
    public ExternalMemoryBlockProvider(Byte* memory, int size);
    public virtual int get_Size();
    [NullableContextAttribute("1")]
protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    [NullableContextAttribute("1")]
public virtual Stream GetStream(StreamConstraints& constraints);
    protected virtual void Dispose(bool disposing);
    public Byte* get_Pointer();
}
internal static class System.Reflection.Internal.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(UInt32 newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data);
}
internal static class System.Reflection.Internal.ImmutableByteArrayInterop : object {
    internal static ImmutableArray`1<byte> DangerousCreateFromUnderlyingArray(Byte[]& array);
    internal static Byte[] DangerousGetUnderlyingArray(ImmutableArray`1<byte> array);
}
internal class System.Reflection.Internal.ImmutableMemoryStream : Stream {
    private ImmutableArray`1<byte> _array;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ImmutableMemoryStream(ImmutableArray`1<byte> array);
    public ImmutableArray`1<byte> GetBuffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class System.Reflection.Internal.MemoryBlock : ValueType {
    [NullableAttribute("0")]
internal Byte* Pointer;
    internal int Length;
    [NullableContextAttribute("0")]
internal MemoryBlock(Byte* buffer, int length);
    [NullableContextAttribute("0")]
internal static MemoryBlock CreateChecked(Byte* buffer, int length);
    private void CheckBounds(int offset, int byteCount);
    [NullableContextAttribute("2")]
internal Byte[] ToArray();
    private string GetDebuggerDisplay();
    internal string GetDebuggerDisplay(Int32& displayedBytes);
    internal string GetDebuggerDisplay(int offset);
    internal MemoryBlock GetMemoryBlockAt(int offset, int length);
    internal byte PeekByte(int offset);
    internal int PeekInt32(int offset);
    internal UInt32 PeekUInt32(int offset);
    internal int PeekCompressedInteger(int offset, Int32& numberOfBytesRead);
    internal ushort PeekUInt16(int offset);
    internal UInt32 PeekTaggedReference(int offset, bool smallRefSize);
    internal UInt32 PeekReferenceUnchecked(int offset, bool smallRefSize);
    internal int PeekReference(int offset, bool smallRefSize);
    internal int PeekHeapReference(int offset, bool smallRefSize);
    internal Guid PeekGuid(int offset);
    internal string PeekUtf16(int offset, int byteCount);
    internal string PeekUtf8(int offset, int byteCount);
    internal string PeekUtf8NullTerminated(int offset, Byte[] prefix, MetadataStringDecoder utf8Decoder, Int32& numberOfBytesRead, char terminator);
    internal int GetUtf8NullTerminatedLength(int offset, Int32& numberOfBytesRead, char terminator);
    internal int Utf8NullTerminatedOffsetOfAsciiChar(int startOffset, char asciiChar);
    internal bool Utf8NullTerminatedEquals(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator, bool ignoreCase);
    internal bool Utf8NullTerminatedStartsWith(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator, bool ignoreCase);
    internal FastComparisonResult Utf8NullTerminatedFastCompare(int offset, string text, int textStart, Int32& firstDifferenceIndex, char terminator, bool ignoreCase);
    internal bool Utf8NullTerminatedStringStartsWithAsciiPrefix(int offset, string asciiPrefix);
    internal int CompareUtf8NullTerminatedStringWithAsciiString(int offset, string asciiString);
    internal Byte[] PeekBytes(int offset, int byteCount);
    internal int IndexOf(byte b, int start);
    internal int IndexOfUnchecked(byte b, int start);
    internal int BinarySearch(String[] asciiKeys, int offset);
    internal int BinarySearchForSlot(int rowCount, int rowSize, int referenceListOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int BinarySearchReference(int rowCount, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int BinarySearchReference(Int32[] ptrTable, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal void BinarySearchReferenceRange(int rowCount, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall, Int32& startRowNumber, Int32& endRowNumber);
    internal void BinarySearchReferenceRange(Int32[] ptrTable, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall, Int32& startRowNumber, Int32& endRowNumber);
    internal int LinearSearchReference(int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal bool IsOrderedByReferenceAscending(int rowSize, int referenceOffset, bool isReferenceSmall);
    internal Int32[] BuildPtrTable(int numberOfRows, int rowSize, int referenceOffset, bool isReferenceSmall);
    private void ReadColumn(UInt32[] result, int rowSize, int referenceOffset, bool isReferenceSmall);
    internal bool PeekHeapValueOffsetAndSize(int index, Int32& offset, Int32& size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Reflection.Internal.MemoryBlockProvider : object {
    public int Size { get; }
    public AbstractMemoryBlock GetMemoryBlock();
    public AbstractMemoryBlock GetMemoryBlock(int start, int size);
    protected abstract virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public abstract virtual Stream GetStream(StreamConstraints& constraints);
    public abstract virtual int get_Size();
    protected abstract virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class System.Reflection.Internal.MemoryMappedFileBlock : AbstractMemoryBlock {
    private DisposableData _data;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    [NullableContextAttribute("1")]
internal MemoryMappedFileBlock(IDisposable accessor, SafeBuffer safeBuffer, long offset, int size);
    public virtual void Dispose();
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
}
internal class System.Reflection.Internal.NativeHeapMemoryBlock : AbstractMemoryBlock {
    private DisposableData _data;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    internal NativeHeapMemoryBlock(int size);
    public virtual void Dispose();
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Internal.ObjectPool`1 : object {
    private Element[] _items;
    private Func`1<T> _factory;
    internal ObjectPool`1(Func`1<T> factory);
    internal ObjectPool`1(Func`1<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    internal void Free(T obj);
}
internal class System.Reflection.Internal.PinnedObject : CriticalDisposableObject {
    private GCHandle _handle;
    private int _isValid;
    public Byte* Pointer { get; }
    [NullableContextAttribute("1")]
public PinnedObject(object obj);
    protected virtual void Release();
    public Byte* get_Pointer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Internal.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    public string ToStringAndFree();
    public static ObjectPool`1<PooledStringBuilder> CreatePool();
    public static PooledStringBuilder GetInstance();
}
internal class System.Reflection.Internal.ReadOnlyUnmanagedMemoryStream : Stream {
    private Byte* _data;
    private int _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyUnmanagedMemoryStream(Byte* data, int length);
    public virtual int ReadByte();
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Reflection.Internal.StreamConstraints : ValueType {
    public object GuardOpt;
    public long ImageStart;
    public int ImageSize;
    public StreamConstraints(object guardOpt, long startPosition, int imageSize);
}
[ExtensionAttribute]
internal static class System.Reflection.Internal.StreamExtensions : object {
    internal static int StreamCopyBufferSize;
    [ExtensionAttribute]
internal static int Read(Stream stream, Byte* buffer, int size);
    [ExtensionAttribute]
internal static void CopyTo(Stream source, Byte* destination, int size);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
internal static int TryReadAll(Stream stream, Span`1<byte> buffer);
    [NullableContextAttribute("1")]
internal static int GetAndValidateSize(Stream stream, int size, string streamParameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Internal.StreamMemoryBlockProvider : MemoryBlockProvider {
    internal static int MemoryMapThreshold;
    private Stream _stream;
    private object _streamGuard;
    private bool _leaveOpen;
    private bool _useMemoryMap;
    private long _imageStart;
    private int _imageSize;
    private MemoryMappedFile _lazyMemoryMap;
    public int Size { get; }
    public StreamMemoryBlockProvider(Stream stream, long imageStart, int imageSize, bool leaveOpen);
    protected virtual void Dispose(bool disposing);
    public virtual int get_Size();
    internal static NativeHeapMemoryBlock ReadMemoryBlockNoLock(Stream stream, long start, int size);
    protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public virtual Stream GetStream(StreamConstraints& constraints);
    private bool TryCreateMemoryMappedFileBlock(long start, int size, MemoryMappedFileBlock& block);
}
[FlagsAttribute]
public enum System.Reflection.ManifestResourceAttributes : Enum {
    public int value__;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
    public static ManifestResourceAttributes VisibilityMask;
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ArrayShape : ValueType {
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <Sizes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <LowerBounds>k__BackingField;
    public int Rank { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public ArrayShape(int rank, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_Sizes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_LowerBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyDefinition : ValueType {
    private MetadataReader _reader;
    public AssemblyHashAlgorithm HashAlgorithm { get; }
    public Version Version { get; }
    public AssemblyFlags Flags { get; }
    public StringHandle Name { get; }
    public StringHandle Culture { get; }
    public BlobHandle PublicKey { get; }
    internal AssemblyDefinition(MetadataReader reader);
    public AssemblyName GetAssemblyName();
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public Version get_Version();
    public AssemblyFlags get_Flags();
    public StringHandle get_Name();
    public StringHandle get_Culture();
    public BlobHandle get_PublicKey();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal AssemblyDefinitionHandle(int rowId);
    internal static AssemblyDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(AssemblyDefinitionHandle handle);
    public static EntityHandle op_Implicit(AssemblyDefinitionHandle handle);
    public static AssemblyDefinitionHandle op_Explicit(Handle handle);
    public static AssemblyDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyFile : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private AssemblyFileHandle Handle { get; }
    public bool ContainsMetadata { get; }
    public StringHandle Name { get; }
    public BlobHandle HashValue { get; }
    [NullableContextAttribute("1")]
internal AssemblyFile(MetadataReader reader, AssemblyFileHandle handle);
    private AssemblyFileHandle get_Handle();
    public bool get_ContainsMetadata();
    public StringHandle get_Name();
    public BlobHandle get_HashValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyFileHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private AssemblyFileHandle(int rowId);
    internal static AssemblyFileHandle FromRowId(int rowId);
    public static Handle op_Implicit(AssemblyFileHandle handle);
    public static EntityHandle op_Implicit(AssemblyFileHandle handle);
    public static AssemblyFileHandle op_Explicit(Handle handle);
    public static AssemblyFileHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(AssemblyFileHandle left, AssemblyFileHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyFileHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyFileHandle left, AssemblyFileHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyFileHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal AssemblyFileHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<AssemblyFileHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyFileHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private static Version s_version_4_0_0_0;
    private int RowId { get; }
    private bool IsVirtual { get; }
    public Version Version { get; }
    public AssemblyFlags Flags { get; }
    public StringHandle Name { get; }
    public StringHandle Culture { get; }
    public BlobHandle PublicKeyOrToken { get; }
    public BlobHandle HashValue { get; }
    internal AssemblyReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private static AssemblyReference();
    public AssemblyName GetAssemblyName();
    private int get_RowId();
    private bool get_IsVirtual();
    public Version get_Version();
    public AssemblyFlags get_Flags();
    public StringHandle get_Name();
    public StringHandle get_Culture();
    public BlobHandle get_PublicKeyOrToken();
    public BlobHandle get_HashValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private static Version GetVirtualVersion();
    private AssemblyFlags GetVirtualFlags();
    private StringHandle GetVirtualName();
    private static VirtualIndex GetVirtualNameIndex(VirtualIndex index);
    private static StringHandle GetVirtualCulture();
    private BlobHandle GetVirtualPublicKeyOrToken();
    private static BlobHandle GetVirtualHashValue();
    private CustomAttributeHandleCollection GetVirtualCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyReferenceHandle : ValueType {
    private UInt32 _value;
    internal UInt32 Value { get; }
    private UInt32 VToken { get; }
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    internal int RowId { get; }
    private AssemblyReferenceHandle(UInt32 value);
    internal static AssemblyReferenceHandle FromRowId(int rowId);
    internal static AssemblyReferenceHandle FromVirtualIndex(VirtualIndex virtualIndex);
    public static Handle op_Implicit(AssemblyReferenceHandle handle);
    public static EntityHandle op_Implicit(AssemblyReferenceHandle handle);
    public static AssemblyReferenceHandle op_Explicit(Handle handle);
    public static AssemblyReferenceHandle op_Explicit(EntityHandle handle);
    internal UInt32 get_Value();
    private UInt32 get_VToken();
    public bool get_IsNil();
    internal bool get_IsVirtual();
    internal int get_RowId();
    public static bool op_Equality(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.AssemblyReferenceHandleCollection : ValueType {
    private MetadataReader _reader;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal AssemblyReferenceHandleCollection(MetadataReader reader);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<AssemblyReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Blob : ValueType {
    [NullableAttribute("1")]
internal Byte[] Buffer;
    internal int Start;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public bool IsDefault { get; }
    [NullableContextAttribute("1")]
internal Blob(Byte[] buffer, int start, int length);
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsDefault();
    public ArraySegment`1<byte> GetBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class System.Reflection.Metadata.BlobBuilder : object {
    internal static int DefaultChunkSize;
    internal static int MinChunkSize;
    private BlobBuilder _nextOrPrevious;
    private int _previousLengthOrFrozenSuffixLengthDelta;
    private Byte[] _buffer;
    private UInt32 _length;
    private BlobBuilder FirstChunk { get; }
    private bool IsHead { get; }
    private int Length { get; }
    private UInt32 FrozenLength { get; }
    public int Count { get; }
    private int PreviousLength { get; private set; }
    protected int FreeBytes { get; }
    protected internal int ChunkCapacity { get; }
    public BlobBuilder(int capacity);
    private BlobBuilder get_FirstChunk();
    private bool get_IsHead();
    private int get_Length();
    private UInt32 get_FrozenLength();
    protected virtual BlobBuilder AllocateChunk(int minimalSize);
    protected virtual void FreeChunk();
    public void Clear();
    protected void Free();
    internal void ClearChunk();
    public int get_Count();
    private int get_PreviousLength();
    private void set_PreviousLength(int value);
    protected int get_FreeBytes();
    protected internal int get_ChunkCapacity();
    internal Chunks GetChunks();
    public Blobs GetBlobs();
    public bool ContentEquals(BlobBuilder other);
    public Byte[] ToArray();
    public Byte[] ToArray(int start, int byteCount);
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> ToImmutableArray();
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> ToImmutableArray(int start, int byteCount);
    public void WriteContentTo(Stream destination);
    public void WriteContentTo(BlobWriter& destination);
    public void WriteContentTo(BlobBuilder destination);
    public void LinkPrefix(BlobBuilder prefix);
    public void LinkSuffix(BlobBuilder suffix);
    private void AddLength(int value);
    private void Expand(int newLength);
    public Blob ReserveBytes(int byteCount);
    private int ReserveBytesImpl(int byteCount);
    private int ReserveBytesPrimitive(int byteCount);
    public void WriteBytes(byte value, int byteCount);
    [NullableContextAttribute("0")]
public void WriteBytes(Byte* buffer, int byteCount);
    private void WriteBytesUnchecked(Byte* buffer, int byteCount);
    public int TryWriteBytes(Stream source, int byteCount);
    [NullableContextAttribute("0")]
public void WriteBytes(ImmutableArray`1<byte> buffer);
    [NullableContextAttribute("0")]
public void WriteBytes(ImmutableArray`1<byte> buffer, int start, int byteCount);
    public void WriteBytes(Byte[] buffer);
    public void WriteBytes(Byte[] buffer, int start, int byteCount);
    public void PadTo(int position);
    public void Align(int alignment);
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt16(short value);
    public void WriteUInt16(ushort value);
    public void WriteInt16BE(short value);
    public void WriteUInt16BE(ushort value);
    public void WriteInt32BE(int value);
    public void WriteUInt32BE(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt64(long value);
    public void WriteUInt64(ulong value);
    public void WriteDecimal(decimal value);
    public void WriteGuid(Guid value);
    public void WriteDateTime(DateTime value);
    public void WriteReference(int reference, bool isSmall);
    public void WriteUTF16(Char[] value);
    public void WriteUTF16(string value);
    [NullableContextAttribute("2")]
public void WriteSerializedString(string value);
    public void WriteUserString(string value);
    public void WriteUTF8(string value, bool allowUnpairedSurrogates);
    internal void WriteUTF8(string str, int start, int length, bool allowUnpairedSurrogates, bool prependSize);
    public void WriteCompressedSignedInteger(int value);
    public void WriteCompressedInteger(int value);
    [NullableContextAttribute("2")]
public void WriteConstant(object value);
    internal string GetDebuggerDisplay();
    private static string Display(Byte[] bytes, int length);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.BlobContentId : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Stamp>k__BackingField;
    public Guid Guid { get; }
    public UInt32 Stamp { get; }
    public bool IsDefault { get; }
    public BlobContentId(Guid guid, UInt32 stamp);
    public BlobContentId(ImmutableArray`1<byte> id);
    [NullableContextAttribute("1")]
public BlobContentId(Byte[] id);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
public UInt32 get_Stamp();
    public bool get_IsDefault();
    public static BlobContentId FromHash(ImmutableArray`1<byte> hashCode);
    [NullableContextAttribute("1")]
public static BlobContentId FromHash(Byte[] hashCode);
    [NullableContextAttribute("1")]
public static Func`2<IEnumerable`1<Blob>, BlobContentId> GetTimeBasedProvider();
    public sealed virtual bool Equals(BlobContentId other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BlobContentId left, BlobContentId right);
    public static bool op_Inequality(BlobContentId left, BlobContentId right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.BlobHandle : ValueType {
    private UInt32 _value;
    internal static int TemplateParameterOffset_AttributeUsageTarget;
    internal UInt32 RawValue { get; }
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    private ushort VirtualValue { get; }
    private BlobHandle(UInt32 value);
    internal static BlobHandle FromOffset(int heapOffset);
    internal static BlobHandle FromVirtualIndex(VirtualIndex virtualIndex, ushort virtualValue);
    [NullableContextAttribute("1")]
internal void SubstituteTemplateParameters(Byte[] blob);
    public static Handle op_Implicit(BlobHandle handle);
    public static BlobHandle op_Explicit(Handle handle);
    internal UInt32 get_RawValue();
    public bool get_IsNil();
    internal int GetHeapOffset();
    internal VirtualIndex GetVirtualIndex();
    internal bool get_IsVirtual();
    private ushort get_VirtualValue();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BlobHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(BlobHandle left, BlobHandle right);
    public static bool op_Inequality(BlobHandle left, BlobHandle right);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class System.Reflection.Metadata.BlobReader : ValueType {
    internal static int InvalidCompressedInteger;
    private MemoryBlock _block;
    private Byte* _endPointer;
    private Byte* _currentPointer;
    private static UInt32[] s_corEncodeTokenArray;
    public Byte* StartPointer { get; }
    public Byte* CurrentPointer { get; }
    public int Length { get; }
    public int Offset { get; public set; }
    public int RemainingBytes { get; }
    public BlobReader(Byte* buffer, int length);
    internal BlobReader(MemoryBlock block);
    private static BlobReader();
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
    public Byte* get_StartPointer();
    public Byte* get_CurrentPointer();
    public int get_Length();
    public int get_Offset();
    public void set_Offset(int value);
    public int get_RemainingBytes();
    public void Reset();
    public void Align(byte alignment);
    internal bool TryAlign(byte alignment);
    internal MemoryBlock GetMemoryBlockAt(int offset, int length);
    private void CheckBounds(int offset, int byteCount);
    private Byte* GetCurrentPointerAndAdvance(int length);
    private Byte* GetCurrentPointerAndAdvance1();
    public bool ReadBoolean();
    public sbyte ReadSByte();
    public byte ReadByte();
    public char ReadChar();
    public short ReadInt16();
    public ushort ReadUInt16();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public long ReadInt64();
    public ulong ReadUInt64();
    public float ReadSingle();
    public double ReadDouble();
    public Guid ReadGuid();
    public decimal ReadDecimal();
    public DateTime ReadDateTime();
    public SignatureHeader ReadSignatureHeader();
    public int IndexOf(byte value);
    [NullableContextAttribute("1")]
public string ReadUTF8(int byteCount);
    [NullableContextAttribute("1")]
public string ReadUTF16(int byteCount);
    [NullableContextAttribute("1")]
public Byte[] ReadBytes(int byteCount);
    [NullableContextAttribute("1")]
public void ReadBytes(int byteCount, Byte[] buffer, int bufferOffset);
    [NullableContextAttribute("1")]
internal string ReadUtf8NullTerminated();
    private int ReadCompressedIntegerOrInvalid();
    public bool TryReadCompressedInteger(Int32& value);
    public int ReadCompressedInteger();
    public bool TryReadCompressedSignedInteger(Int32& value);
    public int ReadCompressedSignedInteger();
    public SerializationTypeCode ReadSerializationTypeCode();
    public SignatureTypeCode ReadSignatureTypeCode();
    [NullableContextAttribute("2")]
public string ReadSerializedString();
    public EntityHandle ReadTypeHandle();
    public BlobHandle ReadBlobHandle();
    [NullableContextAttribute("2")]
public object ReadConstant(ConstantTypeCode typeCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.BlobWriter : ValueType {
    private Byte[] _buffer;
    private int _start;
    private int _end;
    private int _position;
    internal bool IsDefault { get; }
    public int Offset { get; public set; }
    public int Length { get; }
    public int RemainingBytes { get; }
    public Blob Blob { get; }
    public BlobWriter(int size);
    public BlobWriter(Byte[] buffer);
    public BlobWriter(Blob blob);
    public BlobWriter(Byte[] buffer, int start, int count);
    internal bool get_IsDefault();
    public bool ContentEquals(BlobWriter other);
    public int get_Offset();
    public void set_Offset(int value);
    public int get_Length();
    public int get_RemainingBytes();
    public Blob get_Blob();
    public Byte[] ToArray();
    public Byte[] ToArray(int start, int byteCount);
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> ToImmutableArray();
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> ToImmutableArray(int start, int byteCount);
    private int Advance(int value);
    public void WriteBytes(byte value, int byteCount);
    [NullableContextAttribute("0")]
public void WriteBytes(Byte* buffer, int byteCount);
    private void WriteBytesUnchecked(Byte* buffer, int byteCount);
    public void WriteBytes(BlobBuilder source);
    public int WriteBytes(Stream source, int byteCount);
    [NullableContextAttribute("0")]
public void WriteBytes(ImmutableArray`1<byte> buffer);
    [NullableContextAttribute("0")]
public void WriteBytes(ImmutableArray`1<byte> buffer, int start, int byteCount);
    public void WriteBytes(Byte[] buffer);
    public void WriteBytes(Byte[] buffer, int start, int byteCount);
    public void PadTo(int offset);
    public void Align(int alignment);
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt16(short value);
    public void WriteUInt16(ushort value);
    public void WriteInt16BE(short value);
    public void WriteUInt16BE(ushort value);
    public void WriteInt32BE(int value);
    public void WriteUInt32BE(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt64(long value);
    public void WriteUInt64(ulong value);
    public void WriteDecimal(decimal value);
    public void WriteGuid(Guid value);
    public void WriteDateTime(DateTime value);
    public void WriteReference(int reference, bool isSmall);
    public void WriteUTF16(Char[] value);
    public void WriteUTF16(string value);
    [NullableContextAttribute("2")]
public void WriteSerializedString(string str);
    public void WriteUserString(string value);
    public void WriteUTF8(string value, bool allowUnpairedSurrogates);
    private void WriteUTF8(string str, int start, int length, bool allowUnpairedSurrogates, bool prependSize);
    public void WriteCompressedSignedInteger(int value);
    public void WriteCompressedInteger(int value);
    [NullableContextAttribute("2")]
public void WriteConstant(object value);
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Reflection.Metadata.BlobWriterImpl : object {
    internal static int SingleByteCompressedIntegerMaxValue;
    internal static int TwoByteCompressedIntegerMaxValue;
    internal static int MaxCompressedIntegerValue;
    internal static int MinSignedCompressedIntegerValue;
    internal static int MaxSignedCompressedIntegerValue;
    internal static int GetCompressedIntegerSize(int value);
    internal static void WriteCompressedInteger(BlobWriter& writer, UInt32 value);
    internal static void WriteCompressedInteger(BlobBuilder writer, UInt32 value);
    internal static void WriteCompressedSignedInteger(BlobWriter& writer, int value);
    internal static void WriteCompressedSignedInteger(BlobBuilder writer, int value);
    [NullableContextAttribute("2")]
internal static void WriteConstant(BlobWriter& writer, object value);
    internal static void WriteConstant(BlobBuilder writer, object value);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Constant : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ConstantHandle Handle { get; }
    public ConstantTypeCode TypeCode { get; }
    public BlobHandle Value { get; }
    public EntityHandle Parent { get; }
    [NullableContextAttribute("1")]
internal Constant(MetadataReader reader, int rowId);
    private ConstantHandle get_Handle();
    public ConstantTypeCode get_TypeCode();
    public BlobHandle get_Value();
    public EntityHandle get_Parent();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ConstantHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ConstantHandle(int rowId);
    internal static ConstantHandle FromRowId(int rowId);
    public static Handle op_Implicit(ConstantHandle handle);
    public static EntityHandle op_Implicit(ConstantHandle handle);
    public static ConstantHandle op_Explicit(Handle handle);
    public static ConstantHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ConstantHandle left, ConstantHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConstantHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ConstantHandle left, ConstantHandle right);
}
public enum System.Reflection.Metadata.ConstantTypeCode : Enum {
    public byte value__;
    public static ConstantTypeCode Invalid;
    public static ConstantTypeCode Boolean;
    public static ConstantTypeCode Char;
    public static ConstantTypeCode SByte;
    public static ConstantTypeCode Byte;
    public static ConstantTypeCode Int16;
    public static ConstantTypeCode UInt16;
    public static ConstantTypeCode Int32;
    public static ConstantTypeCode UInt32;
    public static ConstantTypeCode Int64;
    public static ConstantTypeCode UInt64;
    public static ConstantTypeCode Single;
    public static ConstantTypeCode Double;
    public static ConstantTypeCode String;
    public static ConstantTypeCode NullReference;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttribute : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private CustomAttributeHandle Handle { get; }
    private MethodDefTreatment Treatment { get; }
    public EntityHandle Constructor { get; }
    public EntityHandle Parent { get; }
    public BlobHandle Value { get; }
    internal CustomAttribute(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private CustomAttributeHandle get_Handle();
    private MethodDefTreatment get_Treatment();
    public EntityHandle get_Constructor();
    public EntityHandle get_Parent();
    public BlobHandle get_Value();
    public CustomAttributeValue`1<TType> DecodeValue(ICustomAttributeTypeProvider`1<TType> provider);
    private BlobHandle GetProjectedValue();
    private BlobHandle GetProjectedValue(CustomAttributeValueTreatment treatment);
    private static AttributeTargets ProjectAttributeTargetValue(UInt32 rawValue);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttributeHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private CustomAttributeHandle(int rowId);
    internal static CustomAttributeHandle FromRowId(int rowId);
    public static Handle op_Implicit(CustomAttributeHandle handle);
    public static EntityHandle op_Implicit(CustomAttributeHandle handle);
    public static CustomAttributeHandle op_Explicit(Handle handle);
    public static CustomAttributeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(CustomAttributeHandle left, CustomAttributeHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(CustomAttributeHandle left, CustomAttributeHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttributeHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal CustomAttributeHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal CustomAttributeHandleCollection(MetadataReader reader, EntityHandle handle);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<CustomAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.CustomAttributeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttributeNamedArgument`1 : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomAttributeNamedArgumentKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private TType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public CustomAttributeNamedArgumentKind Kind { get; }
    [NullableAttribute("1")]
public TType Type { get; }
    public object Value { get; }
    public CustomAttributeNamedArgument`1(string name, CustomAttributeNamedArgumentKind kind, TType type, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public CustomAttributeNamedArgumentKind get_Kind();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum System.Reflection.Metadata.CustomAttributeNamedArgumentKind : Enum {
    public byte value__;
    public static CustomAttributeNamedArgumentKind Field;
    public static CustomAttributeNamedArgumentKind Property;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttributeTypedArgument`1 : ValueType {
    [CompilerGeneratedAttribute]
private TType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public TType Type { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public CustomAttributeTypedArgument`1(TType type, object value);
    [CompilerGeneratedAttribute]
public TType get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomAttributeValue`1 : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CustomAttributeTypedArgument`1<TType>> <FixedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> <NamedArguments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomAttributeTypedArgument`1<TType>> FixedArguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> NamedArguments { get; }
    public CustomAttributeValue`1(ImmutableArray`1<CustomAttributeTypedArgument`1<TType>> fixedArguments, ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> namedArguments);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CustomAttributeTypedArgument`1<TType>> get_FixedArguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> get_NamedArguments();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomDebugInformation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private CustomDebugInformationHandle Handle { get; }
    public EntityHandle Parent { get; }
    public GuidHandle Kind { get; }
    public BlobHandle Value { get; }
    [NullableContextAttribute("1")]
internal CustomDebugInformation(MetadataReader reader, CustomDebugInformationHandle handle);
    private CustomDebugInformationHandle get_Handle();
    public EntityHandle get_Parent();
    public GuidHandle get_Kind();
    public BlobHandle get_Value();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomDebugInformationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private CustomDebugInformationHandle(int rowId);
    internal static CustomDebugInformationHandle FromRowId(int rowId);
    public static Handle op_Implicit(CustomDebugInformationHandle handle);
    public static EntityHandle op_Implicit(CustomDebugInformationHandle handle);
    public static CustomDebugInformationHandle op_Explicit(Handle handle);
    public static CustomDebugInformationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(CustomDebugInformationHandle left, CustomDebugInformationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomDebugInformationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(CustomDebugInformationHandle left, CustomDebugInformationHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.CustomDebugInformationHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal CustomDebugInformationHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal CustomDebugInformationHandleCollection(MetadataReader reader, EntityHandle handle);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<CustomDebugInformationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.CustomDebugInformationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.DebugMetadataHeader : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDefinitionHandle <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdStartOffset>k__BackingField;
    public ImmutableArray`1<byte> Id { get; }
    public MethodDefinitionHandle EntryPoint { get; }
    public int IdStartOffset { get; }
    internal DebugMetadataHeader(ImmutableArray`1<byte> id, MethodDefinitionHandle entryPoint, int idStartOffset);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_Id();
    [CompilerGeneratedAttribute]
public MethodDefinitionHandle get_EntryPoint();
    [CompilerGeneratedAttribute]
public int get_IdStartOffset();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DeclarativeSecurityAttribute : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    public DeclarativeSecurityAction Action { get; }
    public EntityHandle Parent { get; }
    public BlobHandle PermissionSet { get; }
    [NullableContextAttribute("1")]
internal DeclarativeSecurityAttribute(MetadataReader reader, int rowId);
    public DeclarativeSecurityAction get_Action();
    public EntityHandle get_Parent();
    public BlobHandle get_PermissionSet();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DeclarativeSecurityAttributeHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private DeclarativeSecurityAttributeHandle(int rowId);
    internal static DeclarativeSecurityAttributeHandle FromRowId(int rowId);
    public static Handle op_Implicit(DeclarativeSecurityAttributeHandle handle);
    public static EntityHandle op_Implicit(DeclarativeSecurityAttributeHandle handle);
    public static DeclarativeSecurityAttributeHandle op_Explicit(Handle handle);
    public static DeclarativeSecurityAttributeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeclarativeSecurityAttributeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader, EntityHandle handle);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<DeclarativeSecurityAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.DeclarativeSecurityAttributeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Document : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private DocumentHandle Handle { get; }
    public DocumentNameBlobHandle Name { get; }
    public GuidHandle Language { get; }
    public GuidHandle HashAlgorithm { get; }
    public BlobHandle Hash { get; }
    [NullableContextAttribute("1")]
internal Document(MetadataReader reader, DocumentHandle handle);
    private DocumentHandle get_Handle();
    public DocumentNameBlobHandle get_Name();
    public GuidHandle get_Language();
    public GuidHandle get_HashAlgorithm();
    public BlobHandle get_Hash();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DocumentHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private DocumentHandle(int rowId);
    internal static DocumentHandle FromRowId(int rowId);
    public static Handle op_Implicit(DocumentHandle handle);
    public static EntityHandle op_Implicit(DocumentHandle handle);
    public static DocumentHandle op_Explicit(Handle handle);
    public static DocumentHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(DocumentHandle left, DocumentHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(DocumentHandle left, DocumentHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DocumentHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal DocumentHandleCollection(MetadataReader reader);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<DocumentHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.DocumentHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.DocumentNameBlobHandle : ValueType {
    private int _heapOffset;
    public bool IsNil { get; }
    private DocumentNameBlobHandle(int heapOffset);
    internal static DocumentNameBlobHandle FromOffset(int heapOffset);
    public static BlobHandle op_Implicit(DocumentNameBlobHandle handle);
    public static DocumentNameBlobHandle op_Explicit(BlobHandle handle);
    public bool get_IsNil();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentNameBlobHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(DocumentNameBlobHandle left, DocumentNameBlobHandle right);
    public static bool op_Inequality(DocumentNameBlobHandle left, DocumentNameBlobHandle right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ArrayShapeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public ArrayShapeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [NullableContextAttribute("0")]
public void Shape(int rank, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyOSTableReader : ValueType {
    internal int NumberOfRows;
    private int _OSPlatformIdOffset;
    private int _OSMajorVersionIdOffset;
    private int _OSMinorVersionIdOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyOSTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyProcessorTableReader : ValueType {
    internal int NumberOfRows;
    private int _ProcessorOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyProcessorTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyRefOSTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsAssemblyRefTableRowRefSizeSmall;
    private int _OSPlatformIdOffset;
    private int _OSMajorVersionIdOffset;
    private int _OSMinorVersionIdOffset;
    private int _AssemblyRefOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefOSTableReader(int numberOfRows, int assemblyRefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyRefProcessorTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsAssemblyRefTableRowSizeSmall;
    private int _ProcessorOffset;
    private int _AssemblyRefOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefProcessorTableReader(int numberOfRows, int assemblyRefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyRefTableReader : ValueType {
    internal int NumberOfNonVirtualRows;
    internal int NumberOfVirtualRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _MajorVersionOffset;
    private int _MinorVersionOffset;
    private int _BuildNumberOffset;
    private int _RevisionNumberOffset;
    private int _FlagsOffset;
    private int _PublicKeyOrTokenOffset;
    private int _NameOffset;
    private int _CultureOffset;
    private int _HashValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset, MetadataKind metadataKind);
    [NullableContextAttribute("1")]
internal Version GetVersion(int rowId);
    internal AssemblyFlags GetFlags(int rowId);
    internal BlobHandle GetPublicKeyOrToken(int rowId);
    internal StringHandle GetName(int rowId);
    internal StringHandle GetCulture(int rowId);
    internal BlobHandle GetHashValue(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.AssemblyTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _HashAlgIdOffset;
    private int _MajorVersionOffset;
    private int _MinorVersionOffset;
    private int _BuildNumberOffset;
    private int _RevisionNumberOffset;
    private int _FlagsOffset;
    private int _PublicKeyOffset;
    private int _NameOffset;
    private int _CultureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal AssemblyHashAlgorithm GetHashAlgorithm();
    [NullableContextAttribute("1")]
internal Version GetVersion();
    internal AssemblyFlags GetFlags();
    internal BlobHandle GetPublicKey();
    internal StringHandle GetName();
    internal StringHandle GetCulture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.BlobEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public BlobEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public FieldTypeEncoder Field();
    public SignatureTypeEncoder FieldSignature();
    public GenericTypeArgumentsEncoder MethodSpecificationSignature(int genericArgumentCount);
    public MethodSignatureEncoder MethodSignature(SignatureCallingConvention convention, int genericParameterCount, bool isInstanceMethod);
    public MethodSignatureEncoder PropertySignature(bool isInstanceProperty);
    public void CustomAttributeSignature(FixedArgumentsEncoder& fixedArguments, CustomAttributeNamedArgumentsEncoder& namedArguments);
    public void CustomAttributeSignature(Action`1<FixedArgumentsEncoder> fixedArguments, Action`1<CustomAttributeNamedArgumentsEncoder> namedArguments);
    public LocalVariablesEncoder LocalVariableSignature(int variableCount);
    public SignatureTypeEncoder TypeSpecificationSignature();
    public PermissionSetEncoder PermissionSetBlob(int attributeCount);
    public NamedArgumentsEncoder PermissionSetArguments(int argumentCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.Ecma335.BlobHeap : ValueType {
    private static Byte[][] s_virtualValues;
    internal MemoryBlock Block;
    private VirtualHeap _lazyVirtualHeap;
    internal BlobHeap(MemoryBlock block, MetadataKind metadataKind);
    internal Byte[] GetBytes(BlobHandle handle);
    internal MemoryBlock GetMemoryBlock(BlobHandle handle);
    private MemoryBlock GetVirtualHandleMemoryBlock(BlobHandle handle);
    internal BlobReader GetBlobReader(BlobHandle handle);
    internal BlobHandle GetNextHandle(BlobHandle handle);
    internal static Byte[] GetVirtualBlobBytes(BlobHandle handle, bool unique);
    public string GetDocumentName(DocumentNameBlobHandle handle);
    internal bool DocumentNameEquals(DocumentNameBlobHandle handle, string other, bool ignoreCase);
}
internal class System.Reflection.Metadata.Ecma335.ClassLayoutTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private int _PackagingSizeOffset;
    private int _ClassSizeOffset;
    private int _ParentOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ClassLayoutTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetParent(int rowId);
    internal ushort GetPackingSize(int rowId);
    internal UInt32 GetClassSize(int rowId);
    internal int FindRow(TypeDefinitionHandle typeDef);
    private bool CheckSorted();
}
public static class System.Reflection.Metadata.Ecma335.CodedIndex : object {
    public static int HasCustomAttribute(EntityHandle handle);
    public static int HasConstant(EntityHandle handle);
    public static int CustomAttributeType(EntityHandle handle);
    public static int HasDeclSecurity(EntityHandle handle);
    public static int HasFieldMarshal(EntityHandle handle);
    public static int HasSemantics(EntityHandle handle);
    public static int Implementation(EntityHandle handle);
    public static int MemberForwarded(EntityHandle handle);
    public static int MemberRefParent(EntityHandle handle);
    public static int MethodDefOrRef(EntityHandle handle);
    public static int ResolutionScope(EntityHandle handle);
    public static int TypeDefOrRef(EntityHandle handle);
    public static int TypeDefOrRefOrSpec(EntityHandle handle);
    public static int TypeOrMethodDef(EntityHandle handle);
    public static int HasCustomDebugInformation(EntityHandle handle);
    private static HasCustomAttributeTag ToHasCustomAttributeTag(HandleKind kind);
    private static HasConstantTag ToHasConstantTag(HandleKind kind);
    private static CustomAttributeTypeTag ToCustomAttributeTypeTag(HandleKind kind);
    private static HasDeclSecurityTag ToHasDeclSecurityTag(HandleKind kind);
    private static HasFieldMarshalTag ToHasFieldMarshalTag(HandleKind kind);
    private static HasSemanticsTag ToHasSemanticsTag(HandleKind kind);
    private static ImplementationTag ToImplementationTag(HandleKind kind);
    private static MemberForwardedTag ToMemberForwardedTag(HandleKind kind);
    private static MemberRefParentTag ToMemberRefParentTag(HandleKind kind);
    private static MethodDefOrRefTag ToMethodDefOrRefTag(HandleKind kind);
    private static ResolutionScopeTag ToResolutionScopeTag(HandleKind kind);
    private static TypeDefOrRefOrSpecTag ToTypeDefOrRefOrSpecTag(HandleKind kind);
    private static TypeDefOrRefTag ToTypeDefOrRefTag(HandleKind kind);
    private static TypeOrMethodDefTag ToTypeOrMethodDefTag(HandleKind kind);
    private static HasCustomDebugInformationTag ToHasCustomDebugInformationTag(HandleKind kind);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ConstantTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasConstantRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _TypeOffset;
    private int _ParentOffset;
    private int _ValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ConstantTableReader(int numberOfRows, bool declaredSorted, int hasConstantRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ConstantTypeCode GetType(ConstantHandle handle);
    internal BlobHandle GetValue(ConstantHandle handle);
    internal EntityHandle GetParent(ConstantHandle handle);
    internal ConstantHandle FindConstant(EntityHandle parentHandle);
    private bool CheckSorted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.Ecma335.ControlFlowBuilder : object {
    private Builder<BranchInfo> _branches;
    private Builder<int> _labels;
    private Builder<ExceptionHandlerInfo> _lazyExceptionHandlers;
    internal IEnumerable`1<BranchInfo> Branches { get; }
    internal IEnumerable`1<int> Labels { get; }
    internal int BranchCount { get; }
    internal int ExceptionHandlerCount { get; }
    public void Clear();
    internal LabelHandle AddLabel();
    internal void AddBranch(int ilOffset, LabelHandle label, ILOpCode opCode);
    internal void MarkLabel(int ilOffset, LabelHandle label);
    private int GetLabelOffsetChecked(LabelHandle label);
    private void ValidateLabel(LabelHandle label, string parameterName);
    public void AddFinallyRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd);
    public void AddFaultRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd);
    public void AddCatchRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, EntityHandle catchType);
    public void AddFilterRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, LabelHandle filterStart);
    private void AddExceptionRegion(ExceptionRegionKind kind, LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, LabelHandle filterStart, EntityHandle catchType);
    internal IEnumerable`1<BranchInfo> get_Branches();
    internal IEnumerable`1<int> get_Labels();
    internal int get_BranchCount();
    internal int get_ExceptionHandlerCount();
    internal void CopyCodeAndFixupBranches(BlobBuilder srcBuilder, BlobBuilder dstBuilder);
    internal void SerializeExceptionTable(BlobBuilder builder);
    private bool HasSmallExceptionRegions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Reflection.Metadata.Ecma335.COR20Constants : object {
    internal static int SizeOfCorHeader;
    internal static UInt32 COR20MetadataSignature;
    internal static int MinimumSizeofMetadataHeader;
    internal static int SizeofStorageHeader;
    internal static int MinimumSizeofStreamHeader;
    internal static string StringStreamName;
    internal static string BlobStreamName;
    internal static string GUIDStreamName;
    internal static string UserStringStreamName;
    internal static string CompressedMetadataTableStreamName;
    internal static string UncompressedMetadataTableStreamName;
    internal static string MinimalDeltaMetadataTableStreamName;
    internal static string StandalonePdbStreamName;
    internal static int LargeStreamHeapSize;
}
internal enum System.Reflection.Metadata.Ecma335.CorElementType : Enum {
    public byte value__;
    public static CorElementType Invalid;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_HANDLE;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public CustomAttributeArrayTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public void ObjectArray();
    public CustomAttributeElementTypeEncoder ElementType();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1 : ValueType {
    private ICustomAttributeTypeProvider`1<TType> _provider;
    private MetadataReader _reader;
    [NullableContextAttribute("1")]
public CustomAttributeDecoder`1(ICustomAttributeTypeProvider`1<TType> provider, MetadataReader reader);
    public CustomAttributeValue`1<TType> DecodeValue(EntityHandle constructor, BlobHandle value);
    private ImmutableArray`1<CustomAttributeTypedArgument`1<TType>> DecodeFixedArguments(BlobReader& signatureReader, BlobReader& valueReader, int count, BlobReader genericContextReader);
    private ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> DecodeNamedArguments(BlobReader& valueReader);
    private ArgumentTypeInfo<TType> DecodeFixedArgumentType(BlobReader& signatureReader, BlobReader genericContextReader, bool isElementType);
    private ArgumentTypeInfo<TType> DecodeNamedArgumentType(BlobReader& valueReader, bool isElementType);
    private CustomAttributeTypedArgument`1<TType> DecodeArgument(BlobReader& valueReader, ArgumentTypeInfo<TType> info);
    private Nullable`1<ImmutableArray`1<CustomAttributeTypedArgument`1<TType>>> DecodeArrayArgument(BlobReader& blobReader, ArgumentTypeInfo<TType> info);
    private TType GetTypeFromHandle(EntityHandle handle);
    private static void SkipType(BlobReader& blobReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public CustomAttributeElementTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    private void WriteTypeCode(SerializationTypeCode value);
    public void Boolean();
    public void Char();
    public void SByte();
    public void Byte();
    public void Int16();
    public void UInt16();
    public void Int32();
    public void UInt32();
    public void Int64();
    public void UInt64();
    public void Single();
    public void Double();
    public void String();
    public void PrimitiveType(PrimitiveSerializationTypeCode type);
    public void SystemType();
    public void Enum(string enumTypeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public CustomAttributeNamedArgumentsEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public NamedArgumentsEncoder Count(int count);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.CustomAttributeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasCustomAttributeRefSizeSmall;
    private bool _IsCustomAttributeTypeRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ParentOffset;
    private int _TypeOffset;
    private int _ValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    [NullableAttribute("2")]
internal Int32[] PtrTable;
    internal CustomAttributeTableReader(int numberOfRows, bool declaredSorted, int hasCustomAttributeRefSize, int customAttributeTypeRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetParent(CustomAttributeHandle handle);
    internal EntityHandle GetConstructor(CustomAttributeHandle handle);
    internal BlobHandle GetValue(CustomAttributeHandle handle);
    internal void GetAttributeRange(EntityHandle parentHandle, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.CustomAttributeTreatment : Enum {
    public byte value__;
    public static CustomAttributeTreatment None;
    public static CustomAttributeTreatment WinMD;
}
internal static class System.Reflection.Metadata.Ecma335.CustomAttributeTypeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static ulong TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 customAttributeType);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.CustomAttributeValueTreatment : Enum {
    public byte value__;
    public static CustomAttributeValueTreatment None;
    public static CustomAttributeValueTreatment AttributeUsageAllowSingle;
    public static CustomAttributeValueTreatment AttributeUsageAllowMultiple;
    public static CustomAttributeValueTreatment AttributeUsageVersionAttribute;
    public static CustomAttributeValueTreatment AttributeUsageDeprecatedAttribute;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.CustomDebugInformationTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isHasCustomDebugInformationRefSizeSmall;
    private bool _isGuidHeapRefSizeSmall;
    private bool _isBlobHeapRefSizeSmall;
    private int _kindOffset;
    private int _valueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal CustomDebugInformationTableReader(int numberOfRows, bool declaredSorted, int hasCustomDebugInformationRefSize, int guidHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetParent(CustomDebugInformationHandle handle);
    internal GuidHandle GetKind(CustomDebugInformationHandle handle);
    internal BlobHandle GetValue(CustomDebugInformationHandle handle);
    internal void GetRange(EntityHandle parentHandle, Int32& firstImplRowId, Int32& lastImplRowId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.CustomModifiersEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public CustomModifiersEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomModifiersEncoder AddModifier(EntityHandle type, bool isOptional);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.DeclSecurityTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasDeclSecurityRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ActionOffset;
    private int _ParentOffset;
    private int _PermissionSetOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal DeclSecurityTableReader(int numberOfRows, bool declaredSorted, int hasDeclSecurityRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal DeclarativeSecurityAction GetAction(int rowId);
    internal EntityHandle GetParent(int rowId);
    internal BlobHandle GetPermissionSet(int rowId);
    internal void GetAttributeRange(EntityHandle parentToken, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.DocumentTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isGuidHeapRefSizeSmall;
    private bool _isBlobHeapRefSizeSmall;
    private int _hashAlgorithmOffset;
    private int _hashOffset;
    private int _languageOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal DocumentTableReader(int numberOfRows, int guidHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal DocumentNameBlobHandle GetName(DocumentHandle handle);
    internal GuidHandle GetHashAlgorithm(DocumentHandle handle);
    internal BlobHandle GetHash(DocumentHandle handle);
    internal GuidHandle GetLanguage(DocumentHandle handle);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry : ValueType {
    [CompilerGeneratedAttribute]
private EntityHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private EditAndContinueOperation <Operation>k__BackingField;
    public EntityHandle Handle { get; }
    public EditAndContinueOperation Operation { get; }
    public EditAndContinueLogEntry(EntityHandle handle, EditAndContinueOperation operation);
    [CompilerGeneratedAttribute]
public EntityHandle get_Handle();
    [CompilerGeneratedAttribute]
public EditAndContinueOperation get_Operation();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EditAndContinueLogEntry other);
    public virtual int GetHashCode();
}
public enum System.Reflection.Metadata.Ecma335.EditAndContinueOperation : Enum {
    public int value__;
    public static EditAndContinueOperation Default;
    public static EditAndContinueOperation AddMethod;
    public static EditAndContinueOperation AddField;
    public static EditAndContinueOperation AddParameter;
    public static EditAndContinueOperation AddProperty;
    public static EditAndContinueOperation AddEvent;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.EnCLogTableReader : ValueType {
    internal int NumberOfRows;
    private int _TokenOffset;
    private int _FuncCodeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EnCLogTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset, MetadataStreamKind metadataStreamKind);
    internal UInt32 GetToken(int rowId);
    internal EditAndContinueOperation GetFuncCode(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.EnCMapTableReader : ValueType {
    internal int NumberOfRows;
    private int _TokenOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EnCMapTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
    internal UInt32 GetToken(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.EventMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsEventRefSizeSmall;
    private int _ParentOffset;
    private int _EventListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int eventRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindEventMapRowIdFor(TypeDefinitionHandle typeDef);
    internal TypeDefinitionHandle GetParentType(int rowId);
    internal int GetEventListStartFor(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.EventPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsEventTableRowRefSizeSmall;
    private int _EventOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventPtrTableReader(int numberOfRows, int eventTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EventDefinitionHandle GetEventFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.EventTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _EventTypeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventTableReader(int numberOfRows, int typeDefOrRefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EventAttributes GetFlags(EventDefinitionHandle handle);
    internal StringHandle GetName(EventDefinitionHandle handle);
    internal EntityHandle GetEventType(EventDefinitionHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder : ValueType {
    internal static int MaxSmallExceptionRegions;
    internal static int MaxExceptionRegions;
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSmallFormat>k__BackingField;
    public BlobBuilder Builder { get; }
    public bool HasSmallFormat { get; }
    internal ExceptionRegionEncoder(BlobBuilder builder, bool hasSmallFormat);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [CompilerGeneratedAttribute]
public bool get_HasSmallFormat();
    public static bool IsSmallRegionCount(int exceptionRegionCount);
    public static bool IsSmallExceptionRegion(int startOffset, int length);
    internal static bool IsSmallExceptionRegionFromBounds(int startOffset, int endOffset);
    internal static int GetExceptionTableSize(int exceptionRegionCount, bool isSmallFormat);
    internal static bool IsExceptionRegionCountInBounds(int exceptionRegionCount);
    internal static bool IsValidCatchTypeHandle(EntityHandle catchType);
    internal static ExceptionRegionEncoder SerializeTableHeader(BlobBuilder builder, int exceptionRegionCount, bool hasSmallRegions);
    public ExceptionRegionEncoder AddFinally(int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    public ExceptionRegionEncoder AddFault(int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    public ExceptionRegionEncoder AddCatch(int tryOffset, int tryLength, int handlerOffset, int handlerLength, EntityHandle catchType);
    public ExceptionRegionEncoder AddFilter(int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset);
    public ExceptionRegionEncoder Add(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, EntityHandle catchType, int filterOffset);
    internal void AddUnchecked(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int catchTokenOrOffset);
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.ExportedTypeExtensions : object {
    [ExtensionAttribute]
public static int GetTypeDefinitionId(ExportedType exportedType);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ExportedTypeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsImplementationRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _TypeDefIdOffset;
    private int _TypeNameOffset;
    private int _TypeNamespaceOffset;
    private int _ImplementationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ExportedTypeTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetTypeName(int rowId);
    internal StringHandle GetTypeNamespaceString(int rowId);
    internal NamespaceDefinitionHandle GetTypeNamespace(int rowId);
    internal EntityHandle GetImplementation(int rowId);
    internal TypeAttributes GetFlags(int rowId);
    internal int GetTypeDefId(int rowId);
    internal int GetNamespace(int rowId);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.FieldDefTreatment : Enum {
    public byte value__;
    public static FieldDefTreatment None;
    public static FieldDefTreatment EnumValue;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FieldLayoutTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _OffsetOffset;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldLayoutTableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindFieldLayoutRowId(FieldDefinitionHandle handle);
    internal UInt32 GetOffset(int rowId);
    internal FieldDefinitionHandle GetField(int rowId);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FieldMarshalTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasFieldMarshalRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ParentOffset;
    private int _NativeTypeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldMarshalTableReader(int numberOfRows, bool declaredSorted, int hasFieldMarshalRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetParent(int rowId);
    internal BlobHandle GetNativeType(int rowId);
    internal int FindFieldMarshalRowId(EntityHandle handle);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FieldPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldPtrTableReader(int numberOfRows, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal FieldDefinitionHandle GetFieldFor(int rowId);
    internal int GetRowIdForFieldDefRow(int fieldDefRowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FieldRVATableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _RvaOffset;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldRVATableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int GetRva(int rowId);
    internal int FindFieldRvaRowId(int fieldDefRowId);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FieldTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(FieldDefinitionHandle handle);
    internal FieldAttributes GetFlags(FieldDefinitionHandle handle);
    internal BlobHandle GetSignature(FieldDefinitionHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.FieldTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public FieldTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomModifiersEncoder CustomModifiers();
    public SignatureTypeEncoder Type(bool isByRef);
    public void TypedReference();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.FileTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _HashValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FileTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetHashValue(AssemblyFileHandle handle);
    internal UInt32 GetFlags(AssemblyFileHandle handle);
    internal StringHandle GetName(AssemblyFileHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public FixedArgumentsEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public LiteralEncoder AddArgument();
}
public enum System.Reflection.Metadata.Ecma335.FunctionPointerAttributes : Enum {
    public int value__;
    public static FunctionPointerAttributes None;
    public static FunctionPointerAttributes HasThis;
    public static FunctionPointerAttributes HasExplicitThis;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.GenericParamConstraintTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsGenericParamTableRowRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private int _OwnerOffset;
    private int _ConstraintOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal GenericParamConstraintTableReader(int numberOfRows, bool declaredSorted, int genericParamTableRowRefSize, int typeDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal GenericParameterConstraintHandleCollection FindConstraintsForGenericParam(GenericParameterHandle genericParameter);
    private bool CheckSorted();
    internal EntityHandle GetConstraint(GenericParameterConstraintHandle handle);
    internal GenericParameterHandle GetOwner(GenericParameterConstraintHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.GenericParamTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeOrMethodDefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _NumberOffset;
    private int _FlagsOffset;
    private int _OwnerOffset;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal GenericParamTableReader(int numberOfRows, bool declaredSorted, int typeOrMethodDefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ushort GetNumber(GenericParameterHandle handle);
    internal GenericParameterAttributes GetFlags(GenericParameterHandle handle);
    internal StringHandle GetName(GenericParameterHandle handle);
    internal EntityHandle GetOwner(GenericParameterHandle handle);
    internal GenericParameterHandleCollection FindGenericParametersForType(TypeDefinitionHandle typeDef);
    internal GenericParameterHandleCollection FindGenericParametersForMethod(MethodDefinitionHandle methodDef);
    private int BinarySearchTag(UInt32 searchCodedTag, UInt16& genericParamCount);
    private bool CheckSorted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public GenericTypeArgumentsEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public SignatureTypeEncoder AddArgument();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.GuidHeap : ValueType {
    internal MemoryBlock Block;
    public GuidHeap(MemoryBlock block);
    internal Guid GetGuid(GuidHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HandleType : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Constant;
    internal static UInt32 CustomAttribute;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Signature;
    internal static UInt32 EventMap;
    internal static UInt32 Event;
    internal static UInt32 PropertyMap;
    internal static UInt32 Property;
    internal static UInt32 MethodSemantics;
    internal static UInt32 MethodImpl;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 NestedClass;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 Document;
    internal static UInt32 MethodDebugInformation;
    internal static UInt32 LocalScope;
    internal static UInt32 LocalVariable;
    internal static UInt32 LocalConstant;
    internal static UInt32 ImportScope;
    internal static UInt32 AsyncMethod;
    internal static UInt32 CustomDebugInformation;
    internal static UInt32 UserString;
    internal static UInt32 Blob;
    internal static UInt32 Guid;
    internal static UInt32 String;
    internal static UInt32 String1;
    internal static UInt32 String2;
    internal static UInt32 String3;
    internal static UInt32 Namespace;
    internal static UInt32 HeapMask;
    internal static UInt32 TypeMask;
    internal static UInt32 VirtualBit;
    internal static UInt32 NonVirtualStringTypeMask;
}
internal static class System.Reflection.Metadata.Ecma335.HasConstantTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasConstant);
    internal static UInt32 ConvertToTag(EntityHandle token);
}
internal static class System.Reflection.Metadata.Ecma335.HasCustomAttributeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 Field;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 Param;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Module;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Property;
    internal static UInt32 Event;
    internal static UInt32 StandAloneSig;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 GenericParam;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 MethodSpec;
    internal static UInt32 TagMask;
    internal static UInt32 InvalidTokenType;
    [NullableAttribute("1")]
internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static HasCustomAttributeTag();
    internal static EntityHandle ConvertToHandle(UInt32 hasCustomAttribute);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasCustomDebugInformationTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 Field;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 Param;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Module;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Property;
    internal static UInt32 Event;
    internal static UInt32 StandAloneSig;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 GenericParam;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 MethodSpec;
    internal static UInt32 Document;
    internal static UInt32 LocalScope;
    internal static UInt32 LocalVariable;
    internal static UInt32 LocalConstant;
    internal static UInt32 Import;
    internal static UInt32 TagMask;
    internal static UInt32 InvalidTokenType;
    [NullableAttribute("1")]
internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static HasCustomDebugInformationTag();
    internal static EntityHandle ConvertToHandle(UInt32 taggedReference);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasDeclSecurityTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 MethodDef;
    internal static UInt32 Assembly;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasDeclSecurity);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasFieldMarshalTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasFieldMarshal);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasSemanticsTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Event;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasSemantic);
    internal static UInt32 ConvertEventHandleToTag(EventDefinitionHandle eventDef);
    internal static UInt32 ConvertPropertyHandleToTag(PropertyDefinitionHandle propertyDef);
}
internal static class System.Reflection.Metadata.Ecma335.HeapHandleType : object {
    internal static int OffsetBitCount;
    internal static UInt32 OffsetMask;
    internal static UInt32 VirtualBit;
    internal static bool IsValidHeapOffset(UInt32 offset);
}
public enum System.Reflection.Metadata.Ecma335.HeapIndex : Enum {
    public int value__;
    public static HeapIndex UserString;
    public static HeapIndex String;
    public static HeapIndex Blob;
    public static HeapIndex Guid;
}
internal static class System.Reflection.Metadata.Ecma335.HeapIndexExtensions : object {
    internal static int Count;
}
internal enum System.Reflection.Metadata.Ecma335.HeapSizeFlag : Enum {
    public byte value__;
    public static HeapSizeFlag StringHeapLarge;
    public static HeapSizeFlag GuidHeapLarge;
    public static HeapSizeFlag BlobHeapLarge;
    public static HeapSizeFlag EncDeltas;
    public static HeapSizeFlag DeletedMarks;
}
internal enum System.Reflection.Metadata.Ecma335.HeapSizes : Enum {
    public byte value__;
    public static HeapSizes StringHeapLarge;
    public static HeapSizes GuidHeapLarge;
    public static HeapSizes BlobHeapLarge;
    public static HeapSizes ExtraData;
}
internal static class System.Reflection.Metadata.Ecma335.ImplementationTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 File;
    internal static UInt32 AssemblyRef;
    internal static UInt32 ExportedType;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 implementation);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ImplMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsModuleRefTableRowRefSizeSmall;
    private bool _IsMemberForwardRowRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _MemberForwardedOffset;
    private int _ImportNameOffset;
    private int _ImportScopeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ImplMapTableReader(int numberOfRows, bool declaredSorted, int moduleRefTableRowRefSize, int memberForwardedRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodImport GetImport(int rowId);
    internal EntityHandle GetMemberForwarded(int rowId);
    internal int FindImplForMethod(MethodDefinitionHandle methodDef);
    private int BinarySearchTag(UInt32 searchCodedTag);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ImportScopeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isImportScopeRefSizeSmall;
    private bool _isBlobHeapRefSizeSmall;
    private int _importsOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ImportScopeTableReader(int numberOfRows, int importScopeRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ImportScopeHandle GetParent(ImportScopeHandle handle);
    internal BlobHandle GetImports(ImportScopeHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.InstructionEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <CodeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBuilder <ControlFlowBuilder>k__BackingField;
    public BlobBuilder CodeBuilder { get; }
    [NullableAttribute("2")]
public ControlFlowBuilder ControlFlowBuilder { get; }
    public int Offset { get; }
    public InstructionEncoder(BlobBuilder codeBuilder, ControlFlowBuilder controlFlowBuilder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_CodeBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ControlFlowBuilder get_ControlFlowBuilder();
    public int get_Offset();
    public void OpCode(ILOpCode code);
    public void Token(EntityHandle handle);
    public void Token(int token);
    public void LoadString(UserStringHandle handle);
    public void Call(EntityHandle methodHandle);
    public void Call(MethodDefinitionHandle methodHandle);
    public void Call(MethodSpecificationHandle methodHandle);
    public void Call(MemberReferenceHandle methodHandle);
    public void CallIndirect(StandaloneSignatureHandle signature);
    public void LoadConstantI4(int value);
    public void LoadConstantI8(long value);
    public void LoadConstantR4(float value);
    public void LoadConstantR8(double value);
    public void LoadLocal(int slotIndex);
    public void StoreLocal(int slotIndex);
    public void LoadLocalAddress(int slotIndex);
    public void LoadArgument(int argumentIndex);
    public void LoadArgumentAddress(int argumentIndex);
    public void StoreArgument(int argumentIndex);
    public LabelHandle DefineLabel();
    public void Branch(ILOpCode code, LabelHandle label);
    public void MarkLabel(LabelHandle label);
    private ControlFlowBuilder GetBranchBuilder();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.InterfaceImplTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private int _ClassOffset;
    private int _InterfaceOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal InterfaceImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int typeDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    private bool CheckSorted();
    internal void GetInterfaceImplRange(TypeDefinitionHandle typeDef, Int32& firstImplRowId, Int32& lastImplRowId);
    internal EntityHandle GetInterface(int rowId);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.LabelHandle : ValueType {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; }
    public bool IsNil { get; }
    internal LabelHandle(int id);
    [CompilerGeneratedAttribute]
public int get_Id();
    public bool get_IsNil();
    public sealed virtual bool Equals(LabelHandle other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LabelHandle left, LabelHandle right);
    public static bool op_Inequality(LabelHandle left, LabelHandle right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.LiteralEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public LiteralEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public VectorEncoder Vector();
    public void TaggedVector(CustomAttributeArrayTypeEncoder& arrayType, VectorEncoder& vector);
    public void TaggedVector(Action`1<CustomAttributeArrayTypeEncoder> arrayType, Action`1<VectorEncoder> vector);
    public ScalarEncoder Scalar();
    public void TaggedScalar(CustomAttributeElementTypeEncoder& type, ScalarEncoder& scalar);
    public void TaggedScalar(Action`1<CustomAttributeElementTypeEncoder> type, Action`1<ScalarEncoder> scalar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.LiteralsEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public LiteralsEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public LiteralEncoder AddLiteral();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.LocalConstantTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isStringHeapRefSizeSmall;
    private bool _isBlobHeapRefSizeSmall;
    private int _signatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal LocalConstantTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(LocalConstantHandle handle);
    internal BlobHandle GetSignature(LocalConstantHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.LocalScopeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isMethodRefSmall;
    private bool _isImportScopeRefSmall;
    private bool _isLocalConstantRefSmall;
    private bool _isLocalVariableRefSmall;
    private int _importScopeOffset;
    private int _variableListOffset;
    private int _constantListOffset;
    private int _startOffsetOffset;
    private int _lengthOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal LocalScopeTableReader(int numberOfRows, bool declaredSorted, int methodRefSize, int importScopeRefSize, int localVariableRefSize, int localConstantRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle GetMethod(int rowId);
    internal ImportScopeHandle GetImportScope(LocalScopeHandle handle);
    internal int GetVariableStart(int rowId);
    internal int GetConstantStart(int rowId);
    internal int GetStartOffset(int rowId);
    internal int GetLength(int rowId);
    internal int GetEndOffset(int rowId);
    internal void GetLocalScopeRange(int methodDefRid, Int32& firstScopeRowId, Int32& lastScopeRowId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.LocalVariablesEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public LocalVariablesEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public LocalVariableTypeEncoder AddVariable();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.LocalVariableTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isStringHeapRefSizeSmall;
    private int _attributesOffset;
    private int _indexOffset;
    private int _nameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal LocalVariableTableReader(int numberOfRows, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal LocalVariableAttributes GetAttributes(LocalVariableHandle handle);
    internal ushort GetIndex(LocalVariableHandle handle);
    internal StringHandle GetName(LocalVariableHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public LocalVariableTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomModifiersEncoder CustomModifiers();
    public SignatureTypeEncoder Type(bool isByRef, bool isPinned);
    public void TypedReference();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ManifestResourceTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsImplementationRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _OffsetOffset;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _ImplementationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ManifestResourceTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(ManifestResourceHandle handle);
    internal EntityHandle GetImplementation(ManifestResourceHandle handle);
    internal UInt32 GetOffset(ManifestResourceHandle handle);
    internal ManifestResourceAttributes GetFlags(ManifestResourceHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.MemberForwardedTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 MethodDef;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 memberForwarded);
    internal static UInt32 ConvertMethodDefToTag(MethodDefinitionHandle methodDef);
}
internal static class System.Reflection.Metadata.Ecma335.MemberRefParentTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 ModuleRef;
    internal static UInt32 MethodDef;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static ulong TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 memberRef);
}
internal class System.Reflection.Metadata.Ecma335.MemberRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMemberRefParentRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ClassOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MemberRefTableReader(int numberOfRows, int memberRefParentRefSize, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(MemberReferenceHandle handle);
    internal StringHandle GetName(MemberReferenceHandle handle);
    internal EntityHandle GetClass(MemberReferenceHandle handle);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.MemberRefTreatment : Enum {
    public byte value__;
    public static MemberRefTreatment None;
    public static MemberRefTreatment Dispose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.Ecma335.MetadataAggregator : object {
    private ImmutableArray`1<ImmutableArray`1<int>> _heapSizes;
    private ImmutableArray`1<ImmutableArray`1<RowCounts>> _rowCounts;
    public MetadataAggregator(MetadataReader baseReader, IReadOnlyList`1<MetadataReader> deltaReaders);
    [NullableContextAttribute("2")]
public MetadataAggregator(IReadOnlyList`1<int> baseTableRowCounts, IReadOnlyList`1<int> baseHeapSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    private MetadataAggregator(MetadataReader baseReader, IReadOnlyList`1<int> baseTableRowCounts, IReadOnlyList`1<int> baseHeapSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    internal MetadataAggregator(RowCounts[][] rowCounts, Int32[][] heapSizes);
    private static void CalculateBaseCounts(MetadataReader baseReader, IReadOnlyList`1& baseTableRowCounts, IReadOnlyList`1& baseHeapSizes);
    private static ImmutableArray`1<ImmutableArray`1<int>> CalculateHeapSizes(IReadOnlyList`1<int> baseSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    private static ImmutableArray`1<ImmutableArray`1<RowCounts>> CalculateRowCounts(IReadOnlyList`1<int> baseRowCounts, IReadOnlyList`1<MetadataReader> deltaReaders);
    private static ImmutableArray`1<ImmutableArray`1<T>> ToImmutable(T[][] array);
    internal static RowCounts[][] GetBaseRowCounts(IReadOnlyList`1<int> baseRowCounts, int generations);
    internal static void CalculateDeltaRowCountsForGeneration(RowCounts[][] rowCounts, int generation, EnCMapTableReader& encMapTable);
    public Handle GetGenerationHandle(Handle handle, Int32& generation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.Ecma335.MetadataBuilder : object {
    private Nullable`1<ModuleRow> _moduleRow;
    private Nullable`1<AssemblyRow> _assemblyRow;
    private List`1<ClassLayoutRow> _classLayoutTable;
    private List`1<ConstantRow> _constantTable;
    private int _constantTableLastParent;
    private bool _constantTableNeedsSorting;
    private List`1<CustomAttributeRow> _customAttributeTable;
    private int _customAttributeTableLastParent;
    private bool _customAttributeTableNeedsSorting;
    private List`1<DeclSecurityRow> _declSecurityTable;
    private int _declSecurityTableLastParent;
    private bool _declSecurityTableNeedsSorting;
    private List`1<EncLogRow> _encLogTable;
    private List`1<EncMapRow> _encMapTable;
    private List`1<EventRow> _eventTable;
    private List`1<EventMapRow> _eventMapTable;
    private List`1<ExportedTypeRow> _exportedTypeTable;
    private List`1<FieldLayoutRow> _fieldLayoutTable;
    private List`1<FieldMarshalRow> _fieldMarshalTable;
    private int _fieldMarshalTableLastParent;
    private bool _fieldMarshalTableNeedsSorting;
    private List`1<FieldRvaRow> _fieldRvaTable;
    private List`1<FieldDefRow> _fieldTable;
    private List`1<FileTableRow> _fileTable;
    private List`1<GenericParamConstraintRow> _genericParamConstraintTable;
    private List`1<GenericParamRow> _genericParamTable;
    private List`1<ImplMapRow> _implMapTable;
    private List`1<InterfaceImplRow> _interfaceImplTable;
    private List`1<ManifestResourceRow> _manifestResourceTable;
    private List`1<MemberRefRow> _memberRefTable;
    private List`1<MethodImplRow> _methodImplTable;
    private List`1<MethodSemanticsRow> _methodSemanticsTable;
    private int _methodSemanticsTableLastAssociation;
    private bool _methodSemanticsTableNeedsSorting;
    private List`1<MethodSpecRow> _methodSpecTable;
    private List`1<MethodRow> _methodDefTable;
    private List`1<ModuleRefRow> _moduleRefTable;
    private List`1<NestedClassRow> _nestedClassTable;
    private List`1<ParamRow> _paramTable;
    private List`1<PropertyMapRow> _propertyMapTable;
    private List`1<PropertyRow> _propertyTable;
    private List`1<TypeDefRow> _typeDefTable;
    private List`1<TypeRefRow> _typeRefTable;
    private List`1<TypeSpecRow> _typeSpecTable;
    private List`1<AssemblyRefTableRow> _assemblyRefTable;
    private List`1<StandaloneSigRow> _standAloneSigTable;
    private List`1<DocumentRow> _documentTable;
    private List`1<MethodDebugInformationRow> _methodDebugInformationTable;
    private List`1<LocalScopeRow> _localScopeTable;
    private List`1<LocalVariableRow> _localVariableTable;
    private List`1<LocalConstantRow> _localConstantTable;
    private List`1<ImportScopeRow> _importScopeTable;
    private List`1<StateMachineMethodRow> _stateMachineMethodTable;
    private List`1<CustomDebugInformationRow> _customDebugInformationTable;
    private Dictionary`2<string, UserStringHandle> _userStrings;
    private HeapBlobBuilder _userStringBuilder;
    private int _userStringHeapStartOffset;
    private Dictionary`2<string, StringHandle> _strings;
    private int _stringHeapStartOffset;
    private int _stringHeapCapacity;
    private Dictionary`2<ImmutableArray`1<byte>, BlobHandle> _blobs;
    private int _blobHeapStartOffset;
    private int _blobHeapSize;
    private Dictionary`2<Guid, GuidHandle> _guids;
    private HeapBlobBuilder _guidBuilder;
    public MetadataBuilder(int userStringHeapStartOffset, int stringHeapStartOffset, int blobHeapStartOffset, int guidHeapStartOffset);
    [NullableContextAttribute("0")]
internal SerializedMetadata GetSerializedMetadata(ImmutableArray`1<int> externalRowCounts, int metadataVersionByteCount, bool isStandaloneDebugMetadata);
    internal static void SerializeMetadataHeader(BlobBuilder builder, string metadataVersion, MetadataSizes sizes);
    private static void SerializeStreamHeader(Int32& offsetFromStartOfMetadata, int alignedStreamSize, string streamName, BlobBuilder builder);
    public void SetCapacity(TableIndex table, int rowCount);
    private static void SetTableCapacity(List`1<T> table, int rowCount);
    public int GetRowCount(TableIndex table);
    [NullableContextAttribute("0")]
public ImmutableArray`1<int> GetRowCounts();
    public ModuleDefinitionHandle AddModule(int generation, StringHandle moduleName, GuidHandle mvid, GuidHandle encId, GuidHandle encBaseId);
    public AssemblyDefinitionHandle AddAssembly(StringHandle name, Version version, StringHandle culture, BlobHandle publicKey, AssemblyFlags flags, AssemblyHashAlgorithm hashAlgorithm);
    public AssemblyReferenceHandle AddAssemblyReference(StringHandle name, Version version, StringHandle culture, BlobHandle publicKeyOrToken, AssemblyFlags flags, BlobHandle hashValue);
    public TypeDefinitionHandle AddTypeDefinition(TypeAttributes attributes, StringHandle namespace, StringHandle name, EntityHandle baseType, FieldDefinitionHandle fieldList, MethodDefinitionHandle methodList);
    public void AddTypeLayout(TypeDefinitionHandle type, ushort packingSize, UInt32 size);
    public InterfaceImplementationHandle AddInterfaceImplementation(TypeDefinitionHandle type, EntityHandle implementedInterface);
    public void AddNestedType(TypeDefinitionHandle type, TypeDefinitionHandle enclosingType);
    public TypeReferenceHandle AddTypeReference(EntityHandle resolutionScope, StringHandle namespace, StringHandle name);
    public TypeSpecificationHandle AddTypeSpecification(BlobHandle signature);
    public StandaloneSignatureHandle AddStandaloneSignature(BlobHandle signature);
    public PropertyDefinitionHandle AddProperty(PropertyAttributes attributes, StringHandle name, BlobHandle signature);
    public void AddPropertyMap(TypeDefinitionHandle declaringType, PropertyDefinitionHandle propertyList);
    public EventDefinitionHandle AddEvent(EventAttributes attributes, StringHandle name, EntityHandle type);
    public void AddEventMap(TypeDefinitionHandle declaringType, EventDefinitionHandle eventList);
    [NullableContextAttribute("2")]
public ConstantHandle AddConstant(EntityHandle parent, object value);
    public void AddMethodSemantics(EntityHandle association, MethodSemanticsAttributes semantics, MethodDefinitionHandle methodDefinition);
    public CustomAttributeHandle AddCustomAttribute(EntityHandle parent, EntityHandle constructor, BlobHandle value);
    public MethodSpecificationHandle AddMethodSpecification(EntityHandle method, BlobHandle instantiation);
    public ModuleReferenceHandle AddModuleReference(StringHandle moduleName);
    public ParameterHandle AddParameter(ParameterAttributes attributes, StringHandle name, int sequenceNumber);
    public GenericParameterHandle AddGenericParameter(EntityHandle parent, GenericParameterAttributes attributes, StringHandle name, int index);
    public GenericParameterConstraintHandle AddGenericParameterConstraint(GenericParameterHandle genericParameter, EntityHandle constraint);
    public FieldDefinitionHandle AddFieldDefinition(FieldAttributes attributes, StringHandle name, BlobHandle signature);
    public void AddFieldLayout(FieldDefinitionHandle field, int offset);
    public void AddMarshallingDescriptor(EntityHandle parent, BlobHandle descriptor);
    public void AddFieldRelativeVirtualAddress(FieldDefinitionHandle field, int offset);
    public MethodDefinitionHandle AddMethodDefinition(MethodAttributes attributes, MethodImplAttributes implAttributes, StringHandle name, BlobHandle signature, int bodyOffset, ParameterHandle parameterList);
    public void AddMethodImport(MethodDefinitionHandle method, MethodImportAttributes attributes, StringHandle name, ModuleReferenceHandle module);
    public MethodImplementationHandle AddMethodImplementation(TypeDefinitionHandle type, EntityHandle methodBody, EntityHandle methodDeclaration);
    public MemberReferenceHandle AddMemberReference(EntityHandle parent, StringHandle name, BlobHandle signature);
    public ManifestResourceHandle AddManifestResource(ManifestResourceAttributes attributes, StringHandle name, EntityHandle implementation, UInt32 offset);
    public AssemblyFileHandle AddAssemblyFile(StringHandle name, BlobHandle hashValue, bool containsMetadata);
    public ExportedTypeHandle AddExportedType(TypeAttributes attributes, StringHandle namespace, StringHandle name, EntityHandle implementation, int typeDefinitionId);
    public DeclarativeSecurityAttributeHandle AddDeclarativeSecurityAttribute(EntityHandle parent, DeclarativeSecurityAction action, BlobHandle permissionSet);
    public void AddEncLogEntry(EntityHandle entity, EditAndContinueOperation code);
    public void AddEncMapEntry(EntityHandle entity);
    public DocumentHandle AddDocument(BlobHandle name, GuidHandle hashAlgorithm, BlobHandle hash, GuidHandle language);
    public MethodDebugInformationHandle AddMethodDebugInformation(DocumentHandle document, BlobHandle sequencePoints);
    public LocalScopeHandle AddLocalScope(MethodDefinitionHandle method, ImportScopeHandle importScope, LocalVariableHandle variableList, LocalConstantHandle constantList, int startOffset, int length);
    public LocalVariableHandle AddLocalVariable(LocalVariableAttributes attributes, int index, StringHandle name);
    public LocalConstantHandle AddLocalConstant(StringHandle name, BlobHandle signature);
    public ImportScopeHandle AddImportScope(ImportScopeHandle parentScope, BlobHandle imports);
    public void AddStateMachineMethod(MethodDefinitionHandle moveNextMethod, MethodDefinitionHandle kickoffMethod);
    public CustomDebugInformationHandle AddCustomDebugInformation(EntityHandle parent, GuidHandle kind, BlobHandle value);
    internal void ValidateOrder();
    private void ValidateClassLayoutTable();
    private void ValidateFieldLayoutTable();
    private void ValidateFieldRvaTable();
    private void ValidateGenericParamTable();
    private void ValidateGenericParamConstaintTable();
    private void ValidateImplMapTable();
    private void ValidateInterfaceImplTable();
    private void ValidateMethodImplTable();
    private void ValidateNestedClassTable();
    private void ValidateLocalScopeTable();
    private void ValidateStateMachineMethodTable();
    internal void SerializeMetadataTables(BlobBuilder writer, MetadataSizes metadataSizes, ImmutableArray`1<int> stringMap, int methodBodyStreamRva, int mappedFieldDataStreamRva);
    private static void SerializeTablesHeader(BlobBuilder writer, MetadataSizes metadataSizes);
    internal void SerializeModuleTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeEncLogTable(BlobBuilder writer);
    private void SerializeEncMapTable(BlobBuilder writer);
    private void SerializeTypeRefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeTypeDefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeFieldTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeMethodDefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes, int methodBodyStreamRva);
    private void SerializeParamTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeInterfaceImplTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeMemberRefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeConstantTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeCustomAttributeTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeFieldMarshalTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeDeclSecurityTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeClassLayoutTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeFieldLayoutTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeStandAloneSigTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeEventMapTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeEventTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializePropertyMapTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializePropertyTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeMethodSemanticsTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeMethodImplTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeModuleRefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeTypeSpecTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeImplMapTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeFieldRvaTable(BlobBuilder writer, MetadataSizes metadataSizes, int mappedFieldDataStreamRva);
    private void SerializeAssemblyTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeAssemblyRefTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeFileTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeExportedTypeTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeManifestResourceTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeNestedClassTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeGenericParamTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeGenericParamConstraintTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeMethodSpecTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeDocumentTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeMethodDebugInformationTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeLocalScopeTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeLocalVariableTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeLocalConstantTable(BlobBuilder writer, ImmutableArray`1<int> stringMap, MetadataSizes metadataSizes);
    private void SerializeImportScopeTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeStateMachineMethodTable(BlobBuilder writer, MetadataSizes metadataSizes);
    private void SerializeCustomDebugInformationTable(BlobBuilder writer, MetadataSizes metadataSizes);
    public void SetCapacity(HeapIndex heap, int byteCount);
    [NullableContextAttribute("0")]
internal static int SerializeHandle(ImmutableArray`1<int> map, StringHandle handle);
    internal static int SerializeHandle(BlobHandle handle);
    internal static int SerializeHandle(GuidHandle handle);
    internal static int SerializeHandle(UserStringHandle handle);
    public BlobHandle GetOrAddBlob(BlobBuilder value);
    public BlobHandle GetOrAddBlob(Byte[] value);
    [NullableContextAttribute("0")]
public BlobHandle GetOrAddBlob(ImmutableArray`1<byte> value);
    [NullableContextAttribute("2")]
public BlobHandle GetOrAddConstantBlob(object value);
    public BlobHandle GetOrAddBlobUTF16(string value);
    public BlobHandle GetOrAddBlobUTF8(string value, bool allowUnpairedSurrogates);
    public BlobHandle GetOrAddDocumentName(string value);
    private static char ChooseSeparator(string str);
    public GuidHandle GetOrAddGuid(Guid guid);
    [NullableContextAttribute("0")]
public ReservedBlob`1<GuidHandle> ReserveGuid();
    private GuidHandle GetNewGuidHandle();
    public StringHandle GetOrAddString(string value);
    [NullableContextAttribute("0")]
public ReservedBlob`1<UserStringHandle> ReserveUserString(int length);
    public UserStringHandle GetOrAddUserString(string value);
    private UserStringHandle GetNewUserStringHandle();
    private static ImmutableArray`1<int> SerializeStringHeap(BlobBuilder heapBuilder, Dictionary`2<string, StringHandle> strings, int stringHeapStartOffset);
    internal void WriteHeapsTo(BlobBuilder builder, BlobBuilder stringHeap);
    private void WriteAlignedBlobHeap(BlobBuilder builder);
    private static void WriteAligned(BlobBuilder source, BlobBuilder target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.MetadataReaderExtensions : object {
    [ExtensionAttribute]
public static int GetTableRowCount(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetTableRowSize(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetTableMetadataOffset(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
private static MemoryBlock GetTableMetadataBlock(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetHeapSize(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
public static int GetHeapMetadataOffset(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
private static MemoryBlock GetMetadataBlock(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
public static UserStringHandle GetNextHandle(MetadataReader reader, UserStringHandle handle);
    [ExtensionAttribute]
public static BlobHandle GetNextHandle(MetadataReader reader, BlobHandle handle);
    [ExtensionAttribute]
public static StringHandle GetNextHandle(MetadataReader reader, StringHandle handle);
    [ExtensionAttribute]
public static IEnumerable`1<EditAndContinueLogEntry> GetEditAndContinueLogEntries(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<EntityHandle> GetEditAndContinueMapEntries(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTypesWithProperties(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTypesWithEvents(MetadataReader reader);
    [ExtensionAttribute]
public static SignatureTypeKind ResolveSignatureTypeKind(MetadataReader reader, EntityHandle typeHandle, byte rawTypeKind);
    [IteratorStateMachineAttribute("System.Reflection.Metadata.Ecma335.MetadataReaderExtensions/<<GetEditAndContinueLogEntries>g__Core|10_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<EditAndContinueLogEntry> <GetEditAndContinueLogEntries>g__Core|10_0(MetadataReader reader);
    [IteratorStateMachineAttribute("System.Reflection.Metadata.Ecma335.MetadataReaderExtensions/<<GetEditAndContinueMapEntries>g__Core|11_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<EntityHandle> <GetEditAndContinueMapEntries>g__Core|11_0(MetadataReader reader);
    [IteratorStateMachineAttribute("System.Reflection.Metadata.Ecma335.MetadataReaderExtensions/<<GetTypesWithProperties>g__Core|12_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TypeDefinitionHandle> <GetTypesWithProperties>g__Core|12_0(MetadataReader reader);
    [IteratorStateMachineAttribute("System.Reflection.Metadata.Ecma335.MetadataReaderExtensions/<<GetTypesWithEvents>g__Core|13_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TypeDefinitionHandle> <GetTypesWithEvents>g__Core|13_0(MetadataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.Ecma335.MetadataRootBuilder : object {
    [NullableAttribute("0")]
internal static ImmutableArray`1<int> EmptyRowCounts;
    private MetadataBuilder _tablesAndHeaps;
    private SerializedMetadata _serializedMetadata;
    [CompilerGeneratedAttribute]
private string <MetadataVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressValidation>k__BackingField;
    public string MetadataVersion { get; }
    public bool SuppressValidation { get; }
    public MetadataSizes Sizes { get; }
    public MetadataRootBuilder(MetadataBuilder tablesAndHeaps, string metadataVersion, bool suppressValidation);
    private static MetadataRootBuilder();
    [CompilerGeneratedAttribute]
public string get_MetadataVersion();
    [CompilerGeneratedAttribute]
public bool get_SuppressValidation();
    public MetadataSizes get_Sizes();
    public void Serialize(BlobBuilder builder, int methodBodyStreamRva, int mappedFieldDataStreamRva);
}
public class System.Reflection.Metadata.Ecma335.MetadataSizes : object {
    internal static int MaxMetadataVersionByteCount;
    internal int MetadataVersionPaddedLength;
    internal static ulong SortedDebugTables;
    internal bool IsEncDelta;
    internal bool IsCompressed;
    internal bool BlobReferenceIsSmall;
    internal bool StringReferenceIsSmall;
    internal bool GuidReferenceIsSmall;
    internal bool CustomAttributeTypeCodedIndexIsSmall;
    internal bool DeclSecurityCodedIndexIsSmall;
    internal bool EventDefReferenceIsSmall;
    internal bool FieldDefReferenceIsSmall;
    internal bool GenericParamReferenceIsSmall;
    internal bool HasConstantCodedIndexIsSmall;
    internal bool HasCustomAttributeCodedIndexIsSmall;
    internal bool HasFieldMarshalCodedIndexIsSmall;
    internal bool HasSemanticsCodedIndexIsSmall;
    internal bool ImplementationCodedIndexIsSmall;
    internal bool MemberForwardedCodedIndexIsSmall;
    internal bool MemberRefParentCodedIndexIsSmall;
    internal bool MethodDefReferenceIsSmall;
    internal bool MethodDefOrRefCodedIndexIsSmall;
    internal bool ModuleRefReferenceIsSmall;
    internal bool ParameterReferenceIsSmall;
    internal bool PropertyDefReferenceIsSmall;
    internal bool ResolutionScopeCodedIndexIsSmall;
    internal bool TypeDefReferenceIsSmall;
    internal bool TypeDefOrRefCodedIndexIsSmall;
    internal bool TypeOrMethodDefCodedIndexIsSmall;
    internal bool DocumentReferenceIsSmall;
    internal bool LocalVariableReferenceIsSmall;
    internal bool LocalConstantReferenceIsSmall;
    internal bool ImportScopeReferenceIsSmall;
    internal bool HasCustomDebugInformationCodedIndexIsSmall;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <HeapSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <RowCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ExternalRowCounts>k__BackingField;
    internal ulong PresentTablesMask;
    internal ulong ExternalTablesMask;
    internal int MetadataStreamStorageSize;
    internal int MetadataTableStreamSize;
    internal int StandalonePdbStreamSize;
    internal static int PdbIdSize;
    public ImmutableArray`1<int> HeapSizes { get; }
    public ImmutableArray`1<int> RowCounts { get; }
    public ImmutableArray`1<int> ExternalRowCounts { get; }
    internal bool IsStandaloneDebugMetadata { get; }
    internal int MetadataHeaderSize { get; }
    internal int MetadataSize { get; }
    internal MetadataSizes(ImmutableArray`1<int> rowCounts, ImmutableArray`1<int> externalRowCounts, ImmutableArray`1<int> heapSizes, int metadataVersionByteCount, bool isStandaloneDebugMetadata);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_HeapSizes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_RowCounts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ExternalRowCounts();
    internal bool get_IsStandaloneDebugMetadata();
    internal bool IsPresent(TableIndex table);
    internal int get_MetadataHeaderSize();
    [NullableContextAttribute("1")]
internal static int GetMetadataStreamHeaderSize(string streamName);
    internal int get_MetadataSize();
    public int GetAlignedHeapSize(HeapIndex index);
    internal int CalculateTableStreamHeaderSize();
    internal int CalculateStandalonePdbStreamSize();
    private static ulong ComputeNonEmptyTableMask(ImmutableArray`1<int> rowCounts);
    private int GetTableSize(TableIndex index, int rowSize);
    private bool IsReferenceSmall(int tagBitSize, TableIndex[] tables);
    private bool ReferenceFits(int bitCount, TableIndex[] tables);
}
internal static class System.Reflection.Metadata.Ecma335.MetadataStreamConstants : object {
    internal static int SizeOfMetadataTableHeader;
    internal static UInt32 LargeTableRowCount;
}
internal enum System.Reflection.Metadata.Ecma335.MetadataStreamKind : Enum {
    public int value__;
    public static MetadataStreamKind Illegal;
    public static MetadataStreamKind Compressed;
    public static MetadataStreamKind Uncompressed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.MetadataTokens : object {
    public static int TableCount;
    public static int HeapCount;
    private static MetadataTokens();
    [ExtensionAttribute]
public static int GetRowNumber(MetadataReader reader, EntityHandle handle);
    [ExtensionAttribute]
public static int GetHeapOffset(MetadataReader reader, Handle handle);
    [ExtensionAttribute]
public static int GetToken(MetadataReader reader, EntityHandle handle);
    [ExtensionAttribute]
public static int GetToken(MetadataReader reader, Handle handle);
    private static int MapVirtualHandleRowId(MetadataReader reader, Handle handle);
    public static int GetRowNumber(EntityHandle handle);
    public static int GetHeapOffset(Handle handle);
    public static int GetHeapOffset(BlobHandle handle);
    public static int GetHeapOffset(GuidHandle handle);
    public static int GetHeapOffset(UserStringHandle handle);
    public static int GetHeapOffset(StringHandle handle);
    public static int GetToken(Handle handle);
    public static int GetToken(EntityHandle handle);
    public static bool TryGetTableIndex(HandleKind type, TableIndex& index);
    public static bool TryGetHeapIndex(HandleKind type, HeapIndex& index);
    public static Handle Handle(int token);
    public static EntityHandle EntityHandle(int token);
    public static EntityHandle EntityHandle(TableIndex tableIndex, int rowNumber);
    public static EntityHandle Handle(TableIndex tableIndex, int rowNumber);
    private static int ToRowId(int rowNumber);
    public static MethodDefinitionHandle MethodDefinitionHandle(int rowNumber);
    public static MethodImplementationHandle MethodImplementationHandle(int rowNumber);
    public static MethodSpecificationHandle MethodSpecificationHandle(int rowNumber);
    public static TypeDefinitionHandle TypeDefinitionHandle(int rowNumber);
    public static ExportedTypeHandle ExportedTypeHandle(int rowNumber);
    public static TypeReferenceHandle TypeReferenceHandle(int rowNumber);
    public static TypeSpecificationHandle TypeSpecificationHandle(int rowNumber);
    public static InterfaceImplementationHandle InterfaceImplementationHandle(int rowNumber);
    public static MemberReferenceHandle MemberReferenceHandle(int rowNumber);
    public static FieldDefinitionHandle FieldDefinitionHandle(int rowNumber);
    public static EventDefinitionHandle EventDefinitionHandle(int rowNumber);
    public static PropertyDefinitionHandle PropertyDefinitionHandle(int rowNumber);
    public static StandaloneSignatureHandle StandaloneSignatureHandle(int rowNumber);
    public static ParameterHandle ParameterHandle(int rowNumber);
    public static GenericParameterHandle GenericParameterHandle(int rowNumber);
    public static GenericParameterConstraintHandle GenericParameterConstraintHandle(int rowNumber);
    public static ModuleReferenceHandle ModuleReferenceHandle(int rowNumber);
    public static AssemblyReferenceHandle AssemblyReferenceHandle(int rowNumber);
    public static CustomAttributeHandle CustomAttributeHandle(int rowNumber);
    public static DeclarativeSecurityAttributeHandle DeclarativeSecurityAttributeHandle(int rowNumber);
    public static ConstantHandle ConstantHandle(int rowNumber);
    public static ManifestResourceHandle ManifestResourceHandle(int rowNumber);
    public static AssemblyFileHandle AssemblyFileHandle(int rowNumber);
    public static DocumentHandle DocumentHandle(int rowNumber);
    public static MethodDebugInformationHandle MethodDebugInformationHandle(int rowNumber);
    public static LocalScopeHandle LocalScopeHandle(int rowNumber);
    public static LocalVariableHandle LocalVariableHandle(int rowNumber);
    public static LocalConstantHandle LocalConstantHandle(int rowNumber);
    public static ImportScopeHandle ImportScopeHandle(int rowNumber);
    public static CustomDebugInformationHandle CustomDebugInformationHandle(int rowNumber);
    public static UserStringHandle UserStringHandle(int offset);
    public static StringHandle StringHandle(int offset);
    public static BlobHandle BlobHandle(int offset);
    public static GuidHandle GuidHandle(int offset);
    public static DocumentNameBlobHandle DocumentNameBlobHandle(int offset);
}
internal static class System.Reflection.Metadata.Ecma335.MetadataWriterUtilities : object {
    [NullableContextAttribute("2")]
public static SignatureTypeCode GetConstantTypeCode(object value);
    internal static void SerializeRowCounts(BlobBuilder writer, ImmutableArray`1<int> rowCounts);
}
[FlagsAttribute]
public enum System.Reflection.Metadata.Ecma335.MethodBodyAttributes : Enum {
    public int value__;
    public static MethodBodyAttributes None;
    public static MethodBodyAttributes InitLocals;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public MethodBodyStreamEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public MethodBody AddMethodBody(int codeSize, int maxStack, int exceptionRegionCount, bool hasSmallExceptionRegions, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes);
    public MethodBody AddMethodBody(int codeSize, int maxStack, int exceptionRegionCount, bool hasSmallExceptionRegions, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes, bool hasDynamicStackAllocation);
    public int AddMethodBody(InstructionEncoder instructionEncoder, int maxStack, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes);
    public int AddMethodBody(InstructionEncoder instructionEncoder, int maxStack, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes, bool hasDynamicStackAllocation);
    private int SerializeHeader(int codeSize, ushort maxStack, int exceptionRegionCount, MethodBodyAttributes attributes, StandaloneSignatureHandle localVariablesSignature, bool hasDynamicStackAllocation);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodDebugInformationTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isDocumentRefSmall;
    private bool _isBlobHeapRefSizeSmall;
    private int _sequencePointsOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodDebugInformationTableReader(int numberOfRows, int documentRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal DocumentHandle GetDocument(MethodDebugInformationHandle handle);
    internal BlobHandle GetSequencePoints(MethodDebugInformationHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.MethodDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 methodDefOrRef);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.MethodDefTreatment : Enum {
    public byte value__;
    public static MethodDefTreatment None;
    public static MethodDefTreatment KindMask;
    public static MethodDefTreatment Other;
    public static MethodDefTreatment DelegateMethod;
    public static MethodDefTreatment AttributeMethod;
    public static MethodDefTreatment InterfaceMethod;
    public static MethodDefTreatment Implementation;
    public static MethodDefTreatment HiddenInterfaceImplementation;
    public static MethodDefTreatment DisposeMethod;
    public static MethodDefTreatment MarkAbstractFlag;
    public static MethodDefTreatment MarkPublicFlag;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodImplTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsMethodDefOrRefRefSizeSmall;
    private int _ClassOffset;
    private int _MethodBodyOffset;
    private int _MethodDeclarationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int methodDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetClass(MethodImplementationHandle handle);
    internal EntityHandle GetMethodBody(MethodImplementationHandle handle);
    internal EntityHandle GetMethodDeclaration(MethodImplementationHandle handle);
    internal void GetMethodImplRange(TypeDefinitionHandle typeDef, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodTableRowRefSizeSmall;
    private int _MethodOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodPtrTableReader(int numberOfRows, int methodTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle GetMethodFor(int rowId);
    internal int GetRowIdForMethodDefRow(int methodDefRowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodSemanticsTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodTableRowRefSizeSmall;
    private bool _IsHasSemanticRefSizeSmall;
    private int _SemanticsFlagOffset;
    private int _MethodOffset;
    private int _AssociationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodSemanticsTableReader(int numberOfRows, bool declaredSorted, int methodTableRowRefSize, int hasSemanticRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle GetMethod(int rowId);
    internal MethodSemanticsAttributes GetSemantics(int rowId);
    internal EntityHandle GetAssociation(int rowId);
    internal int FindSemanticMethodsForEvent(EventDefinitionHandle eventDef, UInt16& methodCount);
    internal int FindSemanticMethodsForProperty(PropertyDefinitionHandle propertyDef, UInt16& methodCount);
    private int BinarySearchTag(UInt32 searchCodedTag, UInt16& methodCount);
    private bool CheckSorted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.MethodSignatureEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVarArgs>k__BackingField;
    public BlobBuilder Builder { get; }
    public bool HasVarArgs { get; }
    public MethodSignatureEncoder(BlobBuilder builder, bool hasVarArgs);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [CompilerGeneratedAttribute]
public bool get_HasVarArgs();
    public void Parameters(int parameterCount, ReturnTypeEncoder& returnType, ParametersEncoder& parameters);
    public void Parameters(int parameterCount, Action`1<ReturnTypeEncoder> returnType, Action`1<ParametersEncoder> parameters);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodSpecTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodDefOrRefRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _MethodOffset;
    private int _InstantiationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodSpecTableReader(int numberOfRows, int methodDefOrRefRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetMethod(MethodSpecificationHandle handle);
    internal BlobHandle GetInstantiation(MethodSpecificationHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.MethodTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsParamRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _RvaOffset;
    private int _ImplFlagsOffset;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    private int _ParamListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodTableReader(int numberOfRows, int paramRefSize, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int GetParamStart(int rowId);
    internal BlobHandle GetSignature(MethodDefinitionHandle handle);
    internal int GetRva(MethodDefinitionHandle handle);
    internal StringHandle GetName(MethodDefinitionHandle handle);
    internal MethodAttributes GetFlags(MethodDefinitionHandle handle);
    internal MethodImplAttributes GetImplFlags(MethodDefinitionHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ModuleRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ModuleRefTableReader(int numberOfRows, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(ModuleReferenceHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ModuleTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsGUIDHeapRefSizeSmall;
    private int _GenerationOffset;
    private int _NameOffset;
    private int _MVIdOffset;
    private int _EnCIdOffset;
    private int _EnCBaseIdOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ModuleTableReader(int numberOfRows, int stringHeapRefSize, int guidHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ushort GetGeneration();
    internal StringHandle GetName();
    internal GuidHandle GetMvid();
    internal GuidHandle GetEncId();
    internal GuidHandle GetEncBaseId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public NamedArgumentsEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public void AddArgument(bool isField, NamedArgumentTypeEncoder& type, NameEncoder& name, LiteralEncoder& literal);
    public void AddArgument(bool isField, Action`1<NamedArgumentTypeEncoder> type, Action`1<NameEncoder> name, Action`1<LiteralEncoder> literal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public NamedArgumentTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomAttributeElementTypeEncoder ScalarType();
    public void Object();
    public CustomAttributeArrayTypeEncoder SZArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.NameEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public NameEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public void Name(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.Ecma335.NamespaceCache : object {
    private MetadataReader _metadataReader;
    private object _namespaceTableAndListLock;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _namespaceTable;
    private NamespaceData _rootNamespace;
    private UInt32 _virtualNamespaceCounter;
    internal bool CacheIsRealized { get; }
    internal NamespaceCache(MetadataReader reader);
    internal bool get_CacheIsRealized();
    internal string GetFullName(NamespaceDefinitionHandle handle);
    internal NamespaceData GetRootNamespace();
    internal NamespaceData GetNamespaceData(NamespaceDefinitionHandle handle);
    private StringHandle GetSimpleName(NamespaceDefinitionHandle fullNamespaceHandle, int segmentIndex);
    private void PopulateNamespaceTable();
    private static void MergeDuplicateNamespaces(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table, Dictionary`2& stringTable);
    private NamespaceDataBuilder SynthesizeNamespaceData(string fullName, NamespaceDefinitionHandle realChild);
    private static void LinkChildDataToParentData(NamespaceDataBuilder child, NamespaceDataBuilder parent);
    private void LinkChildToParentNamespace(Dictionary`2<string, NamespaceDataBuilder> existingNamespaces, NamespaceDataBuilder realChild, List`1& virtualNamespaces);
    private void ResolveParentChildRelationships(Dictionary`2<string, NamespaceDataBuilder> namespaces, List`1& virtualNamespaces);
    private void PopulateTableWithTypeDefinitions(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table);
    private void PopulateTableWithExportedTypes(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table);
    private void EnsureNamespaceTableIsPopulated();
}
internal class System.Reflection.Metadata.Ecma335.NamespaceData : object {
    public StringHandle Name;
    [NullableAttribute("1")]
public string FullName;
    public NamespaceDefinitionHandle Parent;
    public ImmutableArray`1<NamespaceDefinitionHandle> NamespaceDefinitions;
    public ImmutableArray`1<TypeDefinitionHandle> TypeDefinitions;
    public ImmutableArray`1<ExportedTypeHandle> ExportedTypes;
    public NamespaceData(StringHandle name, string fullName, NamespaceDefinitionHandle parent, ImmutableArray`1<NamespaceDefinitionHandle> namespaceDefinitions, ImmutableArray`1<TypeDefinitionHandle> typeDefinitions, ImmutableArray`1<ExportedTypeHandle> exportedTypes);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.NestedClassTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private int _NestedClassOffset;
    private int _EnclosingClassOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal NestedClassTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetNestedClass(int rowId);
    internal TypeDefinitionHandle GetEnclosingClass(int rowId);
    internal TypeDefinitionHandle FindEnclosingType(TypeDefinitionHandle nestedTypeDef);
    private bool CheckSorted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ParametersEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVarArgs>k__BackingField;
    public BlobBuilder Builder { get; }
    public bool HasVarArgs { get; }
    public ParametersEncoder(BlobBuilder builder, bool hasVarArgs);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [CompilerGeneratedAttribute]
public bool get_HasVarArgs();
    public ParameterTypeEncoder AddParameter();
    public ParametersEncoder StartVarArgs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ParameterTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public ParameterTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomModifiersEncoder CustomModifiers();
    public SignatureTypeEncoder Type(bool isByRef);
    public void TypedReference();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ParamPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsParamTableRowRefSizeSmall;
    private int _ParamOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ParamPtrTableReader(int numberOfRows, int paramTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ParameterHandle GetParamFor(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.ParamTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _SequenceOffset;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ParamTableReader(int numberOfRows, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ParameterAttributes GetFlags(ParameterHandle handle);
    internal ushort GetSequence(ParameterHandle handle);
    internal StringHandle GetName(ParameterHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.PermissionSetEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public PermissionSetEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [NullableContextAttribute("0")]
public PermissionSetEncoder AddPermission(string typeName, ImmutableArray`1<byte> encodedArguments);
    public PermissionSetEncoder AddPermission(string typeName, BlobBuilder encodedArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.Ecma335.PortablePdbBuilder : object {
    private Blob _pdbIdBlob;
    private MethodDefinitionHandle _entryPoint;
    private MetadataBuilder _builder;
    private SerializedMetadata _serializedMetadata;
    [CompilerGeneratedAttribute]
private Func`2<IEnumerable`1<Blob>, BlobContentId> <IdProvider>k__BackingField;
    public string MetadataVersion { get; }
    public ushort FormatVersion { get; }
    public Func`2<IEnumerable`1<Blob>, BlobContentId> IdProvider { get; }
    [NullableContextAttribute("0")]
public PortablePdbBuilder(MetadataBuilder tablesAndHeaps, ImmutableArray`1<int> typeSystemRowCounts, MethodDefinitionHandle entryPoint, Func`2<IEnumerable`1<Blob>, BlobContentId> idProvider);
    public string get_MetadataVersion();
    public ushort get_FormatVersion();
    [CompilerGeneratedAttribute]
public Func`2<IEnumerable`1<Blob>, BlobContentId> get_IdProvider();
    private static void ValidateTypeSystemRowCounts(ImmutableArray`1<int> typeSystemRowCounts);
    private void SerializeStandalonePdbStream(BlobBuilder builder);
    public BlobContentId Serialize(BlobBuilder builder);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.PropertyMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsPropertyRefSizeSmall;
    private int _ParentOffset;
    private int _PropertyListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int propertyRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindPropertyMapRowIdFor(TypeDefinitionHandle typeDef);
    internal TypeDefinitionHandle GetParentType(int rowId);
    internal int GetPropertyListStartFor(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.PropertyPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsPropertyTableRowRefSizeSmall;
    private int _PropertyOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyPtrTableReader(int numberOfRows, int propertyTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal PropertyDefinitionHandle GetPropertyFor(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.PropertyTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal PropertyAttributes GetFlags(PropertyDefinitionHandle handle);
    internal StringHandle GetName(PropertyDefinitionHandle handle);
    internal BlobHandle GetSignature(PropertyDefinitionHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.ResolutionScopeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Module;
    internal static UInt32 ModuleRef;
    internal static UInt32 AssemblyRef;
    internal static UInt32 TypeRef;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 resolutionScope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ReturnTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public ReturnTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public CustomModifiersEncoder CustomModifiers();
    public SignatureTypeEncoder Type(bool isByRef);
    public void TypedReference();
    public void Void();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.ScalarEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public ScalarEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public void NullArray();
    [NullableContextAttribute("2")]
public void Constant(object value);
    [NullableContextAttribute("2")]
public void SystemType(string serializedTypeName);
    private void String(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.Ecma335.SerializedMetadata : object {
    [NullableAttribute("0")]
internal ImmutableArray`1<int> StringMap;
    internal BlobBuilder StringHeap;
    internal MetadataSizes Sizes;
    public SerializedMetadata(MetadataSizes sizes, BlobBuilder stringHeap, ImmutableArray`1<int> stringMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.SignatureDecoder`2 : ValueType {
    private ISignatureTypeProvider`2<TType, TGenericContext> _provider;
    private MetadataReader _metadataReaderOpt;
    private TGenericContext _genericContext;
    public SignatureDecoder`2(ISignatureTypeProvider`2<TType, TGenericContext> provider, MetadataReader metadataReader, TGenericContext genericContext);
    public TType DecodeType(BlobReader& blobReader, bool allowTypeSpecifications);
    private TType DecodeType(BlobReader& blobReader, bool allowTypeSpecifications, int typeCode);
    private ImmutableArray`1<TType> DecodeTypeSequence(BlobReader& blobReader);
    public MethodSignature`1<TType> DecodeMethodSignature(BlobReader& blobReader);
    public ImmutableArray`1<TType> DecodeMethodSpecificationSignature(BlobReader& blobReader);
    public ImmutableArray`1<TType> DecodeLocalSignature(BlobReader& blobReader);
    public TType DecodeFieldSignature(BlobReader& blobReader);
    private TType DecodeArrayType(BlobReader& blobReader);
    private TType DecodeGenericTypeInstance(BlobReader& blobReader);
    private TType DecodeModifiedType(BlobReader& blobReader, bool isRequired);
    private TType DecodeTypeHandle(BlobReader& blobReader, byte rawTypeKind, bool allowTypeSpecifications);
    private static void CheckHeader(SignatureHeader header, SignatureKind expectedKind);
    private static void CheckMethodOrPropertyHeader(SignatureHeader header);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.SignatureTypeEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public SignatureTypeEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    private void WriteTypeCode(SignatureTypeCode value);
    private void ClassOrValue(bool isValueType);
    public void Boolean();
    public void Char();
    public void SByte();
    public void Byte();
    public void Int16();
    public void UInt16();
    public void Int32();
    public void UInt32();
    public void Int64();
    public void UInt64();
    public void Single();
    public void Double();
    public void String();
    public void IntPtr();
    public void UIntPtr();
    public void Object();
    public void PrimitiveType(PrimitiveTypeCode type);
    public void Array(SignatureTypeEncoder& elementType, ArrayShapeEncoder& arrayShape);
    public void Array(Action`1<SignatureTypeEncoder> elementType, Action`1<ArrayShapeEncoder> arrayShape);
    public void Type(EntityHandle type, bool isValueType);
    public MethodSignatureEncoder FunctionPointer(SignatureCallingConvention convention, FunctionPointerAttributes attributes, int genericParameterCount);
    public GenericTypeArgumentsEncoder GenericInstantiation(EntityHandle genericType, int genericArgumentCount, bool isValueType);
    public void GenericMethodTypeParameter(int parameterIndex);
    public void GenericTypeParameter(int parameterIndex);
    public SignatureTypeEncoder Pointer();
    public void VoidPointer();
    public SignatureTypeEncoder SZArray();
    public CustomModifiersEncoder CustomModifiers();
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.StandAloneSigTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsBlobHeapRefSizeSmall;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal StandAloneSigTableReader(int numberOfRows, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(int rowId);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.StateMachineMethodTableReader : ValueType {
    internal int NumberOfRows;
    private bool _isMethodRefSizeSmall;
    private int _kickoffMethodOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal StateMachineMethodTableReader(int numberOfRows, bool declaredSorted, int methodRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle FindKickoffMethod(int moveNextMethodRowId);
    private MethodDefinitionHandle GetKickoffMethod(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.StreamHeader : ValueType {
    internal UInt32 Offset;
    internal int Size;
    [NullableAttribute("1")]
internal string Name;
}
internal static class System.Reflection.Metadata.Ecma335.StringHandleType : object {
    internal static UInt32 TypeMask;
    internal static UInt32 NonVirtualTypeMask;
    internal static UInt32 String;
    internal static UInt32 DotTerminatedString;
    internal static UInt32 ReservedString1;
    internal static UInt32 ReservedString2;
    internal static UInt32 VirtualString;
    internal static UInt32 WinRTPrefixedString;
    internal static UInt32 ReservedVirtualString1;
    internal static UInt32 ReservedVirtualString2;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.Ecma335.StringHeap : ValueType {
    private static String[] s_virtualValues;
    internal MemoryBlock Block;
    private VirtualHeap _lazyVirtualHeap;
    internal StringHeap(MemoryBlock block, MetadataKind metadataKind);
    private static MemoryBlock TrimEnd(MemoryBlock block);
    internal string GetString(StringHandle handle, MetadataStringDecoder utf8Decoder);
    internal MemoryBlock GetMemoryBlock(StringHandle handle);
    internal static string GetVirtualString(VirtualIndex index);
    private string GetNonVirtualString(StringHandle handle, MetadataStringDecoder utf8Decoder, Byte[] prefixOpt);
    private MemoryBlock GetNonVirtualStringMemoryBlock(StringHandle handle);
    private Byte[] GetNonVirtualStringBytes(StringHandle handle, Byte[] prefix);
    private string GetVirtualHandleString(StringHandle handle, MetadataStringDecoder utf8Decoder);
    private MemoryBlock GetVirtualHandleMemoryBlock(StringHandle handle);
    internal BlobReader GetBlobReader(StringHandle handle);
    internal StringHandle GetNextHandle(StringHandle handle);
    internal bool Equals(StringHandle handle, string value, MetadataStringDecoder utf8Decoder, bool ignoreCase);
    internal bool StartsWith(StringHandle handle, string value, MetadataStringDecoder utf8Decoder, bool ignoreCase);
    internal bool EqualsRaw(StringHandle rawHandle, string asciiString);
    internal int IndexOfRaw(int startIndex, char asciiChar);
    internal bool StartsWithRaw(StringHandle rawHandle, string asciiPrefix);
    internal int BinarySearchRaw(String[] asciiKeys, StringHandle rawHandle);
}
internal enum System.Reflection.Metadata.Ecma335.StringKind : Enum {
    public byte value__;
    public static StringKind Plain;
    public static StringKind Virtual;
    public static StringKind WinRTPrefixed;
    public static StringKind DotTerminated;
}
public enum System.Reflection.Metadata.Ecma335.TableIndex : Enum {
    public byte value__;
    public static TableIndex Module;
    public static TableIndex TypeRef;
    public static TableIndex TypeDef;
    public static TableIndex FieldPtr;
    public static TableIndex Field;
    public static TableIndex MethodPtr;
    public static TableIndex MethodDef;
    public static TableIndex ParamPtr;
    public static TableIndex Param;
    public static TableIndex InterfaceImpl;
    public static TableIndex MemberRef;
    public static TableIndex Constant;
    public static TableIndex CustomAttribute;
    public static TableIndex FieldMarshal;
    public static TableIndex DeclSecurity;
    public static TableIndex ClassLayout;
    public static TableIndex FieldLayout;
    public static TableIndex StandAloneSig;
    public static TableIndex EventMap;
    public static TableIndex EventPtr;
    public static TableIndex Event;
    public static TableIndex PropertyMap;
    public static TableIndex PropertyPtr;
    public static TableIndex Property;
    public static TableIndex MethodSemantics;
    public static TableIndex MethodImpl;
    public static TableIndex ModuleRef;
    public static TableIndex TypeSpec;
    public static TableIndex ImplMap;
    public static TableIndex FieldRva;
    public static TableIndex EncLog;
    public static TableIndex EncMap;
    public static TableIndex Assembly;
    public static TableIndex AssemblyProcessor;
    public static TableIndex AssemblyOS;
    public static TableIndex AssemblyRef;
    public static TableIndex AssemblyRefProcessor;
    public static TableIndex AssemblyRefOS;
    public static TableIndex File;
    public static TableIndex ExportedType;
    public static TableIndex ManifestResource;
    public static TableIndex NestedClass;
    public static TableIndex GenericParam;
    public static TableIndex MethodSpec;
    public static TableIndex GenericParamConstraint;
    public static TableIndex Document;
    public static TableIndex MethodDebugInformation;
    public static TableIndex LocalScope;
    public static TableIndex LocalVariable;
    public static TableIndex LocalConstant;
    public static TableIndex ImportScope;
    public static TableIndex StateMachineMethod;
    public static TableIndex CustomDebugInformation;
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.TableMask : Enum {
    public ulong value__;
    public static TableMask Module;
    public static TableMask TypeRef;
    public static TableMask TypeDef;
    public static TableMask FieldPtr;
    public static TableMask Field;
    public static TableMask MethodPtr;
    public static TableMask MethodDef;
    public static TableMask ParamPtr;
    public static TableMask Param;
    public static TableMask InterfaceImpl;
    public static TableMask MemberRef;
    public static TableMask Constant;
    public static TableMask CustomAttribute;
    public static TableMask FieldMarshal;
    public static TableMask DeclSecurity;
    public static TableMask ClassLayout;
    public static TableMask FieldLayout;
    public static TableMask StandAloneSig;
    public static TableMask EventMap;
    public static TableMask EventPtr;
    public static TableMask Event;
    public static TableMask PropertyMap;
    public static TableMask PropertyPtr;
    public static TableMask Property;
    public static TableMask MethodSemantics;
    public static TableMask MethodImpl;
    public static TableMask ModuleRef;
    public static TableMask TypeSpec;
    public static TableMask ImplMap;
    public static TableMask FieldRva;
    public static TableMask EnCLog;
    public static TableMask EnCMap;
    public static TableMask Assembly;
    public static TableMask AssemblyRef;
    public static TableMask File;
    public static TableMask ExportedType;
    public static TableMask ManifestResource;
    public static TableMask NestedClass;
    public static TableMask GenericParam;
    public static TableMask MethodSpec;
    public static TableMask GenericParamConstraint;
    public static TableMask Document;
    public static TableMask MethodDebugInformation;
    public static TableMask LocalScope;
    public static TableMask LocalVariable;
    public static TableMask LocalConstant;
    public static TableMask ImportScope;
    public static TableMask StateMachineMethod;
    public static TableMask CustomDebugInformation;
    public static TableMask PtrTables;
    public static TableMask EncTables;
    public static TableMask TypeSystemTables;
    public static TableMask DebugTables;
    public static TableMask AllTables;
    public static TableMask ValidPortablePdbExternalTables;
}
internal static class System.Reflection.Metadata.Ecma335.TokenTypeIds : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Constant;
    internal static UInt32 CustomAttribute;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Signature;
    internal static UInt32 EventMap;
    internal static UInt32 Event;
    internal static UInt32 PropertyMap;
    internal static UInt32 Property;
    internal static UInt32 MethodSemantics;
    internal static UInt32 MethodImpl;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 NestedClass;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 Document;
    internal static UInt32 MethodDebugInformation;
    internal static UInt32 LocalScope;
    internal static UInt32 LocalVariable;
    internal static UInt32 LocalConstant;
    internal static UInt32 ImportScope;
    internal static UInt32 AsyncMethod;
    internal static UInt32 CustomDebugInformation;
    internal static UInt32 UserString;
    internal static int RowIdBitCount;
    internal static UInt32 RIDMask;
    internal static UInt32 TypeMask;
    internal static UInt32 VirtualBit;
    internal static bool IsEntityOrUserStringToken(UInt32 vToken);
    internal static bool IsEntityToken(UInt32 vToken);
    internal static bool IsValidRowId(UInt32 rowId);
    internal static bool IsValidRowId(int rowId);
}
internal static class System.Reflection.Metadata.Ecma335.TypeDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 typeDefOrRefTag);
}
internal class System.Reflection.Metadata.Ecma335.TypeDefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldRefSizeSmall;
    private bool _IsMethodRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _NamespaceOffset;
    private int _ExtendsOffset;
    private int _FieldListOffset;
    private int _MethodListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeDefTableReader(int numberOfRows, int fieldRefSize, int methodRefSize, int typeDefOrRefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeAttributes GetFlags(TypeDefinitionHandle handle);
    internal NamespaceDefinitionHandle GetNamespaceDefinition(TypeDefinitionHandle handle);
    internal StringHandle GetNamespace(TypeDefinitionHandle handle);
    internal StringHandle GetName(TypeDefinitionHandle handle);
    internal EntityHandle GetExtends(TypeDefinitionHandle handle);
    internal int GetFieldStart(int rowId);
    internal int GetMethodStart(int rowId);
    internal TypeDefinitionHandle FindTypeContainingMethod(int methodDefOrPtrRowId, int numberOfMethods);
    internal TypeDefinitionHandle FindTypeContainingField(int fieldDefOrPtrRowId, int numberOfFields);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.TypeDefTreatment : Enum {
    public byte value__;
    public static TypeDefTreatment None;
    public static TypeDefTreatment KindMask;
    public static TypeDefTreatment NormalNonAttribute;
    public static TypeDefTreatment NormalAttribute;
    public static TypeDefTreatment UnmangleWinRTName;
    public static TypeDefTreatment PrefixWinRTName;
    public static TypeDefTreatment RedirectedToClrType;
    public static TypeDefTreatment RedirectedToClrAttribute;
    public static TypeDefTreatment MarkAbstractFlag;
    public static TypeDefTreatment MarkInternalFlag;
}
internal static class System.Reflection.Metadata.Ecma335.TypeOrMethodDefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 MethodDef;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 typeOrMethodDef);
    internal static UInt32 ConvertTypeDefRowIdToTag(TypeDefinitionHandle typeDef);
    internal static UInt32 ConvertMethodDefToTag(MethodDefinitionHandle methodDef);
}
internal enum System.Reflection.Metadata.Ecma335.TypeRefSignatureTreatment : Enum {
    public byte value__;
    public static TypeRefSignatureTreatment None;
    public static TypeRefSignatureTreatment ProjectedToClass;
    public static TypeRefSignatureTreatment ProjectedToValueType;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.TypeRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsResolutionScopeRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _ResolutionScopeOffset;
    private int _NameOffset;
    private int _NamespaceOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeRefTableReader(int numberOfRows, int resolutionScopeRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetResolutionScope(TypeReferenceHandle handle);
    internal StringHandle GetName(TypeReferenceHandle handle);
    internal StringHandle GetNamespace(TypeReferenceHandle handle);
}
internal enum System.Reflection.Metadata.Ecma335.TypeRefTreatment : Enum {
    public byte value__;
    public static TypeRefTreatment None;
    public static TypeRefTreatment SystemDelegate;
    public static TypeRefTreatment SystemAttribute;
    public static TypeRefTreatment UseProjectionInfo;
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.TypeSpecTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsBlobHeapRefSizeSmall;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeSpecTableReader(int numberOfRows, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(TypeSpecificationHandle handle);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Metadata.Ecma335.UserStringHeap : ValueType {
    internal MemoryBlock Block;
    public UserStringHeap(MemoryBlock block);
    [NullableContextAttribute("1")]
internal string GetString(UserStringHandle handle);
    internal UserStringHandle GetNextHandle(UserStringHandle handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Ecma335.VectorEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public BlobBuilder Builder { get; }
    public VectorEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public LiteralsEncoder Count(int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.Ecma335.VirtualHeap : CriticalDisposableObject {
    private Dictionary`2<UInt32, PinnedBlob> _blobs;
    protected virtual void Release();
    private Dictionary`2<UInt32, PinnedBlob> GetBlobs();
    public bool TryGetMemoryBlock(UInt32 rawHandle, MemoryBlock& block);
    internal MemoryBlock AddBlob(UInt32 rawHandle, Byte[] value);
    internal static VirtualHeap GetOrCreateVirtualHeap(VirtualHeap& lazyHeap);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.EntityHandle : ValueType {
    private UInt32 _vToken;
    public static ModuleDefinitionHandle ModuleDefinition;
    public static AssemblyDefinitionHandle AssemblyDefinition;
    internal UInt32 Type { get; }
    internal UInt32 VType { get; }
    internal bool IsVirtual { get; }
    public bool IsNil { get; }
    internal int RowId { get; }
    internal UInt32 SpecificHandleValue { get; }
    public HandleKind Kind { get; }
    internal int Token { get; }
    internal EntityHandle(UInt32 vToken);
    private static EntityHandle();
    public static Handle op_Implicit(EntityHandle handle);
    public static EntityHandle op_Explicit(Handle handle);
    internal UInt32 get_Type();
    internal UInt32 get_VType();
    internal bool get_IsVirtual();
    public bool get_IsNil();
    internal int get_RowId();
    internal UInt32 get_SpecificHandleValue();
    public HandleKind get_Kind();
    internal int get_Token();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EntityHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(EntityHandle left, EntityHandle right);
    public static bool op_Inequality(EntityHandle left, EntityHandle right);
    internal static int Compare(EntityHandle left, EntityHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.EventAccessors : ValueType {
    private int _adderRowId;
    private int _removerRowId;
    private int _raiserRowId;
    private ImmutableArray`1<MethodDefinitionHandle> _others;
    public MethodDefinitionHandle Adder { get; }
    public MethodDefinitionHandle Remover { get; }
    public MethodDefinitionHandle Raiser { get; }
    public ImmutableArray`1<MethodDefinitionHandle> Others { get; }
    internal EventAccessors(int adderRowId, int removerRowId, int raiserRowId, ImmutableArray`1<MethodDefinitionHandle> others);
    public MethodDefinitionHandle get_Adder();
    public MethodDefinitionHandle get_Remover();
    public MethodDefinitionHandle get_Raiser();
    public ImmutableArray`1<MethodDefinitionHandle> get_Others();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.EventDefinition : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private EventDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public EventAttributes Attributes { get; }
    public EntityHandle Type { get; }
    [NullableContextAttribute("1")]
internal EventDefinition(MetadataReader reader, EventDefinitionHandle handle);
    private EventDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public EventAttributes get_Attributes();
    public EntityHandle get_Type();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public EventAccessors GetAccessors();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.EventDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private EventDefinitionHandle(int rowId);
    internal static EventDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(EventDefinitionHandle handle);
    public static EntityHandle op_Implicit(EventDefinitionHandle handle);
    public static EventDefinitionHandle op_Explicit(Handle handle);
    public static EventDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(EventDefinitionHandle left, EventDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EventDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(EventDefinitionHandle left, EventDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.EventDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal EventDefinitionHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal EventDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<EventDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.EventDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ExceptionRegion : ValueType {
    private ExceptionRegionKind _kind;
    private int _tryOffset;
    private int _tryLength;
    private int _handlerOffset;
    private int _handlerLength;
    private int _classTokenOrFilterOffset;
    public ExceptionRegionKind Kind { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public EntityHandle CatchType { get; }
    internal ExceptionRegion(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classTokenOrFilterOffset);
    public ExceptionRegionKind get_Kind();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public int get_FilterOffset();
    public EntityHandle get_CatchType();
}
public enum System.Reflection.Metadata.ExceptionRegionKind : Enum {
    public ushort value__;
    public static ExceptionRegionKind Catch;
    public static ExceptionRegionKind Filter;
    public static ExceptionRegionKind Finally;
    public static ExceptionRegionKind Fault;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ExportedType : ValueType {
    internal MetadataReader reader;
    internal int rowId;
    private ExportedTypeHandle Handle { get; }
    public TypeAttributes Attributes { get; }
    public bool IsForwarder { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    public NamespaceDefinitionHandle NamespaceDefinition { get; }
    public EntityHandle Implementation { get; }
    internal ExportedType(MetadataReader reader, int rowId);
    private ExportedTypeHandle get_Handle();
    public TypeAttributes get_Attributes();
    public bool get_IsForwarder();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    public NamespaceDefinitionHandle get_NamespaceDefinition();
    public EntityHandle get_Implementation();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ExportedTypeHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ExportedTypeHandle(int rowId);
    internal static ExportedTypeHandle FromRowId(int rowId);
    public static Handle op_Implicit(ExportedTypeHandle handle);
    public static EntityHandle op_Implicit(ExportedTypeHandle handle);
    public static ExportedTypeHandle op_Explicit(Handle handle);
    public static ExportedTypeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ExportedTypeHandle left, ExportedTypeHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExportedTypeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ExportedTypeHandle left, ExportedTypeHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ExportedTypeHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal ExportedTypeHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ExportedTypeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ExportedTypeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.FieldDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private FieldDefTreatment Treatment { get; }
    private FieldDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public FieldAttributes Attributes { get; }
    public BlobHandle Signature { get; }
    internal FieldDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private FieldDefTreatment get_Treatment();
    private FieldDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public FieldAttributes get_Attributes();
    public BlobHandle get_Signature();
    public TType DecodeSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public TypeDefinitionHandle GetDeclaringType();
    public ConstantHandle GetDefaultValue();
    public int GetRelativeVirtualAddress();
    public int GetOffset();
    public BlobHandle GetMarshallingDescriptor();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private StringHandle GetProjectedName();
    private FieldAttributes GetProjectedFlags();
    private BlobHandle GetProjectedSignature();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.FieldDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private FieldDefinitionHandle(int rowId);
    internal static FieldDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(FieldDefinitionHandle handle);
    public static EntityHandle op_Implicit(FieldDefinitionHandle handle);
    public static FieldDefinitionHandle op_Explicit(Handle handle);
    public static FieldDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(FieldDefinitionHandle left, FieldDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FieldDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(FieldDefinitionHandle left, FieldDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.FieldDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal FieldDefinitionHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal FieldDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<FieldDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.FieldDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.GenericParameter : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private GenericParameterHandle Handle { get; }
    public EntityHandle Parent { get; }
    public GenericParameterAttributes Attributes { get; }
    public int Index { get; }
    public StringHandle Name { get; }
    [NullableContextAttribute("1")]
internal GenericParameter(MetadataReader reader, GenericParameterHandle handle);
    private GenericParameterHandle get_Handle();
    public EntityHandle get_Parent();
    public GenericParameterAttributes get_Attributes();
    public int get_Index();
    public StringHandle get_Name();
    public GenericParameterConstraintHandleCollection GetConstraints();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.GenericParameterConstraint : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private GenericParameterConstraintHandle Handle { get; }
    public GenericParameterHandle Parameter { get; }
    public EntityHandle Type { get; }
    [NullableContextAttribute("1")]
internal GenericParameterConstraint(MetadataReader reader, GenericParameterConstraintHandle handle);
    private GenericParameterConstraintHandle get_Handle();
    public GenericParameterHandle get_Parameter();
    public EntityHandle get_Type();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.GenericParameterConstraintHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private GenericParameterConstraintHandle(int rowId);
    internal static GenericParameterConstraintHandle FromRowId(int rowId);
    public static Handle op_Implicit(GenericParameterConstraintHandle handle);
    public static EntityHandle op_Implicit(GenericParameterConstraintHandle handle);
    public static GenericParameterConstraintHandle op_Explicit(Handle handle);
    public static GenericParameterConstraintHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericParameterConstraintHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.Metadata.GenericParameterConstraintHandleCollection : ValueType {
    private int _firstRowId;
    private ushort _count;
    public int Count { get; }
    public GenericParameterConstraintHandle Item { get; }
    internal GenericParameterConstraintHandleCollection(int firstRowId, ushort count);
    public sealed virtual int get_Count();
    public sealed virtual GenericParameterConstraintHandle get_Item(int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GenericParameterConstraintHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterConstraintHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.GenericParameterHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private GenericParameterHandle(int rowId);
    internal static GenericParameterHandle FromRowId(int rowId);
    public static Handle op_Implicit(GenericParameterHandle handle);
    public static EntityHandle op_Implicit(GenericParameterHandle handle);
    public static GenericParameterHandle op_Explicit(Handle handle);
    public static GenericParameterHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(GenericParameterHandle left, GenericParameterHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericParameterHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(GenericParameterHandle left, GenericParameterHandle right);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.Metadata.GenericParameterHandleCollection : ValueType {
    private int _firstRowId;
    private ushort _count;
    public int Count { get; }
    public GenericParameterHandle Item { get; }
    internal GenericParameterHandleCollection(int firstRowId, ushort count);
    public sealed virtual int get_Count();
    public sealed virtual GenericParameterHandle get_Item(int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GenericParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.GuidHandle : ValueType {
    private int _index;
    public bool IsNil { get; }
    internal int Index { get; }
    private GuidHandle(int index);
    internal static GuidHandle FromIndex(int heapIndex);
    public static Handle op_Implicit(GuidHandle handle);
    public static GuidHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal int get_Index();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GuidHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(GuidHandle left, GuidHandle right);
    public static bool op_Inequality(GuidHandle left, GuidHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Handle : ValueType {
    private int _value;
    private byte _vType;
    public static ModuleDefinitionHandle ModuleDefinition;
    public static AssemblyDefinitionHandle AssemblyDefinition;
    internal int RowId { get; }
    internal int Offset { get; }
    internal UInt32 EntityHandleType { get; }
    internal UInt32 Type { get; }
    internal UInt32 EntityHandleValue { get; }
    internal UInt32 SpecificEntityHandleValue { get; }
    internal byte VType { get; }
    internal bool IsVirtual { get; }
    internal bool IsHeapHandle { get; }
    public HandleKind Kind { get; }
    public bool IsNil { get; }
    internal bool IsEntityOrUserStringHandle { get; }
    internal int Token { get; }
    internal Handle(byte vType, int value);
    private static Handle();
    internal static Handle FromVToken(UInt32 vToken);
    internal int get_RowId();
    internal int get_Offset();
    internal UInt32 get_EntityHandleType();
    internal UInt32 get_Type();
    internal UInt32 get_EntityHandleValue();
    internal UInt32 get_SpecificEntityHandleValue();
    internal byte get_VType();
    internal bool get_IsVirtual();
    internal bool get_IsHeapHandle();
    public HandleKind get_Kind();
    public bool get_IsNil();
    internal bool get_IsEntityOrUserStringHandle();
    internal int get_Token();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Handle other);
    public virtual int GetHashCode();
    public static bool op_Equality(Handle left, Handle right);
    public static bool op_Inequality(Handle left, Handle right);
    internal static int Compare(Handle left, Handle right);
}
public class System.Reflection.Metadata.HandleComparer : object {
    private static HandleComparer s_default;
    [NullableAttribute("1")]
public static HandleComparer Default { get; }
    private static HandleComparer();
    [NullableContextAttribute("1")]
public static HandleComparer get_Default();
    public sealed virtual bool Equals(Handle x, Handle y);
    public sealed virtual bool Equals(EntityHandle x, EntityHandle y);
    public sealed virtual int GetHashCode(Handle obj);
    public sealed virtual int GetHashCode(EntityHandle obj);
    public sealed virtual int Compare(Handle x, Handle y);
    public sealed virtual int Compare(EntityHandle x, EntityHandle y);
}
public enum System.Reflection.Metadata.HandleKind : Enum {
    public byte value__;
    public static HandleKind ModuleDefinition;
    public static HandleKind TypeReference;
    public static HandleKind TypeDefinition;
    public static HandleKind FieldDefinition;
    public static HandleKind MethodDefinition;
    public static HandleKind Parameter;
    public static HandleKind InterfaceImplementation;
    public static HandleKind MemberReference;
    public static HandleKind Constant;
    public static HandleKind CustomAttribute;
    public static HandleKind DeclarativeSecurityAttribute;
    public static HandleKind StandaloneSignature;
    public static HandleKind EventDefinition;
    public static HandleKind PropertyDefinition;
    public static HandleKind MethodImplementation;
    public static HandleKind ModuleReference;
    public static HandleKind TypeSpecification;
    public static HandleKind AssemblyDefinition;
    public static HandleKind AssemblyFile;
    public static HandleKind AssemblyReference;
    public static HandleKind ExportedType;
    public static HandleKind GenericParameter;
    public static HandleKind MethodSpecification;
    public static HandleKind GenericParameterConstraint;
    public static HandleKind ManifestResource;
    public static HandleKind Document;
    public static HandleKind MethodDebugInformation;
    public static HandleKind LocalScope;
    public static HandleKind LocalVariable;
    public static HandleKind LocalConstant;
    public static HandleKind ImportScope;
    public static HandleKind CustomDebugInformation;
    public static HandleKind NamespaceDefinition;
    public static HandleKind UserString;
    public static HandleKind String;
    public static HandleKind Blob;
    public static HandleKind Guid;
}
[ExtensionAttribute]
internal static class System.Reflection.Metadata.HandleKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsHeapHandle(HandleKind kind);
}
[NullableContextAttribute("1")]
public interface System.Reflection.Metadata.IConstructedTypeProvider`1 {
    public abstract virtual TType GetGenericInstantiation(TType genericType, ImmutableArray`1<TType> typeArguments);
    public abstract virtual TType GetArrayType(TType elementType, ArrayShape shape);
    public abstract virtual TType GetByReferenceType(TType elementType);
    public abstract virtual TType GetPointerType(TType elementType);
}
[NullableContextAttribute("1")]
public interface System.Reflection.Metadata.ICustomAttributeTypeProvider`1 {
    public abstract virtual TType GetSystemType();
    public abstract virtual bool IsSystemType(TType type);
    public abstract virtual TType GetTypeFromSerializedName(string name);
    public abstract virtual PrimitiveTypeCode GetUnderlyingEnumType(TType type);
}
public enum System.Reflection.Metadata.ILOpCode : Enum {
    public ushort value__;
    public static ILOpCode Nop;
    public static ILOpCode Break;
    public static ILOpCode Ldarg_0;
    public static ILOpCode Ldarg_1;
    public static ILOpCode Ldarg_2;
    public static ILOpCode Ldarg_3;
    public static ILOpCode Ldloc_0;
    public static ILOpCode Ldloc_1;
    public static ILOpCode Ldloc_2;
    public static ILOpCode Ldloc_3;
    public static ILOpCode Stloc_0;
    public static ILOpCode Stloc_1;
    public static ILOpCode Stloc_2;
    public static ILOpCode Stloc_3;
    public static ILOpCode Ldarg_s;
    public static ILOpCode Ldarga_s;
    public static ILOpCode Starg_s;
    public static ILOpCode Ldloc_s;
    public static ILOpCode Ldloca_s;
    public static ILOpCode Stloc_s;
    public static ILOpCode Ldnull;
    public static ILOpCode Ldc_i4_m1;
    public static ILOpCode Ldc_i4_0;
    public static ILOpCode Ldc_i4_1;
    public static ILOpCode Ldc_i4_2;
    public static ILOpCode Ldc_i4_3;
    public static ILOpCode Ldc_i4_4;
    public static ILOpCode Ldc_i4_5;
    public static ILOpCode Ldc_i4_6;
    public static ILOpCode Ldc_i4_7;
    public static ILOpCode Ldc_i4_8;
    public static ILOpCode Ldc_i4_s;
    public static ILOpCode Ldc_i4;
    public static ILOpCode Ldc_i8;
    public static ILOpCode Ldc_r4;
    public static ILOpCode Ldc_r8;
    public static ILOpCode Dup;
    public static ILOpCode Pop;
    public static ILOpCode Jmp;
    public static ILOpCode Call;
    public static ILOpCode Calli;
    public static ILOpCode Ret;
    public static ILOpCode Br_s;
    public static ILOpCode Brfalse_s;
    public static ILOpCode Brtrue_s;
    public static ILOpCode Beq_s;
    public static ILOpCode Bge_s;
    public static ILOpCode Bgt_s;
    public static ILOpCode Ble_s;
    public static ILOpCode Blt_s;
    public static ILOpCode Bne_un_s;
    public static ILOpCode Bge_un_s;
    public static ILOpCode Bgt_un_s;
    public static ILOpCode Ble_un_s;
    public static ILOpCode Blt_un_s;
    public static ILOpCode Br;
    public static ILOpCode Brfalse;
    public static ILOpCode Brtrue;
    public static ILOpCode Beq;
    public static ILOpCode Bge;
    public static ILOpCode Bgt;
    public static ILOpCode Ble;
    public static ILOpCode Blt;
    public static ILOpCode Bne_un;
    public static ILOpCode Bge_un;
    public static ILOpCode Bgt_un;
    public static ILOpCode Ble_un;
    public static ILOpCode Blt_un;
    public static ILOpCode Switch;
    public static ILOpCode Ldind_i1;
    public static ILOpCode Ldind_u1;
    public static ILOpCode Ldind_i2;
    public static ILOpCode Ldind_u2;
    public static ILOpCode Ldind_i4;
    public static ILOpCode Ldind_u4;
    public static ILOpCode Ldind_i8;
    public static ILOpCode Ldind_i;
    public static ILOpCode Ldind_r4;
    public static ILOpCode Ldind_r8;
    public static ILOpCode Ldind_ref;
    public static ILOpCode Stind_ref;
    public static ILOpCode Stind_i1;
    public static ILOpCode Stind_i2;
    public static ILOpCode Stind_i4;
    public static ILOpCode Stind_i8;
    public static ILOpCode Stind_r4;
    public static ILOpCode Stind_r8;
    public static ILOpCode Add;
    public static ILOpCode Sub;
    public static ILOpCode Mul;
    public static ILOpCode Div;
    public static ILOpCode Div_un;
    public static ILOpCode Rem;
    public static ILOpCode Rem_un;
    public static ILOpCode And;
    public static ILOpCode Or;
    public static ILOpCode Xor;
    public static ILOpCode Shl;
    public static ILOpCode Shr;
    public static ILOpCode Shr_un;
    public static ILOpCode Neg;
    public static ILOpCode Not;
    public static ILOpCode Conv_i1;
    public static ILOpCode Conv_i2;
    public static ILOpCode Conv_i4;
    public static ILOpCode Conv_i8;
    public static ILOpCode Conv_r4;
    public static ILOpCode Conv_r8;
    public static ILOpCode Conv_u4;
    public static ILOpCode Conv_u8;
    public static ILOpCode Callvirt;
    public static ILOpCode Cpobj;
    public static ILOpCode Ldobj;
    public static ILOpCode Ldstr;
    public static ILOpCode Newobj;
    public static ILOpCode Castclass;
    public static ILOpCode Isinst;
    public static ILOpCode Conv_r_un;
    public static ILOpCode Unbox;
    public static ILOpCode Throw;
    public static ILOpCode Ldfld;
    public static ILOpCode Ldflda;
    public static ILOpCode Stfld;
    public static ILOpCode Ldsfld;
    public static ILOpCode Ldsflda;
    public static ILOpCode Stsfld;
    public static ILOpCode Stobj;
    public static ILOpCode Conv_ovf_i1_un;
    public static ILOpCode Conv_ovf_i2_un;
    public static ILOpCode Conv_ovf_i4_un;
    public static ILOpCode Conv_ovf_i8_un;
    public static ILOpCode Conv_ovf_u1_un;
    public static ILOpCode Conv_ovf_u2_un;
    public static ILOpCode Conv_ovf_u4_un;
    public static ILOpCode Conv_ovf_u8_un;
    public static ILOpCode Conv_ovf_i_un;
    public static ILOpCode Conv_ovf_u_un;
    public static ILOpCode Box;
    public static ILOpCode Newarr;
    public static ILOpCode Ldlen;
    public static ILOpCode Ldelema;
    public static ILOpCode Ldelem_i1;
    public static ILOpCode Ldelem_u1;
    public static ILOpCode Ldelem_i2;
    public static ILOpCode Ldelem_u2;
    public static ILOpCode Ldelem_i4;
    public static ILOpCode Ldelem_u4;
    public static ILOpCode Ldelem_i8;
    public static ILOpCode Ldelem_i;
    public static ILOpCode Ldelem_r4;
    public static ILOpCode Ldelem_r8;
    public static ILOpCode Ldelem_ref;
    public static ILOpCode Stelem_i;
    public static ILOpCode Stelem_i1;
    public static ILOpCode Stelem_i2;
    public static ILOpCode Stelem_i4;
    public static ILOpCode Stelem_i8;
    public static ILOpCode Stelem_r4;
    public static ILOpCode Stelem_r8;
    public static ILOpCode Stelem_ref;
    public static ILOpCode Ldelem;
    public static ILOpCode Stelem;
    public static ILOpCode Unbox_any;
    public static ILOpCode Conv_ovf_i1;
    public static ILOpCode Conv_ovf_u1;
    public static ILOpCode Conv_ovf_i2;
    public static ILOpCode Conv_ovf_u2;
    public static ILOpCode Conv_ovf_i4;
    public static ILOpCode Conv_ovf_u4;
    public static ILOpCode Conv_ovf_i8;
    public static ILOpCode Conv_ovf_u8;
    public static ILOpCode Refanyval;
    public static ILOpCode Ckfinite;
    public static ILOpCode Mkrefany;
    public static ILOpCode Ldtoken;
    public static ILOpCode Conv_u2;
    public static ILOpCode Conv_u1;
    public static ILOpCode Conv_i;
    public static ILOpCode Conv_ovf_i;
    public static ILOpCode Conv_ovf_u;
    public static ILOpCode Add_ovf;
    public static ILOpCode Add_ovf_un;
    public static ILOpCode Mul_ovf;
    public static ILOpCode Mul_ovf_un;
    public static ILOpCode Sub_ovf;
    public static ILOpCode Sub_ovf_un;
    public static ILOpCode Endfinally;
    public static ILOpCode Leave;
    public static ILOpCode Leave_s;
    public static ILOpCode Stind_i;
    public static ILOpCode Conv_u;
    public static ILOpCode Arglist;
    public static ILOpCode Ceq;
    public static ILOpCode Cgt;
    public static ILOpCode Cgt_un;
    public static ILOpCode Clt;
    public static ILOpCode Clt_un;
    public static ILOpCode Ldftn;
    public static ILOpCode Ldvirtftn;
    public static ILOpCode Ldarg;
    public static ILOpCode Ldarga;
    public static ILOpCode Starg;
    public static ILOpCode Ldloc;
    public static ILOpCode Ldloca;
    public static ILOpCode Stloc;
    public static ILOpCode Localloc;
    public static ILOpCode Endfilter;
    public static ILOpCode Unaligned;
    public static ILOpCode Volatile;
    public static ILOpCode Tail;
    public static ILOpCode Initobj;
    public static ILOpCode Constrained;
    public static ILOpCode Cpblk;
    public static ILOpCode Initblk;
    public static ILOpCode Rethrow;
    public static ILOpCode Sizeof;
    public static ILOpCode Refanytype;
    public static ILOpCode Readonly;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.ILOpCodeExtensions : object {
    [ExtensionAttribute]
public static bool IsBranch(ILOpCode opCode);
    [ExtensionAttribute]
public static int GetBranchOperandSize(ILOpCode opCode);
    [ExtensionAttribute]
public static ILOpCode GetShortBranch(ILOpCode opCode);
    [ExtensionAttribute]
public static ILOpCode GetLongBranch(ILOpCode opCode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.ImageFormatLimitationException : Exception {
    public ImageFormatLimitationException(string message);
    public ImageFormatLimitationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ImageFormatLimitationException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ImportDefinition : ValueType {
    [CompilerGeneratedAttribute]
private ImportDefinitionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobHandle <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyReferenceHandle <TargetAssembly>k__BackingField;
    private Handle _typeOrNamespace;
    public ImportDefinitionKind Kind { get; }
    public BlobHandle Alias { get; }
    public AssemblyReferenceHandle TargetAssembly { get; }
    public BlobHandle TargetNamespace { get; }
    public EntityHandle TargetType { get; }
    internal ImportDefinition(ImportDefinitionKind kind, BlobHandle alias, AssemblyReferenceHandle assembly, Handle typeOrNamespace);
    [CompilerGeneratedAttribute]
public ImportDefinitionKind get_Kind();
    [CompilerGeneratedAttribute]
public BlobHandle get_Alias();
    [CompilerGeneratedAttribute]
public AssemblyReferenceHandle get_TargetAssembly();
    public BlobHandle get_TargetNamespace();
    public EntityHandle get_TargetType();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ImportDefinitionCollection : ValueType {
    private MemoryBlock _block;
    internal ImportDefinitionCollection(MemoryBlock block);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ImportDefinition> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ImportDefinition>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Reflection.Metadata.ImportDefinitionKind : Enum {
    public int value__;
    public static ImportDefinitionKind ImportNamespace;
    public static ImportDefinitionKind ImportAssemblyNamespace;
    public static ImportDefinitionKind ImportType;
    public static ImportDefinitionKind ImportXmlNamespace;
    public static ImportDefinitionKind ImportAssemblyReferenceAlias;
    public static ImportDefinitionKind AliasAssemblyReference;
    public static ImportDefinitionKind AliasNamespace;
    public static ImportDefinitionKind AliasAssemblyNamespace;
    public static ImportDefinitionKind AliasType;
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ImportScope : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ImportScopeHandle Handle { get; }
    public ImportScopeHandle Parent { get; }
    public BlobHandle ImportsBlob { get; }
    [NullableContextAttribute("1")]
internal ImportScope(MetadataReader reader, ImportScopeHandle handle);
    private ImportScopeHandle get_Handle();
    public ImportScopeHandle get_Parent();
    public BlobHandle get_ImportsBlob();
    public ImportDefinitionCollection GetImports();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ImportScopeCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal ImportScopeCollection(MetadataReader reader);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ImportScopeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ImportScopeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ImportScopeHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ImportScopeHandle(int rowId);
    internal static ImportScopeHandle FromRowId(int rowId);
    public static Handle op_Implicit(ImportScopeHandle handle);
    public static EntityHandle op_Implicit(ImportScopeHandle handle);
    public static ImportScopeHandle op_Explicit(Handle handle);
    public static ImportScopeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ImportScopeHandle left, ImportScopeHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImportScopeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ImportScopeHandle left, ImportScopeHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.InterfaceImplementation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private InterfaceImplementationHandle Handle { get; }
    public EntityHandle Interface { get; }
    [NullableContextAttribute("1")]
internal InterfaceImplementation(MetadataReader reader, InterfaceImplementationHandle handle);
    private InterfaceImplementationHandle get_Handle();
    public EntityHandle get_Interface();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.InterfaceImplementationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal InterfaceImplementationHandle(int rowId);
    internal static InterfaceImplementationHandle FromRowId(int rowId);
    public static Handle op_Implicit(InterfaceImplementationHandle handle);
    public static EntityHandle op_Implicit(InterfaceImplementationHandle handle);
    public static InterfaceImplementationHandle op_Explicit(Handle handle);
    public static InterfaceImplementationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InterfaceImplementationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.InterfaceImplementationHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal InterfaceImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle implementingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<InterfaceImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.InterfaceImplementationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
public interface System.Reflection.Metadata.ISignatureTypeProvider`2 {
    public abstract virtual TType GetFunctionPointerType(MethodSignature`1<TType> signature);
    public abstract virtual TType GetGenericMethodParameter(TGenericContext genericContext, int index);
    public abstract virtual TType GetGenericTypeParameter(TGenericContext genericContext, int index);
    public abstract virtual TType GetModifiedType(TType modifier, TType unmodifiedType, bool isRequired);
    public abstract virtual TType GetPinnedType(TType elementType);
    public abstract virtual TType GetTypeFromSpecification(MetadataReader reader, TGenericContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
}
[NullableContextAttribute("1")]
public interface System.Reflection.Metadata.ISimpleTypeProvider`1 {
    public abstract virtual TType GetPrimitiveType(PrimitiveTypeCode typeCode);
    public abstract virtual TType GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public abstract virtual TType GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
}
[NullableContextAttribute("1")]
public interface System.Reflection.Metadata.ISZArrayTypeProvider`1 {
    public abstract virtual TType GetSZArrayType(TType elementType);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalConstant : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private LocalConstantHandle Handle { get; }
    public StringHandle Name { get; }
    public BlobHandle Signature { get; }
    [NullableContextAttribute("1")]
internal LocalConstant(MetadataReader reader, LocalConstantHandle handle);
    private LocalConstantHandle get_Handle();
    public StringHandle get_Name();
    public BlobHandle get_Signature();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalConstantHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private LocalConstantHandle(int rowId);
    internal static LocalConstantHandle FromRowId(int rowId);
    public static Handle op_Implicit(LocalConstantHandle handle);
    public static EntityHandle op_Implicit(LocalConstantHandle handle);
    public static LocalConstantHandle op_Explicit(Handle handle);
    public static LocalConstantHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(LocalConstantHandle left, LocalConstantHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalConstantHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(LocalConstantHandle left, LocalConstantHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalConstantHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal LocalConstantHandleCollection(MetadataReader reader, LocalScopeHandle scope);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<LocalConstantHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalConstantHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalScope : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private LocalScopeHandle Handle { get; }
    public MethodDefinitionHandle Method { get; }
    public ImportScopeHandle ImportScope { get; }
    public int StartOffset { get; }
    public int Length { get; }
    public int EndOffset { get; }
    [NullableContextAttribute("1")]
internal LocalScope(MetadataReader reader, LocalScopeHandle handle);
    private LocalScopeHandle get_Handle();
    public MethodDefinitionHandle get_Method();
    public ImportScopeHandle get_ImportScope();
    public int get_StartOffset();
    public int get_Length();
    public int get_EndOffset();
    public LocalVariableHandleCollection GetLocalVariables();
    public LocalConstantHandleCollection GetLocalConstants();
    public ChildrenEnumerator GetChildren();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalScopeHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private LocalScopeHandle(int rowId);
    internal static LocalScopeHandle FromRowId(int rowId);
    public static Handle op_Implicit(LocalScopeHandle handle);
    public static EntityHandle op_Implicit(LocalScopeHandle handle);
    public static LocalScopeHandle op_Explicit(Handle handle);
    public static LocalScopeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(LocalScopeHandle left, LocalScopeHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalScopeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(LocalScopeHandle left, LocalScopeHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalScopeHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal LocalScopeHandleCollection(MetadataReader reader, int methodDefinitionRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<LocalScopeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalScopeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalVariable : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private LocalVariableHandle Handle { get; }
    public LocalVariableAttributes Attributes { get; }
    public int Index { get; }
    public StringHandle Name { get; }
    [NullableContextAttribute("1")]
internal LocalVariable(MetadataReader reader, LocalVariableHandle handle);
    private LocalVariableHandle get_Handle();
    public LocalVariableAttributes get_Attributes();
    public int get_Index();
    public StringHandle get_Name();
}
[FlagsAttribute]
public enum System.Reflection.Metadata.LocalVariableAttributes : Enum {
    public int value__;
    public static LocalVariableAttributes None;
    public static LocalVariableAttributes DebuggerHidden;
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalVariableHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private LocalVariableHandle(int rowId);
    internal static LocalVariableHandle FromRowId(int rowId);
    public static Handle op_Implicit(LocalVariableHandle handle);
    public static EntityHandle op_Implicit(LocalVariableHandle handle);
    public static LocalVariableHandle op_Explicit(Handle handle);
    public static LocalVariableHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(LocalVariableHandle left, LocalVariableHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalVariableHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(LocalVariableHandle left, LocalVariableHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.LocalVariableHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal LocalVariableHandleCollection(MetadataReader reader, LocalScopeHandle scope);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<LocalVariableHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalVariableHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ManifestResource : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ManifestResourceHandle Handle { get; }
    public long Offset { get; }
    public ManifestResourceAttributes Attributes { get; }
    public StringHandle Name { get; }
    public EntityHandle Implementation { get; }
    [NullableContextAttribute("1")]
internal ManifestResource(MetadataReader reader, ManifestResourceHandle handle);
    private ManifestResourceHandle get_Handle();
    public long get_Offset();
    public ManifestResourceAttributes get_Attributes();
    public StringHandle get_Name();
    public EntityHandle get_Implementation();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ManifestResourceHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ManifestResourceHandle(int rowId);
    internal static ManifestResourceHandle FromRowId(int rowId);
    public static Handle op_Implicit(ManifestResourceHandle handle);
    public static EntityHandle op_Implicit(ManifestResourceHandle handle);
    public static ManifestResourceHandle op_Explicit(Handle handle);
    public static ManifestResourceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ManifestResourceHandle left, ManifestResourceHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ManifestResourceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ManifestResourceHandle left, ManifestResourceHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ManifestResourceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal ManifestResourceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ManifestResourceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ManifestResourceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MemberReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private MemberRefTreatment Treatment { get; }
    private MemberReferenceHandle Handle { get; }
    public EntityHandle Parent { get; }
    public StringHandle Name { get; }
    public BlobHandle Signature { get; }
    internal MemberReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private MemberRefTreatment get_Treatment();
    private MemberReferenceHandle get_Handle();
    public EntityHandle get_Parent();
    public StringHandle get_Name();
    public BlobHandle get_Signature();
    public TType DecodeFieldSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public MethodSignature`1<TType> DecodeMethodSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public MemberReferenceKind GetKind();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private EntityHandle GetProjectedParent();
    private StringHandle GetProjectedName();
    private BlobHandle GetProjectedSignature();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MemberReferenceHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MemberReferenceHandle(int rowId);
    internal static MemberReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(MemberReferenceHandle handle);
    public static EntityHandle op_Implicit(MemberReferenceHandle handle);
    public static MemberReferenceHandle op_Explicit(Handle handle);
    public static MemberReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MemberReferenceHandle left, MemberReferenceHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MemberReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MemberReferenceHandle left, MemberReferenceHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MemberReferenceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal MemberReferenceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MemberReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MemberReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Reflection.Metadata.MemberReferenceKind : Enum {
    public int value__;
    public static MemberReferenceKind Method;
    public static MemberReferenceKind Field;
}
public enum System.Reflection.Metadata.MetadataKind : Enum {
    public int value__;
    public static MetadataKind Ecma335;
    public static MetadataKind WindowsMetadata;
    public static MetadataKind ManagedWindowsMetadata;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.MetadataReader : object {
    internal NamespaceCache NamespaceCache;
    internal MemoryBlock Block;
    internal int WinMDMscorlibRef;
    private object _memoryOwnerObj;
    private MetadataReaderOptions _options;
    private Dictionary`2<TypeDefinitionHandle, ImmutableArray`1<TypeDefinitionHandle>> _lazyNestedTypesMap;
    private string _versionString;
    private MetadataKind _metadataKind;
    private MetadataStreamKind _metadataStreamKind;
    private DebugMetadataHeader _debugMetadataHeader;
    internal StringHeap StringHeap;
    internal BlobHeap BlobHeap;
    internal GuidHeap GuidHeap;
    internal UserStringHeap UserStringHeap;
    internal bool IsMinimalDelta;
    private TableMask _sortedTables;
    internal Int32[] TableRowCounts;
    internal ModuleTableReader ModuleTable;
    internal TypeRefTableReader TypeRefTable;
    internal TypeDefTableReader TypeDefTable;
    internal FieldPtrTableReader FieldPtrTable;
    internal FieldTableReader FieldTable;
    internal MethodPtrTableReader MethodPtrTable;
    internal MethodTableReader MethodDefTable;
    internal ParamPtrTableReader ParamPtrTable;
    internal ParamTableReader ParamTable;
    internal InterfaceImplTableReader InterfaceImplTable;
    internal MemberRefTableReader MemberRefTable;
    internal ConstantTableReader ConstantTable;
    internal CustomAttributeTableReader CustomAttributeTable;
    internal FieldMarshalTableReader FieldMarshalTable;
    internal DeclSecurityTableReader DeclSecurityTable;
    internal ClassLayoutTableReader ClassLayoutTable;
    internal FieldLayoutTableReader FieldLayoutTable;
    internal StandAloneSigTableReader StandAloneSigTable;
    internal EventMapTableReader EventMapTable;
    internal EventPtrTableReader EventPtrTable;
    internal EventTableReader EventTable;
    internal PropertyMapTableReader PropertyMapTable;
    internal PropertyPtrTableReader PropertyPtrTable;
    internal PropertyTableReader PropertyTable;
    internal MethodSemanticsTableReader MethodSemanticsTable;
    internal MethodImplTableReader MethodImplTable;
    internal ModuleRefTableReader ModuleRefTable;
    internal TypeSpecTableReader TypeSpecTable;
    internal ImplMapTableReader ImplMapTable;
    internal FieldRVATableReader FieldRvaTable;
    internal EnCLogTableReader EncLogTable;
    internal EnCMapTableReader EncMapTable;
    internal AssemblyTableReader AssemblyTable;
    internal AssemblyProcessorTableReader AssemblyProcessorTable;
    internal AssemblyOSTableReader AssemblyOSTable;
    internal AssemblyRefTableReader AssemblyRefTable;
    internal AssemblyRefProcessorTableReader AssemblyRefProcessorTable;
    internal AssemblyRefOSTableReader AssemblyRefOSTable;
    internal FileTableReader FileTable;
    internal ExportedTypeTableReader ExportedTypeTable;
    internal ManifestResourceTableReader ManifestResourceTable;
    internal NestedClassTableReader NestedClassTable;
    internal GenericParamTableReader GenericParamTable;
    internal MethodSpecTableReader MethodSpecTable;
    internal GenericParamConstraintTableReader GenericParamConstraintTable;
    internal DocumentTableReader DocumentTable;
    internal MethodDebugInformationTableReader MethodDebugInformationTable;
    internal LocalScopeTableReader LocalScopeTable;
    internal LocalVariableTableReader LocalVariableTable;
    internal LocalConstantTableReader LocalConstantTable;
    internal ImportScopeTableReader ImportScopeTable;
    internal StateMachineMethodTableReader StateMachineMethodTable;
    internal CustomDebugInformationTableReader CustomDebugInformationTable;
    [CompilerGeneratedAttribute]
private MetadataStringDecoder <UTF8Decoder>k__BackingField;
    internal static string ClrPrefix;
    internal static Byte[] WinRTPrefix;
    private static String[] s_projectedTypeNames;
    private static ProjectionInfo[] s_projectionInfos;
    internal bool UseFieldPtrTable { get; }
    internal bool UseMethodPtrTable { get; }
    internal bool UseParamPtrTable { get; }
    internal bool UseEventPtrTable { get; }
    internal bool UsePropertyPtrTable { get; }
    [NullableAttribute("0")]
public Byte* MetadataPointer { get; }
    public int MetadataLength { get; }
    public MetadataReaderOptions Options { get; }
    public string MetadataVersion { get; }
    [NullableAttribute("2")]
public DebugMetadataHeader DebugMetadataHeader { get; }
    public MetadataKind MetadataKind { get; }
    public MetadataStringComparer StringComparer { get; }
    public MetadataStringDecoder UTF8Decoder { get; }
    public bool IsAssembly { get; }
    public AssemblyReferenceHandleCollection AssemblyReferences { get; }
    public TypeDefinitionHandleCollection TypeDefinitions { get; }
    public TypeReferenceHandleCollection TypeReferences { get; }
    public CustomAttributeHandleCollection CustomAttributes { get; }
    public DeclarativeSecurityAttributeHandleCollection DeclarativeSecurityAttributes { get; }
    public MemberReferenceHandleCollection MemberReferences { get; }
    public ManifestResourceHandleCollection ManifestResources { get; }
    public AssemblyFileHandleCollection AssemblyFiles { get; }
    public ExportedTypeHandleCollection ExportedTypes { get; }
    public MethodDefinitionHandleCollection MethodDefinitions { get; }
    public FieldDefinitionHandleCollection FieldDefinitions { get; }
    public EventDefinitionHandleCollection EventDefinitions { get; }
    public PropertyDefinitionHandleCollection PropertyDefinitions { get; }
    public DocumentHandleCollection Documents { get; }
    public MethodDebugInformationHandleCollection MethodDebugInformation { get; }
    public LocalScopeHandleCollection LocalScopes { get; }
    public LocalVariableHandleCollection LocalVariables { get; }
    public LocalConstantHandleCollection LocalConstants { get; }
    public ImportScopeCollection ImportScopes { get; }
    public CustomDebugInformationHandleCollection CustomDebugInformation { get; }
    [NullableContextAttribute("0")]
public MetadataReader(Byte* metadata, int length);
    [NullableContextAttribute("0")]
public MetadataReader(Byte* metadata, int length, MetadataReaderOptions options);
    [NullableContextAttribute("0")]
public MetadataReader(Byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
    [NullableContextAttribute("2")]
internal MetadataReader(Byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder, object memoryOwner);
    private static MetadataReader();
    internal AssemblyName GetAssemblyName(StringHandle nameHandle, Version version, StringHandle cultureHandle, BlobHandle publicKeyOrTokenHandle, AssemblyHashAlgorithm assemblyHashAlgorithm, AssemblyFlags flags);
    public static AssemblyName GetAssemblyName(string assemblyFile);
    private static AssemblyNameFlags GetAssemblyNameFlags(AssemblyFlags flags);
    private static AssemblyContentType GetContentTypeFromAssemblyFlags(AssemblyFlags flags);
    private void ReadMetadataHeader(BlobReader& memReader, String& versionString);
    private MetadataKind GetMetadataKind(string versionString);
    private static StreamHeader[] ReadStreamHeaders(BlobReader& memReader);
    private void InitializeStreamReaders(MemoryBlock& metadataRoot, StreamHeader[] streamHeaders, MetadataStreamKind& metadataStreamKind, MemoryBlock& metadataTableStream, MemoryBlock& standalonePdbStream);
    private void ReadMetadataTableHeader(BlobReader& reader, HeapSizes& heapSizes, Int32[]& metadataTableRowCounts, TableMask& sortedTables);
    private static Int32[] ReadMetadataTableRowCounts(BlobReader& memReader, ulong presentTableMask);
    internal static void ReadStandalonePortablePdbStream(MemoryBlock pdbStreamBlock, int pdbStreamOffset, DebugMetadataHeader& debugMetadataHeader, Int32[]& externalTableRowCounts);
    private int GetReferenceSize(Int32[] rowCounts, TableIndex index);
    private void InitializeTableReaders(MemoryBlock metadataTablesMemoryBlock, HeapSizes heapSizes, Int32[] rowCounts, Int32[] externalRowCountsOpt);
    private static Int32[] CombineRowCounts(Int32[] local, Int32[] external, TableIndex firstLocalTableIndex);
    private int ComputeCodedTokenSize(int largeRowSize, Int32[] rowCounts, TableMask tablesReferenced);
    private bool IsDeclaredSorted(TableMask index);
    internal bool get_UseFieldPtrTable();
    internal bool get_UseMethodPtrTable();
    internal bool get_UseParamPtrTable();
    internal bool get_UseEventPtrTable();
    internal bool get_UsePropertyPtrTable();
    internal void GetFieldRange(TypeDefinitionHandle typeDef, Int32& firstFieldRowId, Int32& lastFieldRowId);
    internal void GetMethodRange(TypeDefinitionHandle typeDef, Int32& firstMethodRowId, Int32& lastMethodRowId);
    internal void GetEventRange(TypeDefinitionHandle typeDef, Int32& firstEventRowId, Int32& lastEventRowId);
    internal void GetPropertyRange(TypeDefinitionHandle typeDef, Int32& firstPropertyRowId, Int32& lastPropertyRowId);
    internal void GetParameterRange(MethodDefinitionHandle methodDef, Int32& firstParamRowId, Int32& lastParamRowId);
    internal void GetLocalVariableRange(LocalScopeHandle scope, Int32& firstVariableRowId, Int32& lastVariableRowId);
    internal void GetLocalConstantRange(LocalScopeHandle scope, Int32& firstConstantRowId, Int32& lastConstantRowId);
    [NullableContextAttribute("0")]
public Byte* get_MetadataPointer();
    public int get_MetadataLength();
    public MetadataReaderOptions get_Options();
    public string get_MetadataVersion();
    [NullableContextAttribute("2")]
public DebugMetadataHeader get_DebugMetadataHeader();
    public MetadataKind get_MetadataKind();
    public MetadataStringComparer get_StringComparer();
    [CompilerGeneratedAttribute]
public MetadataStringDecoder get_UTF8Decoder();
    public bool get_IsAssembly();
    public AssemblyReferenceHandleCollection get_AssemblyReferences();
    public TypeDefinitionHandleCollection get_TypeDefinitions();
    public TypeReferenceHandleCollection get_TypeReferences();
    public CustomAttributeHandleCollection get_CustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection get_DeclarativeSecurityAttributes();
    public MemberReferenceHandleCollection get_MemberReferences();
    public ManifestResourceHandleCollection get_ManifestResources();
    public AssemblyFileHandleCollection get_AssemblyFiles();
    public ExportedTypeHandleCollection get_ExportedTypes();
    public MethodDefinitionHandleCollection get_MethodDefinitions();
    public FieldDefinitionHandleCollection get_FieldDefinitions();
    public EventDefinitionHandleCollection get_EventDefinitions();
    public PropertyDefinitionHandleCollection get_PropertyDefinitions();
    public DocumentHandleCollection get_Documents();
    public MethodDebugInformationHandleCollection get_MethodDebugInformation();
    public LocalScopeHandleCollection get_LocalScopes();
    public LocalVariableHandleCollection get_LocalVariables();
    public LocalConstantHandleCollection get_LocalConstants();
    public ImportScopeCollection get_ImportScopes();
    public CustomDebugInformationHandleCollection get_CustomDebugInformation();
    public AssemblyDefinition GetAssemblyDefinition();
    public string GetString(StringHandle handle);
    public string GetString(NamespaceDefinitionHandle handle);
    public Byte[] GetBlobBytes(BlobHandle handle);
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> GetBlobContent(BlobHandle handle);
    public BlobReader GetBlobReader(BlobHandle handle);
    public BlobReader GetBlobReader(StringHandle handle);
    public string GetUserString(UserStringHandle handle);
    public Guid GetGuid(GuidHandle handle);
    public ModuleDefinition GetModuleDefinition();
    public AssemblyReference GetAssemblyReference(AssemblyReferenceHandle handle);
    public TypeDefinition GetTypeDefinition(TypeDefinitionHandle handle);
    public NamespaceDefinition GetNamespaceDefinitionRoot();
    public NamespaceDefinition GetNamespaceDefinition(NamespaceDefinitionHandle handle);
    private UInt32 GetTypeDefTreatmentAndRowId(TypeDefinitionHandle handle);
    public TypeReference GetTypeReference(TypeReferenceHandle handle);
    private UInt32 GetTypeRefTreatmentAndRowId(TypeReferenceHandle handle);
    public ExportedType GetExportedType(ExportedTypeHandle handle);
    public CustomAttributeHandleCollection GetCustomAttributes(EntityHandle handle);
    public CustomAttribute GetCustomAttribute(CustomAttributeHandle handle);
    private UInt32 GetCustomAttributeTreatmentAndRowId(CustomAttributeHandle handle);
    public DeclarativeSecurityAttribute GetDeclarativeSecurityAttribute(DeclarativeSecurityAttributeHandle handle);
    public Constant GetConstant(ConstantHandle handle);
    public MethodDefinition GetMethodDefinition(MethodDefinitionHandle handle);
    private UInt32 GetMethodDefTreatmentAndRowId(MethodDefinitionHandle handle);
    public FieldDefinition GetFieldDefinition(FieldDefinitionHandle handle);
    private UInt32 GetFieldDefTreatmentAndRowId(FieldDefinitionHandle handle);
    public PropertyDefinition GetPropertyDefinition(PropertyDefinitionHandle handle);
    public EventDefinition GetEventDefinition(EventDefinitionHandle handle);
    public MethodImplementation GetMethodImplementation(MethodImplementationHandle handle);
    public MemberReference GetMemberReference(MemberReferenceHandle handle);
    private UInt32 GetMemberRefTreatmentAndRowId(MemberReferenceHandle handle);
    public MethodSpecification GetMethodSpecification(MethodSpecificationHandle handle);
    public Parameter GetParameter(ParameterHandle handle);
    public GenericParameter GetGenericParameter(GenericParameterHandle handle);
    public GenericParameterConstraint GetGenericParameterConstraint(GenericParameterConstraintHandle handle);
    public ManifestResource GetManifestResource(ManifestResourceHandle handle);
    public AssemblyFile GetAssemblyFile(AssemblyFileHandle handle);
    public StandaloneSignature GetStandaloneSignature(StandaloneSignatureHandle handle);
    public TypeSpecification GetTypeSpecification(TypeSpecificationHandle handle);
    public ModuleReference GetModuleReference(ModuleReferenceHandle handle);
    public InterfaceImplementation GetInterfaceImplementation(InterfaceImplementationHandle handle);
    internal TypeDefinitionHandle GetDeclaringType(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle GetDeclaringType(FieldDefinitionHandle fieldDef);
    public string GetString(DocumentNameBlobHandle handle);
    public Document GetDocument(DocumentHandle handle);
    public MethodDebugInformation GetMethodDebugInformation(MethodDebugInformationHandle handle);
    public MethodDebugInformation GetMethodDebugInformation(MethodDefinitionHandle handle);
    public LocalScope GetLocalScope(LocalScopeHandle handle);
    public LocalVariable GetLocalVariable(LocalVariableHandle handle);
    public LocalConstant GetLocalConstant(LocalConstantHandle handle);
    public ImportScope GetImportScope(ImportScopeHandle handle);
    public CustomDebugInformation GetCustomDebugInformation(CustomDebugInformationHandle handle);
    public CustomDebugInformationHandleCollection GetCustomDebugInformation(EntityHandle handle);
    public LocalScopeHandleCollection GetLocalScopes(MethodDefinitionHandle handle);
    public LocalScopeHandleCollection GetLocalScopes(MethodDebugInformationHandle handle);
    private void InitializeNestedTypesMap();
    [NullableContextAttribute("0")]
internal ImmutableArray`1<TypeDefinitionHandle> GetNestedTypes(TypeDefinitionHandle typeDef);
    private TypeDefTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinitionHandle typeDef);
    private int GetProjectionIndexForTypeReference(TypeReferenceHandle typeRef, Boolean& isIDisposable);
    internal static AssemblyReferenceHandle GetProjectedAssemblyRef(int projectionIndex);
    internal static StringHandle GetProjectedName(int projectionIndex);
    internal static StringHandle GetProjectedNamespace(int projectionIndex);
    internal static TypeRefSignatureTreatment GetProjectedSignatureTreatment(int projectionIndex);
    private static void InitializeProjectedTypes();
    internal static String[] GetProjectedTypeNames();
    private static UInt32 TreatmentAndRowId(byte treatment, int rowId);
    internal UInt32 CalculateTypeDefTreatmentAndRowId(TypeDefinitionHandle handle);
    private bool IsClrImplementationType(TypeDefinitionHandle typeDef);
    internal UInt32 CalculateTypeRefTreatmentAndRowId(TypeReferenceHandle handle);
    private TypeRefTreatment GetSpecialTypeRefTreatment(TypeReferenceHandle handle);
    private bool IsSystemAttribute(TypeReferenceHandle handle);
    private bool NeedsWinRTPrefix(TypeAttributes flags, EntityHandle extends);
    private UInt32 CalculateMethodDefTreatmentAndRowId(MethodDefinitionHandle methodDef);
    private MethodDefTreatment GetMethodTreatmentFromCustomAttributes(MethodDefinitionHandle methodDef);
    private UInt32 CalculateFieldDefTreatmentAndRowId(FieldDefinitionHandle handle);
    private UInt32 CalculateMemberRefTreatmentAndRowId(MemberReferenceHandle handle);
    private bool ImplementsRedirectedInterface(MemberReferenceHandle memberRef, Boolean& isIDisposable);
    private int FindMscorlibAssemblyRefNoProjection();
    internal CustomAttributeValueTreatment CalculateCustomAttributeValueTreatment(CustomAttributeHandle handle);
    private bool IsWindowsAttributeUsageAttribute(EntityHandle targetType, CustomAttributeHandle attributeHandle);
    private bool HasAttribute(EntityHandle token, string asciiNamespaceName, string asciiTypeName);
    private bool GetAttributeTypeNameRaw(CustomAttributeHandle caHandle, StringHandle& namespaceName, StringHandle& typeName);
    private EntityHandle GetAttributeTypeRaw(CustomAttributeHandle handle);
}
[FlagsAttribute]
public enum System.Reflection.Metadata.MetadataReaderOptions : Enum {
    public int value__;
    public static MetadataReaderOptions None;
    public static MetadataReaderOptions Default;
    public static MetadataReaderOptions ApplyWindowsRuntimeProjections;
}
public class System.Reflection.Metadata.MetadataReaderProvider : object {
    private MemoryBlockProvider _blockProviderOpt;
    private AbstractMemoryBlock _lazyMetadataBlock;
    private MetadataReader _lazyMetadataReader;
    private object _metadataReaderGuard;
    [NullableContextAttribute("1")]
internal MetadataReaderProvider(AbstractMemoryBlock metadataBlock);
    private MetadataReaderProvider(MemoryBlockProvider blockProvider);
    public static MetadataReaderProvider FromPortablePdbImage(Byte* start, int size);
    public static MetadataReaderProvider FromMetadataImage(Byte* start, int size);
    public static MetadataReaderProvider FromPortablePdbImage(ImmutableArray`1<byte> image);
    public static MetadataReaderProvider FromMetadataImage(ImmutableArray`1<byte> image);
    [NullableContextAttribute("1")]
public static MetadataReaderProvider FromPortablePdbStream(Stream stream, MetadataStreamOptions options, int size);
    [NullableContextAttribute("1")]
public static MetadataReaderProvider FromMetadataStream(Stream stream, MetadataStreamOptions options, int size);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public MetadataReader GetMetadataReader(MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
    private static bool CanReuseReader(MetadataReader reader, MetadataReaderOptions options, MetadataStringDecoder utf8DecoderOpt);
    [NullableContextAttribute("1")]
internal AbstractMemoryBlock GetMetadataBlock();
}
[FlagsAttribute]
public enum System.Reflection.Metadata.MetadataStreamOptions : Enum {
    public int value__;
    public static MetadataStreamOptions Default;
    public static MetadataStreamOptions LeaveOpen;
    public static MetadataStreamOptions PrefetchMetadata;
}
[ExtensionAttribute]
internal static class System.Reflection.Metadata.MetadataStreamOptionsExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(MetadataStreamOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MetadataStringComparer : ValueType {
    private MetadataReader _reader;
    internal MetadataStringComparer(MetadataReader reader);
    public bool Equals(StringHandle handle, string value);
    public bool Equals(StringHandle handle, string value, bool ignoreCase);
    public bool Equals(NamespaceDefinitionHandle handle, string value);
    public bool Equals(NamespaceDefinitionHandle handle, string value, bool ignoreCase);
    public bool Equals(DocumentNameBlobHandle handle, string value);
    public bool Equals(DocumentNameBlobHandle handle, string value, bool ignoreCase);
    public bool StartsWith(StringHandle handle, string value);
    public bool StartsWith(StringHandle handle, string value, bool ignoreCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Metadata.MetadataStringDecoder : object {
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static MetadataStringDecoder <DefaultUTF8>k__BackingField;
    public Encoding Encoding { get; }
    public static MetadataStringDecoder DefaultUTF8 { get; }
    public MetadataStringDecoder(Encoding encoding);
    private static MetadataStringDecoder();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public static MetadataStringDecoder get_DefaultUTF8();
    [NullableContextAttribute("0")]
public virtual string GetString(Byte* bytes, int byteCount);
}
public class System.Reflection.Metadata.MethodBodyBlock : object {
    private MemoryBlock _il;
    private int _size;
    private ushort _maxStack;
    private bool _localVariablesInitialized;
    private StandaloneSignatureHandle _localSignature;
    private ImmutableArray`1<ExceptionRegion> _exceptionRegions;
    public int Size { get; }
    public int MaxStack { get; }
    public bool LocalVariablesInitialized { get; }
    public StandaloneSignatureHandle LocalSignature { get; }
    public ImmutableArray`1<ExceptionRegion> ExceptionRegions { get; }
    private MethodBodyBlock(bool localVariablesInitialized, ushort maxStack, StandaloneSignatureHandle localSignatureHandle, MemoryBlock il, ImmutableArray`1<ExceptionRegion> exceptionRegions, int size);
    public int get_Size();
    public int get_MaxStack();
    public bool get_LocalVariablesInitialized();
    public StandaloneSignatureHandle get_LocalSignature();
    public ImmutableArray`1<ExceptionRegion> get_ExceptionRegions();
    [NullableContextAttribute("2")]
public Byte[] GetILBytes();
    public ImmutableArray`1<byte> GetILContent();
    public BlobReader GetILReader();
    [NullableContextAttribute("1")]
public static MethodBodyBlock Create(BlobReader reader);
    private static ImmutableArray`1<ExceptionRegion> ReadSmallExceptionHandlers(BlobReader& memReader, int count);
    private static ImmutableArray`1<ExceptionRegion> ReadFatExceptionHandlers(BlobReader& memReader, int count);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDebugInformation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private MethodDebugInformationHandle Handle { get; }
    public BlobHandle SequencePointsBlob { get; }
    public DocumentHandle Document { get; }
    public StandaloneSignatureHandle LocalSignature { get; }
    [NullableContextAttribute("1")]
internal MethodDebugInformation(MetadataReader reader, MethodDebugInformationHandle handle);
    private MethodDebugInformationHandle get_Handle();
    public BlobHandle get_SequencePointsBlob();
    public DocumentHandle get_Document();
    public StandaloneSignatureHandle get_LocalSignature();
    public SequencePointCollection GetSequencePoints();
    public MethodDefinitionHandle GetStateMachineKickoffMethod();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDebugInformationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodDebugInformationHandle(int rowId);
    internal static MethodDebugInformationHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodDebugInformationHandle handle);
    public static EntityHandle op_Implicit(MethodDebugInformationHandle handle);
    public static MethodDebugInformationHandle op_Explicit(Handle handle);
    public static MethodDebugInformationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodDebugInformationHandle left, MethodDebugInformationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodDebugInformationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodDebugInformationHandle left, MethodDebugInformationHandle right);
    public MethodDefinitionHandle ToDefinitionHandle();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDebugInformationHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal MethodDebugInformationHandleCollection(MetadataReader reader);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MethodDebugInformationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodDebugInformationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private MethodDefTreatment Treatment { get; }
    private MethodDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public BlobHandle Signature { get; }
    public int RelativeVirtualAddress { get; }
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes ImplAttributes { get; }
    internal MethodDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private MethodDefTreatment get_Treatment();
    private MethodDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public BlobHandle get_Signature();
    public MethodSignature`1<TType> DecodeSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public int get_RelativeVirtualAddress();
    public MethodAttributes get_Attributes();
    public MethodImplAttributes get_ImplAttributes();
    public TypeDefinitionHandle GetDeclaringType();
    public ParameterHandleCollection GetParameters();
    public GenericParameterHandleCollection GetGenericParameters();
    public MethodImport GetImport();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
    private StringHandle GetProjectedName();
    private MethodAttributes GetProjectedFlags();
    private MethodImplAttributes GetProjectedImplFlags();
    private BlobHandle GetProjectedSignature();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodDefinitionHandle(int rowId);
    internal static MethodDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodDefinitionHandle handle);
    public static EntityHandle op_Implicit(MethodDefinitionHandle handle);
    public static MethodDefinitionHandle op_Explicit(Handle handle);
    public static MethodDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodDefinitionHandle left, MethodDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodDefinitionHandle left, MethodDefinitionHandle right);
    public MethodDebugInformationHandle ToDebugInformationHandle();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal MethodDefinitionHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal MethodDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MethodDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodImplementation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private MethodImplementationHandle Handle { get; }
    public TypeDefinitionHandle Type { get; }
    public EntityHandle MethodBody { get; }
    public EntityHandle MethodDeclaration { get; }
    [NullableContextAttribute("1")]
internal MethodImplementation(MetadataReader reader, MethodImplementationHandle handle);
    private MethodImplementationHandle get_Handle();
    public TypeDefinitionHandle get_Type();
    public EntityHandle get_MethodBody();
    public EntityHandle get_MethodDeclaration();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodImplementationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodImplementationHandle(int rowId);
    internal static MethodImplementationHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodImplementationHandle handle);
    public static EntityHandle op_Implicit(MethodImplementationHandle handle);
    public static MethodImplementationHandle op_Explicit(Handle handle);
    public static MethodImplementationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodImplementationHandle left, MethodImplementationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodImplementationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodImplementationHandle left, MethodImplementationHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodImplementationHandleCollection : ValueType {
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal MethodImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MethodImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodImplementationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodImport : ValueType {
    private MethodImportAttributes _attributes;
    private StringHandle _name;
    private ModuleReferenceHandle _module;
    public MethodImportAttributes Attributes { get; }
    public StringHandle Name { get; }
    public ModuleReferenceHandle Module { get; }
    internal MethodImport(MethodImportAttributes attributes, StringHandle name, ModuleReferenceHandle module);
    public MethodImportAttributes get_Attributes();
    public StringHandle get_Name();
    public ModuleReferenceHandle get_Module();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodSignature`1 : ValueType {
    [CompilerGeneratedAttribute]
private SignatureHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private TType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequiredParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GenericParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TType> <ParameterTypes>k__BackingField;
    public SignatureHeader Header { get; }
    public TType ReturnType { get; }
    public int RequiredParameterCount { get; }
    public int GenericParameterCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TType> ParameterTypes { get; }
    public MethodSignature`1(SignatureHeader header, TType returnType, int requiredParameterCount, int genericParameterCount, ImmutableArray`1<TType> parameterTypes);
    [CompilerGeneratedAttribute]
public SignatureHeader get_Header();
    [CompilerGeneratedAttribute]
public TType get_ReturnType();
    [CompilerGeneratedAttribute]
public int get_RequiredParameterCount();
    [CompilerGeneratedAttribute]
public int get_GenericParameterCount();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TType> get_ParameterTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodSpecification : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private MethodSpecificationHandle Handle { get; }
    public EntityHandle Method { get; }
    public BlobHandle Signature { get; }
    internal MethodSpecification(MetadataReader reader, MethodSpecificationHandle handle);
    private MethodSpecificationHandle get_Handle();
    public EntityHandle get_Method();
    public BlobHandle get_Signature();
    public ImmutableArray`1<TType> DecodeSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.MethodSpecificationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodSpecificationHandle(int rowId);
    internal static MethodSpecificationHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodSpecificationHandle handle);
    public static EntityHandle op_Implicit(MethodSpecificationHandle handle);
    public static MethodSpecificationHandle op_Explicit(Handle handle);
    public static MethodSpecificationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodSpecificationHandle left, MethodSpecificationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodSpecificationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodSpecificationHandle left, MethodSpecificationHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ModuleDefinition : ValueType {
    private MetadataReader _reader;
    public int Generation { get; }
    public StringHandle Name { get; }
    public GuidHandle Mvid { get; }
    public GuidHandle GenerationId { get; }
    public GuidHandle BaseGenerationId { get; }
    [NullableContextAttribute("1")]
internal ModuleDefinition(MetadataReader reader);
    public int get_Generation();
    public StringHandle get_Name();
    public GuidHandle get_Mvid();
    public GuidHandle get_GenerationId();
    public GuidHandle get_BaseGenerationId();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ModuleDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal ModuleDefinitionHandle(int rowId);
    internal static ModuleDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(ModuleDefinitionHandle handle);
    public static EntityHandle op_Implicit(ModuleDefinitionHandle handle);
    public static ModuleDefinitionHandle op_Explicit(Handle handle);
    public static ModuleDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ModuleDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ModuleReference : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ModuleReferenceHandle Handle { get; }
    public StringHandle Name { get; }
    [NullableContextAttribute("1")]
internal ModuleReference(MetadataReader reader, ModuleReferenceHandle handle);
    private ModuleReferenceHandle get_Handle();
    public StringHandle get_Name();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ModuleReferenceHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ModuleReferenceHandle(int rowId);
    internal static ModuleReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(ModuleReferenceHandle handle);
    public static EntityHandle op_Implicit(ModuleReferenceHandle handle);
    public static ModuleReferenceHandle op_Explicit(Handle handle);
    public static ModuleReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ModuleReferenceHandle left, ModuleReferenceHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ModuleReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ModuleReferenceHandle left, ModuleReferenceHandle right);
}
public class System.Reflection.Metadata.NamespaceDefinition : ValueType {
    private NamespaceData _data;
    public StringHandle Name { get; }
    public NamespaceDefinitionHandle Parent { get; }
    public ImmutableArray`1<NamespaceDefinitionHandle> NamespaceDefinitions { get; }
    public ImmutableArray`1<TypeDefinitionHandle> TypeDefinitions { get; }
    public ImmutableArray`1<ExportedTypeHandle> ExportedTypes { get; }
    [NullableContextAttribute("1")]
internal NamespaceDefinition(NamespaceData data);
    public StringHandle get_Name();
    public NamespaceDefinitionHandle get_Parent();
    public ImmutableArray`1<NamespaceDefinitionHandle> get_NamespaceDefinitions();
    public ImmutableArray`1<TypeDefinitionHandle> get_TypeDefinitions();
    public ImmutableArray`1<ExportedTypeHandle> get_ExportedTypes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.NamespaceDefinitionHandle : ValueType {
    private UInt32 _value;
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    internal bool HasFullName { get; }
    private NamespaceDefinitionHandle(UInt32 value);
    internal static NamespaceDefinitionHandle FromFullNameOffset(int stringHeapOffset);
    internal static NamespaceDefinitionHandle FromVirtualIndex(UInt32 virtualIndex);
    public static Handle op_Implicit(NamespaceDefinitionHandle handle);
    public static NamespaceDefinitionHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal bool get_IsVirtual();
    internal int GetHeapOffset();
    internal bool get_HasFullName();
    internal StringHandle GetFullName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamespaceDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
    public static bool op_Inequality(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.Parameter : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ParameterHandle Handle { get; }
    public ParameterAttributes Attributes { get; }
    public int SequenceNumber { get; }
    public StringHandle Name { get; }
    [NullableContextAttribute("1")]
internal Parameter(MetadataReader reader, ParameterHandle handle);
    private ParameterHandle get_Handle();
    public ParameterAttributes get_Attributes();
    public int get_SequenceNumber();
    public StringHandle get_Name();
    public ConstantHandle GetDefaultValue();
    public BlobHandle GetMarshallingDescriptor();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ParameterHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ParameterHandle(int rowId);
    internal static ParameterHandle FromRowId(int rowId);
    public static Handle op_Implicit(ParameterHandle handle);
    public static EntityHandle op_Implicit(ParameterHandle handle);
    public static ParameterHandle op_Explicit(Handle handle);
    public static ParameterHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ParameterHandle left, ParameterHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ParameterHandle left, ParameterHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ParameterHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal ParameterHandleCollection(MetadataReader reader, MethodDefinitionHandle containingMethod);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ParameterHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Reflection.Metadata.PathUtilities : object {
    private static string s_platformSpecificDirectorySeparator;
    private static string PlatformSpecificDirectorySeparator { get; }
    private static string get_PlatformSpecificDirectorySeparator();
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
    internal static string CombinePathWithRelativePath(string root, string relativePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Reflection.Metadata.PEReaderExtensions : object {
    [ExtensionAttribute]
public static MethodBodyBlock GetMethodBody(PEReader peReader, int relativeVirtualAddress);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader, MetadataReaderOptions options);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.Metadata.PooledBlobBuilder : BlobBuilder {
    private static ObjectPool`1<PooledBlobBuilder> s_chunkPool;
    private PooledBlobBuilder(int size);
    private static PooledBlobBuilder();
    public static PooledBlobBuilder GetInstance();
    protected virtual BlobBuilder AllocateChunk(int minimalSize);
    protected virtual void FreeChunk();
    public void Free();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Reflection.Metadata.PortablePdbVersions : object {
    internal static string DefaultMetadataVersion;
    internal static ushort DefaultFormatVersion;
    internal static ushort MinFormatVersion;
    internal static ushort MinEmbeddedVersion;
    internal static ushort DefaultEmbeddedVersion;
    internal static ushort MinUnsupportedEmbeddedVersion;
    internal static UInt32 DebugDirectoryEmbeddedSignature;
    internal static ushort PortableCodeViewVersionMagic;
    internal static UInt32 DebugDirectoryEntryVersion(ushort portablePdbVersion);
    internal static UInt32 DebugDirectoryEmbeddedVersion(ushort portablePdbVersion);
    internal static string Format(ushort version);
}
public enum System.Reflection.Metadata.PrimitiveSerializationTypeCode : Enum {
    public byte value__;
    public static PrimitiveSerializationTypeCode Boolean;
    public static PrimitiveSerializationTypeCode Byte;
    public static PrimitiveSerializationTypeCode SByte;
    public static PrimitiveSerializationTypeCode Char;
    public static PrimitiveSerializationTypeCode Int16;
    public static PrimitiveSerializationTypeCode UInt16;
    public static PrimitiveSerializationTypeCode Int32;
    public static PrimitiveSerializationTypeCode UInt32;
    public static PrimitiveSerializationTypeCode Int64;
    public static PrimitiveSerializationTypeCode UInt64;
    public static PrimitiveSerializationTypeCode Single;
    public static PrimitiveSerializationTypeCode Double;
    public static PrimitiveSerializationTypeCode String;
}
public enum System.Reflection.Metadata.PrimitiveTypeCode : Enum {
    public byte value__;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode IntPtr;
    public static PrimitiveTypeCode UIntPtr;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode TypedReference;
    public static PrimitiveTypeCode Void;
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.PropertyAccessors : ValueType {
    private int _getterRowId;
    private int _setterRowId;
    private ImmutableArray`1<MethodDefinitionHandle> _others;
    public MethodDefinitionHandle Getter { get; }
    public MethodDefinitionHandle Setter { get; }
    public ImmutableArray`1<MethodDefinitionHandle> Others { get; }
    internal PropertyAccessors(int getterRowId, int setterRowId, ImmutableArray`1<MethodDefinitionHandle> others);
    public MethodDefinitionHandle get_Getter();
    public MethodDefinitionHandle get_Setter();
    public ImmutableArray`1<MethodDefinitionHandle> get_Others();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.PropertyDefinition : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private PropertyDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public PropertyAttributes Attributes { get; }
    public BlobHandle Signature { get; }
    internal PropertyDefinition(MetadataReader reader, PropertyDefinitionHandle handle);
    private PropertyDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public PropertyAttributes get_Attributes();
    public BlobHandle get_Signature();
    public MethodSignature`1<TType> DecodeSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public ConstantHandle GetDefaultValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public PropertyAccessors GetAccessors();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.PropertyDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private PropertyDefinitionHandle(int rowId);
    internal static PropertyDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(PropertyDefinitionHandle handle);
    public static EntityHandle op_Implicit(PropertyDefinitionHandle handle);
    public static PropertyDefinitionHandle op_Explicit(Handle handle);
    public static PropertyDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.PropertyDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    [NullableContextAttribute("1")]
internal PropertyDefinitionHandleCollection(MetadataReader reader);
    [NullableContextAttribute("1")]
internal PropertyDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PropertyDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.PropertyDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.ReservedBlob`1 : ValueType {
    [CompilerGeneratedAttribute]
private THandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private Blob <Content>k__BackingField;
    public THandle Handle { get; }
    public Blob Content { get; }
    internal ReservedBlob`1(THandle handle, Blob content);
    [CompilerGeneratedAttribute]
public THandle get_Handle();
    [CompilerGeneratedAttribute]
public Blob get_Content();
    public BlobWriter CreateWriter();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class System.Reflection.Metadata.SequencePoint : ValueType {
    public static int HiddenLine;
    [CompilerGeneratedAttribute]
private DocumentHandle <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    public DocumentHandle Document { get; }
    public int Offset { get; }
    public int StartLine { get; }
    public int EndLine { get; }
    public int StartColumn { get; }
    public int EndColumn { get; }
    public bool IsHidden { get; }
    internal SequencePoint(DocumentHandle document, int offset);
    internal SequencePoint(DocumentHandle document, int offset, int startLine, ushort startColumn, int endLine, ushort endColumn);
    [CompilerGeneratedAttribute]
public DocumentHandle get_Document();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SequencePoint other);
    public bool get_IsHidden();
    private string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.SequencePointCollection : ValueType {
    private MemoryBlock _block;
    private DocumentHandle _document;
    internal SequencePointCollection(MemoryBlock block, DocumentHandle document);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<SequencePoint> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.SequencePoint>.GetEnumerator();
}
public enum System.Reflection.Metadata.SerializationTypeCode : Enum {
    public byte value__;
    public static SerializationTypeCode Invalid;
    public static SerializationTypeCode Boolean;
    public static SerializationTypeCode Char;
    public static SerializationTypeCode SByte;
    public static SerializationTypeCode Byte;
    public static SerializationTypeCode Int16;
    public static SerializationTypeCode UInt16;
    public static SerializationTypeCode Int32;
    public static SerializationTypeCode UInt32;
    public static SerializationTypeCode Int64;
    public static SerializationTypeCode UInt64;
    public static SerializationTypeCode Single;
    public static SerializationTypeCode Double;
    public static SerializationTypeCode String;
    public static SerializationTypeCode SZArray;
    public static SerializationTypeCode Type;
    public static SerializationTypeCode TaggedObject;
    public static SerializationTypeCode Enum;
}
[FlagsAttribute]
public enum System.Reflection.Metadata.SignatureAttributes : Enum {
    public byte value__;
    public static SignatureAttributes None;
    public static SignatureAttributes Generic;
    public static SignatureAttributes Instance;
    public static SignatureAttributes ExplicitThis;
}
public enum System.Reflection.Metadata.SignatureCallingConvention : Enum {
    public byte value__;
    public static SignatureCallingConvention Default;
    public static SignatureCallingConvention CDecl;
    public static SignatureCallingConvention StdCall;
    public static SignatureCallingConvention ThisCall;
    public static SignatureCallingConvention FastCall;
    public static SignatureCallingConvention VarArgs;
    public static SignatureCallingConvention Unmanaged;
}
public class System.Reflection.Metadata.SignatureHeader : ValueType {
    private byte _rawValue;
    public static byte CallingConventionOrKindMask;
    public byte RawValue { get; }
    public SignatureCallingConvention CallingConvention { get; }
    public SignatureKind Kind { get; }
    public SignatureAttributes Attributes { get; }
    public bool HasExplicitThis { get; }
    public bool IsInstance { get; }
    public bool IsGeneric { get; }
    public SignatureHeader(byte rawValue);
    public SignatureHeader(SignatureKind kind, SignatureCallingConvention convention, SignatureAttributes attributes);
    public byte get_RawValue();
    public SignatureCallingConvention get_CallingConvention();
    public SignatureKind get_Kind();
    public SignatureAttributes get_Attributes();
    public bool get_HasExplicitThis();
    public bool get_IsInstance();
    public bool get_IsGeneric();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignatureHeader other);
    public virtual int GetHashCode();
    public static bool op_Equality(SignatureHeader left, SignatureHeader right);
    public static bool op_Inequality(SignatureHeader left, SignatureHeader right);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum System.Reflection.Metadata.SignatureKind : Enum {
    public byte value__;
    public static SignatureKind Method;
    public static SignatureKind Field;
    public static SignatureKind LocalVariables;
    public static SignatureKind Property;
    public static SignatureKind MethodSpecification;
}
public enum System.Reflection.Metadata.SignatureTypeCode : Enum {
    public byte value__;
    public static SignatureTypeCode Invalid;
    public static SignatureTypeCode Void;
    public static SignatureTypeCode Boolean;
    public static SignatureTypeCode Char;
    public static SignatureTypeCode SByte;
    public static SignatureTypeCode Byte;
    public static SignatureTypeCode Int16;
    public static SignatureTypeCode UInt16;
    public static SignatureTypeCode Int32;
    public static SignatureTypeCode UInt32;
    public static SignatureTypeCode Int64;
    public static SignatureTypeCode UInt64;
    public static SignatureTypeCode Single;
    public static SignatureTypeCode Double;
    public static SignatureTypeCode String;
    public static SignatureTypeCode Pointer;
    public static SignatureTypeCode ByReference;
    public static SignatureTypeCode GenericTypeParameter;
    public static SignatureTypeCode Array;
    public static SignatureTypeCode GenericTypeInstance;
    public static SignatureTypeCode TypedReference;
    public static SignatureTypeCode IntPtr;
    public static SignatureTypeCode UIntPtr;
    public static SignatureTypeCode FunctionPointer;
    public static SignatureTypeCode Object;
    public static SignatureTypeCode SZArray;
    public static SignatureTypeCode GenericMethodParameter;
    public static SignatureTypeCode RequiredModifier;
    public static SignatureTypeCode OptionalModifier;
    public static SignatureTypeCode TypeHandle;
    public static SignatureTypeCode Sentinel;
    public static SignatureTypeCode Pinned;
}
public enum System.Reflection.Metadata.SignatureTypeKind : Enum {
    public byte value__;
    public static SignatureTypeKind Unknown;
    public static SignatureTypeKind Class;
    public static SignatureTypeKind ValueType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.StandaloneSignature : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private StandaloneSignatureHandle Handle { get; }
    public BlobHandle Signature { get; }
    internal StandaloneSignature(MetadataReader reader, StandaloneSignatureHandle handle);
    private StandaloneSignatureHandle get_Handle();
    public BlobHandle get_Signature();
    public MethodSignature`1<TType> DecodeMethodSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public ImmutableArray`1<TType> DecodeLocalSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public CustomAttributeHandleCollection GetCustomAttributes();
    public StandaloneSignatureKind GetKind();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.StandaloneSignatureHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private StandaloneSignatureHandle(int rowId);
    internal static StandaloneSignatureHandle FromRowId(int rowId);
    public static Handle op_Implicit(StandaloneSignatureHandle handle);
    public static EntityHandle op_Implicit(StandaloneSignatureHandle handle);
    public static StandaloneSignatureHandle op_Explicit(Handle handle);
    public static StandaloneSignatureHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StandaloneSignatureHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
}
public enum System.Reflection.Metadata.StandaloneSignatureKind : Enum {
    public int value__;
    public static StandaloneSignatureKind Method;
    public static StandaloneSignatureKind LocalVariables;
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.StringHandle : ValueType {
    private UInt32 _value;
    internal UInt32 RawValue { get; }
    internal bool IsVirtual { get; }
    public bool IsNil { get; }
    internal StringKind StringKind { get; }
    private StringHandle(UInt32 value);
    internal static StringHandle FromOffset(int heapOffset);
    internal static StringHandle FromVirtualIndex(VirtualIndex virtualIndex);
    internal static StringHandle FromWriterVirtualIndex(int virtualIndex);
    internal StringHandle WithWinRTPrefix();
    internal StringHandle WithDotTermination();
    internal StringHandle SuffixRaw(int prefixByteLength);
    public static Handle op_Implicit(StringHandle handle);
    public static StringHandle op_Explicit(Handle handle);
    internal UInt32 get_RawValue();
    internal bool get_IsVirtual();
    public bool get_IsNil();
    internal int GetHeapOffset();
    internal VirtualIndex GetVirtualIndex();
    internal int GetWriterVirtualIndex();
    internal StringKind get_StringKind();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(StringHandle left, StringHandle right);
    public static bool op_Inequality(StringHandle left, StringHandle right);
}
internal static class System.Reflection.Metadata.StringUtils : object {
    internal static int IgnoreCaseMask(bool ignoreCase);
    internal static bool IsEqualAscii(int a, int b, int ignoreCaseMask);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private TypeDefTreatment Treatment { get; }
    private TypeDefinitionHandle Handle { get; }
    public TypeAttributes Attributes { get; }
    public bool IsNested { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    public NamespaceDefinitionHandle NamespaceDefinition { get; }
    public EntityHandle BaseType { get; }
    [NullableContextAttribute("1")]
internal TypeDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private TypeDefTreatment get_Treatment();
    private TypeDefinitionHandle get_Handle();
    public TypeAttributes get_Attributes();
    public bool get_IsNested();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    public NamespaceDefinitionHandle get_NamespaceDefinition();
    public EntityHandle get_BaseType();
    public TypeLayout GetLayout();
    public TypeDefinitionHandle GetDeclaringType();
    public GenericParameterHandleCollection GetGenericParameters();
    public MethodDefinitionHandleCollection GetMethods();
    public FieldDefinitionHandleCollection GetFields();
    public PropertyDefinitionHandleCollection GetProperties();
    public EventDefinitionHandleCollection GetEvents();
    public ImmutableArray`1<TypeDefinitionHandle> GetNestedTypes();
    public MethodImplementationHandleCollection GetMethodImplementations();
    public InterfaceImplementationHandleCollection GetInterfaceImplementations();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
    private TypeAttributes GetProjectedFlags();
    private StringHandle GetProjectedName();
    private NamespaceDefinitionHandle GetProjectedNamespace();
    private StringHandle GetProjectedNamespaceString();
    private EntityHandle GetProjectedBaseType();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeDefinitionHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeDefinitionHandle(int rowId);
    internal static TypeDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeDefinitionHandle handle);
    public static EntityHandle op_Implicit(TypeDefinitionHandle handle);
    public static TypeDefinitionHandle op_Explicit(Handle handle);
    public static TypeDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeDefinitionHandle left, TypeDefinitionHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeDefinitionHandle left, TypeDefinitionHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeDefinitionHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal TypeDefinitionHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TypeDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeLayout : ValueType {
    private int _size;
    private int _packingSize;
    public int Size { get; }
    public int PackingSize { get; }
    public bool IsDefault { get; }
    public TypeLayout(int size, int packingSize);
    public int get_Size();
    public int get_PackingSize();
    public bool get_IsDefault();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private TypeRefTreatment Treatment { get; }
    private TypeReferenceHandle Handle { get; }
    public EntityHandle ResolutionScope { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    internal TypeRefSignatureTreatment SignatureTreatment { get; }
    [NullableContextAttribute("1")]
internal TypeReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private TypeRefTreatment get_Treatment();
    private TypeReferenceHandle get_Handle();
    public EntityHandle get_ResolutionScope();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    private EntityHandle GetProjectedResolutionScope();
    private StringHandle GetProjectedName();
    private StringHandle GetProjectedNamespace();
    internal TypeRefSignatureTreatment get_SignatureTreatment();
    private TypeRefSignatureTreatment GetProjectedSignatureTreatment();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeReferenceHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeReferenceHandle(int rowId);
    internal static TypeReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeReferenceHandle handle);
    public static EntityHandle op_Implicit(TypeReferenceHandle handle);
    public static TypeReferenceHandle op_Explicit(Handle handle);
    public static TypeReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeReferenceHandle left, TypeReferenceHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeReferenceHandle left, TypeReferenceHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeReferenceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal TypeReferenceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TypeReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeSpecification : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private TypeSpecificationHandle Handle { get; }
    public BlobHandle Signature { get; }
    internal TypeSpecification(MetadataReader reader, TypeSpecificationHandle handle);
    private TypeSpecificationHandle get_Handle();
    public BlobHandle get_Signature();
    public TType DecodeSignature(ISignatureTypeProvider`2<TType, TGenericContext> provider, TGenericContext genericContext);
    public CustomAttributeHandleCollection GetCustomAttributes();
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.TypeSpecificationHandle : ValueType {
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeSpecificationHandle(int rowId);
    internal static TypeSpecificationHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeSpecificationHandle handle);
    public static EntityHandle op_Implicit(TypeSpecificationHandle handle);
    public static TypeSpecificationHandle op_Explicit(Handle handle);
    public static TypeSpecificationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeSpecificationHandle left, TypeSpecificationHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeSpecificationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeSpecificationHandle left, TypeSpecificationHandle right);
}
[IsReadOnlyAttribute]
public class System.Reflection.Metadata.UserStringHandle : ValueType {
    private int _offset;
    public bool IsNil { get; }
    private UserStringHandle(int offset);
    internal static UserStringHandle FromOffset(int heapOffset);
    public static Handle op_Implicit(UserStringHandle handle);
    public static UserStringHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal int GetHeapOffset();
    public static bool op_Equality(UserStringHandle left, UserStringHandle right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UserStringHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(UserStringHandle left, UserStringHandle right);
}
[FlagsAttribute]
public enum System.Reflection.MethodImportAttributes : Enum {
    public short value__;
    public static MethodImportAttributes None;
    public static MethodImportAttributes ExactSpelling;
    public static MethodImportAttributes BestFitMappingDisable;
    public static MethodImportAttributes BestFitMappingEnable;
    public static MethodImportAttributes BestFitMappingMask;
    public static MethodImportAttributes CharSetAnsi;
    public static MethodImportAttributes CharSetUnicode;
    public static MethodImportAttributes CharSetAuto;
    public static MethodImportAttributes CharSetMask;
    public static MethodImportAttributes ThrowOnUnmappableCharEnable;
    public static MethodImportAttributes ThrowOnUnmappableCharDisable;
    public static MethodImportAttributes ThrowOnUnmappableCharMask;
    public static MethodImportAttributes SetLastError;
    public static MethodImportAttributes CallingConventionWinApi;
    public static MethodImportAttributes CallingConventionCDecl;
    public static MethodImportAttributes CallingConventionStdCall;
    public static MethodImportAttributes CallingConventionThisCall;
    public static MethodImportAttributes CallingConventionFastCall;
    public static MethodImportAttributes CallingConventionMask;
}
[FlagsAttribute]
public enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes Adder;
    public static MethodSemanticsAttributes Remover;
    public static MethodSemanticsAttributes Raiser;
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.Characteristics : Enum {
    public ushort value__;
    public static Characteristics RelocsStripped;
    public static Characteristics ExecutableImage;
    public static Characteristics LineNumsStripped;
    public static Characteristics LocalSymsStripped;
    public static Characteristics AggressiveWSTrim;
    public static Characteristics LargeAddressAware;
    public static Characteristics BytesReversedLo;
    public static Characteristics Bit32Machine;
    public static Characteristics DebugStripped;
    public static Characteristics RemovableRunFromSwap;
    public static Characteristics NetRunFromSwap;
    public static Characteristics System;
    public static Characteristics Dll;
    public static Characteristics UpSystemOnly;
    public static Characteristics BytesReversedHi;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.CodeViewDebugDirectoryData : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Age>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public Guid Guid { get; }
    public int Age { get; }
    public string Path { get; }
    internal CodeViewDebugDirectoryData(Guid guid, int age, string path);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
public int get_Age();
    [CompilerGeneratedAttribute]
public string get_Path();
}
public class System.Reflection.PortableExecutable.CoffHeader : object {
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NumberOfSections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToSymbolTable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SizeOfOptionalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Characteristics <Characteristics>k__BackingField;
    internal static int Size;
    public Machine Machine { get; }
    public short NumberOfSections { get; }
    public int TimeDateStamp { get; }
    public int PointerToSymbolTable { get; }
    public int NumberOfSymbols { get; }
    public short SizeOfOptionalHeader { get; }
    public Characteristics Characteristics { get; }
    internal CoffHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public Machine get_Machine();
    [CompilerGeneratedAttribute]
public short get_NumberOfSections();
    [CompilerGeneratedAttribute]
public int get_TimeDateStamp();
    [CompilerGeneratedAttribute]
public int get_PointerToSymbolTable();
    [CompilerGeneratedAttribute]
public int get_NumberOfSymbols();
    [CompilerGeneratedAttribute]
public short get_SizeOfOptionalHeader();
    [CompilerGeneratedAttribute]
public Characteristics get_Characteristics();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.CorFlags : Enum {
    public int value__;
    public static CorFlags ILOnly;
    public static CorFlags Requires32Bit;
    public static CorFlags ILLibrary;
    public static CorFlags StrongNameSigned;
    public static CorFlags NativeEntryPoint;
    public static CorFlags TrackDebugData;
    public static CorFlags Prefers32Bit;
}
public class System.Reflection.PortableExecutable.CorHeader : object {
    [CompilerGeneratedAttribute]
private ushort <MajorRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <MetadataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EntryPointTokenOrRelativeVirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ResourcesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <StrongNameSignatureDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CodeManagerTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <VtableFixupsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExportAddressTableJumpsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ManagedNativeHeaderDirectory>k__BackingField;
    public ushort MajorRuntimeVersion { get; }
    public ushort MinorRuntimeVersion { get; }
    public DirectoryEntry MetadataDirectory { get; }
    public CorFlags Flags { get; }
    public int EntryPointTokenOrRelativeVirtualAddress { get; }
    public DirectoryEntry ResourcesDirectory { get; }
    public DirectoryEntry StrongNameSignatureDirectory { get; }
    public DirectoryEntry CodeManagerTableDirectory { get; }
    public DirectoryEntry VtableFixupsDirectory { get; }
    public DirectoryEntry ExportAddressTableJumpsDirectory { get; }
    public DirectoryEntry ManagedNativeHeaderDirectory { get; }
    internal CorHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public ushort get_MajorRuntimeVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorRuntimeVersion();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_MetadataDirectory();
    [CompilerGeneratedAttribute]
public CorFlags get_Flags();
    [CompilerGeneratedAttribute]
public int get_EntryPointTokenOrRelativeVirtualAddress();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ResourcesDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_StrongNameSignatureDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CodeManagerTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_VtableFixupsDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExportAddressTableJumpsDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ManagedNativeHeaderDirectory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PortableExecutable.DebugDirectoryBuilder : object {
    private List`1<Entry> _entries;
    private BlobBuilder _dataBuilder;
    internal int TableSize { get; }
    internal int Size { get; }
    internal void AddEntry(DebugDirectoryEntryType type, UInt32 version, UInt32 stamp, int dataSize);
    public void AddEntry(DebugDirectoryEntryType type, UInt32 version, UInt32 stamp);
    public void AddEntry(DebugDirectoryEntryType type, UInt32 version, UInt32 stamp, TData data, Action`2<BlobBuilder, TData> dataSerializer);
    public void AddCodeViewEntry(string pdbPath, BlobContentId pdbContentId, ushort portablePdbVersion);
    public void AddCodeViewEntry(string pdbPath, BlobContentId pdbContentId, ushort portablePdbVersion, int age);
    public void AddReproducibleEntry();
    private static int WriteCodeViewData(BlobBuilder builder, string pdbPath, Guid pdbGuid, int age);
    [NullableContextAttribute("0")]
public void AddPdbChecksumEntry(string algorithmName, ImmutableArray`1<byte> checksum);
    private static int WritePdbChecksumData(BlobBuilder builder, string algorithmName, ImmutableArray`1<byte> checksum);
    internal int get_TableSize();
    internal int get_Size();
    internal void Serialize(BlobBuilder builder, SectionLocation sectionLocation, int sectionOffset);
    public void AddEmbeddedPortablePdbEntry(BlobBuilder debugMetadata, ushort portablePdbVersion);
    private static int WriteEmbeddedPortablePdbData(BlobBuilder builder, BlobBuilder debugMetadata);
}
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.DebugDirectoryEntry : ValueType {
    internal static int Size;
    [CompilerGeneratedAttribute]
private UInt32 <Stamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugDirectoryEntryType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataRelativeVirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataPointer>k__BackingField;
    public UInt32 Stamp { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public DebugDirectoryEntryType Type { get; }
    public int DataSize { get; }
    public int DataRelativeVirtualAddress { get; }
    public int DataPointer { get; }
    public bool IsPortableCodeView { get; }
    public DebugDirectoryEntry(UInt32 stamp, ushort majorVersion, ushort minorVersion, DebugDirectoryEntryType type, int dataSize, int dataRelativeVirtualAddress, int dataPointer);
    [CompilerGeneratedAttribute]
public UInt32 get_Stamp();
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public DebugDirectoryEntryType get_Type();
    [CompilerGeneratedAttribute]
public int get_DataSize();
    [CompilerGeneratedAttribute]
public int get_DataRelativeVirtualAddress();
    [CompilerGeneratedAttribute]
public int get_DataPointer();
    public bool get_IsPortableCodeView();
}
public enum System.Reflection.PortableExecutable.DebugDirectoryEntryType : Enum {
    public int value__;
    public static DebugDirectoryEntryType Unknown;
    public static DebugDirectoryEntryType Coff;
    public static DebugDirectoryEntryType CodeView;
    public static DebugDirectoryEntryType Reproducible;
    public static DebugDirectoryEntryType EmbeddedPortablePdb;
    public static DebugDirectoryEntryType PdbChecksum;
}
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.DirectoryEntry : ValueType {
    public int RelativeVirtualAddress;
    public int Size;
    public DirectoryEntry(int relativeVirtualAddress, int size);
    internal DirectoryEntry(PEBinaryReader& reader);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.DllCharacteristics : Enum {
    public ushort value__;
    public static DllCharacteristics ProcessInit;
    public static DllCharacteristics ProcessTerm;
    public static DllCharacteristics ThreadInit;
    public static DllCharacteristics ThreadTerm;
    public static DllCharacteristics HighEntropyVirtualAddressSpace;
    public static DllCharacteristics DynamicBase;
    public static DllCharacteristics NxCompatible;
    public static DllCharacteristics NoIsolation;
    public static DllCharacteristics NoSeh;
    public static DllCharacteristics NoBind;
    public static DllCharacteristics AppContainer;
    public static DllCharacteristics WdmDriver;
    public static DllCharacteristics TerminalServerAware;
}
public enum System.Reflection.PortableExecutable.Machine : Enum {
    public ushort value__;
    public static Machine Unknown;
    public static Machine I386;
    public static Machine WceMipsV2;
    public static Machine Alpha;
    public static Machine SH3;
    public static Machine SH3Dsp;
    public static Machine SH3E;
    public static Machine SH4;
    public static Machine SH5;
    public static Machine Arm;
    public static Machine Thumb;
    public static Machine ArmThumb2;
    public static Machine AM33;
    public static Machine PowerPC;
    public static Machine PowerPCFP;
    public static Machine IA64;
    public static Machine MIPS16;
    public static Machine Alpha64;
    public static Machine MipsFpu;
    public static Machine MipsFpu16;
    public static Machine Tricore;
    public static Machine Ebc;
    public static Machine Amd64;
    public static Machine M32R;
    public static Machine Arm64;
    public static Machine LoongArch32;
    public static Machine LoongArch64;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PortableExecutable.ManagedPEBuilder : PEBuilder {
    public static int ManagedResourcesDataAlignment;
    public static int MappedFieldDataAlignment;
    private PEDirectoriesBuilder _peDirectoriesBuilder;
    private MetadataRootBuilder _metadataRootBuilder;
    private BlobBuilder _ilStream;
    private BlobBuilder _mappedFieldDataOpt;
    private BlobBuilder _managedResourcesOpt;
    private ResourceSectionBuilder _nativeResourcesOpt;
    private int _strongNameSignatureSize;
    private MethodDefinitionHandle _entryPointOpt;
    private DebugDirectoryBuilder _debugDirectoryBuilderOpt;
    private CorFlags _corFlags;
    private int _lazyEntryPointAddress;
    private Blob _lazyStrongNameSignature;
    [NullableContextAttribute("2")]
public ManagedPEBuilder(PEHeaderBuilder header, MetadataRootBuilder metadataRootBuilder, BlobBuilder ilStream, BlobBuilder mappedFieldData, BlobBuilder managedResources, ResourceSectionBuilder nativeResources, DebugDirectoryBuilder debugDirectoryBuilder, int strongNameSignatureSize, MethodDefinitionHandle entryPoint, CorFlags flags, Func`2<IEnumerable`1<Blob>, BlobContentId> deterministicIdProvider);
    private DebugDirectoryBuilder CreateDefaultDebugDirectoryBuilder();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<Section> CreateSections();
    protected virtual BlobBuilder SerializeSection(string name, SectionLocation location);
    private BlobBuilder SerializeTextSection(SectionLocation location);
    private BlobBuilder SerializeResourceSection(SectionLocation location);
    private BlobBuilder SerializeRelocationSection(SectionLocation location);
    private static void WriteRelocationSection(BlobBuilder builder, Machine machine, int entryPointAddress);
    protected internal virtual PEDirectoriesBuilder GetDirectories();
    public void Sign(BlobBuilder peImage, Func`2<IEnumerable`1<Blob>, Byte[]> signatureProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Reflection.PortableExecutable.ManagedTextSection : object {
    [CompilerGeneratedAttribute]
private Characteristics <ImageCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ILStreamSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResourceDataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrongNameSignatureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DebugDataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MappedFieldDataSize>k__BackingField;
    public static int ManagedResourcesDataAlignment;
    public static int MappedFieldDataAlignment;
    public Characteristics ImageCharacteristics { get; }
    public Machine Machine { get; }
    public int ILStreamSize { get; }
    public int MetadataSize { get; }
    public int ResourceDataSize { get; }
    public int StrongNameSignatureSize { get; }
    public int DebugDataSize { get; }
    public int MappedFieldDataSize { get; }
    internal bool RequiresStartupStub { get; }
    internal bool Requires64bits { get; }
    public bool Is32Bit { get; }
    private string CorEntryPointName { get; }
    private int SizeOfImportAddressTable { get; }
    private int SizeOfImportTable { get; }
    private static int SizeOfNameTable { get; }
    private int SizeOfRuntimeStartupStub { get; }
    public int OffsetToILStream { get; }
    public ManagedTextSection(Characteristics imageCharacteristics, Machine machine, int ilStreamSize, int metadataSize, int resourceDataSize, int strongNameSignatureSize, int debugDataSize, int mappedFieldDataSize);
    [CompilerGeneratedAttribute]
public Characteristics get_ImageCharacteristics();
    [CompilerGeneratedAttribute]
public Machine get_Machine();
    [CompilerGeneratedAttribute]
public int get_ILStreamSize();
    [CompilerGeneratedAttribute]
public int get_MetadataSize();
    [CompilerGeneratedAttribute]
public int get_ResourceDataSize();
    [CompilerGeneratedAttribute]
public int get_StrongNameSignatureSize();
    [CompilerGeneratedAttribute]
public int get_DebugDataSize();
    [CompilerGeneratedAttribute]
public int get_MappedFieldDataSize();
    internal bool get_RequiresStartupStub();
    internal bool get_Requires64bits();
    public bool get_Is32Bit();
    private string get_CorEntryPointName();
    private int get_SizeOfImportAddressTable();
    private int get_SizeOfImportTable();
    private static int get_SizeOfNameTable();
    private int get_SizeOfRuntimeStartupStub();
    internal int CalculateOffsetToMappedFieldDataStreamUnaligned();
    public int CalculateOffsetToMappedFieldDataStream();
    internal int ComputeOffsetToDebugDirectory();
    private int ComputeOffsetToImportTable();
    public int get_OffsetToILStream();
    private int ComputeOffsetToMetadata();
    public int ComputeSizeOfTextSection();
    public int GetEntryPointAddress(int rva);
    public DirectoryEntry GetImportAddressTableDirectoryEntry(int rva);
    public DirectoryEntry GetImportTableDirectoryEntry(int rva);
    public DirectoryEntry GetCorHeaderDirectoryEntry(int rva);
    public void Serialize(BlobBuilder builder, int relativeVirtualAddess, int entryPointTokenOrRelativeVirtualAddress, CorFlags corFlags, ulong baseAddress, BlobBuilder metadataBuilder, BlobBuilder ilBuilder, BlobBuilder mappedFieldDataBuilderOpt, BlobBuilder resourceBuilderOpt, BlobBuilder debugDataBuilderOpt, Blob& strongNameSignature);
    private void WriteImportAddressTable(BlobBuilder builder, int importTableRva);
    private void WriteImportTable(BlobBuilder builder, int importTableRva, int importAddressTableRva);
    private static void WriteNameTable(BlobBuilder builder);
    private void WriteCorHeader(BlobBuilder builder, int textSectionRva, int entryPointTokenOrRva, CorFlags corFlags);
    private void WriteRuntimeStartupStub(BlobBuilder sectionBuilder, int importAddressTableRva, ulong baseAddress);
}
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData : ValueType {
    [CompilerGeneratedAttribute]
private string <AlgorithmName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <Checksum>k__BackingField;
    [NullableAttribute("1")]
public string AlgorithmName { get; }
    public ImmutableArray`1<byte> Checksum { get; }
    internal PdbChecksumDebugDirectoryData(string algorithmName, ImmutableArray`1<byte> checksum);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_AlgorithmName();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_Checksum();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.Reflection.PortableExecutable.PEBinaryReader : ValueType {
    private long _startOffset;
    private long _maxOffset;
    private BinaryReader _reader;
    public int CurrentOffset { get; }
    public PEBinaryReader(Stream stream, int size);
    public int get_CurrentOffset();
    public void Seek(int offset);
    public Byte[] ReadBytes(int count);
    public byte ReadByte();
    public short ReadInt16();
    public ushort ReadUInt16();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public string ReadNullPaddedUTF8(int byteCount);
    private void CheckBounds(UInt32 count);
    private void CheckBounds(long startPosition, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.PortableExecutable.PEBuilder : object {
    [CompilerGeneratedAttribute]
private PEHeaderBuilder <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IEnumerable`1<Blob>, BlobContentId> <IdProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeterministic>k__BackingField;
    private Lazy`1<ImmutableArray`1<Section>> _lazySections;
    private Blob _lazyChecksum;
    internal static int DosHeaderSize;
    public PEHeaderBuilder Header { get; }
    public Func`2<IEnumerable`1<Blob>, BlobContentId> IdProvider { get; }
    public bool IsDeterministic { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> DosHeader { get; }
    protected PEBuilder(PEHeaderBuilder header, Func`2<IEnumerable`1<Blob>, BlobContentId> deterministicIdProvider);
    [CompilerGeneratedAttribute]
public PEHeaderBuilder get_Header();
    [CompilerGeneratedAttribute]
public Func`2<IEnumerable`1<Blob>, BlobContentId> get_IdProvider();
    [CompilerGeneratedAttribute]
public bool get_IsDeterministic();
    [NullableContextAttribute("0")]
protected ImmutableArray`1<Section> GetSections();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<Section> CreateSections();
    protected abstract virtual BlobBuilder SerializeSection(string name, SectionLocation location);
    protected internal abstract virtual PEDirectoriesBuilder GetDirectories();
    public BlobContentId Serialize(BlobBuilder builder);
    private ImmutableArray`1<SerializedSection> SerializeSections();
    private static void WritePESignature(BlobBuilder builder);
    private static ReadOnlySpan`1<byte> get_DosHeader();
    private void WriteCoffHeader(BlobBuilder builder, ImmutableArray`1<SerializedSection> sections, Blob& stampFixup);
    private void WritePEHeader(BlobBuilder builder, PEDirectoriesBuilder directories, ImmutableArray`1<SerializedSection> sections);
    private static void WriteSectionHeaders(BlobBuilder builder, ImmutableArray`1<SerializedSection> serializedSections);
    private static void WriteSectionHeader(BlobBuilder builder, SerializedSection serializedSection);
    private static int IndexOfSection(ImmutableArray`1<SerializedSection> sections, SectionCharacteristics characteristics);
    private static int SumRawDataSizes(ImmutableArray`1<SerializedSection> sections, SectionCharacteristics characteristics);
    [IteratorStateMachineAttribute("System.Reflection.PortableExecutable.PEBuilder/<GetContentToSign>d__30")]
internal static IEnumerable`1<Blob> GetContentToSign(BlobBuilder peImage, int peHeadersSize, int peHeaderAlignment, Blob strongNameSignatureFixup);
    internal static Blob GetPrefixBlob(Blob container, Blob blob);
    internal static Blob GetSuffixBlob(Blob container, Blob blob);
    [IteratorStateMachineAttribute("System.Reflection.PortableExecutable.PEBuilder/<GetContentToChecksum>d__33")]
internal static IEnumerable`1<Blob> GetContentToChecksum(BlobBuilder peImage, Blob checksumFixup);
    internal void Sign(BlobBuilder peImage, Blob strongNameSignatureFixup, Func`2<IEnumerable`1<Blob>, Byte[]> signatureProvider);
    internal static UInt32 CalculateChecksum(BlobBuilder peImage, Blob checksumFixup);
    private static UInt32 CalculateChecksum(IEnumerable`1<Blob> blobs);
    private static UInt32 AggregateChecksum(UInt32 checksum, ushort value);
}
public class System.Reflection.PortableExecutable.PEDirectoriesBuilder : object {
    [CompilerGeneratedAttribute]
private int <AddressOfEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExportTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ResourceTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExceptionTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BaseRelocationTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DebugTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CopyrightTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <GlobalPointerTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ThreadLocalStorageTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <LoadConfigTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BoundImportTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportAddressTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DelayImportTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CorHeaderTable>k__BackingField;
    public int AddressOfEntryPoint { get; public set; }
    public DirectoryEntry ExportTable { get; public set; }
    public DirectoryEntry ImportTable { get; public set; }
    public DirectoryEntry ResourceTable { get; public set; }
    public DirectoryEntry ExceptionTable { get; public set; }
    public DirectoryEntry BaseRelocationTable { get; public set; }
    public DirectoryEntry DebugTable { get; public set; }
    public DirectoryEntry CopyrightTable { get; public set; }
    public DirectoryEntry GlobalPointerTable { get; public set; }
    public DirectoryEntry ThreadLocalStorageTable { get; public set; }
    public DirectoryEntry LoadConfigTable { get; public set; }
    public DirectoryEntry BoundImportTable { get; public set; }
    public DirectoryEntry ImportAddressTable { get; public set; }
    public DirectoryEntry DelayImportTable { get; public set; }
    public DirectoryEntry CorHeaderTable { get; public set; }
    [CompilerGeneratedAttribute]
public int get_AddressOfEntryPoint();
    [CompilerGeneratedAttribute]
public void set_AddressOfEntryPoint(int value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExportTable();
    [CompilerGeneratedAttribute]
public void set_ExportTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportTable();
    [CompilerGeneratedAttribute]
public void set_ImportTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ResourceTable();
    [CompilerGeneratedAttribute]
public void set_ResourceTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExceptionTable();
    [CompilerGeneratedAttribute]
public void set_ExceptionTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BaseRelocationTable();
    [CompilerGeneratedAttribute]
public void set_BaseRelocationTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DebugTable();
    [CompilerGeneratedAttribute]
public void set_DebugTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CopyrightTable();
    [CompilerGeneratedAttribute]
public void set_CopyrightTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_GlobalPointerTable();
    [CompilerGeneratedAttribute]
public void set_GlobalPointerTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ThreadLocalStorageTable();
    [CompilerGeneratedAttribute]
public void set_ThreadLocalStorageTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_LoadConfigTable();
    [CompilerGeneratedAttribute]
public void set_LoadConfigTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BoundImportTable();
    [CompilerGeneratedAttribute]
public void set_BoundImportTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportAddressTable();
    [CompilerGeneratedAttribute]
public void set_ImportAddressTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DelayImportTable();
    [CompilerGeneratedAttribute]
public void set_DelayImportTable(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CorHeaderTable();
    [CompilerGeneratedAttribute]
public void set_CorHeaderTable(DirectoryEntry value);
}
public class System.Reflection.PortableExecutable.PEHeader : object {
    [CompilerGeneratedAttribute]
private PEMagic <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MajorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfInitializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfUninitializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AddressOfEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseOfCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseOfData>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CheckSum>k__BackingField;
    [CompilerGeneratedAttribute]
private Subsystem <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private DllCharacteristics <DllCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfRvaAndSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ResourceTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExceptionTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CertificateTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BaseRelocationTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DebugTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CopyrightTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <GlobalPointerTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ThreadLocalStorageTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <LoadConfigTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BoundImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportAddressTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DelayImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CorHeaderTableDirectory>k__BackingField;
    internal static int OffsetOfChecksum;
    public PEMagic Magic { get; }
    public byte MajorLinkerVersion { get; }
    public byte MinorLinkerVersion { get; }
    public int SizeOfCode { get; }
    public int SizeOfInitializedData { get; }
    public int SizeOfUninitializedData { get; }
    public int AddressOfEntryPoint { get; }
    public int BaseOfCode { get; }
    public int BaseOfData { get; }
    public ulong ImageBase { get; }
    public int SectionAlignment { get; }
    public int FileAlignment { get; }
    public ushort MajorOperatingSystemVersion { get; }
    public ushort MinorOperatingSystemVersion { get; }
    public ushort MajorImageVersion { get; }
    public ushort MinorImageVersion { get; }
    public ushort MajorSubsystemVersion { get; }
    public ushort MinorSubsystemVersion { get; }
    public int SizeOfImage { get; }
    public int SizeOfHeaders { get; }
    public UInt32 CheckSum { get; }
    public Subsystem Subsystem { get; }
    public DllCharacteristics DllCharacteristics { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    public int NumberOfRvaAndSizes { get; }
    public DirectoryEntry ExportTableDirectory { get; }
    public DirectoryEntry ImportTableDirectory { get; }
    public DirectoryEntry ResourceTableDirectory { get; }
    public DirectoryEntry ExceptionTableDirectory { get; }
    public DirectoryEntry CertificateTableDirectory { get; }
    public DirectoryEntry BaseRelocationTableDirectory { get; }
    public DirectoryEntry DebugTableDirectory { get; }
    public DirectoryEntry CopyrightTableDirectory { get; }
    public DirectoryEntry GlobalPointerTableDirectory { get; }
    public DirectoryEntry ThreadLocalStorageTableDirectory { get; }
    public DirectoryEntry LoadConfigTableDirectory { get; }
    public DirectoryEntry BoundImportTableDirectory { get; }
    public DirectoryEntry ImportAddressTableDirectory { get; }
    public DirectoryEntry DelayImportTableDirectory { get; }
    public DirectoryEntry CorHeaderTableDirectory { get; }
    internal PEHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public PEMagic get_Magic();
    [CompilerGeneratedAttribute]
public byte get_MajorLinkerVersion();
    [CompilerGeneratedAttribute]
public byte get_MinorLinkerVersion();
    [CompilerGeneratedAttribute]
public int get_SizeOfCode();
    [CompilerGeneratedAttribute]
public int get_SizeOfInitializedData();
    [CompilerGeneratedAttribute]
public int get_SizeOfUninitializedData();
    [CompilerGeneratedAttribute]
public int get_AddressOfEntryPoint();
    [CompilerGeneratedAttribute]
public int get_BaseOfCode();
    [CompilerGeneratedAttribute]
public int get_BaseOfData();
    [CompilerGeneratedAttribute]
public ulong get_ImageBase();
    [CompilerGeneratedAttribute]
public int get_SectionAlignment();
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
public ushort get_MajorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MajorImageVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorImageVersion();
    [CompilerGeneratedAttribute]
public ushort get_MajorSubsystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorSubsystemVersion();
    [CompilerGeneratedAttribute]
public int get_SizeOfImage();
    [CompilerGeneratedAttribute]
public int get_SizeOfHeaders();
    [CompilerGeneratedAttribute]
public UInt32 get_CheckSum();
    [CompilerGeneratedAttribute]
public Subsystem get_Subsystem();
    [CompilerGeneratedAttribute]
public DllCharacteristics get_DllCharacteristics();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackReserve();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackCommit();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapReserve();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapCommit();
    [CompilerGeneratedAttribute]
public int get_NumberOfRvaAndSizes();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExportTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ResourceTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExceptionTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CertificateTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BaseRelocationTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DebugTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CopyrightTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_GlobalPointerTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ThreadLocalStorageTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_LoadConfigTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BoundImportTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportAddressTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DelayImportTableDirectory();
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CorHeaderTableDirectory();
    internal static int Size(bool is32Bit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PortableExecutable.PEHeaderBuilder : object {
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private Characteristics <ImageCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MajorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Subsystem <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private DllCharacteristics <DllCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapCommit>k__BackingField;
    public Machine Machine { get; }
    public Characteristics ImageCharacteristics { get; }
    public byte MajorLinkerVersion { get; }
    public byte MinorLinkerVersion { get; }
    public ulong ImageBase { get; }
    public int SectionAlignment { get; }
    public int FileAlignment { get; }
    public ushort MajorOperatingSystemVersion { get; }
    public ushort MinorOperatingSystemVersion { get; }
    public ushort MajorImageVersion { get; }
    public ushort MinorImageVersion { get; }
    public ushort MajorSubsystemVersion { get; }
    public ushort MinorSubsystemVersion { get; }
    public Subsystem Subsystem { get; }
    public DllCharacteristics DllCharacteristics { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    internal bool Is32Bit { get; }
    public PEHeaderBuilder(Machine machine, int sectionAlignment, int fileAlignment, ulong imageBase, byte majorLinkerVersion, byte minorLinkerVersion, ushort majorOperatingSystemVersion, ushort minorOperatingSystemVersion, ushort majorImageVersion, ushort minorImageVersion, ushort majorSubsystemVersion, ushort minorSubsystemVersion, Subsystem subsystem, DllCharacteristics dllCharacteristics, Characteristics imageCharacteristics, ulong sizeOfStackReserve, ulong sizeOfStackCommit, ulong sizeOfHeapReserve, ulong sizeOfHeapCommit);
    [CompilerGeneratedAttribute]
public Machine get_Machine();
    [CompilerGeneratedAttribute]
public Characteristics get_ImageCharacteristics();
    [CompilerGeneratedAttribute]
public byte get_MajorLinkerVersion();
    [CompilerGeneratedAttribute]
public byte get_MinorLinkerVersion();
    [CompilerGeneratedAttribute]
public ulong get_ImageBase();
    [CompilerGeneratedAttribute]
public int get_SectionAlignment();
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
public ushort get_MajorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MajorImageVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorImageVersion();
    [CompilerGeneratedAttribute]
public ushort get_MajorSubsystemVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorSubsystemVersion();
    [CompilerGeneratedAttribute]
public Subsystem get_Subsystem();
    [CompilerGeneratedAttribute]
public DllCharacteristics get_DllCharacteristics();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackReserve();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackCommit();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapReserve();
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapCommit();
    public static PEHeaderBuilder CreateExecutableHeader();
    public static PEHeaderBuilder CreateLibraryHeader();
    internal bool get_Is32Bit();
    internal int ComputeSizeOfPEHeaders(int sectionCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PortableExecutable.PEHeaders : object {
    private CoffHeader _coffHeader;
    private PEHeader _peHeader;
    private ImmutableArray`1<SectionHeader> _sectionHeaders;
    private CorHeader _corHeader;
    private bool _isLoadedImage;
    private int _metadataStartOffset;
    private int _metadataSize;
    private int _coffHeaderStartOffset;
    private int _corHeaderStartOffset;
    private int _peHeaderStartOffset;
    internal static ushort DosSignature;
    internal static int PESignatureOffsetLocation;
    internal static UInt32 PESignature;
    internal static int PESignatureSize;
    public int MetadataStartOffset { get; }
    public int MetadataSize { get; }
    public CoffHeader CoffHeader { get; }
    public int CoffHeaderStartOffset { get; }
    public bool IsCoffOnly { get; }
    [NullableAttribute("2")]
public PEHeader PEHeader { get; }
    public int PEHeaderStartOffset { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<SectionHeader> SectionHeaders { get; }
    [NullableAttribute("2")]
public CorHeader CorHeader { get; }
    public int CorHeaderStartOffset { get; }
    public bool IsConsoleApplication { get; }
    public bool IsDll { get; }
    public bool IsExe { get; }
    public PEHeaders(Stream peStream);
    public PEHeaders(Stream peStream, int size);
    public PEHeaders(Stream peStream, int size, bool isLoadedImage);
    public int get_MetadataStartOffset();
    public int get_MetadataSize();
    public CoffHeader get_CoffHeader();
    public int get_CoffHeaderStartOffset();
    public bool get_IsCoffOnly();
    [NullableContextAttribute("2")]
public PEHeader get_PEHeader();
    public int get_PEHeaderStartOffset();
    [NullableContextAttribute("0")]
public ImmutableArray`1<SectionHeader> get_SectionHeaders();
    [NullableContextAttribute("2")]
public CorHeader get_CorHeader();
    public int get_CorHeaderStartOffset();
    public bool get_IsConsoleApplication();
    public bool get_IsDll();
    public bool get_IsExe();
    private bool TryCalculateCorHeaderOffset(long peStreamSize, Int32& startOffset);
    private static void SkipDosHeader(PEBinaryReader& reader, Boolean& isCOFFOnly);
    private ImmutableArray`1<SectionHeader> ReadSectionHeaders(PEBinaryReader& reader);
    public bool TryGetDirectoryOffset(DirectoryEntry directory, Int32& offset);
    internal bool TryGetDirectoryOffset(DirectoryEntry directory, Int32& offset, bool canCrossSectionBoundary);
    public int GetContainingSectionIndex(int relativeVirtualAddress);
    internal int IndexOfSection(string name);
    private void CalculateMetadataLocation(long peImageSize, Int32& start, Int32& size);
}
public enum System.Reflection.PortableExecutable.PEMagic : Enum {
    public ushort value__;
    public static PEMagic PE32;
    public static PEMagic PE32Plus;
}
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.PEMemoryBlock : ValueType {
    private AbstractMemoryBlock _block;
    private int _offset;
    public Byte* Pointer { get; }
    public int Length { get; }
    [NullableContextAttribute("1")]
internal PEMemoryBlock(AbstractMemoryBlock block, int offset);
    public Byte* get_Pointer();
    public int get_Length();
    public BlobReader GetReader();
    public BlobReader GetReader(int start, int length);
    public ImmutableArray`1<byte> GetContent();
    public ImmutableArray`1<byte> GetContent(int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PortableExecutable.PEReader : object {
    [CompilerGeneratedAttribute]
private bool <IsLoadedImage>k__BackingField;
    private MemoryBlockProvider _peImage;
    private PEHeaders _lazyPEHeaders;
    private AbstractMemoryBlock _lazyMetadataBlock;
    private AbstractMemoryBlock _lazyImageBlock;
    private AbstractMemoryBlock[] _lazyPESectionBlocks;
    public bool IsLoadedImage { get; }
    public PEHeaders PEHeaders { get; }
    public bool IsEntireImageAvailable { get; }
    public bool HasMetadata { get; }
    [NullableContextAttribute("0")]
public PEReader(Byte* peImage, int size);
    [NullableContextAttribute("0")]
public PEReader(Byte* peImage, int size, bool isLoadedImage);
    public PEReader(Stream peStream);
    public PEReader(Stream peStream, PEStreamOptions options);
    public PEReader(Stream peStream, PEStreamOptions options, int size);
    [NullableContextAttribute("0")]
public PEReader(ImmutableArray`1<byte> peImage);
    [CompilerGeneratedAttribute]
public bool get_IsLoadedImage();
    public sealed virtual void Dispose();
    private MemoryBlockProvider GetPEImage();
    public PEHeaders get_PEHeaders();
    private void InitializePEHeaders();
    private static PEHeaders ReadPEHeadersNoLock(Stream stream, long imageStartPosition, int imageSize, bool isLoadedImage);
    private AbstractMemoryBlock GetEntireImageBlock();
    private AbstractMemoryBlock GetMetadataBlock();
    private AbstractMemoryBlock GetPESectionBlock(int index);
    public bool get_IsEntireImageAvailable();
    public PEMemoryBlock GetEntireImage();
    public bool get_HasMetadata();
    public PEMemoryBlock GetMetadata();
    public PEMemoryBlock GetSectionData(int relativeVirtualAddress);
    public PEMemoryBlock GetSectionData(string sectionName);
    [NullableContextAttribute("0")]
public ImmutableArray`1<DebugDirectoryEntry> ReadDebugDirectory();
    [NullableContextAttribute("0")]
internal static ImmutableArray`1<DebugDirectoryEntry> ReadDebugDirectoryEntries(BlobReader reader);
    private AbstractMemoryBlock GetDebugDirectoryEntryDataBlock(DebugDirectoryEntry entry);
    public CodeViewDebugDirectoryData ReadCodeViewDebugDirectoryData(DebugDirectoryEntry entry);
    internal static CodeViewDebugDirectoryData DecodeCodeViewDebugDirectoryData(AbstractMemoryBlock block);
    public PdbChecksumDebugDirectoryData ReadPdbChecksumDebugDirectoryData(DebugDirectoryEntry entry);
    internal static PdbChecksumDebugDirectoryData DecodePdbChecksumDebugDirectoryData(AbstractMemoryBlock block);
    [NullableContextAttribute("2")]
public bool TryOpenAssociatedPortablePdb(string peImagePath, Func`2<string, Stream> pdbFileStreamProvider, MetadataReaderProvider& pdbReaderProvider, String& pdbPath);
    private bool TryOpenCodeViewPortablePdb(DebugDirectoryEntry codeViewEntry, string peImageDirectory, Func`2<string, Stream> pdbFileStreamProvider, MetadataReaderProvider& provider, String& pdbPath, Exception& errorToReport);
    private static bool TryOpenPortablePdbFile(string path, BlobContentId id, Func`2<string, Stream> pdbFileStreamProvider, MetadataReaderProvider& provider, Exception& errorToReport);
    private void TryOpenEmbeddedPortablePdb(DebugDirectoryEntry embeddedPdbEntry, Boolean& openedEmbeddedPdb, MetadataReaderProvider& provider, Exception& errorToReport);
    public MetadataReaderProvider ReadEmbeddedPortablePdbDebugDirectoryData(DebugDirectoryEntry entry);
    internal static void ValidateEmbeddedPortablePdbVersion(DebugDirectoryEntry entry);
    internal static NativeHeapMemoryBlock DecodeEmbeddedPortablePdbDebugDirectoryData(AbstractMemoryBlock block);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.PEStreamOptions : Enum {
    public int value__;
    public static PEStreamOptions Default;
    public static PEStreamOptions LeaveOpen;
    public static PEStreamOptions PrefetchMetadata;
    public static PEStreamOptions PrefetchEntireImage;
    public static PEStreamOptions IsLoadedImage;
}
[ExtensionAttribute]
internal static class System.Reflection.PortableExecutable.PEStreamOptionsExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(PEStreamOptions options);
}
public abstract class System.Reflection.PortableExecutable.ResourceSectionBuilder : object {
    [NullableContextAttribute("1")]
protected internal abstract virtual void Serialize(BlobBuilder builder, SectionLocation location);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.SectionCharacteristics : Enum {
    public UInt32 value__;
    public static SectionCharacteristics TypeReg;
    public static SectionCharacteristics TypeDSect;
    public static SectionCharacteristics TypeNoLoad;
    public static SectionCharacteristics TypeGroup;
    public static SectionCharacteristics TypeNoPad;
    public static SectionCharacteristics TypeCopy;
    public static SectionCharacteristics ContainsCode;
    public static SectionCharacteristics ContainsInitializedData;
    public static SectionCharacteristics ContainsUninitializedData;
    public static SectionCharacteristics LinkerOther;
    public static SectionCharacteristics LinkerInfo;
    public static SectionCharacteristics TypeOver;
    public static SectionCharacteristics LinkerRemove;
    public static SectionCharacteristics LinkerComdat;
    public static SectionCharacteristics MemProtected;
    public static SectionCharacteristics NoDeferSpecExc;
    public static SectionCharacteristics GPRel;
    public static SectionCharacteristics MemFardata;
    public static SectionCharacteristics MemSysheap;
    public static SectionCharacteristics MemPurgeable;
    public static SectionCharacteristics Mem16Bit;
    public static SectionCharacteristics MemLocked;
    public static SectionCharacteristics MemPreload;
    public static SectionCharacteristics Align1Bytes;
    public static SectionCharacteristics Align2Bytes;
    public static SectionCharacteristics Align4Bytes;
    public static SectionCharacteristics Align8Bytes;
    public static SectionCharacteristics Align16Bytes;
    public static SectionCharacteristics Align32Bytes;
    public static SectionCharacteristics Align64Bytes;
    public static SectionCharacteristics Align128Bytes;
    public static SectionCharacteristics Align256Bytes;
    public static SectionCharacteristics Align512Bytes;
    public static SectionCharacteristics Align1024Bytes;
    public static SectionCharacteristics Align2048Bytes;
    public static SectionCharacteristics Align4096Bytes;
    public static SectionCharacteristics Align8192Bytes;
    public static SectionCharacteristics AlignMask;
    public static SectionCharacteristics LinkerNRelocOvfl;
    public static SectionCharacteristics MemDiscardable;
    public static SectionCharacteristics MemNotCached;
    public static SectionCharacteristics MemNotPaged;
    public static SectionCharacteristics MemShared;
    public static SectionCharacteristics MemExecute;
    public static SectionCharacteristics MemRead;
    public static SectionCharacteristics MemWrite;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.SectionHeader : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VirtualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfRawData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToRawData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToRelocations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToLineNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfRelocations>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfLineNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionCharacteristics <SectionCharacteristics>k__BackingField;
    internal static int NameSize;
    internal static int Size;
    public string Name { get; }
    public int VirtualSize { get; }
    public int VirtualAddress { get; }
    public int SizeOfRawData { get; }
    public int PointerToRawData { get; }
    public int PointerToRelocations { get; }
    public int PointerToLineNumbers { get; }
    public ushort NumberOfRelocations { get; }
    public ushort NumberOfLineNumbers { get; }
    public SectionCharacteristics SectionCharacteristics { get; }
    internal SectionHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_VirtualSize();
    [CompilerGeneratedAttribute]
public int get_VirtualAddress();
    [CompilerGeneratedAttribute]
public int get_SizeOfRawData();
    [CompilerGeneratedAttribute]
public int get_PointerToRawData();
    [CompilerGeneratedAttribute]
public int get_PointerToRelocations();
    [CompilerGeneratedAttribute]
public int get_PointerToLineNumbers();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfRelocations();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfLineNumbers();
    [CompilerGeneratedAttribute]
public SectionCharacteristics get_SectionCharacteristics();
}
[IsReadOnlyAttribute]
public class System.Reflection.PortableExecutable.SectionLocation : ValueType {
    [CompilerGeneratedAttribute]
private int <RelativeVirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToRawData>k__BackingField;
    public int RelativeVirtualAddress { get; }
    public int PointerToRawData { get; }
    public SectionLocation(int relativeVirtualAddress, int pointerToRawData);
    [CompilerGeneratedAttribute]
public int get_RelativeVirtualAddress();
    [CompilerGeneratedAttribute]
public int get_PointerToRawData();
}
public enum System.Reflection.PortableExecutable.Subsystem : Enum {
    public ushort value__;
    public static Subsystem Unknown;
    public static Subsystem Native;
    public static Subsystem WindowsGui;
    public static Subsystem WindowsCui;
    public static Subsystem OS2Cui;
    public static Subsystem PosixCui;
    public static Subsystem NativeWindows;
    public static Subsystem WindowsCEGui;
    public static Subsystem EfiApplication;
    public static Subsystem EfiBootServiceDriver;
    public static Subsystem EfiRuntimeDriver;
    public static Subsystem EfiRom;
    public static Subsystem Xbox;
    public static Subsystem WindowsBootApplication;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Reflection.Throw : object {
    [DoesNotReturnAttribute]
internal static void InvalidCast();
    [DoesNotReturnAttribute]
internal static void InvalidArgument(string message, string parameterName);
    [DoesNotReturnAttribute]
internal static void InvalidArgument_OffsetForVirtualHeapHandle();
    [DoesNotReturnAttribute]
internal static Exception InvalidArgument_UnexpectedHandleKind(HandleKind kind);
    [DoesNotReturnAttribute]
internal static Exception InvalidArgument_Handle(string parameterName);
    [DoesNotReturnAttribute]
internal static void SignatureNotVarArg();
    [DoesNotReturnAttribute]
internal static void ControlFlowBuilderNotAvailable();
    [DoesNotReturnAttribute]
internal static void InvalidOperationBuilderAlreadyLinked();
    [DoesNotReturnAttribute]
internal static void InvalidOperation(string message);
    [DoesNotReturnAttribute]
internal static void InvalidOperation_LabelNotMarked(int id);
    [DoesNotReturnAttribute]
internal static void LabelDoesntBelongToBuilder(string parameterName);
    [DoesNotReturnAttribute]
internal static void HeapHandleRequired();
    [DoesNotReturnAttribute]
internal static void EntityOrUserStringHandleRequired();
    [DoesNotReturnAttribute]
internal static void InvalidToken();
    [DoesNotReturnAttribute]
internal static void ArgumentNull(string parameterName);
    [DoesNotReturnAttribute]
internal static void ArgumentEmptyString(string parameterName);
    [DoesNotReturnAttribute]
internal static void ArgumentEmptyArray(string parameterName);
    [DoesNotReturnAttribute]
internal static void ValueArgumentNull();
    [DoesNotReturnAttribute]
internal static void BuilderArgumentNull();
    [DoesNotReturnAttribute]
internal static void ArgumentOutOfRange(string parameterName);
    [DoesNotReturnAttribute]
internal static void ArgumentOutOfRange(string parameterName, string message);
    [DoesNotReturnAttribute]
internal static void BlobTooLarge(string parameterName);
    [DoesNotReturnAttribute]
internal static void IndexOutOfRange();
    [DoesNotReturnAttribute]
internal static void TableIndexOutOfRange();
    [DoesNotReturnAttribute]
internal static void ValueArgumentOutOfRange();
    [DoesNotReturnAttribute]
internal static void OutOfBounds();
    [DoesNotReturnAttribute]
internal static void WriteOutOfBounds();
    [DoesNotReturnAttribute]
internal static void InvalidCodedIndex();
    [DoesNotReturnAttribute]
internal static void InvalidHandle();
    [DoesNotReturnAttribute]
internal static void InvalidCompressedInteger();
    [DoesNotReturnAttribute]
internal static void InvalidSerializedString();
    [DoesNotReturnAttribute]
internal static void ImageTooSmall();
    [DoesNotReturnAttribute]
internal static void ImageTooSmallOrContainsInvalidOffsetOrCount();
    [DoesNotReturnAttribute]
internal static void ReferenceOverflow();
    [DoesNotReturnAttribute]
internal static void TableNotSorted(TableIndex tableIndex);
    [DoesNotReturnAttribute]
internal static void InvalidOperation_TableNotSorted(TableIndex tableIndex);
    [DoesNotReturnAttribute]
internal static void InvalidOperation_PEImageNotAvailable();
    [DoesNotReturnAttribute]
internal static void TooManySubnamespaces();
    [DoesNotReturnAttribute]
internal static void ValueOverflow();
    [DoesNotReturnAttribute]
internal static void SequencePointValueOutOfRange();
    [DoesNotReturnAttribute]
internal static void HeapSizeLimitExceeded(HeapIndex heap);
    [DoesNotReturnAttribute]
internal static void PEReaderDisposed();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeAttributesExtensions : object {
    [ExtensionAttribute]
public static bool IsForwarder(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsNested(TypeAttributes flags);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ImageTooSmall { get; }
    internal static string InvalidCorHeaderSize { get; }
    internal static string InvalidHandle { get; }
    internal static string UnexpectedHandleKind { get; }
    internal static string UnexpectedOpCode { get; }
    internal static string InvalidLocalSignatureToken { get; }
    internal static string InvalidMetadataSectionSpan { get; }
    internal static string InvalidMethodHeader1 { get; }
    internal static string InvalidMethodHeader2 { get; }
    internal static string InvalidPESignature { get; }
    internal static string InvalidSehHeader { get; }
    internal static string InvalidToken { get; }
    internal static string MetadataImageDoesNotRepresentAnAssembly { get; }
    internal static string StandaloneDebugMetadataImageDoesNotContainModuleTable { get; }
    internal static string PEImageNotAvailable { get; }
    internal static string MissingDataDirectory { get; }
    internal static string NotMetadataHeapHandle { get; }
    internal static string NotMetadataTableOrUserStringHandle { get; }
    internal static string SectionTooSmall { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string UnknownFileFormat { get; }
    internal static string UnknownPEMagicValue { get; }
    internal static string MetadataTableNotSorted { get; }
    internal static string ModuleTableInvalidNumberOfRows { get; }
    internal static string UnknownTables { get; }
    internal static string IllegalTablesInCompressedMetadataStream { get; }
    internal static string TableRowCountSpaceTooSmall { get; }
    internal static string OutOfBoundsRead { get; }
    internal static string OutOfBoundsWrite { get; }
    internal static string MetadataHeaderTooSmall { get; }
    internal static string MetadataSignature { get; }
    internal static string NotEnoughSpaceForVersionString { get; }
    internal static string StreamHeaderTooSmall { get; }
    internal static string NotEnoughSpaceForStreamHeaderName { get; }
    internal static string NotEnoughSpaceForStringStream { get; }
    internal static string NotEnoughSpaceForBlobStream { get; }
    internal static string NotEnoughSpaceForGUIDStream { get; }
    internal static string NotEnoughSpaceForMetadataStream { get; }
    internal static string InvalidMetadataStreamFormat { get; }
    internal static string MetadataTablesTooSmall { get; }
    internal static string MetadataTableHeaderTooSmall { get; }
    internal static string WinMDMissingMscorlibRef { get; }
    internal static string UnexpectedStreamEnd { get; }
    internal static string InvalidMethodRva { get; }
    internal static string CantGetOffsetForVirtualHeapHandle { get; }
    internal static string InvalidNumberOfSections { get; }
    internal static string InvalidSignature { get; }
    internal static string PEImageDoesNotHaveMetadata { get; }
    internal static string InvalidCodedIndex { get; }
    internal static string InvalidCompressedInteger { get; }
    internal static string InvalidDocumentName { get; }
    internal static string RowIdOrHeapOffsetTooLarge { get; }
    internal static string EnCMapNotSorted { get; }
    internal static string InvalidSerializedString { get; }
    internal static string StreamTooLarge { get; }
    internal static string ImageTooSmallOrContainsInvalidOffsetOrCount { get; }
    internal static string MetadataStringDecoderEncodingMustBeUtf8 { get; }
    internal static string InvalidConstantValue { get; }
    internal static string InvalidConstantValueOfType { get; }
    internal static string InvalidImportDefinitionKind { get; }
    internal static string ValueTooLarge { get; }
    internal static string BlobTooLarge { get; }
    internal static string InvalidTypeSize { get; }
    internal static string HandleBelongsToFutureGeneration { get; }
    internal static string InvalidRowCount { get; }
    internal static string InvalidEntryPointToken { get; }
    internal static string TooManySubnamespaces { get; }
    internal static string TooManyExceptionRegions { get; }
    internal static string SequencePointValueOutOfRange { get; }
    internal static string InvalidDirectoryRVA { get; }
    internal static string InvalidDirectorySize { get; }
    internal static string InvalidDebugDirectoryEntryCharacteristics { get; }
    internal static string UnexpectedCodeViewDataSignature { get; }
    internal static string UnexpectedEmbeddedPortablePdbDataSignature { get; }
    internal static string InvalidPdbChecksumDataFormat { get; }
    internal static string UnexpectedSignatureHeader { get; }
    internal static string UnexpectedSignatureHeader2 { get; }
    internal static string NotTypeDefOrRefHandle { get; }
    internal static string UnexpectedSignatureTypeCode { get; }
    internal static string SignatureTypeSequenceMustHaveAtLeastOneElement { get; }
    internal static string NotTypeDefOrRefOrSpecHandle { get; }
    internal static string UnexpectedDebugDirectoryType { get; }
    internal static string HeapSizeLimitExceeded { get; }
    internal static string BuilderMustAligned { get; }
    internal static string BuilderAlreadyLinked { get; }
    internal static string ReturnedBuilderSizeTooSmall { get; }
    internal static string SignatureNotVarArg { get; }
    internal static string LabelDoesntBelongToBuilder { get; }
    internal static string ControlFlowBuilderNotAvailable { get; }
    internal static string BaseReaderMustBeFullMetadataReader { get; }
    internal static string ModuleAlreadyAdded { get; }
    internal static string AssemblyAlreadyAdded { get; }
    internal static string ExpectedListOfSize { get; }
    internal static string ExpectedArrayOfSize { get; }
    internal static string ExpectedNonEmptyList { get; }
    internal static string ExpectedNonEmptyArray { get; }
    internal static string ExpectedNonEmptyString { get; }
    internal static string ReadersMustBeDeltaReaders { get; }
    internal static string SignatureProviderReturnedInvalidSignature { get; }
    internal static string UnknownSectionName { get; }
    internal static string HashTooShort { get; }
    internal static string UnexpectedArrayLength { get; }
    internal static string ValueMustBeMultiple { get; }
    internal static string MustNotReturnNull { get; }
    internal static string MetadataVersionTooLong { get; }
    internal static string RowCountMustBeZero { get; }
    internal static string RowCountOutOfRange { get; }
    internal static string SizeMismatch { get; }
    internal static string DataTooBig { get; }
    internal static string UnsupportedFormatVersion { get; }
    internal static string DistanceBetweenInstructionAndLabelTooBig { get; }
    internal static string LabelNotMarked { get; }
    internal static string MethodHasNoExceptionRegions { get; }
    internal static string InvalidExceptionRegionBounds { get; }
    internal static string UnexpectedValue { get; }
    internal static string UnexpectedValueUnknownType { get; }
    private static SR();
    private static bool UsingResourceKeys();
    [NullableContextAttribute("1")]
internal static string GetResourceString(string resourceKey);
    [NullableContextAttribute("1")]
internal static string GetResourceString(string resourceKey, string defaultString);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ImageTooSmall();
    internal static string get_InvalidCorHeaderSize();
    internal static string get_InvalidHandle();
    internal static string get_UnexpectedHandleKind();
    internal static string get_UnexpectedOpCode();
    internal static string get_InvalidLocalSignatureToken();
    internal static string get_InvalidMetadataSectionSpan();
    internal static string get_InvalidMethodHeader1();
    internal static string get_InvalidMethodHeader2();
    internal static string get_InvalidPESignature();
    internal static string get_InvalidSehHeader();
    internal static string get_InvalidToken();
    internal static string get_MetadataImageDoesNotRepresentAnAssembly();
    internal static string get_StandaloneDebugMetadataImageDoesNotContainModuleTable();
    internal static string get_PEImageNotAvailable();
    internal static string get_MissingDataDirectory();
    internal static string get_NotMetadataHeapHandle();
    internal static string get_NotMetadataTableOrUserStringHandle();
    internal static string get_SectionTooSmall();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_UnknownFileFormat();
    internal static string get_UnknownPEMagicValue();
    internal static string get_MetadataTableNotSorted();
    internal static string get_ModuleTableInvalidNumberOfRows();
    internal static string get_UnknownTables();
    internal static string get_IllegalTablesInCompressedMetadataStream();
    internal static string get_TableRowCountSpaceTooSmall();
    internal static string get_OutOfBoundsRead();
    internal static string get_OutOfBoundsWrite();
    internal static string get_MetadataHeaderTooSmall();
    internal static string get_MetadataSignature();
    internal static string get_NotEnoughSpaceForVersionString();
    internal static string get_StreamHeaderTooSmall();
    internal static string get_NotEnoughSpaceForStreamHeaderName();
    internal static string get_NotEnoughSpaceForStringStream();
    internal static string get_NotEnoughSpaceForBlobStream();
    internal static string get_NotEnoughSpaceForGUIDStream();
    internal static string get_NotEnoughSpaceForMetadataStream();
    internal static string get_InvalidMetadataStreamFormat();
    internal static string get_MetadataTablesTooSmall();
    internal static string get_MetadataTableHeaderTooSmall();
    internal static string get_WinMDMissingMscorlibRef();
    internal static string get_UnexpectedStreamEnd();
    internal static string get_InvalidMethodRva();
    internal static string get_CantGetOffsetForVirtualHeapHandle();
    internal static string get_InvalidNumberOfSections();
    internal static string get_InvalidSignature();
    internal static string get_PEImageDoesNotHaveMetadata();
    internal static string get_InvalidCodedIndex();
    internal static string get_InvalidCompressedInteger();
    internal static string get_InvalidDocumentName();
    internal static string get_RowIdOrHeapOffsetTooLarge();
    internal static string get_EnCMapNotSorted();
    internal static string get_InvalidSerializedString();
    internal static string get_StreamTooLarge();
    internal static string get_ImageTooSmallOrContainsInvalidOffsetOrCount();
    internal static string get_MetadataStringDecoderEncodingMustBeUtf8();
    internal static string get_InvalidConstantValue();
    internal static string get_InvalidConstantValueOfType();
    internal static string get_InvalidImportDefinitionKind();
    internal static string get_ValueTooLarge();
    internal static string get_BlobTooLarge();
    internal static string get_InvalidTypeSize();
    internal static string get_HandleBelongsToFutureGeneration();
    internal static string get_InvalidRowCount();
    internal static string get_InvalidEntryPointToken();
    internal static string get_TooManySubnamespaces();
    internal static string get_TooManyExceptionRegions();
    internal static string get_SequencePointValueOutOfRange();
    internal static string get_InvalidDirectoryRVA();
    internal static string get_InvalidDirectorySize();
    internal static string get_InvalidDebugDirectoryEntryCharacteristics();
    internal static string get_UnexpectedCodeViewDataSignature();
    internal static string get_UnexpectedEmbeddedPortablePdbDataSignature();
    internal static string get_InvalidPdbChecksumDataFormat();
    internal static string get_UnexpectedSignatureHeader();
    internal static string get_UnexpectedSignatureHeader2();
    internal static string get_NotTypeDefOrRefHandle();
    internal static string get_UnexpectedSignatureTypeCode();
    internal static string get_SignatureTypeSequenceMustHaveAtLeastOneElement();
    internal static string get_NotTypeDefOrRefOrSpecHandle();
    internal static string get_UnexpectedDebugDirectoryType();
    internal static string get_HeapSizeLimitExceeded();
    internal static string get_BuilderMustAligned();
    internal static string get_BuilderAlreadyLinked();
    internal static string get_ReturnedBuilderSizeTooSmall();
    internal static string get_SignatureNotVarArg();
    internal static string get_LabelDoesntBelongToBuilder();
    internal static string get_ControlFlowBuilderNotAvailable();
    internal static string get_BaseReaderMustBeFullMetadataReader();
    internal static string get_ModuleAlreadyAdded();
    internal static string get_AssemblyAlreadyAdded();
    internal static string get_ExpectedListOfSize();
    internal static string get_ExpectedArrayOfSize();
    internal static string get_ExpectedNonEmptyList();
    internal static string get_ExpectedNonEmptyArray();
    internal static string get_ExpectedNonEmptyString();
    internal static string get_ReadersMustBeDeltaReaders();
    internal static string get_SignatureProviderReturnedInvalidSignature();
    internal static string get_UnknownSectionName();
    internal static string get_HashTooShort();
    internal static string get_UnexpectedArrayLength();
    internal static string get_ValueMustBeMultiple();
    internal static string get_MustNotReturnNull();
    internal static string get_MetadataVersionTooLong();
    internal static string get_RowCountMustBeZero();
    internal static string get_RowCountOutOfRange();
    internal static string get_SizeMismatch();
    internal static string get_DataTooBig();
    internal static string get_UnsupportedFormatVersion();
    internal static string get_DistanceBetweenInstructionAndLabelTooBig();
    internal static string get_LabelNotMarked();
    internal static string get_MethodHasNoExceptionRegions();
    internal static string get_InvalidExceptionRegionBounds();
    internal static string get_UnexpectedValue();
    internal static string get_UnexpectedValueUnknownType();
}
