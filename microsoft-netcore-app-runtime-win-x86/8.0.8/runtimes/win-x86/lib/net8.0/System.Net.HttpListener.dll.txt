internal static class FxResources.System.Net.HttpListener.SR : object {
}
internal static class Interop : object {
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal class System.Net.AsyncRequestContext : RequestContextBase {
    private NativeOverlapped* _nativeOverlapped;
    private ThreadPoolBoundHandle _boundHandle;
    private ListenerAsyncResult _result;
    internal NativeOverlapped* NativeOverlapped { get; }
    internal AsyncRequestContext(ThreadPoolBoundHandle boundHandle, ListenerAsyncResult result);
    private HTTP_REQUEST* Allocate(ThreadPoolBoundHandle boundHandle, UInt32 size);
    internal void Reset(ThreadPoolBoundHandle boundHandle, ulong requestId, UInt32 size);
    protected virtual void OnReleasePins();
    protected virtual void Dispose(bool disposing);
    internal NativeOverlapped* get_NativeOverlapped();
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
internal enum System.Net.BoundaryType : Enum {
    public int value__;
    public static BoundaryType ContentLength;
    public static BoundaryType Chunked;
    public static BoundaryType Multipart;
    public static BoundaryType None;
    public static BoundaryType Invalid;
}
[ExtensionAttribute]
internal static class System.Net.CookieCollectionExtensions : object {
    private static Func`4<CookieCollection, Cookie, bool, int> s_internalAddFunc;
    [ExtensionAttribute]
public static int InternalAdd(CookieCollection cookieCollection, Cookie cookie, bool isStrict);
}
[ExtensionAttribute]
internal static class System.Net.CookieExtensions : object {
    private static Func`2<Cookie, string> s_toServerStringFunc;
    private static Func`2<Cookie, Cookie> s_cloneFunc;
    private static Func`2<Cookie, CookieVariant> s_getVariantFunc;
    [ExtensionAttribute]
public static string ToServerString(Cookie cookie);
    [ExtensionAttribute]
public static Cookie Clone(Cookie cookie);
    [ExtensionAttribute]
public static bool IsRfc2965Variant(Cookie cookie);
}
internal class System.Net.CookieParser : ValueType {
    private CookieTokenizer _tokenizer;
    private Cookie _savedCookie;
    private static Func`3<Cookie, string, bool> s_internalSetNameMethod;
    private static FieldInfo s_isQuotedDomainField;
    private static Func`3<Cookie, string, bool> InternalSetNameMethod { get; }
    private static FieldInfo IsQuotedDomainField { get; }
    internal CookieParser(string cookieString);
    private static Func`3<Cookie, string, bool> get_InternalSetNameMethod();
    private static FieldInfo get_IsQuotedDomainField();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : ValueType {
    private bool _eofCookie;
    private int _index;
    private int _length;
    private string _name;
    private bool _quoted;
    private int _start;
    private CookieToken _token;
    private int _tokenLength;
    private string _tokenStream;
    private string _value;
    private int _cookieStartIndex;
    private int _cookieLength;
    private static RecognizedAttribute[] s_recognizedAttributes;
    private static RecognizedAttribute[] s_recognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.EntitySendFormat : Enum {
    public int value__;
    public static EntitySendFormat ContentLength;
    public static EntitySendFormat Chunked;
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListener : object {
    private object _internalLock;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private HttpListenerPrefixCollection _prefixes;
    internal Hashtable _uriPrefixes;
    private bool _ignoreWriteExceptions;
    private ServiceNameStore _defaultServiceNames;
    private HttpListenerTimeoutManager _timeoutManager;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private AuthenticationSchemeSelector _authenticationDelegate;
    private AuthenticationSchemes _authenticationScheme;
    private ExtendedProtectionSelector _extendedProtectionSelectorDelegate;
    private string _realm;
    internal static bool SkipIOCPCallbackOnSuccess;
    private static Byte[] s_wwwAuthenticateBytes;
    private HttpListenerSession _currentSession;
    private bool _unsafeConnectionNtlmAuthentication;
    private HttpServerSessionHandle _serverSessionHandle;
    private ulong _urlGroupId;
    private bool _V2Initialized;
    private Dictionary`2<ulong, DisconnectAsyncResult> _disconnectResults;
    internal ICollection PrefixCollection { get; }
    [NullableAttribute("2")]
public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    [NullableAttribute("2")]
public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    [NullableAttribute("2")]
public string Realm { get; public set; }
    public bool IsListening { get; }
    public bool IgnoreWriteExceptions { get; public set; }
    public static bool IsSupported { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    private Dictionary`2<ulong, DisconnectAsyncResult> DisconnectResults { get; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    private static HttpListener();
    internal ICollection get_PrefixCollection();
    [NullableContextAttribute("2")]
public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    [NullableContextAttribute("2")]
public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    [NullableContextAttribute("2")]
public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    [NullableContextAttribute("2")]
public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public HttpListenerPrefixCollection get_Prefixes();
    internal void AddPrefix(string uriPrefix);
    internal bool ContainsPrefix(string uriPrefix);
    internal bool RemovePrefix(string uriPrefix);
    internal void RemoveAll(bool clear);
    [NullableContextAttribute("2")]
public string get_Realm();
    [NullableContextAttribute("2")]
public void set_Realm(string value);
    public bool get_IsListening();
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public Task`1<HttpListenerContext> GetContextAsync();
    public void Close();
    internal void CheckDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
    public static bool get_IsSupported();
    private void ValidateV2Property();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    private Dictionary`2<ulong, DisconnectAsyncResult> get_DisconnectResults();
    private void SetUrlGroupProperty(HTTP_SERVER_PROPERTY property, Void* info, UInt32 infosize);
    internal void SetServerTimeout(Int32[] timeouts, UInt32 minSendBytesPerSecond);
    public HttpListenerTimeoutManager get_TimeoutManager();
    private void SetupV2Config();
    public void Start();
    private void CleanupV2Config();
    private void AttachRequestQueueToUrlGroup();
    private void DetachRequestQueueFromUrlGroup();
    public void Stop();
    private void CreateRequestQueueHandle();
    private void CloseRequestQueueHandle();
    public void Abort();
    private void Dispose();
    private void RemovePrefixCore(string uriPrefix);
    private void AddAllPrefixes();
    private void AddPrefixCore(string registeredPrefix);
    public HttpListenerContext GetContext();
    internal static bool ValidateRequest(HttpListenerSession session, RequestContextBase requestMemory);
    [NullableContextAttribute("2")]
public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    internal HttpListenerContext HandleAuthentication(HttpListenerSession session, RequestContextBase memoryBlob, Boolean& stoleBlob);
    private static void FreeContext(HttpListenerContext& httpContext, RequestContextBase memoryBlob);
    internal void SetAuthenticationHeaders(HttpListenerContext context);
    private ChannelBinding GetChannelBinding(HttpListenerSession session, ulong connectionId, bool isSecureConnection, ExtendedProtectionPolicy policy);
    private ExtendedProtectionPolicy GetAuthenticationExtendedProtectionPolicy(ExtendedProtectionPolicy policy);
    private static HttpStatusCode HttpStatusFromSecurityStatus(NegotiateAuthenticationStatusCode statusErrorCode);
    internal static bool IsCredentialFailure(NegotiateAuthenticationStatusCode error);
    internal static bool IsClientFault(NegotiateAuthenticationStatusCode error);
    private static void AddChallenge(ArrayList& challenges, string challenge);
    private ArrayList BuildChallenge(AuthenticationSchemes authenticationScheme);
    private static void RegisterForDisconnectNotification(HttpListenerSession session, ulong connectionId, DisconnectAsyncResult& disconnectResult);
    private static void SendError(HttpListenerSession session, ulong requestId, HttpStatusCode httpStatusCode, ArrayList challenges);
    private static int GetTokenOffsetFromBlob(IntPtr blob);
    private static int GetTokenSizeFromBlob(IntPtr blob);
    internal static ChannelBinding GetChannelBindingFromTls(HttpListenerSession session, ulong connectionId);
    [CompilerGeneratedAttribute]
internal static string <AddPrefix>g__CreateRegisteredPrefix|32_0(string uriPrefix, int j, int i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    [CompilerGeneratedAttribute]
public virtual string get_Password();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerContext : object {
    internal HttpListener _listener;
    private HttpListenerResponse _response;
    private IPrincipal _user;
    [CompilerGeneratedAttribute]
private HttpListenerRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationSchemes <AuthenticationSchemes>k__BackingField;
    private string _mutualAuthentication;
    [CompilerGeneratedAttribute]
private HttpListenerSession <ListenerSession>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedProtectionPolicy <ExtendedProtectionPolicy>k__BackingField;
    public HttpListenerRequest Request { get; }
    [NullableAttribute("2")]
public IPrincipal User { get; }
    internal AuthenticationSchemes AuthenticationSchemes { get; internal set; }
    public HttpListenerResponse Response { get; }
    internal HttpListenerSession ListenerSession { get; private set; }
    unknown ExtendedProtectionPolicy ExtendedProtectionPolicy {internal set; }
    [NullableAttribute("2")]
internal string MutualAuthentication { get; }
    [NullableAttribute("2")]
internal HttpListener Listener { get; }
    internal SafeHandle RequestQueueHandle { get; }
    internal ThreadPoolBoundHandle RequestQueueBoundHandle { get; }
    internal ulong RequestId { get; }
    internal HttpListenerContext(HttpListenerSession session, RequestContextBase memoryBlob);
    [CompilerGeneratedAttribute]
public HttpListenerRequest get_Request();
    [NullableContextAttribute("2")]
public IPrincipal get_User();
    [CompilerGeneratedAttribute]
internal AuthenticationSchemes get_AuthenticationSchemes();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationSchemes(AuthenticationSchemes value);
    public HttpListenerResponse get_Response();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    [CompilerGeneratedAttribute]
internal HttpListenerSession get_ListenerSession();
    [CompilerGeneratedAttribute]
private void set_ListenerSession(HttpListenerSession value);
    internal void SetIdentity(IPrincipal principal, string mutualAuthentication);
    [CompilerGeneratedAttribute]
internal void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal string get_MutualAuthentication();
    internal HttpListener get_Listener();
    internal SafeHandle get_RequestQueueHandle();
    internal ThreadPoolBoundHandle get_RequestQueueBoundHandle();
    internal ulong get_RequestId();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [NullableContextAttribute("0")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal void Close();
    internal void Abort();
    internal HTTP_VERB GetKnownMethod();
    internal static void CancelRequest(SafeHandle requestQueueHandle, ulong requestId);
    internal void ForceCancelRequest(SafeHandle requestQueueHandle, ulong requestId);
    internal void SetAuthenticationHeaders();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerPrefixCollection : object {
    private HttpListener _httpListener;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual int get_Count();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual bool Contains(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    public sealed virtual void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerRequest : object {
    private CookieCollection _cookies;
    private Nullable`1<bool> _keepAlive;
    private string _rawUrl;
    private Uri _requestUri;
    private Version _version;
    [CompilerGeneratedAttribute]
private ListenerClientCertState <ClientCertState>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCertificate>k__BackingField;
    private ulong _requestId;
    internal ulong _connectionId;
    private SslStatus _sslStatus;
    private string _cookedUrlHost;
    private string _cookedUrlPath;
    private string _cookedUrlQuery;
    private long _contentLength;
    private Stream _requestStream;
    private string _httpMethod;
    private WebHeaderCollection _webHeaders;
    private IPEndPoint _localEndPoint;
    private IPEndPoint _remoteEndPoint;
    private BoundaryType _boundaryType;
    private int _clientCertificateError;
    private RequestContextBase _memoryBlob;
    private HttpListenerContext _httpContext;
    private bool _isDisposed;
    private string _serviceName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AcceptTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] UserLanguages { get; }
    public CookieCollection Cookies { get; }
    public Encoding ContentEncoding { get; }
    [NullableAttribute("2")]
public string ContentType { get; }
    public bool IsLocal { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public NameValueCollection QueryString { get; }
    [NullableAttribute("2")]
public string RawUrl { get; }
    private string RequestScheme { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    [NullableAttribute("2")]
public Uri UrlReferrer { get; }
    [NullableAttribute("2")]
public Uri Url { get; }
    public Version ProtocolVersion { get; }
    internal ListenerClientCertState ClientCertState { get; internal set; }
    [NullableAttribute("2")]
internal X509Certificate2 ClientCertificate { get; internal set; }
    public int ClientCertificateError { get; }
    internal HttpListenerContext HttpListenerContext { get; }
    internal IntPtr RequestBuffer { get; }
    internal IntPtr OriginalBlobAddress { get; }
    internal ulong RequestId { get; }
    public Guid RequestTraceIdentifier { get; }
    public long ContentLength64 { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsSecureConnection { get; }
    [NullableAttribute("2")]
public string ServiceName { get; internal set; }
    public TransportContext TransportContext { get; }
    public bool HasEntityBody { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public IPEndPoint LocalEndPoint { get; }
    private Uri RequestUri { get; }
    private static bool SupportsWebSockets { get; }
    internal HttpListenerRequest(HttpListenerContext httpContext, RequestContextBase memoryBlob);
    public String[] get_AcceptTypes();
    public String[] get_UserLanguages();
    private CookieCollection ParseCookies(Uri uri, string setCookieHeader);
    public CookieCollection get_Cookies();
    public Encoding get_ContentEncoding();
    [NullableContextAttribute("2")]
public string get_ContentType();
    public bool get_IsLocal();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public NameValueCollection get_QueryString();
    [NullableContextAttribute("2")]
public string get_RawUrl();
    private string get_RequestScheme();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    [NullableContextAttribute("2")]
public Uri get_UrlReferrer();
    [NullableContextAttribute("2")]
public Uri get_Url();
    public Version get_ProtocolVersion();
    [NullableContextAttribute("2")]
public X509Certificate2 GetClientCertificate();
    [NullableContextAttribute("2")]
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public Task`1<X509Certificate2> GetClientCertificateAsync();
    [CompilerGeneratedAttribute]
internal ListenerClientCertState get_ClientCertState();
    [CompilerGeneratedAttribute]
internal void set_ClientCertState(ListenerClientCertState value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_ClientCertificate();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificate(X509Certificate2 value);
    public int get_ClientCertificateError();
    internal HttpListenerContext get_HttpListenerContext();
    internal IntPtr get_RequestBuffer();
    internal IntPtr get_OriginalBlobAddress();
    internal void DetachBlob(RequestContextBase memoryBlob);
    internal void ReleasePins();
    internal ulong get_RequestId();
    public Guid get_RequestTraceIdentifier();
    public long get_ContentLength64();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsSecureConnection();
    [NullableContextAttribute("2")]
public string get_ServiceName();
    internal void set_ServiceName(string value);
    private int GetClientCertificateErrorCore();
    internal void SetClientCertificateError(int clientCertificateError);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    public bool get_HasEntityBody();
    public IPEndPoint get_RemoteEndPoint();
    public IPEndPoint get_LocalEndPoint();
    internal void Close();
    private ListenerClientCertAsyncResult BeginGetClientCertificateCore(AsyncCallback requestCallback, object state);
    private void GetClientCertificateCore();
    private Uri get_RequestUri();
    internal ChannelBinding GetChannelBinding();
    internal void CheckDisposed();
    private static bool get_SupportsWebSockets();
}
internal class System.Net.HttpListenerRequestContext : TransportContext {
    private HttpListenerRequest _request;
    internal HttpListenerRequestContext(HttpListenerRequest request);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static UTF8Encoding s_utf8Encoding;
    private static Encoding s_ansiEncoding;
    private string _rawUri;
    private string _cookedUriScheme;
    private string _cookedUriHost;
    private string _cookedUriPath;
    private string _cookedUriQuery;
    private StringBuilder _requestUriString;
    private List`1<byte> _rawOctets;
    private string _rawPath;
    private Uri _requestUri;
    private HttpListenerRequestUriBuilder(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private static HttpListenerRequestUriBuilder();
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private Uri Build();
    private void BuildRequestUriUsingCookedPath();
    private void BuildRequestUriUsingRawPath();
    private static Encoding GetEncoding(EncodingType type);
    private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding);
    private ParsingResult ParseRawPath(Encoding encoding);
    private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint);
    private bool AddPercentEncodedOctetToRawOctetsList(string escapedCharacter);
    private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding);
    private static void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets);
    private static string GetOctetsAsString(List`1<byte> octets);
    private static string GetPath(string uriString);
    private static string AddSlashToAsteriskOnlyPath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpListenerResponse : object {
    private BoundaryType _boundaryType;
    private CookieCollection _cookies;
    private HttpListenerContext _httpContext;
    private bool _keepAlive;
    private HttpResponseStream _responseStream;
    private string _statusDescription;
    private WebHeaderCollection _webHeaders;
    [CompilerGeneratedAttribute]
private Encoding <ContentEncoding>k__BackingField;
    private ResponseState _responseState;
    private long _contentLength;
    private HTTP_RESPONSE _nativeResponse;
    public WebHeaderCollection Headers { get; public set; }
    [NullableAttribute("2")]
public Encoding ContentEncoding { get; public set; }
    [NullableAttribute("2")]
public string ContentType { get; public set; }
    private HttpListenerContext HttpListenerContext { get; }
    private HttpListenerRequest HttpListenerRequest { get; }
    internal EntitySendFormat EntitySendFormat { get; internal set; }
    public bool SendChunked { get; public set; }
    public long ContentLength64 { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    [NullableAttribute("2")]
public string RedirectLocation { get; public set; }
    public string StatusDescription { get; public set; }
    public int StatusCode { get; public set; }
    public Version ProtocolVersion { get; public set; }
    internal BoundaryType BoundaryType { get; }
    internal bool ComputedHeaders { get; }
    internal bool SentHeaders { get; }
    private bool Disposed { get; }
    internal HttpListenerResponse(HttpListenerContext httpContext);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Encoding get_ContentEncoding();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ContentEncoding(Encoding value);
    [NullableContextAttribute("2")]
public string get_ContentType();
    [NullableContextAttribute("2")]
public void set_ContentType(string value);
    private HttpListenerContext get_HttpListenerContext();
    private HttpListenerRequest get_HttpListenerRequest();
    internal EntitySendFormat get_EntitySendFormat();
    internal void set_EntitySendFormat(EntitySendFormat value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    private static bool CanSendResponseBody(int responseCode);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    [NullableContextAttribute("2")]
public string get_RedirectLocation();
    [NullableContextAttribute("2")]
public void set_RedirectLocation(string value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public void AddHeader(string name, string value);
    public void AppendHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    private void ComputeCookies();
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
    private void CheckDisposed();
    private void CheckSentHeaders();
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public void Abort();
    public void Close();
    public void Close(Byte[] responseEntity, bool willBlock);
    private void Dispose();
    internal BoundaryType get_BoundaryType();
    [MemberNotNullAttribute("_responseStream")]
private void EnsureResponseStream();
    private void NonBlockingCloseCallback(IAsyncResult asyncResult);
    internal UInt32 SendHeaders(HTTP_DATA_CHUNK* pDataChunk, HttpResponseStreamAsyncResult asyncResult, HTTP_FLAGS flags, bool isWebSocketHandshake);
    internal HTTP_FLAGS ComputeHeaders();
    internal void ComputeCoreHeaders();
    private List`1<GCHandle> SerializeHeaders(HTTP_RESPONSE_HEADERS& headers, bool isWebSocketHandshake);
    private static void FreePinnedHeaders(List`1<GCHandle> pinnedHeaders);
    internal void CancelLastWrite(SafeHandle requestQueueHandle);
    internal bool get_ComputedHeaders();
    internal bool get_SentHeaders();
    private bool get_Disposed();
}
internal class System.Net.HttpListenerSession : object {
    public HttpListener Listener;
    public SafeHandle RequestQueueHandle;
    private ThreadPoolBoundHandle _requestQueueBoundHandle;
    public ThreadPoolBoundHandle RequestQueueBoundHandle { get; }
    public HttpListenerSession(HttpListener listener);
    public ThreadPoolBoundHandle get_RequestQueueBoundHandle();
    public void CloseRequestQueueHandle();
}
public class System.Net.HttpListenerTimeoutManager : object {
    private HttpListener _listener;
    private Int32[] _timeouts;
    private UInt32 _minSendBytesPerSecond;
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    internal HttpListenerTimeoutManager(HttpListener context);
    private TimeSpan GetTimeout(HTTP_TIMEOUT_TYPE type);
    private void SetTimespanTimeout(HTTP_TIMEOUT_TYPE type, TimeSpan value);
    public TimeSpan get_EntityBody();
    [SupportedOSPlatformAttribute("windows")]
public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    [SupportedOSPlatformAttribute("windows")]
public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    [SupportedOSPlatformAttribute("windows")]
public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    [SupportedOSPlatformAttribute("windows")]
public void set_MinSendBytesPerSecond(long value);
}
internal class System.Net.HttpRequestQueueV2Handle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.HttpRequestStream : Stream {
    private bool _closed;
    private HttpListenerContext _httpContext;
    private UInt32 _dataChunkOffset;
    private int _dataChunkIndex;
    private bool _inOpaqueMode;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Closed { get; }
    internal bool BufferedDataChunksAvailable { get; }
    internal HttpListenerContext InternalHttpContext { get; }
    internal HttpRequestStream(HttpListenerContext httpContext);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal bool get_Closed();
    protected virtual void Dispose(bool disposing);
    internal bool get_BufferedDataChunksAvailable();
    internal HttpListenerContext get_InternalHttpContext();
    private int ReadCore(Byte[] buffer, int offset, int size);
    private void UpdateAfterRead(UInt32 statusCode, UInt32 dataRead);
    public IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    internal void SwitchToOpaqueMode();
    internal UInt32 GetChunks(Byte[] buffer, int offset, int size);
}
internal class System.Net.HttpResponseStream : Stream {
    private bool _closed;
    private HttpListenerContext _httpContext;
    private long _leftToWrite;
    private bool _inOpaqueMode;
    private HttpResponseStreamAsyncResult _lastWrite;
    internal bool Closed { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpListenerContext InternalHttpContext { get; }
    private static ReadOnlySpan`1<byte> ChunkTerminator { get; }
    internal HttpResponseStream(HttpListenerContext httpContext);
    internal bool get_Closed();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    internal HTTP_FLAGS ComputeLeftToWrite();
    internal HttpListenerContext get_InternalHttpContext();
    internal void SetClosedFlag();
    private void WriteCore(Byte[] buffer, int offset, int size);
    private HttpResponseStreamAsyncResult BeginWriteCore(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    private void EndWriteCore(IAsyncResult asyncResult);
    private void UpdateAfterWrite(UInt32 dataWritten);
    private static ReadOnlySpan`1<byte> get_ChunkTerminator();
    private void DisposeCore();
    internal void SwitchToOpaqueMode();
    internal void CancelLastWrite(SafeHandle requestQueueHandle);
}
internal class System.Net.HttpResponseStreamAsyncResult : LazyAsyncResult {
    private ThreadPoolBoundHandle _boundHandle;
    internal NativeOverlapped* _pOverlapped;
    private HTTP_DATA_CHUNK[] _dataChunks;
    internal bool _sentHeaders;
    private static IOCompletionCallback s_IOCallback;
    private static Byte[] s_CRLFArray;
    internal ushort dataChunkCount { get; }
    internal HTTP_DATA_CHUNK* pDataChunks { get; }
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback);
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback, Byte[] buffer, int offset, int size, bool chunked, bool sentHeaders, ThreadPoolBoundHandle boundHandle);
    private static HttpResponseStreamAsyncResult();
    internal ushort get_dataChunkCount();
    internal HTTP_DATA_CHUNK* get_pDataChunks();
    private static Byte[] GetChunkHeader(int size, Int32& offset);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(HttpResponseStreamAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void Callback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    protected virtual void Cleanup();
}
internal class System.Net.HttpServerSessionHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private ulong _serverSessionId;
    internal HttpServerSessionHandle(ulong id);
    internal ulong DangerousGetServerSessionId();
    protected virtual bool ReleaseHandle();
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal class System.Net.ListenerAsyncResult : LazyAsyncResult {
    private static IOCompletionCallback s_ioCallback;
    private AsyncRequestContext _requestContext;
    internal static IOCompletionCallback IOCallback { get; }
    internal ListenerAsyncResult(HttpListenerSession session, object userState, AsyncCallback callback);
    private static ListenerAsyncResult();
    internal static IOCompletionCallback get_IOCallback();
    private static void IOCompleted(ListenerAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal UInt32 QueueBeginGetContext();
    protected virtual void Cleanup();
}
internal class System.Net.ListenerClientCertAsyncResult : LazyAsyncResult {
    private ThreadPoolBoundHandle _boundHandle;
    private NativeOverlapped* _pOverlapped;
    private Byte[] _backingBuffer;
    private HTTP_SSL_CLIENT_CERT_INFO* _memoryBlob;
    private UInt32 _size;
    private static IOCompletionCallback s_IOCallback;
    internal NativeOverlapped* NativeOverlapped { get; }
    internal HTTP_SSL_CLIENT_CERT_INFO* RequestBlob { get; }
    internal ListenerClientCertAsyncResult(ThreadPoolBoundHandle boundHandle, object asyncObject, object userState, AsyncCallback callback, UInt32 size);
    private static ListenerClientCertAsyncResult();
    internal NativeOverlapped* get_NativeOverlapped();
    internal HTTP_SSL_CLIENT_CERT_INFO* get_RequestBlob();
    internal void Reset(UInt32 size);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(ListenerClientCertAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    protected virtual void Cleanup();
    protected virtual override void Finalize();
}
internal enum System.Net.ListenerClientCertState : Enum {
    public int value__;
    public static ListenerClientCertState NotInitialized;
    public static ListenerClientCertState InProgress;
    public static ListenerClientCertState Completed;
}
internal class System.Net.ListenerPrefixEnumerator : object {
    private IEnumerator _enumerator;
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListenerPrefixEnumerator(IEnumerator enumerator);
    public sealed virtual string get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, ReadOnlySpan`1<byte> buffer, string memberName);
    [EventAttribute("4")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
}
internal abstract class System.Net.RequestContextBase : object {
    private HTTP_REQUEST* _memoryBlob;
    private HTTP_REQUEST* _originalBlobAddress;
    private IntPtr _backingBuffer;
    private int _backingBufferLength;
    internal HTTP_REQUEST* RequestBlob { get; }
    internal IntPtr RequestBuffer { get; }
    internal UInt32 Size { get; }
    internal IntPtr OriginalBlobAddress { get; }
    protected void BaseConstruction(HTTP_REQUEST* requestBlob);
    internal void ReleasePins();
    protected abstract virtual void OnReleasePins();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal HTTP_REQUEST* get_RequestBlob();
    internal IntPtr get_RequestBuffer();
    internal UInt32 get_Size();
    internal IntPtr get_OriginalBlobAddress();
    protected void SetBlob(HTTP_REQUEST* requestBlob);
    protected void UnsetBlob();
    protected void SetBuffer(int size);
}
internal class System.Net.ServiceNameStore : object {
    private List`1<string> _serviceNames;
    private ServiceNameCollection _serviceNameCollection;
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    private static string NormalizeServiceName(string inputServiceName);
    private bool AddSingleServiceName(string spn);
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    private bool Contains(string newServiceName);
    public void Clear();
    private static string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings);
    public static string BuildSimpleServiceName(string uriPrefix);
    public static String[] BuildServiceNames(string uriPrefix);
}
internal class System.Net.SyncRequestContext : RequestContextBase {
    internal SyncRequestContext(int size);
    private HTTP_REQUEST* Allocate(int newSize);
    internal void Reset(int size);
    protected virtual void OnReleasePins();
}
internal static class System.Net.WebHeaderEncoding : object {
    internal static string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal static int GetByteCount(string myString);
    internal static void GetBytes(string myString, int charIndex, int charCount, Byte[] bytes, int byteIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private Uri _requestUri;
    private NameValueCollection _headers;
    private CookieCollection _cookieCollection;
    private IPrincipal _user;
    private bool _isAuthenticated;
    private bool _isLocal;
    private bool _isSecureConnection;
    private string _origin;
    private IEnumerable`1<string> _secWebSocketProtocols;
    private string _secWebSocketVersion;
    private string _secWebSocketKey;
    private WebSocket _webSocket;
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
    private static IPrincipal CopyPrincipal(IPrincipal user);
}
internal static class System.Net.WebSockets.HttpWebSocket : object {
    [CompilerGeneratedAttribute]
private static bool <WebSocketsSupported>k__BackingField;
    private static string SupportedVersion { get; }
    private static bool WebSocketsSupported { get; }
    private static HttpWebSocket();
    internal static string GetSecWebSocketAcceptString(string secWebSocketKey);
    internal static bool ProcessWebSocketProtocolHeader(string clientSecWebSocketProtocol, string subProtocol, String& acceptProtocol);
    internal static void ValidateOptions(string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval);
    private static void ValidateWebSocketHeaders(HttpListenerContext context);
    internal static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    [AsyncStateMachineAttribute("System.Net.WebSockets.HttpWebSocket/<AcceptWebSocketAsyncCore>d__12")]
private static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsyncCore(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    private static ulong SendWebSocketHeaders(HttpListenerResponse response);
    internal static void ValidateInnerStream(Stream innerStream);
    internal static void ThrowIfConnectionAborted(Stream connection, bool read);
    [DoesNotReturnAttribute]
internal static void ThrowPlatformNotSupportedException_WSPC();
    private static string get_SupportedVersion();
    [CompilerGeneratedAttribute]
private static bool get_WebSocketsSupported();
}
internal class System.Net.WebSockets.SafeWebSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.WebSockets.ServerWebSocket : WebSocketBase {
    private SafeHandle _sessionHandle;
    private Property[] _properties;
    internal SafeHandle SessionHandle { get; }
    public ServerWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal static WebSocket Create(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal virtual SafeHandle get_SessionHandle();
    private SafeWebSocketHandle CreateWebSocketHandle();
}
internal abstract class System.Net.WebSockets.WebSocketBase : WebSocket {
    private OutstandingOperationHelper _closeOutstandingOperationHelper;
    private OutstandingOperationHelper _closeOutputOutstandingOperationHelper;
    private OutstandingOperationHelper _receiveOutstandingOperationHelper;
    private OutstandingOperationHelper _sendOutstandingOperationHelper;
    private Stream _innerStream;
    private IWebSocketStream _innerStreamAsWebSocketStream;
    private string _subProtocol;
    private SemaphoreSlim _sendFrameThrottle;
    private object _thisLock;
    private WebSocketBuffer _internalBuffer;
    private KeepAliveTracker _keepAliveTracker;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanedUp;
    private TaskCompletionSource modreq(System.Runtime.CompilerServices.IsVolatile) _closeReceivedTaskCompletionSource;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _closeOutputTask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _closeNetworkConnectionTask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closeAsyncStartedReceive;
    private WebSocketState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _keepAliveTask;
    private ReceiveOperation modreq(System.Runtime.CompilerServices.IsVolatile) _receiveOperation;
    private SendOperation modreq(System.Runtime.CompilerServices.IsVolatile) _sendOperation;
    private SendOperation modreq(System.Runtime.CompilerServices.IsVolatile) _keepAliveOperation;
    private CloseOutputOperation modreq(System.Runtime.CompilerServices.IsVolatile) _closeOutputOperation;
    private Nullable`1<WebSocketCloseStatus> _closeStatus;
    private string _closeStatusDescription;
    private int _receiveState;
    private Exception _pendingException;
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    internal WebSocketBuffer InternalBuffer { get; }
    internal SafeHandle SessionHandle { get; }
    protected WebSocketBase(Stream innerStream, string subProtocol, TimeSpan keepAliveInterval, WebSocketBuffer internalBuffer);
    public virtual WebSocketState get_State();
    public virtual string get_SubProtocol();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    internal WebSocketBuffer get_InternalBuffer();
    protected void StartKeepAliveTimer();
    internal abstract virtual SafeHandle get_SessionHandle();
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<ReceiveAsyncCore>d__42")]
private Task`1<WebSocketReceiveResult> ReceiveAsyncCore(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<SendAsyncCore>d__44")]
private Task SendAsyncCore(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<SendFrameAsync>d__45")]
private Task SendFrameAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public virtual void Abort();
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<CloseOutputAsyncCore>d__48")]
private Task CloseOutputAsyncCore(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    private bool OnCloseOutputCompleted();
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<StartOnCloseCompleted>d__50")]
private Task`1<bool> StartOnCloseCompleted(bool thisLockTakenSnapshot, bool sessionHandleLockTakenSnapshot, CancellationToken cancellationToken);
    private void FinishOnCloseCompleted();
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<CloseAsyncCore>d__53")]
private Task CloseAsyncCore(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Dispose();
    private static void ResetFlagAndTakeLock(object lockObject, Boolean& thisLockTaken);
    private void ResetFlagsAndTakeLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void TakeLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void ReleaseLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void EnsureReceiveOperation();
    private void EnsureSendOperation();
    private void EnsureKeepAliveOperation();
    private void EnsureCloseOutputOperation();
    private static void ReleaseLock(object lockObject, Boolean& lockTaken);
    private static BufferType GetBufferType(WebSocketMessageType messageType, bool endOfMessage);
    private static WebSocketMessageType GetMessageType(BufferType bufferType);
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    private void ThrowIfAborted(bool aborted, Exception innerException);
    private bool CanHandleExceptionDuringClose(Exception error);
    private void ThrowIfConvertibleException(string methodName, Exception exception, CancellationToken cancellationToken, bool aborted);
    private void CleanUp();
    private void OnBackgroundTaskException(Exception exception);
    private void ThrowIfPendingException();
    private void ThrowIfDisposed();
    private void UpdateReceiveState(int newReceiveState, int expectedReceiveState);
    private bool StartOnCloseReceived(Boolean& thisLockTaken);
    private void FinishOnCloseReceived(WebSocketCloseStatus closeStatus, string closeStatusDescription);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<OnKeepAlive>d__77")]
private static void OnKeepAlive(object sender);
}
internal class System.Net.WebSockets.WebSocketBuffer : object {
    private static int s_PropertyBufferSize;
    private int _receiveBufferSize;
    private long _startAddress;
    private long _endAddress;
    private GCHandle _gcHandle;
    private ArraySegment`1<byte> _internalBuffer;
    private ArraySegment`1<byte> _nativeBuffer;
    private ArraySegment`1<byte> _payloadBuffer;
    private ArraySegment`1<byte> _propertyBuffer;
    private int _sendBufferSize;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _payloadOffset;
    private PayloadReceiveResult modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedPayloadReceiveResult;
    private long _pinnedSendBufferStartAddress;
    private long _pinnedSendBufferEndAddress;
    private ArraySegment`1<byte> _pinnedSendBuffer;
    private GCHandle _pinnedSendBufferHandle;
    private int _stateWhenDisposing;
    private int _sendBufferState;
    public int ReceiveBufferSize { get; }
    public int SendBufferSize { get; }
    private WebSocketBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize, int sendBufferSize);
    private static WebSocketBuffer();
    public int get_ReceiveBufferSize();
    public int get_SendBufferSize();
    internal static WebSocketBuffer CreateServerBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize);
    public void Dispose(WebSocketState webSocketState);
    public sealed virtual void Dispose();
    internal Property[] CreateProperties(bool useZeroMaskingKey);
    internal void PinSendBuffer(ArraySegment`1<byte> payload, Boolean& bufferHasBeenPinned);
    internal IntPtr ConvertPinnedSendPayloadToNative(ArraySegment`1<byte> payload);
    internal IntPtr ConvertPinnedSendPayloadToNative(Byte[] buffer, int offset, int count);
    internal ArraySegment`1<byte> ConvertPinnedSendPayloadFromNative(Buffer buffer, BufferType bufferType);
    private bool IsPinnedSendPayloadBuffer(Byte[] buffer, int offset, int count);
    internal bool IsPinnedSendPayloadBuffer(Buffer buffer, BufferType bufferType);
    internal void ReleasePinnedSendBuffer();
    internal void BufferPayload(ArraySegment`1<byte> payload, int unconsumedDataOffset, WebSocketMessageType messageType, bool endOfMessage);
    internal bool ReceiveFromBufferedPayload(ArraySegment`1<byte> buffer, WebSocketReceiveResult& receiveResult);
    internal ArraySegment`1<byte> ConvertNativeBuffer(Buffer buffer, BufferType bufferType);
    internal void ConvertCloseBuffer(Buffer buffer, WebSocketCloseStatus& closeStatus, String& reason);
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    private static int GetNativeSendBufferSize(int sendBufferSize, bool isServerBuffer);
    internal static void UnwrapWebSocketBuffer(Buffer buffer, BufferType bufferType, IntPtr& bufferData, UInt32& bufferLength);
    private void ThrowIfDisposed();
    private int GetOffset(IntPtr pBuffer);
    private int GetMaxBufferSize();
    internal bool IsInternalBuffer(Byte[] buffer, int offset, int count);
    internal IntPtr ToIntPtr(int offset);
    private bool IsNativeBuffer(IntPtr pBuffer, UInt32 bufferSize);
    private void CleanUp();
    internal static ArraySegment`1<byte> CreateInternalBufferArraySegment(int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
    internal static void Validate(int count, int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
    private static int GetInternalBufferSize(int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
}
internal class System.Net.WebSockets.WebSocketHttpListenerDuplexStream : Stream {
    private static EventHandler`1<HttpListenerAsyncEventArgs> s_OnReadCompleted;
    private static EventHandler`1<HttpListenerAsyncEventArgs> s_OnWriteCompleted;
    private static Func`2<Exception, bool> s_CanHandleException;
    private static Action`1<object> s_OnCancel;
    private HttpRequestStream _inputStream;
    private HttpResponseStream _outputStream;
    private HttpListenerContext _context;
    private bool _inOpaqueMode;
    private WebSocketBase _webSocket;
    private HttpListenerAsyncEventArgs _writeEventArgs;
    private HttpListenerAsyncEventArgs _readEventArgs;
    private TaskCompletionSource _writeTaskCompletionSource;
    private TaskCompletionSource`1<int> _readTaskCompletionSource;
    private int _cleanedUp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool SupportsMultipleWrite { get; }
    public WebSocketHttpListenerDuplexStream(HttpRequestStream inputStream, HttpResponseStream outputStream, HttpListenerContext context);
    private static WebSocketHttpListenerDuplexStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<ReadAsyncCore>d__30")]
private Task`1<int> ReadAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool ReadAsyncFast(HttpListenerAsyncEventArgs eventArgs);
    public virtual int ReadByte();
    public sealed virtual bool get_SupportsMultipleWrite();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public sealed virtual Task MultipleWriteAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<MultipleWriteAsyncCore>d__38")]
private Task MultipleWriteAsyncCore(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<WriteAsyncCore>d__41")]
private Task WriteAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool WriteAsyncFast(HttpListenerAsyncEventArgs eventArgs);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<CloseNetworkConnectionAsync>d__50")]
public sealed virtual Task CloseNetworkConnectionAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Abort();
    private static bool CanHandleException(Exception error);
    private static void OnCancel(object state);
    public sealed virtual void SwitchToOpaqueMode(WebSocketBase webSocket);
    private static void OnWriteCompleted(object sender, HttpListenerAsyncEventArgs eventArgs);
    private static void OnReadCompleted(object sender, HttpListenerAsyncEventArgs eventArgs);
}
internal static class System.Net.WebSockets.WebSocketProtocolComponent : object {
    private static IntPtr s_webSocketDllHandle;
    private static string s_supportedVersion;
    private static HttpHeader[] s_initialClientRequestHeaders;
    private static HttpHeader[] s_serverFakeRequestHeaders;
    internal static string SupportedVersion { get; }
    internal static bool IsSupported { get; }
    private static WebSocketProtocolComponent();
    internal static string get_SupportedVersion();
    internal static bool get_IsSupported();
    internal static string GetSupportedVersion();
    internal static SafeWebSocketHandle WebSocketCreateServerHandle(Property[] properties, int propertyCount);
    internal static void WebSocketAbortHandle(SafeHandle webSocketHandle);
    internal static void WebSocketDeleteHandle(IntPtr webSocketPtr);
    internal static void WebSocketSend(WebSocketBase webSocket, BufferType bufferType, Buffer buffer);
    internal static void WebSocketSendWithoutBody(WebSocketBase webSocket, BufferType bufferType);
    internal static void WebSocketReceive(WebSocketBase webSocket);
    internal static void WebSocketGetAction(WebSocketBase webSocket, ActionQueue actionQueue, Buffer[] dataBuffers, UInt32& dataBufferCount, Action& action, BufferType& bufferType, IntPtr& actionContext);
    internal static void WebSocketCompleteAction(WebSocketBase webSocket, IntPtr actionContext, int bytesTransferred);
    private static void DrainActionQueue(SafeHandle webSocketHandle, ActionQueue actionQueue);
    private static HttpHeader MarshalAndVerifyHttpHeader(WEB_SOCKET_HTTP_HEADER* httpHeaderPtr);
    public static bool Succeeded(int hr);
    private static void ThrowOnError(int errorCode);
    private static void ThrowIfSessionHandleClosed(WebSocketBase webSocket);
    private static WebSocketException ConvertObjectDisposedException(WebSocketBase webSocket, ObjectDisposedException innerException);
}
internal static class System.Net.WebSockets.WebSocketValidate : object {
    private static SearchValues`1<char> s_validSubprotocolChars;
    private static WebSocketValidate();
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription);
    internal static void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName);
    internal static void ValidateBuffer(Byte[] buffer, int offset, int count);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_log_listener_delegate_exception { get; }
    internal static string net_log_listener_unsupported_authentication_scheme { get; }
    internal static string net_log_listener_unmatched_authentication_scheme { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_listener_cannot_set_custom_cbt { get; }
    internal static string net_listener_detach_error { get; }
    internal static string net_listener_scheme { get; }
    internal static string net_listener_host { get; }
    internal static string net_listener_mustcall { get; }
    internal static string net_listener_slash { get; }
    internal static string net_listener_already { get; }
    internal static string net_log_listener_no_cbt_disabled { get; }
    internal static string net_log_listener_no_cbt_http { get; }
    internal static string net_log_listener_no_cbt_trustedproxy { get; }
    internal static string net_log_listener_cbt { get; }
    internal static string net_log_listener_spn_add { get; }
    internal static string net_log_listener_spn_not_add { get; }
    internal static string net_log_listener_spn_remove { get; }
    internal static string net_log_listener_spn_not_remove { get; }
    internal static string net_listener_no_spns { get; }
    internal static string net_ssp_dont_support_cbt { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_array_too_small { get; }
    internal static string net_listener_mustcompletecall { get; }
    internal static string net_listener_invalid_cbt_type { get; }
    internal static string net_listener_callinprogress { get; }
    internal static string net_log_listener_cant_create_uri { get; }
    internal static string net_log_listener_cant_convert_raw_path { get; }
    internal static string net_log_listener_cant_convert_percent_value { get; }
    internal static string net_log_listener_cant_convert_to_utf8 { get; }
    internal static string net_log_listener_cant_convert_bytes { get; }
    internal static string net_invalidstatus { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_rspsubmitted { get; }
    internal static string net_nochunkuploadonhttp10 { get; }
    internal static string net_cookie_exists { get; }
    internal static string net_wrongversion { get; }
    internal static string net_noseek { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_entitytoobig { get; }
    internal static string net_io_notenoughbyteswritten { get; }
    internal static string net_listener_close_urlgroup_error { get; }
    internal static string net_WebSockets_NativeSendResponseHeaders { get; }
    internal static string net_WebSockets_ClientAcceptingNoProtocols { get; }
    internal static string net_WebSockets_AcceptUnsupportedProtocol { get; }
    internal static string net_WebSockets_AcceptNotAWebSocket { get; }
    internal static string net_WebSockets_AcceptHeaderNotFound { get; }
    internal static string net_WebSockets_AcceptUnsupportedWebSocketVersion { get; }
    internal static string net_WebSockets_InvalidCharInProtocolString { get; }
    internal static string net_WebSockets_ReasonNotNull { get; }
    internal static string net_WebSockets_InvalidCloseStatusCode { get; }
    internal static string net_WebSockets_InvalidCloseStatusDescription { get; }
    internal static string net_WebSockets_UnsupportedPlatform { get; }
    internal static string net_readonlystream { get; }
    internal static string net_WebSockets_InvalidState_ClosedOrAborted { get; }
    internal static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync { get; }
    internal static string net_Websockets_AlreadyOneOutstandingOperation { get; }
    internal static string net_WebSockets_InvalidMessageType { get; }
    internal static string net_WebSockets_InvalidBufferType { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_InternalBuffer { get; }
    internal static string net_WebSockets_Argument_InvalidMessageType { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_log_listener_delegate_exception();
    internal static string get_net_log_listener_unsupported_authentication_scheme();
    internal static string get_net_log_listener_unmatched_authentication_scheme();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_listener_cannot_set_custom_cbt();
    internal static string get_net_listener_detach_error();
    internal static string get_net_listener_scheme();
    internal static string get_net_listener_host();
    internal static string get_net_listener_mustcall();
    internal static string get_net_listener_slash();
    internal static string get_net_listener_already();
    internal static string get_net_log_listener_no_cbt_disabled();
    internal static string get_net_log_listener_no_cbt_http();
    internal static string get_net_log_listener_no_cbt_trustedproxy();
    internal static string get_net_log_listener_cbt();
    internal static string get_net_log_listener_spn_add();
    internal static string get_net_log_listener_spn_not_add();
    internal static string get_net_log_listener_spn_remove();
    internal static string get_net_log_listener_spn_not_remove();
    internal static string get_net_listener_no_spns();
    internal static string get_net_ssp_dont_support_cbt();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_array_too_small();
    internal static string get_net_listener_mustcompletecall();
    internal static string get_net_listener_invalid_cbt_type();
    internal static string get_net_listener_callinprogress();
    internal static string get_net_log_listener_cant_create_uri();
    internal static string get_net_log_listener_cant_convert_raw_path();
    internal static string get_net_log_listener_cant_convert_percent_value();
    internal static string get_net_log_listener_cant_convert_to_utf8();
    internal static string get_net_log_listener_cant_convert_bytes();
    internal static string get_net_invalidstatus();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_rspsubmitted();
    internal static string get_net_nochunkuploadonhttp10();
    internal static string get_net_cookie_exists();
    internal static string get_net_wrongversion();
    internal static string get_net_noseek();
    internal static string get_net_writeonlystream();
    internal static string get_net_entitytoobig();
    internal static string get_net_io_notenoughbyteswritten();
    internal static string get_net_listener_close_urlgroup_error();
    internal static string get_net_WebSockets_NativeSendResponseHeaders();
    internal static string get_net_WebSockets_ClientAcceptingNoProtocols();
    internal static string get_net_WebSockets_AcceptUnsupportedProtocol();
    internal static string get_net_WebSockets_AcceptNotAWebSocket();
    internal static string get_net_WebSockets_AcceptHeaderNotFound();
    internal static string get_net_WebSockets_AcceptUnsupportedWebSocketVersion();
    internal static string get_net_WebSockets_InvalidCharInProtocolString();
    internal static string get_net_WebSockets_ReasonNotNull();
    internal static string get_net_WebSockets_InvalidCloseStatusCode();
    internal static string get_net_WebSockets_InvalidCloseStatusDescription();
    internal static string get_net_WebSockets_UnsupportedPlatform();
    internal static string get_net_readonlystream();
    internal static string get_net_WebSockets_InvalidState_ClosedOrAborted();
    internal static string get_net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync();
    internal static string get_net_Websockets_AlreadyOneOutstandingOperation();
    internal static string get_net_WebSockets_InvalidMessageType();
    internal static string get_net_WebSockets_InvalidBufferType();
    internal static string get_net_WebSockets_ArgumentOutOfRange_InternalBuffer();
    internal static string get_net_WebSockets_Argument_InvalidMessageType();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
