internal static class FXAssembly : object {
    internal static string Version;
}
internal class Microsoft.Build.BackEnd.AssemblyTaskFactory : object {
    public string FactoryName { get; }
    public Type TaskType { get; }
    public sealed virtual string get_FactoryName();
    public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary`2<string, string> taskIdentityParameters);
    public sealed virtual void CleanupTask(ITask task);
    internal LoadedType InitializeFactory(AssemblyLoadInfo loadInfo, string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IDictionary`2<string, string> taskFactoryIdentityParameters, bool taskHostFactoryExplicitlyRequested, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, string taskProjectFile);
    internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskIdentityParameters, AppDomainSetup appDomainSetup, bool isOutOfProc);
    internal bool TaskNameCreatableByFactory(string taskName, IDictionary`2<string, string> taskIdentityParameters, string taskProjectFile, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
}
internal static class Microsoft.Build.BackEnd.BatchingEngine : object {
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, ElementLocation elementLocation);
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, string implicitBatchableItemType, ElementLocation elementLocation);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryCollection : object {
    public BuildComponentFactoryCollection(IBuildComponentHost host);
    public void RegisterDefaultFactories();
    public void ShutdownComponents();
    public void ShutdownComponent(BuildComponentType componentType);
    public void ReplaceFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    public void ReplaceFactory(BuildComponentType componentType, IBuildComponent instance);
    public void AddFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory, CreationPattern creationPattern);
    public IBuildComponent GetComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryDelegate : MulticastDelegate {
    public BuildComponentFactoryDelegate(object object, IntPtr method);
    public virtual IBuildComponent Invoke(BuildComponentType type);
    public virtual IAsyncResult BeginInvoke(BuildComponentType type, AsyncCallback callback, object object);
    public virtual IBuildComponent EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.BuildComponentType : Enum {
    public int value__;
    public static BuildComponentType RequestManager;
    public static BuildComponentType Scheduler;
    public static BuildComponentType ResultsCache;
    public static BuildComponentType PropertyCache;
    public static BuildComponentType ConfigCache;
    public static BuildComponentType NodeManager;
    public static BuildComponentType InProcNodeProvider;
    public static BuildComponentType OutOfProcNodeProvider;
    public static BuildComponentType RemoteNodeProvider;
    public static BuildComponentType NodePacketFactory;
    public static BuildComponentType RequestEngine;
    public static BuildComponentType FileMonitor;
    public static BuildComponentType NodeEndpoint;
    public static BuildComponentType LoggingService;
    public static BuildComponentType RequestBuilder;
    public static BuildComponentType TargetBuilder;
    public static BuildComponentType TaskBuilder;
    public static BuildComponentType TestDataProvider;
    public static BuildComponentType OutOfProcTaskHostNodeProvider;
    public static BuildComponentType TaskHostNodeManager;
    public static BuildComponentType RegisteredTaskObjectCache;
}
internal class Microsoft.Build.BackEnd.BuildRequest : object {
    public static int InvalidGlobalRequestId;
    public static int InvalidNodeRequestId;
    public static int ResultsTransferNodeRequestId;
    public bool IsConfigurationResolved { get; }
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int GlobalRequestId { get; public set; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; public set; }
    public List`1<string> Targets { get; }
    public NodePacketType Type { get; }
    public BuildEventContext ParentBuildEventContext { get; }
    public BuildEventContext BuildEventContext { get; public set; }
    public BuildRequestDataFlags BuildRequestDataFlags { get; public set; }
    internal HostServices HostServices { get; }
    internal bool IsRootRequest { get; }
    public BuildRequest(int submissionId, int nodeRequestId, int configurationId, ICollection`1<string> escapedTargets, HostServices hostServices, BuildEventContext parentBuildEventContext, BuildRequest parentRequest, BuildRequestDataFlags buildRequestDataFlags);
    [DebuggerStepThroughAttribute]
public bool get_IsConfigurationResolved();
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    public void set_GlobalRequestId(int value);
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public void set_NodeRequestId(int value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_Targets();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_ParentBuildEventContext();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    public void set_BuildEventContext(BuildEventContext value);
    public BuildRequestDataFlags get_BuildRequestDataFlags();
    public void set_BuildRequestDataFlags(BuildRequestDataFlags value);
    [DebuggerStepThroughAttribute]
internal HostServices get_HostServices();
    [DebuggerStepThroughAttribute]
internal bool get_IsRootRequest();
    public void ResolveConfiguration(int newConfigId);
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal bool DoesResultApplyToRequest(BuildResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestBlockedDelegate : MulticastDelegate {
    public BuildRequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry sourceEntry, int blockingGlobalRequestId, string blockingTarget);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry sourceEntry, int blockingGlobalRequestId, string blockingTarget, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestBlocker : object {
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public String[] TargetsInProgress { get; }
    public int BlockingRequestId { get; }
    public string BlockingTarget { get; }
    public BuildRequest[] BuildRequests { get; }
    public YieldAction YieldAction { get; }
    internal BuildRequestBlocker(INodePacketTranslator translator);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, int blockingGlobalRequestId, string blockingTarget);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, BuildRequest[] buildRequests);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, YieldAction action);
    internal BuildRequestBlocker(int blockedGlobalRequestId);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public String[] get_TargetsInProgress();
    [DebuggerStepThroughAttribute]
public int get_BlockingRequestId();
    [DebuggerStepThroughAttribute]
public string get_BlockingTarget();
    [DebuggerStepThroughAttribute]
public BuildRequest[] get_BuildRequests();
    [DebuggerStepThroughAttribute]
public YieldAction get_YieldAction();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestCompletedDelegate : MulticastDelegate {
    public BuildRequestCompletedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry completedEntry);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry completedEntry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfiguration : object {
    public static int InvalidConfigurationId;
    public bool IsCacheable { get; public set; }
    public bool ExplicitlyLoaded { get; public set; }
    public bool IsActivelyBuilding { get; }
    public bool IsLoaded { get; }
    public bool IsCached { get; private set; }
    public bool IsTraversal { get; }
    public bool WasGeneratedByNode { get; }
    public int ConfigurationId { get; public set; }
    public string ProjectFullPath { get; }
    public string ToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> Properties { get; }
    public ProjectInstance Project { get; public set; }
    public bool HasTargetsResolved { get; }
    public List`1<string> ProjectInitialTargets { get; public set; }
    public List`1<string> ProjectDefaultTargets { get; public set; }
    public NodePacketType Type { get; }
    public Lookup BaseLookup { get; }
    public Dictionary`2<string, int> ActivelyBuildingTargets { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public bool ExplicitToolsVersionSpecified { get; }
    internal int ResultsNodeId { get; internal set; }
    internal BuildRequestConfiguration(BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, ProjectInstance instance);
    [CompilerGeneratedAttribute]
public bool get_IsCacheable();
    [CompilerGeneratedAttribute]
public void set_IsCacheable(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitlyLoaded();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyLoaded(bool value);
    public bool get_IsActivelyBuilding();
    public bool get_IsLoaded();
    [CompilerGeneratedAttribute]
public bool get_IsCached();
    [CompilerGeneratedAttribute]
private void set_IsCached(bool value);
    public bool get_IsTraversal();
    [DebuggerStepThroughAttribute]
public bool get_WasGeneratedByNode();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public void set_ConfigurationId(int value);
    [DebuggerStepThroughAttribute]
public string get_ProjectFullPath();
    [DebuggerStepThroughAttribute]
public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public PropertyDictionary`1<ProjectPropertyInstance> get_Properties();
    [DebuggerStepThroughAttribute]
public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public void set_Project(ProjectInstance value);
    public bool get_HasTargetsResolved();
    [DebuggerStepThroughAttribute]
public List`1<string> get_ProjectInitialTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectInitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_ProjectDefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectDefaultTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public Lookup get_BaseLookup();
    public Dictionary`2<string, int> get_ActivelyBuildingTargets();
    public Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public string get_SavedCurrentDirectory();
    public void set_SavedCurrentDirectory(string value);
    [DebuggerStepThroughAttribute]
public bool get_ExplicitToolsVersionSpecified();
    internal int get_ResultsNodeId();
    internal void set_ResultsNodeId(int value);
    public static bool op_Equality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public static bool op_Inequality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public void CacheIfPossible();
    public void RetrieveFromCache();
    public List`1<string> GetTargetsUsedToBuildRequest(BuildRequest request);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildRequestConfiguration other);
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal void ApplyTransferredState(ProjectInstance instance);
    internal string GetCacheFile();
    internal void ClearCacheFile();
    internal BuildRequestConfiguration ShallowCloneWithNewId(int newId);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfigurationResponse : object {
    public int NodeConfigurationId { get; }
    public int GlobalConfigurationId { get; }
    public int ResultsNodeId { get; }
    public NodePacketType Type { get; }
    public BuildRequestConfigurationResponse(int nodeConfigId, int globalConfigId, int resultsNodeId);
    public int get_NodeConfigurationId();
    public int get_GlobalConfigurationId();
    public int get_ResultsNodeId();
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestEngine : object {
    public BuildRequestEngineStatus Status { get; }
    public sealed virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    public sealed virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    public sealed virtual void add_OnRequestResumed(RequestResumedDelegate value);
    public sealed virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    public sealed virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    public sealed virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    public sealed virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    public sealed virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    public sealed virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    public sealed virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    public sealed virtual void add_OnEngineException(EngineExceptionDelegate value);
    public sealed virtual void remove_OnEngineException(EngineExceptionDelegate value);
    public sealed virtual BuildRequestEngineStatus get_Status();
    public sealed virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public sealed virtual void CleanupForBuild();
    public sealed virtual void SubmitBuildRequest(BuildRequest request);
    public sealed virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public sealed virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal enum Microsoft.Build.BackEnd.BuildRequestEngineStatus : Enum {
    public int value__;
    public static BuildRequestEngineStatus Uninitialized;
    public static BuildRequestEngineStatus Idle;
    public static BuildRequestEngineStatus Active;
    public static BuildRequestEngineStatus Waiting;
    public static BuildRequestEngineStatus Shutdown;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntry : object {
    public object GlobalLock { get; }
    public string ProjectRootDirectory { get; }
    public BuildRequestEntryState State { get; }
    public BuildRequest Request { get; }
    public BuildRequestConfiguration RequestConfiguration { get; }
    public BuildResult Result { get; }
    public IRequestBuilder Builder { get; public set; }
    internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration requestConfiguration);
    public void add_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    public void remove_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    [DebuggerStepThroughAttribute]
public object get_GlobalLock();
    public string get_ProjectRootDirectory();
    [DebuggerStepThroughAttribute]
public BuildRequestEntryState get_State();
    [DebuggerStepThroughAttribute]
public BuildRequest get_Request();
    [DebuggerStepThroughAttribute]
public BuildRequestConfiguration get_RequestConfiguration();
    [DebuggerStepThroughAttribute]
public BuildResult get_Result();
    [DebuggerStepThroughAttribute]
public IRequestBuilder get_Builder();
    [DebuggerStepThroughAttribute]
public void set_Builder(IRequestBuilder value);
    public void WaitForConfiguration(BuildRequestConfiguration configuration);
    public void WaitForResult(BuildRequest newRequest);
    public void WaitForBlockingRequest(int blockingGlobalRequestId);
    public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId);
    public List`1<BuildRequest> GetRequestsToIssueIfReady();
    public List`1<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue();
    public String[] GetActiveTargets();
    public void ReportResult(BuildResult result);
    public void Unblock();
    public IDictionary`2<int, BuildResult> Continue();
    public void Cancel();
    public void Complete(BuildResult result);
}
internal enum Microsoft.Build.BackEnd.BuildRequestEntryState : Enum {
    public int value__;
    public static BuildRequestEntryState Active;
    public static BuildRequestEntryState Ready;
    public static BuildRequestEntryState Waiting;
    public static BuildRequestEntryState Complete;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntryStateChangedDelegate : MulticastDelegate {
    public BuildRequestEntryStateChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry entry, BuildRequestEntryState newState);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry entry, BuildRequestEntryState newState, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestUnblocker : object {
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public BuildResult Result { get; }
    internal BuildRequestUnblocker(INodePacketTranslator translator);
    internal BuildRequestUnblocker(int globalRequestIdToResume);
    internal BuildRequestUnblocker(BuildResult buildResult);
    internal BuildRequestUnblocker(BuildRequest parentRequest, BuildResult buildResult);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public BuildResult get_Result();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
[RunInMTAAttribute]
internal class Microsoft.Build.BackEnd.CallTarget : object {
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    public String[] get_Targets();
    public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    public bool get_RunEachTargetSeparately();
    public void set_RunEachTargetSeparately(bool value);
    public bool get_UseResultsCache();
    public void set_UseResultsCache(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    public TaskLoggingHelper get_Log();
    public sealed virtual bool Execute();
    public Task`1<bool> ExecuteInternal();
}
internal class Microsoft.Build.BackEnd.CircularDependencyException : Exception {
    protected CircularDependencyException(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache {
    public abstract virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public abstract virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public abstract virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public abstract virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache : RegisteredTaskObjectCacheBase {
    protected virtual void Finalize();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase : object {
    private static RegisteredTaskObjectCacheBase();
    public sealed virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    protected bool IsCollectionEmptyOrUncreated(RegisteredTaskObjectLifetime lifetime);
    protected ConcurrentDictionary`2<object, object> GetCollectionForLifetime(RegisteredTaskObjectLifetime lifetime, bool dontCreate);
    protected Lazy`1<ConcurrentDictionary`2<object, object>> GetLazyCollectionForLifetime(RegisteredTaskObjectLifetime lifetime);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.BackEnd.ConfigCache : object {
    public BuildRequestConfiguration Item { get; }
    public sealed virtual BuildRequestConfiguration get_Item(int configId);
    public sealed virtual void AddConfiguration(BuildRequestConfiguration config);
    public sealed virtual void RemoveConfiguration(int configId);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public sealed virtual bool HasConfiguration(int configId);
    public sealed virtual void ClearConfigurations();
    public sealed virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public sealed virtual bool IsConfigCacheSizeLargerThanThreshold();
    public sealed virtual bool WriteConfigurationsToDisk();
    public sealed virtual IEnumerator`1<BuildRequestConfiguration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    protected int GetKeyForConfiguration(BuildRequestConfiguration config);
}
internal class Microsoft.Build.BackEnd.ConfigCreateCallback : MulticastDelegate {
    public ConfigCreateCallback(object object, IntPtr method);
    public virtual BuildRequestConfiguration Invoke(BuildRequestConfiguration existingConfiguration, bool loadProject);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration existingConfiguration, bool loadProject, AsyncCallback callback, object object);
    public virtual BuildRequestConfiguration EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ConfigurationMetadata : object {
    public string ProjectFullPath { get; private set; }
    public string ToolsVersion { get; private set; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalProperties { get; private set; }
    public ConfigurationMetadata(BuildRequestConfiguration configuration);
    public ConfigurationMetadata(Project project);
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
private void set_ProjectFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
private void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public PropertyDictionary`1<ProjectPropertyInstance> get_GlobalProperties();
    [CompilerGeneratedAttribute]
private void set_GlobalProperties(PropertyDictionary`1<ProjectPropertyInstance> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConfigurationMetadata other);
}
internal enum Microsoft.Build.BackEnd.ContinueOnError : Enum {
    public int value__;
    public static ContinueOnError ErrorAndStop;
    public static ContinueOnError ErrorAndContinue;
    public static ContinueOnError WarnAndContinue;
}
internal class Microsoft.Build.BackEnd.DataReceivedDelegate : MulticastDelegate {
    public DataReceivedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, INodePacket packet);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, INodePacket packet, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.DependencyAnalysisLogDetail : object {
    internal OutofdateReason Reason { get; }
    public string InputItemName { get; }
    public string OutputItemName { get; }
    public string Input { get; }
    public string Output { get; }
    public DependencyAnalysisLogDetail(string input, string output, string inputItemName, string outputItemName, OutofdateReason reason);
    internal OutofdateReason get_Reason();
    public string get_InputItemName();
    public string get_OutputItemName();
    public string get_Input();
    public string get_Output();
}
internal enum Microsoft.Build.BackEnd.DependencyAnalysisResult : Enum {
    public int value__;
    public static DependencyAnalysisResult SkipUpToDate;
    public static DependencyAnalysisResult SkipNoInputs;
    public static DependencyAnalysisResult SkipNoOutputs;
    public static DependencyAnalysisResult IncrementalBuild;
    public static DependencyAnalysisResult FullBuild;
}
internal class Microsoft.Build.BackEnd.EngineExceptionDelegate : MulticastDelegate {
    public EngineExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.EngineStatusChangedDelegate : MulticastDelegate {
    public EngineStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEngineStatus newStatus);
    public virtual IAsyncResult BeginInvoke(BuildRequestEngineStatus newStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.FullTracking : object {
    public sealed virtual void Dispose();
    internal static IDisposable Track(string targetName, string taskName, string projectRootDirectory, PropertyDictionary`1<ProjectPropertyInstance> projectProperties);
    internal static IDisposable Suspend();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.FullyQualifiedBuildRequest : object {
    public BuildRequestConfiguration Config { get; }
    public String[] Targets { get; }
    public bool ResultsNeeded { get; }
    public FullyQualifiedBuildRequest(BuildRequestConfiguration config, String[] targets, bool resultsNeeded);
    public BuildRequestConfiguration get_Config();
    public String[] get_Targets();
    public bool get_ResultsNeeded();
    public static bool op_Equality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public static bool op_Inequality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal interface Microsoft.Build.BackEnd.IBuildComponent {
    public abstract virtual void InitializeComponent(IBuildComponentHost host);
    public abstract virtual void ShutdownComponent();
}
internal interface Microsoft.Build.BackEnd.IBuildComponentHost {
    public string Name { get; }
    public BuildParameters BuildParameters { get; }
    public LegacyThreadingData LegacyThreadingData { get; }
    public ILoggingService LoggingService { get; }
    public abstract virtual string get_Name();
    public abstract virtual BuildParameters get_BuildParameters();
    public abstract virtual LegacyThreadingData get_LegacyThreadingData();
    public abstract virtual ILoggingService get_LoggingService();
    public abstract virtual void RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    public abstract virtual IBuildComponent GetComponent(BuildComponentType type);
}
internal interface Microsoft.Build.BackEnd.IBuildRequestEngine {
    public BuildRequestEngineStatus Status { get; }
    public abstract virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    public abstract virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    public abstract virtual void add_OnRequestResumed(RequestResumedDelegate value);
    public abstract virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    public abstract virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    public abstract virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    public abstract virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    public abstract virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    public abstract virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    public abstract virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    public abstract virtual void add_OnEngineException(EngineExceptionDelegate value);
    public abstract virtual void remove_OnEngineException(EngineExceptionDelegate value);
    public abstract virtual BuildRequestEngineStatus get_Status();
    public abstract virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public abstract virtual void CleanupForBuild();
    public abstract virtual void SubmitBuildRequest(BuildRequest request);
    public abstract virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public abstract virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IBuildResults {
    public Exception Exception { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public ITargetResult Item { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual BuildResultCode get_OverallResult();
    public abstract virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public abstract virtual Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public abstract virtual void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public abstract virtual string get_SavedCurrentDirectory();
    public abstract virtual void set_SavedCurrentDirectory(string value);
    public abstract virtual ITargetResult get_Item(string target);
    public abstract virtual bool HasResultsForTarget(string target);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IConfigCache {
    public BuildRequestConfiguration Item { get; }
    public abstract virtual BuildRequestConfiguration get_Item(int configId);
    public abstract virtual void AddConfiguration(BuildRequestConfiguration config);
    public abstract virtual void RemoveConfiguration(int configId);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public abstract virtual bool HasConfiguration(int configId);
    public abstract virtual void ClearConfigurations();
    public abstract virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public abstract virtual bool IsConfigCacheSizeLargerThanThreshold();
    public abstract virtual bool WriteConfigurationsToDisk();
}
internal interface Microsoft.Build.BackEnd.INode {
    public abstract virtual NodeEngineShutdownReason Run(Exception& shutdownException);
}
internal interface Microsoft.Build.BackEnd.INodeEndpoint {
    public LinkStatus LinkStatus { get; }
    public abstract virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public abstract virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public abstract virtual LinkStatus get_LinkStatus();
    public abstract virtual void Listen(INodePacketFactory factory);
    public abstract virtual void Connect(INodePacketFactory factory);
    public abstract virtual void Disconnect();
    public abstract virtual void SendData(INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodeManager {
    public abstract virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity affinity);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownNodes(bool enableReuse);
    public abstract virtual void ClearPerBuildState();
}
internal interface Microsoft.Build.BackEnd.INodePacket {
    public NodePacketType Type { get; }
    public abstract virtual NodePacketType get_Type();
}
internal interface Microsoft.Build.BackEnd.INodePacketFactory {
    public abstract virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public abstract virtual void UnregisterPacketHandler(NodePacketType packetType);
    public abstract virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public abstract virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodePacketHandler {
    public abstract virtual void PacketReceived(int node, INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodePacketTranslatable {
    public abstract virtual void Translate(INodePacketTranslator translator);
}
internal interface Microsoft.Build.BackEnd.INodePacketTranslator {
    public TranslationDirection Mode { get; }
    public BinaryReader Reader { get; }
    public BinaryWriter Writer { get; }
    public abstract virtual TranslationDirection get_Mode();
    public abstract virtual BinaryReader get_Reader();
    public abstract virtual BinaryWriter get_Writer();
    public abstract virtual void Translate(Boolean& value);
    public abstract virtual void Translate(Byte& value);
    public abstract virtual void Translate(Int16& value);
    public abstract virtual void Translate(UInt16& value);
    public abstract virtual void Translate(Int32& value);
    public abstract virtual void Translate(String& value);
    public abstract virtual void Translate(String[]& array);
    public abstract virtual void Translate(List`1& list);
    public abstract virtual void Translate(List`1& list, NodePacketValueFactory`1<T> factory);
    public abstract virtual void Translate(DateTime& value);
    public abstract virtual void Translate(BuildEventContext& value);
    public abstract virtual void TranslateEnum(T& value, int numericValue);
    public abstract virtual void TranslateDotNet(T& value);
    public abstract virtual void Translate(T& value);
    public abstract virtual void Translate(T& value, NodePacketValueFactory`1<T> factory);
    public abstract virtual void TranslateCulture(CultureInfo& culture);
    public abstract virtual void Translate(Byte[]& byteArray);
    public abstract virtual void TranslateArray(T[]& array);
    public abstract virtual void TranslateArray(T[]& array, NodePacketValueFactory`1<T> factory);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer, NodePacketValueFactory`1<T> valueFactory);
    public abstract virtual void TranslateDictionary(D& dictionary, NodePacketValueFactory`1<T> valueFactory);
    public abstract virtual void TranslateDictionary(D& dictionary, NodePacketValueFactory`1<T> valueFactory, NodePacketDictionaryCreator`1<D> dictionaryCreator);
    public abstract virtual bool TranslateNullable(T value);
}
internal interface Microsoft.Build.BackEnd.INodeProvider {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    public abstract virtual NodeProviderType get_ProviderType();
    public abstract virtual int get_AvailableNodes();
    public abstract virtual bool CreateNode(int nodeId, INodePacketFactory packetFactory, NodeConfiguration configuration);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownNodes(bool enableReuse);
}
internal class Microsoft.Build.BackEnd.InProcNode : object {
    public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEndpoint);
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal abstract class Microsoft.Build.BackEnd.IntrinsicTask : object {
    internal TargetLoggingContext LoggingContext { get; private set; }
    internal ProjectInstance Project { get; private set; }
    protected IntrinsicTask(TargetLoggingContext loggingContext, ProjectInstance projectInstance);
    [CompilerGeneratedAttribute]
internal TargetLoggingContext get_LoggingContext();
    [CompilerGeneratedAttribute]
private void set_LoggingContext(TargetLoggingContext value);
    [CompilerGeneratedAttribute]
internal ProjectInstance get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(ProjectInstance value);
    internal static IntrinsicTask InstantiateTask(ProjectTargetInstanceChild taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance);
    internal abstract virtual void ExecuteTask(Lookup lookup);
    protected static void AddIfNotEmptyString(List`1<string> list, string value);
}
internal class Microsoft.Build.BackEnd.IntrinsicTaskFactory : object {
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    public IntrinsicTaskFactory(Type intrinsicType);
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
internal interface Microsoft.Build.BackEnd.IPropertyCache {
}
internal interface Microsoft.Build.BackEnd.IRequestBuilder {
    public abstract virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    public abstract virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    public abstract virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    public abstract virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    public abstract virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    public abstract virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    public abstract virtual void BuildRequest(NodeLoggingContext nodeLoggingContext, BuildRequestEntry entry);
    public abstract virtual void ContinueRequest();
    public abstract virtual void CancelRequest();
}
internal interface Microsoft.Build.BackEnd.IRequestBuilderCallback {
    public abstract virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults);
    public abstract virtual void BlockOnTargetInProgress(int blockingRequestId, string blockingTarget);
    public abstract virtual void Yield();
    public abstract virtual void Reacquire();
    public abstract virtual void EnterMSBuildCallbackState();
    public abstract virtual void ExitMSBuildCallbackState();
}
internal interface Microsoft.Build.BackEnd.IResultsCache {
    public abstract virtual void AddResult(BuildResult result);
    public abstract virtual void ClearResults();
    public abstract virtual BuildResult GetResultForRequest(BuildRequest request);
    public abstract virtual BuildResult GetResultsForConfiguration(int configurationId);
    public abstract virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets);
    public abstract virtual void ClearResultsForConfiguration(int configurationId);
    public abstract virtual void WriteResultsToDisk();
}
internal interface Microsoft.Build.BackEnd.IScheduler {
    public int MinimumAssignableConfigurationId { get; }
    public abstract virtual int get_MinimumAssignableConfigurationId();
    public abstract virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public abstract virtual int GetConfigurationIdFromPlan(string configurationPath);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfo);
    public abstract virtual void ReportBuildAborted(int nodeId);
    public abstract virtual void Reset();
    public abstract virtual void WriteDetailedSummary(int submissionId);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilder {
    public abstract virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext projectLoggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targets, Lookup baseLookup, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilderCallback {
    public abstract virtual Task`1<ITargetResult[]> LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation referenceLocation);
}
internal interface Microsoft.Build.BackEnd.ITaskBuilder {
    public abstract virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild task, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITaskExecutionHost {
    public ProjectInstance ProjectInstance { get; }
    public abstract virtual ProjectInstance get_ProjectInstance();
    public abstract virtual void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, AppDomainSetup appDomainSetup, bool isOutOfProc, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<TaskRequirements> FindTask(IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool SetTaskParameters(IDictionary`2<string, Tuple`2<string, ElementLocation>> parameters);
    public abstract virtual bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    public abstract virtual void CleanupForBatch();
    public abstract virtual void CleanupForTask();
    public abstract virtual bool Execute();
}
internal class Microsoft.Build.BackEnd.ItemBucket : object {
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> Expander { get; }
    internal int BucketSequenceNumber { get; }
    internal Lookup Lookup { get; }
    internal ItemBucket(ICollection`1<string> itemNames, Dictionary`2<string, string> metadata, Lookup lookup, int bucketSequenceNumber);
    public sealed virtual int CompareTo(object obj);
    internal static ItemBucket GetDummyBucketForComparisons(Dictionary`2<string, string> metadata);
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> get_Expander();
    internal int get_BucketSequenceNumber();
    internal Lookup get_Lookup();
    internal void AddItem(ProjectItemInstance item);
    internal void LeaveScope();
}
internal class Microsoft.Build.BackEnd.ItemGroupIntrinsicTask : IntrinsicTask {
    public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance);
    internal virtual void ExecuteTask(Lookup lookup);
}
internal enum Microsoft.Build.BackEnd.LinkStatus : Enum {
    public int value__;
    public static LinkStatus Inactive;
    public static LinkStatus Active;
    public static LinkStatus Failed;
    public static LinkStatus ConnectionFailed;
}
internal class Microsoft.Build.BackEnd.LinkStatusChangedDelegate : MulticastDelegate {
    public LinkStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, LinkStatus status);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, LinkStatus status, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class Microsoft.Build.BackEnd.Logging.BaseConsoleLogger : object {
    internal static int tabWidth;
    internal static string projectSeparatorLine;
    internal LoggerVerbosity verbosity;
    internal DateTime buildStarted;
    internal WriteHandler write;
    internal ColorSetter setColor;
    internal ColorResetter resetColor;
    internal bool skipProjectStartedText;
    internal int currentIndentLevel;
    internal static String[] newLines;
    internal string loggerParameters;
    internal static Char[] parameterDelimiters;
    internal bool showPerfSummary;
    internal bool showItemAndPropertyList;
    internal bool showTargetOutputs;
    protected bool showOnlyWarnings;
    protected bool showOnlyErrors;
    protected bool showEnvironment;
    protected bool showProjectFile;
    internal bool ignoreLoggerErrors;
    internal bool runningWithCharacterFileType;
    internal int numberOfProcessors;
    internal int errorCount;
    internal int warningCount;
    internal ArrayList errorList;
    internal ArrayList warningList;
    internal Hashtable projectPerformanceCounters;
    internal Hashtable targetPerformanceCounters;
    internal Hashtable taskPerformanceCounters;
    public LoggerVerbosity Verbosity { get; public set; }
    public int NumberOfProcessors { get; public set; }
    public string Parameters { get; public set; }
    internal bool SkipProjectStartedText { get; internal set; }
    internal bool ShowSummary { get; internal set; }
    protected WriteHandler WriteHandler { get; protected set; }
    private static BaseConsoleLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public int get_NumberOfProcessors();
    public void set_NumberOfProcessors(int value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    internal bool get_SkipProjectStartedText();
    internal void set_SkipProjectStartedText(bool value);
    internal bool get_ShowSummary();
    internal void set_ShowSummary(bool value);
    protected WriteHandler get_WriteHandler();
    protected void set_WriteHandler(WriteHandler value);
    public void ParseParameters();
    internal string IndentString(string s, int indent);
    internal static String[] SplitStringOnNewLines(string s);
    internal void WriteNewLine();
    internal void WriteLinePrettyFromResource(string resourceString, Object[] args);
    internal void WriteLinePrettyFromResource(int indentLevel, string resourceString, Object[] args);
    internal void WritePretty(string formattedString);
    internal void ShowPerfSummary();
    internal void WritePretty(int indentLevel, string formattedString);
    internal void WriteLinePretty(string formattedString);
    internal void WriteLinePretty(int indentLevel, string formattedString);
    internal void IsRunningWithCharacterFileType();
    internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
    internal static void SetColor(ConsoleColor c);
    internal static void ResetColor();
    internal static ConsoleColor TransformColor(ConsoleColor foreground, ConsoleColor background);
    internal static void DontSetColor(ConsoleColor c);
    internal static void DontResetColor();
    internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandler logwriter, ColorSetter colorSet, ColorResetter colorReset);
    internal void WriteProperties(ArrayList properties);
    internal void WriteEnvironment(IDictionary`2<string, string> environment);
    internal ArrayList ExtractPropertyList(IEnumerable properties);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal virtual void OutputProperties(ArrayList list);
    internal void WriteItems(SortedList itemTypes);
    internal SortedList ExtractItemList(IEnumerable items);
    internal virtual void OutputItems(string itemType, ArrayList itemTypeList);
    internal static PerformanceCounter GetPerformanceCounter(string scopeName, Hashtable& table);
    internal void DisplayCounters(Hashtable counters);
    public virtual void Shutdown();
    internal abstract virtual void ResetConsoleLoggerState();
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Initialize(IEventSource eventSource);
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    public abstract virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public abstract virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public abstract virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public abstract virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public abstract virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public abstract virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public abstract virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public abstract virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public abstract virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public abstract virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public abstract virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public abstract virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
}
internal class Microsoft.Build.BackEnd.Logging.BaseLoggingContext : object {
    public ILoggingService LoggingService { get; }
    public BuildEventContext BuildEventContext { get; protected set; }
    public bool IsValid { get; protected set; }
    public bool IsInProcNode { get; }
    protected BaseLoggingContext(ILoggingService loggingService, BuildEventContext eventContext, bool inProc);
    protected BaseLoggingContext(BaseLoggingContext baseContext);
    [DebuggerStepThroughAttribute]
public ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    protected void set_BuildEventContext(BuildEventContext value);
    [DebuggerStepThroughAttribute]
public bool get_IsValid();
    [DebuggerStepThroughAttribute]
protected void set_IsValid(bool value);
    [DebuggerStepThroughAttribute]
public bool get_IsInProcNode();
    internal void LogComment(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    internal void LogCommentFromText(MessageImportance importance, string message);
    internal void LogBuildEvent(BuildEventArgs buildEvent);
    internal void LogError(BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogErrorWithSubcategory(BuildEventFileInfo file, string subcategoryResourceName, string messageResourceName, Object[] messageArgs);
    internal void LogErrorFromText(BuildEventFileInfo file, string subcategoryResourceName, string errorCode, string helpKeyword, string message);
    internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProjectFileException);
    internal void LogFatalBuildError(BuildEventFileInfo file, Exception exception);
    internal void LogFatalTaskError(BuildEventFileInfo file, Exception exception, string taskName);
    internal void LogFatalError(BuildEventFileInfo file, Exception exception, string messageResourceName, Object[] messageArgs);
    internal void LogTaskWarningFromException(BuildEventFileInfo file, Exception exception, string taskName);
    internal void LogWarning(BuildEventFileInfo file, string subcategoryResourceName, string messageResourceName, Object[] messageArgs);
    internal void LogWarningFromText(BuildEventFileInfo file, string subcategoryResourceName, string warningCode, string helpKeyword, string message);
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink : object {
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    internal BuildEventArgTransportSink(SendDataDelegate sendData);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void ShutDown();
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventManager : object {
    private static BuildEventManager();
    internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTimestamp);
    internal void AddTargetStartedEvent(TargetStartedEventArgs e, bool requireTimeStamp);
    internal List`1<ProjectStartedEventMinimumFields> GetProjectCallStack(BuildEventContext e);
    internal void SetErrorWarningFlagOnCallStack(BuildEventContext e);
    internal String[] ProjectCallStackFromProject(BuildEventContext e);
    internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e);
    internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e);
    internal void RemoveProjectStartedEvent(BuildEventContext e);
    internal void RemoveTargetStartedEvent(BuildEventContext e);
}
internal class Microsoft.Build.BackEnd.Logging.CentralForwardingLogger : object {
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IEventRedirector get_BuildEventRedirector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NodeId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeIdTargetId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal class Microsoft.Build.BackEnd.Logging.ErrorWarningSummaryDictionaryKey : object {
    internal BuildEventContext EntryPointContext { get; }
    internal string TargetName { get; }
    internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName);
    private static ErrorWarningSummaryDictionaryKey();
    internal BuildEventContext get_EntryPointContext();
    internal string get_TargetName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.EventRedirectorToSink : object {
    internal EventRedirectorToSink(int loggerId, IBuildEventSink eventSink);
    private sealed virtual override void Microsoft.Build.Framework.IEventRedirector.ForwardEvent(BuildEventArgs buildEvent);
}
internal class Microsoft.Build.BackEnd.Logging.EventSourceSink : MarshalByRefObject {
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void ShutDown();
    internal void UnregisterAllEventHandlers();
}
internal interface Microsoft.Build.BackEnd.Logging.IBuildEventSink {
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual bool get_HaveLoggedBuildStartedEvent();
    public abstract virtual void set_HaveLoggedBuildStartedEvent(bool value);
    public abstract virtual bool get_HaveLoggedBuildFinishedEvent();
    public abstract virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    public abstract virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public abstract virtual void Consume(BuildEventArgs buildEvent);
    public abstract virtual void ShutDown();
}
internal interface Microsoft.Build.BackEnd.Logging.ILoggingService {
    public LoggingServiceState ServiceState { get; }
    public LoggerMode LoggingMode { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public abstract virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    public abstract virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    public abstract virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    public abstract virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    public abstract virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    public abstract virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    public abstract virtual LoggingServiceState get_ServiceState();
    public abstract virtual LoggerMode get_LoggingMode();
    public abstract virtual bool get_OnlyLogCriticalEvents();
    public abstract virtual void set_OnlyLogCriticalEvents(bool value);
    public abstract virtual int get_MaxCPUCount();
    public abstract virtual void set_MaxCPUCount(int value);
    public abstract virtual ICollection`1<ILogger> get_Loggers();
    public abstract virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public abstract virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public abstract virtual ICollection`1<string> get_RegisteredSinkNames();
    public abstract virtual String[] get_PropertiesToSerialize();
    public abstract virtual void set_PropertiesToSerialize(String[] value);
    public abstract virtual bool get_SerializeAllProperties();
    public abstract virtual void set_SerializeAllProperties(bool value);
    public abstract virtual bool get_RunningOnRemoteNode();
    public abstract virtual void set_RunningOnRemoteNode(bool value);
    public abstract virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public abstract virtual bool RegisterLogger(ILogger logger);
    public abstract virtual void UnregisterAllLoggers();
    public abstract virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> loggerDescriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public abstract virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public abstract virtual void LogBuildEvent(BuildEventArgs buildEvent);
    public abstract virtual void LogError(BuildEventContext buildEventContext, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public abstract virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public abstract virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogBuildStarted();
    public abstract virtual void LogBuildFinished(bool success);
    public abstract virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items);
    public abstract virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public abstract virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName);
    public abstract virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public abstract virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public abstract virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public abstract virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
}
internal static class Microsoft.Build.BackEnd.Logging.LogFormatter : object {
    internal static string FormatLogTimeStamp(DateTime timeStamp);
    internal static string FormatTimeSpan(TimeSpan t);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggerMode : Enum {
    public int value__;
    public static LoggerMode Synchronous;
    public static LoggerMode Asynchronous;
}
internal class Microsoft.Build.BackEnd.Logging.LoggingExceptionDelegate : MulticastDelegate {
    public LoggingExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingService : object {
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public int NextProjectId { get; }
    public int NextTargetId { get; }
    public int NextTaskId { get; }
    public LoggingServiceState ServiceState { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public LoggerMode LoggingMode { get; }
    public bool LoggingQueueHasEvents { get; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    protected LoggingService(LoggerMode loggerMode, int nodeId);
    private static LoggingService();
    public sealed virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    public sealed virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    public sealed virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    public sealed virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    public sealed virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    public sealed virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PropertiesToSerialize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PropertiesToSerialize(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SerializeAllProperties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SerializeAllProperties(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RunningOnRemoteNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RunningOnRemoteNode(bool value);
    public int get_NextProjectId();
    public int get_NextTargetId();
    public int get_NextTaskId();
    public sealed virtual LoggingServiceState get_ServiceState();
    public sealed virtual bool get_OnlyLogCriticalEvents();
    public sealed virtual void set_OnlyLogCriticalEvents(bool value);
    public sealed virtual int get_MaxCPUCount();
    public sealed virtual void set_MaxCPUCount(int value);
    public sealed virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public sealed virtual ICollection`1<ILogger> get_Loggers();
    public sealed virtual LoggerMode get_LoggingMode();
    public bool get_LoggingQueueHasEvents();
    public sealed virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public sealed virtual ICollection`1<string> get_RegisteredSinkNames();
    public static ILoggingService CreateLoggingService(LoggerMode mode, int node);
    public sealed virtual void InitializeComponent(IBuildComponentHost buildComponentHost);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    public sealed virtual bool RegisterLogger(ILogger logger);
    public sealed virtual void UnregisterAllLoggers();
    public sealed virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public sealed virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public sealed virtual void LogBuildEvent(BuildEventArgs buildEvent);
    internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottling);
    internal void WaitForThreadToProcessEvents();
    internal void InjectNonSerializedData(LogMessagePacket loggingPacket);
    public sealed virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext location, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public sealed virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public sealed virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogBuildStarted();
    public sealed virtual void LogBuildFinished(bool success);
    public sealed virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items);
    public sealed virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public sealed virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName);
    public sealed virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public sealed virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public sealed virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public sealed virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingServiceFactory : object {
    internal LoggingServiceFactory(LoggerMode mode, int nodeId);
    public IBuildComponent CreateInstance(BuildComponentType type);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggingServiceState : Enum {
    public int value__;
    public static LoggingServiceState Instantiated;
    public static LoggingServiceState Initialized;
    public static LoggingServiceState ShuttingDown;
    public static LoggingServiceState Shutdown;
}
internal class Microsoft.Build.BackEnd.Logging.NodeLoggingContext : BaseLoggingContext {
    internal NodeLoggingContext(ILoggingService loggingService, int nodeId, bool inProcNode);
    internal void LogBuildFinished(bool success);
    internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry);
    internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration);
    internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfiguration configuration, BuildResult result);
}
internal class Microsoft.Build.BackEnd.Logging.NullCentralLogger : object {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public void AnyEventRaisedHandler(object sender, BuildEventArgs e);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
internal class Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger : BaseConsoleLogger {
    public ParallelConsoleLogger(LoggerVerbosity verbosity);
    public ParallelConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    private static ParallelConsoleLogger();
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    internal void WriteProperties(BuildEventArgs e, IEnumerable properties);
    internal virtual void OutputProperties(ArrayList list);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal void WriteItems(BuildEventArgs e, IEnumerable items);
    internal virtual void OutputItems(string itemType, ArrayList itemTypeList);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    internal static MPPerformanceCounter GetPerformanceCounter(string scopeName, Hashtable& table);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectFullKey : object {
    internal int ProjectKey { get; internal set; }
    internal int EntryPointKey { get; internal set; }
    internal ProjectFullKey(int projectKey, int entryPointKey);
    internal int get_ProjectKey();
    internal void set_ProjectKey(int value);
    internal int get_EntryPointKey();
    internal void set_EntryPointKey(int value);
    public string ToString(LoggerVerbosity verbosity);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.ProjectLoggingContext : BaseLoggingContext {
    internal NodeLoggingContext NodeLoggingContext { get; }
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry, BuildEventContext parentBuildEventContext);
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, BuildEventContext parentBuildEventContext);
    internal NodeLoggingContext get_NodeLoggingContext();
    internal void LogProjectFinished(bool success);
    internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, ProjectTargetInstance target, string parentTargetName);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectStartedEventMinimumFields : object {
    internal DateTime TimeStamp { get; }
    internal int ProjectKey { get; }
    internal int EntryPointKey { get; }
    internal string FullProjectKey { get; }
    internal ProjectStartedEventMinimumFields ParentProjectStartedEvent { get; }
    internal string TargetNames { get; }
    internal int ProjectId { get; }
    internal string ProjectFile { get; }
    internal bool ShowProjectFinishedEvent { get; internal set; }
    internal bool ErrorInProject { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, ProjectStartedEventArgs startedEvent, ProjectStartedEventMinimumFields parentProjectStartedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal int get_ProjectKey();
    internal int get_EntryPointKey();
    internal string get_FullProjectKey();
    internal ProjectStartedEventMinimumFields get_ParentProjectStartedEvent();
    internal string get_TargetNames();
    internal int get_ProjectId();
    internal string get_ProjectFile();
    internal bool get_ShowProjectFinishedEvent();
    internal void set_ShowProjectFinishedEvent(bool value);
    internal bool get_ErrorInProject();
    internal void set_ErrorInProject(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
}
internal class Microsoft.Build.BackEnd.Logging.SendDataDelegate : MulticastDelegate {
    public SendDataDelegate(object object, IntPtr method);
    public virtual void Invoke(INodePacket packetToSend);
    public virtual IAsyncResult BeginInvoke(INodePacket packetToSend, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.SerialConsoleLogger : BaseConsoleLogger {
    internal FrameStack contextStack;
    public SerialConsoleLogger(LoggerVerbosity verbosity);
    public SerialConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    internal void WriteProjectStarted();
}
internal class Microsoft.Build.BackEnd.Logging.TargetLoggingContext : BaseLoggingContext {
    internal static bool EnableTargetOutputLogging { get; internal set; }
    internal ProjectLoggingContext ProjectLoggingContext { get; }
    internal ProjectTargetInstance Target { get; }
    internal TargetLoggingContext(ProjectLoggingContext projectLoggingContext, string projectFullPath, ProjectTargetInstance target, string parentTargetName);
    internal TargetLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    private static TargetLoggingContext();
    internal static bool get_EnableTargetOutputLogging();
    internal static void set_EnableTargetOutputLogging(bool value);
    internal ProjectLoggingContext get_ProjectLoggingContext();
    internal ProjectTargetInstance get_Target();
    internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable`1<TaskItem> targetOutputs);
    internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task);
}
internal class Microsoft.Build.BackEnd.Logging.TargetStartedEventMinimumFields : object {
    internal DateTime TimeStamp { get; }
    internal string TargetName { get; }
    internal string TargetFile { get; }
    internal string ProjectFile { get; }
    internal string Message { get; }
    internal bool ShowTargetFinishedEvent { get; internal set; }
    internal bool ErrorInTarget { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal string ParentTarget { get; }
    internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal string get_TargetName();
    internal string get_TargetFile();
    internal string get_ProjectFile();
    internal string get_Message();
    internal bool get_ShowTargetFinishedEvent();
    internal void set_ShowTargetFinishedEvent(bool value);
    internal bool get_ErrorInTarget();
    internal void set_ErrorInTarget(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
    internal string get_ParentTarget();
}
internal class Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver : MarshalByRefObject {
    internal void Initialize(string taskAssemblyFileToResolve);
    internal void InstallHandler();
    internal void RemoveHandler();
    internal Assembly ResolveAssembly(object sender, ResolveEventArgs args);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
}
internal class Microsoft.Build.BackEnd.Logging.TaskLoggingContext : BaseLoggingContext {
    internal TargetLoggingContext TargetLoggingContext { get; }
    internal ProjectTargetInstanceChild Task { get; }
    internal string TaskName { get; }
    internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task);
    internal TaskLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    internal TargetLoggingContext get_TargetLoggingContext();
    internal ProjectTargetInstanceChild get_Task();
    internal string get_TaskName();
    internal void LogTaskBatchFinished(string projectFullPath, bool success);
}
internal class Microsoft.Build.BackEnd.Logging.WriteLinePrettyFromResourceDelegate : MulticastDelegate {
    public WriteLinePrettyFromResourceDelegate(object object, IntPtr method);
    public virtual void Invoke(int indentLevel, string resourceString, Object[] args);
    public virtual IAsyncResult BeginInvoke(int indentLevel, string resourceString, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.LogMessagePacket : LogMessagePacketBase {
    internal LogMessagePacket(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.Lookup : object {
    internal ReadOnlyLookup ReadOnlyLookup { get; }
    internal IDictionary`2<string, object> GlobalsForDebugging { get; }
    internal Lookup(ItemDictionary`1<ProjectItemInstance> projectItems, PropertyDictionary`1<ProjectPropertyInstance> properties, IDictionary`2<string, object> globalsForDebugging);
    internal ReadOnlyLookup get_ReadOnlyLookup();
    internal IDictionary`2<string, object> get_GlobalsForDebugging();
    internal List`1<string> GetPropertyOverrideMessages(Dictionary`2<string, string> lookupHash);
    internal Lookup Clone();
    internal Scope EnterScope(string description);
    internal ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex);
    internal ProjectPropertyInstance GetProperty(string name);
    internal ICollection`1<ProjectItemInstance> GetItems(string itemType);
    internal void PopulateWithItems(string itemType, ICollection`1<ProjectItemInstance> group);
    internal void PopulateWithItem(ProjectItemInstance item);
    internal void SetProperty(ProjectPropertyInstance property);
    internal void AddNewItemsOfItemType(string itemType, ICollection`1<ProjectItemInstance> group, bool doNotAddDuplicates);
    internal void AddNewItem(ProjectItemInstance item);
    internal void RemoveItems(IEnumerable`1<ProjectItemInstance> items);
    internal void RemoveItem(ProjectItemInstance item);
    internal void ModifyItems(string itemType, ICollection`1<ProjectItemInstance> group, MetadataModifications metadataChanges);
}
internal class Microsoft.Build.BackEnd.MSBuild : object {
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public TaskLoggingHelper Log { get; }
    public ITaskHost HostObject { get; public set; }
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public TaskLoggingHelper get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    public String[] get_Properties();
    public void set_Properties(String[] value);
    public string get_RemoveProperties();
    public void set_RemoveProperties(string value);
    public String[] get_Targets();
    public void set_Targets(String[] value);
    public ITaskItem[] get_Projects();
    public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    public bool get_RebaseOutputs();
    public void set_RebaseOutputs(bool value);
    public bool get_StopOnFirstFailure();
    public void set_StopOnFirstFailure(bool value);
    public bool get_RunEachTargetSeparately();
    public void set_RunEachTargetSeparately(bool value);
    public string get_ToolsVersion();
    public void set_ToolsVersion(string value);
    public bool get_BuildInParallel();
    public void set_BuildInParallel(bool value);
    public bool get_UnloadProjectsOnCompletion();
    public void set_UnloadProjectsOnCompletion(bool value);
    public bool get_UseResultsCache();
    public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    public String[] get_TargetAndPropertyListSeparators();
    public void set_TargetAndPropertyListSeparators(String[] value);
    public sealed virtual bool Execute();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteInternal>d__0")]
[DebuggerStepThroughAttribute]
public Task`1<bool> ExecuteInternal();
    internal static ArrayList CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteTargets>d__14")]
internal static Task`1<bool> ExecuteTargets(ITaskItem[] projects, Hashtable propertiesTable, String[] undefineProperties, ArrayList targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, ArrayList targetOutputs, bool useResultsCache, bool unloadProjectsOnCompletion, string toolsVersion);
}
internal static class Microsoft.Build.BackEnd.NativeMethods : object {
    internal static UInt32 NORMALPRIORITYCLASS;
    internal static UInt32 CREATENOWINDOW;
    internal static int STARTFUSESTDHANDLES;
    internal static int CREATE_NEW_CONSOLE;
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidHandle;
    private static NativeMethods();
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES& lpProcessAttributes, SECURITY_ATTRIBUTES& lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUP_INFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
}
internal class Microsoft.Build.BackEnd.NewBuildRequestsDelegate : MulticastDelegate {
    public NewBuildRequestsDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry sourceEntry, FullyQualifiedBuildRequest[] requests);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry sourceEntry, FullyQualifiedBuildRequest[] requests, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NewConfigurationRequestDelegate : MulticastDelegate {
    public NewConfigurationRequestDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestConfiguration config);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration config, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodeBuildComplete : object {
    public bool PrepareForReuse { get; }
    public NodePacketType Type { get; }
    public NodeBuildComplete(bool prepareForReuse);
    [DebuggerStepThroughAttribute]
public bool get_PrepareForReuse();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static NodeBuildComplete FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeConfiguration : object {
    public int NodeId { get; public set; }
    public BuildParameters BuildParameters { get; }
    public LoggerDescription[] LoggerDescriptions { get; }
    public AppDomainSetup AppDomainSetup { get; }
    public NodePacketType Type { get; }
    public NodeConfiguration(int nodeId, BuildParameters buildParameters, LoggerDescription[] forwardingLoggers, AppDomainSetup appDomainSetup);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public void set_NodeId(int value);
    [DebuggerStepThroughAttribute]
public BuildParameters get_BuildParameters();
    [DebuggerStepThroughAttribute]
public LoggerDescription[] get_LoggerDescriptions();
    [DebuggerStepThroughAttribute]
public AppDomainSetup get_AppDomainSetup();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal NodeConfiguration Clone();
}
internal class Microsoft.Build.BackEnd.NodeEndpointInProc : object {
    public LinkStatus LinkStatus { get; }
    private static NodeEndpointInProc();
    public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComponentHost host);
}
internal class Microsoft.Build.BackEnd.NodeEndpointOutOfProc : NodeEndpointOutOfProcBase {
    internal NodeEndpointOutOfProc(string pipeName, IBuildComponentHost host);
    protected virtual long GetHostHandshake();
    protected virtual long GetClientHandshake();
}
internal abstract class Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase : object {
    public LinkStatus LinkStatus { get; }
    public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    internal void InternalConstruct(string pipeName);
    protected abstract virtual long GetHostHandshake();
    protected abstract virtual long GetClientHandshake();
    protected void ChangeLinkStatus(LinkStatus newStatus);
}
internal class Microsoft.Build.BackEnd.NodeFailedToLaunchException : Exception {
    public string ErrorCode { get; private set; }
    public string ErrorDescription { get; private set; }
    internal NodeFailedToLaunchException(string errorCode, string message);
    protected NodeFailedToLaunchException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
private void set_ErrorDescription(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.BackEnd.NodeInfo : object {
    public int NodeId { get; }
    public NodeProviderType ProviderType { get; }
    public NodeInfo(int nodeId, NodeProviderType providerType);
    public int get_NodeId();
    public NodeProviderType get_ProviderType();
    public bool AssignConfiguration(int configId);
    public bool HasConfiguration(int configId);
    internal bool CanServiceRequestWithAffinity(NodeAffinity nodeAffinity);
}
internal class Microsoft.Build.BackEnd.NodeManager : object {
    public sealed virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownNodes(bool enableReuse);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.NodePacketDictionaryCreator`1 : MulticastDelegate {
    public NodePacketDictionaryCreator`1(object object, IntPtr method);
    public virtual T Invoke(int capacity);
    public virtual IAsyncResult BeginInvoke(int capacity, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodePacketFactory : object {
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal class Microsoft.Build.BackEnd.NodePacketFactoryMethod : MulticastDelegate {
    public NodePacketFactoryMethod(object object, IntPtr method);
    public virtual INodePacket Invoke(INodePacketTranslator translator);
    public virtual IAsyncResult BeginInvoke(INodePacketTranslator translator, AsyncCallback callback, object object);
    public virtual INodePacket EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.BackEnd.NodePacketTranslator : object {
    internal static INodePacketTranslator GetReadTranslator(Stream stream, SharedReadBuffer buffer);
    internal static INodePacketTranslator GetWriteTranslator(Stream stream);
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.NodePacketTranslatorExtensions : object {
    [ExtensionAttribute]
public static void TranslateProjectPropertyInstanceDictionary(INodePacketTranslator translator, PropertyDictionary`1& value);
}
internal enum Microsoft.Build.BackEnd.NodePacketType : Enum {
    public byte value__;
    public static NodePacketType NodeConfiguration;
    public static NodePacketType BuildRequestConfiguration;
    public static NodePacketType BuildRequestConfigurationResponse;
    public static NodePacketType ProjectLoadInfo;
    public static NodePacketType BuildRequestBlocker;
    public static NodePacketType BuildRequestUnblocker;
    public static NodePacketType BuildRequest;
    public static NodePacketType BuildResult;
    public static NodePacketType LogMessage;
    public static NodePacketType NodeBuildComplete;
    public static NodePacketType NodeShutdown;
    public static NodePacketType TaskHostConfiguration;
    public static NodePacketType TaskHostTaskComplete;
    public static NodePacketType TaskHostTaskCancelled;
}
internal class Microsoft.Build.BackEnd.NodePacketValueFactory`1 : MulticastDelegate {
    public NodePacketValueFactory`1(object object, IntPtr method);
    public virtual T Invoke(INodePacketTranslator translator);
    public virtual IAsyncResult BeginInvoke(INodePacketTranslator translator, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodeProviderInProc : object {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    protected virtual void Finalize();
    public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownNodes(bool enableReuse);
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProc : NodeProviderOutOfProcBase {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    internal static long HostHandshake { get; }
    internal static long ClientHandshake { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static long get_HostHandshake();
    internal static long get_ClientHandshake();
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownNodes(bool enableReuse);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
}
internal abstract class Microsoft.Build.BackEnd.NodeProviderOutOfProcBase : object {
    protected IBuildComponentHost ComponentHost { get; protected set; }
    protected IBuildComponentHost get_ComponentHost();
    protected void set_ComponentHost(IBuildComponentHost value);
    protected void SendData(NodeContext context, INodePacket packet);
    protected void ShutdownNodes(List`1<NodeContext> contextsToShutDown, bool enableReuse);
    protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode);
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    internal static string TaskHostNameForClr2TaskHost { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static string get_TaskHostNameForClr2TaskHost();
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public void SendData(TaskHostContext hostContext, INodePacket packet);
    public sealed virtual void ShutdownNodes(bool enableReuse);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    internal static void ClearCachedTaskHostPaths();
    internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContext);
    internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostContext);
    internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
    internal void DisconnectFromHost(TaskHostContext hostContext);
    internal bool CreateNode(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
}
internal enum Microsoft.Build.BackEnd.NodeProviderType : Enum {
    public int value__;
    public static NodeProviderType InProc;
    public static NodeProviderType OutOfProc;
    public static NodeProviderType Remote;
}
internal class Microsoft.Build.BackEnd.NodeShutdown : object {
    public NodePacketType Type { get; }
    public NodeShutdownReason Reason { get; }
    public Exception Exception { get; }
    public NodeShutdown(NodeShutdownReason reason);
    public NodeShutdown(NodeShutdownReason reason, Exception e);
    public sealed virtual NodePacketType get_Type();
    public NodeShutdownReason get_Reason();
    public Exception get_Exception();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static NodeShutdown FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeShutdownDelegate : MulticastDelegate {
    public NodeShutdownDelegate(object object, IntPtr method);
    public virtual void Invoke(NodeEngineShutdownReason reason, Exception e);
    public virtual IAsyncResult BeginInvoke(NodeEngineShutdownReason reason, Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.NodeShutdownReason : Enum {
    public int value__;
    public static NodeShutdownReason Requested;
    public static NodeShutdownReason Error;
    public static NodeShutdownReason ConnectionFailed;
}
internal enum Microsoft.Build.BackEnd.OutofdateReason : Enum {
    public int value__;
    public static OutofdateReason MissingInput;
    public static OutofdateReason MissingOutput;
    public static OutofdateReason NewerInput;
}
internal class Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask : IntrinsicTask {
    public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance);
    internal virtual void ExecuteTask(Lookup lookup);
}
internal static class Microsoft.Build.BackEnd.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Hashtable& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Hashtable& finalPropertiesTable);
}
internal class Microsoft.Build.BackEnd.ReadOnlyLookup : object {
    internal ReadOnlyLookup(Lookup lookup);
    public sealed virtual ICollection`1<ProjectItemInstance> GetItems(string itemType);
    public sealed virtual ProjectPropertyInstance GetProperty(string name);
    public sealed virtual ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex);
}
internal class Microsoft.Build.BackEnd.RequestBlockedDelegate : MulticastDelegate {
    public RequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestBlocker blocker);
    public virtual IAsyncResult BeginInvoke(BuildRequestBlocker blocker, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestBuilder : object {
    internal BuildRequestEntry RequestEntry { get; }
    internal bool HasActiveBuildRequest { get; }
    public sealed virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    public sealed virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    public sealed virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    public sealed virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    public sealed virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    public sealed virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    internal BuildRequestEntry get_RequestEntry();
    internal bool get_HasActiveBuildRequest();
    public sealed virtual void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry);
    public sealed virtual void ContinueRequest();
    public sealed virtual void CancelRequest();
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildProjects>d__2")]
public sealed virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults);
    public sealed virtual void BlockOnTargetInProgress(int blockingGlobalRequestId, string blockingTarget);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void EnterMSBuildCallbackState();
    public sealed virtual void ExitMSBuildCallbackState();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static bool IsBuilderUsingLegacyThreadingSemantics(IBuildComponentHost host, BuildRequestEntry entry);
    internal static int WaitWithBuilderThreadStart(WaitHandle[] handles, bool recursive, LegacyThreadingData threadingData);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.RequestCompleteDelegate : MulticastDelegate {
    public RequestCompleteDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request, BuildResult result);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, BuildResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestResumedDelegate : MulticastDelegate {
    public RequestResumedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ResultsCache : object {
    internal IDictionary`2<int, BuildResult> ResultsDictionary { get; }
    internal IDictionary`2<int, BuildResult> get_ResultsDictionary();
    public sealed virtual void AddResult(BuildResult result);
    public sealed virtual void ClearResults();
    public sealed virtual BuildResult GetResultForRequest(BuildRequest request);
    public sealed virtual BuildResult GetResultsForConfiguration(int configurationId);
    public sealed virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets);
    public sealed virtual void ClearResultsForConfiguration(int configurationId);
    public sealed virtual void WriteResultsToDisk();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
}
internal class Microsoft.Build.BackEnd.ResultsCacheResponse : ValueType {
    public ResultsCacheResponseType Type;
    public BuildResult Results;
    public HashSet`1<string> ExplicitTargetsToBuild;
    public ResultsCacheResponse(ResultsCacheResponseType type);
}
internal enum Microsoft.Build.BackEnd.ResultsCacheResponseType : Enum {
    public int value__;
    public static ResultsCacheResponseType NotSatisfied;
    public static ResultsCacheResponseType Satisfied;
}
internal class Microsoft.Build.BackEnd.SchedulableRequest : object {
    public SchedulableRequestState State { get; }
    public BuildRequest BuildRequest { get; }
    public SchedulableRequest Parent { get; }
    public int AssignedNode { get; }
    public IEnumerable`1<string> ActiveTargets { get; }
    public int RequestsWeAreBlockedByCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlockedBy { get; }
    public int RequestsWeAreBlockingCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlocking { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent);
    public SchedulableRequestState get_State();
    public BuildRequest get_BuildRequest();
    public SchedulableRequest get_Parent();
    public int get_AssignedNode();
    public IEnumerable`1<string> get_ActiveTargets();
    public int get_RequestsWeAreBlockedByCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlockedBy();
    public int get_RequestsWeAreBlockingCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlocking();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_StartTime();
    public void set_StartTime(DateTime value);
    public DateTime get_EndTime();
    public void set_EndTime(DateTime value);
    public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState);
    public void Yield(String[] activeTargets);
    public void Reacquire();
    public void BlockByRequest(SchedulableRequest blockingRequest, String[] activeTargets);
    public void UnblockWithResult(BuildResult result);
    public void ResumeExecution(int nodeId);
    public void Complete(BuildResult result);
    public void Delete();
    public void VerifyState(SchedulableRequestState requiredState);
    public void VerifyOneOfStates(SchedulableRequestState[] requiredStates);
}
internal enum Microsoft.Build.BackEnd.SchedulableRequestState : Enum {
    public int value__;
    public static SchedulableRequestState Unscheduled;
    public static SchedulableRequestState Ready;
    public static SchedulableRequestState Executing;
    public static SchedulableRequestState Blocked;
    public static SchedulableRequestState Yielding;
    public static SchedulableRequestState Completed;
}
internal enum Microsoft.Build.BackEnd.ScheduleActionType : Enum {
    public int value__;
    public static ScheduleActionType NoAction;
    public static ScheduleActionType Schedule;
    public static ScheduleActionType ScheduleWithConfiguration;
    public static ScheduleActionType ReportResults;
    public static ScheduleActionType ResumeExecution;
    public static ScheduleActionType CreateNode;
    public static ScheduleActionType SubmissionComplete;
    public static ScheduleActionType CircularDependency;
}
internal class Microsoft.Build.BackEnd.Scheduler : object {
    internal static int InvalidNodeId;
    internal static int ResultsTransferredId;
    internal static int InProcNodeId;
    internal static int VirtualNode;
    public int MinimumAssignableConfigurationId { get; }
    public sealed virtual int get_MinimumAssignableConfigurationId();
    public sealed virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public sealed virtual int GetConfigurationIdFromPlan(string configPath);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfos);
    public sealed virtual void ReportBuildAborted(int nodeId);
    public sealed virtual void Reset();
    public sealed virtual void WriteDetailedSummary(int submissionId);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
}
internal class Microsoft.Build.BackEnd.SchedulerCircularDependencyException : Exception {
    public IEnumerable`1<SchedulableRequest> Ancestors { get; }
    public BuildRequest Request { get; }
    public SchedulerCircularDependencyException(BuildRequest request, IList`1<SchedulableRequest> ancestors);
    public IEnumerable`1<SchedulableRequest> get_Ancestors();
    public BuildRequest get_Request();
}
internal class Microsoft.Build.BackEnd.ScheduleResponse : object {
    internal ScheduleActionType Action;
    internal int NodeId;
    internal BuildResult BuildResult;
    internal BuildRequest BuildRequest;
    internal BuildRequestUnblocker Unblocker;
    internal NodeAffinity RequiredNodeType;
    internal int NumberOfNodesToCreate;
    internal ScheduleResponse(ScheduleActionType type);
    public static ScheduleResponse CreateScheduleResponse(int node, BuildRequest requestToSchedule, bool sendConfiguration);
    public static ScheduleResponse CreateReportResultResponse(int node, BuildResult resultToReport);
    public static ScheduleResponse CreateResumeExecutionResponse(int node, int globalRequestIdToResume);
    public static ScheduleResponse CreateCircularDependencyResponse(int node, BuildRequest parentRequest, BuildRequest requestCausingCircularDependency);
    public static ScheduleResponse CreateSubmissionCompleteResponse(BuildResult rootRequestResult);
    public static ScheduleResponse CreateNewNodeResponse(NodeAffinity typeOfNodeToCreate, int count);
    public virtual string ToString();
}
internal class Microsoft.Build.BackEnd.ScheduleTimeRecord : object {
    public TimeSpan AccumulatedTime { get; }
    public TimeSpan get_AccumulatedTime();
    public void StartState(DateTime currentTime);
    public void EndState(DateTime currentTime);
}
internal class Microsoft.Build.BackEnd.SchedulingData : object {
    public IEnumerable`1<SchedulingEvent> BuildEvents { get; }
    public IEnumerable`1<SchedulableRequest> ExecutingRequests { get; }
    public int ExecutingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> ReadyRequests { get; }
    public int ReadyRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> BlockedRequests { get; }
    public int BlockedRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> YieldingRequests { get; }
    public int YieldingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequests { get; }
    public int UnscheduledRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequestsWhichCanBeScheduled { get; }
    public IEnumerable`1<int> Configurations { get; }
    public DateTime EventTime { get; public set; }
    public IEnumerable`1<SchedulingEvent> get_BuildEvents();
    public IEnumerable`1<SchedulableRequest> get_ExecutingRequests();
    public int get_ExecutingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_ReadyRequests();
    public int get_ReadyRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_BlockedRequests();
    public int get_BlockedRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_YieldingRequests();
    public int get_YieldingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_UnscheduledRequests();
    public int get_UnscheduledRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_UnscheduledRequestsWhichCanBeScheduled();
    public IEnumerable`1<int> get_Configurations();
    public DateTime get_EventTime();
    public void set_EventTime(DateTime value);
    public SchedulableRequest CreateRequest(BuildRequest buildRequest, SchedulableRequest parent);
    public void UpdateFromState(SchedulableRequest request, SchedulableRequestState previousState);
    public IEnumerable`1<SchedulableRequest> GetRequestsAssignedToConfiguration(int configurationId);
    public int GetRequestsAssignedToConfigurationCount(int configurationId);
    public SchedulableRequest GetExecutingRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequestIfAny(int globalRequestId);
    public SchedulableRequest GetYieldingRequest(int globalRequestId);
    public SchedulableRequest GetReadyRequest(int globalRequestId);
    public SchedulableRequest GetScheduledRequest(int globalRequestId);
    public bool IsNodeWorking(int nodeId);
    public int GetConfigurationsCountByNode(int nodeId, bool excludeTraversals, IConfigCache configCache);
    public SchedulableRequest GetExecutingRequestByNode(int nodeId);
    public bool IsRequestScheduled(SchedulableRequest request);
    public int GetScheduledRequestsCountByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetScheduledRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetReadyRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetRequestsByHierarchy(SchedulableRequest root);
    public int GetAssignedNodeForRequestConfiguration(int configurationId);
    public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId);
    internal void UnassignNodeForRequestConfiguration(int configurationId);
}
internal class Microsoft.Build.BackEnd.SchedulingPlan : object {
    public bool IsPlanValid { get; private set; }
    public int MaximumConfigurationId { get; private set; }
    public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData);
    [CompilerGeneratedAttribute]
public bool get_IsPlanValid();
    [CompilerGeneratedAttribute]
private void set_IsPlanValid(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumConfigurationId();
    [CompilerGeneratedAttribute]
private void set_MaximumConfigurationId(int value);
    public void WritePlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public void ReadPlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public int GetConfigIdForPath(string configPath);
    public int GetConfigWithGreatestNumberOfReferences(IEnumerable`1<int> configsToSchedule);
    public int GetConfigWithGreatestPlanTime(IEnumerable`1<int> realConfigsToSchedule);
    public int GetReferencesCountForConfigByPath(string configFullPath);
    public void VisitConfig(string configName);
    public void CompleteConfig(string configName);
}
internal class Microsoft.Build.BackEnd.TargetBuilder : object {
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<BuildTargets>d__0")]
public sealed virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targetNames, Lookup baseLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    [AsyncStateMachineAttribute("")]
[DebuggerStepThroughAttribute]
private sealed virtual override Task`1<ITargetResult[]> Microsoft.Build.BackEnd.ITargetBuilderCallback.LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation taskLocation);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("")]
private sealed virtual override Task`1<BuildResult[]> Microsoft.Build.BackEnd.IRequestBuilderCallback.BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults);
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.BlockOnTargetInProgress(int blockingGlobalBuildRequestId, string blockingTarget);
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Yield();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Reacquire();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.EnterMSBuildCallbackState();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.ExitMSBuildCallbackState();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
[DebuggerDisplayAttribute("Name={targetSpecification.TargetName} State={state} Result={targetResult.ResultCode}")]
internal class Microsoft.Build.BackEnd.TargetEntry : object {
    internal bool ErrorTarget { get; internal set; }
    internal ElementLocation ReferenceLocation { get; }
    internal bool StopProcessingOnCompletion { get; internal set; }
    internal string Name { get; }
    internal TargetEntryState State { get; }
    internal TargetResult Result { get; }
    internal Lookup Lookup { get; }
    internal ProjectTargetInstance Target { get; }
    internal BuildRequestEntry RequestEntry { get; }
    internal TargetEntry ParentEntry { get; }
    internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, IBuildComponentHost host, bool stopProcessingOnCompletion);
    [CompilerGeneratedAttribute]
internal bool get_ErrorTarget();
    [CompilerGeneratedAttribute]
internal void set_ErrorTarget(bool value);
    internal ElementLocation get_ReferenceLocation();
    [CompilerGeneratedAttribute]
internal bool get_StopProcessingOnCompletion();
    [CompilerGeneratedAttribute]
internal void set_StopProcessingOnCompletion(bool value);
    internal string get_Name();
    internal TargetEntryState get_State();
    internal TargetResult get_Result();
    internal Lookup get_Lookup();
    internal ProjectTargetInstance get_Target();
    internal BuildRequestEntry get_RequestEntry();
    internal TargetEntry get_ParentEntry();
    public sealed virtual bool Equals(TargetEntry other);
    internal List`1<TargetSpecification> GetDependencies(ProjectLoggingContext projectLoggingContext);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetEntry/<ExecuteTarget>d__0")]
internal Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry requestEntry, ProjectLoggingContext projectLoggingContext, CancellationToken cancellationToken);
    internal List`1<TargetSpecification> GetErrorTargets(ProjectLoggingContext projectLoggingContext);
    internal TargetResult GatherResults();
    internal void EnterLegacyCallTargetScope(Lookup lookup);
    internal void MarkForError();
    internal void LeaveLegacyCallTargetScopes();
}
internal enum Microsoft.Build.BackEnd.TargetEntryState : Enum {
    public int value__;
    public static TargetEntryState Dependencies;
    public static TargetEntryState Execution;
    public static TargetEntryState ErrorExecution;
    public static TargetEntryState Completed;
}
[DebuggerDisplayAttribute("Name={TargetName}")]
internal class Microsoft.Build.BackEnd.TargetSpecification : object {
    public string TargetName { get; private set; }
    public ElementLocation ReferenceLocation { get; private set; }
    internal TargetSpecification(string targetName, ElementLocation referenceLocation);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
private void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public ElementLocation get_ReferenceLocation();
    [CompilerGeneratedAttribute]
private void set_ReferenceLocation(ElementLocation value);
}
internal class Microsoft.Build.BackEnd.TargetUpToDateChecker : object {
    internal ProjectTargetInstance TargetToAnalyze { get; }
    internal TargetUpToDateChecker(ProjectInstance project, ProjectTargetInstance targetToAnalyze, ILoggingService loggingServices, BuildEventContext buildEventContext);
    private static TargetUpToDateChecker();
    internal ProjectTargetInstance get_TargetToAnalyze();
    internal DependencyAnalysisResult PerformDependencyAnalysis(ItemBucket bucket, ItemDictionary`1& changedTargetInputs, ItemDictionary`1& upToDateTargetInputs);
    internal static string GetFullBuildReason(DependencyAnalysisLogDetail logDetail);
    internal static bool IsAnyOutOfDate(DependencyAnalysisLogDetail& dependencyAnalysisDetailEntry, string projectDirectory, IList`1<T> inputs, IList`1<T> outputs);
}
internal class Microsoft.Build.BackEnd.TaskBuilder : object {
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteTask>d__0")]
public sealed virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext loggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild taskInstance, TaskExecutionMode mode, Lookup inferLookup, Lookup executeLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal enum Microsoft.Build.BackEnd.TaskCompleteType : Enum {
    public int value__;
    public static TaskCompleteType Success;
    public static TaskCompleteType Failure;
    public static TaskCompleteType CrashedDuringInitialization;
    public static TaskCompleteType CrashedDuringExecution;
    public static TaskCompleteType CrashedAfterExecution;
}
internal class Microsoft.Build.BackEnd.TaskExecutionHost : object {
    private ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.ProjectInstance { get; }
    internal ITask TaskInstance { get; }
    internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    internal TaskExecutionHost(IBuildComponentHost host);
    protected virtual void Finalize();
    private sealed virtual override ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.get_ProjectInstance();
    internal ITask get_TaskInstance();
    internal TaskFactoryWrapper get__UNITTESTONLY_TaskFactoryWrapper();
    internal void set__UNITTESTONLY_TaskFactoryWrapper(TaskFactoryWrapper value);
    [CompilerGeneratedAttribute]
internal AppDomainSetup get_AppDomainSetup();
    [CompilerGeneratedAttribute]
internal void set_AppDomainSetup(AppDomainSetup value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, AppDomainSetup appDomainSetup, bool isOutOfProc, CancellationToken cancellationToken);
    private sealed virtual override Nullable`1<TaskRequirements> Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.SetTaskParameters(IDictionary`2<string, Tuple`2<string, ElementLocation>> parameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForBatch();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForTask();
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.Execute();
    protected virtual void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskExecutionMode : Enum {
    public int value__;
    public static TaskExecutionMode Invalid;
    public static TaskExecutionMode ExecuteTaskAndGatherOutputs;
    public static TaskExecutionMode InferOutputsOnly;
}
internal class Microsoft.Build.BackEnd.TaskFactoryLoggingHost : MarshalByRefObject {
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal BaseLoggingContext LoggingContext { get; }
    public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BaseLoggingContext loggingContext);
    public bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    [DebuggerStepThroughAttribute]
internal BaseLoggingContext get_LoggingContext();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    public virtual object InitializeLifetimeService();
    internal void MarkAsInactive();
    internal bool IsEventSerializable(BuildEventArgs e);
}
internal class Microsoft.Build.BackEnd.TaskHost : MarshalByRefObject {
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; internal set; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal bool ConvertErrorsToWarnings { get; internal set; }
    internal TaskLoggingContext LoggingContext { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; }
    internal bool IsOutOfProc { get; }
    public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback);
    private static TaskHost();
    public sealed virtual bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    internal void set_ContinueOnError(bool value);
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    internal bool get_ConvertErrorsToWarnings();
    internal void set_ConvertErrorsToWarnings(bool value);
    [DebuggerStepThroughAttribute]
internal TaskLoggingContext get_LoggingContext();
    [DebuggerStepThroughAttribute]
internal void set_LoggingContext(TaskLoggingContext value);
    internal AppDomainSetup get_AppDomainSetup();
    internal bool get_IsOutOfProc();
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion);
    public sealed virtual bool BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, String[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
    public sealed virtual BuildEngineResult BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskHost/<InternalBuildProjects>d__7")]
public Task`1<BuildEngineResult> InternalBuildProjects(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs);
    public virtual object InitializeLifetimeService();
    internal void MarkAsInactive();
    internal bool IsEventSerializable(BuildEventArgs e);
}
internal class Microsoft.Build.BackEnd.TaskHostConfiguration : object {
    public int NodeId { get; }
    public string StartupDirectory { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; }
    public CultureInfo UICulture { get; }
    public AppDomainSetup AppDomainSetup { get; }
    public int LineNumberOfTask { get; }
    public int ColumnNumberOfTask { get; }
    public bool ContinueOnError { get; }
    public string ProjectFileOfTask { get; }
    public string TaskName { get; }
    public string TaskLocation { get; }
    public Dictionary`2<string, TaskParameter> TaskParameters { get; }
    public NodePacketType Type { get; }
    public TaskHostConfiguration(int nodeId, string startupDirectory, IDictionary`2<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture, AppDomainSetup appDomainSetup, int lineNumberOfTask, int columnNumberOfTask, string projectFileOfTask, bool continueOnError, string taskName, string taskLocation, IDictionary`2<string, object> taskParameters);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public string get_StartupDirectory();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    [DebuggerStepThroughAttribute]
public CultureInfo get_Culture();
    [DebuggerStepThroughAttribute]
public CultureInfo get_UICulture();
    [DebuggerStepThroughAttribute]
public AppDomainSetup get_AppDomainSetup();
    [DebuggerStepThroughAttribute]
public int get_LineNumberOfTask();
    [DebuggerStepThroughAttribute]
public int get_ColumnNumberOfTask();
    [DebuggerStepThroughAttribute]
public bool get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public string get_ProjectFileOfTask();
    [DebuggerStepThroughAttribute]
public string get_TaskName();
    [DebuggerStepThroughAttribute]
public string get_TaskLocation();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskParameters();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostNodeManager : object {
    public sealed virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownNodes(bool enableReuse);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.TaskHostTask : object {
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskHostParameters, LoadedType taskType, AppDomainSetup appDomainSetup);
    public sealed virtual IBuildEngine get_BuildEngine();
    public sealed virtual void set_BuildEngine(IBuildEngine value);
    public sealed virtual ITaskHost get_HostObject();
    public sealed virtual void set_HostObject(ITaskHost value);
    public sealed virtual void SetPropertyValue(TaskPropertyInfo property, object value);
    public sealed virtual object GetPropertyValue(TaskPropertyInfo property);
    public sealed virtual void Cancel();
    public sealed virtual bool Execute();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal void Cleanup();
}
internal class Microsoft.Build.BackEnd.TaskHostTaskCancelled : object {
    public NodePacketType Type { get; }
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostTaskComplete : object {
    public TaskCompleteType TaskResult { get; }
    public Exception TaskException { get; }
    public string TaskExceptionMessage { get; }
    public String[] TaskExceptionMessageArgs { get; }
    public Dictionary`2<string, TaskParameter> TaskOutputParameters { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public NodePacketType Type { get; }
    public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary`2<string, string> buildProcessEnvironment);
    [DebuggerStepThroughAttribute]
public TaskCompleteType get_TaskResult();
    [DebuggerStepThroughAttribute]
public Exception get_TaskException();
    [DebuggerStepThroughAttribute]
public string get_TaskExceptionMessage();
    [DebuggerStepThroughAttribute]
public String[] get_TaskExceptionMessageArgs();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskOutputParameters();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelper : MarshalByRefObject {
    protected string TaskName { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    protected string get_TaskName();
    protected IBuildEngine get_BuildEngine();
    public ResourceManager get_TaskResources();
    public void set_TaskResources(ResourceManager value);
    public string get_HelpKeywordPrefix();
    public void set_HelpKeywordPrefix(string value);
    public bool get_HasLoggedErrors();
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public virtual object InitializeLifetimeService();
    public void MarkAsInactive();
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelperExtension : TaskLoggingHelper {
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
internal class Microsoft.Build.BackEnd.TaskParameter : MarshalByRefObject {
    public TaskParameterType ParameterType { get; }
    public object WrappedParameter { get; }
    public TaskParameter(object wrappedParameter);
    [DebuggerStepThroughAttribute]
public TaskParameterType get_ParameterType();
    [DebuggerStepThroughAttribute]
public object get_WrappedParameter();
    public virtual string ToString();
    public sealed virtual void Translate(INodePacketTranslator translator);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    internal static TaskParameter FactoryForDeserialization(INodePacketTranslator translator);
}
internal enum Microsoft.Build.BackEnd.TaskParameterType : Enum {
    public int value__;
    public static TaskParameterType Null;
    public static TaskParameterType String;
    public static TaskParameterType StringArray;
    public static TaskParameterType ValueType;
    public static TaskParameterType ValueTypeArray;
    public static TaskParameterType ITaskItem;
    public static TaskParameterType ITaskItemArray;
    public static TaskParameterType Invalid;
}
internal static class Microsoft.Build.BackEnd.TaskParameterTypeVerifier : object {
    internal static bool IsValidScalarInputParameter(Type parameterType);
    internal static bool IsValidVectorInputParameter(Type parameterType);
    internal static bool IsAssignableToITask(Type parameterType);
    internal static bool IsValueTypeOutputParameter(Type parameterType);
    internal static bool IsValidInputParameter(Type parameterType);
    internal static bool IsValidOutputParameter(Type parameterType);
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskRequirements : Enum {
    public int value__;
    public static TaskRequirements None;
    public static TaskRequirements RequireSTAThread;
    public static TaskRequirements RequireSeparateAppDomain;
}
internal enum Microsoft.Build.BackEnd.TranslationDirection : Enum {
    public int value__;
    public static TranslationDirection WriteToStream;
    public static TranslationDirection ReadFromStream;
}
internal enum Microsoft.Build.BackEnd.WorkUnitActionCode : Enum {
    public int value__;
    public static WorkUnitActionCode Continue;
    public static WorkUnitActionCode Stop;
}
internal class Microsoft.Build.BackEnd.WorkUnitResult : object {
    internal WorkUnitResultCode ResultCode { get; }
    internal WorkUnitActionCode ActionCode { get; }
    internal Exception Exception { get; }
    internal WorkUnitResult(WorkUnitResultCode resultCode, WorkUnitActionCode actionCode, Exception e);
    internal WorkUnitResultCode get_ResultCode();
    internal WorkUnitActionCode get_ActionCode();
    internal Exception get_Exception();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static WorkUnitResult FactoryForDeserialization(INodePacketTranslator translator);
    internal WorkUnitResult AggregateResult(WorkUnitResult result);
}
internal enum Microsoft.Build.BackEnd.WorkUnitResultCode : Enum {
    public int value__;
    public static WorkUnitResultCode Skipped;
    public static WorkUnitResultCode Success;
    public static WorkUnitResultCode Failed;
    public static WorkUnitResultCode Canceled;
}
internal enum Microsoft.Build.BackEnd.YieldAction : Enum {
    public byte value__;
    public static YieldAction Yield;
    public static YieldAction Reacquire;
    public static YieldAction None;
}
internal class Microsoft.Build.Collections.BitHelper : object {
    [SecurityCriticalAttribute]
internal BitHelper(Int32* bitArrayPtr, int length);
    [SecurityCriticalAttribute]
internal BitHelper(Int32[] bitArray, int length);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static T Dequeue(ConcurrentQueue`1<T> stack);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentStackExtensions : object {
    [ExtensionAttribute]
public static T Peek(ConcurrentStack`1<T> stack);
    [ExtensionAttribute]
public static T Pop(ConcurrentStack`1<T> stack);
}
internal class Microsoft.Build.Collections.Contains`1 : MulticastDelegate {
    public Contains`1(object object, IntPtr method);
    public virtual bool Invoke(N item);
    public virtual IAsyncResult BeginInvoke(N item, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Collections.ConvertingEnumerable`2 : object {
    internal ConvertingEnumerable`2(IEnumerable`1<TFrom> backingEnumerable, Converter`2<TFrom, TTo> converter);
    public sealed virtual IEnumerator`1<TTo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Collections.CopyOnReadEnumerable`1 : object {
    public CopyOnReadEnumerable`1(IEnumerable`1<T> backingEnumerable, object syncRoot);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    internal IEqualityComparer`1<K> get_Comparer();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1 : object {
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    internal int Count { get; }
    internal ICollection`1<string> PropertyNames { get; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    internal T Item { get; internal set; }
    public CopyOnWritePropertyDictionary`1(int capacity);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    internal int get_Count();
    internal ICollection`1<string> get_PropertyNames();
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public bool Contains(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(CopyOnWritePropertyDictionary`1<T> other);
    private sealed virtual override T Microsoft.Build.Evaluation.IPropertyProvider<T>.GetProperty(string name);
    private sealed virtual override T Microsoft.Build.Evaluation.IPropertyProvider<T>.GetProperty(string name, int startIndex, int endIndex);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    internal bool Remove(string name);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal void RemoveProperties(IEnumerable`1<T> other);
    internal IDictionary`2<string, string> ToDictionary();
    internal CopyOnWritePropertyDictionary`1<T> DeepClone();
}
internal class Microsoft.Build.Collections.FilteringEnumerable`2 : ValueType {
    private IEnumerable`1<Base> enumerable;
    internal FilteringEnumerable`2(IEnumerable`1<Base> enumerable);
    public sealed virtual IEnumerator`1<Filter> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class Microsoft.Build.Collections.HashHelpers : object {
    internal static int MaxPrimeArrayLength;
    internal static Int32[] primes;
    private static HashHelpers();
    [ReliabilityContractAttribute("3", "2")]
internal static bool IsPrime(int candidate);
    [ReliabilityContractAttribute("3", "2")]
internal static int GetPrime(int min);
    internal static int GetMinPrime();
    internal static int ExpandPrime(int oldSize);
}
internal class Microsoft.Build.Collections.HashSetDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public HashSetDebugView`1(RetrievableEntryHashSet`1<T> set);
    public T[] get_Items();
}
internal static class Microsoft.Build.Collections.HashTableUtility : object {
    internal static int Compare(IDictionary`2<string, string> h1, IDictionary`2<string, string> h2);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
}
internal interface Microsoft.Build.Collections.IDeepCloneable`1 {
    public abstract virtual T DeepClone();
}
internal interface Microsoft.Build.Collections.IImmutable {
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
[DebuggerDisplayAttribute("#Item types={ItemTypes.Count} #Items={Count}")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ItemDictionary`1 : object {
    internal int Count { get; }
    internal ICollection`1<string> ItemTypes { get; }
    internal ICollection`1<T> Item { get; }
    internal ItemDictionary`1(int initialItemTypesCapacity);
    internal ItemDictionary`1(IEnumerable`1<T> items);
    internal int get_Count();
    internal ICollection`1<string> get_ItemTypes();
    internal ICollection`1<T> get_Item(string itemtype);
    public void Clear();
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ICollection`1<T> GetItems(string itemType);
    internal bool Contains(T projectItem);
    internal void Add(T projectItem);
    internal bool Remove(T projectItem);
    internal void Replace(T existingItem, T newItem);
    internal void ImportItems(IEnumerable`1<T> other);
    internal void ImportItemsOfType(string itemType, IEnumerable`1<T> items);
    internal void RemoveItems(IEnumerable`1<T> other);
    internal void AddEmptyMarker(string itemType);
    internal bool HasEmptyMarker(string itemType);
}
internal interface Microsoft.Build.Collections.IValued {
    public string EscapedValue { get; }
    public abstract virtual string get_EscapedValue();
}
internal class Microsoft.Build.Collections.LookasideStringInterner : object {
    public LookasideStringInterner(StringComparer comparer, int defaultCollectionSize);
    public LookasideStringInterner(INodePacketTranslator translator);
    public int Intern(string str);
    public string GetString(int index);
    public sealed virtual void Translate(INodePacketTranslator translator);
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : EqualityComparer`1<string> {
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    internal static MSBuildNameIgnoreCaseComparer Mutable { get; }
    private static MSBuildNameIgnoreCaseComparer();
    internal static MSBuildNameIgnoreCaseComparer get_Default();
    internal static MSBuildNameIgnoreCaseComparer get_Mutable();
    public static bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public T GetValueWithConstraints(IDictionary`2<string, T> dictionary, string key, int startIndex, int endIndex);
    public sealed virtual bool Equals(IKeyed x, IKeyed y);
    public virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(IKeyed keyed);
    public virtual int GetHashCode(string obj);
    internal void SetConstraintsForUnitTestingOnly(string constraintString, int startIndex, int endIndex);
    internal void RemoveConstraintsForUnitTestingOnly();
}
[DebuggerDisplayAttribute("#Keys={KeyCount} #Values={ValueCount}")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.MultiDictionary`2 : object {
    internal int KeyCount { get; }
    internal int ValueCount { get; }
    internal IEnumerable`1<K> Keys { get; }
    internal IEnumerable`1<V> Item { get; }
    internal MultiDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal int get_KeyCount();
    internal int get_ValueCount();
    internal IEnumerable`1<K> get_Keys();
    internal IEnumerable`1<V> get_Item(K key);
    internal void Add(K key, V value);
    internal bool Remove(K key, V value);
    internal void Clear();
}
internal class Microsoft.Build.Collections.OrdinalIgnoreCaseKeyedComparer : object {
    internal static OrdinalIgnoreCaseKeyedComparer Instance { get; }
    private static OrdinalIgnoreCaseKeyedComparer();
    internal static OrdinalIgnoreCaseKeyedComparer get_Instance();
    public sealed virtual bool Equals(IKeyed one, IKeyed two);
    public sealed virtual int GetHashCode(IKeyed item);
}
internal class Microsoft.Build.Collections.OrdinalKeyedComparer : object {
    internal static OrdinalKeyedComparer Instance { get; }
    private static OrdinalKeyedComparer();
    internal static OrdinalKeyedComparer get_Instance();
    public sealed virtual bool Equals(IKeyed one, IKeyed two);
    public sealed virtual int GetHashCode(IKeyed item);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.PropertyDictionary`1 : object {
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    internal int Count { get; }
    [DebuggerBrowsableAttribute("0")]
internal ICollection`1<string> PropertyNames { get; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    internal T Item { get; internal set; }
    internal PropertyDictionary`1(int capacity);
    internal PropertyDictionary`1(IEnumerable`1<T> elements);
    internal PropertyDictionary`1(int capacity, IEnumerable`1<T> elements);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    internal int get_Count();
    internal ICollection`1<string> get_PropertyNames();
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public bool Contains(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(PropertyDictionary`1<T> other);
    public sealed virtual T GetProperty(string name);
    public sealed virtual T GetProperty(string name, int startIndex, int endIndex);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    internal bool Remove(string name);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal void RemoveProperties(IEnumerable`1<T> other);
    internal IDictionary`2<string, string> ToDictionary();
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal class Microsoft.Build.Collections.ReadOnlyConvertingCollection`2 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal ReadOnlyConvertingCollection`2(ICollection`1<V> backing, Converter`2<V, N> converter);
    internal ReadOnlyConvertingCollection`2(ICollection`1<V> backing, Converter`2<V, N> converter, Contains`1<N> contains);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(N item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(N item);
    public sealed virtual void CopyTo(N[] array, int arrayIndex);
    public sealed virtual bool Remove(N item);
    public sealed virtual IEnumerator`1<N> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3 : object {
    public ICollection`1<K> Keys { get; }
    public ICollection`1<N> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public N Item { get; public set; }
    internal ReadOnlyConvertingDictionary`3(IDictionary`2<K, V> backing, Converter`2<V, N> converter);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<N> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual N get_Item(K key);
    public sealed virtual void set_Item(K key, N value);
    public sealed virtual void Add(K key, N value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, N& value);
    public sealed virtual void Add(KeyValuePair`2<K, N> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, N> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, N> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, N>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
[DebuggerDisplayAttribute("Count = 0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyList`1 : object {
    public static ReadOnlyEmptyList`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    public static ReadOnlyEmptyList`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Build.Collections.HashSetDebugView`1")]
internal class Microsoft.Build.Collections.RetrievableEntryHashSet`1 : object {
    public ICollection`1<string> Keys { get; }
    public ICollection`1<T> Values { get; }
    internal T Item { get; internal set; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IEqualityComparer`1<IKeyed> Comparer { get; }
    public RetrievableEntryHashSet`1(IEqualityComparer`1<IKeyed> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<IKeyed> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(IEnumerable`1<KeyValuePair`2<string, T>> collection, IEqualityComparer`1<IKeyed> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(int suggestedCapacity, IEqualityComparer`1<IKeyed> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<IKeyed> comparer);
    protected RetrievableEntryHashSet`1(SerializationInfo info, StreamingContext context);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<T> get_Values();
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    internal bool Contains(string key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> entry);
    public sealed virtual bool ContainsKey(string key);
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool TryGetValue(string key, T& item);
    public T Get(string key);
    public T Get(IKeyed item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(string item);
    public sealed virtual bool Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> entry);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal void MakeReadOnly();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public void Add(T item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> entry);
    public void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int index);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public IEqualityComparer`1<IKeyed> get_Comparer();
    public void TrimExcess();
    internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet`1<T> other);
    internal T[] ToArray();
}
internal class Microsoft.Build.Collections.Triple`3 : ValueType {
    private A first;
    private B second;
    private C third;
    public A First { get; }
    public B Second { get; }
    public C Third { get; }
    public Triple`3(A first, B second, C third);
    public A get_First();
    public B get_Second();
    public C get_Third();
}
[DebuggerDisplayAttribute("#Entries={backingDictionary.Count}")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.WeakDictionary`2 : object {
    internal int Count { get; }
    internal V Item { get; internal set; }
    internal WeakDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal int get_Count();
    internal V get_Item(K key);
    internal void set_Item(K key, V value);
    internal bool Contains(K key);
    internal bool TryGetValue(K key, V& value);
    internal bool Remove(K key);
    internal int Scavenge();
    internal void Clear();
}
internal class Microsoft.Build.Collections.WeakReference`1 : object {
    internal T Target { get; }
    internal WeakReference`1(T target);
    internal T get_Target();
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.WeakValueDictionary`2 : object {
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public V Item { get; public set; }
    public WeakValueDictionary`2(IEqualityComparer`1<K> keyComparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool Contains(K key);
    public bool TryGetValue(K key, V& value);
    public bool Remove(K key);
    public int Scavenge();
    public void Clear();
}
internal class Microsoft.Build.Construction.AspNetCompilerParameters : ValueType {
    internal string aspNetVirtualPath;
    internal string aspNetPhysicalPath;
    internal string aspNetTargetPath;
    internal string aspNetForce;
    internal string aspNetUpdateable;
    internal string aspNetDebug;
    internal string aspNetKeyFile;
    internal string aspNetKeyContainer;
    internal string aspNetDelaySign;
    internal string aspNetAPTCA;
    internal string aspNetFixedNames;
}
internal class Microsoft.Build.Construction.ConfigurationInSolution : object {
    internal static char configurationPlatformSeparator;
    internal string ConfigurationName { get; }
    internal string PlatformName { get; }
    internal string FullName { get; }
    internal ConfigurationInSolution(string configurationName, string platformName);
    internal string get_ConfigurationName();
    internal string get_PlatformName();
    internal string get_FullName();
}
public abstract class Microsoft.Build.Construction.ElementLocation : object {
    [DebuggerBrowsableAttribute("0")]
public string File { get; }
    [DebuggerBrowsableAttribute("0")]
public int Line { get; }
    [DebuggerBrowsableAttribute("0")]
public int Column { get; }
    public string LocationString { get; }
    internal static ElementLocation EmptyLocation { get; }
    private static ElementLocation();
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public sealed virtual string get_LocationString();
    internal static ElementLocation get_EmptyLocation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static IElementLocation FactoryForDeserialization(INodePacketTranslator translator);
    internal static ElementLocation Create(string file);
    internal static ElementLocation Create(string file, int line, int column);
}
[DebuggerDisplayAttribute("ProjectChooseElement (#Children={Count} HasOtherwise={OtherwiseElement != null})")]
public class Microsoft.Build.Construction.ProjectChooseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectWhenElement> WhenElements { get; }
    public ProjectOtherwiseElement OtherwiseElement { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectChooseElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectWhenElement> get_WhenElements();
    public ProjectOtherwiseElement get_OtherwiseElement();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
internal class Microsoft.Build.Construction.ProjectConfigurationInSolution : ConfigurationInSolution {
    internal bool IncludeInBuild { get; }
    internal ProjectConfigurationInSolution(string configurationName, string platformName, bool includeInBuild);
    internal bool get_IncludeInBuild();
}
public abstract class Microsoft.Build.Construction.ProjectElement : object {
    public string Condition { get; public set; }
    public string Label { get; public set; }
    public ProjectElementContainer Parent { get; internal set; }
    public IEnumerable`1<ProjectElementContainer> AllParents { get; }
    public ProjectElement PreviousSibling { get; internal set; }
    public ProjectElement NextSibling { get; internal set; }
    public ProjectRootElement ContainingProject { get; internal set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation LabelLocation { get; }
    public ElementLocation Location { get; }
    internal string ElementName { get; }
    internal XmlElementWithLocation XmlElement { get; private set; }
    internal XmlDocumentWithLocation XmlDocument { get; }
    internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Label();
    [DebuggerStepThroughAttribute]
public void set_Label(string value);
    [DebuggerStepThroughAttribute]
public ProjectElementContainer get_Parent();
    internal void set_Parent(ProjectElementContainer value);
    public IEnumerable`1<ProjectElementContainer> get_AllParents();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public ProjectElement get_PreviousSibling();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
internal void set_PreviousSibling(ProjectElement value);
    [DebuggerStepThroughAttribute]
[CompilerGeneratedAttribute]
public ProjectElement get_NextSibling();
    [DebuggerStepThroughAttribute]
[CompilerGeneratedAttribute]
internal void set_NextSibling(ProjectElement value);
    public ProjectRootElement get_ContainingProject();
    internal void set_ContainingProject(ProjectRootElement value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_LabelLocation();
    public ElementLocation get_Location();
    internal string get_ElementName();
    [CompilerGeneratedAttribute]
internal XmlElementWithLocation get_XmlElement();
    [CompilerGeneratedAttribute]
private void set_XmlElement(XmlElementWithLocation value);
    [DebuggerStepThroughAttribute]
internal XmlDocumentWithLocation get_XmlDocument();
    internal void SetProjectRootElementFromParser(XmlElementWithLocation xmlElement, ProjectRootElement projectRootElement);
    internal void ClearParent();
    internal void ReplaceElement(XmlElementWithLocation newElement);
    internal abstract virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer proposedParent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
    internal virtual void OnAfterParentChanged(ProjectElementContainer newParent);
}
public abstract class Microsoft.Build.Construction.ProjectElementContainer : ProjectElement {
    public IEnumerable`1<ProjectElement> AllChildren { get; }
    public ICollection`1<ProjectElement> Children { get; }
    public ICollection`1<ProjectElement> ChildrenReversed { get; }
    public int Count { get; }
    public ProjectElement FirstChild { get; private set; }
    public ProjectElement LastChild { get; private set; }
    internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public IEnumerable`1<ProjectElement> get_AllChildren();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_Children();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_ChildrenReversed();
    [DebuggerStepThroughAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public ProjectElement get_FirstChild();
    [DebuggerStepThroughAttribute]
[CompilerGeneratedAttribute]
private void set_FirstChild(ProjectElement value);
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public ProjectElement get_LastChild();
    [DebuggerStepThroughAttribute]
[CompilerGeneratedAttribute]
private void set_LastChild(ProjectElement value);
    public void InsertAfterChild(ProjectElement child, ProjectElement reference);
    public void InsertBeforeChild(ProjectElement child, ProjectElement reference);
    public void AppendChild(ProjectElement child);
    public void PrependChild(ProjectElement child);
    public void RemoveChild(ProjectElement child);
    public void RemoveAllChildren();
    internal void AppendParentedChildNoChecks(ProjectElement child);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Construction.ProjectExtensionsElement : ProjectElement {
    public string Condition { get; public set; }
    public string Content { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public string Item { get; public set; }
    internal ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement project);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Content();
    public void set_Content(string value);
    public virtual ElementLocation get_ConditionLocation();
    public string get_Item(string name);
    public void set_Item(string name, string value);
    internal static ProjectExtensionsElement CreateParented(XmlElementWithLocation element, ProjectRootElement parent, ProjectRootElement containingProject);
    internal static ProjectExtensionsElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("Project={Project} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectImportElement : ProjectElement {
    public string Project { get; public set; }
    public ElementLocation ProjectLocation { get; }
    internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public string get_Project();
    public void set_Project(string value);
    public ElementLocation get_ProjectLocation();
    internal static ProjectImportElement CreateDisconnected(string project, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("#Imports={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectImportGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectImportElement> Imports { get; }
    internal ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectImportElement> get_Imports();
    public ProjectImportElement AddImport(string project);
    internal static ProjectImportGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
internal class Microsoft.Build.Construction.ProjectInSolution : object {
    internal static int DependencyLevelUnknown;
    internal static int DependencyLevelBeingDetermined;
    internal static String[] projectNamesToDisambiguate;
    internal SolutionProjectType ProjectType { get; internal set; }
    internal string ProjectName { get; internal set; }
    internal string RelativePath { get; internal set; }
    internal string AbsolutePath { get; }
    internal string Extension { get; }
    internal string ProjectGuid { get; internal set; }
    internal ArrayList Dependencies { get; }
    internal ArrayList ProjectReferences { get; }
    internal string ParentProjectGuid { get; internal set; }
    internal SolutionParser ParentSolution { get; internal set; }
    internal Hashtable AspNetConfigurations { get; internal set; }
    internal Dictionary`2<string, ProjectConfigurationInSolution> ProjectConfigurations { get; }
    internal int DependencyLevel { get; internal set; }
    internal bool IsStaticLibrary { get; internal set; }
    internal bool ChildReferencesGathered { get; internal set; }
    internal string TargetFrameworkMoniker { get; internal set; }
    internal ProjectInSolution(SolutionParser solution);
    private static ProjectInSolution();
    internal SolutionProjectType get_ProjectType();
    internal void set_ProjectType(SolutionProjectType value);
    internal string get_ProjectName();
    internal void set_ProjectName(string value);
    internal string get_RelativePath();
    internal void set_RelativePath(string value);
    internal string get_AbsolutePath();
    internal string get_Extension();
    internal string get_ProjectGuid();
    internal void set_ProjectGuid(string value);
    internal ArrayList get_Dependencies();
    internal ArrayList get_ProjectReferences();
    internal string get_ParentProjectGuid();
    internal void set_ParentProjectGuid(string value);
    internal SolutionParser get_ParentSolution();
    internal void set_ParentSolution(SolutionParser value);
    internal Hashtable get_AspNetConfigurations();
    internal void set_AspNetConfigurations(Hashtable value);
    internal Dictionary`2<string, ProjectConfigurationInSolution> get_ProjectConfigurations();
    internal int get_DependencyLevel();
    internal void set_DependencyLevel(int value);
    internal bool get_IsStaticLibrary();
    internal void set_IsStaticLibrary(bool value);
    internal bool get_ChildReferencesGathered();
    internal void set_ChildReferencesGathered(bool value);
    internal string get_TargetFrameworkMoniker();
    internal void set_TargetFrameworkMoniker(string value);
    internal bool CanBeMSBuildProjectFile(String& errorMessage);
    internal string GetUniqueProjectName();
    internal void UpdateUniqueProjectName(string newUniqueName);
    internal static string DisambiguateProjectTargetName(string uniqueProjectName);
}
[DebuggerDisplayAttribute("{ItemType} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionElement : ProjectElementContainer {
    public string ItemType { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    internal ProjectItemDefinitionElement(XmlElement xmlElement, ProjectItemDefinitionGroupElement parent, ProjectRootElement containingProject);
    public string get_ItemType();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    internal static ProjectItemDefinitionElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("#ItemDefinitions={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    internal static ProjectItemDefinitionGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("{ItemType} Include={Include} Exclude={Exclude} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemElement : ProjectElementContainer {
    public string ItemType { get; public set; }
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string Remove { get; public set; }
    public string KeepMetadata { get; public set; }
    public string RemoveMetadata { get; public set; }
    public string KeepDuplicates { get; public set; }
    public bool HasMetadata { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    internal bool IncludeHasWildcards { get; }
    internal ProjectItemElement NextItem { get; }
    internal ProjectItemElement(XmlElementWithLocation xmlElement, ProjectItemGroupElement parent, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_Include();
    public void set_Include(string value);
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    public void set_Exclude(string value);
    [DebuggerStepThroughAttribute]
public string get_Remove();
    public void set_Remove(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    public void set_KeepMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    public void set_RemoveMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    public void set_KeepDuplicates(string value);
    public bool get_HasMetadata();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ElementLocation get_IncludeLocation();
    public ElementLocation get_ExcludeLocation();
    public ElementLocation get_RemoveLocation();
    public ElementLocation get_KeepMetadataLocation();
    public ElementLocation get_RemoveMetadataLocation();
    public ElementLocation get_KeepDuplicatesLocation();
    internal bool get_IncludeHasWildcards();
    internal ProjectItemElement get_NextItem();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    internal static ProjectItemElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal void ChangeItemType(string newItemType);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void OnAfterParentChanged(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("#Items={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectItemElement> Items { get; }
    internal bool DefinitelyAreNoChildrenWithWildcards { get; internal set; }
    internal ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemElement> get_Items();
    internal bool get_DefinitelyAreNoChildrenWithWildcards();
    internal void set_DefinitelyAreNoChildrenWithWildcards(bool value);
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    internal static ProjectItemGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectMetadataElement : ProjectElement {
    public string Name { get; public set; }
    public string Value { get; public set; }
    internal ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal void ChangeName(string newName);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("ExecuteTargets={ExecuteTargets}")]
public class Microsoft.Build.Construction.ProjectOnErrorElement : ProjectElement {
    public string ExecuteTargetsAttribute { get; public set; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement project);
    [DebuggerStepThroughAttribute]
public string get_ExecuteTargetsAttribute();
    public void set_ExecuteTargetsAttribute(string value);
    public ElementLocation get_ExecuteTargetsLocation();
    internal static ProjectOnErrorElement CreateDisconnected(string executeTargets, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("#Children={Count}")]
public class Microsoft.Build.Construction.ProjectOtherwiseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectOtherwiseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("Name={Name} TaskParameter={TaskParameter} ItemName={ItemName} PropertyName={PropertyName} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectOutputElement : ProjectElement {
    public string TaskParameter { get; public set; }
    public bool IsOutputItem { get; }
    public bool IsOutputProperty { get; }
    public string ItemType { get; public set; }
    public string PropertyName { get; public set; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectOutputElement(XmlElement xmlElement, ProjectTaskElement parent, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_TaskParameter();
    [DebuggerStepThroughAttribute]
public void set_TaskParameter(string value);
    public bool get_IsOutputItem();
    public bool get_IsOutputProperty();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_PropertyName();
    public void set_PropertyName(string value);
    public ElementLocation get_TaskParameterLocation();
    public ElementLocation get_PropertyNameLocation();
    public ElementLocation get_ItemTypeLocation();
    internal static ProjectOutputElement CreateDisconnected(string taskParameter, string itemType, string propertyName, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
internal class Microsoft.Build.Construction.ProjectParser : object {
    internal static int MaximumChooseNesting;
    private static ProjectParser();
    internal static void Parse(XmlDocumentWithLocation document, ProjectRootElement projectRootElement);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectPropertyElement : ProjectElement {
    public string Name { get; public set; }
    public string Value { get; public set; }
    internal ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectPropertyGroupElement parent, ProjectRootElement containingProject);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectPropertyElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal void ChangeName(string newName);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("#Properties={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectPropertyGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectPropertyElement> PropertiesReversed { get; }
    internal ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectPropertyElement> get_PropertiesReversed();
    public ProjectPropertyElement AddProperty(string name, string unevaluatedValue);
    public ProjectPropertyElement SetProperty(string name, string unevaluatedValue);
    internal static ProjectPropertyGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")]
public class Microsoft.Build.Construction.ProjectRootElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroups { get; }
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectItemElement> Items { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroups { get; }
    public ICollection`1<ProjectImportElement> Imports { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectTargetElement> Targets { get; }
    public ICollection`1<ProjectUsingTaskElement> UsingTasks { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroupsReversed { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroupsReversed { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroupsReversed { get; }
    public string DirectoryPath { get; internal set; }
    public string FullPath { get; public set; }
    public Encoding Encoding { get; }
    public string DefaultTargets { get; public set; }
    public string InitialTargets { get; public set; }
    public string TreatAsLocalProperty { get; public set; }
    public string ToolsVersion { get; public set; }
    public string RawXml { get; }
    public bool HasUnsavedChanges { get; }
    public int Version { get; }
    public DateTime TimeLastChanged { get; }
    public DateTime LastWriteTimeWhenRead { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ProjectFileLocation { get; }
    public ElementLocation ToolsVersionLocation { get; }
    public ElementLocation DefaultTargetsLocation { get; }
    public ElementLocation InitialTargetsLocation { get; }
    public ElementLocation TreatAsLocalPropertyLocation { get; }
    internal bool IsExplicitlyLoaded { get; private set; }
    internal ProjectRootElementCache ProjectRootElementCache { get; }
    internal bool IsMemberOfProjectCollection { get; }
    internal bool ContainsTargetsWithReturnsAttribute { get; internal set; }
    internal ProjectExtensionsElement ProjectExtensions { get; }
    internal string LastDirtyReason { get; }
    internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded);
    private static ProjectRootElement();
    internal void add_OnAfterProjectRename(RenameHandlerDelegate value);
    internal void remove_OnAfterProjectRename(RenameHandlerDelegate value);
    internal void add_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    internal void remove_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroups();
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectItemElement> get_Items();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroups();
    public ICollection`1<ProjectImportElement> get_Imports();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectTargetElement> get_Targets();
    public ICollection`1<ProjectUsingTaskElement> get_UsingTasks();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroupsReversed();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroupsReversed();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroupsReversed();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroupsReversed();
    [DebuggerStepThroughAttribute]
public string get_DirectoryPath();
    internal void set_DirectoryPath(string value);
    public string get_FullPath();
    public void set_FullPath(string value);
    public Encoding get_Encoding();
    [DebuggerStepThroughAttribute]
public string get_DefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_DefaultTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_InitialTargets();
    [DebuggerStepThroughAttribute]
public void set_InitialTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_TreatAsLocalProperty();
    [DebuggerStepThroughAttribute]
public void set_TreatAsLocalProperty(string value);
    [DebuggerStepThroughAttribute]
public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public void set_ToolsVersion(string value);
    public string get_RawXml();
    public bool get_HasUnsavedChanges();
    public int get_Version();
    [DebuggerStepThroughAttribute]
public DateTime get_TimeLastChanged();
    [DebuggerStepThroughAttribute]
public DateTime get_LastWriteTimeWhenRead();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ProjectFileLocation();
    public ElementLocation get_ToolsVersionLocation();
    public ElementLocation get_DefaultTargetsLocation();
    public ElementLocation get_InitialTargetsLocation();
    public ElementLocation get_TreatAsLocalPropertyLocation();
    [CompilerGeneratedAttribute]
internal bool get_IsExplicitlyLoaded();
    [CompilerGeneratedAttribute]
private void set_IsExplicitlyLoaded(bool value);
    [DebuggerStepThroughAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    internal bool get_IsMemberOfProjectCollection();
    [CompilerGeneratedAttribute]
internal bool get_ContainsTargetsWithReturnsAttribute();
    [CompilerGeneratedAttribute]
internal void set_ContainsTargetsWithReturnsAttribute(bool value);
    internal ProjectExtensionsElement get_ProjectExtensions();
    internal string get_LastDirtyReason();
    public static ProjectRootElement Create();
    public static ProjectRootElement Create(ProjectCollection projectCollection);
    public static ProjectRootElement Create(string path);
    public static ProjectRootElement Create(string path, ProjectCollection projectCollection);
    public static ProjectRootElement Create(XmlReader xmlReader);
    public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection);
    public static ProjectRootElement Open(string path);
    public static ProjectRootElement Open(string path, ProjectCollection projectCollection);
    public static ProjectRootElement TryOpen(string path);
    public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection);
    public ProjectImportElement AddImport(string project);
    public ProjectImportGroupElement AddImportGroup();
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    public ProjectItemDefinitionGroupElement AddItemDefinitionGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectPropertyElement AddProperty(string name, string value);
    public ProjectTargetElement AddTarget(string name);
    public ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName);
    public ProjectChooseElement CreateChooseElement();
    public ProjectImportElement CreateImportElement(string project);
    public ProjectItemElement CreateItemElement(string itemType);
    public ProjectItemElement CreateItemElement(string itemType, string include);
    public ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
    public ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
    public ProjectItemGroupElement CreateItemGroupElement();
    public ProjectImportGroupElement CreateImportGroupElement();
    public ProjectMetadataElement CreateMetadataElement(string name);
    public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
    public ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
    public ProjectOtherwiseElement CreateOtherwiseElement();
    public ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
    public ProjectExtensionsElement CreateProjectExtensionsElement();
    public ProjectPropertyGroupElement CreatePropertyGroupElement();
    public ProjectPropertyElement CreatePropertyElement(string name);
    public ProjectTargetElement CreateTargetElement(string name);
    public ProjectTaskElement CreateTaskElement(string name);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
    public UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
    public ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
    public ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
    public ProjectWhenElement CreateWhenElement(string condition);
    public void Save();
    public void Save(Encoding saveEncoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    internal static ProjectRootElement Create(ProjectRootElementCache projectRootElementCache);
    internal static ProjectRootElement Open(string path, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded);
    internal static ProjectRootElement Open(XmlDocumentWithLocation document);
    internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, ProjectRootElementCache projectRootElementCache, BuildEventContext buildEventContext, bool isExplicitlyLoaded);
    internal XmlElementWithLocation CreateElement(string name);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal sealed virtual void MarkDirty(string reason, string param);
    internal void MarkProjectDirty(Project project);
    internal void MarkAsExplicitlyLoaded();
}
[DebuggerDisplayAttribute("#Strings={Count} #Documents={documents.Count}")]
internal class Microsoft.Build.Construction.ProjectStringCache : object {
    internal int Count { get; }
    internal int get_Count();
    public string Add(string key, XmlDocument document);
    public string Get(string key);
    public void Clear(XmlDocument document);
}
[DebuggerDisplayAttribute("Name={Name} #Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectTargetElement : ProjectElementContainer {
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectTaskElement> Tasks { get; }
    public ICollection`1<ProjectOnErrorElement> OnErrors { get; }
    public string Name { get; public set; }
    public string Inputs { get; public set; }
    public string Outputs { get; public set; }
    public string KeepDuplicateOutputs { get; public set; }
    public string DependsOnTargets { get; public set; }
    public string BeforeTargets { get; public set; }
    public string AfterTargets { get; public set; }
    public string Returns { get; public set; }
    public ElementLocation NameLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    internal ProjectTargetInstance TargetInstance { get; internal set; }
    internal ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectTaskElement> get_Tasks();
    public ICollection`1<ProjectOnErrorElement> get_OnErrors();
    [DebuggerStepThroughAttribute]
public string get_Name();
    public void set_Name(string value);
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    public void set_Inputs(string value);
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    public void set_Outputs(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    public void set_KeepDuplicateOutputs(string value);
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    public void set_DependsOnTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_BeforeTargets();
    public void set_BeforeTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_AfterTargets();
    public void set_AfterTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_Returns();
    public void set_Returns(string value);
    public ElementLocation get_NameLocation();
    public ElementLocation get_InputsLocation();
    public ElementLocation get_OutputsLocation();
    public ElementLocation get_KeepDuplicateOutputsLocation();
    public ElementLocation get_DependsOnTargetsLocation();
    public ElementLocation get_BeforeTargetsLocation();
    public ElementLocation get_ReturnsLocation();
    public ElementLocation get_AfterTargetsLocation();
    [CompilerGeneratedAttribute]
internal ProjectTargetInstance get_TargetInstance();
    [CompilerGeneratedAttribute]
internal void set_TargetInstance(ProjectTargetInstance value);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectTaskElement AddTask(string taskName);
    internal static ProjectTargetElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
}
[DebuggerDisplayAttribute("{Name} Condition={Condition} ContinueOnError={ContinueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Outputs={Count}")]
public class Microsoft.Build.Construction.ProjectTaskElement : ProjectElementContainer {
    public string ContinueOnError { get; public set; }
    public string MSBuildRuntime { get; public set; }
    public string MSBuildArchitecture { get; public set; }
    public string Name { get; }
    public ICollection`1<ProjectOutputElement> Outputs { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> ParameterLocations { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    internal CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> ParametersForEvaluation { get; }
    internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public void set_ContinueOnError(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildRuntime();
    [DebuggerStepThroughAttribute]
public void set_MSBuildRuntime(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildArchitecture();
    [DebuggerStepThroughAttribute]
public void set_MSBuildArchitecture(string value);
    public string get_Name();
    public ICollection`1<ProjectOutputElement> get_Outputs();
    public IDictionary`2<string, string> get_Parameters();
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> get_ParameterLocations();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    internal CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> get_ParametersForEvaluation();
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType);
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition);
    public string GetParameter(string name);
    public void SetParameter(string name, string unevaluatedValue);
    public void RemoveParameter(string name);
    public void RemoveAllParameters();
    internal static ProjectTaskElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("Evaluate={Evaluate} TaskBody={TaskBody}")]
public class Microsoft.Build.Construction.ProjectUsingTaskBodyElement : ProjectElement {
    public string Condition { get; public set; }
    public string TaskBody { get; public set; }
    public string Evaluate { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation EvaluateLocation { get; }
    internal ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectUsingTaskElement parent, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public string get_TaskBody();
    public void set_TaskBody(string value);
    public string get_Evaluate();
    public void set_Evaluate(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_EvaluateLocation();
    internal static ProjectUsingTaskBodyElement CreateDisconnected(string evaluate, string body, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("TaskName={TaskName} AssemblyName={AssemblyName} AssemblyFile={AssemblyFile} Condition={Condition} Runtime={Runtime} Architecture={Architecture}")]
public class Microsoft.Build.Construction.ProjectUsingTaskElement : ProjectElementContainer {
    public string AssemblyFile { get; public set; }
    public string AssemblyName { get; public set; }
    public string TaskName { get; public set; }
    public string TaskFactory { get; public set; }
    public string Runtime { get; public set; }
    public string Architecture { get; public set; }
    public ProjectUsingTaskBodyElement TaskBody { get; }
    public UsingTaskParameterGroupElement ParameterGroup { get; }
    public ElementLocation TaskNameLocation { get; }
    public ElementLocation AssemblyFileLocation { get; }
    public ElementLocation AssemblyNameLocation { get; }
    public ElementLocation RuntimeLocation { get; }
    public ElementLocation ArchitectureLocation { get; }
    public ElementLocation TaskFactoryLocation { get; }
    internal ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    public string get_AssemblyFile();
    public void set_AssemblyFile(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_TaskName();
    public void set_TaskName(string value);
    public string get_TaskFactory();
    public void set_TaskFactory(string value);
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_Architecture();
    public void set_Architecture(string value);
    public ProjectUsingTaskBodyElement get_TaskBody();
    public UsingTaskParameterGroupElement get_ParameterGroup();
    public ElementLocation get_TaskNameLocation();
    public ElementLocation get_AssemblyFileLocation();
    public ElementLocation get_AssemblyNameLocation();
    public ElementLocation get_RuntimeLocation();
    public ElementLocation get_ArchitectureLocation();
    public ElementLocation get_TaskFactoryLocation();
    public UsingTaskParameterGroupElement AddParameterGroup();
    public ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string taskBody);
    internal static ProjectUsingTaskElement CreateDisconnected(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("Name={Name} ParameterType={ParameterType} Output={Output} Required={Required}")]
public class Microsoft.Build.Construction.ProjectUsingTaskParameterElement : ProjectElement {
    public string Condition { get; public set; }
    public string Name { get; public set; }
    public string ParameterType { get; public set; }
    public string Output { get; public set; }
    public string Required { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ParameterTypeLocation { get; }
    public ElementLocation OutputLocation { get; }
    public ElementLocation RequiredLocation { get; }
    internal ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, UsingTaskParameterGroupElement parent, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Name();
    public void set_Name(string value);
    public string get_ParameterType();
    public void set_ParameterType(string value);
    public string get_Output();
    public void set_Output(string value);
    public string get_Required();
    public void set_Required(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ParameterTypeLocation();
    public ElementLocation get_OutputLocation();
    public ElementLocation get_RequiredLocation();
    internal static ProjectUsingTaskParameterElement CreateDisconnected(string parameterName, string output, string required, string parameterType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
[DebuggerDisplayAttribute("#Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectWhenElement : ProjectElementContainer {
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    internal ProjectWhenElement(XmlElement xmlElement, ProjectChooseElement parent, ProjectRootElement containingProject);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    internal static ProjectWhenElement CreateDisconnected(string condition, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
internal class Microsoft.Build.Construction.RegistryLocation : object {
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    internal RegistryLocation(string registryPath);
    public sealed virtual string get_File();
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public sealed virtual string get_LocationString();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static RegistryLocation FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.Construction.RenameHandlerDelegate : MulticastDelegate {
    public RenameHandlerDelegate(object object, IntPtr method);
    public virtual void Invoke(string oldFullPath);
    public virtual IAsyncResult BeginInvoke(string oldFullPath, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Construction.SolutionParser : object {
    internal static int slnFileMinUpgradableVersion;
    internal static int slnFileMinVersion;
    internal static int slnFileMaxVersion;
    internal ArrayList SolutionParserWarnings { get; }
    internal ArrayList SolutionParserComments { get; }
    internal ArrayList SolutionParserErrorCodes { get; }
    internal int Version { get; }
    internal bool ContainsWebProjects { get; }
    internal bool ContainsWebDeploymentProjects { get; }
    internal ArrayList ProjectsInOrder { get; internal set; }
    internal Hashtable ProjectsByGuid { get; internal set; }
    internal string SolutionFile { get; internal set; }
    internal string SolutionFileDirectory { get; internal set; }
    internal StreamReader SolutionReader { get; internal set; }
    internal ProjectInSolution[] Projects { get; }
    internal List`1<ConfigurationInSolution> SolutionConfigurations { get; }
    private static SolutionParser();
    internal ArrayList get_SolutionParserWarnings();
    internal ArrayList get_SolutionParserComments();
    internal ArrayList get_SolutionParserErrorCodes();
    internal int get_Version();
    internal bool get_ContainsWebProjects();
    internal bool get_ContainsWebDeploymentProjects();
    internal ArrayList get_ProjectsInOrder();
    internal void set_ProjectsInOrder(ArrayList value);
    internal Hashtable get_ProjectsByGuid();
    internal void set_ProjectsByGuid(Hashtable value);
    internal string get_SolutionFile();
    internal void set_SolutionFile(string value);
    internal string get_SolutionFileDirectory();
    internal void set_SolutionFileDirectory(string value);
    internal StreamReader get_SolutionReader();
    internal void set_SolutionReader(StreamReader value);
    internal ProjectInSolution[] get_Projects();
    internal List`1<ConfigurationInSolution> get_SolutionConfigurations();
    internal static int GetSolutionFileMajorVersion(string solutionFile);
    internal void ParseSolutionFileForConversion();
    internal void ParseSolutionFile();
    internal void ParseSolution();
    internal void ParseEtpProject(ProjectInSolution etpProj);
    internal void ParseFirstProjectLine(string firstLine, ProjectInSolution proj);
    internal void ParseNestedProjects();
    internal void ParseSolutionConfigurations();
    internal Hashtable ParseProjectConfigurations();
    internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurationsEntries);
    internal string GetDefaultConfigurationName();
    internal string GetDefaultPlatformName();
    internal string GetProjectUniqueNameByGuid(string projectGuid);
    internal string GetProjectRelativePathByGuid(string projectGuid);
}
internal class Microsoft.Build.Construction.SolutionProjectGenerator : object {
    internal static ProjectInstance[] Generate(SolutionParser solution, IDictionary`2<string, string> globalProperties, string toolsVersionOverride, BuildEventContext projectBuildEventContext, ILoggingService loggingService);
    internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement msbuildProject, SolutionParser solutionParser, ConfigurationInSolution solutionConfiguration);
    internal static ProjectTaskElement AddErrorWarningMessageElement(ProjectTargetElement target, string elementType, bool treatAsLiteral, string textResourceName, Object[] args);
    internal static string PredictActiveSolutionConfigurationName(SolutionParser solutionParser, IDictionary`2<string, string> globalProperties);
}
internal enum Microsoft.Build.Construction.SolutionProjectType : Enum {
    public int value__;
    public static SolutionProjectType Unknown;
    public static SolutionProjectType KnownToBeMSBuildFormat;
    public static SolutionProjectType SolutionFolder;
    public static SolutionProjectType WebProject;
    public static SolutionProjectType WebDeploymentProject;
    public static SolutionProjectType EtpSubProject;
}
[DebuggerDisplayAttribute("#Parameters={Count}")]
public class Microsoft.Build.Construction.UsingTaskParameterGroupElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectUsingTaskParameterElement> Parameters { get; }
    public ElementLocation ConditionLocation { get; }
    internal UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectUsingTaskParameterElement> get_Parameters();
    public virtual ElementLocation get_ConditionLocation();
    public ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType);
    public ProjectUsingTaskParameterElement AddParameter(string name);
    internal static UsingTaskParameterGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
}
internal class Microsoft.Build.Construction.XmlAttributeWithLocation : XmlAttribute {
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document);
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document, int lineNumber, int columnNumber);
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
}
internal class Microsoft.Build.Construction.XmlDocumentWithLocation : XmlDocument {
    internal string FullPath { get; internal set; }
    internal ProjectStringCache StringCache { get; internal set; }
    internal XmlDocumentWithLocation(bool loadAsReadOnly);
    private static XmlDocumentWithLocation();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal ProjectStringCache get_StringCache();
    internal void set_StringCache(ProjectStringCache value);
    public virtual void Load(XmlReader reader);
    public virtual void Load(string fullPath);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI);
    public virtual XmlWhitespace CreateWhitespace(string text);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlComment CreateComment(string data);
    public virtual void Save(Stream outStream);
    public virtual void Save(string filename);
    public virtual void Save(TextWriter writer);
    public virtual void Save(XmlWriter writer);
    internal static void ClearReadOnlyFlags_UnitTestsOnly();
    internal void ClearAnyCachedStrings();
}
internal class Microsoft.Build.Construction.XmlElementWithLocation : XmlElement {
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document);
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document, int lineNumber, int columnNumber);
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
    public XmlAttributeWithLocation GetAttributeWithLocation(string name);
    public virtual XmlNode RemoveChild(XmlNode oldChild);
    internal ElementLocation GetAttributeLocation(string name);
}
internal class Microsoft.Build.Construction.XmlNameTableThreadSafe : NameTable {
    public virtual string Add(string key);
    public virtual string Add(Char[] key, int start, int len);
    public virtual string Get(string value);
    public virtual string Get(Char[] key, int start, int len);
}
internal class Microsoft.Build.Debugging.DebuggerLocalType : ValueType {
    private string name;
    private Type type;
    internal string Name { get; }
    internal Type Type { get; }
    internal DebuggerLocalType(string name, Type type);
    internal string get_Name();
    internal Type get_Type();
}
public static class Microsoft.Build.Debugging.DebuggerManager : object {
    internal static bool DebuggingEnabled { get; }
    private static DebuggerManager();
    internal static bool get_DebuggingEnabled();
    internal static void Terminate();
    internal static void DefineState(ElementLocation location, string name, ICollection`1<DebuggerLocalType> earlyLocals);
    internal static void BakeStates(string fileName);
    internal static void EnterState(ElementLocation location, IDictionary`2<string, object> locals);
    internal static void PulseState(ElementLocation location, IDictionary`2<string, object> locals);
    internal static void Break();
    internal static void LeaveState(ElementLocation location);
    internal static void Initialize();
}
internal class Microsoft.Build.Evaluation.AndExpressionNode : OperatorExpressionNode {
    internal bool PossibleAndCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
}
internal static class Microsoft.Build.Evaluation.BuiltInMetadata : object {
    internal static int MetadataCount { get; }
    internal static ICollection`1<string> MetadataNames { get; }
    [DebuggerStepThroughAttribute]
internal static int get_MetadataCount();
    [DebuggerStepThroughAttribute]
internal static ICollection`1<string> get_MetadataNames();
    internal static string GetMetadataValue(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string name, String& fullPath);
    internal static string GetMetadataValueEscaped(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string name, String& fullPath);
}
internal static class Microsoft.Build.Evaluation.CharacterUtilities : object {
    internal static bool IsNumberStart(char candidate);
    internal static bool IsSimpleStringStart(char candidate);
    internal static bool IsSimpleStringChar(char candidate);
    internal static bool IsHexAlphabetic(char candidate);
    internal static bool IsHexDigit(char candidate);
}
internal static class Microsoft.Build.Evaluation.ConditionEvaluator : object {
    private static ConditionEvaluator();
    internal static void UpdateConditionedPropertiesTable(Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string leftValue, string rightValueExpanded);
    internal static bool EvaluateCondition(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext);
    internal static bool EvaluateConditionCollectingConditionedProperties(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext);
}
internal class Microsoft.Build.Evaluation.EqualExpressionNode : MultipleComparisonNode {
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
}
internal class Microsoft.Build.Evaluation.Evaluator`4 : object {
    internal static bool DebugEvaluation { get; }
    private static Evaluator`4();
    internal static bool get_DebugEvaluation();
    internal static IDictionary`2<string, object> Evaluate(IEvaluatorData`4<P, I, M, D> data, ProjectRootElement root, ProjectLoadSettings loadSettings, int maxNodeCount, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, ILoggingService loggingService, IItemFactory`2<I, I> itemFactory, IToolsetProvider toolsetProvider, ProjectRootElementCache projectRootElementCache, BuildEventContext buildEventContext, ProjectInstance projectInstanceIfAnyForDebuggerOnly);
    internal static List`1<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory`2<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander`2<P, I> expander);
}
internal class Microsoft.Build.Evaluation.EvaluatorMetadataTable : object {
    internal IEnumerable`1<EvaluatorMetadata> Entries { get; }
    public EvaluatorMetadataTable(string implicitItemType);
    internal IEnumerable`1<EvaluatorMetadata> get_Entries();
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
    internal void SetValue(ProjectMetadataElement xml, string evaluatedValueEscaped);
}
internal class Microsoft.Build.Evaluation.Expander`2 : object {
    internal bool WarnForUninitializedProperties { get; internal set; }
    internal IMetadataTable Metadata { get; internal set; }
    internal UsedUninitializedProperties UsedUninitializedProperties { get; internal set; }
    internal Expander`2(IPropertyProvider`1<P> properties);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items, IMetadataTable metadata);
    private static Expander`2();
    internal bool get_WarnForUninitializedProperties();
    internal void set_WarnForUninitializedProperties(bool value);
    internal IMetadataTable get_Metadata();
    internal void set_Metadata(IMetadataTable value);
    internal UsedUninitializedProperties get_UsedUninitializedProperties();
    internal void set_UsedUninitializedProperties(UsedUninitializedProperties value);
    internal static bool ExpressionMayContainExpandableExpressions(string expression);
    internal static bool ExpressionContainsItemVector(string expression);
    internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<string> ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandIntoItemsLeaveEscaped(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandSingleItemVectorExpressionIntoItems(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, Boolean& isTransformExpression, IElementLocation elementLocation);
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ExpanderOptions : Enum {
    public int value__;
    public static ExpanderOptions Invalid;
    public static ExpanderOptions ExpandCustomMetadata;
    public static ExpanderOptions ExpandBuiltInMetadata;
    public static ExpanderOptions ExpandMetadata;
    public static ExpanderOptions ExpandProperties;
    public static ExpanderOptions ExpandItems;
    public static ExpanderOptions BreakOnNotEmpty;
    public static ExpanderOptions ExpandPropertiesAndItems;
    public static ExpanderOptions ExpandPropertiesAndMetadata;
    public static ExpanderOptions ExpandPropertiesAndCustomMetadata;
    public static ExpanderOptions ExpandAll;
}
internal static class Microsoft.Build.Evaluation.ExpressionShredder : object {
    internal static IList`1<string> SplitSemiColonSeparatedList(string expression);
    internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(List`1<string> expressions);
    internal static bool ContainsMetadataExpressionOutsideTransform(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression, int start, int end);
}
internal class Microsoft.Build.Evaluation.FunctionCallExpressionNode : OperatorExpressionNode {
    internal FunctionCallExpressionNode(string functionName, ArrayList arguments);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
}
internal abstract class Microsoft.Build.Evaluation.GenericExpressionNode : object {
    internal bool PossibleAndCollision { get; internal set; }
    internal bool PossibleOrCollision { get; internal set; }
    internal abstract virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal abstract virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal abstract virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal abstract virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state);
    internal abstract virtual string GetExpandedValue(IConditionEvaluationState state);
    internal abstract virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal abstract virtual void ResetState();
    internal bool Evaluate(IConditionEvaluationState state);
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
    internal bool PotentialAndOrConflict();
    internal abstract virtual bool DetectOr();
    internal abstract virtual bool DetectAnd();
}
internal class Microsoft.Build.Evaluation.GreaterThanExpressionNode : NumericComparisonExpressionNode {
    protected virtual bool Compare(double left, double right);
}
internal class Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    protected virtual bool Compare(double left, double right);
}
internal interface Microsoft.Build.Evaluation.IEvaluatorData`4 {
    public string Directory { get; }
    public TaskRegistry TaskRegistry { get; public set; }
    public Toolset Toolset { get; }
    public string SubToolsetVersion { get; }
    public string ExplicitToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    public List`1<string> InitialTargets { get; public set; }
    public List`1<string> DefaultTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> BeforeTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> AfterTargets { get; public set; }
    public Dictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public bool ShouldEvaluateForDesignTime { get; }
    public PropertyDictionary`1<P> Properties { get; }
    public IEnumerable`1<D> ItemDefinitionsEnumerable { get; }
    public ItemDictionary`1<I> Items { get; }
    public abstract virtual string get_Directory();
    public abstract virtual TaskRegistry get_TaskRegistry();
    public abstract virtual void set_TaskRegistry(TaskRegistry value);
    public abstract virtual Toolset get_Toolset();
    public abstract virtual string get_SubToolsetVersion();
    public abstract virtual string get_ExplicitToolsVersion();
    public abstract virtual PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    public abstract virtual ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    public abstract virtual List`1<string> get_InitialTargets();
    public abstract virtual void set_InitialTargets(List`1<string> value);
    public abstract virtual List`1<string> get_DefaultTargets();
    public abstract virtual void set_DefaultTargets(List`1<string> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_BeforeTargets();
    public abstract virtual void set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_AfterTargets();
    public abstract virtual void set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual Dictionary`2<string, List`1<string>> get_ConditionedProperties();
    public abstract virtual bool get_ShouldEvaluateForDesignTime();
    public abstract virtual PropertyDictionary`1<P> get_Properties();
    public abstract virtual IEnumerable`1<D> get_ItemDefinitionsEnumerable();
    public abstract virtual ItemDictionary`1<I> get_Items();
    public abstract virtual void InitializeForEvaluation(IToolsetProvider toolsetProvider);
    public abstract virtual void FinishEvaluation();
    public abstract virtual void AddItem(I item);
    public abstract virtual void AddItemIgnoringCondition(I item);
    public abstract virtual IItemDefinition`1<M> AddItemDefinition(string itemType);
    public abstract virtual void AddToAllEvaluatedPropertiesList(P property);
    public abstract virtual void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
    public abstract virtual void AddToAllEvaluatedItemsList(I item);
    public abstract virtual IItemDefinition`1<M> GetItemDefinition(string itemType);
    public abstract virtual P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    public abstract virtual P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, P predecessor);
    public abstract virtual ProjectTargetInstance GetTarget(string targetName);
    public abstract virtual void AddTarget(ProjectTargetInstance target);
    public abstract virtual void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    public abstract virtual void RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    public abstract virtual string ExpandString(string unexpandedValue);
    public abstract virtual bool EvaluateCondition(string condition);
}
internal interface Microsoft.Build.Evaluation.IItem {
    public string EvaluatedInclude { get; }
    public string EvaluatedIncludeEscaped { get; }
    public string ProjectDirectory { get; }
    public abstract virtual string get_EvaluatedInclude();
    public abstract virtual string get_EvaluatedIncludeEscaped();
    public abstract virtual string get_ProjectDirectory();
    public abstract virtual string GetMetadataValue(string name);
    public abstract virtual string GetMetadataValueEscaped(string name);
}
internal interface Microsoft.Build.Evaluation.IItem`1 {
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue);
}
internal interface Microsoft.Build.Evaluation.IItemDefinition`1 {
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, M predecessor);
}
internal interface Microsoft.Build.Evaluation.IItemFactory`2 {
    public string ItemType { get; public set; }
    unknown ProjectItemElement ItemElement {public set; }
    public abstract virtual string get_ItemType();
    public abstract virtual void set_ItemType(string value);
    public abstract virtual void set_ItemElement(ProjectItemElement value);
    public abstract virtual T CreateItem(string include);
    public abstract virtual T CreateItem(S source);
    public abstract virtual T CreateItem(string include, S baseItem);
    public abstract virtual T CreateItem(string include, string includeBeforeWildcardExpansion);
    public abstract virtual void SetMetadata(IEnumerable`1<Pair`2<ProjectMetadataElement, string>> metadata, IEnumerable`1<T> destinationItems);
}
internal interface Microsoft.Build.Evaluation.IItemProvider`1 {
    public abstract virtual ICollection`1<T> GetItems(string itemType);
}
internal interface Microsoft.Build.Evaluation.IMetadataTable {
    public abstract virtual string GetEscapedValue(string name);
    public abstract virtual string GetEscapedValue(string itemType, string name);
    public abstract virtual string GetEscapedValueIfPresent(string itemType, string name);
}
internal interface Microsoft.Build.Evaluation.IMetadatum {
}
internal static class Microsoft.Build.Evaluation.IntrinsicFunctions : object {
    internal static double Add(double a, double b);
    internal static long Add(long a, long b);
    internal static double Subtract(double a, double b);
    internal static long Subtract(long a, long b);
    internal static double Multiply(double a, double b);
    internal static long Multiply(long a, long b);
    internal static double Divide(double a, double b);
    internal static long Divide(long a, long b);
    internal static double Modulo(double a, double b);
    internal static long Modulo(long a, long b);
    internal static string Escape(string unescaped);
    internal static string Unescape(string escaped);
    internal static int BitwiseOr(int first, int second);
    internal static int BitwiseAnd(int first, int second);
    internal static int BitwiseXor(int first, int second);
    internal static int BitwiseNot(int first);
    internal static object GetRegistryValue(string keyName, string valueName);
    internal static object GetRegistryValue(string keyName, string valueName, object defaultValue);
    internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, Object[] views);
    internal static string MakeRelative(string basePath, string path);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName);
    internal static string ValueOrDefault(string conditionValue, string defaultValue);
    internal static bool DoesTaskHostExist(string runtime, string architecture);
    internal static List`1<string> __GetListTest();
}
internal interface Microsoft.Build.Evaluation.IProjectMetadataParent {
    public Project Project { get; }
    public string ItemType { get; }
    public abstract virtual Project get_Project();
    public abstract virtual string get_ItemType();
}
internal interface Microsoft.Build.Evaluation.IProperty {
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string EvaluatedValueEscaped { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_EvaluatedValue();
    public abstract virtual string get_EvaluatedValueEscaped();
}
internal interface Microsoft.Build.Evaluation.IPropertyProvider`1 {
    public abstract virtual T GetProperty(string name);
    public abstract virtual T GetProperty(string name, int startIndex, int endIndex);
}
internal class Microsoft.Build.Evaluation.ItemsAndMetadataPair : ValueType {
    private HashSet`1<string> items;
    private Dictionary`2<string, MetadataReference> metadata;
    internal HashSet`1<string> Items { get; internal set; }
    internal Dictionary`2<string, MetadataReference> Metadata { get; internal set; }
    internal ItemsAndMetadataPair(HashSet`1<string> items, Dictionary`2<string, MetadataReference> metadata);
    internal HashSet`1<string> get_Items();
    internal void set_Items(HashSet`1<string> value);
    internal Dictionary`2<string, MetadataReference> get_Metadata();
    internal void set_Metadata(Dictionary`2<string, MetadataReference> value);
}
internal interface Microsoft.Build.Evaluation.IToolsetProvider {
    public ICollection`1<Toolset> Toolsets { get; }
    public abstract virtual ICollection`1<Toolset> get_Toolsets();
    public abstract virtual Toolset GetToolset(string toolsVersion);
}
internal class Microsoft.Build.Evaluation.LessThanExpressionNode : NumericComparisonExpressionNode {
    protected virtual bool Compare(double left, double right);
}
internal class Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    protected virtual bool Compare(double left, double right);
}
internal class Microsoft.Build.Evaluation.LoadXmlFromPath : MulticastDelegate {
    public LoadXmlFromPath(object object, IntPtr method);
    public virtual XmlDocumentWithLocation Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual XmlDocumentWithLocation EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Evaluation.MetadataReference : ValueType {
    internal string ItemName;
    internal string MetadataName;
    internal MetadataReference(string itemName, string metadataName);
}
internal abstract class Microsoft.Build.Evaluation.MultipleComparisonNode : OperatorExpressionNode {
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(bool left, bool right);
    protected abstract virtual bool Compare(string left, string right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual void ResetState();
}
internal class Microsoft.Build.Evaluation.NotEqualExpressionNode : MultipleComparisonNode {
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
}
internal class Microsoft.Build.Evaluation.NotExpressionNode : OperatorExpressionNode {
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
}
internal abstract class Microsoft.Build.Evaluation.NumericComparisonExpressionNode : OperatorExpressionNode {
    protected abstract virtual bool Compare(double left, double right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
}
internal class Microsoft.Build.Evaluation.NumericExpressionNode : OperandExpressionNode {
    internal NumericExpressionNode(string value);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
}
internal abstract class Microsoft.Build.Evaluation.OperandExpressionNode : GenericExpressionNode {
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
internal abstract class Microsoft.Build.Evaluation.OperatorExpressionNode : GenericExpressionNode {
    internal GenericExpressionNode LeftChild { get; internal set; }
    internal GenericExpressionNode RightChild { get; internal set; }
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
    internal void set_LeftChild(GenericExpressionNode value);
    internal GenericExpressionNode get_LeftChild();
    internal void set_RightChild(GenericExpressionNode value);
    internal GenericExpressionNode get_RightChild();
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
internal class Microsoft.Build.Evaluation.OrExpressionNode : OperatorExpressionNode {
    internal bool PossibleOrCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
}
internal class Microsoft.Build.Evaluation.Parser : object {
    internal int errorPosition;
    internal BuildEventContext LogBuildEventContext { get; internal set; }
    internal ILoggingService LoggingServices { get; internal set; }
    internal BuildEventContext get_LogBuildEventContext();
    internal void set_LogBuildEventContext(BuildEventContext value);
    internal void set_LoggingServices(ILoggingService value);
    internal ILoggingService get_LoggingServices();
    internal GenericExpressionNode Parse(string expression, ParserOptions optionSettings, ElementLocation elementLocation);
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ParserOptions : Enum {
    public int value__;
    public static ParserOptions None;
    public static ParserOptions AllowProperties;
    public static ParserOptions AllowItemLists;
    public static ParserOptions AllowPropertiesAndItemLists;
    public static ParserOptions AllowBuiltInMetadata;
    public static ParserOptions AllowCustomMetadata;
    public static ParserOptions AllowItemMetadata;
    public static ParserOptions AllowPropertiesAndItemMetadata;
    public static ParserOptions AllowPropertiesAndCustomMetadata;
    public static ParserOptions AllowAll;
}
internal class Microsoft.Build.Evaluation.Preprocessor : object {
    internal static XmlDocument GetPreprocessedDocument(Project project);
}
[DebuggerDisplayAttribute("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")]
public class Microsoft.Build.Evaluation.Project : object {
    public ProjectCollection ProjectCollection { get; }
    public ProjectRootElement Xml { get; }
    public bool IsDirty { get; }
    public int EvaluationCounter { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<string> ItemTypes { get; }
    public ICollection`1<ProjectProperty> Properties { get; }
    public IDictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public IDictionary`2<string, ProjectItemDefinition> ItemDefinitions { get; }
    public ICollection`1<ProjectItem> Items { get; }
    public ICollection`1<ProjectItem> ItemsIgnoringCondition { get; }
    public IList`1<ResolvedImport> Imports { get; }
    public IList`1<ResolvedImport> ImportsIncludingDuplicates { get; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public ICollection`1<ProjectProperty> AllEvaluatedProperties { get; }
    public ICollection`1<ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
    public ICollection`1<ProjectItem> AllEvaluatedItems { get; }
    public string ToolsVersion { get; }
    public string SubToolsetVersion { get; }
    public string DirectoryPath { get; }
    public string FullPath { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    public bool IsBuildEnabled { get; public set; }
    public ElementLocation ProjectFileLocation { get; }
    internal ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    internal ILoggingService LoggingService { get; }
    public Project(ProjectCollection projectCollection);
    public Project(IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(ProjectRootElement xml);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(XmlReader xmlReader);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(string projectFile);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private static Project();
    [DebuggerStepThroughAttribute]
public ProjectCollection get_ProjectCollection();
    [DebuggerStepThroughAttribute]
public ProjectRootElement get_Xml();
    public bool get_IsDirty();
    public int get_EvaluationCounter();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_ItemTypes();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectProperty> get_Properties();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, List`1<string>> get_ConditionedProperties();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectItemDefinition> get_ItemDefinitions();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItem> get_Items();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItem> get_ItemsIgnoringCondition();
    public IList`1<ResolvedImport> get_Imports();
    public IList`1<ResolvedImport> get_ImportsIncludingDuplicates();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public ICollection`1<ProjectProperty> get_AllEvaluatedProperties();
    public ICollection`1<ProjectMetadata> get_AllEvaluatedItemDefinitionMetadata();
    public ICollection`1<ProjectItem> get_AllEvaluatedItems();
    public string get_ToolsVersion();
    public string get_SubToolsetVersion();
    [DebuggerStepThroughAttribute]
public string get_DirectoryPath();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public void set_FullPath(string value);
    [CompilerGeneratedAttribute]
public bool get_SkipEvaluation();
    [CompilerGeneratedAttribute]
public void set_SkipEvaluation(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableMarkDirty();
    [CompilerGeneratedAttribute]
public void set_DisableMarkDirty(bool value);
    public bool get_IsBuildEnabled();
    public void set_IsBuildEnabled(bool value);
    public ElementLocation get_ProjectFileLocation();
    [DebuggerStepThroughAttribute]
internal ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    [DebuggerStepThroughAttribute]
internal ILoggingService get_LoggingService();
    public static string GetEvaluatedItemIncludeEscaped(ProjectItem item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item);
    public static string GetMetadataValueEscaped(ProjectMetadata metadatum);
    public static string GetMetadataValueEscaped(ProjectItem item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name);
    public static string GetPropertyValueEscaped(ProjectProperty property);
    public IEnumerable`1<ProjectElement> GetLogicalProject();
    [DebuggerStepThroughAttribute]
public ProjectProperty GetProperty(string name);
    public string GetPropertyValue(string name);
    public ProjectProperty SetProperty(string name, string unevaluatedValue);
    public bool SetGlobalProperty(string name, string escapedValue);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItem> GetItems(string itemType);
    public ICollection`1<ProjectItem> GetItemsIgnoringCondition(string itemType);
    public ICollection`1<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
    public bool RemoveProperty(ProjectProperty property);
    public bool RemoveGlobalProperty(string name);
    public bool RemoveItem(ProjectItem item);
    public void RemoveItems(IEnumerable`1<ProjectItem> items);
    public string ExpandString(string unexpandedValue);
    public ProjectInstance CreateProjectInstance();
    public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings);
    public void MarkDirty();
    public void ReevaluateIfNecessary();
    public void Save();
    public void Save(Encoding encoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    public void SaveLogicalProject(TextWriter writer);
    public bool Build();
    public bool Build(ILogger logger);
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement);
    internal bool SplitItemElementIfNecessary(ProjectItemElement itemElement);
    internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXml, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    internal void RemoveItemBeforeItemTypeChange(ProjectItem item);
    internal void ReAddExistingItemAfterItemTypeChange(ProjectItem item);
    internal string ExpandPropertyValueBestEffortLeaveEscaped(string unevaluatedValue, ElementLocation propertyLocation);
    internal string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamedItemElement);
    internal string ExpandMetadataValueBestEffortLeaveEscaped(IMetadataTable metadataTable, string unevaluatedValue, ElementLocation metadataLocation);
    internal void Zombify();
    internal void VerifyThrowInvalidOperationNotZombie();
    internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml);
}
public class Microsoft.Build.Evaluation.ProjectChangedEventArgs : EventArgs {
    public Project Project { get; private set; }
    internal ProjectChangedEventArgs(Project project);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(Project value);
}
public class Microsoft.Build.Evaluation.ProjectCollection : object {
    public static ProjectCollection GlobalProjectCollection { get; }
    public static Version Version { get; }
    public string DefaultToolsVersion { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<Project> LoadedProjects { get; }
    public int Count { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetDefinitionLocations ToolsetLocations { get; }
    public bool IsBuildEnabled { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    internal ILoggingService LoggingService { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesCollection { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentProperties { get; }
    internal int ToolsetsVersion { get; }
    internal int MaxNodeCount { get; internal set; }
    internal ProjectRootElementCache ProjectRootElementCache { get; private set; }
    private static ProjectCollection();
    public ProjectCollection(ToolsetDefinitionLocations toolsetLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents);
    public void add_ProjectAdded(ProjectAddedEventHandler value);
    public void remove_ProjectAdded(ProjectAddedEventHandler value);
    public void add_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    public void remove_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    public void add_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    public void remove_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    public void add_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    public void remove_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    public static ProjectCollection get_GlobalProjectCollection();
    public static Version get_Version();
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public ICollection`1<Project> get_LoadedProjects();
    public int get_Count();
    [DebuggerStepThroughAttribute]
public ICollection`1<ILogger> get_Loggers();
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    [DebuggerStepThroughAttribute]
public ToolsetDefinitionLocations get_ToolsetLocations();
    [DebuggerStepThroughAttribute]
public bool get_IsBuildEnabled();
    [DebuggerStepThroughAttribute]
public void set_IsBuildEnabled(bool value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    public HostServices get_HostServices();
    public void set_HostServices(HostServices value);
    public bool get_SkipEvaluation();
    public void set_SkipEvaluation(bool value);
    public bool get_DisableMarkDirty();
    public void set_DisableMarkDirty(bool value);
    [DebuggerStepThroughAttribute]
internal ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesCollection();
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentProperties();
    [DebuggerStepThroughAttribute]
internal int get_ToolsetsVersion();
    internal int get_MaxNodeCount();
    internal void set_MaxNodeCount(int value);
    internal ProjectRootElementCache get_ProjectRootElementCache();
    private void set_ProjectRootElementCache(ProjectRootElementCache value);
    public static string Escape(string unescapedString);
    public static string Unescape(string escapedString);
    public bool ContainsToolset(string toolsVersion);
    public void AddToolset(Toolset toolset);
    public bool RemoveToolset(string toolsVersion);
    public void RemoveAllToolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    public ICollection`1<Project> GetLoadedProjects(string fullPath);
    public Project LoadProject(string fileName);
    public Project LoadProject(string fileName, string toolsVersion);
    public Project LoadProject(string fileName, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader);
    public Project LoadProject(XmlReader xmlReader, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public void RegisterLogger(ILogger logger);
    public void RegisterLoggers(IEnumerable`1<ILogger> loggers);
    public void RegisterForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public void UnregisterAllLoggers();
    public void UnloadProject(Project project);
    public void UnloadProject(ProjectRootElement projectRootElement);
    public void UnloadAllProjects();
    public ProjectPropertyInstance GetGlobalProperty(string name);
    public void SetGlobalProperty(string name, string value);
    public bool RemoveGlobalProperty(string name);
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.InitializeComponent(IBuildComponentHost host);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent();
    public bool TryUnloadProject(ProjectRootElement projectRootElement);
    internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project project);
    internal void AfterUpdateLoadedProjectGlobalProperties(Project project);
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs : EventArgs {
    public ProjectCollectionChangedState Changed { get; private set; }
    internal ProjectCollectionChangedEventArgs(ProjectCollectionChangedState changedState);
    [CompilerGeneratedAttribute]
public ProjectCollectionChangedState get_Changed();
    [CompilerGeneratedAttribute]
private void set_Changed(ProjectCollectionChangedState value);
}
public enum Microsoft.Build.Evaluation.ProjectCollectionChangedState : Enum {
    public int value__;
    public static ProjectCollectionChangedState DefaultToolsVersion;
    public static ProjectCollectionChangedState Toolsets;
    public static ProjectCollectionChangedState Loggers;
    public static ProjectCollectionChangedState GlobalProperties;
    public static ProjectCollectionChangedState IsBuildEnabled;
    public static ProjectCollectionChangedState OnlyLogCriticalEvents;
    public static ProjectCollectionChangedState HostServices;
    public static ProjectCollectionChangedState DisableMarkDirty;
    public static ProjectCollectionChangedState SkipEvaluation;
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItem : object {
    [DebuggerBrowsableAttribute("0")]
public ProjectItemElement Xml { get; }
    public string ItemType { get; public set; }
    public string UnevaluatedInclude { get; public set; }
    public string EvaluatedInclude { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public bool IsImported { get; }
    public IEnumerable`1<ProjectMetadata> DirectMetadata { get; }
    public int DirectMetadataCount { get; }
    public ICollection`1<ProjectMetadata> Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ICollection`1<ProjectMetadata> MetadataCollection { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansion { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansionEscaped { get; }
    internal List`1<ProjectItemDefinition> InheritedItemDefinitions { get; }
    internal ProjectItem(Project project, ProjectItemElement xml, string evaluatedIncludeEscaped, string evaluatedIncludeBeforeWildcardExpansionEscaped, PropertyDictionary`1<ProjectMetadata> directMetadataCloned, List`1<ProjectItemDefinition> inheritedItemDefinitionsCloned);
    [DebuggerStepThroughAttribute]
public ProjectItemElement get_Xml();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedInclude();
    public void set_UnevaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    public bool get_IsImported();
    public IEnumerable`1<ProjectMetadata> get_DirectMetadata();
    [DebuggerStepThroughAttribute]
public int get_DirectMetadataCount();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectMetadata> get_Metadata();
    [DebuggerStepThroughAttribute]
public int get_MetadataCount();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    internal ICollection`1<ProjectMetadata> get_MetadataCollection();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansion();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansionEscaped();
    [DebuggerStepThroughAttribute]
internal List`1<ProjectItemDefinition> get_InheritedItemDefinitions();
    public ProjectMetadata GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.GetMetadata(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    public bool RemoveMetadata(string name);
    public void Rename(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    internal void ChangeItemType(string newItemType);
    internal void SplitOwnItemElement();
}
[DebuggerDisplayAttribute("{itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItemDefinition : object {
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public IEnumerable`1<ProjectMetadata> Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ProjectItemDefinition(Project project, string itemType);
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public IEnumerable`1<ProjectMetadata> get_Metadata();
    public int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadata GetMetadata(string name);
    public string GetMetadataValue(string name);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ProjectLoadSettings : Enum {
    public int value__;
    public static ProjectLoadSettings Default;
    public static ProjectLoadSettings IgnoreMissingImports;
    public static ProjectLoadSettings RecordDuplicateButNotCircularImports;
    public static ProjectLoadSettings RejectCircularImports;
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{xml.Value}]")]
public class Microsoft.Build.Evaluation.ProjectMetadata : object {
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string UnevaluatedValue { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public ProjectMetadataElement Xml { get; }
    public Project Project { get; }
    public string ItemType { get; }
    public ProjectMetadata Predecessor { get; }
    public bool IsImported { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_UnevaluatedValue(string value);
    [DebuggerStepThroughAttribute]
public ProjectMetadataElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    public string get_ItemType();
    [DebuggerStepThroughAttribute]
public ProjectMetadata get_Predecessor();
    public bool get_IsImported();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>.Equals(ProjectMetadata other);
    internal ProjectMetadata DeepClone();
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
public abstract class Microsoft.Build.Evaluation.ProjectProperty : object {
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    public string UnevaluatedValue { get; public set; }
    public bool IsEnvironmentProperty { get; }
    public bool IsGlobalProperty { get; }
    public bool IsReservedProperty { get; }
    [DebuggerBrowsableAttribute("0")]
public ProjectPropertyElement Xml { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public ProjectProperty Predecessor { get; }
    public bool IsImported { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    internal ProjectProperty(Project project, string evaluatedValueEscaped);
    [DebuggerStepThroughAttribute]
public abstract virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    [DebuggerStepThroughAttribute]
public abstract virtual string get_UnevaluatedValue();
    public abstract virtual void set_UnevaluatedValue(string value);
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsEnvironmentProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsGlobalProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsReservedProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectPropertyElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectProperty get_Predecessor();
    public abstract virtual bool get_IsImported();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>.Equals(ProjectProperty other);
    internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    internal static ProjectProperty Create(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor);
    internal void UpdateEvaluatedValue(string evaluatedValueEscaped);
}
internal class Microsoft.Build.Evaluation.ProjectRootElementCache : object {
    private static ProjectRootElementCache();
    internal ProjectRootElementCache(bool autoReloadFromDisk);
    internal static void add_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    internal static void remove_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    internal void add_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    internal void remove_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    internal void add_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    internal void remove_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    internal void add_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    internal void remove_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    internal ProjectRootElement Get(string projectFile, OpenProjectRootElement openProjectRootElement, bool isExplicitlyLoaded);
    internal void AddEntry(ProjectRootElement projectRootElement);
    internal void OnProjectRootElementDirtied(ProjectRootElement sender, ProjectXmlChangedEventArgs e);
    internal void OnProjectDirtied(Project sender, ProjectChangedEventArgs e);
    internal void RenameEntry(string oldFullPath, ProjectRootElement projectRootElement);
    internal ProjectRootElement TryGet(string projectFile);
    internal void DiscardStrongReferences();
    internal void Clear();
    internal void DiscardImplicitReferences();
    internal void DiscardAnyWeakReference(ProjectRootElement projectRootElement);
}
public class Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs : EventArgs {
    public ProjectRootElement ProjectXml { get; private set; }
    public string Reason { get; }
    internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter);
    [CompilerGeneratedAttribute]
public ProjectRootElement get_ProjectXml();
    [CompilerGeneratedAttribute]
private void set_ProjectXml(ProjectRootElement value);
    public string get_Reason();
}
internal class Microsoft.Build.Evaluation.ReadApplicationConfiguration : MulticastDelegate {
    public ReadApplicationConfiguration(object object, IntPtr method);
    public virtual Configuration Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Configuration EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Evaluation.ResolvedImport : ValueType {
    private ProjectImportElement importingElement;
    private ProjectRootElement importedProject;
    private bool isImported;
    public ProjectImportElement ImportingElement { get; }
    public ProjectRootElement ImportedProject { get; }
    public bool IsImported { get; }
    internal ResolvedImport(Project project, ProjectImportElement importingElement, ProjectRootElement importedProject);
    public ProjectImportElement get_ImportingElement();
    public ProjectRootElement get_ImportedProject();
    public bool get_IsImported();
}
internal class Microsoft.Build.Evaluation.Scanner : object {
    internal Token CurrentToken { get; }
    internal string UnexpectedlyFound { get; }
    internal Scanner(string expressionToParse, ParserOptions options);
    private static Scanner();
    internal string GetErrorResource();
    internal bool IsNext(TokenType type);
    internal string IsNextString();
    internal Token get_CurrentToken();
    internal int GetErrorPosition();
    internal string get_UnexpectedlyFound();
    internal bool Advance();
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ShredderOptions : Enum {
    public int value__;
    public static ShredderOptions Invalid;
    public static ShredderOptions ItemTypes;
    public static ShredderOptions MetadataOutsideTransforms;
    public static ShredderOptions All;
}
internal class Microsoft.Build.Evaluation.StringExpressionNode : OperandExpressionNode {
    internal StringExpressionNode(string value, bool expandable);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
}
internal class Microsoft.Build.Evaluation.StringMetadataTable : object {
    internal StringMetadataTable(Dictionary`2<string, string> metadata);
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
}
[DebuggerDisplayAttribute("SubToolsetVersion={SubToolsetVersion} #Properties={properties.Count}")]
public class Microsoft.Build.Evaluation.SubToolset : object {
    public string SubToolsetVersion { get; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    internal SubToolset(string subToolsetVersion, PropertyDictionary`1<ProjectPropertyInstance> properties);
    public string get_SubToolsetVersion();
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static SubToolset FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.Evaluation.Token : object {
    internal static Token Comma;
    internal static Token LeftParenthesis;
    internal static Token RightParenthesis;
    internal static Token LessThan;
    internal static Token GreaterThan;
    internal static Token LessThanOrEqualTo;
    internal static Token GreaterThanOrEqualTo;
    internal static Token And;
    internal static Token Or;
    internal static Token EqualTo;
    internal static Token NotEqualTo;
    internal static Token Not;
    internal static Token EndOfInput;
    internal bool Expandable { get; internal set; }
    internal string String { get; }
    internal Token(TokenType type, string tokenString);
    internal Token(TokenType type, string tokenString, bool expandable);
    private static Token();
    [CompilerGeneratedAttribute]
internal bool get_Expandable();
    [CompilerGeneratedAttribute]
internal void set_Expandable(bool value);
    internal bool IsToken(TokenType type);
    internal string get_String();
}
[DebuggerDisplayAttribute("ToolsVersion={ToolsVersion} ToolsPath={ToolsPath} #Properties={properties.Count}")]
public class Microsoft.Build.Evaluation.Toolset : object {
    public string ToolsVersion { get; }
    public string ToolsPath { get; private set; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    public IDictionary`2<string, SubToolset> SubToolsets { get; }
    public string DefaultSubToolsetVersion { get; }
    internal static bool Dev10IsInstalled { get; }
    internal string OverrideTasksPath { get; }
    public Toolset(string toolsVersion, string toolsPath, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists);
    private static Toolset();
    public string get_ToolsVersion();
    public string get_ToolsPath();
    private void set_ToolsPath(string value);
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    public IDictionary`2<string, SubToolset> get_SubToolsets();
    public string get_DefaultSubToolsetVersion();
    internal static bool get_Dev10IsInstalled();
    internal string get_OverrideTasksPath();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    public string GenerateSubToolsetVersion();
    public string GenerateSubToolsetVersion(IDictionary`2<string, string> overrideGlobalProperties, int solutionVersion);
    public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion);
    internal static Toolset FactoryForDeserialization(INodePacketTranslator translator);
    internal static String[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning);
    internal string GenerateSubToolsetVersion(PropertyDictionary`1<ProjectPropertyInstance> overrideGlobalProperties);
    internal string GenerateSubToolsetVersion(int solutionVersion);
    internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
    internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
}
internal class Microsoft.Build.Evaluation.ToolsetConfigurationReader : ToolsetReader {
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    internal ToolsetConfigurationReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    internal ToolsetConfigurationReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ReadApplicationConfiguration readApplicationConfiguration);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
}
internal class Microsoft.Build.Evaluation.ToolsetConfigurationSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public ToolsetElementCollection Toolsets { get; }
    [ConfigurationPropertyAttribute("default")]
public string Default { get; public set; }
    [ConfigurationPropertyAttribute("msbuildOverrideTasksPath")]
public string MSBuildOverrideTasksPath { get; public set; }
    public ToolsetElementCollection get_Toolsets();
    public string get_Default();
    public void set_Default(string value);
    public string get_MSBuildOverrideTasksPath();
    public void set_MSBuildOverrideTasksPath(string value);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ToolsetDefinitionLocations : Enum {
    public int value__;
    public static ToolsetDefinitionLocations None;
    public static ToolsetDefinitionLocations ConfigurationFile;
    public static ToolsetDefinitionLocations Registry;
}
internal class Microsoft.Build.Evaluation.ToolsetElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("toolsVersion")]
public string toolsVersion { get; public set; }
    [ConfigurationPropertyAttribute("")]
public PropertyElementCollection PropertyElements { get; }
    public string get_toolsVersion();
    public void set_toolsVersion(string value);
    public PropertyElementCollection get_PropertyElements();
}
internal class Microsoft.Build.Evaluation.ToolsetElementCollection : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected bool ThrowOnDuplicate { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual string get_ElementName();
    public ToolsetElement GetElement(string toolsVersion);
    public ToolsetElement GetElement(int index);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual void BaseAdd(int index, ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
}
[DebuggerDisplayAttribute("Name={Name} Value={Value}")]
internal class Microsoft.Build.Evaluation.ToolsetPropertyDefinition : object {
    public string Name { get; }
    public string Value { get; public set; }
    public IElementLocation Source { get; }
    public ToolsetPropertyDefinition(string name, string value, IElementLocation source);
    public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public IElementLocation get_Source();
}
internal class Microsoft.Build.Evaluation.ToolsetProvider : object {
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetProvider(string defaultToolsVersion, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ToolsetProvider(IEnumerable`1<Toolset> toolsets);
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ToolsetProvider FactoryForDeserialization(INodePacketTranslator translator);
}
internal abstract class Microsoft.Build.Evaluation.ToolsetReader : object {
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected ToolsetReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected abstract virtual string get_DefaultToolsVersion();
    protected abstract virtual string get_MSBuildOverrideTasksPath();
    internal static string ReadAllToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations locations);
    internal static string ReadAllToolsets(Dictionary`2<string, Toolset> toolsets, ToolsetRegistryReader registryReader, ToolsetConfigurationReader configurationReader, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations locations);
    internal string ReadToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties, String& msBuildOverrideTasksPath);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected abstract virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
}
internal class Microsoft.Build.Evaluation.ToolsetRegistryReader : ToolsetReader {
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    internal ToolsetRegistryReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    internal ToolsetRegistryReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
}
internal class Microsoft.Build.Evaluation.UsedUninitializedProperties : object {
    internal IDictionary`2<string, IElementLocation> Properties { get; internal set; }
    internal bool Warn { get; internal set; }
    internal string CurrentlyEvaluatingPropertyElementName { get; internal set; }
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, IElementLocation> get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(IDictionary`2<string, IElementLocation> value);
    [CompilerGeneratedAttribute]
internal bool get_Warn();
    [CompilerGeneratedAttribute]
internal void set_Warn(bool value);
    [CompilerGeneratedAttribute]
internal string get_CurrentlyEvaluatingPropertyElementName();
    [CompilerGeneratedAttribute]
internal void set_CurrentlyEvaluatingPropertyElementName(string value);
}
public class Microsoft.Build.Exceptions.BuildAbortedException : Exception {
    public string ErrorCode { get; private set; }
    public BuildAbortedException(string message);
    public BuildAbortedException(string message, Exception innerException);
    protected BuildAbortedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Build.Exceptions.InternalLoggerException : Exception {
    public BuildEventArgs BuildEventArgs { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool InitializationException { get; }
    public InternalLoggerException(string message);
    public InternalLoggerException(string message, Exception innerException);
    internal InternalLoggerException(string message, Exception innerException, BuildEventArgs e, string errorCode, string helpKeyword, bool initializationException);
    private InternalLoggerException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public BuildEventArgs get_BuildEventArgs();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_InitializationException();
    internal static void Throw(Exception innerException, BuildEventArgs e, string messageResourceName, bool initializationException, String[] messageArgs);
}
public class Microsoft.Build.Exceptions.InvalidProjectFileException : Exception {
    public string Message { get; }
    public string BaseMessage { get; }
    public string ProjectFile { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string ErrorSubcategory { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool HasBeenLogged { get; internal set; }
    public InvalidProjectFileException(string message);
    public InvalidProjectFileException(string message, Exception innerException);
    internal InvalidProjectFileException(string message, InvalidProjectFileException innerException);
    private InvalidProjectFileException(SerializationInfo info, StreamingContext context);
    public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword);
    internal InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_BaseMessage();
    public string get_ProjectFile();
    public int get_LineNumber();
    public int get_ColumnNumber();
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_ErrorSubcategory();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_HasBeenLogged();
    internal void set_HasBeenLogged(bool value);
}
public class Microsoft.Build.Exceptions.InvalidToolsetDefinitionException : Exception {
    public string ErrorCode { get; }
    public InvalidToolsetDefinitionException(string message);
    public InvalidToolsetDefinitionException(string message, Exception innerException);
    protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context);
    public InvalidToolsetDefinitionException(string message, string errorCode);
    public InvalidToolsetDefinitionException(string message, string errorCode, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_ErrorCode();
    internal static void Throw(string resourceName, String[] args);
    internal static void Throw(Exception innerException, string resourceName, String[] args);
}
internal class Microsoft.Build.Exceptions.RegistryException : Exception {
    public RegistryException(string message);
    public RegistryException(string message, Exception innerException);
    public RegistryException(string message, string source);
    protected RegistryException(SerializationInfo info, StreamingContext context);
    public RegistryException(string message, string source, Exception innerException);
}
public class Microsoft.Build.Execution.BuildManager : object {
    public static BuildManager DefaultBuildManager { get; }
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    public BuildManager(string hostName);
    private static BuildManager();
    protected virtual void Finalize();
    public static BuildManager get_DefaultBuildManager();
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    public void BeginBuild(BuildParameters parameters);
    public void CancelAllSubmissions();
    public void ResetCaches();
    public ProjectInstance GetProjectInstanceForBuild(Project project);
    public BuildSubmission PendBuildRequest(BuildRequestData requestData);
    public BuildResult BuildRequest(BuildRequestData requestData);
    public void EndBuild();
    public BuildResult Build(BuildParameters parameters, BuildRequestData requestData);
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild);
    internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildEventContext buildEventContext);
}
public class Microsoft.Build.Execution.BuildParameters : object {
    public ThreadPriority BuildThreadPriority { get; public set; }
    public bool UseSynchronousLogging { get; public set; }
    public IDictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; public set; }
    public string DefaultToolsVersion { get; public set; }
    public bool DetailedSummary { get; public set; }
    public bool DisableInProcNode { get; public set; }
    public bool LogTaskInputs { get; public set; }
    public bool LogInitialPropertiesAndItems { get; public set; }
    public bool ResetCaches { get; public set; }
    public bool EnableNodeReuse { get; public set; }
    public IDictionary`2<string, string> EnvironmentProperties { get; }
    public IEnumerable`1<ForwardingLoggerRecord> ForwardingLoggers { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool LegacyThreadingSemantics { get; public set; }
    public IEnumerable`1<ILogger> Loggers { get; public set; }
    public int MaxNodeCount { get; public set; }
    public int MemoryUseLimit { get; public set; }
    public string NodeExeLocation { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public ToolsetDefinitionLocations ToolsetDefinitionLocations { get; public set; }
    public ICollection`1<Toolset> Toolsets { get; }
    public CultureInfo UICulture { get; public set; }
    public bool SaveOperatingEnvironment { get; public set; }
    public bool ShutdownInProcNodeOnBuildFinish { get; public set; }
    internal static int ThreadStackSize { get; }
    internal static int EndpointShutdownTimeout { get; }
    internal static int EngineShutdownTimeout { get; }
    internal static int IdleRequestBuilderLimit { get; }
    internal static int LoggingThreadShutdownTimeout { get; }
    internal static int RequestBuilderShutdownTimeout { get; }
    internal static string StartupDirectory { get; }
    internal static bool EnableBuildPlan { get; }
    internal static bool WarnOnUninitializedProperty { get; internal set; }
    internal static bool DumpOpportunisticInternStats { get; }
    internal static bool DebugExpansion { get; }
    internal static bool KeepDuplicateOutputs { get; }
    internal int BuildId { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentPropertiesInternal { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesInternal { get; }
    internal int NodeId { get; internal set; }
    internal IToolsetProvider ToolsetProvider { get; }
    internal ProjectRootElementCache ProjectRootElementCache { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    public BuildParameters(ProjectCollection projectCollection);
    private static BuildParameters();
    public ThreadPriority get_BuildThreadPriority();
    public void set_BuildThreadPriority(ThreadPriority value);
    public bool get_UseSynchronousLogging();
    public void set_UseSynchronousLogging(bool value);
    public IDictionary`2<string, string> get_BuildProcessEnvironment();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    public bool get_DetailedSummary();
    public void set_DetailedSummary(bool value);
    public bool get_DisableInProcNode();
    public void set_DisableInProcNode(bool value);
    public bool get_LogTaskInputs();
    public void set_LogTaskInputs(bool value);
    public bool get_LogInitialPropertiesAndItems();
    public void set_LogInitialPropertiesAndItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResetCaches();
    [CompilerGeneratedAttribute]
public void set_ResetCaches(bool value);
    public bool get_EnableNodeReuse();
    public void set_EnableNodeReuse(bool value);
    public IDictionary`2<string, string> get_EnvironmentProperties();
    public IEnumerable`1<ForwardingLoggerRecord> get_ForwardingLoggers();
    public void set_ForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public void set_GlobalProperties(IDictionary`2<string, string> value);
    public HostServices get_HostServices();
    public void set_HostServices(HostServices value);
    [CompilerGeneratedAttribute]
public bool get_LegacyThreadingSemantics();
    [CompilerGeneratedAttribute]
public void set_LegacyThreadingSemantics(bool value);
    public IEnumerable`1<ILogger> get_Loggers();
    public void set_Loggers(IEnumerable`1<ILogger> value);
    public int get_MaxNodeCount();
    public void set_MaxNodeCount(int value);
    public int get_MemoryUseLimit();
    public void set_MemoryUseLimit(int value);
    public string get_NodeExeLocation();
    public void set_NodeExeLocation(string value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    public ToolsetDefinitionLocations get_ToolsetDefinitionLocations();
    public void set_ToolsetDefinitionLocations(ToolsetDefinitionLocations value);
    public ICollection`1<Toolset> get_Toolsets();
    public CultureInfo get_UICulture();
    public void set_UICulture(CultureInfo value);
    public bool get_SaveOperatingEnvironment();
    public void set_SaveOperatingEnvironment(bool value);
    public bool get_ShutdownInProcNodeOnBuildFinish();
    public void set_ShutdownInProcNodeOnBuildFinish(bool value);
    internal static int get_ThreadStackSize();
    internal static int get_EndpointShutdownTimeout();
    internal static int get_EngineShutdownTimeout();
    internal static int get_IdleRequestBuilderLimit();
    internal static int get_LoggingThreadShutdownTimeout();
    internal static int get_RequestBuilderShutdownTimeout();
    internal static string get_StartupDirectory();
    internal static bool get_EnableBuildPlan();
    internal static bool get_WarnOnUninitializedProperty();
    internal static void set_WarnOnUninitializedProperty(bool value);
    internal static bool get_DumpOpportunisticInternStats();
    internal static bool get_DebugExpansion();
    internal static bool get_KeepDuplicateOutputs();
    internal int get_BuildId();
    internal void set_BuildId(int value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentPropertiesInternal();
    internal void set_EnvironmentPropertiesInternal(PropertyDictionary`1<ProjectPropertyInstance> value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesInternal();
    internal int get_NodeId();
    internal void set_NodeId(int value);
    internal IToolsetProvider get_ToolsetProvider();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
internal void set_ProjectRootElementCache(ProjectRootElementCache value);
    [CompilerGeneratedAttribute]
internal AppDomainSetup get_AppDomainSetup();
    [CompilerGeneratedAttribute]
internal void set_AppDomainSetup(AppDomainSetup value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public Toolset GetToolset(string toolsVersion);
    public BuildParameters Clone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static BuildParameters FactoryForDeserialization(INodePacketTranslator translator);
}
public class Microsoft.Build.Execution.BuildRequestData : object {
    public ProjectInstance ProjectInstance { get; private set; }
    public string ProjectFullPath { get; internal set; }
    public ICollection`1<string> TargetNames { get; private set; }
    public BuildRequestDataFlags Flags { get; private set; }
    public ICollection`1<ProjectPropertyInstance> GlobalProperties { get; }
    public string ExplicitlySpecifiedToolsVersion { get; private set; }
    public HostServices HostServices { get; private set; }
    public IEnumerable`1<string> PropertiesToTransfer { get; private set; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; private set; }
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable`1<string> propertiesToTransfer);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    [CompilerGeneratedAttribute]
public ProjectInstance get_ProjectInstance();
    [CompilerGeneratedAttribute]
private void set_ProjectInstance(ProjectInstance value);
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
internal void set_ProjectFullPath(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
private void set_TargetNames(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(BuildRequestDataFlags value);
    public ICollection`1<ProjectPropertyInstance> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public string get_ExplicitlySpecifiedToolsVersion();
    [CompilerGeneratedAttribute]
private void set_ExplicitlySpecifiedToolsVersion(string value);
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
    [CompilerGeneratedAttribute]
private void set_HostServices(HostServices value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PropertiesToTransfer();
    [CompilerGeneratedAttribute]
private void set_PropertiesToTransfer(IEnumerable`1<string> value);
    internal bool get_ExplicitToolsVersionSpecified();
    [CompilerGeneratedAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    [CompilerGeneratedAttribute]
private void set_GlobalPropertiesDictionary(PropertyDictionary`1<ProjectPropertyInstance> value);
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.BuildRequestDataFlags : Enum {
    public int value__;
    public static BuildRequestDataFlags None;
    public static BuildRequestDataFlags ReplaceExistingProjectInstance;
    public static BuildRequestDataFlags ProvideProjectStateAfterBuild;
    public static BuildRequestDataFlags IgnoreExistingProjectState;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Execution.BuildResult : object {
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int GlobalRequestId { get; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; }
    public Exception Exception { get; internal set; }
    public bool CircularDependency { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public ProjectInstance ProjectStateAfterBuild { get; public set; }
    private NodePacketType Microsoft.Build.BackEnd.INodePacket.Type { get; }
    private Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.SavedEnvironmentVariables { get; private set; }
    private string Microsoft.Build.BackEnd.IBuildResults.SavedCurrentDirectory { get; private set; }
    internal List`1<string> InitialTargets { get; internal set; }
    internal List`1<string> DefaultTargets { get; internal set; }
    internal bool ResultBelongsToRootRequest { get; }
    public ITargetResult Item { get; }
    internal BuildResult(BuildRequest request);
    internal BuildResult(BuildRequest request, Exception exception);
    internal BuildResult(BuildRequest request, bool circularDependency);
    internal BuildResult(BuildResult existingResults, String[] targetNames);
    internal BuildResult(BuildRequest request, BuildResult existingResults, Exception exception);
    internal BuildResult(BuildResult result, int nodeRequestId);
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
internal void set_Exception(Exception value);
    [DebuggerStepThroughAttribute]
public bool get_CircularDependency();
    public sealed virtual BuildResultCode get_OverallResult();
    [DebuggerStepThroughAttribute]
public sealed virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public ProjectInstance get_ProjectStateAfterBuild();
    public void set_ProjectStateAfterBuild(ProjectInstance value);
    [DebuggerStepThroughAttribute]
private sealed virtual override NodePacketType Microsoft.Build.BackEnd.INodePacket.get_Type();
    private sealed virtual override Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.get_SavedEnvironmentVariables();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildResults.get_SavedCurrentDirectory();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedCurrentDirectory(string value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_InitialTargets();
    [DebuggerStepThroughAttribute]
internal void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_DefaultTargets();
    [DebuggerStepThroughAttribute]
internal void set_DefaultTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal bool get_ResultBelongsToRootRequest();
    [DebuggerStepThroughAttribute]
public sealed virtual ITargetResult get_Item(string target);
    public void AddResultsForTarget(string target, TargetResult result);
    public void MergeResults(BuildResult results);
    public sealed virtual bool HasResultsForTarget(string target);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal void CacheIfPossible();
    internal void ClearCachedFiles();
    internal BuildResult Clone();
}
public enum Microsoft.Build.Execution.BuildResultCode : Enum {
    public int value__;
    public static BuildResultCode Success;
    public static BuildResultCode Failure;
}
public class Microsoft.Build.Execution.BuildSubmission : object {
    public BuildManager BuildManager { get; private set; }
    public int SubmissionId { get; private set; }
    public object AsyncContext { get; private set; }
    public WaitHandle WaitHandle { get; }
    public bool IsCompleted { get; }
    public BuildResult BuildResult { get; public set; }
    internal BuildRequestData BuildRequestData { get; private set; }
    internal BuildRequest BuildRequest { get; internal set; }
    internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics);
    [CompilerGeneratedAttribute]
public BuildManager get_BuildManager();
    [CompilerGeneratedAttribute]
private void set_BuildManager(BuildManager value);
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    [CompilerGeneratedAttribute]
private void set_SubmissionId(int value);
    [CompilerGeneratedAttribute]
public object get_AsyncContext();
    [CompilerGeneratedAttribute]
private void set_AsyncContext(object value);
    public WaitHandle get_WaitHandle();
    public bool get_IsCompleted();
    public BuildResult get_BuildResult();
    public void set_BuildResult(BuildResult value);
    [CompilerGeneratedAttribute]
internal BuildRequestData get_BuildRequestData();
    [CompilerGeneratedAttribute]
private void set_BuildRequestData(BuildRequestData value);
    [CompilerGeneratedAttribute]
internal BuildRequest get_BuildRequest();
    [CompilerGeneratedAttribute]
internal void set_BuildRequest(BuildRequest value);
    public BuildResult Execute();
    public void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context);
    internal void CompleteResults(BuildResult result);
    internal void CompleteLogging(bool waitForLoggingThread);
}
public class Microsoft.Build.Execution.BuildSubmissionCompleteCallback : MulticastDelegate {
    public BuildSubmissionCompleteCallback(object object, IntPtr method);
    public virtual void Invoke(BuildSubmission submission);
    public virtual IAsyncResult BeginInvoke(BuildSubmission submission, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("#Entries={hostObjectMap.Count}")]
public class Microsoft.Build.Execution.HostServices : object {
    public ITaskHost GetHostObject(string projectFile, string targetName, string taskName);
    public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject);
    public void UnregisterProject(string projectFullPath);
    public NodeAffinity GetNodeAffinity(string projectFile);
    public void SetNodeAffinity(string projectFile, NodeAffinity nodeAffinity);
    public void OnRenameProject(string oldFullPath, string newFullPath);
    internal bool HasHostObject(string projectFile);
}
public interface Microsoft.Build.Execution.ITargetResult {
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual ITaskItem[] get_Items();
    public abstract virtual TargetResultCode get_ResultCode();
}
internal class Microsoft.Build.Execution.LegacyThreadingData : object {
    internal AutoResetEvent StartNewRequestBuilderMainThreadEvent { get; }
    internal ManualResetEvent LegacyThreadInactiveEvent { get; }
    internal RequestBuilder InstanceForMainThread { get; internal set; }
    internal int MainThreadSubmissionId { get; internal set; }
    internal AutoResetEvent get_StartNewRequestBuilderMainThreadEvent();
    internal ManualResetEvent get_LegacyThreadInactiveEvent();
    internal RequestBuilder get_InstanceForMainThread();
    internal void set_InstanceForMainThread(RequestBuilder value);
    internal int get_MainThreadSubmissionId();
    internal void set_MainThreadSubmissionId(int value);
    internal void SignalLegacyThreadStart(RequestBuilder instance);
    internal void SignalLegacyThreadEnd();
}
public enum Microsoft.Build.Execution.NodeAffinity : Enum {
    public int value__;
    public static NodeAffinity InProc;
    public static NodeAffinity OutOfProc;
    public static NodeAffinity Any;
}
public enum Microsoft.Build.Execution.NodeEngineShutdownReason : Enum {
    public int value__;
    public static NodeEngineShutdownReason BuildComplete;
    public static NodeEngineShutdownReason BuildCompleteReuse;
    public static NodeEngineShutdownReason ConnectionFailed;
    public static NodeEngineShutdownReason Error;
}
public class Microsoft.Build.Execution.OutOfProcNode : object {
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    internal static bool IsOutOfProcNode { get; }
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    internal static bool get_IsOutOfProcNode();
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RoutePacket(int nodeId, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
}
[DebuggerDisplayAttribute("{FullPath} #Targets={TargetsCount} DefaultTargets={(DefaultTargets == null) ? System.String.Empty : System.String.Join(";", DefaultTargets.ToArray())} ToolsVersion={Toolset.ToolsVersion} InitialTargets={(InitialTargets == null) ? System.String.Empty : System.String.Join(";", InitialTargets.ToArray())} #GlobalProperties={globalProperties.Count} #Properties={properties.Count} #ItemTypes={items.ItemTypes.Count} #Items={items.Count}")]
public class Microsoft.Build.Execution.ProjectInstance : object {
    public IDictionary`2<string, string> GlobalProperties { get; }
    public string ToolsVersion { get; }
    public ICollection`1<string> ItemTypes { get; }
    public ICollection`1<ProjectPropertyInstance> Properties { get; }
    public ICollection`1<ProjectItemInstance> Items { get; }
    public string Directory { get; }
    public string FullPath { get; }
    public IDictionary`2<string, ProjectItemDefinitionInstance> ItemDefinitions { get; }
    public List`1<string> DefaultTargets { get; private set; }
    public List`1<string> InitialTargets { get; private set; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public bool IsImmutable { get; }
    private TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.TaskRegistry { get; private set; }
    private Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Toolset { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SubToolsetVersion { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ExplicitToolsVersion { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesDictionary { get; }
    private ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Properties { get; }
    private IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable { get; }
    private ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Items { get; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitialTargets { get; private set; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.DefaultTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.BeforeTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AfterTargets { get; private set; }
    private Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ConditionedProperties { get; }
    private bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ShouldEvaluateForDesignTime { get; }
    public ElementLocation ProjectFileLocation { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    internal Toolset Toolset { get; private set; }
    internal bool TreatingHigherToolsVersionsAs40 { get; }
    internal string OriginalProjectToolsVersion { get; }
    internal string ExplicitToolsVersion { get; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal string SubToolsetVersion { get; private set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> PropertiesToBuildWith { get; }
    internal ItemDictionary`1<ProjectItemInstance> ItemsToBuildWith { get; }
    internal IDictionary`2<string, object> InitialGlobalsForDebugging { get; }
    internal TaskRegistry TaskRegistry { get; private set; }
    internal int TargetsCount { get; }
    internal ProjectRootElementCache ProjectRootElementCache { get; private set; }
    public ProjectInstance(string projectFile);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    public ProjectInstance(ProjectRootElement xml);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFrom, IDictionary`2<string, string> globalProperties);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, int solutionVersion, ProjectCollection projectCollection);
    internal ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext);
    internal ProjectInstance(Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary`1<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_ItemTypes();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyInstance> get_Properties();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemInstance> get_Items();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_Directory();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectItemDefinitionInstance> get_ItemDefinitions();
    [CompilerGeneratedAttribute]
public List`1<string> get_DefaultTargets();
    [CompilerGeneratedAttribute]
private void set_DefaultTargets(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_InitialTargets();
    [CompilerGeneratedAttribute]
private void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public bool get_IsImmutable();
    [DebuggerStepThroughAttribute]
private sealed virtual override TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_TaskRegistry();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_TaskRegistry(TaskRegistry value);
    [DebuggerStepThroughAttribute]
private sealed virtual override Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Toolset();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_SubToolsetVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ExplicitToolsVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesDictionary();
    private sealed virtual override ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesToTreatAsLocal();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Properties();
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ItemDefinitionsEnumerable();
    [DebuggerStepThroughAttribute]
private sealed virtual override ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Items();
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_InitialTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_DefaultTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_DefaultTargets(List`1<string> value);
    [CompilerGeneratedAttribute]
private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_BeforeTargets();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    [CompilerGeneratedAttribute]
private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_AfterTargets();
    [CompilerGeneratedAttribute]
private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    private sealed virtual override Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ConditionedProperties();
    private sealed virtual override bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ShouldEvaluateForDesignTime();
    public ElementLocation get_ProjectFileLocation();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    [CompilerGeneratedAttribute]
internal Toolset get_Toolset();
    [CompilerGeneratedAttribute]
private void set_Toolset(Toolset value);
    internal bool get_TreatingHigherToolsVersionsAs40();
    internal string get_OriginalProjectToolsVersion();
    internal string get_ExplicitToolsVersion();
    internal bool get_ExplicitToolsVersionSpecified();
    [CompilerGeneratedAttribute]
internal string get_SubToolsetVersion();
    [CompilerGeneratedAttribute]
private void set_SubToolsetVersion(string value);
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_PropertiesToBuildWith();
    [DebuggerStepThroughAttribute]
internal ItemDictionary`1<ProjectItemInstance> get_ItemsToBuildWith();
    internal IDictionary`2<string, object> get_InitialGlobalsForDebugging();
    [CompilerGeneratedAttribute]
internal TaskRegistry get_TaskRegistry();
    [CompilerGeneratedAttribute]
private void set_TaskRegistry(TaskRegistry value);
    internal int get_TargetsCount();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
private void set_ProjectRootElementCache(ProjectRootElementCache value);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item);
    public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum);
    public static string GetMetadataValueEscaped(ProjectItemInstance item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name);
    public static string GetPropertyValueEscaped(ProjectPropertyInstance property);
    private sealed virtual override ICollection`1<ProjectItemInstance> Microsoft.Build.Evaluation.IItemProvider<Microsoft.Build.Execution.ProjectItemInstance>.GetItems(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitializeForEvaluation(IToolsetProvider toolsetProvider);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.FinishEvaluation();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItem(ProjectItemInstance item);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemIgnoringCondition(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemDefinition(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedPropertiesList(ProjectPropertyInstance property);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadataInstance itemDefinitionMetadatum);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemsList(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetItemDefinition(string itemType);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, ProjectPropertyInstance predecessor);
    private sealed virtual override ProjectTargetInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetTarget(string targetName);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddTarget(ProjectTargetInstance target);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectPropertyInstance GetProperty(string name);
    [DebuggerStepThroughAttribute]
private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IPropertyProvider<Microsoft.Build.Execution.ProjectPropertyInstance>.GetProperty(string name, int startIndex, int endIndex);
    public string GetPropertyValue(string name);
    public ProjectPropertyInstance SetProperty(string name, string evaluatedValue);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItemInstance> GetItems(string itemType);
    public IEnumerable`1<ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude);
    public bool RemoveItem(ProjectItemInstance item);
    public bool RemoveProperty(string name);
    public ProjectInstance DeepCopy();
    public ProjectInstance DeepCopy(bool isImmutable);
    public bool Build();
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IDictionary`2& targetOutputs);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, IDictionary`2& targetOutputs);
    public sealed virtual string ExpandString(string unexpandedValue);
    public sealed virtual bool EvaluateCondition(string condition);
    public ProjectRootElement ToProjectRootElement();
    public void UpdateStateFrom(ProjectInstance projectState);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary`1<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded);
    internal static ProjectInstance FactoryForDeserialization(INodePacketTranslator translator);
    internal static void VerifyThrowNotImmutable(bool isImmutable);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, int maxNodeCount, IDictionary`2& targetOutputs);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, IDictionary`2& targetOutputs);
    internal IList`1<TargetSpecification> GetTargetsWhichRunBefore(string target);
    internal IList`1<TargetSpecification> GetTargetsWhichRunAfter(string target);
    internal void Cache(INodePacketTranslator translator);
    internal void RetrieveFromCache(INodePacketTranslator translator);
    internal ProjectTargetInstance AddTarget(string targetName, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, bool parentProjectSupportsReturnsAttribute);
    internal void RemoveTarget(string targetName);
    internal void VerifyThrowNotImmutable();
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.ProjectInstanceSettings : Enum {
    public int value__;
    public static ProjectInstanceSettings None;
    public static ProjectInstanceSettings Immutable;
    public static ProjectInstanceSettings ImmutableWithFastItemLookup;
}
[DebuggerDisplayAttribute("{itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Execution.ProjectItemDefinitionInstance : object {
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public ICollection`1<ProjectMetadataInstance> Metadata { get; }
    public int MetadataCount { get; }
    public IEnumerable`1<string> MetadataNames { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ProjectItemDefinitionInstance(ProjectInstance projectInstance, string itemType);
    internal ProjectItemDefinitionInstance(ProjectInstance projectInstance, ProjectItemDefinition itemDefinition);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public ICollection`1<ProjectMetadataInstance> get_Metadata();
    public int get_MetadataCount();
    public IEnumerable`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor);
    internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("Condition={condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskInstance : ProjectTargetInstanceChild {
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskItemInstance> Items { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, IEnumerable`1<ProjectItemGroupTaskItemInstance> items);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskItemInstance> get_Items();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskInstance DeepClone();
}
[DebuggerDisplayAttribute("{itemType} Include={include} Exclude={exclude} Remove={remove} Condition={condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance : object {
    public string ItemType { get; }
    public string Include { get; }
    public string Exclude { get; }
    public string Remove { get; }
    public string KeepMetadata { get; }
    public string RemoveMetadata { get; }
    public string KeepDuplicates { get; }
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskMetadataInstance> Metadata { get; }
    public ElementLocation Location { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskItemInstance(string itemType, string include, string exclude, string remove, string keepMetadata, string removeMetadata, string keepDuplicates, string condition, ElementLocation location, ElementLocation includeLocation, ElementLocation excludeLocation, ElementLocation removeLocation, ElementLocation keepMetadataLocation, ElementLocation removeMetadataLocation, ElementLocation keepDuplicatesLocation, ElementLocation conditionLocation, IEnumerable`1<ProjectItemGroupTaskMetadataInstance> metadata);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    [DebuggerStepThroughAttribute]
public string get_Include();
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    [DebuggerStepThroughAttribute]
public string get_Remove();
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskMetadataInstance> get_Metadata();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_IncludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ExcludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicatesLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskItemInstance DeepClone();
}
[DebuggerDisplayAttribute("{name} Value={value} Condition={condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance : object {
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskMetadataInstance DeepClone();
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
public class Microsoft.Build.Execution.ProjectItemInstance : object {
    [DebuggerBrowsableAttribute("0")]
public ProjectInstance Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public string EvaluatedInclude { get; public set; }
    private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public IEnumerable`1<ProjectMetadataInstance> Metadata { get; }
    public int DirectMetadataCount { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    public ICollection`1<string> MetadataNames { get; }
    private string Microsoft.Build.Framework.ITaskItem.ItemSpec { get; private set; }
    private ICollection Microsoft.Build.Framework.ITaskItem.MetadataNames { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    internal static IEqualityComparer`1<ProjectItemInstance> EqualityComparer { get; }
    internal string ProjectFullPath { get; }
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> directMetadata, List`1<ProjectItemDefinitionInstance> itemDefinitions);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, IEnumerable`1<KeyValuePair`2<string, string>> directMetadata);
    public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public IEnumerable`1<ProjectMetadataInstance> get_Metadata();
    public int get_DirectMetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    public ICollection`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.get_ItemSpec();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.set_ItemSpec(string value);
    private sealed virtual override ICollection Microsoft.Build.Framework.ITaskItem.get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    internal static IEqualityComparer`1<ProjectItemInstance> get_EqualityComparer();
    internal string get_ProjectFullPath();
    public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    public ProjectMetadataInstance SetMetadata(string name, string evaluatedValue);
    public void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataDictionary);
    public sealed virtual void RemoveMetadata(string metadataName);
    public virtual string ToString();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItem<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string name);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(ITaskItem destinationItem);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata();
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override ProjectItemInstance Microsoft.Build.Collections.IDeepCloneable<Microsoft.Build.Execution.ProjectItemInstance>.DeepClone();
    internal static void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataList, IEnumerable`1<ProjectItemInstance> items);
    internal static ProjectItemInstance FactoryForDeserialization(INodePacketTranslator translator, ProjectInstance projectInstance);
    internal void SetMetadata(CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> metadataDictionary);
    internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped);
    internal ProjectItemInstance DeepClone();
    internal ProjectItemInstance DeepClone(ProjectInstance newProject);
    internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("{name}={EvaluatedValue}")]
public class Microsoft.Build.Execution.ProjectMetadataInstance : object {
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadataInstance(string name, string escapedValue);
    internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers);
    internal ProjectMetadataInstance(ProjectMetadata metadatum);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>.Equals(ProjectMetadataInstance other);
    public sealed virtual ProjectMetadataInstance DeepClone();
    internal static ProjectMetadataInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("ExecuteTargets={executeTargets} Condition={condition}")]
public class Microsoft.Build.Execution.ProjectOnErrorInstance : ProjectTargetInstanceChild {
    public string Condition { get; }
    public string ExecuteTargets { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorInstance(string executeTargets, string condition, ElementLocation location, ElementLocation executeTargetsLocation, ElementLocation conditionLocation);
    public virtual string get_Condition();
    public string get_ExecuteTargets();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ExecuteTargetsLocation();
}
[DebuggerDisplayAttribute("Condition={condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance : ProjectTargetInstanceChild {
    public string Condition { get; }
    public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> Properties { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, IEnumerable`1<ProjectPropertyGroupTaskPropertyInstance> properties);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> get_Properties();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskInstance DeepClone();
}
[DebuggerDisplayAttribute("{name}={Value} Condition={condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance : object {
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskPropertyInstance DeepClone();
}
[DebuggerDisplayAttribute("{name}={escapedValue}")]
public class Microsoft.Build.Execution.ProjectPropertyInstance : object {
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; public set; }
    public bool IsImmutable { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedValue(string value);
    public virtual bool get_IsImmutable();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(ProjectPropertyInstance other);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Collections.IDeepCloneable<Microsoft.Build.Execution.ProjectPropertyInstance>.DeepClone();
    public virtual string ToString();
    internal static ProjectPropertyInstance Create(string name, string escapedValue);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location, bool isImmutable);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable);
    internal static ProjectPropertyInstance FactoryForDeserialization(INodePacketTranslator translator);
    internal ProjectPropertyInstance DeepClone();
    internal ProjectPropertyInstance DeepClone(bool isImmutable);
    internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("Name={name} Count={children.Count} Condition={condition} Inputs={inputs} Outputs={outputs} DependsOnTargets={dependsOnTargets}")]
public class Microsoft.Build.Execution.ProjectTargetInstance : object {
    public string Name { get; }
    public string Condition { get; }
    public string Inputs { get; }
    public string Outputs { get; }
    public string Returns { get; }
    public string KeepDuplicateOutputs { get; }
    public string DependsOnTargets { get; }
    public IList`1<ProjectTargetInstanceChild> Children { get; }
    public IList`1<ProjectOnErrorInstance> OnErrorChildren { get; }
    public ICollection`1<ProjectTaskInstance> Tasks { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal bool ParentProjectSupportsReturnsAttribute { get; }
    internal ProjectTargetInstance(string name, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, ElementLocation location, ElementLocation conditionLocation, ElementLocation inputsLocation, ElementLocation outputsLocation, ElementLocation returnsLocation, ElementLocation keepDuplicateOutputsLocation, ElementLocation dependsOnTargetsLocation, ElementLocation beforeTargetsLocation, ElementLocation afterTargetsLocation, ReadOnlyCollection`1<ProjectTargetInstanceChild> children, ReadOnlyCollection`1<ProjectOnErrorInstance> onErrorChildren, bool parentProjectSupportsReturnsAttribute);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    [DebuggerStepThroughAttribute]
public string get_Returns();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectTargetInstanceChild> get_Children();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectOnErrorInstance> get_OnErrorChildren();
    public ICollection`1<ProjectTaskInstance> get_Tasks();
    public string get_FullPath();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_InputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_OutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ReturnsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicateOutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_DependsOnTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_BeforeTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_AfterTargetsLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
internal bool get_ParentProjectSupportsReturnsAttribute();
    internal ProjectTargetElement ToProjectTargetElement(ProjectRootElement rootElement);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
}
public abstract class Microsoft.Build.Execution.ProjectTargetInstanceChild : object {
    public string Condition { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public string get_FullPath();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_ConditionLocation();
}
[DebuggerDisplayAttribute("Name={name} Condition={condition} ContinueOnError={continueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Parameters={parameters.Count} #Outputs={outputs.Count}")]
public class Microsoft.Build.Execution.ProjectTaskInstance : ProjectTargetInstanceChild {
    public string Name { get; }
    public string Condition { get; }
    public string ContinueOnError { get; }
    public string MSBuildRuntime { get; }
    public string MSBuildArchitecture { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public IList`1<ProjectTaskInstanceChild> Outputs { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> ParametersForBuild { get; }
    internal ProjectTaskInstance(ProjectTaskElement element, IList`1<ProjectTaskInstanceChild> outputs);
    internal ProjectTaskInstance(string name, ElementLocation taskLocation, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
    public string get_Name();
    public virtual string get_Condition();
    public string get_ContinueOnError();
    public string get_MSBuildRuntime();
    public string get_MSBuildArchitecture();
    public IDictionary`2<string, string> get_Parameters();
    public IList`1<ProjectTaskInstanceChild> get_Outputs();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> get_ParametersForBuild();
    internal string GetParameter(string parameterName);
    internal void SetParameter(string parameterName, string unevaluatedValue);
    internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition);
    internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition);
}
public abstract class Microsoft.Build.Execution.ProjectTaskInstanceChild : object {
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_TaskParameterLocation();
    public abstract virtual ElementLocation get_ConditionLocation();
}
public class Microsoft.Build.Execution.ProjectTaskOutputItemInstance : ProjectTaskInstanceChild {
    public string ItemType { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_ItemType();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
    public ElementLocation get_ItemTypeLocation();
}
public class Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild {
    public string PropertyName { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_PropertyName();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public ElementLocation get_PropertyNameLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
}
internal class Microsoft.Build.Execution.ReflectableTaskPropertyInfo : TaskPropertyInfo {
    internal PropertyInfo Reflection { get; }
    internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType);
    internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo);
    internal PropertyInfo get_Reflection();
}
public class Microsoft.Build.Execution.TargetResult : object {
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    internal WorkUnitResult WorkUnitResult { get; }
    internal bool TargetFailureDoesntCauseBuildFailure { get; internal set; }
    internal TargetResult(TaskItem[] items, WorkUnitResult result);
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
public sealed virtual ITaskItem[] get_Items();
    [DebuggerStepThroughAttribute]
public sealed virtual TargetResultCode get_ResultCode();
    [DebuggerStepThroughAttribute]
internal WorkUnitResult get_WorkUnitResult();
    [DebuggerStepThroughAttribute]
internal bool get_TargetFailureDoesntCauseBuildFailure();
    [DebuggerStepThroughAttribute]
internal void set_TargetFailureDoesntCauseBuildFailure(bool value);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static TargetResult FactoryForDeserialization(INodePacketTranslator translator);
    internal static string GetCacheFile(int configId, string targetToCache);
    internal static string GetCacheDirectory(int configId, string targetToCache);
    internal void CacheItems(int configId, string targetName);
}
public enum Microsoft.Build.Execution.TargetResultCode : Enum {
    public byte value__;
    public static TargetResultCode Skipped;
    public static TargetResultCode Success;
    public static TargetResultCode Failure;
}
internal class Microsoft.Build.Execution.TaskFactoryWrapper : object {
    public LoadedType TaskFactoryLoadedType { get; private set; }
    public ITaskFactory TaskFactory { get; }
    public IDictionary`2<string, string> GetNamesOfPropertiesWithRequiredAttribute { get; }
    public IDictionary`2<string, string> GetNamesOfPropertiesWithOutputAttribute { get; }
    public string Name { get; }
    public IDictionary`2<string, string> FactoryIdentityParameters { get; }
    internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary`2<string, string> factoryIdentityParameters);
    [CompilerGeneratedAttribute]
public LoadedType get_TaskFactoryLoadedType();
    [CompilerGeneratedAttribute]
private void set_TaskFactoryLoadedType(LoadedType value);
    public ITaskFactory get_TaskFactory();
    public IDictionary`2<string, string> get_GetNamesOfPropertiesWithRequiredAttribute();
    public IDictionary`2<string, string> get_GetNamesOfPropertiesWithOutputAttribute();
    public string get_Name();
    public IDictionary`2<string, string> get_FactoryIdentityParameters();
    public TaskPropertyInfo GetProperty(string propertyName);
    internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value);
    internal object GetPropertyValue(ITask task, TaskPropertyInfo property);
    internal bool IsCreatableByFactory(string taskName);
}
internal class Microsoft.Build.Execution.TaskRegistry : object {
    internal Toolset Toolset { get; }
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> TaskRegistrations { get; }
    internal TaskRegistry(ProjectRootElementCache projectRootElementCache);
    internal TaskRegistry(Toolset toolset, ProjectRootElementCache projectRootElementCache);
    private static TaskRegistry();
    [DebuggerStepThroughAttribute]
internal Toolset get_Toolset();
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> get_TaskRegistrations();
    internal static void RegisterTasksFromUsingTaskElement(ILoggingService loggingService, BuildEventContext buildEventContext, string directoryOfImportingFile, ProjectUsingTaskElement projectUsingTaskXml, TaskRegistry taskRegistry, Expander`2<P, I> expander, ExpanderOptions expanderOptions);
    internal TaskFactoryWrapper GetRegisteredTask(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    internal RegisteredTaskRecord GetTaskRegistrationRecord(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, Boolean& retrievedFromCache);
}
internal static class Microsoft.Build.Internal.AvailableStaticMethods : object {
    private static AvailableStaticMethods();
    internal static bool ContainsKey(string key);
    internal static bool TryAdd(string key, Tuple`2<string, Type> value);
    internal static bool TryGetValue(string key, Tuple`2& value);
    internal static void Reset_ForUnitTestsOnly();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.CommunicationsUtilities : object {
    internal static int NodeConnectionTimeout { get; }
    private static CommunicationsUtilities();
    internal static int get_NodeConnectionTimeout();
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static void CopyMemory(Char* destination, Char* source, UInt32 length);
    internal static Char[] GetEnvironmentCharArray();
    internal static Dictionary`2<string, string> GetEnvironmentVariables();
    internal static void SetEnvironment(IDictionary`2<string, string> newEnvironment);
    internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clientHandshake);
    internal static long GetTaskHostHostHandshake(TaskHostContext hostContext);
    internal static long GetTaskHostClientHandshake(TaskHostContext hostContext);
    [ExtensionAttribute]
internal static void WriteLongForHandshake(PipeStream stream, long value);
    [ExtensionAttribute]
internal static long ReadLongForHandshake(PipeStream stream);
    [ExtensionAttribute]
internal static long ReadLongForHandshake(PipeStream stream, Byte[] leadingBytesToReject, byte rejectionByteToReturn);
    internal static TaskHostContext GetTaskHostContext(IDictionary`2<string, string> taskHostParameters);
    internal static TaskHostContext GetTaskHostContext(bool is64BitProcess, int clrVersion);
    internal static TaskHostContext GetCurrentTaskHostContext();
    internal static int GetIntegerVariableOrDefault(string environmentVariable, int defaultValue);
    internal static void Trace(string format, Object[] args);
    internal static void Trace(int nodeId, string format, Object[] args);
}
internal static class Microsoft.Build.Internal.Constants : object {
    internal static string defaultToolsVersion;
    internal static string defaultFallbackToolsVersion;
    internal static string defaultSolutionWrapperProjectToolsVersion;
    internal static string SubToolsetVersionPropertyName;
    internal static string Dev10SubToolsetValue;
    internal static string programFilesx86;
    internal static long assemblyTimestamp;
    internal static string AssemblyVersion { get; }
    internal static long AssemblyTimestamp { get; }
    internal static string get_AssemblyVersion();
    internal static long get_AssemblyTimestamp();
}
internal class Microsoft.Build.Internal.EngineFileUtilities : object {
    internal static String[] GetFileListUnescaped(string directoryEscaped, string filespecEscaped);
    internal static String[] GetFileListEscaped(string directoryEscaped, string filespecEscaped);
}
internal class Microsoft.Build.Internal.ProjectXmlUtilities : object {
    internal static List`1<XmlElementWithLocation> GetVerifyThrowProjectChildElements(XmlElementWithLocation element);
    internal static void VerifyThrowProjectNoChildElements(XmlElementWithLocation element);
    internal static void ThrowProjectInvalidChildElementDueToDuplicate(XmlElementWithLocation child);
    internal static void ThrowProjectInvalidChildElement(string name, string parentName, ElementLocation location);
    internal static void VerifyThrowProjectValidNamespace(XmlElementWithLocation element);
    internal static void VerifyThrowProjectAttributeEitherMissingOrNotEmpty(XmlElementWithLocation xmlElement, string attributeName);
    internal static void VerifyThrowProjectNoAttributes(XmlElementWithLocation element);
    internal static void VerifyThrowProjectInvalidAttribute(bool condition, XmlAttributeWithLocation attribute);
    internal static void VerifyThrowProjectRequiredAttribute(XmlElementWithLocation element, string attributeName);
    internal static void VerifyThrowProjectAttributes(XmlElementWithLocation element, String[] validAttributes);
    internal static void ThrowProjectInvalidAttribute(XmlAttributeWithLocation attribute);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value, bool allowSettingEmptyAttributes);
    internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool returnNullForNonexistentAttributes);
}
internal class Microsoft.Build.Internal.RegistryKeyWrapper : object {
    public string Name { get; }
    protected RegistryKeyWrapper(RegistryKey wrappedKey, RegistryKey registryHive);
    internal RegistryKeyWrapper(string registryKeyPath);
    internal RegistryKeyWrapper(string registryKeyPath, RegistryHive registryHive, RegistryView registryView);
    internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive);
    public virtual string get_Name();
    public static bool KeyExists(string registryKeyPath, RegistryHive registryHive, RegistryView registryView);
    public virtual object GetValue(string name);
    public virtual String[] GetValueNames();
    public virtual String[] GetSubKeyNames();
    public virtual RegistryKeyWrapper OpenSubKey(string name);
    public virtual bool Exists();
    public sealed virtual void Dispose();
}
internal static class Microsoft.Build.Internal.ReservedPropertyNames : object {
    internal static string projectDirectory;
    internal static string projectDirectoryNoRoot;
    internal static string projectFile;
    internal static string projectExtension;
    internal static string projectFullPath;
    internal static string projectName;
    internal static string thisFileDirectory;
    internal static string thisFileDirectoryNoRoot;
    internal static string thisFile;
    internal static string thisFileExtension;
    internal static string thisFileFullPath;
    internal static string thisFileName;
    internal static string binPath;
    internal static string projectDefaultTargets;
    internal static string extensionsPath;
    internal static string extensionsPath32;
    internal static string extensionsPath64;
    internal static string userExtensionsPath;
    internal static string toolsPath;
    internal static string toolsVersion;
    internal static string overrideTasksPath;
    internal static string startupDirectory;
    internal static string buildNodeCount;
    internal static string lastTaskResult;
    internal static string extensionsPathSuffix;
    internal static string userExtensionsPathSuffix;
    internal static string programFiles32;
    internal static string localAppData;
    private static ReservedPropertyNames();
    internal static bool IsReservedProperty(string property);
}
internal enum Microsoft.Build.Internal.TaskHostContext : Enum {
    public int value__;
    public static TaskHostContext X32CLR2;
    public static TaskHostContext X64CLR2;
    public static TaskHostContext X32CLR4;
    public static TaskHostContext X64CLR4;
    public static TaskHostContext Invalid;
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.Utilities : object {
    private static Utilities();
    internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string s);
    internal static string GetXmlNodeInnerContents(XmlElementWithLocation node);
    internal static string RemoveXmlNamespace(string xml);
    internal static string CreateToolsVersionListString(IEnumerable`1<Toolset> toolsets);
    internal static PropertyDictionary`1<ProjectPropertyInstance> GetEnvironmentProperties();
    [ExtensionAttribute]
public static int FastCountOrZero(IEnumerable enumerable);
    [ExtensionAttribute]
public static IEnumerable`1<T> Values(IEnumerable`1<KeyValuePair`2<string, T>> source);
}
internal class Microsoft.Build.InterningBinaryReader : BinaryReader {
    public virtual string ReadString();
    internal static SharedReadBuffer CreateSharedBuffer();
    internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer);
}
public class Microsoft.Build.Logging.ColorResetter : MulticastDelegate {
    public ColorResetter(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ColorSetter : MulticastDelegate {
    public ColorSetter(object object, IntPtr method);
    public virtual void Invoke(ConsoleColor color);
    public virtual IAsyncResult BeginInvoke(ConsoleColor color, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ConfigurableForwardingLogger : object {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    private static ConfigurableForwardingLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    public virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Shutdown();
    protected virtual void ForwardToCentralLogger(BuildEventArgs e);
}
public class Microsoft.Build.Logging.ConsoleLogger : object {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public bool SkipProjectStartedText { get; public set; }
    public bool ShowSummary { get; public set; }
    protected WriteHandler WriteHandler { get; protected set; }
    public ConsoleLogger(LoggerVerbosity verbosity);
    public ConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public bool get_SkipProjectStartedText();
    public void set_SkipProjectStartedText(bool value);
    public bool get_ShowSummary();
    public void set_ShowSummary(bool value);
    protected WriteHandler get_WriteHandler();
    protected void set_WriteHandler(WriteHandler value);
    public void ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Shutdown();
    public void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public void ErrorHandler(object sender, BuildErrorEventArgs e);
    public void WarningHandler(object sender, BuildWarningEventArgs e);
    public void MessageHandler(object sender, BuildMessageEventArgs e);
    public void CustomEventHandler(object sender, CustomBuildEventArgs e);
    internal static void SetColor(ConsoleColor c);
    internal static void ResetColor();
}
public class Microsoft.Build.Logging.DistributedFileLogger : object {
    internal FileLogger InternalFilelogger { get; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    private static DistributedFileLogger();
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    internal FileLogger get_InternalFilelogger();
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
}
public class Microsoft.Build.Logging.FileLogger : ConsoleLogger {
    private static FileLogger();
    public virtual void Initialize(IEventSource eventSource);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Shutdown();
}
public class Microsoft.Build.Logging.ForwardingLoggerRecord : object {
    public ILogger CentralLogger { get; private set; }
    public LoggerDescription ForwardingLoggerDescription { get; private set; }
    public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription);
    [CompilerGeneratedAttribute]
public ILogger get_CentralLogger();
    [CompilerGeneratedAttribute]
private void set_CentralLogger(ILogger value);
    [CompilerGeneratedAttribute]
public LoggerDescription get_ForwardingLoggerDescription();
    [CompilerGeneratedAttribute]
private void set_ForwardingLoggerDescription(LoggerDescription value);
}
public class Microsoft.Build.Logging.LoggerDescription : object {
    internal int LoggerId { get; internal set; }
    internal string Name { get; }
    public string LoggerSwitchParameters { get; }
    public LoggerVerbosity Verbosity { get; }
    public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, LoggerVerbosity verbosity);
    private static LoggerDescription();
    internal int get_LoggerId();
    internal void set_LoggerId(int value);
    internal string get_Name();
    public string get_LoggerSwitchParameters();
    public LoggerVerbosity get_Verbosity();
    internal IForwardingLogger CreateForwardingLogger();
    public ILogger CreateLogger();
    internal void ConvertPathsToFullPaths();
    internal void WriteToStream(BinaryWriter writer);
    internal void CreateFromStream(BinaryReader reader);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static LoggerDescription FactoryForTranslation(INodePacketTranslator translator);
}
public class Microsoft.Build.Logging.WriteHandler : MulticastDelegate {
    public WriteHandler(object object, IntPtr method);
    public virtual void Invoke(string message);
    public virtual IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.OpportunisticIntern : object {
    private static OpportunisticIntern();
    internal static int AssignViaEnvironment(string env, int default);
    internal static void EnableStatisticsGathering();
    internal static string InternableToString(IInternable candidate);
    internal static string StringBuilderToString(StringBuilder candidate);
    internal static string CharArrayToString(Char[] candidate, int count);
    internal static string CharArrayToString(Char[] candidate, int startIndex, int count);
    internal static string InternStringIfPossible(string candidate);
    internal static void ReportStatistics();
}
internal abstract class Microsoft.Build.Shared.AssemblyLoadInfo : object {
    public string AssemblyName { get; }
    public string AssemblyFile { get; }
    internal string AssemblyLocation { get; }
    internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile);
    public abstract virtual string get_AssemblyName();
    public abstract virtual string get_AssemblyFile();
    internal abstract virtual string get_AssemblyLocation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual void Translate(INodePacketTranslator translator);
    public static AssemblyLoadInfo FactoryForTranslation(INodePacketTranslator translator);
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool CompareCulture(AssemblyNameExtension that);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal bool get_IsUnnamedAssembly();
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static void RegisterMSBuildExeResources(ResourceManager manager);
    internal static string GetString(string name);
    internal static string GetStringLookingInMSBuildExeResourcesFirst(string name);
    internal static ResourceManager get_PrimaryResources();
    internal static ResourceManager get_SharedResources();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AwaitExtensions : object {
    internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance { get; }
    private static AwaitExtensions();
    internal static TaskScheduler get_OneSTAThreadPerTaskSchedulerInstance();
    [ExtensionAttribute]
internal static TaskAwaiter GetAwaiter(WaitHandle handle);
    [ExtensionAttribute]
internal static TaskAwaiter`1<int> GetAwaiter(WaitHandle[] handles);
    [ExtensionAttribute]
internal static Task ToTask(WaitHandle handle, int timeout);
    [ExtensionAttribute]
internal static Task`1<int> ToTask(WaitHandle[] handles, int timeout);
}
internal class Microsoft.Build.Shared.BuildEventFileInfo : object {
    internal string File { get; }
    internal int Line { get; }
    internal int Column { get; }
    internal int EndLine { get; }
    internal int EndColumn { get; }
    internal BuildEventFileInfo(string file);
    internal BuildEventFileInfo(IElementLocation location);
    internal BuildEventFileInfo(string file, int line, int column);
    internal BuildEventFileInfo(string file, int line, int column, int endLine, int endColumn);
    internal BuildEventFileInfo(XmlException e);
    internal string get_File();
    internal int get_Line();
    internal int get_Column();
    internal int get_EndLine();
    internal int get_EndColumn();
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static CanonicalError();
    internal static Parts Parse(string message);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.CollectionHelpers : object {
    internal static List`1<T> RemoveNulls(List`1<T> inputs);
    [ExtensionAttribute]
internal static bool ContainsValueAndIsEqual(Dictionary`2<string, string> dictionary, string key, string value, StringComparison comparer);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static bool CanConvertStringToBool(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string Escape(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static EventArgsFormatting();
    internal static string EscapeCarriageReturn(string stringWithCarriageReturn);
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.FileMatcher : object {
    internal static Char[] directorySeparatorCharacters;
    private static FileMatcher();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal static void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, GetFileSystemEntries getFileSystemEntries);
    internal static bool IsDirectorySeparator(char c);
    internal static void RemoveProjectDirectory(String[] paths, string projectDirectory);
    internal static void GetFileSpecInfo(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    internal static Result FileMatch(string filespec, string fileToMatch);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, GetFileSystemEntries getFileSystemEntries, DirectoryExists directoryExists);
}
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static int MaxPath;
    internal static string FileTimeFormat;
    internal static string cacheDirectory;
    internal static string ExecutingAssemblyPath { get; }
    internal static string CurrentExecutableName { get; }
    internal static string CurrentExecutablePath { get; }
    internal static string CurrentExecutableDirectory { get; }
    internal static string CurrentExecutableConfigurationFilePath { get; }
    private static FileUtilities();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string get_CurrentExecutableName();
    internal static string get_CurrentExecutablePath();
    internal static string get_CurrentExecutableDirectory();
    internal static string get_CurrentExecutableConfigurationFilePath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive);
    internal static bool IsRootedNoThrow(string path);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath);
    internal static bool FileExistsNoThrow(string fullPath);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string fullDotNetFrameworkRegistryKey;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string fullDotNetFrameworkSdkRegistryKeyV40OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV40OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV40OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV40OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    internal static string fullDotNetFrameworkSdkRegistryKeyV45OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV45OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV45OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV45OnVS11;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    internal static string PathToDotNetFrameworkSdkV35ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV35ToolsOnVS11 { get; }
    internal static string PathToDotNetFrameworkSdkV40ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV40ToolsOnVS11 { get; }
    internal static string PathToDotNetFrameworkSdkV45ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV45ToolsOnVS11 { get; }
    internal static string PathToWindowsSdkV45OnVS10 { get; }
    internal static string PathToWindowsSdkV45OnVS11 { get; }
    internal static string PathToDotNetFrameworkReferenceAssembliesV30 { get; }
    internal static string PathToDotNetFrameworkReferenceAssembliesV35 { get; }
    private static FrameworkLocationHelper();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    internal static string get_PathToDotNetFrameworkSdkV35ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV35ToolsOnVS11();
    internal static string get_PathToDotNetFrameworkSdkV40ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV40ToolsOnVS11();
    internal static string get_PathToDotNetFrameworkSdkV45ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV45ToolsOnVS11();
    internal static string get_PathToWindowsSdkV45OnVS10();
    internal static string get_PathToWindowsSdkV45OnVS11();
    internal static string get_PathToDotNetFrameworkReferenceAssembliesV30();
    internal static string get_PathToDotNetFrameworkReferenceAssembliesV35();
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal interface Microsoft.Build.Shared.IElementLocation {
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual string get_LocationString();
}
internal static class Microsoft.Build.Shared.InprocTrackingNativeMethods : object {
    internal static void StartTrackingContext(string intermediateDirectory, string taskName);
    internal static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarker);
    internal static void EndTrackingContext();
    internal static void StopTrackingAndCleanup();
    internal static void SuspendTracking();
    internal static void ResumeTracking();
    internal static void WriteAllTLogs(string intermediateDirectory, string tlogRootName);
    internal static void WriteContextTLogs(string intermediateDirectory, string tlogRootName);
    internal static void SetThreadCount(int threadCount);
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.Build.Shared.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
}
internal class Microsoft.Build.Shared.LoadedType : object {
    internal Type Type { get; }
    internal Assembly LoadedAssembly { get; }
    internal AssemblyLoadInfo Assembly { get; }
    internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo);
    internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly);
    public bool HasLoadInSeparateAppDomainAttribute();
    public bool HasSTAThreadAttribute();
    internal Type get_Type();
    internal Assembly get_LoadedAssembly();
    internal AssemblyLoadInfo get_Assembly();
}
internal enum Microsoft.Build.Shared.LoggingEventType : Enum {
    public int value__;
    public static LoggingEventType Invalid;
    public static LoggingEventType CustomEvent;
    public static LoggingEventType BuildErrorEvent;
    public static LoggingEventType BuildFinishedEvent;
    public static LoggingEventType BuildMessageEvent;
    public static LoggingEventType BuildStartedEvent;
    public static LoggingEventType BuildWarningEvent;
    public static LoggingEventType ProjectFinishedEvent;
    public static LoggingEventType ProjectStartedEvent;
    public static LoggingEventType TargetStartedEvent;
    public static LoggingEventType TargetFinishedEvent;
    public static LoggingEventType TaskStartedEvent;
    public static LoggingEventType TaskFinishedEvent;
    public static LoggingEventType TaskCommandLineEvent;
}
internal abstract class Microsoft.Build.Shared.LogMessagePacketBase : object {
    public NodePacketType Type { get; }
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> NodeBuildEvent { get; }
    internal LoggingEventType EventType { get; }
    internal LogMessagePacketBase(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent, TargetFinishedTranslator targetFinishedTranslator);
    protected LogMessagePacketBase(INodePacketTranslator translator);
    private static LogMessagePacketBase();
    public sealed virtual NodePacketType get_Type();
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> get_NodeBuildEvent();
    internal LoggingEventType get_EventType();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal void WriteToStream(INodePacketTranslator translator);
    internal void ReadFromStream(INodePacketTranslator translator);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static HandleRef NullHandleRef;
    internal static IntPtr NullIntPtr;
    internal static int MAX_PATH;
    private static NativeMethodsShared();
    internal static int SetErrorMode(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static string FindOnPath(string filename);
    internal static void KillTree(int processIdTokill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, StringBuilder lpBuffer);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, StringBuilder buffer, IntPtr mustBeZero);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
internal class Microsoft.Build.Shared.OutOfProcTaskHostTaskResult : object {
    public TaskCompleteType Result { get; private set; }
    public IDictionary`2<string, object> FinalParameterValues { get; private set; }
    public Exception TaskException { get; private set; }
    public string ExceptionMessage { get; private set; }
    public String[] ExceptionMessageArgs { get; private set; }
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    [CompilerGeneratedAttribute]
public TaskCompleteType get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(TaskCompleteType value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_FinalParameterValues();
    [CompilerGeneratedAttribute]
private void set_FinalParameterValues(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Exception get_TaskException();
    [CompilerGeneratedAttribute]
private void set_TaskException(Exception value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public String[] get_ExceptionMessageArgs();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessageArgs(String[] value);
}
internal class Microsoft.Build.Shared.Pair`2 : ValueType {
    private TKey key;
    private TValue value;
    internal TKey Key { get; }
    internal TValue Value { get; }
    public Pair`2(TKey key, TValue value);
    internal TKey get_Key();
    internal TValue get_Value();
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
internal static class Microsoft.Build.Shared.ProjectErrorUtilities : object {
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, object arg0);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, object arg0);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, object arg0, object arg1);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, object arg0);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, object arg0, object arg1, object arg2, object arg3);
}
internal static class Microsoft.Build.Shared.ProjectFileErrorUtilities : object {
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
}
internal class Microsoft.Build.Shared.ProjectWriter : XmlTextWriter {
    internal static string itemTypeOrMetadataNameSpecification;
    internal static string itemFunctionNameSpecification;
    internal static Regex itemVectorTransformPattern;
    internal static Regex itemVectorTransformRawPattern;
    internal ProjectWriter(TextWriter w);
    internal ProjectWriter(string filename, Encoding encoding);
    private static ProjectWriter();
    internal void Initialize(XmlDocument project);
    internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementDeclaration);
    public virtual void WriteString(string text);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReuseableStringBuilder : object {
    public int Length { get; }
    internal ReuseableStringBuilder(int capacity);
    public sealed virtual int get_Length();
    private sealed virtual override char Microsoft.Build.OpportunisticIntern.IInternable.get_Item(int index);
    private sealed virtual override string Microsoft.Build.OpportunisticIntern.IInternable.ExpensiveConvertToString();
    private sealed virtual override bool Microsoft.Build.OpportunisticIntern.IInternable.IsOrdinalEqualToStringOfSameLength(string other);
    private sealed virtual override bool Microsoft.Build.OpportunisticIntern.IInternable.ReferenceEquals(string other);
    public virtual string ToString();
    private sealed virtual override void System.IDisposable.Dispose();
    internal ReuseableStringBuilder Append(char value);
    internal ReuseableStringBuilder Append(string value);
    internal ReuseableStringBuilder Append(string value, int startIndex, int count);
    internal ReuseableStringBuilder Remove(int startIndex, int length);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.TaskLoader : object {
    internal static bool IsTaskClass(Type type, object unused);
    internal static ITask CreateTask(LoadedType loadedType, string taskName, string taskLocation, int taskLine, int taskColumn, LogError logError, AppDomainSetup appDomainSetup, bool isOutOfProc, AppDomain& taskAppDomain);
    internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args);
    internal static void RemoveAssemblyResolver();
}
internal static class Microsoft.Build.Shared.ThreadPoolExtensions : object {
    internal static bool QueueThreadPoolWorkItemWithCulture(WaitCallback callback, CultureInfo culture, CultureInfo uiCulture);
}
internal class Microsoft.Build.Shared.TypeLoader : object {
    internal TypeLoader(TypeFilter isDesiredType);
    private static TypeLoader();
    internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2);
    internal LoadedType Load(string typeName, AssemblyLoadInfo assembly);
    internal LoadedType ReflectionOnlyLoad(string typeName, AssemblyLoadInfo assembly);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
internal static class Microsoft.Build.Shared.XMakeAttributes : object {
    internal static string condition;
    internal static string executeTargets;
    internal static string name;
    internal static string msbuildVersion;
    internal static string xmlns;
    internal static string defaultTargets;
    internal static string initialTargets;
    internal static string treatAsLocalProperty;
    internal static string dependsOnTargets;
    internal static string beforeTargets;
    internal static string afterTargets;
    internal static string include;
    internal static string exclude;
    internal static string remove;
    internal static string keepMetadata;
    internal static string removeMetadata;
    internal static string keepDuplicates;
    internal static string inputs;
    internal static string outputs;
    internal static string keepDuplicateOutputs;
    internal static string assemblyName;
    internal static string assemblyFile;
    internal static string taskName;
    internal static string continueOnError;
    internal static string project;
    internal static string taskParameter;
    internal static string itemName;
    internal static string propertyName;
    internal static string toolsVersion;
    internal static string runtime;
    internal static string msbuildRuntime;
    internal static string architecture;
    internal static string msbuildArchitecture;
    internal static string taskFactory;
    internal static string parameterType;
    internal static string required;
    internal static string output;
    internal static string defaultValue;
    internal static string evaluate;
    internal static string label;
    internal static string returns;
    internal static string requiredRuntime;
    internal static string requiredPlatform;
    internal static string defaultXmlNamespace;
    internal static bool IsSpecialTaskAttribute(string attribute);
    internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute);
    internal static bool IsNonBatchingTargetAttribute(string attribute);
    internal static bool IsValidMSBuildRuntimeValue(string runtime);
    internal static bool IsValidMSBuildArchitectureValue(string architecture);
    internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB);
    internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, String& mergedRuntime);
    internal static bool ArchitectureValuesMatch(string architectureA, string architectureB);
    internal static string GetExplicitMSBuildRuntime(string runtime);
    internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, String& mergedArchitecture);
    internal static string GetCurrentMSBuildArchitecture();
    internal static string GetExplicitMSBuildArchitecture(string architecture);
}
internal static class Microsoft.Build.Shared.XMakeElements : object {
    internal static string project;
    internal static string visualStudioProject;
    internal static string target;
    internal static string propertyGroup;
    internal static string output;
    internal static string itemGroup;
    internal static string itemDefinitionGroup;
    internal static string usingTask;
    internal static string projectExtensions;
    internal static string onError;
    internal static string error;
    internal static string warning;
    internal static string message;
    internal static string import;
    internal static string importGroup;
    internal static string choose;
    internal static string when;
    internal static string otherwise;
    internal static string usingTaskParameterGroup;
    internal static string usingTaskParameter;
    internal static string usingTaskBody;
    internal static Char[] illegalTargetNameCharacters;
    internal static String[] illegalPropertyOrItemNames;
    internal static Hashtable IllegalItemPropertyNames { get; }
    private static XMakeElements();
    internal static Hashtable get_IllegalItemPropertyNames();
}
internal static class Microsoft.Build.Shared.XmlUtilities : object {
    internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation oldElement, string newElementName, string xmlNamespace);
    internal static void VerifyThrowArgumentValidElementName(string name);
    internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location);
    internal static void VerifyThrowProjectValidElementName(XmlElementWithLocation element);
    internal static bool IsValidElementName(string name);
    internal static int LocateFirstInvalidElementNameCharacter(string name);
    internal static string SniffAttributeValueFromXmlFile(string projectFileName, string elementName, string attributeName);
    internal static bool IsValidInitialElementNameCharacter(char c);
    internal static bool IsValidSubsequentElementNameCharacter(char c);
}
internal abstract class Microsoft.Build.SharedReadBuffer : object {
}
internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    public bool IsEnabled { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    internal CodeMarkerStartEnd(int begin, int end);
    public sealed virtual void Dispose();
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
