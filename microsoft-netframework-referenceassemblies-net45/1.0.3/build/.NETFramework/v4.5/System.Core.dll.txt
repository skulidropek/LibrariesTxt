[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeMemoryMappedFileHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle : SafeBuffer {
    internal SafeMemoryMappedViewHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute("1")]
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "2")]
protected abstract virtual bool ReleaseNativeHandle();
}
[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
[SecurityCriticalAttribute("1")]
public class Microsoft.Win32.SafeHandles.SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
public class System.Action`10 : MulticastDelegate {
    public Action`10(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`11 : MulticastDelegate {
    public Action`11(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`12 : MulticastDelegate {
    public Action`12(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`13 : MulticastDelegate {
    public Action`13(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`14 : MulticastDelegate {
    public Action`14(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`15 : MulticastDelegate {
    public Action`15(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`16 : MulticastDelegate {
    public Action`16(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`9 : MulticastDelegate {
    public Action`9(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.HashSetDebugView`1")]
public class System.Collections.Generic.HashSet`1 : object {
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    protected HashSet`1(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public sealed virtual bool Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public void TrimExcess();
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
}
internal class System.Collections.Generic.HashSetDebugView`1 : object {
}
public class System.Diagnostics.Eventing.EventDescriptor : ValueType {
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
}
public class System.Diagnostics.Eventing.EventProvider : object {
    [SecuritySafeCriticalAttribute]
public EventProvider(Guid providerGuid);
    private static EventProvider();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual void Finalize();
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    [SecurityCriticalAttribute]
public bool WriteMessageEvent(string eventMessage, byte eventLevel, long eventKeywords);
    public bool WriteMessageEvent(string eventMessage);
    public bool WriteEvent(EventDescriptor& eventDescriptor, Object[] eventPayload);
    [SecurityCriticalAttribute]
public bool WriteEvent(EventDescriptor& eventDescriptor, string data);
    [SecurityCriticalAttribute]
protected bool WriteEvent(EventDescriptor& eventDescriptor, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
public bool WriteTransferEvent(EventDescriptor& eventDescriptor, Guid relatedActivityId, Object[] eventPayload);
    [SecurityCriticalAttribute]
protected bool WriteTransferEvent(EventDescriptor& eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
public static void SetActivityId(Guid& id);
    [SecurityCriticalAttribute]
public static Guid CreateActivityId();
}
public class System.Diagnostics.Eventing.EventProviderTraceListener : TraceListener {
    public string Delimiter { get; public set; }
    public bool IsThreadSafe { get; }
    public EventProviderTraceListener(string providerId);
    public EventProviderTraceListener(string providerId, string name);
    public EventProviderTraceListener(string providerId, string name, string delimiter);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    protected virtual String[] GetSupportedAttributes();
    public sealed virtual void Flush();
    public sealed virtual bool get_IsThreadSafe();
    public virtual void Close();
    public sealed virtual void Write(string message);
    public sealed virtual void WriteLine(string message);
    public sealed virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public sealed virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public sealed virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public sealed virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public sealed virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void Fail(string message, string detailMessage);
    [SecurityCriticalAttribute]
public sealed virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
}
public class System.Diagnostics.Eventing.Reader.EventBookmark : object {
    protected EventBookmark(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Eventing.Reader.EventKeyword : object {
    public string Name { get; }
    public long Value { get; }
    public string DisplayName { get; }
    public string get_Name();
    public long get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventLevel : object {
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    public string get_Name();
    public int get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventLogConfiguration : object {
    public string LogName { get; }
    public EventLogType LogType { get; }
    public EventLogIsolation LogIsolation { get; }
    public bool IsEnabled { get; public set; }
    public bool IsClassicLog { get; }
    public string SecurityDescriptor { get; public set; }
    public string LogFilePath { get; public set; }
    public long MaximumSizeInBytes { get; public set; }
    public EventLogMode LogMode { get; public set; }
    public string OwningProviderName { get; }
    public IEnumerable`1<string> ProviderNames { get; }
    public Nullable`1<int> ProviderLevel { get; public set; }
    public Nullable`1<long> ProviderKeywords { get; public set; }
    public Nullable`1<int> ProviderBufferSize { get; }
    public Nullable`1<int> ProviderMinimumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderMaximumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderLatency { get; }
    public Nullable`1<Guid> ProviderControlGuid { get; }
    public EventLogConfiguration(string logName);
    [SecurityCriticalAttribute]
public EventLogConfiguration(string logName, EventLogSession session);
    public string get_LogName();
    public EventLogType get_LogType();
    public EventLogIsolation get_LogIsolation();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsClassicLog();
    public string get_SecurityDescriptor();
    public void set_SecurityDescriptor(string value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public long get_MaximumSizeInBytes();
    public void set_MaximumSizeInBytes(long value);
    public EventLogMode get_LogMode();
    public void set_LogMode(EventLogMode value);
    public string get_OwningProviderName();
    public IEnumerable`1<string> get_ProviderNames();
    public Nullable`1<int> get_ProviderLevel();
    public void set_ProviderLevel(Nullable`1<int> value);
    public Nullable`1<long> get_ProviderKeywords();
    public void set_ProviderKeywords(Nullable`1<long> value);
    public Nullable`1<int> get_ProviderBufferSize();
    public Nullable`1<int> get_ProviderMinimumNumberOfBuffers();
    public Nullable`1<int> get_ProviderMaximumNumberOfBuffers();
    public Nullable`1<int> get_ProviderLatency();
    public Nullable`1<Guid> get_ProviderControlGuid();
    public void SaveChanges();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogException : Exception {
    public string Message { get; }
    public EventLogException(string message);
    public EventLogException(string message, Exception innerException);
    protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected EventLogException(int errorCode);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual string get_Message();
}
public class System.Diagnostics.Eventing.Reader.EventLogInformation : object {
    public Nullable`1<DateTime> CreationTime { get; }
    public Nullable`1<DateTime> LastAccessTime { get; }
    public Nullable`1<DateTime> LastWriteTime { get; }
    public Nullable`1<long> FileSize { get; }
    public Nullable`1<int> Attributes { get; }
    public Nullable`1<long> RecordCount { get; }
    public Nullable`1<long> OldestRecordNumber { get; }
    public Nullable`1<bool> IsLogFull { get; }
    public Nullable`1<DateTime> get_CreationTime();
    public Nullable`1<DateTime> get_LastAccessTime();
    public Nullable`1<DateTime> get_LastWriteTime();
    public Nullable`1<long> get_FileSize();
    public Nullable`1<int> get_Attributes();
    public Nullable`1<long> get_RecordCount();
    public Nullable`1<long> get_OldestRecordNumber();
    public Nullable`1<bool> get_IsLogFull();
}
public class System.Diagnostics.Eventing.Reader.EventLogInvalidDataException : EventLogException {
    public EventLogInvalidDataException(string message);
    public EventLogInvalidDataException(string message, Exception innerException);
    protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Diagnostics.Eventing.Reader.EventLogIsolation : Enum {
    public int value__;
    public static EventLogIsolation Application;
    public static EventLogIsolation System;
    public static EventLogIsolation Custom;
}
public class System.Diagnostics.Eventing.Reader.EventLogLink : object {
    public string LogName { get; }
    public bool IsImported { get; }
    public string DisplayName { get; }
    public string get_LogName();
    public bool get_IsImported();
    public string get_DisplayName();
}
public enum System.Diagnostics.Eventing.Reader.EventLogMode : Enum {
    public int value__;
    public static EventLogMode Circular;
    public static EventLogMode AutoBackup;
    public static EventLogMode Retain;
}
public class System.Diagnostics.Eventing.Reader.EventLogNotFoundException : EventLogException {
    public EventLogNotFoundException(string message);
    public EventLogNotFoundException(string message, Exception innerException);
    protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogPropertySelector : object {
    [SecurityCriticalAttribute]
public EventLogPropertySelector(IEnumerable`1<string> propertyQueries);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException : EventLogException {
    public EventLogProviderDisabledException(string message);
    public EventLogProviderDisabledException(string message, Exception innerException);
    protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogQuery : object {
    public EventLogSession Session { get; public set; }
    public bool TolerateQueryErrors { get; public set; }
    public bool ReverseDirection { get; public set; }
    public EventLogQuery(string path, PathType pathType);
    public EventLogQuery(string path, PathType pathType, string query);
    public EventLogSession get_Session();
    public void set_Session(EventLogSession value);
    public bool get_TolerateQueryErrors();
    public void set_TolerateQueryErrors(bool value);
    public bool get_ReverseDirection();
    public void set_ReverseDirection(bool value);
}
public class System.Diagnostics.Eventing.Reader.EventLogReader : object {
    public int BatchSize { get; public set; }
    public IList`1<EventLogStatus> LogStatus { get; }
    public EventLogReader(string path);
    public EventLogReader(string path, PathType pathType);
    public EventLogReader(EventLogQuery eventQuery);
    [SecurityCriticalAttribute]
public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    public EventRecord ReadEvent();
    [SecurityCriticalAttribute]
public EventRecord ReadEvent(TimeSpan timeout);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public void Seek(EventBookmark bookmark);
    [SecurityCriticalAttribute]
public void Seek(EventBookmark bookmark, long offset);
    [SecurityCriticalAttribute]
public void Seek(SeekOrigin origin, long offset);
    public void CancelReading();
    [SecurityCriticalAttribute]
public IList`1<EventLogStatus> get_LogStatus();
}
public class System.Diagnostics.Eventing.Reader.EventLogReadingException : EventLogException {
    public EventLogReadingException(string message);
    public EventLogReadingException(string message, Exception innerException);
    protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogRecord : EventRecord {
    public int Id { get; }
    public Nullable`1<byte> Version { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<byte> Level { get; }
    public Nullable`1<int> Task { get; }
    public Nullable`1<short> Opcode { get; }
    public Nullable`1<long> Keywords { get; }
    public Nullable`1<long> RecordId { get; }
    public string ProviderName { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string LogName { get; }
    public Nullable`1<int> ProcessId { get; }
    public Nullable`1<int> ThreadId { get; }
    public string MachineName { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public Nullable`1<Guid> ActivityId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public string ContainerLog { get; }
    public IEnumerable`1<int> MatchedQueryIds { get; }
    public EventBookmark Bookmark { get; }
    public string LevelDisplayName { get; }
    public string OpcodeDisplayName { get; }
    public string TaskDisplayName { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public IList`1<EventProperty> Properties { get; }
    public virtual int get_Id();
    public virtual Nullable`1<byte> get_Version();
    public virtual Nullable`1<int> get_Qualifiers();
    public virtual Nullable`1<byte> get_Level();
    public virtual Nullable`1<int> get_Task();
    public virtual Nullable`1<short> get_Opcode();
    public virtual Nullable`1<long> get_Keywords();
    public virtual Nullable`1<long> get_RecordId();
    public virtual string get_ProviderName();
    public virtual Nullable`1<Guid> get_ProviderId();
    public virtual string get_LogName();
    public virtual Nullable`1<int> get_ProcessId();
    public virtual Nullable`1<int> get_ThreadId();
    public virtual string get_MachineName();
    public virtual SecurityIdentifier get_UserId();
    public virtual Nullable`1<DateTime> get_TimeCreated();
    public virtual Nullable`1<Guid> get_ActivityId();
    public virtual Nullable`1<Guid> get_RelatedActivityId();
    public string get_ContainerLog();
    public IEnumerable`1<int> get_MatchedQueryIds();
    [SecuritySafeCriticalAttribute]
public virtual EventBookmark get_Bookmark();
    public virtual string FormatDescription();
    public virtual string FormatDescription(IEnumerable`1<object> values);
    public virtual string get_LevelDisplayName();
    public virtual string get_OpcodeDisplayName();
    public virtual string get_TaskDisplayName();
    public virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public virtual IList`1<EventProperty> get_Properties();
    public IList`1<object> GetPropertyValues(EventLogPropertySelector propertySelector);
    [SecuritySafeCriticalAttribute]
public virtual string ToXml();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogSession : object {
    public static EventLogSession GlobalSession { get; }
    public EventLogSession(string server);
    [SecurityCriticalAttribute]
public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType);
    private static EventLogSession();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public void CancelCurrentOperations();
    public static EventLogSession get_GlobalSession();
    [SecurityCriticalAttribute]
public IEnumerable`1<string> GetProviderNames();
    [SecurityCriticalAttribute]
public IEnumerable`1<string> GetLogNames();
    public EventLogInformation GetLogInformation(string logName, PathType pathType);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo);
    public void ClearLog(string logName);
    public void ClearLog(string logName, string backupPath);
}
public class System.Diagnostics.Eventing.Reader.EventLogStatus : object {
    public string LogName { get; }
    public int StatusCode { get; }
    public string get_LogName();
    public int get_StatusCode();
}
public enum System.Diagnostics.Eventing.Reader.EventLogType : Enum {
    public int value__;
    public static EventLogType Administrative;
    public static EventLogType Operational;
    public static EventLogType Analytical;
    public static EventLogType Debug;
}
public class System.Diagnostics.Eventing.Reader.EventLogWatcher : object {
    public bool Enabled { get; public set; }
    public EventLogWatcher(string path);
    public EventLogWatcher(EventLogQuery eventQuery);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents);
    public void add_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public void remove_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventMetadata : object {
    public long Id { get; }
    public byte Version { get; }
    public EventLogLink LogLink { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public IEnumerable`1<EventKeyword> Keywords { get; }
    public string Template { get; }
    public string Description { get; }
    public long get_Id();
    public byte get_Version();
    public EventLogLink get_LogLink();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public IEnumerable`1<EventKeyword> get_Keywords();
    public string get_Template();
    public string get_Description();
}
public class System.Diagnostics.Eventing.Reader.EventOpcode : object {
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    public string get_Name();
    public int get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventProperty : object {
    public object Value { get; }
    public object get_Value();
}
public abstract class System.Diagnostics.Eventing.Reader.EventRecord : object {
    public int Id { get; }
    public Nullable`1<byte> Version { get; }
    public Nullable`1<byte> Level { get; }
    public Nullable`1<int> Task { get; }
    public Nullable`1<short> Opcode { get; }
    public Nullable`1<long> Keywords { get; }
    public Nullable`1<long> RecordId { get; }
    public string ProviderName { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string LogName { get; }
    public Nullable`1<int> ProcessId { get; }
    public Nullable`1<int> ThreadId { get; }
    public string MachineName { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public Nullable`1<Guid> ActivityId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Qualifiers { get; }
    public string LevelDisplayName { get; }
    public string OpcodeDisplayName { get; }
    public string TaskDisplayName { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public EventBookmark Bookmark { get; }
    public IList`1<EventProperty> Properties { get; }
    public abstract virtual int get_Id();
    public abstract virtual Nullable`1<byte> get_Version();
    public abstract virtual Nullable`1<byte> get_Level();
    public abstract virtual Nullable`1<int> get_Task();
    public abstract virtual Nullable`1<short> get_Opcode();
    public abstract virtual Nullable`1<long> get_Keywords();
    public abstract virtual Nullable`1<long> get_RecordId();
    public abstract virtual string get_ProviderName();
    public abstract virtual Nullable`1<Guid> get_ProviderId();
    public abstract virtual string get_LogName();
    public abstract virtual Nullable`1<int> get_ProcessId();
    public abstract virtual Nullable`1<int> get_ThreadId();
    public abstract virtual string get_MachineName();
    public abstract virtual SecurityIdentifier get_UserId();
    public abstract virtual Nullable`1<DateTime> get_TimeCreated();
    public abstract virtual Nullable`1<Guid> get_ActivityId();
    public abstract virtual Nullable`1<Guid> get_RelatedActivityId();
    public abstract virtual Nullable`1<int> get_Qualifiers();
    public abstract virtual string FormatDescription();
    public abstract virtual string FormatDescription(IEnumerable`1<object> values);
    public abstract virtual string get_LevelDisplayName();
    public abstract virtual string get_OpcodeDisplayName();
    public abstract virtual string get_TaskDisplayName();
    public abstract virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public abstract virtual EventBookmark get_Bookmark();
    public abstract virtual IList`1<EventProperty> get_Properties();
    public abstract virtual string ToXml();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs : EventArgs {
    public EventRecord EventRecord { get; }
    public Exception EventException { get; }
    public EventRecord get_EventRecord();
    public Exception get_EventException();
}
public class System.Diagnostics.Eventing.Reader.EventTask : object {
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    public Guid EventGuid { get; }
    public string get_Name();
    public int get_Value();
    public string get_DisplayName();
    public Guid get_EventGuid();
}
public enum System.Diagnostics.Eventing.Reader.PathType : Enum {
    public int value__;
    public static PathType LogName;
    public static PathType FilePath;
}
public class System.Diagnostics.Eventing.Reader.ProviderMetadata : object {
    public string Name { get; }
    public Guid Id { get; }
    public string MessageFilePath { get; }
    public string ResourceFilePath { get; }
    public string ParameterFilePath { get; }
    public Uri HelpLink { get; }
    public string DisplayName { get; }
    public IList`1<EventLogLink> LogLinks { get; }
    public IList`1<EventLevel> Levels { get; }
    public IList`1<EventOpcode> Opcodes { get; }
    public IList`1<EventKeyword> Keywords { get; }
    public IList`1<EventTask> Tasks { get; }
    public IEnumerable`1<EventMetadata> Events { get; }
    public ProviderMetadata(string providerName);
    public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo);
    public string get_Name();
    public Guid get_Id();
    public string get_MessageFilePath();
    public string get_ResourceFilePath();
    public string get_ParameterFilePath();
    public Uri get_HelpLink();
    [SecurityCriticalAttribute]
public string get_DisplayName();
    [SecurityCriticalAttribute]
public IList`1<EventLogLink> get_LogLinks();
    public IList`1<EventLevel> get_Levels();
    public IList`1<EventOpcode> get_Opcodes();
    public IList`1<EventKeyword> get_Keywords();
    public IList`1<EventTask> get_Tasks();
    [SecurityCriticalAttribute]
public IEnumerable`1<EventMetadata> get_Events();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
public enum System.Diagnostics.Eventing.Reader.SessionAuthentication : Enum {
    public int value__;
    public static SessionAuthentication Default;
    public static SessionAuthentication Negotiate;
    public static SessionAuthentication Kerberos;
    public static SessionAuthentication Ntlm;
}
[FlagsAttribute]
public enum System.Diagnostics.Eventing.Reader.StandardEventKeywords : Enum {
    public long value__;
    public static StandardEventKeywords None;
    public static StandardEventKeywords ResponseTime;
    public static StandardEventKeywords WdiContext;
    public static StandardEventKeywords WdiDiagnostic;
    public static StandardEventKeywords Sqm;
    public static StandardEventKeywords AuditFailure;
    public static StandardEventKeywords AuditSuccess;
    [ObsoleteAttribute("Incorrect value: use CorrelationHint2 instead", "False")]
public static StandardEventKeywords CorrelationHint;
    public static StandardEventKeywords CorrelationHint2;
    public static StandardEventKeywords EventLogClassic;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventLevel : Enum {
    public int value__;
    public static StandardEventLevel LogAlways;
    public static StandardEventLevel Critical;
    public static StandardEventLevel Error;
    public static StandardEventLevel Warning;
    public static StandardEventLevel Informational;
    public static StandardEventLevel Verbose;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventOpcode : Enum {
    public int value__;
    public static StandardEventOpcode Info;
    public static StandardEventOpcode Start;
    public static StandardEventOpcode Stop;
    public static StandardEventOpcode DataCollectionStart;
    public static StandardEventOpcode DataCollectionStop;
    public static StandardEventOpcode Extension;
    public static StandardEventOpcode Reply;
    public static StandardEventOpcode Resume;
    public static StandardEventOpcode Suspend;
    public static StandardEventOpcode Send;
    public static StandardEventOpcode Receive;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventTask : Enum {
    public int value__;
    public static StandardEventTask None;
}
public class System.Diagnostics.EventSchemaTraceListener : TextWriterTraceListener {
    public TextWriter Writer { get; public set; }
    public bool IsThreadSafe { get; }
    public int BufferSize { get; }
    public TraceLogRetentionOption TraceLogRetentionOption { get; }
    public long MaximumFileSize { get; }
    public int MaximumNumberOfFiles { get; }
    public EventSchemaTraceListener(string fileName);
    public EventSchemaTraceListener(string fileName, string name);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize);
    public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles);
    private static EventSchemaTraceListener();
    [SecurityCriticalAttribute]
public TextWriter get_Writer();
    public void set_Writer(TextWriter value);
    public virtual bool get_IsThreadSafe();
    public int get_BufferSize();
    public TraceLogRetentionOption get_TraceLogRetentionOption();
    public long get_MaximumFileSize();
    public int get_MaximumNumberOfFiles();
    public virtual void Close();
    [SecurityCriticalAttribute]
public virtual void Flush();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void Fail(string message, string detailMessage);
    [SecurityCriticalAttribute]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    [SecurityCriticalAttribute]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    [SecurityCriticalAttribute]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    [SecurityCriticalAttribute]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    [SecurityCriticalAttribute]
public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    protected virtual String[] GetSupportedAttributes();
    [SecurityCriticalAttribute]
private bool EnsureWriter();
}
public class System.Diagnostics.PerformanceData.CounterData : object {
    public long Value { get; public set; }
    public long RawValue { get; public set; }
    [SecurityCriticalAttribute]
public long get_Value();
    [SecurityCriticalAttribute]
public void set_Value(long value);
    [SecurityCriticalAttribute]
public void Increment();
    [SecurityCriticalAttribute]
public void Decrement();
    [SecurityCriticalAttribute]
public void IncrementBy(long value);
    [SecurityCriticalAttribute]
public long get_RawValue();
    [SecurityCriticalAttribute]
public void set_RawValue(long value);
}
public class System.Diagnostics.PerformanceData.CounterSet : object {
    [SecuritySafeCriticalAttribute]
public CounterSet(Guid providerGuid, Guid counterSetGuid, CounterSetInstanceType instanceType);
    private static CounterSet();
    public sealed virtual void Dispose();
    protected virtual void Finalize();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public void AddCounter(int counterId, CounterType counterType);
    public void AddCounter(int counterId, CounterType counterType, string counterName);
    [SecuritySafeCriticalAttribute]
public CounterSetInstance CreateCounterSetInstance(string instanceName);
}
public class System.Diagnostics.PerformanceData.CounterSetInstance : object {
    public CounterSetInstanceCounterDataSet Counters { get; }
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
protected virtual void Finalize();
    public CounterSetInstanceCounterDataSet get_Counters();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet : object {
    public CounterData Item { get; }
    public CounterData Item { get; }
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
protected virtual void Finalize();
    public CounterData get_Item(int counterId);
    public CounterData get_Item(string counterName);
}
public enum System.Diagnostics.PerformanceData.CounterSetInstanceType : Enum {
    public int value__;
    public static CounterSetInstanceType Single;
    public static CounterSetInstanceType Multiple;
    public static CounterSetInstanceType GlobalAggregate;
    public static CounterSetInstanceType GlobalAggregateWithHistory;
    public static CounterSetInstanceType MultipleAggregate;
    public static CounterSetInstanceType InstanceAggregate;
}
public enum System.Diagnostics.PerformanceData.CounterType : Enum {
    public int value__;
    public static CounterType QueueLength;
    public static CounterType LargeQueueLength;
    public static CounterType QueueLength100Ns;
    public static CounterType QueueLengthObjectTime;
    public static CounterType RawData32;
    public static CounterType RawData64;
    public static CounterType RawDataHex32;
    public static CounterType RawDataHex64;
    public static CounterType RateOfCountPerSecond32;
    public static CounterType RateOfCountPerSecond64;
    public static CounterType RawFraction32;
    public static CounterType RawFraction64;
    public static CounterType RawBase32;
    public static CounterType RawBase64;
    public static CounterType SampleFraction;
    public static CounterType SampleCounter;
    public static CounterType SampleBase;
    public static CounterType AverageTimer32;
    public static CounterType AverageBase;
    public static CounterType AverageCount64;
    public static CounterType PercentageActive;
    public static CounterType PercentageNotActive;
    public static CounterType PercentageActive100Ns;
    public static CounterType PercentageNotActive100Ns;
    public static CounterType ElapsedTime;
    public static CounterType MultiTimerPercentageActive;
    public static CounterType MultiTimerPercentageNotActive;
    public static CounterType MultiTimerPercentageActive100Ns;
    public static CounterType MultiTimerPercentageNotActive100Ns;
    public static CounterType MultiTimerBase;
    public static CounterType Delta32;
    public static CounterType Delta64;
    public static CounterType ObjectSpecificTimer;
    public static CounterType PrecisionSystemTimer;
    public static CounterType PrecisionTimer100Ns;
    public static CounterType PrecisionObjectSpecificTimer;
}
public enum System.Diagnostics.TraceLogRetentionOption : Enum {
    public int value__;
    public static TraceLogRetentionOption SingleFileUnboundedSize;
    public static TraceLogRetentionOption SingleFileBoundedSize;
    public static TraceLogRetentionOption UnlimitedSequentialFiles;
    public static TraceLogRetentionOption LimitedSequentialFiles;
    public static TraceLogRetentionOption LimitedCircularFiles;
}
public class System.Diagnostics.UnescapedXmlDiagnosticData : object {
    public string UnescapedXml { get; public set; }
    public UnescapedXmlDiagnosticData(string xmlPayload);
    public string get_UnescapedXml();
    public void set_UnescapedXml(string value);
    public virtual string ToString();
}
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    public ExpressionType get_Operation();
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
[DebuggerDisplayAttribute("{DebugView}")]
[DebuggerTypeProxyAttribute("System.Dynamic.BindingRestrictions/BindingRestrictionsProxy")]
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    private static BindingRestrictions();
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public Expression ToExpression();
}
public class System.Dynamic.CallInfo : object {
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, String[] argNames);
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    public int get_ArgumentCount();
    public ReadOnlyCollection`1<string> get_ArgumentNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    public Type Type { get; }
    public bool Explicit { get; }
    public Type ReturnType { get; }
    protected ConvertBinder(Type type, bool explicit);
    public Type get_Type();
    public bool get_Explicit();
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public sealed virtual Type get_ReturnType();
}
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    public string Name { get; }
    public bool IgnoreCase { get; }
    public Type ReturnType { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    public string get_Name();
    public bool get_IgnoreCase();
    public sealed virtual Type get_ReturnType();
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
public class System.Dynamic.DynamicMetaObject : object {
    public static DynamicMetaObject[] EmptyMetaObjects;
    public Expression Expression { get; }
    public BindingRestrictions Restrictions { get; }
    public object Value { get; }
    public bool HasValue { get; }
    public Type RuntimeType { get; }
    public Type LimitType { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    private static DynamicMetaObject();
    public Expression get_Expression();
    public BindingRestrictions get_Restrictions();
    public object get_Value();
    public bool get_HasValue();
    public Type get_RuntimeType();
    public Type get_LimitType();
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public static DynamicMetaObject Create(object value, Expression expression);
}
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    private static DynamicMetaObjectBinder();
    public virtual Type get_ReturnType();
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
}
public class System.Dynamic.DynamicObject : object {
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public class System.Dynamic.ExpandoObject : object {
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private static ExpandoObject();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    protected InvokeBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    public CallInfo CallInfo { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    public ExpressionType get_Operation();
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
public class System.Func`10 : MulticastDelegate {
    public Func`10(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`11 : MulticastDelegate {
    public Func`11(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`12 : MulticastDelegate {
    public Func`12(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`13 : MulticastDelegate {
    public Func`13(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`14 : MulticastDelegate {
    public Func`14(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`15 : MulticastDelegate {
    public Func`15(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`16 : MulticastDelegate {
    public Func`16(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`17 : MulticastDelegate {
    public Func`17(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability None;
    public static HandleInheritability Inheritable;
}
public class System.IO.MemoryMappedFiles.MemoryMappedFile : object {
    public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }
    public static MemoryMappedFile OpenExisting(string mapName);
    public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights);
    [SecurityCriticalAttribute]
public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability);
    public static MemoryMappedFile CreateFromFile(string path);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName);
    public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity);
    [SecurityCriticalAttribute]
public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access);
    [SecurityCriticalAttribute]
public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, bool leaveOpen);
    public static MemoryMappedFile CreateNew(string mapName, long capacity);
    public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access);
    [SecurityCriticalAttribute]
public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability);
    public static MemoryMappedFile CreateOrOpen(string mapName, long capacity);
    public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access);
    [SecurityCriticalAttribute]
public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability);
    public MemoryMappedViewStream CreateViewStream();
    public MemoryMappedViewStream CreateViewStream(long offset, long size);
    [SecurityCriticalAttribute]
public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access);
    public MemoryMappedViewAccessor CreateViewAccessor();
    public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size);
    [SecurityCriticalAttribute]
public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public SafeMemoryMappedFileHandle get_SafeMemoryMappedFileHandle();
    [SecurityCriticalAttribute]
public MemoryMappedFileSecurity GetAccessControl();
    [SecurityCriticalAttribute]
public void SetAccessControl(MemoryMappedFileSecurity memoryMappedFileSecurity);
}
public enum System.IO.MemoryMappedFiles.MemoryMappedFileAccess : Enum {
    public int value__;
    public static MemoryMappedFileAccess ReadWrite;
    public static MemoryMappedFileAccess Read;
    public static MemoryMappedFileAccess Write;
    public static MemoryMappedFileAccess CopyOnWrite;
    public static MemoryMappedFileAccess ReadExecute;
    public static MemoryMappedFileAccess ReadWriteExecute;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileOptions : Enum {
    public int value__;
    public static MemoryMappedFileOptions None;
    public static MemoryMappedFileOptions DelayAllocatePages;
}
[FlagsAttribute]
public enum System.IO.MemoryMappedFiles.MemoryMappedFileRights : Enum {
    public int value__;
    public static MemoryMappedFileRights CopyOnWrite;
    public static MemoryMappedFileRights Write;
    public static MemoryMappedFileRights Read;
    public static MemoryMappedFileRights Execute;
    public static MemoryMappedFileRights Delete;
    public static MemoryMappedFileRights ReadPermissions;
    public static MemoryMappedFileRights ChangePermissions;
    public static MemoryMappedFileRights TakeOwnership;
    public static MemoryMappedFileRights ReadWrite;
    public static MemoryMappedFileRights ReadExecute;
    public static MemoryMappedFileRights ReadWriteExecute;
    public static MemoryMappedFileRights FullControl;
    public static MemoryMappedFileRights AccessSystemSecurity;
}
public class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity : ObjectSecurity`1<MemoryMappedFileRights> {
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor : UnmanagedMemoryAccessor {
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    [SecurityCriticalAttribute]
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public void Flush();
}
public class System.IO.MemoryMappedFiles.MemoryMappedViewStream : UnmanagedMemoryStream {
    public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
    [SecurityCriticalAttribute]
public SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle();
    public virtual void SetLength(long value);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public virtual void Flush();
}
public class System.IO.Pipes.AnonymousPipeClientStream : PipeStream {
    public PipeTransmissionMode TransmissionMode { get; }
    unknown PipeTransmissionMode ReadMode {public set; }
    [SecuritySafeCriticalAttribute]
public AnonymousPipeClientStream(string pipeHandleAsString);
    [SecurityCriticalAttribute]
public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString);
    [SecurityCriticalAttribute]
public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle);
    protected virtual void Finalize();
    [SecurityCriticalAttribute]
public virtual PipeTransmissionMode get_TransmissionMode();
    [SecurityCriticalAttribute]
public virtual void set_ReadMode(PipeTransmissionMode value);
}
public class System.IO.Pipes.AnonymousPipeServerStream : PipeStream {
    public SafePipeHandle ClientSafePipeHandle { get; }
    public PipeTransmissionMode TransmissionMode { get; }
    unknown PipeTransmissionMode ReadMode {public set; }
    [SecuritySafeCriticalAttribute]
public AnonymousPipeServerStream(PipeDirection direction);
    [SecuritySafeCriticalAttribute]
public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability);
    [SecuritySafeCriticalAttribute]
public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize);
    [SecuritySafeCriticalAttribute]
public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity);
    [SecuritySafeCriticalAttribute]
public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle);
    protected virtual void Finalize();
    [SecurityCriticalAttribute]
public string GetClientHandleAsString();
    [SecurityCriticalAttribute]
public SafePipeHandle get_ClientSafePipeHandle();
    [SecurityCriticalAttribute]
public void DisposeLocalCopyOfClientHandle();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public virtual PipeTransmissionMode get_TransmissionMode();
    [SecurityCriticalAttribute]
public virtual void set_ReadMode(PipeTransmissionMode value);
}
public class System.IO.Pipes.NamedPipeClientStream : PipeStream {
    public int NumberOfServerInstances { get; }
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string pipeName);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability);
    [SecuritySafeCriticalAttribute]
public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    protected virtual void Finalize();
    public void Connect();
    [SecurityCriticalAttribute]
public void Connect(int timeout);
    [SecurityCriticalAttribute]
public int get_NumberOfServerInstances();
    [SecurityCriticalAttribute]
protected internal virtual void CheckPipePropertyOperations();
}
public class System.IO.Pipes.NamedPipeServerStream : PipeStream {
    public static int MaxAllowedServerInstances;
    [SecurityCriticalAttribute]
private static NamedPipeServerStream();
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights);
    [SecuritySafeCriticalAttribute]
public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
    protected virtual void Finalize();
    [SecurityCriticalAttribute]
public void WaitForConnection();
    [SecurityCriticalAttribute]
public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state);
    [SecurityCriticalAttribute]
public void EndWaitForConnection(IAsyncResult asyncResult);
    [SecurityCriticalAttribute]
public void Disconnect();
    [SecurityCriticalAttribute]
public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker);
    [SecurityCriticalAttribute]
public string GetImpersonationUserName();
}
[FlagsAttribute]
public enum System.IO.Pipes.PipeAccessRights : Enum {
    public int value__;
    public static PipeAccessRights ReadData;
    public static PipeAccessRights WriteData;
    public static PipeAccessRights ReadAttributes;
    public static PipeAccessRights WriteAttributes;
    public static PipeAccessRights ReadExtendedAttributes;
    public static PipeAccessRights WriteExtendedAttributes;
    public static PipeAccessRights CreateNewInstance;
    public static PipeAccessRights Delete;
    public static PipeAccessRights ReadPermissions;
    public static PipeAccessRights ChangePermissions;
    public static PipeAccessRights TakeOwnership;
    public static PipeAccessRights Synchronize;
    public static PipeAccessRights FullControl;
    public static PipeAccessRights Read;
    public static PipeAccessRights Write;
    public static PipeAccessRights ReadWrite;
    public static PipeAccessRights AccessSystemSecurity;
}
public class System.IO.Pipes.PipeAccessRule : AccessRule {
    public PipeAccessRights PipeAccessRights { get; }
    public PipeAccessRule(string identity, PipeAccessRights rights, AccessControlType type);
    public PipeAccessRule(IdentityReference identity, PipeAccessRights rights, AccessControlType type);
    public PipeAccessRights get_PipeAccessRights();
}
public class System.IO.Pipes.PipeAuditRule : AuditRule {
    public PipeAccessRights PipeAccessRights { get; }
    public PipeAuditRule(IdentityReference identity, PipeAccessRights rights, AuditFlags flags);
    public PipeAuditRule(string identity, PipeAccessRights rights, AuditFlags flags);
    public PipeAccessRights get_PipeAccessRights();
}
public enum System.IO.Pipes.PipeDirection : Enum {
    public int value__;
    public static PipeDirection In;
    public static PipeDirection Out;
    public static PipeDirection InOut;
}
[FlagsAttribute]
public enum System.IO.Pipes.PipeOptions : Enum {
    public int value__;
    public static PipeOptions None;
    public static PipeOptions WriteThrough;
    public static PipeOptions Asynchronous;
}
public class System.IO.Pipes.PipeSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public void AddAccessRule(PipeAccessRule rule);
    public void SetAccessRule(PipeAccessRule rule);
    public void ResetAccessRule(PipeAccessRule rule);
    public bool RemoveAccessRule(PipeAccessRule rule);
    public void RemoveAccessRuleSpecific(PipeAccessRule rule);
    public void AddAuditRule(PipeAuditRule rule);
    public void SetAuditRule(PipeAuditRule rule);
    public bool RemoveAuditRule(PipeAuditRule rule);
    public void RemoveAuditRuleAll(PipeAuditRule rule);
    public void RemoveAuditRuleSpecific(PipeAuditRule rule);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    [SecurityCriticalAttribute]
protected internal void Persist(SafeHandle handle);
    [SecurityCriticalAttribute]
protected internal void Persist(string name);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public abstract class System.IO.Pipes.PipeStream : Stream {
    public bool IsConnected { get; protected set; }
    public bool IsAsync { get; }
    public bool IsMessageComplete { get; }
    public PipeTransmissionMode TransmissionMode { get; }
    public int InBufferSize { get; }
    public int OutBufferSize { get; }
    public PipeTransmissionMode ReadMode { get; public set; }
    public SafePipeHandle SafePipeHandle { get; }
    protected bool IsHandleExposed { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [SecurityCriticalAttribute]
private static PipeStream();
    protected PipeStream(PipeDirection direction, int bufferSize);
    protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize);
    [SecurityCriticalAttribute]
protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync);
    [SecurityCriticalAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    [SecurityCriticalAttribute]
public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    [SecurityCriticalAttribute]
public virtual int EndRead(IAsyncResult asyncResult);
    [SecurityCriticalAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
    [SecurityCriticalAttribute]
public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    [SecurityCriticalAttribute]
public virtual void EndWrite(IAsyncResult asyncResult);
    [SecurityCriticalAttribute]
public virtual int ReadByte();
    [SecurityCriticalAttribute]
public virtual void WriteByte(byte value);
    [SecurityCriticalAttribute]
public virtual void Flush();
    [SecurityCriticalAttribute]
public void WaitForPipeDrain();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public bool get_IsConnected();
    protected void set_IsConnected(bool value);
    public bool get_IsAsync();
    [SecurityCriticalAttribute]
public bool get_IsMessageComplete();
    [SecurityCriticalAttribute]
public virtual PipeTransmissionMode get_TransmissionMode();
    [SecurityCriticalAttribute]
public virtual int get_InBufferSize();
    [SecurityCriticalAttribute]
public virtual int get_OutBufferSize();
    [SecurityCriticalAttribute]
public virtual PipeTransmissionMode get_ReadMode();
    [SecurityCriticalAttribute]
public virtual void set_ReadMode(PipeTransmissionMode value);
    [SecurityCriticalAttribute]
public PipeSecurity GetAccessControl();
    [SecurityCriticalAttribute]
public void SetAccessControl(PipeSecurity pipeSecurity);
    [SecurityCriticalAttribute]
public SafePipeHandle get_SafePipeHandle();
    protected bool get_IsHandleExposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    [SecurityCriticalAttribute]
protected internal virtual void CheckPipePropertyOperations();
    [SecurityCriticalAttribute]
protected internal void CheckReadOperations();
    [SecurityCriticalAttribute]
protected internal void CheckWriteOperations();
}
public class System.IO.Pipes.PipeStreamImpersonationWorker : MulticastDelegate {
    public PipeStreamImpersonationWorker(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Pipes.PipeTransmissionMode : Enum {
    public int value__;
    public static PipeTransmissionMode Byte;
    public static PipeTransmissionMode Message;
}
[ExtensionAttribute]
public static class System.Linq.Enumerable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cast(IEnumerable source);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index);
    public static IEnumerable`1<int> Range(int start, int count);
    public static IEnumerable`1<TResult> Repeat(TResult element, int count);
    public static IEnumerable`1<TResult> Empty();
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Min(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
}
public abstract class System.Linq.EnumerableExecutor : object {
}
public class System.Linq.EnumerableExecutor`1 : EnumerableExecutor {
    public EnumerableExecutor`1(Expression expression);
}
public abstract class System.Linq.EnumerableQuery : object {
    internal Expression Expression { get; }
    internal abstract virtual Expression get_Expression();
}
public class System.Linq.EnumerableQuery`1 : EnumerableQuery {
    private IQueryProvider System.Linq.IQueryable.Provider { get; }
    internal Expression Expression { get; }
    private Expression System.Linq.IQueryable.Expression { get; }
    private Type System.Linq.IQueryable.ElementType { get; }
    public EnumerableQuery`1(IEnumerable`1<T> enumerable);
    public EnumerableQuery`1(Expression expression);
    private sealed virtual override IQueryProvider System.Linq.IQueryable.get_Provider();
    internal virtual Expression get_Expression();
    private sealed virtual override Expression System.Linq.IQueryable.get_Expression();
    private sealed virtual override Type System.Linq.IQueryable.get_ElementType();
    private sealed virtual override IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override IQueryable`1<S> System.Linq.IQueryProvider.CreateQuery(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override S System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private IEnumerator`1<T> GetEnumerator();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BinaryExpressionProxy")]
public class System.Linq.Expressions.BinaryExpression : Expression {
    public bool CanReduce { get; }
    public Expression Right { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public virtual bool get_CanReduce();
    public Expression get_Right();
    public Expression get_Left();
    public MethodInfo get_Method();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
    public virtual Expression Reduce();
    public LambdaExpression get_Conversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BlockExpressionProxy")]
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public Expression Result { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    public Expression get_Result();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/CatchBlockProxy")]
public class System.Linq.Expressions.CatchBlock : object {
    public ParameterExpression Variable { get; }
    public Type Test { get; }
    public Expression Body { get; }
    public Expression Filter { get; }
    public ParameterExpression get_Variable();
    public Type get_Test();
    public Expression get_Body();
    public Expression get_Filter();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConditionalExpressionProxy")]
public class System.Linq.Expressions.ConditionalExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Test { get; }
    public Expression IfTrue { get; }
    public Expression IfFalse { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public Expression get_Test();
    public Expression get_IfTrue();
    public Expression get_IfFalse();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConstantExpressionProxy")]
public class System.Linq.Expressions.ConstantExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public object Value { get; }
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DebugInfoExpressionProxy")]
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public SymbolDocumentInfo Document { get; }
    public bool IsClear { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    public SymbolDocumentInfo get_Document();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DefaultExpressionProxy")]
public class System.Linq.Expressions.DefaultExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DynamicExpressionProxy")]
public class System.Linq.Expressions.DynamicExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public CallSiteBinder get_Binder();
    public Type get_DelegateType();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
}
public abstract class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
public class System.Linq.Expressions.ElementInit : object {
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public MethodInfo get_AddMethod();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
public abstract class System.Linq.Expressions.Expression : object {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    [ObsoleteAttribute("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    private static Expression();
    public static BinaryExpression Assign(Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public virtual string ToString();
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label();
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Type GetFuncType(Type[] typeArgs);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static Type GetActionType(Type[] typeArgs);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static Type GetDelegateType(Type[] typeArgs);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(Type type);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static ParameterExpression Variable(Type type, string name);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ArrayLength(Expression array);
    public static UnaryExpression Quote(Expression expression);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    public TDelegate Compile();
    public TDelegate Compile(DebugInfoGenerator debugInfoGenerator);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType ArrayLength;
    public static ExpressionType ArrayIndex;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType Divide;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Invoke;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType UnaryPlus;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayInit;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType Or;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType Power;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractChecked;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeIs;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Dynamic;
    public static ExpressionType Default;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Label;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Loop;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType Unbox;
    public static ExpressionType AddAssign;
    public static ExpressionType AndAssign;
    public static ExpressionType DivideAssign;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType ModuloAssign;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType OrAssign;
    public static ExpressionType PowerAssign;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType SubtractAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType TypeEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType IsTrue;
    public static ExpressionType IsFalse;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
    public T VisitAndConvert(T node, string callerName);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/GotoExpressionProxy")]
public class System.Linq.Expressions.GotoExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Value { get; }
    public LabelTarget Target { get; }
    public GotoExpressionKind Kind { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Value();
    public LabelTarget get_Target();
    public GotoExpressionKind get_Kind();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/IndexExpressionProxy")]
public class System.Linq.Expressions.IndexExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Object { get; }
    public PropertyInfo Indexer { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public Expression get_Object();
    public PropertyInfo get_Indexer();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/InvocationExpressionProxy")]
public class System.Linq.Expressions.InvocationExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Expression();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LabelExpressionProxy")]
public class System.Linq.Expressions.LabelExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Expression DefaultValue { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public Expression get_DefaultValue();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    public string Name { get; }
    public Type Type { get; }
    public string get_Name();
    public Type get_Type();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LambdaExpressionProxy")]
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public string Name { get; }
    public Expression Body { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public string get_Name();
    public Expression get_Body();
    public Type get_ReturnType();
    public bool get_TailCall();
    public Delegate Compile();
    public Delegate Compile(DebugInfoGenerator debugInfoGenerator);
    public void CompileToMethod(MethodBuilder method);
    public void CompileToMethod(MethodBuilder method, DebugInfoGenerator debugInfoGenerator);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ListInitExpressionProxy")]
public class System.Linq.Expressions.ListInitExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public NewExpression get_NewExpression();
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LoopExpressionProxy")]
public class System.Linq.Expressions.LoopExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Body();
    public LabelTarget get_BreakLabel();
    public LabelTarget get_ContinueLabel();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    public Expression Expression { get; }
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("Do not use this constructor. It will be removed in future releases.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    public MemberBindingType get_BindingType();
    public MemberInfo get_Member();
    public virtual string ToString();
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType MemberBinding;
    public static MemberBindingType ListBinding;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberExpressionProxy")]
public class System.Linq.Expressions.MemberExpression : Expression {
    public MemberInfo Member { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    public MemberInfo get_Member();
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberInitExpressionProxy")]
public class System.Linq.Expressions.MemberInitExpression : Expression {
    public Type Type { get; }
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public sealed virtual ExpressionType get_NodeType();
    public NewExpression get_NewExpression();
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MethodCallExpressionProxy")]
public class System.Linq.Expressions.MethodCallExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public Expression Object { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public MethodInfo get_Method();
    public Expression get_Object();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewArrayExpressionProxy")]
public class System.Linq.Expressions.NewArrayExpression : Expression {
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public sealed virtual Type get_Type();
    public ReadOnlyCollection`1<Expression> get_Expressions();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewExpressionProxy")]
public class System.Linq.Expressions.NewExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public ReadOnlyCollection`1<MemberInfo> get_Members();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ParameterExpressionProxy")]
public class System.Linq.Expressions.ParameterExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public string Name { get; }
    public bool IsByRef { get; }
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public string get_Name();
    public bool get_IsByRef();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/RuntimeVariablesExpressionProxy")]
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchCaseProxy")]
public class System.Linq.Expressions.SwitchCase : object {
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression Body { get; }
    public ReadOnlyCollection`1<Expression> get_TestValues();
    public Expression get_Body();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchExpressionProxy")]
public class System.Linq.Expressions.SwitchExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public Expression DefaultBody { get; }
    public MethodInfo Comparison { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_SwitchValue();
    public ReadOnlyCollection`1<SwitchCase> get_Cases();
    public Expression get_DefaultBody();
    public MethodInfo get_Comparison();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TryExpressionProxy")]
public class System.Linq.Expressions.TryExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public Expression Finally { get; }
    public Expression Fault { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Body();
    public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    public Expression get_Finally();
    public Expression get_Fault();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TypeBinaryExpressionProxy")]
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public Type TypeOperand { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Expression();
    public Type get_TypeOperand();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/UnaryExpressionProxy")]
public class System.Linq.Expressions.UnaryExpression : Expression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public MethodInfo Method { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public bool CanReduce { get; }
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public MethodInfo get_Method();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    public UnaryExpression Update(Expression operand);
}
public interface System.Linq.IGrouping`2 {
    public TKey Key { get; }
    public abstract virtual TKey get_Key();
}
[DefaultMemberAttribute("Item")]
public interface System.Linq.ILookup`2 {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TElement> get_Item(TKey key);
    public abstract virtual bool Contains(TKey key);
}
public interface System.Linq.IOrderedEnumerable`1 {
    public abstract virtual IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
public interface System.Linq.IQueryable {
    public Expression Expression { get; }
    public Type ElementType { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Expression get_Expression();
    public abstract virtual Type get_ElementType();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
[DefaultMemberAttribute("Item")]
public class System.Linq.Lookup`2 : object {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    public IEnumerable`1<TResult> ApplyResultSelector(Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
[ExtensionAttribute]
public static class System.Linq.ParallelEnumerable : object {
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsOrdered(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsParallel(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions);
    public static ParallelQuery`1<int> Range(int start, int count);
    public static ParallelQuery`1<TResult> Repeat(TResult element, int count);
    public static ParallelQuery`1<TResult> Empty();
    [ExtensionAttribute]
public static void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> OfType(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Cast(ParallelQuery source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static TSource ElementAt(ParallelQuery`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index);
}
public enum System.Linq.ParallelExecutionMode : Enum {
    public int value__;
    public static ParallelExecutionMode Default;
    public static ParallelExecutionMode ForceParallelism;
}
public enum System.Linq.ParallelMergeOptions : Enum {
    public int value__;
    public static ParallelMergeOptions Default;
    public static ParallelMergeOptions NotBuffered;
    public static ParallelMergeOptions AutoBuffered;
    public static ParallelMergeOptions FullyBuffered;
}
public class System.Linq.ParallelQuery : object {
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.ParallelQuery`1 : ParallelQuery {
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
[ExtensionAttribute]
public static class System.Linq.Queryable : object {
    [ExtensionAttribute]
public static IQueryable`1<TElement> AsQueryable(IEnumerable`1<TElement> source);
    [ExtensionAttribute]
public static IQueryable AsQueryable(IEnumerable source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TResult> OfType(IQueryable source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Cast(IQueryable source);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, TResult>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TResult>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, IEnumerable`1<TCollection>>> collectionSelector, Expression`1<Func`3<TSource, TCollection, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Join(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, TInner, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupJoin(IQueryable`1<TOuter> outer, IEnumerable`1<TInner> inner, Expression`1<Func`2<TOuter, TKey>> outerKeySelector, Expression`1<Func`2<TInner, TKey>> innerKeySelector, Expression`1<Func`3<TOuter, IEnumerable`1<TInner>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByDescending(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByDescending(IOrderedQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Take(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> TakeWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Skip(IQueryable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> SkipWhile(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, int, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TSource>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<IGrouping`2<TKey, TElement>> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`3<TKey, IEnumerable`1<TSource>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TResult> GroupBy(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TKey>> keySelector, Expression`1<Func`2<TSource, TElement>> elementSelector, Expression`1<Func`3<TKey, IEnumerable`1<TElement>, TResult>> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Distinct(IQueryable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Concat(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Zip(IQueryable`1<TFirst> source1, IEnumerable`1<TSecond> source2, Expression`1<Func`3<TFirst, TSecond, TResult>> resultSelector);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Union(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Intersect(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Except(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource ElementAt(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IQueryable`1<TSource> source, int index);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static IQueryable`1<TSource> DefaultIfEmpty(IQueryable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item);
    [ExtensionAttribute]
public static bool Contains(IQueryable`1<TSource> source, TSource item, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Reverse(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2);
    [ExtensionAttribute]
public static bool SequenceEqual(IQueryable`1<TSource> source1, IEnumerable`1<TSource> source2, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static bool All(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate);
    [ExtensionAttribute]
public static TSource Min(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Min(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static TSource Max(IQueryable`1<TSource> source);
    [ExtensionAttribute]
public static TResult Max(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> selector);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static long Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static float Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static double Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static decimal Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(IQueryable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, int>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<int>>> selector);
    [ExtensionAttribute]
public static float Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, float>> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<float>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, long>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<long>>> selector);
    [ExtensionAttribute]
public static double Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, double>> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<double>>> selector);
    [ExtensionAttribute]
public static decimal Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, decimal>> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, Nullable`1<decimal>>> selector);
    [ExtensionAttribute]
public static TSource Aggregate(IQueryable`1<TSource> source, Expression`1<Func`3<TSource, TSource, TSource>> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func);
    [ExtensionAttribute]
public static TResult Aggregate(IQueryable`1<TSource> source, TAccumulate seed, Expression`1<Func`3<TAccumulate, TSource, TAccumulate>> func, Expression`1<Func`2<TAccumulate, TResult>> selector);
}
public class System.Management.Instrumentation.InstanceNotFoundException : InstrumentationException {
    public InstanceNotFoundException(string message);
    public InstanceNotFoundException(string message, Exception innerException);
    protected InstanceNotFoundException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Instrumentation.InstrumentationBaseException : Exception {
    public InstrumentationBaseException(string message);
    public InstrumentationBaseException(string message, Exception innerException);
    protected InstrumentationBaseException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Instrumentation.InstrumentationException : InstrumentationBaseException {
    public InstrumentationException(string message);
    public InstrumentationException(Exception innerException);
    public InstrumentationException(string message, Exception innerException);
    protected InstrumentationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementBindAttribute : ManagementNewInstanceAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementCommitAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementConfigurationAttribute : ManagementMemberAttribute {
    public ManagementConfigurationType Mode { get; public set; }
    public Type Schema { get; public set; }
    public ManagementConfigurationType get_Mode();
    public void set_Mode(ManagementConfigurationType value);
    public Type get_Schema();
    public void set_Schema(Type value);
}
public enum System.Management.Instrumentation.ManagementConfigurationType : Enum {
    public int value__;
    public static ManagementConfigurationType Apply;
    public static ManagementConfigurationType OnCommit;
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementCreateAttribute : ManagementNewInstanceAttribute {
}
[AttributeUsageAttribute("4")]
public class System.Management.Instrumentation.ManagementEntityAttribute : Attribute {
    public string Name { get; public set; }
    public bool External { get; public set; }
    public bool Singleton { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_External();
    public void set_External(bool value);
    public bool get_Singleton();
    public void set_Singleton(bool value);
}
[AttributeUsageAttribute("96")]
public class System.Management.Instrumentation.ManagementEnumeratorAttribute : ManagementNewInstanceAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
public enum System.Management.Instrumentation.ManagementHostingModel : Enum {
    public int value__;
    public static ManagementHostingModel Decoupled;
    public static ManagementHostingModel NetworkService;
    public static ManagementHostingModel LocalService;
    public static ManagementHostingModel LocalSystem;
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementKeyAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("32767")]
public abstract class System.Management.Instrumentation.ManagementMemberAttribute : Attribute {
    public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("2048")]
public class System.Management.Instrumentation.ManagementNameAttribute : Attribute {
    public string Name { get; }
    public ManagementNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("96")]
public abstract class System.Management.Instrumentation.ManagementNewInstanceAttribute : ManagementMemberAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Instrumentation.ManagementProbeAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("2432")]
public class System.Management.Instrumentation.ManagementReferenceAttribute : Attribute {
    public string Type { get; public set; }
    public string get_Type();
    public void set_Type(string value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementRemoveAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("64")]
public class System.Management.Instrumentation.ManagementTaskAttribute : ManagementMemberAttribute {
    public Type Schema { get; public set; }
    public Type get_Schema();
    public void set_Schema(Type value);
}
[AttributeUsageAttribute("1")]
public class System.Management.Instrumentation.WmiConfigurationAttribute : Attribute {
    public string SecurityRestriction { get; public set; }
    public string NamespaceSecurity { get; public set; }
    public bool IdentifyLevel { get; public set; }
    public ManagementHostingModel HostingModel { get; public set; }
    public string HostingGroup { get; public set; }
    public string Scope { get; }
    public WmiConfigurationAttribute(string scope);
    public string get_SecurityRestriction();
    public void set_SecurityRestriction(string value);
    public string get_NamespaceSecurity();
    public void set_NamespaceSecurity(string value);
    public bool get_IdentifyLevel();
    public void set_IdentifyLevel(bool value);
    public ManagementHostingModel get_HostingModel();
    public void set_HostingModel(ManagementHostingModel value);
    public string get_HostingGroup();
    public void set_HostingGroup(string value);
    public string get_Scope();
}
public class System.Runtime.CompilerServices.CallSite : object {
    public CallSiteBinder Binder { get; }
    public CallSiteBinder get_Binder();
    public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    public T Update { get; }
    public T get_Update();
    public static CallSite`1<T> Create(CallSiteBinder binder);
}
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    public static LabelTarget UpdateLabel { get; }
    private static CallSiteBinder();
    public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    private static CallSiteHelpers();
    public static bool IsInternalFrame(MethodBase mb);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static class System.Runtime.CompilerServices.CallSiteOps : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static CallSite`1<T> CreateMatchmaker(CallSite`1<T> site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool SetNotMatched(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool GetMatch(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void ClearMatch(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void AddRule(CallSite`1<T> site, T rule);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateRules(CallSite`1<T> this, int matched);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static T[] GetRules(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static RuleCache`1<T> GetRuleCache(CallSite`1<T> site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void MoveRule(RuleCache`1<T> cache, T rule, int i);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetCachedRules(RuleCache`1<T> cache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static T Bind(CallSiteBinder binder, CallSite`1<T> site, Object[] args);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.Closure : object {
    public Object[] Constants;
    public Object[] Locals;
    public Closure(Object[] constants, Object[] locals);
}
public abstract class System.Runtime.CompilerServices.DebugInfoGenerator : object {
    public static DebugInfoGenerator CreatePdbGenerator();
    public abstract virtual void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);
}
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[ObsoleteAttribute("do not use this type", "True")]
public class System.Runtime.CompilerServices.ExecutionScope : object {
    public ExecutionScope Parent;
    public Object[] Globals;
    public Object[] Locals;
    public Object[] CreateHoistedLocals();
    public Delegate CreateDelegate(int indexLambda, Object[] locals);
    public Expression IsolateExpression(Expression expression, Object[] locals);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[DefaultMemberAttribute("Item")]
public class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyCollectionBuilder`1(int capacity);
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    private static ReadOnlyCollectionBuilder`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Reverse();
    public void Reverse(int index, int count);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static class System.Runtime.CompilerServices.RuntimeOps : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, Object& value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool ExpandoCheckVersion(ExpandoObject expando, object version);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static Expression Quote(Expression expression, object hoistedLocals, Object[] locals);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables MergeRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, Int32[] indexes);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables CreateRuntimeVariables(Object[] data, Int64[] indexes);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables CreateRuntimeVariables();
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[SecuritySafeCriticalAttribute]
public class System.Runtime.InteropServices.ComAwareEventInfo : EventInfo {
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ComAwareEventInfo(Type type, string eventName);
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual EventAttributes get_Attributes();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual Type get_DeclaringType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
}
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [SecurityCriticalAttribute]
public virtual Byte[] get_Key();
    [SecurityCriticalAttribute]
public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    [SecurityCriticalAttribute]
public virtual void set_KeySize(int value);
    [SecurityCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor();
    [SecurityCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    [SecurityCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor();
    [SecurityCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
public virtual void GenerateKey();
    [SecurityCriticalAttribute]
public virtual void GenerateIV();
}
public class System.Security.Cryptography.AesManaged : Aes {
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    protected virtual void Dispose(bool disposing);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
}
public class System.Security.Cryptography.CngAlgorithm : object {
    public string Algorithm { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
public class System.Security.Cryptography.CngKey : object {
    public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngAlgorithm Algorithm { get; }
    public CngExportPolicies ExportPolicy { get; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; private set; }
    public bool IsMachineKey { get; }
    public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public string UniqueName { get; }
    public CngUIPolicy UIPolicy { get; }
    [SecuritySafeCriticalAttribute]
public CngAlgorithmGroup get_AlgorithmGroup();
    [SecuritySafeCriticalAttribute]
public CngAlgorithm get_Algorithm();
    [SecuritySafeCriticalAttribute]
public CngExportPolicies get_ExportPolicy();
    [SecurityCriticalAttribute]
public SafeNCryptKeyHandle get_Handle();
    [SecuritySafeCriticalAttribute]
public bool get_IsEphemeral();
    [SecurityCriticalAttribute]
private void set_IsEphemeral(bool value);
    [SecuritySafeCriticalAttribute]
public bool get_IsMachineKey();
    [SecuritySafeCriticalAttribute]
public string get_KeyName();
    [SecuritySafeCriticalAttribute]
public int get_KeySize();
    [SecuritySafeCriticalAttribute]
public CngKeyUsages get_KeyUsage();
    [SecuritySafeCriticalAttribute]
public IntPtr get_ParentWindowHandle();
    [SecuritySafeCriticalAttribute]
public void set_ParentWindowHandle(IntPtr value);
    [SecuritySafeCriticalAttribute]
public CngProvider get_Provider();
    [SecurityCriticalAttribute]
public SafeNCryptProviderHandle get_ProviderHandle();
    [SecuritySafeCriticalAttribute]
public string get_UniqueName();
    [SecuritySafeCriticalAttribute]
public CngUIPolicy get_UIPolicy();
    public static CngKey Create(CngAlgorithm algorithm);
    public static CngKey Create(CngAlgorithm algorithm, string keyName);
    [SecuritySafeCriticalAttribute]
public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    [SecuritySafeCriticalAttribute]
public void Delete();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    public static bool Exists(string keyName);
    public static bool Exists(string keyName, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public Byte[] Export(CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public CngProperty GetProperty(string name, CngPropertyOptions options);
    [SecuritySafeCriticalAttribute]
public bool HasProperty(string name, CngPropertyOptions options);
    public static CngKey Open(string keyName);
    public static CngKey Open(string keyName, CngProvider provider);
    [SecuritySafeCriticalAttribute]
public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    [SecurityCriticalAttribute]
public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    [SecuritySafeCriticalAttribute]
public void SetProperty(CngProperty property);
}
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngPropertyCollection Parameters { get; }
    public CngProvider Provider { get; public set; }
    public CngUIPolicy UIPolicy { get; public set; }
    public Nullable`1<CngExportPolicies> get_ExportPolicy();
    public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    public CngKeyCreationOptions get_KeyCreationOptions();
    public void set_KeyCreationOptions(CngKeyCreationOptions value);
    public Nullable`1<CngKeyUsages> get_KeyUsage();
    public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    public IntPtr get_ParentWindowHandle();
    [SecuritySafeCriticalAttribute]
public void set_ParentWindowHandle(IntPtr value);
    [SecuritySafeCriticalAttribute]
public CngPropertyCollection get_Parameters();
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    public CngUIPolicy get_UIPolicy();
    [SecuritySafeCriticalAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
public class System.Security.Cryptography.CngProperty : ValueType {
    private string m_name;
    private CngPropertyOptions m_propertyOptions;
    private Byte[] m_value;
    private Nullable`1<int> m_hashCode;
    public string Name { get; }
    public CngPropertyOptions Options { get; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    public string get_Name();
    public CngPropertyOptions get_Options();
    public Byte[] GetValue();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
public class System.Security.Cryptography.CngProvider : object {
    public string Provider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    public static bool op_Equality(CngProvider left, CngProvider right);
    public static bool op_Inequality(CngProvider left, CngProvider right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
public class System.Security.Cryptography.CngUIPolicy : object {
    public string CreationTitle { get; }
    public string Description { get; }
    public string FriendlyName { get; }
    public CngUIProtectionLevels ProtectionLevel { get; }
    public string UseContext { get; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    public string get_CreationTitle();
    public string get_Description();
    public string get_FriendlyName();
    public CngUIProtectionLevels get_ProtectionLevel();
    public string get_UseContext();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
public abstract class System.Security.Cryptography.ECDiffieHellman : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDiffieHellman Create();
    public static ECDiffieHellman Create(string algorithm);
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public abstract virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
}
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    public CngAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HmacKey { get; public set; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    public Byte[] Label { get; public set; }
    public Byte[] SecretAppend { get; public set; }
    public Byte[] SecretPrepend { get; public set; }
    public Byte[] Seed { get; public set; }
    public CngKey Key { get; private set; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public bool UseSecretAgreementAsHmacKey { get; }
    public ECDiffieHellmanCng(int keySize);
    [SecuritySafeCriticalAttribute]
public ECDiffieHellmanCng(CngKey key);
    private static ECDiffieHellmanCng();
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public Byte[] get_HmacKey();
    public void set_HmacKey(Byte[] value);
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    public Byte[] get_Label();
    public void set_Label(Byte[] value);
    public Byte[] get_SecretAppend();
    public void set_SecretAppend(Byte[] value);
    public Byte[] get_SecretPrepend();
    public void set_SecretPrepend(Byte[] value);
    public Byte[] get_Seed();
    public void set_Seed(Byte[] value);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public bool get_UseSecretAgreementAsHmacKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    [SecuritySafeCriticalAttribute]
public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    [SecurityCriticalAttribute]
public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    protected virtual void Dispose(bool disposing);
    public virtual void FromXmlString(string xmlString);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public virtual string ToXmlString(bool includePrivateParameters);
    public string ToXmlString(ECKeyXmlFormat format);
}
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    public CngKeyBlobFormat BlobFormat { get; }
    public CngKeyBlobFormat get_BlobFormat();
    protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    [SecuritySafeCriticalAttribute]
public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKey Import();
    public virtual string ToXmlString();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ToByteArray();
    public abstract virtual string ToXmlString();
}
public abstract class System.Security.Cryptography.ECDsa : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDsa Create();
    public static ECDsa Create(string algorithm);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; private set; }
    public ECDsaCng(int keySize);
    [SecuritySafeCriticalAttribute]
public ECDsaCng(CngKey key);
    private static ECDsaCng();
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    protected virtual void Dispose(bool disposing);
    public virtual void FromXmlString(string xmlString);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    [SecuritySafeCriticalAttribute]
public Byte[] SignData(Byte[] data, int offset, int count);
    [SecuritySafeCriticalAttribute]
public Byte[] SignData(Stream data);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] SignHash(Byte[] hash);
    public virtual string ToXmlString(bool includePrivateParameters);
    public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    [SecuritySafeCriticalAttribute]
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    [SecuritySafeCriticalAttribute]
public bool VerifyData(Stream data, Byte[] signature);
    [SecuritySafeCriticalAttribute]
public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
public class System.Security.Cryptography.ManifestSignatureInformation : object {
    public AuthenticodeSignatureInformation AuthenticodeSignature { get; }
    public ManifestKinds Manifest { get; }
    public StrongNameSignatureInformation StrongNameSignature { get; }
    public AuthenticodeSignatureInformation get_AuthenticodeSignature();
    public ManifestKinds get_Manifest();
    public StrongNameSignatureInformation get_StrongNameSignature();
    public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application);
    public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests);
    [SecuritySafeCriticalAttribute]
public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode);
}
public class System.Security.Cryptography.ManifestSignatureInformationCollection : ReadOnlyCollection`1<ManifestSignatureInformation> {
    internal ManifestSignatureInformationCollection(IList`1<ManifestSignatureInformation> signatureInformation);
}
public class System.Security.Cryptography.MD5Cng : MD5 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA1Cng : SHA1 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA256Cng : SHA256 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA384Cng : SHA384 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA512Cng : SHA512 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public enum System.Security.Cryptography.SignatureVerificationResult : Enum {
    public int value__;
    public static SignatureVerificationResult Valid;
    public static SignatureVerificationResult AssemblyIdentityMismatch;
    public static SignatureVerificationResult ContainingSignatureInvalid;
    public static SignatureVerificationResult PublicKeyTokenMismatch;
    public static SignatureVerificationResult PublisherMismatch;
    public static SignatureVerificationResult SystemError;
    public static SignatureVerificationResult InvalidSignerCertificate;
    public static SignatureVerificationResult InvalidCountersignature;
    public static SignatureVerificationResult InvalidCertificateSignature;
    public static SignatureVerificationResult InvalidTimestamp;
    public static SignatureVerificationResult BadDigest;
    public static SignatureVerificationResult BasicConstraintsNotObserved;
    public static SignatureVerificationResult UnknownTrustProvider;
    public static SignatureVerificationResult UnknownVerificationAction;
    public static SignatureVerificationResult BadSignatureFormat;
    public static SignatureVerificationResult CertificateNotExplicitlyTrusted;
    public static SignatureVerificationResult MissingSignature;
    public static SignatureVerificationResult CertificateExpired;
    public static SignatureVerificationResult InvalidTimePeriodNesting;
    public static SignatureVerificationResult InvalidCertificateRole;
    public static SignatureVerificationResult PathLengthConstraintViolated;
    public static SignatureVerificationResult UnknownCriticalExtension;
    public static SignatureVerificationResult CertificateUsageNotAllowed;
    public static SignatureVerificationResult IssuerChainingError;
    public static SignatureVerificationResult CertificateMalformed;
    public static SignatureVerificationResult UntrustedRootCertificate;
    public static SignatureVerificationResult CouldNotBuildChain;
    public static SignatureVerificationResult GenericTrustFailure;
    public static SignatureVerificationResult CertificateRevoked;
    public static SignatureVerificationResult UntrustedTestRootCertificate;
    public static SignatureVerificationResult RevocationCheckFailure;
    public static SignatureVerificationResult InvalidCertificateUsage;
    public static SignatureVerificationResult CertificateExplicitlyDistrusted;
    public static SignatureVerificationResult UntrustedCertificationAuthority;
    public static SignatureVerificationResult InvalidCertificatePolicy;
    public static SignatureVerificationResult InvalidCertificateName;
}
public class System.Security.Cryptography.StrongNameSignatureInformation : object {
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public bool IsValid { get; }
    public AsymmetricAlgorithm PublicKey { get; }
    public SignatureVerificationResult VerificationResult { get; }
    private static StrongNameSignatureInformation();
    public string get_HashAlgorithm();
    public int get_HResult();
    public bool get_IsValid();
    public AsymmetricAlgorithm get_PublicKey();
    public SignatureVerificationResult get_VerificationResult();
}
public class System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation : object {
    public string Description { get; }
    public Uri DescriptionUrl { get; }
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public X509Chain SignatureChain { get; }
    public X509Certificate2 SigningCertificate { get; }
    public TimestampInformation Timestamp { get; }
    public TrustStatus TrustStatus { get; }
    public SignatureVerificationResult VerificationResult { get; }
    public string get_Description();
    public Uri get_DescriptionUrl();
    public string get_HashAlgorithm();
    public int get_HResult();
    [SecuritySafeCriticalAttribute]
public X509Chain get_SignatureChain();
    [SecuritySafeCriticalAttribute]
public X509Certificate2 get_SigningCertificate();
    public TimestampInformation get_Timestamp();
    public TrustStatus get_TrustStatus();
    public SignatureVerificationResult get_VerificationResult();
}
public class System.Security.Cryptography.X509Certificates.TimestampInformation : object {
    public string HashAlgorithm { get; }
    public int HResult { get; }
    public bool IsValid { get; }
    public X509Chain SignatureChain { get; }
    public X509Certificate2 SigningCertificate { get; }
    public DateTime Timestamp { get; }
    public SignatureVerificationResult VerificationResult { get; }
    public string get_HashAlgorithm();
    public int get_HResult();
    public bool get_IsValid();
    [SecuritySafeCriticalAttribute]
public X509Chain get_SignatureChain();
    [SecuritySafeCriticalAttribute]
public X509Certificate2 get_SigningCertificate();
    public DateTime get_Timestamp();
    public SignatureVerificationResult get_VerificationResult();
}
public enum System.Security.Cryptography.X509Certificates.TrustStatus : Enum {
    public int value__;
    public static TrustStatus Untrusted;
    public static TrustStatus UnknownIdentity;
    public static TrustStatus KnownIdentity;
    public static TrustStatus Trusted;
}
[FlagsAttribute]
public enum System.Security.ManifestKinds : Enum {
    public int value__;
    public static ManifestKinds None;
    public static ManifestKinds Deployment;
    public static ManifestKinds Application;
    public static ManifestKinds ApplicationAndDeployment;
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
public class System.Threading.ReaderWriterLockSlim : object {
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    public sealed virtual void Dispose();
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
