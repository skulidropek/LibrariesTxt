internal class System.Runtime.DurableInstancing.DisassociateInstanceKeysExtension : object {
    internal bool AutomaticDisassociationEnabled { get; internal set; }
    internal bool get_AutomaticDisassociationEnabled();
    internal void set_AutomaticDisassociationEnabled(bool value);
}
internal interface System.Runtime.DurableInstancing.IDurableInstancingOptions {
    public abstract virtual void SetScopeName(XName scopeName);
}
public class System.Runtime.DurableInstancing.InstanceCollisionException : InstancePersistenceCommandException {
    public InstanceCollisionException(string message);
    public InstanceCollisionException(string message, Exception innerException);
    public InstanceCollisionException(XName commandName, Guid instanceId);
    public InstanceCollisionException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceCollisionException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceCollisionException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceCompleteException : InstancePersistenceCommandException {
    public InstanceCompleteException(string message);
    public InstanceCompleteException(string message, Exception innerException);
    public InstanceCompleteException(XName commandName, Guid instanceId);
    public InstanceCompleteException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceCompleteException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceCompleteException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceHandle : object {
    public bool IsValid { get; private set; }
    internal InstanceView View { get; private set; }
    internal InstanceStore Store { get; private set; }
    internal InstanceOwner Owner { get; private set; }
    internal Guid Id { get; private set; }
    internal long Version { get; private set; }
    internal InstanceHandle ConflictingHandle { get; internal set; }
    internal object ProviderObject { get; internal set; }
    internal EventTraceActivity EventTraceActivity { get; }
    internal InstanceHandle(InstanceStore store, InstanceOwner owner);
    internal InstanceHandle(InstanceStore store, InstanceOwner owner, Guid instanceId);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
internal InstanceView get_View();
    [CompilerGeneratedAttribute]
private void set_View(InstanceView value);
    [CompilerGeneratedAttribute]
internal InstanceStore get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(InstanceStore value);
    [CompilerGeneratedAttribute]
internal InstanceOwner get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(InstanceOwner value);
    internal Guid get_Id();
    private void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal long get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(long value);
    [CompilerGeneratedAttribute]
internal InstanceHandle get_ConflictingHandle();
    [CompilerGeneratedAttribute]
internal void set_ConflictingHandle(InstanceHandle value);
    internal object get_ProviderObject();
    internal void set_ProviderObject(object value);
    internal EventTraceActivity get_EventTraceActivity();
    public void Free();
    internal void BindOwnerEvent(InstancePersistenceEvent persistenceEvent);
    internal void StartPotentialBind();
    internal void BindOwner(InstanceOwner owner);
    internal void BindInstance(Guid instanceId);
    internal void Bind(long instanceVersion);
    internal AsyncWaitHandle StartReclaim(long instanceVersion);
    internal void CancelReclaim(Exception reason);
    internal bool FinishReclaim(Int64& instanceVersion);
    internal InstancePersistenceContext AcquireExecutionContext(Transaction hostTransaction, TimeSpan timeout);
    internal IAsyncResult BeginAcquireExecutionContext(Transaction hostTransaction, TimeSpan timeout, AsyncCallback callback, object state);
    internal InstancePersistenceContext EndAcquireExecutionContext(IAsyncResult result);
    internal void ReleaseExecutionContext();
    internal InstanceView Commit(InstanceView newState);
    internal void EventReady(InstancePersistenceEvent persistenceEvent);
    internal static IAsyncResult BeginWaitForEvents(InstanceHandle handle, TimeSpan timeout, AsyncCallback callback, object state);
    internal static List`1<InstancePersistenceEvent> EndWaitForEvents(IAsyncResult result);
}
public class System.Runtime.DurableInstancing.InstanceHandleConflictException : InstancePersistenceCommandException {
    public InstanceHandleConflictException(string message);
    public InstanceHandleConflictException(string message, Exception innerException);
    public InstanceHandleConflictException(XName commandName, Guid instanceId);
    public InstanceHandleConflictException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceHandleConflictException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceHandleConflictException(SerializationInfo info, StreamingContext context);
}
internal class System.Runtime.DurableInstancing.InstanceHandleReference : object {
    internal InstanceHandle InstanceHandle { get; private set; }
    internal InstanceHandleReference(InstanceHandle instanceHandle);
    [CompilerGeneratedAttribute]
internal InstanceHandle get_InstanceHandle();
    [CompilerGeneratedAttribute]
private void set_InstanceHandle(InstanceHandle value);
    internal void Cancel();
}
[DataContractAttribute]
public class System.Runtime.DurableInstancing.InstanceKey : object {
    public bool IsValid { get; }
    public Guid Value { get; private set; }
    public IDictionary`2<XName, InstanceValue> Metadata { get; private set; }
    public static InstanceKey InvalidKey { get; }
    [DataMemberAttribute]
internal Guid SerializedValue { get; internal set; }
    [DataMemberAttribute]
internal IDictionary`2<XName, InstanceValue> SerializedMetadata { get; internal set; }
    public InstanceKey(Guid value);
    public InstanceKey(Guid value, IDictionary`2<XName, InstanceValue> metadata);
    private static InstanceKey();
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Guid get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Guid value);
    public IDictionary`2<XName, InstanceValue> get_Metadata();
    private void set_Metadata(IDictionary`2<XName, InstanceValue> value);
    public static InstanceKey get_InvalidKey();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Guid get_SerializedValue();
    internal void set_SerializedValue(Guid value);
    internal IDictionary`2<XName, InstanceValue> get_SerializedMetadata();
    internal void set_SerializedMetadata(IDictionary`2<XName, InstanceValue> value);
}
public class System.Runtime.DurableInstancing.InstanceKeyCollisionException : InstancePersistenceCommandException {
    public Guid ConflictingInstanceId { get; private set; }
    public InstanceKey InstanceKey { get; private set; }
    public InstanceKeyCollisionException(string message);
    public InstanceKeyCollisionException(string message, Exception innerException);
    public InstanceKeyCollisionException(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId);
    public InstanceKeyCollisionException(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId, Exception innerException);
    public InstanceKeyCollisionException(XName commandName, Guid instanceId, InstanceKey instanceKey, Guid conflictingInstanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceKeyCollisionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Guid get_ConflictingInstanceId();
    [CompilerGeneratedAttribute]
private void set_ConflictingInstanceId(Guid value);
    [CompilerGeneratedAttribute]
public InstanceKey get_InstanceKey();
    [CompilerGeneratedAttribute]
private void set_InstanceKey(InstanceKey value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceKeyCompleteException : InstancePersistenceCommandException {
    public InstanceKey InstanceKey { get; private set; }
    public InstanceKeyCompleteException(string message);
    public InstanceKeyCompleteException(string message, Exception innerException);
    public InstanceKeyCompleteException(XName commandName, InstanceKey instanceKey);
    public InstanceKeyCompleteException(XName commandName, InstanceKey instanceKey, Exception innerException);
    public InstanceKeyCompleteException(XName commandName, Guid instanceId, InstanceKey instanceKey, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceKeyCompleteException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public InstanceKey get_InstanceKey();
    [CompilerGeneratedAttribute]
private void set_InstanceKey(InstanceKey value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceKeyNotReadyException : InstancePersistenceCommandException {
    public InstanceKey InstanceKey { get; private set; }
    public InstanceKeyNotReadyException(string message);
    public InstanceKeyNotReadyException(string message, Exception innerException);
    public InstanceKeyNotReadyException(XName commandName, InstanceKey instanceKey);
    public InstanceKeyNotReadyException(XName commandName, InstanceKey instanceKey, Exception innerException);
    public InstanceKeyNotReadyException(XName commandName, Guid instanceId, InstanceKey instanceKey, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceKeyNotReadyException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public InstanceKey get_InstanceKey();
    [CompilerGeneratedAttribute]
private void set_InstanceKey(InstanceKey value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Runtime.DurableInstancing.InstanceKeyState : Enum {
    public int value__;
    public static InstanceKeyState Unknown;
    public static InstanceKeyState Associated;
    public static InstanceKeyState Completed;
}
public class System.Runtime.DurableInstancing.InstanceKeyView : object {
    public Guid InstanceKey { get; private set; }
    public InstanceKeyState InstanceKeyState { get; internal set; }
    public InstanceValueConsistency InstanceKeyMetadataConsistency { get; internal set; }
    public IDictionary`2<XName, InstanceValue> InstanceKeyMetadata { get; internal set; }
    internal Dictionary`2<XName, InstanceValue> AccumulatedMetadataWrites { get; }
    internal InstanceKeyView(Guid key);
    private static InstanceKeyView();
    [CompilerGeneratedAttribute]
public Guid get_InstanceKey();
    [CompilerGeneratedAttribute]
private void set_InstanceKey(Guid value);
    [CompilerGeneratedAttribute]
public InstanceKeyState get_InstanceKeyState();
    [CompilerGeneratedAttribute]
internal void set_InstanceKeyState(InstanceKeyState value);
    [CompilerGeneratedAttribute]
public InstanceValueConsistency get_InstanceKeyMetadataConsistency();
    [CompilerGeneratedAttribute]
internal void set_InstanceKeyMetadataConsistency(InstanceValueConsistency value);
    public IDictionary`2<XName, InstanceValue> get_InstanceKeyMetadata();
    internal void set_InstanceKeyMetadata(IDictionary`2<XName, InstanceValue> value);
    internal Dictionary`2<XName, InstanceValue> get_AccumulatedMetadataWrites();
    internal InstanceKeyView Clone();
}
public class System.Runtime.DurableInstancing.InstanceLockedException : InstancePersistenceCommandException {
    public Guid InstanceOwnerId { get; private set; }
    public IDictionary`2<XName, object> SerializableInstanceOwnerMetadata { get; private set; }
    public InstanceLockedException(string message);
    public InstanceLockedException(string message, Exception innerException);
    public InstanceLockedException(XName commandName, Guid instanceId);
    public InstanceLockedException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceLockedException(XName commandName, Guid instanceId, string message, Exception innerException);
    public InstanceLockedException(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata);
    public InstanceLockedException(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata, Exception innerException);
    public InstanceLockedException(XName commandName, Guid instanceId, Guid instanceOwnerId, IDictionary`2<XName, object> serializableInstanceOwnerMetadata, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceLockedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Guid get_InstanceOwnerId();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnerId(Guid value);
    [CompilerGeneratedAttribute]
public IDictionary`2<XName, object> get_SerializableInstanceOwnerMetadata();
    [CompilerGeneratedAttribute]
private void set_SerializableInstanceOwnerMetadata(IDictionary`2<XName, object> value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceLockLostException : InstancePersistenceCommandException {
    public InstanceLockLostException(string message);
    public InstanceLockLostException(string message, Exception innerException);
    public InstanceLockLostException(XName commandName, Guid instanceId);
    public InstanceLockLostException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceLockLostException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceLockLostException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceLockQueryResult : InstanceStoreQueryResult {
    public IDictionary`2<Guid, Guid> InstanceOwnerIds { get; private set; }
    public InstanceLockQueryResult(Guid instanceId, Guid instanceOwnerId);
    public InstanceLockQueryResult(IDictionary`2<Guid, Guid> instanceOwnerIds);
    private static InstanceLockQueryResult();
    [CompilerGeneratedAttribute]
public IDictionary`2<Guid, Guid> get_InstanceOwnerIds();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnerIds(IDictionary`2<Guid, Guid> value);
}
internal class System.Runtime.DurableInstancing.InstanceNormalEvent : InstancePersistenceEvent {
    internal bool IsSignaled { get; internal set; }
    internal HashSet`1<InstanceHandle> BoundHandles { get; }
    internal HashSet`1<InstanceHandle> PendingHandles { get; }
    internal InstanceNormalEvent(InstancePersistenceEvent persistenceEvent);
    [CompilerGeneratedAttribute]
internal bool get_IsSignaled();
    [CompilerGeneratedAttribute]
internal void set_IsSignaled(bool value);
    internal HashSet`1<InstanceHandle> get_BoundHandles();
    internal HashSet`1<InstanceHandle> get_PendingHandles();
}
public class System.Runtime.DurableInstancing.InstanceNotReadyException : InstancePersistenceCommandException {
    public InstanceNotReadyException(string message);
    public InstanceNotReadyException(string message, Exception innerException);
    public InstanceNotReadyException(XName commandName, Guid instanceId);
    public InstanceNotReadyException(XName commandName, Guid instanceId, Exception innerException);
    public InstanceNotReadyException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceNotReadyException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceOwner : object {
    public Guid InstanceOwnerId { get; private set; }
    internal Guid OwnerToken { get; private set; }
    internal Dictionary`2<XName, InstanceNormalEvent> Events { get; }
    internal InstanceOwner(Guid ownerId, Guid lockToken);
    [CompilerGeneratedAttribute]
public Guid get_InstanceOwnerId();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnerId(Guid value);
    [CompilerGeneratedAttribute]
internal Guid get_OwnerToken();
    [CompilerGeneratedAttribute]
private void set_OwnerToken(Guid value);
    internal Dictionary`2<XName, InstanceNormalEvent> get_Events();
    internal void Unbind(InstanceHandle handle);
    internal void StartBind(InstanceHandle handle, InstanceHandleReference& reference);
    internal bool TryCompleteBind(InstanceHandleReference& reference, List`1& handlesPendingResolution, InstanceHandle& handleToFree);
    internal AsyncWaitHandle InitiateLockResolution(long instanceVersion, InstanceHandleReference& reference, List`1& handlesPendingResolution);
    internal void InstanceBound(InstanceHandleReference& reference, List`1& handlesPendingResolution);
    internal void CancelBind(InstanceHandleReference& reference, List`1& handlesPendingResolution);
    internal void FaultBind(InstanceHandleReference& reference, List`1& handlesPendingResolution, Exception reason);
    internal bool FinishBind(InstanceHandleReference& reference, Int64& instanceVersion, List`1& handlesPendingResolution);
    internal static void ResolveHandles(List`1<InstanceHandleReference> handlesPendingResolution);
}
public class System.Runtime.DurableInstancing.InstanceOwnerException : InstancePersistenceException {
    public Guid InstanceOwnerId { get; private set; }
    public InstanceOwnerException(string message);
    public InstanceOwnerException(string message, Exception innerException);
    public InstanceOwnerException(XName commandName, Guid instanceOwnerId);
    public InstanceOwnerException(XName commandName, Guid instanceOwnerId, Exception innerException);
    public InstanceOwnerException(XName commandName, Guid instanceOwnerId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstanceOwnerException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Guid get_InstanceOwnerId();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnerId(Guid value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstanceOwnerQueryResult : InstanceStoreQueryResult {
    public IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> InstanceOwners { get; private set; }
    public InstanceOwnerQueryResult(Guid instanceOwnerId, IDictionary`2<XName, InstanceValue> metadata);
    public InstanceOwnerQueryResult(IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> instanceOwners);
    private static InstanceOwnerQueryResult();
    [CompilerGeneratedAttribute]
public IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> get_InstanceOwners();
    [CompilerGeneratedAttribute]
private void set_InstanceOwners(IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> value);
}
[ExtensionAttribute]
internal static class System.Runtime.DurableInstancing.InstancePersistence : object {
    internal static XNamespace ActivitiesCommandNamespace { get; }
    internal static XNamespace ActivitiesEventNamespace { get; }
    private static InstancePersistence();
    internal static XNamespace get_ActivitiesCommandNamespace();
    internal static XNamespace get_ActivitiesEventNamespace();
    [ExtensionAttribute]
public static void ValidatePropertyBag(IDictionary`2<XName, InstanceValue> bag);
    [ExtensionAttribute]
public static void ValidatePropertyBag(IDictionary`2<XName, InstanceValue> bag, bool allowDelete);
    [ExtensionAttribute]
public static void ValidateProperty(KeyValuePair`2<XName, InstanceValue> property);
    [ExtensionAttribute]
public static void ValidateProperty(KeyValuePair`2<XName, InstanceValue> property, bool allowDelete);
    [ExtensionAttribute]
public static bool IsOptional(InstanceValue value);
    [ExtensionAttribute]
public static bool IsWriteOnly(InstanceValue value);
    [ExtensionAttribute]
public static ReadOnlyDictionaryInternal`2<XName, InstanceValue> ReadOnlyCopy(IDictionary`2<XName, InstanceValue> bag, bool allowWriteOnly);
    [ExtensionAttribute]
public static ReadOnlyDictionaryInternal`2<XName, InstanceValue> ReadOnlyMergeInto(IDictionary`2<XName, InstanceValue> bag, IDictionary`2<XName, InstanceValue> existing, bool allowWriteOnly);
}
public abstract class System.Runtime.DurableInstancing.InstancePersistenceCommand : object {
    public XName Name { get; private set; }
    protected internal bool IsTransactionEnlistmentOptional { get; }
    protected internal bool AutomaticallyAcquiringLock { get; }
    protected InstancePersistenceCommand(XName name);
    [CompilerGeneratedAttribute]
public XName get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(XName value);
    protected internal virtual bool get_IsTransactionEnlistmentOptional();
    protected internal virtual bool get_AutomaticallyAcquiringLock();
    protected internal virtual void Validate(InstanceView view);
    internal virtual IEnumerable`1<InstancePersistenceCommand> Reduce(InstanceView view);
}
public class System.Runtime.DurableInstancing.InstancePersistenceCommandException : InstancePersistenceException {
    public Guid InstanceId { get; private set; }
    public InstancePersistenceCommandException(string message);
    public InstancePersistenceCommandException(string message, Exception innerException);
    public InstancePersistenceCommandException(XName commandName);
    public InstancePersistenceCommandException(XName commandName, Guid instanceId);
    public InstancePersistenceCommandException(XName commandName, Exception innerException);
    public InstancePersistenceCommandException(XName commandName, string message, Exception innerException);
    public InstancePersistenceCommandException(XName commandName, Guid instanceId, Exception innerException);
    public InstancePersistenceCommandException(XName commandName, Guid instanceId, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstancePersistenceCommandException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
private void set_InstanceId(Guid value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.DurableInstancing.InstancePersistenceContext : object {
    public InstanceHandle InstanceHandle { get; private set; }
    public InstanceView InstanceView { get; private set; }
    public long InstanceVersion { get; }
    internal EventTraceActivity EventTraceActivity { get; }
    public Guid LockToken { get; }
    public object UserContext { get; }
    internal Transaction Transaction { get; }
    internal bool IsHandleDoomedByRollback { get; private set; }
    internal InstancePersistenceContext(InstanceHandle handle, Transaction transaction);
    internal InstancePersistenceContext(InstanceHandle handle, TimeSpan timeout);
    [CompilerGeneratedAttribute]
public InstanceHandle get_InstanceHandle();
    [CompilerGeneratedAttribute]
private void set_InstanceHandle(InstanceHandle value);
    [CompilerGeneratedAttribute]
public InstanceView get_InstanceView();
    [CompilerGeneratedAttribute]
private void set_InstanceView(InstanceView value);
    public long get_InstanceVersion();
    internal EventTraceActivity get_EventTraceActivity();
    public Guid get_LockToken();
    public object get_UserContext();
    public void SetCancellationHandler(Action`1<InstancePersistenceContext> cancellationHandler);
    public void BindInstanceOwner(Guid instanceOwnerId, Guid lockToken);
    public void BindInstance(Guid instanceId);
    public void BindEvent(InstancePersistenceEvent persistenceEvent);
    public void BindAcquiredLock(long instanceVersion);
    public void BindReclaimedLock(long instanceVersion, TimeSpan timeout);
    public IAsyncResult BeginBindReclaimedLock(long instanceVersion, TimeSpan timeout, AsyncCallback callback, object state);
    public void EndBindReclaimedLock(IAsyncResult result);
    public Exception CreateBindReclaimedLockException(long instanceVersion);
    public void PersistedInstance(IDictionary`2<XName, InstanceValue> data);
    public void LoadedInstance(InstanceState state, IDictionary`2<XName, InstanceValue> instanceData, IDictionary`2<XName, InstanceValue> instanceMetadata, IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> associatedInstanceKeyMetadata, IDictionary`2<Guid, IDictionary`2<XName, InstanceValue>> completedInstanceKeyMetadata);
    public void CompletedInstance();
    public void ReadInstanceMetadata(IDictionary`2<XName, InstanceValue> metadata, bool complete);
    public void WroteInstanceMetadataValue(XName name, InstanceValue value);
    public void AssociatedInstanceKey(Guid key);
    public void CompletedInstanceKey(Guid key);
    public void UnassociatedInstanceKey(Guid key);
    public void ReadInstanceKeyMetadata(Guid key, IDictionary`2<XName, InstanceValue> metadata, bool complete);
    public void WroteInstanceKeyMetadataValue(Guid key, XName name, InstanceValue value);
    public void ReadInstanceOwnerMetadata(IDictionary`2<XName, InstanceValue> metadata, bool complete);
    public void WroteInstanceOwnerMetadataValue(XName name, InstanceValue value);
    public void QueriedInstanceStore(InstanceStoreQueryResult queryResult);
    public void Execute(InstancePersistenceCommand command, TimeSpan timeout);
    public IAsyncResult BeginExecute(InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state);
    public void EndExecute(IAsyncResult result);
    internal Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal bool get_IsHandleDoomedByRollback();
    [CompilerGeneratedAttribute]
private void set_IsHandleDoomedByRollback(bool value);
    internal void RequireTransaction();
    internal void PrepareForReuse();
    internal void NotifyHandleFree();
    internal static InstanceView OuterExecute(InstanceHandle initialInstanceHandle, InstancePersistenceCommand command, Transaction transaction, TimeSpan timeout);
    internal static IAsyncResult BeginOuterExecute(InstanceHandle initialInstanceHandle, InstancePersistenceCommand command, Transaction transaction, TimeSpan timeout, AsyncCallback callback, object state);
    internal static InstanceView EndOuterExecute(IAsyncResult result);
}
public abstract class System.Runtime.DurableInstancing.InstancePersistenceEvent : object {
    public XName Name { get; private set; }
    internal InstancePersistenceEvent(XName name);
    [CompilerGeneratedAttribute]
public XName get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(XName value);
    public sealed virtual bool Equals(InstancePersistenceEvent persistenceEvent);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(InstancePersistenceEvent left, InstancePersistenceEvent right);
    public static bool op_Inequality(InstancePersistenceEvent left, InstancePersistenceEvent right);
}
public abstract class System.Runtime.DurableInstancing.InstancePersistenceEvent`1 : InstancePersistenceEvent {
    public static T Value { get; }
    protected InstancePersistenceEvent`1(XName name);
    public static T get_Value();
}
public class System.Runtime.DurableInstancing.InstancePersistenceException : Exception {
    public XName CommandName { get; private set; }
    public InstancePersistenceException(string message);
    public InstancePersistenceException(string message, Exception innerException);
    public InstancePersistenceException(XName commandName);
    public InstancePersistenceException(XName commandName, Exception innerException);
    public InstancePersistenceException(XName commandName, string message);
    public InstancePersistenceException(XName commandName, string message, Exception innerException);
    [SecurityCriticalAttribute]
protected InstancePersistenceException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public XName get_CommandName();
    [CompilerGeneratedAttribute]
private void set_CommandName(XName value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Runtime.DurableInstancing.InstanceState : Enum {
    public int value__;
    public static InstanceState Unknown;
    public static InstanceState Uninitialized;
    public static InstanceState Initialized;
    public static InstanceState Completed;
}
public abstract class System.Runtime.DurableInstancing.InstanceStore : object {
    public InstanceOwner DefaultInstanceOwner { get; public set; }
    [CompilerGeneratedAttribute]
public InstanceOwner get_DefaultInstanceOwner();
    [CompilerGeneratedAttribute]
public void set_DefaultInstanceOwner(InstanceOwner value);
    public InstanceHandle CreateInstanceHandle();
    public InstanceHandle CreateInstanceHandle(InstanceOwner owner);
    public InstanceHandle CreateInstanceHandle(Guid instanceId);
    public InstanceHandle CreateInstanceHandle(InstanceOwner owner, Guid instanceId);
    public InstanceView Execute(InstanceHandle handle, InstancePersistenceCommand command, TimeSpan timeout);
    public IAsyncResult BeginExecute(InstanceHandle handle, InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state);
    public InstanceView EndExecute(IAsyncResult result);
    public List`1<InstancePersistenceEvent> WaitForEvents(InstanceHandle handle, TimeSpan timeout);
    public IAsyncResult BeginWaitForEvents(InstanceHandle handle, TimeSpan timeout, AsyncCallback callback, object state);
    public List`1<InstancePersistenceEvent> EndWaitForEvents(IAsyncResult result);
    protected void SignalEvent(InstancePersistenceEvent persistenceEvent, InstanceOwner owner);
    protected void ResetEvent(InstancePersistenceEvent persistenceEvent, InstanceOwner owner);
    protected virtual object OnNewInstanceHandle(InstanceHandle instanceHandle);
    protected virtual void OnFreeInstanceHandle(InstanceHandle instanceHandle, object userContext);
    protected internal virtual bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout);
    protected internal virtual IAsyncResult BeginTryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state);
    protected internal virtual bool EndTryCommand(IAsyncResult result);
    protected InstanceOwner[] GetInstanceOwners();
    protected InstancePersistenceEvent[] GetEvents(InstanceOwner owner);
    internal InstanceOwner GetOrCreateOwner(Guid instanceOwnerId, Guid lockToken);
    internal void PendHandleToEvent(InstanceHandle handle, InstancePersistenceEvent persistenceEvent, InstanceOwner owner);
    internal InstancePersistenceEvent AddHandleToEvent(InstanceHandle handle, InstancePersistenceEvent persistenceEvent, InstanceOwner owner);
    internal List`1<InstancePersistenceEvent> SelectSignaledEvents(IEnumerable`1<XName> eventNames, InstanceOwner owner);
    internal void RemoveHandleFromEvents(InstanceHandle handle, IEnumerable`1<XName> eventNames, InstanceOwner owner);
    internal void FreeInstanceHandle(InstanceHandle handle, object providerObject);
}
public abstract class System.Runtime.DurableInstancing.InstanceStoreQueryResult : object {
}
[DataContractAttribute]
public class System.Runtime.DurableInstancing.InstanceValue : object {
    public object Value { get; private set; }
    public InstanceValueOptions Options { get; private set; }
    public bool IsDeletedValue { get; }
    public static InstanceValue DeletedValue { get; }
    [DataMemberAttribute]
internal object SerializedValue { get; internal set; }
    [DataMemberAttribute]
internal InstanceValueOptions SerializedOptions { get; internal set; }
    public InstanceValue(object value);
    public InstanceValue(object value, InstanceValueOptions options);
    private static InstanceValue();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public InstanceValueOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(InstanceValueOptions value);
    public bool get_IsDeletedValue();
    public static InstanceValue get_DeletedValue();
    internal object get_SerializedValue();
    internal void set_SerializedValue(object value);
    internal InstanceValueOptions get_SerializedOptions();
    internal void set_SerializedOptions(InstanceValueOptions value);
}
[FlagsAttribute]
public enum System.Runtime.DurableInstancing.InstanceValueConsistency : Enum {
    public int value__;
    public static InstanceValueConsistency None;
    public static InstanceValueConsistency InDoubt;
    public static InstanceValueConsistency Partial;
}
[DataContractAttribute]
[FlagsAttribute]
public enum System.Runtime.DurableInstancing.InstanceValueOptions : Enum {
    public int value__;
    [EnumMemberAttribute]
public static InstanceValueOptions None;
    [EnumMemberAttribute]
public static InstanceValueOptions Optional;
    [EnumMemberAttribute]
public static InstanceValueOptions WriteOnly;
}
public class System.Runtime.DurableInstancing.InstanceView : object {
    public Guid InstanceId { get; private set; }
    public bool IsBoundToInstance { get; private set; }
    public InstanceOwner InstanceOwner { get; private set; }
    public bool IsBoundToInstanceOwner { get; }
    public bool IsBoundToLock { get; }
    public InstanceState InstanceState { get; internal set; }
    public InstanceValueConsistency InstanceDataConsistency { get; internal set; }
    public IDictionary`2<XName, InstanceValue> InstanceData { get; internal set; }
    public InstanceValueConsistency InstanceMetadataConsistency { get; internal set; }
    public IDictionary`2<XName, InstanceValue> InstanceMetadata { get; internal set; }
    internal Dictionary`2<XName, InstanceValue> AccumulatedMetadataWrites { get; }
    public InstanceValueConsistency InstanceOwnerMetadataConsistency { get; internal set; }
    public IDictionary`2<XName, InstanceValue> InstanceOwnerMetadata { get; internal set; }
    internal Dictionary`2<XName, InstanceValue> AccumulatedOwnerMetadataWrites { get; }
    public InstanceValueConsistency InstanceKeysConsistency { get; internal set; }
    public IDictionary`2<Guid, InstanceKeyView> InstanceKeys { get; internal set; }
    public ReadOnlyCollection`1<InstanceStoreQueryResult> InstanceStoreQueryResults { get; internal set; }
    internal Collection`1<InstanceStoreQueryResult> QueryResultsBacking { get; }
    internal InstanceView(InstanceOwner owner);
    internal InstanceView(InstanceOwner owner, Guid instanceId);
    private static InstanceView();
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
private void set_InstanceId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsBoundToInstance();
    [CompilerGeneratedAttribute]
private void set_IsBoundToInstance(bool value);
    [CompilerGeneratedAttribute]
public InstanceOwner get_InstanceOwner();
    [CompilerGeneratedAttribute]
private void set_InstanceOwner(InstanceOwner value);
    public bool get_IsBoundToInstanceOwner();
    public bool get_IsBoundToLock();
    [CompilerGeneratedAttribute]
public InstanceState get_InstanceState();
    [CompilerGeneratedAttribute]
internal void set_InstanceState(InstanceState value);
    [CompilerGeneratedAttribute]
public InstanceValueConsistency get_InstanceDataConsistency();
    [CompilerGeneratedAttribute]
internal void set_InstanceDataConsistency(InstanceValueConsistency value);
    public IDictionary`2<XName, InstanceValue> get_InstanceData();
    internal void set_InstanceData(IDictionary`2<XName, InstanceValue> value);
    [CompilerGeneratedAttribute]
public InstanceValueConsistency get_InstanceMetadataConsistency();
    [CompilerGeneratedAttribute]
internal void set_InstanceMetadataConsistency(InstanceValueConsistency value);
    public IDictionary`2<XName, InstanceValue> get_InstanceMetadata();
    internal void set_InstanceMetadata(IDictionary`2<XName, InstanceValue> value);
    internal Dictionary`2<XName, InstanceValue> get_AccumulatedMetadataWrites();
    [CompilerGeneratedAttribute]
public InstanceValueConsistency get_InstanceOwnerMetadataConsistency();
    [CompilerGeneratedAttribute]
internal void set_InstanceOwnerMetadataConsistency(InstanceValueConsistency value);
    public IDictionary`2<XName, InstanceValue> get_InstanceOwnerMetadata();
    internal void set_InstanceOwnerMetadata(IDictionary`2<XName, InstanceValue> value);
    internal Dictionary`2<XName, InstanceValue> get_AccumulatedOwnerMetadataWrites();
    [CompilerGeneratedAttribute]
public InstanceValueConsistency get_InstanceKeysConsistency();
    [CompilerGeneratedAttribute]
internal void set_InstanceKeysConsistency(InstanceValueConsistency value);
    public IDictionary`2<Guid, InstanceKeyView> get_InstanceKeys();
    internal void set_InstanceKeys(IDictionary`2<Guid, InstanceKeyView> value);
    public ReadOnlyCollection`1<InstanceStoreQueryResult> get_InstanceStoreQueryResults();
    internal void set_InstanceStoreQueryResults(ReadOnlyCollection`1<InstanceStoreQueryResult> value);
    internal Collection`1<InstanceStoreQueryResult> get_QueryResultsBacking();
    internal void BindOwner(InstanceOwner owner);
    internal void BindInstance(Guid instanceId);
    internal void BindLock(long instanceVersion);
    internal void StartBindLock(long instanceVersion);
    internal void FinishBindLock(long instanceVersion);
    internal void MakeReadOnly();
    internal InstanceView Clone();
}
internal interface System.Runtime.ICancelable {
    public abstract virtual void Cancel();
}
internal interface System.Runtime.IPersistencePipelineModule {
    public bool IsIOParticipant { get; }
    public bool IsSaveTransactionRequired { get; }
    public bool IsLoadTransactionRequired { get; }
    public abstract virtual bool get_IsIOParticipant();
    public abstract virtual bool get_IsSaveTransactionRequired();
    public abstract virtual bool get_IsLoadTransactionRequired();
    public abstract virtual void CollectValues(IDictionary`2& readWriteValues, IDictionary`2& writeOnlyValues);
    public abstract virtual IDictionary`2<XName, object> MapValues(IDictionary`2<XName, object> readWriteValues, IDictionary`2<XName, object> writeOnlyValues);
    public abstract virtual void PublishValues(IDictionary`2<XName, object> readWriteValues);
    public abstract virtual IAsyncResult BeginOnSave(IDictionary`2<XName, object> readWriteValues, IDictionary`2<XName, object> writeOnlyValues, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOnSave(IAsyncResult result);
    public abstract virtual IAsyncResult BeginOnLoad(IDictionary`2<XName, object> readWriteValues, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOnLoad(IAsyncResult result);
    public abstract virtual void Abort();
}
internal static class System.Runtime.PersistenceMetadataNamespace : object {
    public static XName InstanceType { get; }
    public static XName ActivationType { get; }
    private static PersistenceMetadataNamespace();
    public static XName get_InstanceType();
    public static XName get_ActivationType();
}
internal class System.Runtime.PersistencePipeline : object {
    public ReadOnlyDictionaryInternal`2<XName, InstanceValue> Values { get; }
    public bool IsSaveTransactionRequired { get; }
    public bool IsLoadTransactionRequired { get; }
    public PersistencePipeline(IEnumerable`1<IPersistencePipelineModule> modules, Dictionary`2<XName, InstanceValue> initialValues);
    public PersistencePipeline(IEnumerable`1<IPersistencePipelineModule> modules);
    public ReadOnlyDictionaryInternal`2<XName, InstanceValue> get_Values();
    public bool get_IsSaveTransactionRequired();
    public bool get_IsLoadTransactionRequired();
    public void Collect();
    public void Map();
    public IAsyncResult BeginSave(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndSave(IAsyncResult result);
    public void SetLoadedValues(IDictionary`2<XName, InstanceValue> values);
    public IAsyncResult BeginLoad(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndLoad(IAsyncResult result);
    public void Publish();
    public void Abort();
}
internal class System.Runtime.SRCore : object {
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string PersistenceInitializerThrew { get; }
    internal static string InvalidStateInAsyncResult { get; }
    internal static string ExtensionsCannotBeSetByIndex { get; }
    internal static string CannotCreateContextWithNullId { get; }
    internal static string CannotReplaceTransaction { get; }
    internal static string CommandExecutionCannotOverlap { get; }
    internal static string CompletedMustNotHaveAssociatedKeys { get; }
    internal static string ContextAlreadyBoundToInstance { get; }
    internal static string ContextAlreadyBoundToLock { get; }
    internal static string ContextAlreadyBoundToOwner { get; }
    internal static string ContextMustBeBoundToInstance { get; }
    internal static string ContextMustBeBoundToOwner { get; }
    internal static string ContextNotFromThisStore { get; }
    internal static string GenericInstanceCommandNull { get; }
    internal static string HandleFreed { get; }
    internal static string HandleFreedBeforeInitialized { get; }
    internal static string InstanceOperationRequiresInstance { get; }
    internal static string InstanceOperationRequiresLock { get; }
    internal static string InstanceOperationRequiresNotCompleted { get; }
    internal static string InstanceOperationRequiresNotUninitialized { get; }
    internal static string InstanceOperationRequiresOwner { get; }
    internal static string InvalidInstanceState { get; }
    internal static string InvalidKeyArgument { get; }
    internal static string InvalidLockToken { get; }
    internal static string KeyAlreadyAssociated { get; }
    internal static string KeyAlreadyCompleted { get; }
    internal static string KeyAlreadyUnassociated { get; }
    internal static string KeyNotAssociated { get; }
    internal static string KeyNotCompleted { get; }
    internal static string LoadedWriteOnlyValue { get; }
    internal static string MetadataCannotContainNullKey { get; }
    internal static string MustSetTransactionOnFirstCall { get; }
    internal static string OnFreeInstanceHandleThrew { get; }
    internal static string TransactionInDoubtNonHost { get; }
    internal static string TransactionRolledBackNonHost { get; }
    internal static string UninitializedCannotHaveData { get; }
    internal static string CannotCompleteWithKeys { get; }
    internal static string OnCancelRequestedThrew { get; }
    internal static string AlreadyBoundToInstance { get; }
    internal static string AlreadyBoundToOwner { get; }
    internal static string InstanceRequired { get; }
    internal static string LoadOpAssociateKeysCannotContainLookupKey { get; }
    internal static string LoadOpFreeKeyRequiresAcceptUninitialized { get; }
    internal static string LoadOpKeyMustBeValid { get; }
    internal static string OwnerRequired { get; }
    internal static string ValidateUnlockInstance { get; }
    internal static string InstanceKeyRequiresValidGuid { get; }
    internal static string AsyncTransactionException { get; }
    internal static string ExecuteMustBeNested { get; }
    internal static string TryCommandCannotExecuteSubCommandsAndReduce { get; }
    internal static string CannotAcquireLockDefault { get; }
    internal static string InstanceNotReadyDefault { get; }
    internal static string KeyNotReadyDefault { get; }
    internal static string KeyCollisionDefault { get; }
    internal static string KeyCompleteDefault { get; }
    internal static string InstanceCompleteDefault { get; }
    internal static string InstanceCollisionDefault { get; }
    internal static string InstanceLockLostDefault { get; }
    internal static string InstanceOwnerDefault { get; }
    internal static string InstanceHandleConflictDefault { get; }
    internal static string BindLockRequiresCommandFlag { get; }
    internal static string CannotInvokeBindingFromNonBinding { get; }
    internal static string CannotInvokeTransactionalFromNonTransactional { get; }
    internal static string DoNotCompleteTryCommandWithPendingReclaim { get; }
    internal static string GuidCannotBeEmpty { get; }
    internal static string InstanceStoreBoundSameVersionTwice { get; }
    internal static string MayBindLockCommandShouldValidateOwner { get; }
    internal static string StoreReportedConflictingLockTokens { get; }
    internal static string TimedOutWaitingForLockResolution { get; }
    internal static string BindReclaimedLockException { get; }
    internal static string BindReclaimSucceeded { get; }
    internal static string OwnerBelongsToWrongStore { get; }
    internal static string WaitAlreadyInProgress { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_PersistenceInitializerThrew();
    internal static string get_InvalidStateInAsyncResult();
    internal static string get_ExtensionsCannotBeSetByIndex();
    internal static string get_CannotCreateContextWithNullId();
    internal static string get_CannotReplaceTransaction();
    internal static string get_CommandExecutionCannotOverlap();
    internal static string get_CompletedMustNotHaveAssociatedKeys();
    internal static string get_ContextAlreadyBoundToInstance();
    internal static string get_ContextAlreadyBoundToLock();
    internal static string get_ContextAlreadyBoundToOwner();
    internal static string get_ContextMustBeBoundToInstance();
    internal static string get_ContextMustBeBoundToOwner();
    internal static string get_ContextNotFromThisStore();
    internal static string get_GenericInstanceCommandNull();
    internal static string get_HandleFreed();
    internal static string get_HandleFreedBeforeInitialized();
    internal static string get_InstanceOperationRequiresInstance();
    internal static string get_InstanceOperationRequiresLock();
    internal static string get_InstanceOperationRequiresNotCompleted();
    internal static string get_InstanceOperationRequiresNotUninitialized();
    internal static string get_InstanceOperationRequiresOwner();
    internal static string get_InvalidInstanceState();
    internal static string get_InvalidKeyArgument();
    internal static string get_InvalidLockToken();
    internal static string get_KeyAlreadyAssociated();
    internal static string get_KeyAlreadyCompleted();
    internal static string get_KeyAlreadyUnassociated();
    internal static string get_KeyNotAssociated();
    internal static string get_KeyNotCompleted();
    internal static string get_LoadedWriteOnlyValue();
    internal static string get_MetadataCannotContainNullKey();
    internal static string get_MustSetTransactionOnFirstCall();
    internal static string get_OnFreeInstanceHandleThrew();
    internal static string get_TransactionInDoubtNonHost();
    internal static string get_TransactionRolledBackNonHost();
    internal static string get_UninitializedCannotHaveData();
    internal static string get_CannotCompleteWithKeys();
    internal static string get_OnCancelRequestedThrew();
    internal static string get_AlreadyBoundToInstance();
    internal static string get_AlreadyBoundToOwner();
    internal static string get_InstanceRequired();
    internal static string get_LoadOpAssociateKeysCannotContainLookupKey();
    internal static string get_LoadOpFreeKeyRequiresAcceptUninitialized();
    internal static string get_LoadOpKeyMustBeValid();
    internal static string get_OwnerRequired();
    internal static string get_ValidateUnlockInstance();
    internal static string get_InstanceKeyRequiresValidGuid();
    internal static string get_AsyncTransactionException();
    internal static string get_ExecuteMustBeNested();
    internal static string get_TryCommandCannotExecuteSubCommandsAndReduce();
    internal static string get_CannotAcquireLockDefault();
    internal static string get_InstanceNotReadyDefault();
    internal static string get_KeyNotReadyDefault();
    internal static string get_KeyCollisionDefault();
    internal static string get_KeyCompleteDefault();
    internal static string get_InstanceCompleteDefault();
    internal static string get_InstanceCollisionDefault();
    internal static string get_InstanceLockLostDefault();
    internal static string get_InstanceOwnerDefault();
    internal static string get_InstanceHandleConflictDefault();
    internal static string get_BindLockRequiresCommandFlag();
    internal static string get_CannotInvokeBindingFromNonBinding();
    internal static string get_CannotInvokeTransactionalFromNonTransactional();
    internal static string get_DoNotCompleteTryCommandWithPendingReclaim();
    internal static string get_GuidCannotBeEmpty();
    internal static string get_InstanceStoreBoundSameVersionTwice();
    internal static string get_MayBindLockCommandShouldValidateOwner();
    internal static string get_StoreReportedConflictingLockTokens();
    internal static string get_TimedOutWaitingForLockResolution();
    internal static string get_BindReclaimedLockException();
    internal static string get_BindReclaimSucceeded();
    internal static string get_OwnerBelongsToWrongStore();
    internal static string get_WaitAlreadyInProgress();
    internal static string IncorrectValueType(object param0, object param1);
    internal static string NullAssignedToValueType(object param0);
    internal static string CouldNotResolveNamespacePrefix(object param0);
    internal static string GenericInstanceCommand(object param0);
    internal static string GetParameterTypeMismatch(object param0, object param1);
    internal static string InitialMetadataCannotBeDeleted(object param0);
    internal static string MetadataCannotContainNullValue(object param0);
    internal static string OutsideInstanceExecutionScope(object param0);
    internal static string OutsideTransactionalCommand(object param0);
    internal static string ProviderDoesNotSupportCommand(object param0);
    internal static string CannotAcquireLockSpecific(object param0);
    internal static string InstanceNotReadySpecific(object param0);
    internal static string KeyNotReadySpecific(object param0);
    internal static string KeyCollisionSpecific(object param0, object param1, object param2);
    internal static string NameCollisionOnCollect(object param0, object param1);
    internal static string NameCollisionOnMap(object param0, object param1);
    internal static string PersistencePipelineAbortThrew(object param0);
    internal static string KeyCollisionSpecificKeyOnly(object param0);
    internal static string KeyCompleteSpecific(object param0);
    internal static string InstanceCompleteSpecific(object param0);
    internal static string CannotAcquireLockSpecificWithOwner(object param0, object param1);
    internal static string InstanceCollisionSpecific(object param0);
    internal static string InstanceLockLostSpecific(object param0);
    internal static string InstanceOwnerSpecific(object param0);
    internal static string InstanceHandleConflictSpecific(object param0);
    internal static string WaitForEventsTimedOut(object param0);
}
internal abstract class System.Runtime.TransactedAsyncResult : AsyncResult {
    protected TransactedAsyncResult(AsyncCallback callback, object state);
    protected virtual bool OnContinueAsyncCompletion(IAsyncResult result);
    protected IDisposable PrepareTransactionalCall(Transaction transaction);
}
internal static class System.Runtime.TransactionHelper : object {
    public static void ThrowIfTransactionAbortedOrInDoubt(Transaction transaction);
    public static TransactionScope CreateTransactionScope(Transaction transaction);
    public static void CompleteTransactionScope(TransactionScope& scope);
}
internal static class System.Runtime.Workflow45Namespace : object {
    public static XName DefinitionIdentity { get; }
    public static XName DefinitionIdentities { get; }
    public static XName DefinitionIdentityFilter { get; }
    public static XName WorkflowApplication { get; }
    private static Workflow45Namespace();
    public static XName get_DefinitionIdentity();
    public static XName get_DefinitionIdentities();
    public static XName get_DefinitionIdentityFilter();
    public static XName get_WorkflowApplication();
}
internal static class System.Runtime.WorkflowNamespace : object {
    public static XNamespace VariablesPath { get; }
    public static XNamespace OutputPath { get; }
    public static XName WorkflowHostType { get; }
    public static XName Status { get; }
    public static XName Bookmarks { get; }
    public static XName LastUpdate { get; }
    public static XName Exception { get; }
    public static XName Workflow { get; }
    public static XName KeyProvider { get; }
    private static WorkflowNamespace();
    public static XNamespace get_VariablesPath();
    public static XNamespace get_OutputPath();
    public static XName get_WorkflowHostType();
    public static XName get_Status();
    public static XName get_Bookmarks();
    public static XName get_LastUpdate();
    public static XName get_Exception();
    public static XName get_Workflow();
    public static XName get_KeyProvider();
}
internal static class System.Runtime.WorkflowServiceNamespace : object {
    public static XNamespace EndpointsPath { get; }
    public static XName ControlEndpoint { get; }
    public static XName MessageVersionForReplies { get; }
    public static XName RequestReplyCorrelation { get; }
    public static XName SuspendReason { get; }
    public static XName SiteName { get; }
    public static XName SuspendException { get; }
    public static XName RelativeApplicationPath { get; }
    public static XName RelativeServicePath { get; }
    public static XName CreationContext { get; }
    public static XName Service { get; }
    private static WorkflowServiceNamespace();
    public static XNamespace get_EndpointsPath();
    public static XName get_ControlEndpoint();
    public static XName get_MessageVersionForReplies();
    public static XName get_RequestReplyCorrelation();
    public static XName get_SuspendReason();
    public static XName get_SiteName();
    public static XName get_SuspendException();
    public static XName get_RelativeApplicationPath();
    public static XName get_RelativeServicePath();
    public static XName get_CreationContext();
    public static XName get_Service();
}
