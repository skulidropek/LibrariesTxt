internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string EcmaPublicKeyFull;
    internal static string SilverlightPublicKey;
    internal static string SilverlightPublicKeyToken;
    internal static string SilverlightPublicKeyFull;
    internal static string SilverlightPlatformPublicKey;
    internal static string SilverlightPlatformPublicKeyToken;
    internal static string SilverlightPlatformPublicKeyFull;
    internal static string PlatformPublicKey;
    internal static string PlatformPublicKeyToken;
    internal static string PlatformPublicKeyFull;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string SystemDataOracleClient;
    internal static string System;
    internal static string SystemCore;
    internal static string SystemNumerics;
    internal static string SystemRuntimeRemoting;
    internal static string SystemThreadingTasksDataflow;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string MicrosoftPublicKeyToken;
    internal static string MicrosoftPublicKeyFull;
    internal static string SharedLibPublicKey;
    internal static string SharedLibPublicKeyToken;
    internal static string SharedLibPublicKeyFull;
    internal static string SystemComponentModelDataAnnotations;
    internal static string SystemConfiguration;
    internal static string SystemConfigurationInstall;
    internal static string SystemDeployment;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemNetHttp;
    internal static string SystemNetHttpWebRequest;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemRuntimeWindowsRuntime;
    internal static string SystemRuntimeWindowsRuntimeUIXaml;
    internal static string SystemSecurity;
    internal static string SystemServiceModelWeb;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebAbstractions;
    internal static string SystemWebDynamicData;
    internal static string SystemWebDynamicDataDesign;
    internal static string SystemWebEntityDesign;
    internal static string SystemWebExtensions;
    internal static string SystemWebExtensionsDesign;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebRouting;
    internal static string SystemWebServices;
    internal static string WindowsBase;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVisualStudioWindowsForms;
    internal static string VJSharpCodeProvider;
    internal static string ASPBrowserCapsPublicKey;
    internal static string ASPBrowserCapsFactory;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftVisualStudioWeb;
    internal static string MicrosoftWebDesign;
    internal static string MicrosoftVSDesignerMobile;
    internal static string MicrosoftJScript;
}
internal static class FXAssembly : object {
    internal static string Version;
}
[SecurityCriticalAttribute]
[InterfaceTypeAttribute("1")]
[ComConversionLossAttribute]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
internal interface Microsoft.Runtime.Hosting.IClrStrongName {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
[InterfaceTypeAttribute("1")]
[SecurityCriticalAttribute]
[ComConversionLossAttribute]
internal interface Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
internal static class Microsoft.Runtime.Hosting.StrongNameHelpers : object {
    [SecurityCriticalAttribute]
public static int StrongNameErrorInfo();
    [SecurityCriticalAttribute]
public static void StrongNameFreeBuffer(IntPtr pbMemory);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyDelete(string pwzKeyContainer);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& pdwOutFlags);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& pfWasVerified);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
}
internal static class Microsoft.Win32.ASM_CACHE : object {
    public static UInt32 ZAP;
    public static UInt32 GAC;
    public static UInt32 DOWNLOAD;
}
internal static class Microsoft.Win32.ASM_NAME : object {
    public static UInt32 PUBLIC_KEY;
    public static UInt32 PUBLIC_KEY_TOKEN;
    public static UInt32 HASH_VALUE;
    public static UInt32 NAME;
    public static UInt32 MAJOR_VERSION;
    public static UInt32 MINOR_VERSION;
    public static UInt32 BUILD_NUMBER;
    public static UInt32 REVISION_NUMBER;
    public static UInt32 CULTURE;
    public static UInt32 PROCESSOR_ID_ARRAY;
    public static UInt32 OSINFO_ARRAY;
    public static UInt32 HASH_ALGID;
    public static UInt32 ALIAS;
    public static UInt32 CODEBASE_URL;
    public static UInt32 CODEBASE_LASTMOD;
    public static UInt32 NULL_PUBLIC_KEY;
    public static UInt32 NULL_PUBLIC_KEY_TOKEN;
    public static UInt32 CUSTOM;
    public static UInt32 NULL_CUSTOM;
    public static UInt32 MVID;
    public static UInt32 _32_BIT_ONLY;
    public static UInt32 MAX_PARAMS;
}
internal static class Microsoft.Win32.CANOF : object {
    public static UInt32 PARSE_DISPLAY_NAME;
    public static UInt32 SET_DEFAULT_VALUES;
}
internal static class Microsoft.Win32.Fusion : object {
    [SecurityCriticalAttribute]
public static void ReadCache(ArrayList alAssems, string name, UInt32 nFlag);
}
[GuidAttribute("7c23ff90-33af-11d3-95da-00a024a85b51")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Win32.IApplicationContext {
    public abstract virtual void SetContextNameObject(IAssemblyName pName);
    public abstract virtual void GetContextNameObject(IAssemblyName& ppName);
    public abstract virtual void Set(string szName, int pvValue, UInt32 cbValue, UInt32 dwFlags);
    public abstract virtual void Get(string szName, Int32& pvValue, UInt32& pcbValue, UInt32 dwFlags);
    public abstract virtual void GetDynamicDirectory(Int32& wzDynamicDir, UInt32& pdwSize);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("21b8916c-f28e-11d2-a473-00c04f8ef448")]
internal interface Microsoft.Win32.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IApplicationContext& ppAppCtx, IAssemblyName& ppName, UInt32 dwFlags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[GuidAttribute("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Win32.IAssemblyName {
    public abstract virtual int SetProperty(UInt32 PropertyId, IntPtr pvProperty, UInt32 cbProperty);
    public abstract virtual int GetProperty(UInt32 PropertyId, IntPtr pvProperty, UInt32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(IntPtr szDisplayName, UInt32& pccDisplayName, UInt32 dwDisplayFlags);
    public abstract virtual int BindToObject(object refIID, object pAsmBindSink, IApplicationContext pApplicationContext, string szCodeBase, long llFlags, int pvReserved, UInt32 cbReserved, Int32& ppv);
    public abstract virtual int GetName(UInt32& lpcwBuffer, Int32& pwzName);
    public abstract virtual int GetVersion(UInt32& pdwVersionHi, UInt32& pdwVersionLow);
    public abstract virtual int IsEqual(IAssemblyName pName, UInt32 dwCmpFlags);
    public abstract virtual int Clone(IAssemblyName& pName);
}
internal class Microsoft.Win32.OAVariantLib : object {
    public static int NoValueProp;
    public static int AlphaBool;
    public static int NoUserOverride;
    public static int CalendarHijri;
    public static int LocalBool;
    internal static Type[] ClassTypes;
    private static OAVariantLib();
    [SecurityCriticalAttribute]
internal static Variant ChangeType(Variant source, Type targetClass, short options, CultureInfo culture);
}
[ComVisibleAttribute("True")]
public static class Microsoft.Win32.Registry : object {
    public static RegistryKey CurrentUser;
    public static RegistryKey LocalMachine;
    public static RegistryKey ClassesRoot;
    public static RegistryKey Users;
    public static RegistryKey PerformanceData;
    public static RegistryKey CurrentConfig;
    [ObsoleteAttribute("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")]
public static RegistryKey DynData;
    [SecuritySafeCriticalAttribute]
private static Registry();
    [SecuritySafeCriticalAttribute]
public static object GetValue(string keyName, string valueName, object defaultValue);
    public static void SetValue(string keyName, string valueName, object value);
    [SecuritySafeCriticalAttribute]
public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
}
[ComVisibleAttribute("True")]
public enum Microsoft.Win32.RegistryHive : Enum {
    public int value__;
    public static RegistryHive ClassesRoot;
    public static RegistryHive CurrentUser;
    public static RegistryHive LocalMachine;
    public static RegistryHive Users;
    public static RegistryHive PerformanceData;
    public static RegistryHive CurrentConfig;
    public static RegistryHive DynData;
}
[ComVisibleAttribute("True")]
public class Microsoft.Win32.RegistryKey : MarshalByRefObject {
    internal static IntPtr HKEY_CLASSES_ROOT;
    internal static IntPtr HKEY_CURRENT_USER;
    internal static IntPtr HKEY_LOCAL_MACHINE;
    internal static IntPtr HKEY_USERS;
    internal static IntPtr HKEY_PERFORMANCE_DATA;
    internal static IntPtr HKEY_CURRENT_CONFIG;
    internal static IntPtr HKEY_DYN_DATA;
    public int SubKeyCount { get; }
    [ComVisibleAttribute("False")]
public RegistryView View { get; }
    [ComVisibleAttribute("False")]
public SafeRegistryHandle Handle { get; }
    public int ValueCount { get; }
    public string Name { get; }
    private static RegistryKey();
    public void Close();
    [SecuritySafeCriticalAttribute]
public void Flush();
    public sealed virtual void Dispose();
    public RegistryKey CreateSubKey(string subkey);
    [ComVisibleAttribute("False")]
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck);
    [ComVisibleAttribute("False")]
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions options);
    [ComVisibleAttribute("False")]
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity);
    [ComVisibleAttribute("False")]
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity);
    public void DeleteSubKey(string subkey);
    [SecuritySafeCriticalAttribute]
public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
    public void DeleteSubKeyTree(string subkey);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
    public void DeleteValue(string name);
    [SecuritySafeCriticalAttribute]
public void DeleteValue(string name, bool throwOnMissingValue);
    [SecurityCriticalAttribute]
internal static RegistryKey GetBaseKey(IntPtr hKey);
    [SecurityCriticalAttribute]
internal static RegistryKey GetBaseKey(IntPtr hKey, RegistryView view);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
    public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view);
    [SecuritySafeCriticalAttribute]
public RegistryKey OpenSubKey(string name, bool writable);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights);
    [SecurityCriticalAttribute]
internal RegistryKey InternalOpenSubKey(string name, bool writable);
    public RegistryKey OpenSubKey(string name);
    [SecuritySafeCriticalAttribute]
public int get_SubKeyCount();
    [SecuritySafeCriticalAttribute]
public RegistryView get_View();
    [SecurityCriticalAttribute]
public SafeRegistryHandle get_Handle();
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public static RegistryKey FromHandle(SafeRegistryHandle handle);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
    [SecurityCriticalAttribute]
internal int InternalSubKeyCount();
    [SecuritySafeCriticalAttribute]
public String[] GetSubKeyNames();
    [SecurityCriticalAttribute]
internal String[] InternalGetSubKeyNames();
    [SecuritySafeCriticalAttribute]
public int get_ValueCount();
    [SecurityCriticalAttribute]
internal int InternalValueCount();
    [SecuritySafeCriticalAttribute]
public String[] GetValueNames();
    [SecuritySafeCriticalAttribute]
public object GetValue(string name);
    [SecuritySafeCriticalAttribute]
public object GetValue(string name, object defaultValue);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public object GetValue(string name, object defaultValue, RegistryValueOptions options);
    [SecurityCriticalAttribute]
internal object InternalGetValue(string name, object defaultValue, bool doNotExpand, bool checkSecurity);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public RegistryValueKind GetValueKind(string name);
    [SecuritySafeCriticalAttribute]
public string get_Name();
    public void SetValue(string name, object value);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void SetValue(string name, object value, RegistryValueKind valueKind);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public RegistrySecurity GetAccessControl();
    [SecuritySafeCriticalAttribute]
public RegistrySecurity GetAccessControl(AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
public void SetAccessControl(RegistrySecurity registrySecurity);
    [SecuritySafeCriticalAttribute]
internal void Win32Error(int errorCode, string str);
    [SecuritySafeCriticalAttribute]
internal static void Win32ErrorStatic(int errorCode, string str);
    internal static string FixupName(string name);
}
public enum Microsoft.Win32.RegistryKeyPermissionCheck : Enum {
    public int value__;
    public static RegistryKeyPermissionCheck Default;
    public static RegistryKeyPermissionCheck ReadSubTree;
    public static RegistryKeyPermissionCheck ReadWriteSubTree;
}
[FlagsAttribute]
public enum Microsoft.Win32.RegistryOptions : Enum {
    public int value__;
    public static RegistryOptions None;
    public static RegistryOptions Volatile;
}
[ComVisibleAttribute("True")]
public enum Microsoft.Win32.RegistryValueKind : Enum {
    public int value__;
    public static RegistryValueKind String;
    public static RegistryValueKind ExpandString;
    public static RegistryValueKind Binary;
    public static RegistryValueKind DWord;
    public static RegistryValueKind MultiString;
    public static RegistryValueKind QWord;
    public static RegistryValueKind Unknown;
    [ComVisibleAttribute("False")]
public static RegistryValueKind None;
}
[FlagsAttribute]
public enum Microsoft.Win32.RegistryValueOptions : Enum {
    public int value__;
    public static RegistryValueOptions None;
    public static RegistryValueOptions DoNotExpandEnvironmentNames;
}
public enum Microsoft.Win32.RegistryView : Enum {
    public int value__;
    public static RegistryView Default;
    public static RegistryView Registry64;
    public static RegistryView Registry32;
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFileMappingHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal SafeFileMappingHandle(IntPtr handle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLocalAllocHandle : SafeBuffer {
    internal static SafeLocalAllocHandle InvalidHandle { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    internal static SafeLocalAllocHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLsaLogonProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLsaLogonProcessHandle InvalidHandle { get; }
    internal SafeLsaLogonProcessHandle(IntPtr handle);
    internal static SafeLsaLogonProcessHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle : SafeBuffer {
    internal static SafeLsaMemoryHandle InvalidHandle { get; }
    internal SafeLsaMemoryHandle(IntPtr handle);
    internal static SafeLsaMemoryHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLsaPolicyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLsaPolicyHandle InvalidHandle { get; }
    internal SafeLsaPolicyHandle(IntPtr handle);
    internal static SafeLsaPolicyHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLsaReturnBufferHandle : SafeBuffer {
    internal static SafeLsaReturnBufferHandle InvalidHandle { get; }
    internal SafeLsaReturnBufferHandle(IntPtr handle);
    internal static SafeLsaReturnBufferHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafePEFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeProcessHandle InvalidHandle { get; }
    internal SafeProcessHandle(IntPtr handle);
    internal static SafeProcessHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "2")]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int RegCloseKey(IntPtr hKey);
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeThreadHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeThreadHandle(IntPtr handle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeTokenHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeTokenHandle InvalidHandle { get; }
    internal SafeTokenHandle(IntPtr handle);
    internal static SafeTokenHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeViewOfFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal SafeViewOfFileHandle(IntPtr handle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    internal void SetAsMutex();
    [ReliabilityContractAttribute("3", "2")]
internal void SetAsReservedMutex();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    internal static int GetTimeZoneInformation(TimeZoneInformation& lpTimeZoneInformation);
    internal static int GetDynamicTimeZoneInformation(DynamicTimeZoneInformation& lpDynamicTimeZoneInformation);
    internal static bool GetFileMUIPath(int flags, string filePath, StringBuilder language, Int32& languageLength, StringBuilder fileMuiPath, Int32& fileMuiPathLength, Int64& enumerator);
    internal static int LoadString(SafeLibraryHandle handle, int id, StringBuilder buffer, int bufferLength);
    internal static SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);
    [ReliabilityContractAttribute("3", "2")]
internal static bool FreeLibrary(IntPtr hModule);
}
[SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static class Microsoft.Win32.Win32Native : object {
    internal static int KEY_QUERY_VALUE;
    internal static int KEY_SET_VALUE;
    internal static int KEY_CREATE_SUB_KEY;
    internal static int KEY_ENUMERATE_SUB_KEYS;
    internal static int KEY_NOTIFY;
    internal static int KEY_CREATE_LINK;
    internal static int KEY_READ;
    internal static int KEY_WRITE;
    internal static int KEY_WOW64_64KEY;
    internal static int KEY_WOW64_32KEY;
    internal static int REG_OPTION_NON_VOLATILE;
    internal static int REG_OPTION_VOLATILE;
    internal static int REG_OPTION_CREATE_LINK;
    internal static int REG_OPTION_BACKUP_RESTORE;
    internal static int REG_NONE;
    internal static int REG_SZ;
    internal static int REG_EXPAND_SZ;
    internal static int REG_BINARY;
    internal static int REG_DWORD;
    internal static int REG_DWORD_LITTLE_ENDIAN;
    internal static int REG_DWORD_BIG_ENDIAN;
    internal static int REG_LINK;
    internal static int REG_MULTI_SZ;
    internal static int REG_RESOURCE_LIST;
    internal static int REG_FULL_RESOURCE_DESCRIPTOR;
    internal static int REG_RESOURCE_REQUIREMENTS_LIST;
    internal static int REG_QWORD;
    internal static int HWND_BROADCAST;
    internal static int WM_SETTINGCHANGE;
    internal static UInt32 CRYPTPROTECTMEMORY_BLOCK_SIZE;
    internal static UInt32 CRYPTPROTECTMEMORY_SAME_PROCESS;
    internal static UInt32 CRYPTPROTECTMEMORY_CROSS_PROCESS;
    internal static UInt32 CRYPTPROTECTMEMORY_SAME_LOGON;
    internal static int SECURITY_ANONYMOUS;
    internal static int SECURITY_SQOS_PRESENT;
    internal static string MICROSOFT_KERBEROS_NAME;
    internal static UInt32 ANONYMOUS_LOGON_LUID;
    internal static int SECURITY_ANONYMOUS_LOGON_RID;
    internal static int SECURITY_AUTHENTICATED_USER_RID;
    internal static int SECURITY_LOCAL_SYSTEM_RID;
    internal static int SECURITY_BUILTIN_DOMAIN_RID;
    internal static UInt32 SE_PRIVILEGE_DISABLED;
    internal static UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    internal static UInt32 SE_PRIVILEGE_ENABLED;
    internal static UInt32 SE_PRIVILEGE_USED_FOR_ACCESS;
    internal static UInt32 SE_GROUP_MANDATORY;
    internal static UInt32 SE_GROUP_ENABLED_BY_DEFAULT;
    internal static UInt32 SE_GROUP_ENABLED;
    internal static UInt32 SE_GROUP_OWNER;
    internal static UInt32 SE_GROUP_USE_FOR_DENY_ONLY;
    internal static UInt32 SE_GROUP_LOGON_ID;
    internal static UInt32 SE_GROUP_RESOURCE;
    internal static UInt32 DUPLICATE_CLOSE_SOURCE;
    internal static UInt32 DUPLICATE_SAME_ACCESS;
    internal static UInt32 DUPLICATE_SAME_ATTRIBUTES;
    internal static int TIME_ZONE_ID_INVALID;
    internal static int TIME_ZONE_ID_UNKNOWN;
    internal static int TIME_ZONE_ID_STANDARD;
    internal static int TIME_ZONE_ID_DAYLIGHT;
    internal static int MAX_PATH;
    internal static int MUI_LANGUAGE_ID;
    internal static int MUI_LANGUAGE_NAME;
    internal static int MUI_PREFERRED_UI_LANGUAGES;
    internal static int MUI_INSTALLED_LANGUAGES;
    internal static int MUI_ALL_LANGUAGES;
    internal static int MUI_LANG_NEUTRAL_PE_FILE;
    internal static int MUI_NON_LANG_NEUTRAL_FILE;
    internal static int LOAD_LIBRARY_AS_DATAFILE;
    internal static int LOAD_STRING_MAX_LENGTH;
    internal static int READ_CONTROL;
    internal static int SYNCHRONIZE;
    internal static int STANDARD_RIGHTS_READ;
    internal static int STANDARD_RIGHTS_WRITE;
    internal static int SEMAPHORE_MODIFY_STATE;
    internal static int EVENT_MODIFY_STATE;
    internal static int MUTEX_MODIFY_STATE;
    internal static int MUTEX_ALL_ACCESS;
    internal static int LMEM_FIXED;
    internal static int LMEM_ZEROINIT;
    internal static int LPTR;
    internal static string KERNEL32;
    internal static string USER32;
    internal static string ADVAPI32;
    internal static string OLE32;
    internal static string OLEAUT32;
    internal static string SHELL32;
    internal static string SHIM;
    internal static string CRYPT32;
    internal static string SECUR32;
    internal static string MSCORWKS;
    internal static string LSTRLENA;
    internal static string LSTRLENW;
    internal static string ZEROMEMORY;
    internal static int SEM_FAILCRITICALERRORS;
    internal static int FIND_STARTSWITH;
    internal static int FIND_ENDSWITH;
    internal static int FIND_FROMSTART;
    internal static int FIND_FROMEND;
    internal static int STD_INPUT_HANDLE;
    internal static int STD_OUTPUT_HANDLE;
    internal static int STD_ERROR_HANDLE;
    internal static int CTRL_C_EVENT;
    internal static int CTRL_BREAK_EVENT;
    internal static int CTRL_CLOSE_EVENT;
    internal static int CTRL_LOGOFF_EVENT;
    internal static int CTRL_SHUTDOWN_EVENT;
    internal static short KEY_EVENT;
    internal static int FILE_TYPE_DISK;
    internal static int FILE_TYPE_CHAR;
    internal static int FILE_TYPE_PIPE;
    internal static int REPLACEFILE_WRITE_THROUGH;
    internal static int REPLACEFILE_IGNORE_MERGE_ERRORS;
    internal static UInt32 FILE_MAP_WRITE;
    internal static UInt32 FILE_MAP_READ;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int IO_REPARSE_TAG_MOUNT_POINT;
    internal static int PAGE_READWRITE;
    internal static int MEM_COMMIT;
    internal static int MEM_RESERVE;
    internal static int MEM_RELEASE;
    internal static int MEM_FREE;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_INVALID_FUNCTION;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_HANDLE;
    internal static int ERROR_NOT_ENOUGH_MEMORY;
    internal static int ERROR_INVALID_DATA;
    internal static int ERROR_INVALID_DRIVE;
    internal static int ERROR_NO_MORE_FILES;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_BAD_LENGTH;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_NOT_SUPPORTED;
    internal static int ERROR_FILE_EXISTS;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_CALL_NOT_IMPLEMENTED;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_BAD_PATHNAME;
    internal static int ERROR_ALREADY_EXISTS;
    internal static int ERROR_ENVVAR_NOT_FOUND;
    internal static int ERROR_FILENAME_EXCED_RANGE;
    internal static int ERROR_NO_DATA;
    internal static int ERROR_PIPE_NOT_CONNECTED;
    internal static int ERROR_MORE_DATA;
    internal static int ERROR_DIRECTORY;
    internal static int ERROR_OPERATION_ABORTED;
    internal static int ERROR_NOT_FOUND;
    internal static int ERROR_NO_TOKEN;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_NON_ACCOUNT_SID;
    internal static int ERROR_NOT_ALL_ASSIGNED;
    internal static int ERROR_UNKNOWN_REVISION;
    internal static int ERROR_INVALID_OWNER;
    internal static int ERROR_INVALID_PRIMARY_GROUP;
    internal static int ERROR_NO_SUCH_PRIVILEGE;
    internal static int ERROR_PRIVILEGE_NOT_HELD;
    internal static int ERROR_NONE_MAPPED;
    internal static int ERROR_INVALID_ACL;
    internal static int ERROR_INVALID_SID;
    internal static int ERROR_INVALID_SECURITY_DESCR;
    internal static int ERROR_BAD_IMPERSONATION_LEVEL;
    internal static int ERROR_CANT_OPEN_ANONYMOUS;
    internal static int ERROR_NO_SECURITY_ON_OBJECT;
    internal static int ERROR_TRUSTED_RELATIONSHIP_FAILURE;
    internal static UInt32 STATUS_SUCCESS;
    internal static UInt32 STATUS_SOME_NOT_MAPPED;
    internal static UInt32 STATUS_NO_MEMORY;
    internal static UInt32 STATUS_OBJECT_NAME_NOT_FOUND;
    internal static UInt32 STATUS_NONE_MAPPED;
    internal static UInt32 STATUS_INSUFFICIENT_RESOURCES;
    internal static UInt32 STATUS_ACCESS_DENIED;
    internal static int INVALID_FILE_SIZE;
    internal static int STATUS_ACCOUNT_RESTRICTION;
    internal static int LCID_SUPPORTED;
    internal static int ENABLE_PROCESSED_INPUT;
    internal static int ENABLE_LINE_INPUT;
    internal static int ENABLE_ECHO_INPUT;
    internal static int VER_PLATFORM_WIN32s;
    internal static int VER_PLATFORM_WIN32_WINDOWS;
    internal static int VER_PLATFORM_WIN32_NT;
    internal static int VER_PLATFORM_WINCE;
    internal static int VER_PLATFORM_UNIX;
    internal static int VER_PLATFORM_MACOSX;
    internal static int SHGFP_TYPE_CURRENT;
    internal static int UOI_FLAGS;
    internal static int WSF_VISIBLE;
    internal static int CSIDL_FLAG_CREATE;
    internal static int CSIDL_FLAG_DONT_VERIFY;
    internal static int CSIDL_ADMINTOOLS;
    internal static int CSIDL_CDBURN_AREA;
    internal static int CSIDL_COMMON_ADMINTOOLS;
    internal static int CSIDL_COMMON_DOCUMENTS;
    internal static int CSIDL_COMMON_MUSIC;
    internal static int CSIDL_COMMON_OEM_LINKS;
    internal static int CSIDL_COMMON_PICTURES;
    internal static int CSIDL_COMMON_STARTMENU;
    internal static int CSIDL_COMMON_PROGRAMS;
    internal static int CSIDL_COMMON_STARTUP;
    internal static int CSIDL_COMMON_DESKTOPDIRECTORY;
    internal static int CSIDL_COMMON_TEMPLATES;
    internal static int CSIDL_COMMON_VIDEO;
    internal static int CSIDL_FONTS;
    internal static int CSIDL_MYVIDEO;
    internal static int CSIDL_NETHOOD;
    internal static int CSIDL_PRINTHOOD;
    internal static int CSIDL_PROFILE;
    internal static int CSIDL_PROGRAM_FILES_COMMONX86;
    internal static int CSIDL_PROGRAM_FILESX86;
    internal static int CSIDL_RESOURCES;
    internal static int CSIDL_RESOURCES_LOCALIZED;
    internal static int CSIDL_SYSTEMX86;
    internal static int CSIDL_WINDOWS;
    internal static int CSIDL_APPDATA;
    internal static int CSIDL_COMMON_APPDATA;
    internal static int CSIDL_LOCAL_APPDATA;
    internal static int CSIDL_COOKIES;
    internal static int CSIDL_FAVORITES;
    internal static int CSIDL_HISTORY;
    internal static int CSIDL_INTERNET_CACHE;
    internal static int CSIDL_PROGRAMS;
    internal static int CSIDL_RECENT;
    internal static int CSIDL_SENDTO;
    internal static int CSIDL_STARTMENU;
    internal static int CSIDL_STARTUP;
    internal static int CSIDL_SYSTEM;
    internal static int CSIDL_TEMPLATES;
    internal static int CSIDL_DESKTOPDIRECTORY;
    internal static int CSIDL_PERSONAL;
    internal static int CSIDL_PROGRAM_FILES;
    internal static int CSIDL_PROGRAM_FILES_COMMON;
    internal static int CSIDL_DESKTOP;
    internal static int CSIDL_DRIVES;
    internal static int CSIDL_MYMUSIC;
    internal static int CSIDL_MYPICTURES;
    internal static int NameSamCompatible;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_SID;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN;
    internal static int CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING;
    internal static int CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE;
    internal static int CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE;
    internal static int CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY;
    internal static int CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT;
    internal static int CLAIM_SECURITY_ATTRIBUTE_DISABLED;
    internal static int CLAIM_SECURITY_ATTRIBUTE_MANDATORY;
    internal static int CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS;
    internal static IntPtr INVALID_HANDLE_VALUE;
    private static Win32Native();
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static int FormatMessage(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr va_list_arguments);
    internal static string GetMessage(int errorCode);
    [ReliabilityContractAttribute("3", "1")]
internal static IntPtr LocalAlloc_NoSafeHandle(int uFlags, UIntPtr sizetdwBytes);
    internal static SafeLocalAllocHandle LocalAlloc(int uFlags, UIntPtr sizetdwBytes);
    [ReliabilityContractAttribute("3", "2")]
internal static IntPtr LocalFree(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static void ZeroMemory(IntPtr address, UIntPtr length);
    internal static bool GlobalMemoryStatusEx(MEMORYSTATUSEX buffer);
    internal static UIntPtr VirtualQuery(Void* address, MEMORY_BASIC_INFORMATION& buffer, UIntPtr sizeOfBuffer);
    [ReliabilityContractAttribute("3", "1")]
internal static Void* VirtualAlloc(Void* address, UIntPtr numBytes, int commitOrReserve, int pageProtectionMode);
    [ReliabilityContractAttribute("3", "1")]
internal static bool VirtualFree(Void* address, UIntPtr numBytes, int pageFreeMode);
    [SecurityCriticalAttribute]
internal static bool DoesWin32MethodExist(string moduleName, string methodName);
    internal static bool IsWow64Process(IntPtr hSourceProcessHandle, Boolean& isWow64);
    internal static UInt32 GetTempPath(int bufferLen, StringBuilder buffer);
    internal static int lstrlenA(IntPtr ptr);
    internal static int lstrlenW(IntPtr ptr);
    [ReliabilityContractAttribute("3", "1")]
internal static IntPtr SysAllocStringLen(string src, int len);
    [ReliabilityContractAttribute("3", "1")]
internal static IntPtr SysAllocStringByteLen(Byte[] str, UInt32 len);
    [ReliabilityContractAttribute("3", "2")]
internal static UInt32 SysStringByteLen(IntPtr bstr);
    [ReliabilityContractAttribute("3", "2")]
internal static UInt32 SysStringLen(IntPtr bstr);
    [ReliabilityContractAttribute("3", "2")]
internal static UInt32 SysStringLen(SafeBSTRHandle bstr);
    [ReliabilityContractAttribute("3", "2")]
internal static void SysFreeString(IntPtr bstr);
    internal static int GetACP();
    internal static bool SetEvent(SafeWaitHandle handle);
    internal static bool ResetEvent(SafeWaitHandle handle);
    internal static SafeWaitHandle CreateEvent(SECURITY_ATTRIBUTES lpSecurityAttributes, bool isManualReset, bool initialState, string name);
    internal static SafeWaitHandle OpenEvent(int desiredAccess, bool inheritHandle, string name);
    [ReliabilityContractAttribute("3", "1")]
internal static SafeWaitHandle CreateMutex(SECURITY_ATTRIBUTES lpSecurityAttributes, bool initialOwner, string name);
    internal static SafeWaitHandle OpenMutex(int desiredAccess, bool inheritHandle, string name);
    [ReliabilityContractAttribute("3", "1")]
internal static bool ReleaseMutex(SafeWaitHandle handle);
    internal static int GetFullPathName(Char* path, int numBufferChars, Char* buffer, IntPtr mustBeZero);
    internal static int GetFullPathName(string path, int numBufferChars, StringBuilder buffer, IntPtr mustBeZero);
    internal static int GetLongPathName(Char* path, Char* longPathBuffer, int bufferLength);
    internal static int GetLongPathName(string path, StringBuilder longPathBuffer, int bufferLength);
    [SecurityCriticalAttribute]
internal static SafeFileHandle SafeCreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    [SecurityCriticalAttribute]
internal static SafeFileHandle UnsafeCreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static SafeFileMappingHandle CreateFileMapping(SafeFileHandle hFile, IntPtr lpAttributes, UInt32 fProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    internal static IntPtr MapViewOfFile(SafeFileMappingHandle handle, UInt32 dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, UIntPtr dwNumerOfBytesToMap);
    [ReliabilityContractAttribute("3", "2")]
internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CloseHandle(IntPtr handle);
    internal static int GetFileType(SafeFileHandle handle);
    internal static bool SetEndOfFile(SafeFileHandle hFile);
    internal static bool FlushFileBuffers(SafeFileHandle hFile);
    [SecurityCriticalAttribute]
internal static long SetFilePointer(SafeFileHandle handle, long offset, SeekOrigin origin, Int32& hr);
    internal static int ReadFile(SafeFileHandle handle, Byte* bytes, int numBytesToRead, IntPtr numBytesRead_mustBeZero, NativeOverlapped* overlapped);
    internal static int ReadFile(SafeFileHandle handle, Byte* bytes, int numBytesToRead, Int32& numBytesRead, IntPtr mustBeZero);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, IntPtr numBytesWritten_mustBeZero, NativeOverlapped* lpOverlapped);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, Int32& numBytesWritten, IntPtr mustBeZero);
    internal static bool CancelIoEx(SafeFileHandle handle, NativeOverlapped* lpOverlapped);
    internal static bool GetDiskFreeSpaceEx(string drive, Int64& freeBytesForUser, Int64& totalBytes, Int64& freeBytes);
    internal static int GetDriveType(string drive);
    internal static bool GetVolumeInformation(string drive, StringBuilder volumeName, int volumeNameBufLen, Int32& volSerialNumber, Int32& maxFileNameLen, Int32& fileSystemFlags, StringBuilder fileSystemName, int fileSystemNameBufLen);
    internal static bool SetVolumeLabel(string driveLetter, string volumeName);
    internal static bool QueryPerformanceCounter(Int64& value);
    internal static bool QueryPerformanceFrequency(Int64& value);
    internal static SafeWaitHandle CreateSemaphore(SECURITY_ATTRIBUTES lpSecurityAttributes, int initialCount, int maximumCount, string name);
    [ReliabilityContractAttribute("3", "2")]
internal static bool ReleaseSemaphore(SafeWaitHandle handle, int releaseCount, Int32& previousCount);
    internal static int GetWindowsDirectory(StringBuilder sb, int length);
    internal static int GetSystemDirectory(StringBuilder sb, int length);
    internal static bool SetFileTime(SafeFileHandle hFile, FILE_TIME* creationTime, FILE_TIME* lastAccessTime, FILE_TIME* lastWriteTime);
    internal static int GetFileSize(SafeFileHandle hFile, Int32& highSize);
    internal static bool LockFile(SafeFileHandle handle, int offsetLow, int offsetHigh, int countLow, int countHigh);
    internal static bool UnlockFile(SafeFileHandle handle, int offsetLow, int offsetHigh, int countLow, int countHigh);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static bool CopyFile(string src, string dst, bool failIfExists);
    internal static bool CreateDirectory(string path, SECURITY_ATTRIBUTES lpSecurityAttributes);
    internal static bool DeleteFile(string path);
    internal static bool ReplaceFile(string replacedFileName, string replacementFileName, string backupFileName, int dwReplaceFlags, IntPtr lpExclude, IntPtr lpReserved);
    internal static bool DecryptFile(string path, int reservedMustBeZero);
    internal static bool EncryptFile(string path);
    internal static SafeFindHandle FindFirstFile(string fileName, WIN32_FIND_DATA data);
    internal static bool FindNextFile(SafeFindHandle hndFindFile, WIN32_FIND_DATA lpFindFileData);
    [ReliabilityContractAttribute("3", "2")]
internal static bool FindClose(IntPtr handle);
    internal static int GetCurrentDirectory(int nBufferLength, StringBuilder lpBuffer);
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static bool SetFileAttributes(string name, int attr);
    internal static int GetLogicalDrives();
    internal static UInt32 GetTempFileName(string tmpPath, string prefix, UInt32 uniqueIdOrZero, StringBuilder tmpFileName);
    internal static bool MoveFile(string src, string dst);
    internal static bool DeleteVolumeMountPoint(string mountPoint);
    internal static bool RemoveDirectory(string path);
    internal static bool SetCurrentDirectory(string path);
    internal static int SetErrorMode(int newMode);
    internal static int WideCharToMultiByte(UInt32 cp, UInt32 flags, Char* pwzSource, int cchSource, Byte* pbDestBuffer, int cbDestBuffer, IntPtr null1, IntPtr null2);
    [ReliabilityContractAttribute("3", "2")]
internal static bool SetConsoleCtrlHandler(ConsoleCtrlHandlerRoutine handler, bool addOrRemove);
    internal static bool SetEnvironmentVariable(string lpName, string lpValue);
    internal static int GetEnvironmentVariable(string lpName, StringBuilder lpValue, int size);
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static UInt32 GetCurrentProcessId();
    internal static bool GetUserName(StringBuilder lpBuffer, Int32& nSize);
    internal static int GetComputerName(StringBuilder nameBuffer, Int32& bufferSize);
    internal static int CoCreateGuid(Guid& guid);
    [ForceTokenStabilizationAttribute]
internal static IntPtr CoTaskMemAlloc(UIntPtr cb);
    internal static IntPtr CoTaskMemRealloc(IntPtr pv, UIntPtr cb);
    [ForceTokenStabilizationAttribute]
internal static void CoTaskMemFree(IntPtr ptr);
    internal static bool SetConsoleMode(IntPtr hConsoleHandle, int mode);
    internal static bool GetConsoleMode(IntPtr hConsoleHandle, Int32& mode);
    internal static bool Beep(int frequency, int duration);
    internal static bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO& lpConsoleScreenBufferInfo);
    internal static bool SetConsoleScreenBufferSize(IntPtr hConsoleOutput, COORD size);
    internal static COORD GetLargestConsoleWindowSize(IntPtr hConsoleOutput);
    internal static bool FillConsoleOutputCharacter(IntPtr hConsoleOutput, char character, int nLength, COORD dwWriteCoord, Int32& pNumCharsWritten);
    internal static bool FillConsoleOutputAttribute(IntPtr hConsoleOutput, short wColorAttribute, int numCells, COORD startCoord, Int32& pNumBytesWritten);
    internal static bool SetConsoleWindowInfo(IntPtr hConsoleOutput, bool absolute, SMALL_RECT* consoleWindow);
    internal static bool SetConsoleTextAttribute(IntPtr hConsoleOutput, short attributes);
    internal static bool SetConsoleCursorPosition(IntPtr hConsoleOutput, COORD cursorPosition);
    internal static bool GetConsoleCursorInfo(IntPtr hConsoleOutput, CONSOLE_CURSOR_INFO& cci);
    internal static bool SetConsoleCursorInfo(IntPtr hConsoleOutput, CONSOLE_CURSOR_INFO& cci);
    internal static bool SetConsoleTitle(string title);
    internal static bool ReadConsoleInput(IntPtr hConsoleInput, InputRecord& buffer, int numInputRecords_UseOne, Int32& numEventsRead);
    internal static bool PeekConsoleInput(IntPtr hConsoleInput, InputRecord& buffer, int numInputRecords_UseOne, Int32& numEventsRead);
    internal static bool ReadConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO* pBuffer, COORD bufferSize, COORD bufferCoord, SMALL_RECT& readRegion);
    internal static bool ReadConsoleW(SafeFileHandle hConsoleInput, Byte* lpBuffer, int nNumberOfCharsToRead, Int32& lpNumberOfCharsRead, IntPtr pInputControl);
    internal static bool WriteConsoleOutput(IntPtr hConsoleOutput, CHAR_INFO* buffer, COORD bufferSize, COORD bufferCoord, SMALL_RECT& writeRegion);
    internal static bool WriteConsoleW(SafeFileHandle hConsoleOutput, Byte* lpBuffer, int nNumberOfCharsToWrite, Int32& lpNumberOfCharsWritten, IntPtr lpReservedMustBeNull);
    internal static short GetKeyState(int virtualKeyCode);
    internal static UInt32 GetConsoleCP();
    internal static bool SetConsoleCP(UInt32 codePage);
    internal static UInt32 GetConsoleOutputCP();
    internal static bool SetConsoleOutputCP(UInt32 codePage);
    internal static int RegConnectRegistry(string machineName, SafeRegistryHandle key, SafeRegistryHandle& result);
    internal static int RegCreateKeyEx(SafeRegistryHandle hKey, string lpSubKey, int Reserved, string lpClass, int dwOptions, int samDesired, SECURITY_ATTRIBUTES lpSecurityAttributes, SafeRegistryHandle& hkResult, Int32& lpdwDisposition);
    internal static int RegDeleteKey(SafeRegistryHandle hKey, string lpSubKey);
    internal static int RegDeleteKeyEx(SafeRegistryHandle hKey, string lpSubKey, int samDesired, int Reserved);
    internal static int RegDeleteValue(SafeRegistryHandle hKey, string lpValueName);
    internal static int RegEnumKeyEx(SafeRegistryHandle hKey, int dwIndex, Char* lpName, Int32& lpcbName, Int32[] lpReserved, StringBuilder lpClass, Int32[] lpcbClass, Int64[] lpftLastWriteTime);
    internal static int RegEnumValue(SafeRegistryHandle hKey, int dwIndex, Char* lpValueName, Int32& lpcbValueName, IntPtr lpReserved_MustBeZero, Int32[] lpType, Byte[] lpData, Int32[] lpcbData);
    internal static int RegFlushKey(SafeRegistryHandle hKey);
    internal static int RegOpenKeyEx(SafeRegistryHandle hKey, string lpSubKey, int ulOptions, int samDesired, SafeRegistryHandle& hkResult);
    internal static int RegOpenKeyEx(IntPtr hKey, string lpSubKey, int ulOptions, int samDesired, SafeRegistryHandle& hkResult);
    internal static int RegQueryInfoKey(SafeRegistryHandle hKey, StringBuilder lpClass, Int32[] lpcbClass, IntPtr lpReserved_MustBeZero, Int32& lpcSubKeys, Int32[] lpcbMaxSubKeyLen, Int32[] lpcbMaxClassLen, Int32& lpcValues, Int32[] lpcbMaxValueNameLen, Int32[] lpcbMaxValueLen, Int32[] lpcbSecurityDescriptor, Int32[] lpftLastWriteTime);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Byte[] lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Int32& lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Int64& lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Char[] lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, StringBuilder lpData, Int32& lpcbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Byte[] lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Int32& lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Int64& lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, string lpData, int cbData);
    internal static int ExpandEnvironmentStrings(string lpSrc, StringBuilder lpDst, int nSize);
    internal static IntPtr LocalReAlloc(IntPtr handle, IntPtr sizetcbBytes, int uFlags);
    internal static int SHGetFolderPath(IntPtr hwndOwner, int nFolder, IntPtr hToken, int dwFlags, StringBuilder lpszPath);
    internal static byte GetUserNameEx(int format, StringBuilder domainName, UInt32& domainNameLen);
    internal static bool LookupAccountName(string machineName, string accountName, Byte[] sid, Int32& sidLen, StringBuilder domainName, UInt32& domainNameLen, Int32& peUse);
    internal static IntPtr GetProcessWindowStation();
    internal static bool GetUserObjectInformation(IntPtr hObj, int nIndex, USEROBJECTFLAGS pvBuffer, int nLength, Int32& lpnLengthNeeded);
    internal static IntPtr SendMessageTimeout(IntPtr hWnd, int Msg, IntPtr wParam, string lParam, UInt32 fuFlags, UInt32 uTimeout, IntPtr lpdwResult);
    [ReliabilityContractAttribute("3", "2")]
internal static int SystemFunction040(SafeBSTRHandle pDataIn, UInt32 cbDataIn, UInt32 dwFlags);
    internal static int SystemFunction041(SafeBSTRHandle pDataIn, UInt32 cbDataIn, UInt32 dwFlags);
    internal static int LsaNtStatusToWinError(int status);
    internal static UInt32 BCryptGetFipsAlgorithmMode(Boolean& pfEnabled);
    [ReliabilityContractAttribute("3", "1")]
internal static bool AdjustTokenPrivileges(SafeTokenHandle TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGE& NewState, UInt32 BufferLength, TOKEN_PRIVILEGE& PreviousState, UInt32& ReturnLength);
    internal static bool AllocateLocallyUniqueId(LUID& Luid);
    internal static bool CheckTokenMembership(SafeTokenHandle TokenHandle, Byte[] SidToCheck, Boolean& IsMember);
    internal static int ConvertSdToStringSd(Byte[] securityDescriptor, UInt32 requestedRevision, UInt32 securityInformation, IntPtr& resultString, UInt32& resultStringLength);
    internal static int ConvertStringSdToSd(string stringSd, UInt32 stringSdRevision, IntPtr& resultSd, UInt32& resultSdLength);
    internal static int ConvertStringSidToSid(string stringSid, IntPtr& ByteArray);
    internal static bool ConvertSidToStringSid(IntPtr Sid, IntPtr& StringSid);
    internal static int CreateWellKnownSid(int sidType, Byte[] domainSid, Byte[] resultSid, UInt32& resultSidLength);
    internal static bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, SafeTokenHandle& lpTargetHandle, UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwOptions);
    [ReliabilityContractAttribute("3", "1")]
internal static bool DuplicateHandle(IntPtr hSourceProcessHandle, SafeTokenHandle hSourceHandle, IntPtr hTargetProcessHandle, SafeTokenHandle& lpTargetHandle, UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwOptions);
    [ReliabilityContractAttribute("3", "1")]
internal static bool DuplicateTokenEx(SafeTokenHandle ExistingTokenHandle, TokenAccessLevels DesiredAccess, IntPtr TokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TokenType TokenType, SafeTokenHandle& DuplicateTokenHandle);
    internal static bool DuplicateTokenEx(SafeTokenHandle hExistingToken, UInt32 dwDesiredAccess, IntPtr lpTokenAttributes, UInt32 ImpersonationLevel, UInt32 TokenType, SafeTokenHandle& phNewToken);
    internal static int IsEqualDomainSid(Byte[] sid1, Byte[] sid2, Boolean& result);
    internal static IntPtr GetCurrentProcess();
    internal static IntPtr GetCurrentThread();
    internal static UInt32 GetSecurityDescriptorLength(IntPtr byteArray);
    internal static UInt32 GetSecurityInfoByHandle(SafeHandle handle, UInt32 objectType, UInt32 securityInformation, IntPtr& sidOwner, IntPtr& sidGroup, IntPtr& dacl, IntPtr& sacl, IntPtr& securityDescriptor);
    internal static UInt32 GetSecurityInfoByName(string name, UInt32 objectType, UInt32 securityInformation, IntPtr& sidOwner, IntPtr& sidGroup, IntPtr& dacl, IntPtr& sacl, IntPtr& securityDescriptor);
    internal static bool GetTokenInformation(IntPtr TokenHandle, UInt32 TokenInformationClass, SafeLocalAllocHandle TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    internal static bool GetTokenInformation(SafeTokenHandle TokenHandle, UInt32 TokenInformationClass, SafeLocalAllocHandle TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    internal static int GetWindowsAccountDomainSid(Byte[] sid, Byte[] resultSid, UInt32& resultSidLength);
    internal static int IsWellKnownSid(Byte[] sid, int type);
    internal static UInt32 LsaOpenPolicy(string systemName, LSA_OBJECT_ATTRIBUTES& attributes, int accessMask, SafeLsaPolicyHandle& handle);
    [ReliabilityContractAttribute("3", "1")]
internal static bool LookupPrivilegeValue(string lpSystemName, string lpName, LUID& Luid);
    internal static UInt32 LsaLookupSids(SafeLsaPolicyHandle handle, int count, IntPtr[] sids, SafeLsaMemoryHandle& referencedDomains, SafeLsaMemoryHandle& names);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaFreeMemory(IntPtr handle);
    internal static UInt32 LsaLookupNames(SafeLsaPolicyHandle handle, int count, UNICODE_STRING[] names, SafeLsaMemoryHandle& referencedDomains, SafeLsaMemoryHandle& sids);
    internal static UInt32 LsaLookupNames2(SafeLsaPolicyHandle handle, int flags, int count, UNICODE_STRING[] names, SafeLsaMemoryHandle& referencedDomains, SafeLsaMemoryHandle& sids);
    internal static int LsaConnectUntrusted(SafeLsaLogonProcessHandle& LsaHandle);
    internal static int LsaGetLogonSessionData(LUID& LogonId, SafeLsaReturnBufferHandle& ppLogonSessionData);
    internal static int LsaLogonUser(SafeLsaLogonProcessHandle LsaHandle, UNICODE_INTPTR_STRING& OriginName, UInt32 LogonType, UInt32 AuthenticationPackage, IntPtr AuthenticationInformation, UInt32 AuthenticationInformationLength, IntPtr LocalGroups, TOKEN_SOURCE& SourceContext, SafeLsaReturnBufferHandle& ProfileBuffer, UInt32& ProfileBufferLength, LUID& LogonId, SafeTokenHandle& Token, QUOTA_LIMITS& Quotas, Int32& SubStatus);
    internal static int LsaLookupAuthenticationPackage(SafeLsaLogonProcessHandle LsaHandle, UNICODE_INTPTR_STRING& PackageName, UInt32& AuthenticationPackage);
    internal static int LsaRegisterLogonProcess(UNICODE_INTPTR_STRING& LogonProcessName, SafeLsaLogonProcessHandle& LsaHandle, IntPtr& SecurityMode);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaDeregisterLogonProcess(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaClose(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaFreeReturnBuffer(IntPtr handle);
    internal static bool OpenProcessToken(IntPtr ProcessToken, TokenAccessLevels DesiredAccess, SafeTokenHandle& TokenHandle);
    internal static UInt32 SetSecurityInfoByName(string name, UInt32 objectType, UInt32 securityInformation, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl);
    internal static UInt32 SetSecurityInfoByHandle(SafeHandle handle, UInt32 objectType, UInt32 securityInformation, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl);
    internal static int CreateAssemblyNameObject(IAssemblyName& ppEnum, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    internal static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, UInt32 dwFlags, IntPtr pvReserved);
    internal static bool QueryUnbiasedInterruptTime(UInt64& UnbiasedTime);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
internal class System.__Canon : object {
}
internal class System.__ComObject : MarshalByRefObject {
    [SecurityCriticalAttribute]
internal IntPtr GetIUnknown(Boolean& fIsURTAggregated);
    internal object GetData(object key);
    internal bool SetData(object key, object data);
    [SecurityCriticalAttribute]
internal void ReleaseAllData();
    [SecurityCriticalAttribute]
internal object GetEventProvider(RuntimeType t);
    [SecurityCriticalAttribute]
internal int ReleaseSelf();
    [SecurityCriticalAttribute]
internal void FinalReleaseSelf();
}
internal class System.__DTString : ValueType {
    internal string Value;
    internal int Index;
    internal int len;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    internal CompareInfo CompareInfo { get; }
    internal __DTString(string str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(string str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool Advance(int count);
    [SecurityCriticalAttribute]
internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    [SecurityCriticalAttribute]
internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWord(string target, int endIndex);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
internal class System.__Filters : object {
    internal virtual bool FilterAttribute(MemberInfo m, object filterCriteria);
    internal virtual bool FilterName(MemberInfo m, object filterCriteria);
    internal virtual bool FilterIgnoreCase(MemberInfo m, object filterCriteria);
}
internal static class System.__HResults : object {
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    internal static int E_FAIL;
    internal static int E_POINTER;
    internal static int E_NOTIMPL;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_COMEMULATE;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTMEMORY;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SAFEHANDLEMISSINGATTRIBUTE;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SEMAPHOREFULL;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_THREADSTOP;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_UNSUPPORTEDFORMAT;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_HOSTPROTECTION;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int NTE_FAIL;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int DISP_E_OVERFLOW;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int TYPE_E_TYPEMISMATCH;
}
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("05F696DC-2B29-3663-AD8B-C4389CF2A713")]
[ComVisibleAttribute("True")]
public interface System._AppDomain {
    public Evidence Evidence { get; }
    public string FriendlyName { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public bool ShadowCopyFiles { get; }
    public string DynamicDirectory { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    [SecurityCriticalAttribute]
public abstract virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
public abstract virtual object GetLifetimeService();
    public abstract virtual Evidence get_Evidence();
    public abstract virtual void add_DomainUnload(EventHandler value);
    public abstract virtual void remove_DomainUnload(EventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public abstract virtual void add_ProcessExit(EventHandler value);
    public abstract virtual void remove_ProcessExit(EventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void add_TypeResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_TypeResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void add_ResourceResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_ResourceResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void add_AssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_AssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public abstract virtual Assembly Load(AssemblyName assemblyRef);
    public abstract virtual Assembly Load(string assemblyString);
    public abstract virtual Assembly Load(Byte[] rawAssembly);
    public abstract virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public abstract virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    public abstract virtual Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    public abstract virtual Assembly Load(string assemblyString, Evidence assemblySecurity);
    public abstract virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
    public abstract virtual int ExecuteAssembly(string assemblyFile);
    public abstract virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args);
    public abstract virtual string get_FriendlyName();
    public abstract virtual string get_BaseDirectory();
    public abstract virtual string get_RelativeSearchPath();
    public abstract virtual bool get_ShadowCopyFiles();
    public abstract virtual Assembly[] GetAssemblies();
    [SecurityCriticalAttribute]
public abstract virtual void AppendPrivatePath(string path);
    [SecurityCriticalAttribute]
public abstract virtual void ClearPrivatePath();
    [SecurityCriticalAttribute]
public abstract virtual void SetShadowCopyPath(string s);
    [SecurityCriticalAttribute]
public abstract virtual void ClearShadowCopyPath();
    [SecurityCriticalAttribute]
public abstract virtual void SetCachePath(string s);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string name, object data);
    public abstract virtual object GetData(string name);
    [SecurityCriticalAttribute]
public abstract virtual void SetAppDomainPolicy(PolicyLevel domainPolicy);
    public abstract virtual void SetThreadPrincipal(IPrincipal principal);
    public abstract virtual void SetPrincipalPolicy(PrincipalPolicy policy);
    public abstract virtual void DoCallBack(CrossAppDomainDelegate theDelegate);
    public abstract virtual string get_DynamicDirectory();
}
[ComVisibleAttribute("True")]
public class System.AccessViolationException : SystemException {
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("False")]
public class System.ActivationContext : object {
    public ApplicationIdentity Identity { get; }
    public ContextForm Form { get; }
    public Byte[] ApplicationManifestBytes { get; }
    public Byte[] DeploymentManifestBytes { get; }
    internal String[] ManifestPaths { get; }
    internal string ApplicationDirectory { get; }
    internal string DataDirectory { get; }
    internal ICMS ActivationContextData { get; }
    internal ICMS DeploymentComponentManifest { get; }
    internal ICMS ApplicationComponentManifest { get; }
    internal ApplicationStateDisposition LastApplicationStateResult { get; }
    internal ActivationContext(ApplicationIdentity applicationIdentity);
    internal ActivationContext(ApplicationIdentity applicationIdentity, String[] manifestPaths);
    protected virtual void Finalize();
    public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity);
    public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, String[] manifestPaths);
    public ApplicationIdentity get_Identity();
    public ContextForm get_Form();
    public Byte[] get_ApplicationManifestBytes();
    public Byte[] get_DeploymentManifestBytes();
    internal String[] get_ManifestPaths();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
internal string get_ApplicationDirectory();
    [SecurityCriticalAttribute]
internal string get_DataDirectory();
    [SecurityCriticalAttribute]
internal ICMS get_ActivationContextData();
    [SecurityCriticalAttribute]
internal ICMS get_DeploymentComponentManifest();
    [SecurityCriticalAttribute]
internal ICMS get_ApplicationComponentManifest();
    internal ApplicationStateDisposition get_LastApplicationStateResult();
    [SecurityCriticalAttribute]
internal ICMS GetComponentManifest(IDefinitionIdentity component);
    [SecuritySafeCriticalAttribute]
internal Byte[] GetDeploymentManifestBytes();
    [SecuritySafeCriticalAttribute]
internal Byte[] GetApplicationManifestBytes();
    [SecuritySafeCriticalAttribute]
internal void PrepareForExecution();
    [SecuritySafeCriticalAttribute]
internal ApplicationStateDisposition SetApplicationState(ApplicationState s);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Activator")]
public class System.Activator : object {
    internal static int LookupMask;
    internal static BindingFlags ConLookup;
    internal static BindingFlags ConstructorDefault;
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type, bool nonPublic);
    public static T CreateInstance();
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
internal static ObjectHandle CreateInstance(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo, StackCrawlMark& stackMark);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecurityCriticalAttribute]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(ActivationContext activationContext);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [SecurityCriticalAttribute]
public static object GetObject(Type type, string url);
    [SecurityCriticalAttribute]
public static object GetObject(Type type, string url, object state);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Activator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
public class System.AggregateException : Exception {
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    [SecurityCriticalAttribute]
protected AggregateException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string ToString();
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System._AppDomain")]
[ComVisibleAttribute("True")]
public class System.AppDomain : MarshalByRefObject {
    internal static string TargetFrameworkNameAppCompatSetting;
    internal static int DefaultADID;
    internal static bool ProfileAPICheck { get; }
    internal static bool IsAppXNGen { get; }
    internal String[] PartialTrustVisibleAssemblies { get; internal set; }
    public AppDomainManager DomainManager { get; }
    internal HostSecurityManager HostSecurityManager { get; }
    public static AppDomain CurrentDomain { get; }
    public Evidence Evidence { get; }
    internal Evidence EvidenceNoDemand { get; }
    internal Evidence InternalEvidence { get; }
    public string FriendlyName { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public bool ShadowCopyFiles { get; }
    public ActivationContext ActivationContext { get; }
    public ApplicationIdentity ApplicationIdentity { get; }
    public ApplicationTrust ApplicationTrust { get; }
    public string DynamicDirectory { get; }
    internal DomainSpecificRemotingData RemotingData { get; }
    internal AppDomainSetup FusionStore { get; }
    public AppDomainSetup SetupInformation { get; }
    public PermissionSet PermissionSet { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    internal bool IsLegacyCasPolicyEnabled { get; }
    public int Id { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    [SecurityCriticalAttribute]
public sealed virtual void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void add_TypeResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void remove_TypeResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void add_ResourceResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void remove_ResourceResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void add_AssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void remove_AssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [SecuritySafeCriticalAttribute]
internal static bool get_ProfileAPICheck();
    [SecuritySafeCriticalAttribute]
internal static bool get_IsAppXNGen();
    public sealed virtual Type GetType();
    internal AppDomainHandle GetNativeHandle();
    [SecuritySafeCriticalAttribute]
internal string GetTargetFrameworkName();
    [SecuritySafeCriticalAttribute]
internal bool DisableFusionUpdatesFromADManager();
    [SecuritySafeCriticalAttribute]
internal static bool IsAppXModel();
    [SecuritySafeCriticalAttribute]
internal static bool IsAppXDesignMode();
    [SecuritySafeCriticalAttribute]
internal static void CheckLoadFromSupported();
    [SecuritySafeCriticalAttribute]
internal static void CheckLoadFileSupported();
    [SecuritySafeCriticalAttribute]
internal static void CheckReflectionOnlyLoadSupported();
    [SecuritySafeCriticalAttribute]
internal static void CheckLoadWithPartialNameSupported(StackCrawlMark stackMark);
    [SecuritySafeCriticalAttribute]
internal static void CheckDefinePInvokeSupported();
    [SecuritySafeCriticalAttribute]
internal static void CheckLoadByteArraySupported();
    [SecuritySafeCriticalAttribute]
internal static void CheckCreateDomainSupported();
    [SecuritySafeCriticalAttribute]
internal void GetAppDomainManagerType(String& assembly, String& type);
    internal String[] get_PartialTrustVisibleAssemblies();
    [SecuritySafeCriticalAttribute]
internal void set_PartialTrustVisibleAssemblies(String[] value);
    [SecurityCriticalAttribute]
public AppDomainManager get_DomainManager();
    [SecurityCriticalAttribute]
internal HostSecurityManager get_HostSecurityManager();
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    [SecuritySafeCriticalAttribute]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    [SecuritySafeCriticalAttribute]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes, SecurityContextSource securityContextSource);
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    [SecuritySafeCriticalAttribute]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    [ComVisibleAttribute("False")]
public string ApplyPolicy(string assemblyName);
    public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName);
    [SecurityCriticalAttribute]
internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName);
    public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [SecurityCriticalAttribute]
internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName);
    public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
    public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(AssemblyName assemblyRef);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(string assemblyString);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(Byte[] rawAssembly);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")]
public sealed virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual Assembly Load(string assemblyString, Evidence assemblySecurity);
    public sealed virtual int ExecuteAssembly(string assemblyFile);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssemblyByName(string assemblyName);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, String[] args);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, String[] args);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public static AppDomain get_CurrentDomain();
    [SecuritySafeCriticalAttribute]
public sealed virtual Evidence get_Evidence();
    [SecurityCriticalAttribute]
internal Evidence get_EvidenceNoDemand();
    internal Evidence get_InternalEvidence();
    internal EvidenceBase GetHostEvidence(Type type);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_FriendlyName();
    public sealed virtual string get_BaseDirectory();
    public sealed virtual string get_RelativeSearchPath();
    public sealed virtual bool get_ShadowCopyFiles();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public sealed virtual Assembly[] GetAssemblies();
    public Assembly[] ReflectionOnlyGetAssemblies();
    [SecurityCriticalAttribute]
internal bool IsUnloadingForcedFinalize();
    [SecuritySafeCriticalAttribute]
public bool IsFinalizingForUnload();
    [SecurityCriticalAttribute]
internal static void PublishAnonymouslyHostedDynamicMethodsAssembly(RuntimeAssembly assemblyHandle);
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
public sealed virtual void AppendPrivatePath(string path);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public sealed virtual void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
public sealed virtual void ClearShadowCopyPath();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
public sealed virtual void SetCachePath(string path);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string name, object data);
    [SecurityCriticalAttribute]
public void SetData(string name, object data, IPermission permission);
    [SecuritySafeCriticalAttribute]
public sealed virtual object GetData(string name);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    [ReliabilityContractAttribute("1", "1")]
[SecuritySafeCriticalAttribute]
public static void Unload(AppDomain domain);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual void SetAppDomainPolicy(PolicyLevel domainPolicy);
    [SecurityCriticalAttribute]
public ActivationContext get_ActivationContext();
    [SecurityCriticalAttribute]
public ApplicationIdentity get_ApplicationIdentity();
    [SecurityCriticalAttribute]
public ApplicationTrust get_ApplicationTrust();
    [SecuritySafeCriticalAttribute]
public sealed virtual void SetThreadPrincipal(IPrincipal principal);
    [SecuritySafeCriticalAttribute]
public sealed virtual void SetPrincipalPolicy(PrincipalPolicy policy);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    public sealed virtual void DoCallBack(CrossAppDomainDelegate callBackDelegate);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_DynamicDirectory();
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    public static AppDomain CreateDomain(string friendlyName);
    internal int nExecuteAssembly(RuntimeAssembly assembly, String[] args);
    internal void CreateRemotingData();
    internal DomainSpecificRemotingData get_RemotingData();
    [SecuritySafeCriticalAttribute]
public sealed virtual void add_ProcessExit(EventHandler value);
    public sealed virtual void remove_ProcessExit(EventHandler value);
    [SecuritySafeCriticalAttribute]
public sealed virtual void add_DomainUnload(EventHandler value);
    public sealed virtual void remove_DomainUnload(EventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [SecurityCriticalAttribute]
public sealed virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [SecurityCriticalAttribute]
public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [SecurityCriticalAttribute]
public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    internal AppDomainSetup get_FusionStore();
    internal static RuntimeAssembly GetRuntimeAssembly(Assembly asm);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static int GetIdForUnload(AppDomain domain);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static bool IsDomainIdValid(int id);
    [SecurityCriticalAttribute]
internal static AppDomain GetDefaultDomain();
    internal IPrincipal GetThreadPrincipal();
    [SecurityCriticalAttribute]
internal void CreateDefaultContext();
    [SecurityCriticalAttribute]
internal Context GetDefaultContext();
    [SecuritySafeCriticalAttribute]
internal static void CheckDomainCreationEvidence(AppDomainSetup creationDomainSetup, Evidence creationEvidence);
    [SecuritySafeCriticalAttribute]
public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info);
    [SecurityCriticalAttribute]
internal static AppDomain InternalCreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, StrongName[] fullTrustAssemblies);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, String[] adInitArgs);
    [SecurityCriticalAttribute]
internal IntPtr GetFusionContext();
    [SecurityCriticalAttribute]
internal IntPtr GetSecurityDescriptor();
    [SecurityCriticalAttribute]
internal static AppDomain nCreateDomain(string friendlyName, AppDomainSetup setup, Evidence providedSecurityInfo, Evidence creatorsSecurityInfo, IntPtr parentSecurityDescriptor);
    [SecurityCriticalAttribute]
internal static ObjRef nCreateInstance(string friendlyName, AppDomainSetup setup, Evidence providedSecurityInfo, Evidence creatorsSecurityInfo, IntPtr parentSecurityDescriptor);
    [SecurityCriticalAttribute]
internal void UpdateLoaderOptimization(LoaderOptimization optimization);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public sealed virtual void SetShadowCopyPath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
public void SetShadowCopyFiles();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    public AppDomainSetup get_SetupInformation();
    [SecurityCriticalAttribute]
internal void InternalSetShadowCopyPath(string path);
    [SecurityCriticalAttribute]
internal void InternalSetShadowCopyFiles();
    [SecurityCriticalAttribute]
internal void InternalSetCachePath(string path);
    [SecurityCriticalAttribute]
internal void InternalSetPrivateBinPath(string path);
    [SecurityCriticalAttribute]
internal void InternalSetDynamicBase(string path);
    [SecurityCriticalAttribute]
internal string IsStringInterned(string str);
    [SecurityCriticalAttribute]
internal string GetOrInternString(string str);
    [SecurityCriticalAttribute]
public PermissionSet get_PermissionSet();
    [SecuritySafeCriticalAttribute]
public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    [SecuritySafeCriticalAttribute]
internal bool get_IsLegacyCasPolicyEnabled();
    [SecuritySafeCriticalAttribute]
internal PermissionSet GetHomogenousGrantSet(Evidence evidence);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("1", "1")]
internal static void nUnload(int domainInternal);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName);
    public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [ReliabilityContractAttribute("3", "2")]
public int get_Id();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal int GetId();
    public bool IsDefaultAppDomain();
    [SecurityCriticalAttribute]
public static bool get_MonitoringIsEnabled();
    [SecurityCriticalAttribute]
public static void set_MonitoringIsEnabled(bool value);
    [SecurityCriticalAttribute]
public TimeSpan get_MonitoringTotalProcessorTime();
    [SecurityCriticalAttribute]
public long get_MonitoringTotalAllocatedMemorySize();
    [SecurityCriticalAttribute]
public long get_MonitoringSurvivedMemorySize();
    [SecurityCriticalAttribute]
public static long get_MonitoringSurvivedProcessMemorySize();
    private sealed virtual override void System._AppDomain.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System._AppDomain.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System._AppDomain.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System._AppDomain.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.AppDomainHandle : ValueType {
    private IntPtr m_appDomainHandle;
    internal AppDomainHandle(IntPtr domainHandle);
}
[ComVisibleAttribute("True")]
public class System.AppDomainInitializer : MulticastDelegate {
    public AppDomainInitializer(object object, IntPtr method);
    public virtual void Invoke(String[] args);
    public virtual IAsyncResult BeginInvoke(String[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.AppDomainInitializerInfo : object {
    internal ItemInfo[] Info;
    internal AppDomainInitializerInfo(AppDomainInitializer init);
    [SecuritySafeCriticalAttribute]
internal AppDomainInitializer Unwrap();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.AppDomainManager : MarshalByRefObject {
    public AppDomainManagerInitializationOptions InitializationFlags { get; public set; }
    public ApplicationActivator ApplicationActivator { get; }
    public HostSecurityManager HostSecurityManager { get; }
    public HostExecutionContextManager HostExecutionContextManager { get; }
    public Assembly EntryAssembly { get; }
    internal static AppDomainManager CurrentAppDomainManager { get; }
    [SecurityCriticalAttribute]
public virtual AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
    [SecurityCriticalAttribute]
protected static AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
    [SecurityCriticalAttribute]
public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
    public AppDomainManagerInitializationOptions get_InitializationFlags();
    public void set_InitializationFlags(AppDomainManagerInitializationOptions value);
    public virtual ApplicationActivator get_ApplicationActivator();
    public virtual HostSecurityManager get_HostSecurityManager();
    public virtual HostExecutionContextManager get_HostExecutionContextManager();
    [SecurityCriticalAttribute]
public virtual Assembly get_EntryAssembly();
    [SecurityCriticalAttribute]
internal static AppDomainManager get_CurrentAppDomainManager();
    public virtual bool CheckSecuritySettings(SecurityState state);
    internal void RegisterWithHost();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.AppDomainManagerInitializationOptions : Enum {
    public int value__;
    public static AppDomainManagerInitializationOptions None;
    public static AppDomainManagerInitializationOptions RegisterWithHost;
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.AppDomainSetup : object {
    internal AppDomainSortingSetupInfo _AppDomainSortingSetupInfo;
    internal String[] Value { get; }
    public string AppDomainManagerAssembly { get; public set; }
    public string AppDomainManagerType { get; public set; }
    public String[] PartialTrustVisibleAssemblies { get; public set; }
    public string ApplicationBase { get; public set; }
    internal static string ApplicationBaseKey { get; }
    public string ConfigurationFile { get; public set; }
    internal string ConfigurationFileInternal { get; }
    internal static string ConfigurationFileKey { get; }
    public string TargetFrameworkName { get; public set; }
    internal bool CheckedForTargetFrameworkName { get; internal set; }
    public string DynamicBase { get; public set; }
    internal static string DynamicBaseKey { get; }
    public bool DisallowPublisherPolicy { get; public set; }
    public bool DisallowBindingRedirects { get; public set; }
    public bool DisallowCodeDownload { get; public set; }
    public bool DisallowApplicationBaseProbing { get; public set; }
    internal string DeveloperPath { get; internal set; }
    internal static string DisallowPublisherPolicyKey { get; }
    internal static string DisallowCodeDownloadKey { get; }
    internal static string DisallowBindingRedirectsKey { get; }
    internal static string DeveloperPathKey { get; }
    internal static string DisallowAppBaseProbingKey { get; }
    public string ApplicationName { get; public set; }
    internal static string ApplicationNameKey { get; }
    [XmlIgnoreMemberAttribute]
public AppDomainInitializer AppDomainInitializer { get; public set; }
    public String[] AppDomainInitializerArguments { get; public set; }
    [XmlIgnoreMemberAttribute]
public ActivationArguments ActivationArguments { get; public set; }
    [XmlIgnoreMemberAttribute]
public ApplicationTrust ApplicationTrust { get; public set; }
    public string PrivateBinPath { get; public set; }
    internal static string PrivateBinPathKey { get; }
    public string PrivateBinPathProbe { get; public set; }
    internal static string PrivateBinPathProbeKey { get; }
    public string ShadowCopyDirectories { get; public set; }
    internal static string ShadowCopyDirectoriesKey { get; }
    public string ShadowCopyFiles { get; public set; }
    internal static string ShadowCopyFilesKey { get; }
    public string CachePath { get; public set; }
    internal static string CachePathKey { get; }
    public string LicenseFile { get; public set; }
    public LoaderOptimization LoaderOptimization { get; public set; }
    internal static string LoaderOptimizationKey { get; }
    internal static string ConfigurationExtension { get; }
    internal static string PrivateBinPathEnvironmentVariable { get; }
    internal static string RuntimeConfigurationFile { get; }
    internal static string MachineConfigKey { get; }
    internal static string HostBindingKey { get; }
    public bool SandboxInterop { get; public set; }
    [SecuritySafeCriticalAttribute]
internal AppDomainSetup(AppDomainSetup copy, bool copyDomainBoundData);
    public AppDomainSetup(ActivationContext activationContext);
    [SecuritySafeCriticalAttribute]
public AppDomainSetup(ActivationArguments activationArguments);
    internal void SetupDefaults(string imageLocation, bool imageLocationAlreadyNormalized);
    internal String[] get_Value();
    internal string GetUnsecureApplicationBase();
    public string get_AppDomainManagerAssembly();
    public void set_AppDomainManagerAssembly(string value);
    public string get_AppDomainManagerType();
    public void set_AppDomainManagerType(string value);
    public String[] get_PartialTrustVisibleAssemblies();
    public void set_PartialTrustVisibleAssemblies(String[] value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ApplicationBase();
    public sealed virtual void set_ApplicationBase(string value);
    internal static string get_ApplicationBaseKey();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ConfigurationFile();
    public sealed virtual void set_ConfigurationFile(string value);
    internal string get_ConfigurationFileInternal();
    internal static string get_ConfigurationFileKey();
    public Byte[] GetConfigurationBytes();
    public void SetConfigurationBytes(Byte[] value);
    internal Dictionary`2<string, object> GetCompatibilityFlags();
    public void SetCompatibilitySwitches(IEnumerable`1<string> switches);
    public string get_TargetFrameworkName();
    public void set_TargetFrameworkName(string value);
    internal bool get_CheckedForTargetFrameworkName();
    internal void set_CheckedForTargetFrameworkName(bool value);
    [SecurityCriticalAttribute]
public void SetNativeFunction(string functionName, int functionVersion, IntPtr functionPointer);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_DynamicBase();
    [SecuritySafeCriticalAttribute]
public sealed virtual void set_DynamicBase(string value);
    internal static string get_DynamicBaseKey();
    public bool get_DisallowPublisherPolicy();
    public void set_DisallowPublisherPolicy(bool value);
    public bool get_DisallowBindingRedirects();
    public void set_DisallowBindingRedirects(bool value);
    public bool get_DisallowCodeDownload();
    public void set_DisallowCodeDownload(bool value);
    public bool get_DisallowApplicationBaseProbing();
    public void set_DisallowApplicationBaseProbing(bool value);
    [SecurityCriticalAttribute]
internal string get_DeveloperPath();
    internal void set_DeveloperPath(string value);
    internal static string get_DisallowPublisherPolicyKey();
    internal static string get_DisallowCodeDownloadKey();
    internal static string get_DisallowBindingRedirectsKey();
    internal static string get_DeveloperPathKey();
    internal static string get_DisallowAppBaseProbingKey();
    public sealed virtual string get_ApplicationName();
    public sealed virtual void set_ApplicationName(string value);
    internal static string get_ApplicationNameKey();
    public AppDomainInitializer get_AppDomainInitializer();
    public void set_AppDomainInitializer(AppDomainInitializer value);
    public String[] get_AppDomainInitializerArguments();
    public void set_AppDomainInitializerArguments(String[] value);
    public ActivationArguments get_ActivationArguments();
    public void set_ActivationArguments(ActivationArguments value);
    internal ApplicationTrust InternalGetApplicationTrust();
    internal void InternalSetApplicationTrust(ApplicationTrust value);
    public ApplicationTrust get_ApplicationTrust();
    public void set_ApplicationTrust(ApplicationTrust value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_PrivateBinPath();
    public sealed virtual void set_PrivateBinPath(string value);
    internal static string get_PrivateBinPathKey();
    public sealed virtual string get_PrivateBinPathProbe();
    public sealed virtual void set_PrivateBinPathProbe(string value);
    internal static string get_PrivateBinPathProbeKey();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ShadowCopyDirectories();
    public sealed virtual void set_ShadowCopyDirectories(string value);
    internal static string get_ShadowCopyDirectoriesKey();
    public sealed virtual string get_ShadowCopyFiles();
    public sealed virtual void set_ShadowCopyFiles(string value);
    internal static string get_ShadowCopyFilesKey();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_CachePath();
    public sealed virtual void set_CachePath(string value);
    internal static string get_CachePathKey();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_LicenseFile();
    public sealed virtual void set_LicenseFile(string value);
    public LoaderOptimization get_LoaderOptimization();
    public void set_LoaderOptimization(LoaderOptimization value);
    internal static string get_LoaderOptimizationKey();
    internal static string get_ConfigurationExtension();
    internal static string get_PrivateBinPathEnvironmentVariable();
    internal static string get_RuntimeConfigurationFile();
    internal static string get_MachineConfigKey();
    internal static string get_HostBindingKey();
    [SecurityCriticalAttribute]
internal bool UpdateContextPropertyIfNeeded(LoaderInformation FieldValue, string FieldKey, string UpdatedField, IntPtr fusionContext, AppDomainSetup oldADS);
    [SecurityCriticalAttribute]
internal void UpdateBooleanContextPropertyIfNeeded(LoaderInformation FieldValue, string FieldKey, IntPtr fusionContext, AppDomainSetup oldADS);
    [SecurityCriticalAttribute]
internal static bool ByteArraysAreDifferent(Byte[] A, Byte[] B);
    [SecurityCriticalAttribute]
internal static void UpdateByteArrayContextPropertyIfNeeded(Byte[] NewArray, Byte[] OldArray, string FieldKey, IntPtr fusionContext);
    [SecurityCriticalAttribute]
internal void SetupFusionContext(IntPtr fusionContext, AppDomainSetup oldADS);
    [SecurityCriticalAttribute]
internal static void UpdateContextProperty(IntPtr fusionContext, string key, object value);
    internal static int Locate(string s);
    public bool get_SandboxInterop();
    public void set_SandboxInterop(bool value);
}
[ComVisibleAttribute("True")]
public class System.AppDomainUnloadedException : SystemException {
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.ApplicationId : object {
    internal Byte[] m_publicKeyToken;
    public Byte[] PublicKeyToken { get; }
    public string Name { get; }
    public Version Version { get; }
    public string ProcessorArchitecture { get; }
    public string Culture { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    public Byte[] get_PublicKeyToken();
    public string get_Name();
    public Version get_Version();
    public string get_ProcessorArchitecture();
    public string get_Culture();
    public ApplicationId Copy();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("False")]
public class System.ApplicationIdentity : object {
    public string FullName { get; }
    public string CodeBase { get; }
    internal IDefinitionAppId Identity { get; }
    [SecuritySafeCriticalAttribute]
public ApplicationIdentity(string applicationIdentityFullName);
    [SecurityCriticalAttribute]
internal ApplicationIdentity(IDefinitionAppId applicationIdentity);
    [SecuritySafeCriticalAttribute]
public string get_FullName();
    [SecuritySafeCriticalAttribute]
public string get_CodeBase();
    public virtual string ToString();
    [SecurityCriticalAttribute]
internal IDefinitionAppId get_Identity();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArgIterator : ValueType {
    private IntPtr ArgCookie;
    private IntPtr sigPtr;
    private IntPtr sigPtrLen;
    private IntPtr ArgPtr;
    private int RemainingArgs;
    [SecuritySafeCriticalAttribute]
public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    public void End();
    [SecuritySafeCriticalAttribute]
public int GetRemainingCount();
    [SecuritySafeCriticalAttribute]
public RuntimeTypeHandle GetNextArgType();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
[ComVisibleAttribute("True")]
public class System.ArgumentException : SystemException {
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    [SecurityCriticalAttribute]
protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual object get_ActualValue();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public abstract class System.Array : object {
    internal static int MaxArrayLength;
    public int Length { get; }
    [ComVisibleAttribute("False")]
public long LongLength { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    [ReliabilityContractAttribute("3", "1")]
public static void Resize(T[]& array, int newSize);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, int length);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, int length1, int length2);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    [SecurityCriticalAttribute]
internal static Array UnsafeCreateInstance(Type elementType, int length);
    [SecurityCriticalAttribute]
internal static Array UnsafeCreateInstance(Type elementType, int length1, int length2);
    [SecurityCriticalAttribute]
internal static Array UnsafeCreateInstance(Type elementType, Int32[] lengths);
    [SecurityCriticalAttribute]
internal static Array UnsafeCreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("2", "1")]
public static void Copy(Array sourceArray, Array destinationArray, int length);
    [ReliabilityContractAttribute("2", "1")]
[SecuritySafeCriticalAttribute]
public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    [ReliabilityContractAttribute("2", "1")]
[SecurityCriticalAttribute]
internal static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Copy(Array sourceArray, Array destinationArray, long length);
    [ReliabilityContractAttribute("2", "1")]
public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void Clear(Array array, int index, int length);
    [SecuritySafeCriticalAttribute]
public object GetValue(Int32[] indices);
    [SecuritySafeCriticalAttribute]
public object GetValue(int index);
    [SecuritySafeCriticalAttribute]
public object GetValue(int index1, int index2);
    [SecuritySafeCriticalAttribute]
public object GetValue(int index1, int index2, int index3);
    [ComVisibleAttribute("False")]
public object GetValue(long index);
    [ComVisibleAttribute("False")]
public object GetValue(long index1, long index2);
    [ComVisibleAttribute("False")]
public object GetValue(long index1, long index2, long index3);
    [ComVisibleAttribute("False")]
public object GetValue(Int64[] indices);
    [SecuritySafeCriticalAttribute]
public void SetValue(object value, int index);
    [SecuritySafeCriticalAttribute]
public void SetValue(object value, int index1, int index2);
    [SecuritySafeCriticalAttribute]
public void SetValue(object value, int index1, int index2, int index3);
    [SecuritySafeCriticalAttribute]
public void SetValue(object value, Int32[] indices);
    [ComVisibleAttribute("False")]
public void SetValue(object value, long index);
    [ComVisibleAttribute("False")]
public void SetValue(object value, long index1, long index2);
    [ComVisibleAttribute("False")]
public void SetValue(object value, long index1, long index2, long index3);
    [ComVisibleAttribute("False")]
public void SetValue(object value, Int64[] indices);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public int get_Length();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public long get_LongLength();
    [SecuritySafeCriticalAttribute]
public int GetLength(int dimension);
    [ComVisibleAttribute("False")]
public long GetLongLength(int dimension);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public int get_Rank();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public int GetUpperBound(int dimension);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public int GetLowerBound(int dimension);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal int GetDataPtrOffsetInternal();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    internal static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(Array array, object value);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(Array array, int index, int length, object value);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(Array array, object value, IComparer comparer);
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(T[] array, T value);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(T[] array, int index, int length, T value);
    [ReliabilityContractAttribute("3", "1")]
public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public sealed virtual void CopyTo(Array array, int index);
    [ComVisibleAttribute("False")]
public void CopyTo(Array array, long index);
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    [ReliabilityContractAttribute("3", "1")]
public static int IndexOf(Array array, object value);
    [ReliabilityContractAttribute("3", "1")]
public static int IndexOf(Array array, object value, int startIndex);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    [ReliabilityContractAttribute("3", "1")]
public static int LastIndexOf(Array array, object value);
    [ReliabilityContractAttribute("3", "1")]
public static int LastIndexOf(Array array, object value, int startIndex);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    [ReliabilityContractAttribute("2", "1")]
public static void Reverse(Array array);
    [ReliabilityContractAttribute("2", "1")]
[SecuritySafeCriticalAttribute]
public static void Reverse(Array array, int index, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array array);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array keys, Array items);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array array, int index, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array keys, Array items, int index, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array array, IComparer comparer);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array keys, Array items, IComparer comparer);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(Array array, int index, int length, IComparer comparer);
    [ReliabilityContractAttribute("2", "1")]
[SecuritySafeCriticalAttribute]
public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(T[] array);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(TKey[] keys, TValue[] items);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(T[] array, int index, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(T[] array, IComparer`1<T> comparer);
    [ReliabilityContractAttribute("2", "1")]
public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("2", "1")]
public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    [ReliabilityContractAttribute("2", "1")]
[SecuritySafeCriticalAttribute]
public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    [SecuritySafeCriticalAttribute]
public void Initialize();
}
public class System.ArraySegment`1 : ValueType {
    private T[] _array;
    private int _offset;
    private int _count;
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ComVisibleAttribute("True")]
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.AssemblyLoadEventArgs : EventArgs {
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    public Assembly get_LoadedAssembly();
}
[ComVisibleAttribute("True")]
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("32767")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Attribute")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public virtual object get_TypeId();
    public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    internal AttributeTargets m_attributeTarget;
    internal bool m_allowMultiple;
    internal bool m_inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
[ComVisibleAttribute("True")]
public class System.BadImageFormatException : SystemException {
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_FileName();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string get_FusionLog();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
internal abstract class System.BaseConfigHandler : object {
    protected Delegate[] eventCallbacks;
    public abstract virtual void NotifyEvent(ConfigEvents nEvent);
    public abstract virtual void BeginChildren(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public abstract virtual void EndChildren(int fEmpty, int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public abstract virtual void Error(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public abstract virtual void CreateNode(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public abstract virtual void CreateAttribute(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    [SecurityCriticalAttribute]
internal void RunParser(string fileName);
}
internal static class System.BCLDebug : object {
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_registryChecked;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_loggingNotEnabled;
    internal static bool m_perfWarnings;
    internal static bool m_correctnessWarnings;
    internal static bool m_safeHandleStackTraces;
    internal static PermissionSet modreq(System.Runtime.CompilerServices.IsVolatile) m_MakeConsoleErrorLoggingWork;
    internal static bool SafeHandleStackTracesEnabled { get; }
    private static BCLDebug();
    [ConditionalAttribute("_DEBUG")]
public static void Assert(bool condition, string message);
    [SecuritySafeCriticalAttribute]
[ConditionalAttribute("_LOGGING")]
public static void Log(string message);
    [SecuritySafeCriticalAttribute]
[ConditionalAttribute("_LOGGING")]
public static void Log(string switchName, string message);
    [SecuritySafeCriticalAttribute]
internal static bool CheckEnabled(string switchName);
    [SecuritySafeCriticalAttribute]
[ConditionalAttribute("_LOGGING")]
public static void Log(string switchName, LogLevel level, Object[] messages);
    [ConditionalAttribute("_LOGGING")]
public static void Trace(string switchName, Object[] messages);
    [ConditionalAttribute("_LOGGING")]
public static void Trace(string switchName, string format, Object[] messages);
    [ConditionalAttribute("_LOGGING")]
public static void DumpStack(string switchName);
    [SecuritySafeCriticalAttribute]
[ConditionalAttribute("_DEBUG")]
internal static void ConsoleError(string msg);
    [SecuritySafeCriticalAttribute]
[ConditionalAttribute("_DEBUG")]
internal static void Perf(bool expr, string msg);
    [ConditionalAttribute("_DEBUG")]
internal static void Correctness(bool expr, string msg);
    [SecuritySafeCriticalAttribute]
internal static bool CorrectnessEnabled();
    internal static bool get_SafeHandleStackTracesEnabled();
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    [SecuritySafeCriticalAttribute]
public static Byte[] GetBytes(short value);
    [SecuritySafeCriticalAttribute]
public static Byte[] GetBytes(int value);
    [SecuritySafeCriticalAttribute]
public static Byte[] GetBytes(long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [SecuritySafeCriticalAttribute]
public static Byte[] GetBytes(float value);
    [SecuritySafeCriticalAttribute]
public static Byte[] GetBytes(double value);
    public static char ToChar(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static short ToInt16(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static int ToInt32(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static long ToInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static float ToSingle(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static double ToDouble(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static long DoubleToInt64Bits(double value);
    [SecuritySafeCriticalAttribute]
public static double Int64BitsToDouble(long value);
}
[ComVisibleAttribute("True")]
public class System.Boolean : ValueType {
    internal static int True;
    internal static int False;
    internal static string TrueLiteral;
    internal static string FalseLiteral;
    private bool m_value;
    public static string TrueString;
    public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(bool obj);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    public static bool Parse(string value);
    public static bool TryParse(string value, Boolean& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public static class System.Buffer : object {
    [SecuritySafeCriticalAttribute]
public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    [SecuritySafeCriticalAttribute]
internal static void InternalBlockCopy(Array src, int srcOffsetBytes, Array dst, int dstOffsetBytes, int byteCount);
    [SecurityCriticalAttribute]
internal static int IndexOfByte(Byte* src, byte value, int index, int count);
    [SecuritySafeCriticalAttribute]
public static byte GetByte(Array array, int index);
    [SecuritySafeCriticalAttribute]
public static void SetByte(Array array, int index, byte value);
    [SecuritySafeCriticalAttribute]
public static int ByteLength(Array array);
    [SecurityCriticalAttribute]
internal static void ZeroMemory(Byte* src, long len);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void Memcpy(Char* pDest, int destIndex, Char* pSrc, int srcIndex, int len);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
[FriendAccessAllowedAttribute]
internal static void Memcpy(Byte* dest, Byte* src, int len);
}
[ComVisibleAttribute("True")]
public class System.Byte : ValueType {
    public static byte MaxValue;
    public static byte MinValue;
    private byte m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, IFormatProvider provider);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public class System.CannotUnloadAppDomainException : SystemException {
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Char : ValueType {
    public static char MaxValue;
    public static char MinValue;
    internal static int UNICODE_PLANE00_END;
    internal static int UNICODE_PLANE01_START;
    internal static int UNICODE_PLANE16_END;
    internal static int HIGH_SURROGATE_START;
    internal static int LOW_SURROGATE_END;
    internal char m_value;
    private static Char();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(char obj);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool IsLetterOrDigit(char c);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static char ToUpperInvariant(char c);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
}
[ComVisibleAttribute("True")]
public class System.CharEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
[FriendAccessAllowedAttribute]
internal class System.CLRConfig : object {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
[FriendAccessAllowedAttribute]
internal static bool CheckLegacyManagedDeflateStream();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool CheckThrowUnobservedTaskExceptions();
}
[AttributeUsageAttribute("32767")]
[ComVisibleAttribute("True")]
public class System.CLSCompliantAttribute : Attribute {
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("True")]
public class System.Collections.ArrayList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    internal ArrayList(bool trash);
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    private static ArrayList();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual IEnumerator GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual IEnumerator GetEnumerator(int index, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    [SecuritySafeCriticalAttribute]
public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Collections.BitArray : object {
    public bool Item { get; public set; }
    public int Length { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public BitArray(int length);
    public BitArray(int length, bool defaultValue);
    public BitArray(Byte[] bytes);
    public BitArray(Boolean[] values);
    public BitArray(Int32[] values);
    public BitArray(BitArray bits);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Get(int index);
    public void Set(int index, bool value);
    public void SetAll(bool value);
    public BitArray And(BitArray value);
    public BitArray Or(BitArray value);
    public BitArray Xor(BitArray value);
    public BitArray Not();
    public int get_Length();
    public void set_Length(int value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object Clone();
    public sealed virtual object get_SyncRoot();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
public class System.Collections.CaseInsensitiveComparer : object {
    public static CaseInsensitiveComparer Default { get; }
    public static CaseInsensitiveComparer DefaultInvariant { get; }
    public CaseInsensitiveComparer(CultureInfo culture);
    public static CaseInsensitiveComparer get_Default();
    public static CaseInsensitiveComparer get_DefaultInvariant();
    public sealed virtual int Compare(object a, object b);
}
[ObsoleteAttribute("Please use StringComparer instead.")]
[ComVisibleAttribute("True")]
public class System.Collections.CaseInsensitiveHashCodeProvider : object {
    public static CaseInsensitiveHashCodeProvider Default { get; }
    public static CaseInsensitiveHashCodeProvider DefaultInvariant { get; }
    public CaseInsensitiveHashCodeProvider(CultureInfo culture);
    private static CaseInsensitiveHashCodeProvider();
    public static CaseInsensitiveHashCodeProvider get_Default();
    public static CaseInsensitiveHashCodeProvider get_DefaultInvariant();
    public sealed virtual int GetHashCode(object obj);
}
[ComVisibleAttribute("True")]
public abstract class System.Collections.CollectionBase : object {
    protected ArrayList InnerList { get; }
    protected IList List { get; }
    [ComVisibleAttribute("False")]
public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    protected CollectionBase(int capacity);
    protected ArrayList get_InnerList();
    protected IList get_List();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual IEnumerator GetEnumerator();
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnValidate(object value);
    protected virtual void OnSetComplete(int index, object oldValue, object newValue);
    protected virtual void OnInsertComplete(int index, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(int index, object value);
}
[ComVisibleAttribute("True")]
public class System.Collections.Comparer : object {
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private static Comparer();
    public sealed virtual int Compare(object a, object b);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.CompatibleComparer : object {
    internal IComparer Comparer { get; }
    internal IHashCodeProvider HashCodeProvider { get; }
    internal CompatibleComparer(IComparer comparer, IHashCodeProvider hashCodeProvider);
    public int Compare(object a, object b);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
    internal IComparer get_Comparer();
    internal IHashCodeProvider get_HashCodeProvider();
}
[FriendAccessAllowedAttribute]
[EventSourceAttribute]
internal class System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
    public static CDSCollectionETWBCLProvider Log;
    private static CDSCollectionETWBCLProvider();
    [EventAttribute("1")]
public void ConcurrentStack_FastPushFailed(int spinCount);
    [EventAttribute("2")]
public void ConcurrentStack_FastPopFailed(int spinCount);
    [EventAttribute("3")]
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
    [EventAttribute("4")]
public void ConcurrentBag_TryTakeSteals();
    [EventAttribute("5")]
public void ConcurrentBag_TryPeekSteals();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
public class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public ConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer);
    internal ConcurrentDictionary`2(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<TKey> comparer);
    private static ConcurrentDictionary`2();
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    public KeyValuePair`2[] ToArray();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public bool get_IsEmpty();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_numSnapshotTakers;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Enqueue(T item);
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentStack`1 : object {
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentStack`1(IEnumerable`1<T> collection);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(T[] array, int index);
    public void Push(T item);
    public void PushRange(T[] items);
    public void PushRange(T[] items, int startIndex, int count);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public bool TryPeek(T& result);
    public bool TryPop(T& result);
    public int TryPopRange(T[] items);
    public int TryPopRange(T[] items, int startIndex, int count);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public sealed virtual T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FlagsAttribute]
public enum System.Collections.Concurrent.EnumerablePartitionerOptions : Enum {
    public int value__;
    public static EnumerablePartitionerOptions None;
    public static EnumerablePartitionerOptions NoBuffering;
}
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
public abstract class System.Collections.Concurrent.OrderablePartitioner`1 : Partitioner`1<TSource> {
    public bool KeysOrderedInEachPartition { get; private set; }
    public bool KeysOrderedAcrossPartitions { get; private set; }
    public bool KeysNormalized { get; private set; }
    protected OrderablePartitioner`1(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
    public abstract virtual IList`1<IEnumerator`1<KeyValuePair`2<long, TSource>>> GetOrderablePartitions(int partitionCount);
    public virtual IEnumerable`1<KeyValuePair`2<long, TSource>> GetOrderableDynamicPartitions();
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedInEachPartition();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedInEachPartition(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedAcrossPartitions();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedAcrossPartitions(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysNormalized();
    [CompilerGeneratedAttribute]
private void set_KeysNormalized(bool value);
    public virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
public static class System.Collections.Concurrent.Partitioner : object {
    public static OrderablePartitioner`1<TSource> Create(IList`1<TSource> list, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(TSource[] array, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source, EnumerablePartitionerOptions partitionerOptions);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive);
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
}
public abstract class System.Collections.Concurrent.Partitioner`1 : object {
    public bool SupportsDynamicPartitions { get; }
    public abstract virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual bool get_SupportsDynamicPartitions();
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
internal class System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Concurrent.VolatileBool : ValueType {
    public Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_value;
    public VolatileBool(bool value);
}
[ComVisibleAttribute("True")]
public abstract class System.Collections.DictionaryBase : object {
    protected Hashtable InnerHashtable { get; }
    protected IDictionary Dictionary { get; }
    public int Count { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    protected Hashtable get_InnerHashtable();
    protected IDictionary get_Dictionary();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual object OnGet(object key, object currentValue);
    protected virtual void OnSet(object key, object oldValue, object newValue);
    protected virtual void OnInsert(object key, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(object key, object value);
    protected virtual void OnValidate(object key, object value);
    protected virtual void OnSetComplete(object key, object oldValue, object newValue);
    protected virtual void OnInsertComplete(object key, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(object key, object value);
}
[ComVisibleAttribute("True")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.EmptyReadOnlyDictionaryInternal : object {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`1")]
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    public static IArraySortHelper`1<T> Default { get; }
    public static IArraySortHelper`1<T> get_Default();
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void IntrospectiveSort(T[] keys, int left, int length, IComparer`1<T> comparer);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`2")]
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    public static IArraySortHelper`2<TKey, TValue> Default { get; }
    public static IArraySortHelper`2<TKey, TValue> get_Default();
    [SecuritySafeCriticalAttribute]
public static IArraySortHelper`2<TKey, TValue> CreateArraySortHelper();
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
}
internal class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    [SecuritySafeCriticalAttribute]
internal virtual int IndexOf(Byte[] array, byte value, int startIndex, int count);
    internal virtual int LastIndexOf(Byte[] array, byte value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectComparer`1")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    public static Comparer`1<T> Default { get; }
    public static Comparer`1<T> get_Default();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
public class System.Collections.Generic.Dictionary`2 : object {
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    internal TValue GetValueOrDefault(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectEqualityComparer`1")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    public static EqualityComparer`1<T> Default { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static EqualityComparer`1<T> get_Default();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
}
internal class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface System.Collections.Generic.IArraySortHelper`1 {
    public abstract virtual void Sort(TKey[] keys, int index, int length, IComparer`1<TKey> comparer);
    public abstract virtual int BinarySearch(TKey[] keys, int index, int length, TKey value, IComparer`1<TKey> comparer);
}
internal interface System.Collections.Generic.IArraySortHelper`2 {
    public abstract virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
}
[TypeDependencyAttribute("System.SZArrayHelper")]
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[TypeDependencyAttribute("System.SZArrayHelper")]
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
[TypeDependencyAttribute("System.SZArrayHelper")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int IntrosortSizeThreshold;
    internal static int FloorLog2(int n);
    internal static void ThrowOrIgnoreBadComparer(object comparer);
}
[TypeDependencyAttribute("System.SZArrayHelper")]
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[TypeDependencyAttribute("System.SZArrayHelper")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[ComVisibleAttribute("True")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.List`1 : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual T get_Item(int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void CopyTo(T[] array);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Enumerator<T> GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int IndexOf(T item);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    internal static IList`1<T> Synchronized(List`1<T> list);
}
internal class System.Collections.Generic.LongEnumEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.Mscorlib_CollectionDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public Mscorlib_CollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public Mscorlib_DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryKeyCollectionDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public Mscorlib_DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryValueCollectionDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public Mscorlib_DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public Mscorlib_KeyedCollectionDebugView`2(KeyedCollection`2<K, T> keyedCollection);
    public T[] get_Items();
}
internal class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    internal virtual int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    internal virtual int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.RandomizedObjectEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    [SecuritySafeCriticalAttribute]
public sealed virtual int GetHashCode(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
internal class System.Collections.Generic.RandomizedStringEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual bool Equals(string x, string y);
    [SecuritySafeCriticalAttribute]
public sealed virtual int GetHashCode(string obj);
    [SecuritySafeCriticalAttribute]
public sealed virtual int GetHashCode(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
[FriendAccessAllowedAttribute]
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    public static int MaxPrimeArrayLength;
    public static bool s_UseRandomizedStringHashing;
    public static Int32[] primes;
    internal static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    internal static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
    [ReliabilityContractAttribute("3", "2")]
public static bool IsPrime(int candidate);
    [ReliabilityContractAttribute("3", "2")]
public static int GetPrime(int min);
    public static int GetMinPrime();
    public static int ExpandPrime(int oldSize);
    public static bool IsWellKnownEqualityComparer(object comparer);
    public static IEqualityComparer GetRandomizedEqualityComparer(object comparer);
    public static object GetEqualityComparerForSerialization(object comparer);
    internal static long GetEntropy();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("True")]
public class System.Collections.Hashtable : object {
    internal static int HashPrime;
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    protected IEqualityComparer EqualityComparer { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    protected IEqualityComparer get_EqualityComparer();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Add(object key, object value);
    [ReliabilityContractAttribute("3", "2")]
public virtual void Clear();
    public virtual object Clone();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    public virtual object get_Item(object key);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void set_Item(object key, object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual IDictionaryEnumerator GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual ICollection get_Keys();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual ICollection get_Values();
    [ReliabilityContractAttribute("3", "1")]
public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
[ComVisibleAttribute("True")]
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
[ComVisibleAttribute("True")]
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
[ComVisibleAttribute("True")]
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
[ComVisibleAttribute("True")]
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
public interface System.Collections.IEnumerable {
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
[GuidAttribute("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[ComVisibleAttribute("True")]
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
[ComVisibleAttribute("True")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DebuggerDisplayAttribute("{value}")]
internal class System.Collections.KeyValuePairs : object {
    public object Key { get; }
    public object Value { get; }
    public KeyValuePairs(object key, object value);
    public object get_Key();
    public object get_Value();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.ListDictionaryInternal : object {
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.ObjectModel.Collection`1 : object {
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual void Clear();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual void CopyTo(T[] array, int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual void ClearItems();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual void InsertItem(int index, T item);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2")]
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Count = {Count}")]
public abstract class System.Collections.ObjectModel.KeyedCollection`2 : Collection`1<TItem> {
    public IEqualityComparer`1<TKey> Comparer { get; }
    public TItem Item { get; }
    protected IDictionary`2<TKey, TItem> Dictionary { get; }
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer);
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer, int dictionaryCreationThreshold);
    public IEqualityComparer`1<TKey> get_Comparer();
    public TItem get_Item(TKey key);
    public bool Contains(TKey key);
    public bool Remove(TKey key);
    protected IDictionary`2<TKey, TItem> get_Dictionary();
    protected void ChangeItemKey(TItem item, TKey newKey);
    protected virtual void ClearItems();
    protected abstract virtual TKey GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TItem item);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int get_Count();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual T get_Item(int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
    internal static void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Queue/QueueDebugView")]
[ComVisibleAttribute("True")]
public class System.Collections.Queue : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Queue(int capacity);
    public Queue(int capacity, float growFactor);
    public Queue(ICollection col);
    public virtual int get_Count();
    public virtual object Clone();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual void CopyTo(Array array, int index);
    public virtual void Enqueue(object obj);
    public virtual IEnumerator GetEnumerator();
    public virtual object Dequeue();
    public virtual object Peek();
    public static Queue Synchronized(Queue queue);
    public virtual bool Contains(object obj);
    internal object GetElement(int i);
    public virtual Object[] ToArray();
    public virtual void TrimToSize();
}
[ComVisibleAttribute("True")]
public abstract class System.Collections.ReadOnlyCollectionBase : object {
    protected ArrayList InnerList { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected ArrayList get_InnerList();
    public virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.SortedList/SortedListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.SortedList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public SortedList(int initialCapacity);
    public SortedList(IComparer comparer);
    public SortedList(IComparer comparer, int capacity);
    public SortedList(IDictionary d);
    public SortedList(IDictionary d, IComparer comparer);
    private static SortedList();
    public virtual void Add(object key, object value);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    public virtual object GetByIndex(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual object GetKey(int index);
    public virtual IList GetKeyList();
    public virtual IList GetValueList();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual int IndexOfKey(object key);
    public virtual int IndexOfValue(object value);
    public virtual void RemoveAt(int index);
    public virtual void Remove(object key);
    public virtual void SetByIndex(int index, object value);
    public static SortedList Synchronized(SortedList list);
    public virtual void TrimToSize();
}
[DebuggerTypeProxyAttribute("System.Collections.Stack/StackDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("True")]
public class System.Collections.Stack : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Stack(int initialCapacity);
    public Stack(ICollection col);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object obj);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual object Peek();
    public virtual object Pop();
    public virtual void Push(object obj);
    public static Stack Synchronized(Stack stack);
    public virtual Object[] ToArray();
}
internal class System.Collections.StructuralComparer : object {
    public sealed virtual int Compare(object x, object y);
}
public static class System.Collections.StructuralComparisons : object {
    public static IComparer StructuralComparer { get; }
    public static IEqualityComparer StructuralEqualityComparer { get; }
    public static IComparer get_StructuralComparer();
    public static IEqualityComparer get_StructuralEqualityComparer();
}
internal class System.Collections.StructuralEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal enum System.CompatibilityFlag : Enum {
    public int value__;
    public static CompatibilityFlag SwallowUnhandledExceptions;
    public static CompatibilityFlag NullReferenceExceptionOnAV;
    public static CompatibilityFlag EagerlyGenerateRandomAsymmKeys;
    public static CompatibilityFlag FullTrustListAssembliesInGac;
    public static CompatibilityFlag DateTimeParseIgnorePunctuation;
    public static CompatibilityFlag OnlyGACDomainNeutral;
    public static CompatibilityFlag DisableReplacementCustomCulture;
}
[FriendAccessAllowedAttribute]
internal static class System.CompatibilitySwitches : object {
    public static bool IsCompatibilityBehaviorDefined { get; }
    public static bool IsAppEarlierThanSilverlight4 { get; }
    public static bool IsAppEarlierThanWindowsPhone8 { get; }
    public static bool IsNetFx40TimeSpanLegacyFormatMode { get; }
    public static bool IsNetFx40LegacySecurityPolicy { get; }
    public static bool IsNetFx45LegacyManagedDeflateStream { get; }
    public static bool get_IsCompatibilityBehaviorDefined();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool get_IsAppEarlierThanSilverlight4();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool get_IsAppEarlierThanWindowsPhone8();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool get_IsNetFx40TimeSpanLegacyFormatMode();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool get_IsNetFx40LegacySecurityPolicy();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool get_IsNetFx45LegacyManagedDeflateStream();
}
internal enum System.ConfigEvents : Enum {
    public int value__;
    public static ConfigEvents StartDocument;
    public static ConfigEvents StartDTD;
    public static ConfigEvents EndDTD;
    public static ConfigEvents StartDTDSubset;
    public static ConfigEvents EndDTDSubset;
    public static ConfigEvents EndProlog;
    public static ConfigEvents StartEntity;
    public static ConfigEvents EndEntity;
    public static ConfigEvents EndDocument;
    public static ConfigEvents DataAvailable;
    public static ConfigEvents LastEvent;
}
internal class System.ConfigNode : object {
    internal string Name { get; }
    internal string Value { get; internal set; }
    internal ConfigNode Parent { get; }
    internal List`1<ConfigNode> Children { get; }
    internal List`1<DictionaryEntry> Attributes { get; }
    internal ConfigNode(string name, ConfigNode parent);
    internal string get_Name();
    internal string get_Value();
    internal void set_Value(string value);
    internal ConfigNode get_Parent();
    internal List`1<ConfigNode> get_Children();
    internal List`1<DictionaryEntry> get_Attributes();
    internal void AddChild(ConfigNode child);
    internal int AddAttribute(string key, string value);
    internal void ReplaceAttribute(int index, string key, string value);
}
internal enum System.ConfigNodeSubType : Enum {
    public int value__;
    public static ConfigNodeSubType Version;
    public static ConfigNodeSubType Encoding;
    public static ConfigNodeSubType Standalone;
    public static ConfigNodeSubType NS;
    public static ConfigNodeSubType XMLSpace;
    public static ConfigNodeSubType XMLLang;
    public static ConfigNodeSubType System;
    public static ConfigNodeSubType Public;
    public static ConfigNodeSubType NData;
    public static ConfigNodeSubType AtCData;
    public static ConfigNodeSubType AtId;
    public static ConfigNodeSubType AtIdref;
    public static ConfigNodeSubType AtIdrefs;
    public static ConfigNodeSubType AtEntity;
    public static ConfigNodeSubType AtEntities;
    public static ConfigNodeSubType AtNmToken;
    public static ConfigNodeSubType AtNmTokens;
    public static ConfigNodeSubType AtNotation;
    public static ConfigNodeSubType AtRequired;
    public static ConfigNodeSubType AtImplied;
    public static ConfigNodeSubType AtFixed;
    public static ConfigNodeSubType PentityDecl;
    public static ConfigNodeSubType Empty;
    public static ConfigNodeSubType Any;
    public static ConfigNodeSubType Mixed;
    public static ConfigNodeSubType Sequence;
    public static ConfigNodeSubType Choice;
    public static ConfigNodeSubType Star;
    public static ConfigNodeSubType Plus;
    public static ConfigNodeSubType Questionmark;
    public static ConfigNodeSubType LastSubNodeType;
}
internal enum System.ConfigNodeType : Enum {
    public int value__;
    public static ConfigNodeType Element;
    public static ConfigNodeType Attribute;
    public static ConfigNodeType Pi;
    public static ConfigNodeType XmlDecl;
    public static ConfigNodeType DocType;
    public static ConfigNodeType DTDAttribute;
    public static ConfigNodeType EntityDecl;
    public static ConfigNodeType ElementDecl;
    public static ConfigNodeType AttlistDecl;
    public static ConfigNodeType Notation;
    public static ConfigNodeType Group;
    public static ConfigNodeType IncludeSect;
    public static ConfigNodeType PCData;
    public static ConfigNodeType CData;
    public static ConfigNodeType IgnoreSect;
    public static ConfigNodeType Comment;
    public static ConfigNodeType EntityRef;
    public static ConfigNodeType Whitespace;
    public static ConfigNodeType Name;
    public static ConfigNodeType NMToken;
    public static ConfigNodeType String;
    public static ConfigNodeType Peref;
    public static ConfigNodeType Model;
    public static ConfigNodeType ATTDef;
    public static ConfigNodeType ATTType;
    public static ConfigNodeType ATTPresence;
    public static ConfigNodeType DTDSubset;
    public static ConfigNodeType LastNodeType;
}
internal class System.ConfigTreeParser : BaseConfigHandler {
    internal ConfigNode Parse(string fileName, string configPath);
    [SecuritySafeCriticalAttribute]
internal ConfigNode Parse(string fileName, string configPath, bool skipSecurityStuff);
    public virtual void NotifyEvent(ConfigEvents nEvent);
    public virtual void BeginChildren(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public virtual void EndChildren(int fEmpty, int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public virtual void Error(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public virtual void CreateNode(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
    public virtual void CreateAttribute(int size, ConfigNodeSubType subType, ConfigNodeType nType, int terminal, string text, int textLength, int prefixLength);
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Configuration.Assemblies.AssemblyHash : ValueType {
    private AssemblyHashAlgorithm _Algorithm;
    private Byte[] _Value;
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static AssemblyHash Empty;
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyHashAlgorithm Algorithm { get; public set; }
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyHash(Byte[] value);
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyHash(AssemblyHashAlgorithm algorithm, Byte[] value);
    private static AssemblyHash();
    public AssemblyHashAlgorithm get_Algorithm();
    public void set_Algorithm(AssemblyHashAlgorithm value);
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public Byte[] GetValue();
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetValue(Byte[] value);
    [ObsoleteAttribute("The AssemblyHash class has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public sealed virtual object Clone();
}
[ComVisibleAttribute("True")]
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    [ComVisibleAttribute("False")]
public static AssemblyHashAlgorithm SHA256;
    [ComVisibleAttribute("False")]
public static AssemblyHashAlgorithm SHA384;
    [ComVisibleAttribute("False")]
public static AssemblyHashAlgorithm SHA512;
}
[ComVisibleAttribute("True")]
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public static class System.Console : object {
    public static bool IsInputRedirected { get; }
    public static bool IsOutputRedirected { get; }
    public static bool IsErrorRedirected { get; }
    public static TextReader In { get; }
    public static TextWriter Out { get; }
    public static TextWriter Error { get; }
    public static Encoding InputEncoding { get; public set; }
    public static Encoding OutputEncoding { get; public set; }
    public static ConsoleColor BackgroundColor { get; public set; }
    public static ConsoleColor ForegroundColor { get; public set; }
    public static int BufferHeight { get; public set; }
    public static int BufferWidth { get; public set; }
    public static int WindowHeight { get; public set; }
    public static int WindowWidth { get; public set; }
    public static int LargestWindowWidth { get; }
    public static int LargestWindowHeight { get; }
    public static int WindowLeft { get; public set; }
    public static int WindowTop { get; public set; }
    public static int CursorLeft { get; public set; }
    public static int CursorTop { get; public set; }
    public static int CursorSize { get; public set; }
    public static bool CursorVisible { get; public set; }
    public static string Title { get; public set; }
    public static bool KeyAvailable { get; }
    public static bool NumberLock { get; }
    public static bool CapsLock { get; }
    public static bool TreatControlCAsInput { get; public set; }
    private static Console();
    [SecuritySafeCriticalAttribute]
public static bool get_IsInputRedirected();
    [SecuritySafeCriticalAttribute]
public static bool get_IsOutputRedirected();
    [SecuritySafeCriticalAttribute]
public static bool get_IsErrorRedirected();
    [SecuritySafeCriticalAttribute]
public static TextReader get_In();
    public static TextWriter get_Out();
    public static TextWriter get_Error();
    [SecuritySafeCriticalAttribute]
public static Encoding get_InputEncoding();
    [SecuritySafeCriticalAttribute]
public static void set_InputEncoding(Encoding value);
    [SecuritySafeCriticalAttribute]
public static Encoding get_OutputEncoding();
    [SecuritySafeCriticalAttribute]
public static void set_OutputEncoding(Encoding value);
    public static void Beep();
    [SecuritySafeCriticalAttribute]
public static void Beep(int frequency, int duration);
    [SecuritySafeCriticalAttribute]
public static void Clear();
    [SecuritySafeCriticalAttribute]
public static ConsoleColor get_BackgroundColor();
    [SecuritySafeCriticalAttribute]
public static void set_BackgroundColor(ConsoleColor value);
    [SecuritySafeCriticalAttribute]
public static ConsoleColor get_ForegroundColor();
    [SecuritySafeCriticalAttribute]
public static void set_ForegroundColor(ConsoleColor value);
    [SecuritySafeCriticalAttribute]
public static void ResetColor();
    public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
    [SecuritySafeCriticalAttribute]
public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    [SecuritySafeCriticalAttribute]
public static int get_BufferHeight();
    public static void set_BufferHeight(int value);
    [SecuritySafeCriticalAttribute]
public static int get_BufferWidth();
    public static void set_BufferWidth(int value);
    [SecuritySafeCriticalAttribute]
public static void SetBufferSize(int width, int height);
    [SecuritySafeCriticalAttribute]
public static int get_WindowHeight();
    public static void set_WindowHeight(int value);
    [SecuritySafeCriticalAttribute]
public static int get_WindowWidth();
    public static void set_WindowWidth(int value);
    [SecuritySafeCriticalAttribute]
public static void SetWindowSize(int width, int height);
    [SecuritySafeCriticalAttribute]
public static int get_LargestWindowWidth();
    [SecuritySafeCriticalAttribute]
public static int get_LargestWindowHeight();
    [SecuritySafeCriticalAttribute]
public static int get_WindowLeft();
    public static void set_WindowLeft(int value);
    [SecuritySafeCriticalAttribute]
public static int get_WindowTop();
    public static void set_WindowTop(int value);
    [SecuritySafeCriticalAttribute]
public static void SetWindowPosition(int left, int top);
    [SecuritySafeCriticalAttribute]
public static int get_CursorLeft();
    public static void set_CursorLeft(int value);
    [SecuritySafeCriticalAttribute]
public static int get_CursorTop();
    public static void set_CursorTop(int value);
    [SecuritySafeCriticalAttribute]
public static void SetCursorPosition(int left, int top);
    [SecuritySafeCriticalAttribute]
public static int get_CursorSize();
    [SecuritySafeCriticalAttribute]
public static void set_CursorSize(int value);
    [SecuritySafeCriticalAttribute]
public static bool get_CursorVisible();
    [SecuritySafeCriticalAttribute]
public static void set_CursorVisible(bool value);
    [SecuritySafeCriticalAttribute]
public static string get_Title();
    [SecuritySafeCriticalAttribute]
public static void set_Title(string value);
    public static ConsoleKeyInfo ReadKey();
    [SecuritySafeCriticalAttribute]
public static ConsoleKeyInfo ReadKey(bool intercept);
    [SecuritySafeCriticalAttribute]
public static bool get_KeyAvailable();
    [SecuritySafeCriticalAttribute]
public static bool get_NumberLock();
    [SecuritySafeCriticalAttribute]
public static bool get_CapsLock();
    [SecuritySafeCriticalAttribute]
public static bool get_TreatControlCAsInput();
    [SecuritySafeCriticalAttribute]
public static void set_TreatControlCAsInput(bool value);
    [SecuritySafeCriticalAttribute]
public static void add_CancelKeyPress(ConsoleCancelEventHandler value);
    [SecuritySafeCriticalAttribute]
public static void remove_CancelKeyPress(ConsoleCancelEventHandler value);
    public static Stream OpenStandardError();
    public static Stream OpenStandardError(int bufferSize);
    public static Stream OpenStandardInput();
    public static Stream OpenStandardInput(int bufferSize);
    public static Stream OpenStandardOutput();
    public static Stream OpenStandardOutput(int bufferSize);
    [SecuritySafeCriticalAttribute]
public static void SetIn(TextReader newIn);
    [SecuritySafeCriticalAttribute]
public static void SetOut(TextWriter newOut);
    [SecuritySafeCriticalAttribute]
public static void SetError(TextWriter newError);
    public static int Read();
    public static string ReadLine();
    public static void WriteLine();
    public static void WriteLine(bool value);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(decimal value);
    public static void WriteLine(double value);
    public static void WriteLine(float value);
    public static void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(UInt32 value);
    public static void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(ulong value);
    public static void WriteLine(object value);
    public static void WriteLine(string value);
    public static void WriteLine(string format, object arg0);
    public static void WriteLine(string format, object arg0, object arg1);
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3);
    public static void WriteLine(string format, Object[] arg);
    public static void Write(string format, object arg0);
    public static void Write(string format, object arg0, object arg1);
    public static void Write(string format, object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static void Write(string format, object arg0, object arg1, object arg2, object arg3);
    public static void Write(string format, Object[] arg);
    public static void Write(bool value);
    public static void Write(char value);
    public static void Write(Char[] buffer);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(double value);
    public static void Write(decimal value);
    public static void Write(float value);
    public static void Write(int value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32 value);
    public static void Write(long value);
    [CLSCompliantAttribute("False")]
public static void Write(ulong value);
    public static void Write(object value);
    public static void Write(string value);
}
public class System.ConsoleCancelEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public ConsoleSpecialKey SpecialKey { get; }
    internal ConsoleCancelEventArgs(ConsoleSpecialKey type);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public ConsoleSpecialKey get_SpecialKey();
}
public class System.ConsoleCancelEventHandler : MulticastDelegate {
    public ConsoleCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ConsoleCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ConsoleColor : Enum {
    public int value__;
    public static ConsoleColor Black;
    public static ConsoleColor DarkBlue;
    public static ConsoleColor DarkGreen;
    public static ConsoleColor DarkCyan;
    public static ConsoleColor DarkRed;
    public static ConsoleColor DarkMagenta;
    public static ConsoleColor DarkYellow;
    public static ConsoleColor Gray;
    public static ConsoleColor DarkGray;
    public static ConsoleColor Blue;
    public static ConsoleColor Green;
    public static ConsoleColor Cyan;
    public static ConsoleColor Red;
    public static ConsoleColor Magenta;
    public static ConsoleColor Yellow;
    public static ConsoleColor White;
}
public enum System.ConsoleKey : Enum {
    public int value__;
    public static ConsoleKey Backspace;
    public static ConsoleKey Tab;
    public static ConsoleKey Clear;
    public static ConsoleKey Enter;
    public static ConsoleKey Pause;
    public static ConsoleKey Escape;
    public static ConsoleKey Spacebar;
    public static ConsoleKey PageUp;
    public static ConsoleKey PageDown;
    public static ConsoleKey End;
    public static ConsoleKey Home;
    public static ConsoleKey LeftArrow;
    public static ConsoleKey UpArrow;
    public static ConsoleKey RightArrow;
    public static ConsoleKey DownArrow;
    public static ConsoleKey Select;
    public static ConsoleKey Print;
    public static ConsoleKey Execute;
    public static ConsoleKey PrintScreen;
    public static ConsoleKey Insert;
    public static ConsoleKey Delete;
    public static ConsoleKey Help;
    public static ConsoleKey D0;
    public static ConsoleKey D1;
    public static ConsoleKey D2;
    public static ConsoleKey D3;
    public static ConsoleKey D4;
    public static ConsoleKey D5;
    public static ConsoleKey D6;
    public static ConsoleKey D7;
    public static ConsoleKey D8;
    public static ConsoleKey D9;
    public static ConsoleKey A;
    public static ConsoleKey B;
    public static ConsoleKey C;
    public static ConsoleKey D;
    public static ConsoleKey E;
    public static ConsoleKey F;
    public static ConsoleKey G;
    public static ConsoleKey H;
    public static ConsoleKey I;
    public static ConsoleKey J;
    public static ConsoleKey K;
    public static ConsoleKey L;
    public static ConsoleKey M;
    public static ConsoleKey N;
    public static ConsoleKey O;
    public static ConsoleKey P;
    public static ConsoleKey Q;
    public static ConsoleKey R;
    public static ConsoleKey S;
    public static ConsoleKey T;
    public static ConsoleKey U;
    public static ConsoleKey V;
    public static ConsoleKey W;
    public static ConsoleKey X;
    public static ConsoleKey Y;
    public static ConsoleKey Z;
    public static ConsoleKey LeftWindows;
    public static ConsoleKey RightWindows;
    public static ConsoleKey Applications;
    public static ConsoleKey Sleep;
    public static ConsoleKey NumPad0;
    public static ConsoleKey NumPad1;
    public static ConsoleKey NumPad2;
    public static ConsoleKey NumPad3;
    public static ConsoleKey NumPad4;
    public static ConsoleKey NumPad5;
    public static ConsoleKey NumPad6;
    public static ConsoleKey NumPad7;
    public static ConsoleKey NumPad8;
    public static ConsoleKey NumPad9;
    public static ConsoleKey Multiply;
    public static ConsoleKey Add;
    public static ConsoleKey Separator;
    public static ConsoleKey Subtract;
    public static ConsoleKey Decimal;
    public static ConsoleKey Divide;
    public static ConsoleKey F1;
    public static ConsoleKey F2;
    public static ConsoleKey F3;
    public static ConsoleKey F4;
    public static ConsoleKey F5;
    public static ConsoleKey F6;
    public static ConsoleKey F7;
    public static ConsoleKey F8;
    public static ConsoleKey F9;
    public static ConsoleKey F10;
    public static ConsoleKey F11;
    public static ConsoleKey F12;
    public static ConsoleKey F13;
    public static ConsoleKey F14;
    public static ConsoleKey F15;
    public static ConsoleKey F16;
    public static ConsoleKey F17;
    public static ConsoleKey F18;
    public static ConsoleKey F19;
    public static ConsoleKey F20;
    public static ConsoleKey F21;
    public static ConsoleKey F22;
    public static ConsoleKey F23;
    public static ConsoleKey F24;
    public static ConsoleKey BrowserBack;
    public static ConsoleKey BrowserForward;
    public static ConsoleKey BrowserRefresh;
    public static ConsoleKey BrowserStop;
    public static ConsoleKey BrowserSearch;
    public static ConsoleKey BrowserFavorites;
    public static ConsoleKey BrowserHome;
    public static ConsoleKey VolumeMute;
    public static ConsoleKey VolumeDown;
    public static ConsoleKey VolumeUp;
    public static ConsoleKey MediaNext;
    public static ConsoleKey MediaPrevious;
    public static ConsoleKey MediaStop;
    public static ConsoleKey MediaPlay;
    public static ConsoleKey LaunchMail;
    public static ConsoleKey LaunchMediaSelect;
    public static ConsoleKey LaunchApp1;
    public static ConsoleKey LaunchApp2;
    public static ConsoleKey Oem1;
    public static ConsoleKey OemPlus;
    public static ConsoleKey OemComma;
    public static ConsoleKey OemMinus;
    public static ConsoleKey OemPeriod;
    public static ConsoleKey Oem2;
    public static ConsoleKey Oem3;
    public static ConsoleKey Oem4;
    public static ConsoleKey Oem5;
    public static ConsoleKey Oem6;
    public static ConsoleKey Oem7;
    public static ConsoleKey Oem8;
    public static ConsoleKey Oem102;
    public static ConsoleKey Process;
    public static ConsoleKey Packet;
    public static ConsoleKey Attention;
    public static ConsoleKey CrSel;
    public static ConsoleKey ExSel;
    public static ConsoleKey EraseEndOfFile;
    public static ConsoleKey Play;
    public static ConsoleKey Zoom;
    public static ConsoleKey NoName;
    public static ConsoleKey Pa1;
    public static ConsoleKey OemClear;
}
public class System.ConsoleKeyInfo : ValueType {
    private char _keyChar;
    private ConsoleKey _key;
    private ConsoleModifiers _mods;
    public char KeyChar { get; }
    public ConsoleKey Key { get; }
    public ConsoleModifiers Modifiers { get; }
    public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
    public char get_KeyChar();
    public ConsoleKey get_Key();
    public ConsoleModifiers get_Modifiers();
    public virtual bool Equals(object value);
    public bool Equals(ConsoleKeyInfo obj);
    public static bool op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b);
    public static bool op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.ConsoleModifiers : Enum {
    public int value__;
    public static ConsoleModifiers Alt;
    public static ConsoleModifiers Shift;
    public static ConsoleModifiers Control;
}
public enum System.ConsoleSpecialKey : Enum {
    public int value__;
    public static ConsoleSpecialKey ControlC;
    public static ConsoleSpecialKey ControlBreak;
}
[ComVisibleAttribute("True")]
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[ComVisibleAttribute("True")]
public class System.ContextMarshalException : SystemException {
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.ContextStaticAttribute : Attribute {
}
public static class System.Convert : object {
    internal static RuntimeType[] ConvertTypes;
    internal static Char[] base64Table;
    public static object DBNull;
    private static Convert();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    [SecuritySafeCriticalAttribute]
public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [SecuritySafeCriticalAttribute]
public static string ToString(byte value, int toBase);
    [SecuritySafeCriticalAttribute]
public static string ToString(short value, int toBase);
    [SecuritySafeCriticalAttribute]
public static string ToString(int value, int toBase);
    [SecuritySafeCriticalAttribute]
public static string ToString(long value, int toBase);
    public static string ToBase64String(Byte[] inArray);
    [ComVisibleAttribute("False")]
public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    [SecuritySafeCriticalAttribute]
public static Byte[] FromBase64String(string s);
    [SecuritySafeCriticalAttribute]
public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.CrossAppDomainDelegate : MulticastDelegate {
    public CrossAppDomainDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.CtorDelegate : MulticastDelegate {
    public CtorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.CultureAwareComparer : StringComparer {
    internal CultureAwareComparer(CultureInfo culture, bool ignoreCase);
    internal CultureAwareComparer(CompareInfo compareInfo, bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
internal class System.CultureAwareRandomizedComparer : StringComparer {
    internal CultureAwareRandomizedComparer(CompareInfo compareInfo, bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
[ForceTokenStabilizationAttribute]
internal class System.Currency : ValueType {
    internal long m_value;
    [ForceTokenStabilizationAttribute]
public Currency(decimal value);
    internal Currency(long value, int ignored);
    public static Currency FromOACurrency(long cy);
    public long ToOACurrency();
    [SecuritySafeCriticalAttribute]
public static decimal ToDecimal(Currency c);
}
internal class System.CurrentSystemTimeZone : TimeZone {
    public string StandardName { get; }
    public string DaylightName { get; }
    [SecuritySafeCriticalAttribute]
public virtual string get_StandardName();
    [SecuritySafeCriticalAttribute]
public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    [SecuritySafeCriticalAttribute]
public virtual DaylightTime GetDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
    [SecurityCriticalAttribute]
internal static int nativeGetTimeZoneMinuteOffset();
    [SecurityCriticalAttribute]
internal static string nativeGetDaylightName();
    [SecurityCriticalAttribute]
internal static string nativeGetStandardName();
    [SecurityCriticalAttribute]
internal static Int16[] nativeGetDaylightChanges(int year);
}
[ComVisibleAttribute("True")]
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
public class System.DateTime : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMillis;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static ulong TicksMask;
    private static ulong FlagsMask;
    private static ulong LocalMask;
    private static long TicksCeiling;
    private static ulong KindUnspecified;
    private static ulong KindUtc;
    private static ulong KindLocal;
    private static ulong KindLocalAmbiguousDst;
    private static int KindShift;
    private static string TicksField;
    private static string DateDataField;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    private ulong dateData;
    internal long InternalTicks { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public static DateTime UtcNow { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private static DateTime();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal long get_InternalTicks();
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal long ToBinaryRaw();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public DateTime get_Date();
    public int get_Day();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public DateTimeKind get_Kind();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Millisecond();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public static DateTime get_UtcNow();
    [SecurityCriticalAttribute]
internal static long GetSystemTimeAsFileTime();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Second();
    public long get_Ticks();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TimeSpan get_TimeOfDay();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Equality(DateTime d1, DateTime d2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(DateTime d1, DateTime d2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_LessThan(DateTime t1, DateTime t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_GreaterThan(DateTime t1, DateTime t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
}
internal static class System.DateTimeFormat : object {
    internal static int MaxSecondsFractionDigits;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    [SecuritySafeCriticalAttribute]
internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    internal static int ParseRepeatPattern(string format, int pos, char patternChar);
    internal static int ParseQuoteString(string format, int pos, StringBuilder result);
    internal static int ParseNextChar(string format, int pos);
    internal static string GetRealFormat(string format, DateTimeFormatInfo dtfi);
    internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi);
    internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(string format, DateTime dateTime);
    [SecuritySafeCriticalAttribute]
internal static void InvalidFormatForUtc(string format, DateTime dateTime);
}
[ComVisibleAttribute("True")]
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
public class System.DateTimeOffset : ValueType {
    internal static long MaxOffset;
    internal static long MinOffset;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    private DateTime m_dateTime;
    private short m_offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static int MaxDateTimeNumberDigits;
    internal static string GMTName;
    internal static string ZuluName;
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DateTimeParse();
    internal static DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static bool IsDigit(char ch);
    internal static bool ProcessHebrewTerminalState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminaltState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    [SecuritySafeCriticalAttribute]
internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    internal static bool TryParseQuoteString(string format, int pos, StringBuilder result, Int32& returnValue);
    [ConditionalAttribute("_LOGGING")]
internal static void LexTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
internal static void PTSTraceExit(DS dps, bool passed);
    [ConditionalAttribute("_LOGGING")]
internal static void TPTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
internal static void DTFITrace(DateTimeFormatInfo dtfi);
}
internal class System.DateTimeRawInfo : ValueType {
    [SecurityCriticalAttribute]
private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool timeZone;
    [SecurityCriticalAttribute]
internal void Init(Int32* numberBuffer);
    [SecuritySafeCriticalAttribute]
internal void AddNumber(int value);
    [SecuritySafeCriticalAttribute]
internal int GetNumber(int index);
}
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal void Init();
    internal void SetDate(int year, int month, int day);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
[ComVisibleAttribute("True")]
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
[ComVisibleAttribute("True")]
public class System.DBNull : object {
    public static DBNull Value;
    private static DBNull();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public class System.Decimal : ValueType {
    private static int SignMask;
    private static byte DECIMAL_NEG;
    private static byte DECIMAL_ADD;
    private static int ScaleMask;
    private static int ScaleShift;
    private static int MaxInt32Scale;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    [SecuritySafeCriticalAttribute]
public Decimal(float value);
    [SecuritySafeCriticalAttribute]
public Decimal(double value);
    [ForceTokenStabilizationAttribute]
internal Decimal(Currency value);
    public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private static Decimal();
    public static long ToOACurrency(decimal value);
    public static decimal FromOACurrency(long cy);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static int Compare(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(decimal value);
    [SecuritySafeCriticalAttribute]
public static decimal Divide(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object value);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool Equals(decimal value);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static bool Equals(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal Floor(decimal d);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static Int32[] GetBits(decimal d);
    internal static void GetBytes(decimal d, Byte[] buffer);
    internal static decimal ToDecimal(Byte[] buffer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
internal static decimal Max(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static decimal Min(decimal d1, decimal d2);
    public static decimal Remainder(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    [SecuritySafeCriticalAttribute]
public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    [SecuritySafeCriticalAttribute]
public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    [SecuritySafeCriticalAttribute]
internal static Currency ToCurrency(decimal d);
    [SecuritySafeCriticalAttribute]
public static double ToDouble(decimal d);
    [SecurityCriticalAttribute]
internal static int FCallToInt32(decimal d);
    [SecuritySafeCriticalAttribute]
public static int ToInt32(decimal d);
    [SecuritySafeCriticalAttribute]
public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public static ulong ToUInt64(decimal d);
    [SecuritySafeCriticalAttribute]
public static float ToSingle(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal Truncate(decimal d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal op_Addition(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal op_Subtraction(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal op_Multiply(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_LessThan(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_GreaterThan(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.DefaultBinder : Binder {
    [CompilerGeneratedAttribute]
private static Predicate`1<Type> CS$<>9__CachedAnonymousMethodDelegate1;
    [SecuritySafeCriticalAttribute]
public virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    [SecuritySafeCriticalAttribute]
public virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    [SecuritySafeCriticalAttribute]
public virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    [SecuritySafeCriticalAttribute]
public virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    internal static bool CompareMethodSigAndName(MethodBase m1, MethodBase m2);
    internal static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    [SecurityCriticalAttribute]
internal static bool CanConvertPrimitiveObjectToType(object source, RuntimeType type);
    [CompilerGeneratedAttribute]
private static bool <SelectProperty>b__0(Type t);
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
public abstract class System.Delegate : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal object _target;
    [SecurityCriticalAttribute]
internal object _methodBase;
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal IntPtr _methodPtr;
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal IntPtr _methodPtrAux;
    public MethodInfo Method { get; }
    public object Target { get; }
    [SecuritySafeCriticalAttribute]
protected Delegate(object target, string method);
    [SecuritySafeCriticalAttribute]
protected Delegate(Type target, string method);
    public object DynamicInvoke(Object[] args);
    [SecuritySafeCriticalAttribute]
protected virtual object DynamicInvokeImpl(Object[] args);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Delegate Combine(Delegate a, Delegate b);
    [ComVisibleAttribute("True")]
public static Delegate Combine(Delegate[] delegates);
    public virtual Delegate[] GetInvocationList();
    public MethodInfo get_Method();
    [SecuritySafeCriticalAttribute]
protected virtual MethodInfo GetMethodImpl();
    public object get_Target();
    [SecuritySafeCriticalAttribute]
public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate CombineImpl(Delegate d);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual object Clone();
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    [SecuritySafeCriticalAttribute]
public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    [SecuritySafeCriticalAttribute]
public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal static Delegate CreateDelegateNoSecurityCheck(Type type, object target, RuntimeMethodHandle method);
    [SecurityCriticalAttribute]
internal static Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static Delegate CreateDelegateInternal(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static Delegate UnsafeCreateDelegate(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags);
    [SecurityCriticalAttribute]
internal static MulticastDelegate InternalAllocLike(Delegate d);
    [SecurityCriticalAttribute]
internal static bool InternalEqualTypes(object a, object b);
    [SecurityCriticalAttribute]
internal IntPtr GetMulticastInvoke();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal IntPtr GetInvokeMethod();
    internal IRuntimeMethodInfo FindMethodHandle();
    [SecurityCriticalAttribute]
internal static bool InternalEqualMethodHandles(Delegate left, Delegate right);
    [SecurityCriticalAttribute]
internal IntPtr AdjustTarget(object target, IntPtr methodPtr);
    [SecurityCriticalAttribute]
internal IntPtr GetCallStub(IntPtr methodPtr);
    [SecuritySafeCriticalAttribute]
internal virtual object GetTarget();
    [SecurityCriticalAttribute]
internal static bool CompareUnmanagedFunctionPtrs(Delegate d1, Delegate d2);
}
internal enum System.DelegateBindingFlags : Enum {
    public int value__;
    public static DelegateBindingFlags StaticMethodOnly;
    public static DelegateBindingFlags InstanceMethodOnly;
    public static DelegateBindingFlags OpenDelegateOnly;
    public static DelegateBindingFlags ClosedDelegateOnly;
    public static DelegateBindingFlags NeverCloseOverNull;
    public static DelegateBindingFlags CaselessMatching;
    public static DelegateBindingFlags SkipSecurityChecks;
    public static DelegateBindingFlags RelaxedSignature;
}
internal class System.DelegateSerializationHolder : object {
    [SecurityCriticalAttribute]
internal static DelegateEntry GetDelegateSerializationInfo(SerializationInfo info, Type delegateType, object target, MethodInfo method, int targetIndex);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("False")]
public static class System.Deployment.Internal.InternalActivationContextHelper : object {
    [SecuritySafeCriticalAttribute]
public static object GetActivationContextData(ActivationContext appInfo);
    [SecuritySafeCriticalAttribute]
public static object GetApplicationComponentManifest(ActivationContext appInfo);
    [SecuritySafeCriticalAttribute]
public static object GetDeploymentComponentManifest(ActivationContext appInfo);
    public static void PrepareForExecution(ActivationContext appInfo);
    public static bool IsFirstRun(ActivationContext appInfo);
    public static Byte[] GetApplicationManifestBytes(ActivationContext appInfo);
    public static Byte[] GetDeploymentManifestBytes(ActivationContext appInfo);
}
[ComVisibleAttribute("False")]
public static class System.Deployment.Internal.InternalApplicationIdentityHelper : object {
    [SecurityCriticalAttribute]
public static object GetInternalAppId(ApplicationIdentity id);
}
internal class System.Deployment.Internal.Isolation.BLOB : ValueType {
    public UInt32 Size;
    public IntPtr BlobData;
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
}
internal class System.Deployment.Internal.Isolation.CATEGORY : ValueType {
    public IDefinitionIdentity DefinitionIdentity;
}
internal class System.Deployment.Internal.Isolation.CATEGORY_INSTANCE : ValueType {
    public IDefinitionAppId DefinitionAppId_Application;
    public string XMLSnippet;
}
internal class System.Deployment.Internal.Isolation.CATEGORY_SUBCATEGORY : ValueType {
    public string Subcategory;
}
[GuidAttribute("0af57545-a72a-4fbe-813c-8554ed7d4528")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IActContext {
    [SecurityCriticalAttribute]
public abstract virtual void GetAppId(Object& AppId);
    [SecurityCriticalAttribute]
public abstract virtual void EnumCategories(UInt32 Flags, IReferenceIdentity CategoryToMatch, Guid& riid, Object& EnumOut);
    [SecurityCriticalAttribute]
public abstract virtual void EnumSubcategories(UInt32 Flags, IDefinitionIdentity CategoryId, string SubcategoryPattern, Guid& riid, Object& EnumOut);
    [SecurityCriticalAttribute]
public abstract virtual void EnumCategoryInstances(UInt32 Flags, IDefinitionIdentity CategoryId, string Subcategory, Guid& riid, Object& EnumOut);
    [SecurityCriticalAttribute]
public abstract virtual void ReplaceStringMacros(UInt32 Flags, string Culture, string ReplacementPattern, String& Replaced);
    [SecurityCriticalAttribute]
public abstract virtual void GetComponentStringTableStrings(UInt32 Flags, IntPtr ComponentIndex, IntPtr StringCount, String[] SourceStrings, String[]& DestinationStrings, IntPtr CultureFallbacks);
    [SecurityCriticalAttribute]
public abstract virtual void GetApplicationProperties(UInt32 Flags, UIntPtr cProperties, String[] PropertyNames, String[]& PropertyValues, UIntPtr[]& ComponentIndicies);
    [SecurityCriticalAttribute]
public abstract virtual void ApplicationBasePath(UInt32 Flags, String& ApplicationPath);
    [SecurityCriticalAttribute]
public abstract virtual void GetComponentManifest(UInt32 Flags, IDefinitionIdentity ComponentId, Guid& riid, Object& ManifestInteface);
    [SecurityCriticalAttribute]
public abstract virtual void GetComponentPayloadPath(UInt32 Flags, IDefinitionIdentity ComponentId, String& PayloadPath);
    [SecurityCriticalAttribute]
public abstract virtual void FindReferenceInContext(UInt32 dwFlags, IReferenceIdentity Reference, Object& MatchedDefinition);
    [SecurityCriticalAttribute]
public abstract virtual void CreateActContextFromCategoryInstance(UInt32 dwFlags, CATEGORY_INSTANCE& CategoryInstance, Object& ppCreatedAppContext);
    [SecurityCriticalAttribute]
public abstract virtual void EnumComponents(UInt32 dwFlags, Object& ppIdentityEnum);
    [SecurityCriticalAttribute]
public abstract virtual void PrepareForExecution(IntPtr Inputs, IntPtr Outputs);
    [SecurityCriticalAttribute]
public abstract virtual void SetApplicationRunningState(UInt32 dwFlags, UInt32 ulState, UInt32& ulDisposition);
    [SecurityCriticalAttribute]
public abstract virtual void GetApplicationStateFilesystemLocation(UInt32 dwFlags, UIntPtr Component, IntPtr pCoordinateList, String& ppszPath);
    [SecurityCriticalAttribute]
public abstract virtual void FindComponentsByDefinition(UInt32 dwFlags, UIntPtr ComponentCount, IDefinitionIdentity[] Components, UIntPtr[] Indicies, UInt32[] Dispositions);
    [SecurityCriticalAttribute]
public abstract virtual void FindComponentsByReference(UInt32 dwFlags, UIntPtr Components, IReferenceIdentity[] References, UIntPtr[] Indicies, UInt32[] Dispositions);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("8c87810c-2541-4f75-b2d0-9af515488e23")]
internal interface System.Deployment.Internal.Isolation.IAppIdAuthority {
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionAppId TextToDefinition(UInt32 Flags, string Identity);
    [SecurityCriticalAttribute]
public abstract virtual IReferenceAppId TextToReference(UInt32 Flags, string Identity);
    [SecurityCriticalAttribute]
public abstract virtual string DefinitionToText(UInt32 Flags, IDefinitionAppId DefinitionAppId);
    [SecurityCriticalAttribute]
public abstract virtual string ReferenceToText(UInt32 Flags, IReferenceAppId ReferenceAppId);
    [SecurityCriticalAttribute]
public abstract virtual bool AreDefinitionsEqual(UInt32 Flags, IDefinitionAppId Definition1, IDefinitionAppId Definition2);
    [SecurityCriticalAttribute]
public abstract virtual bool AreReferencesEqual(UInt32 Flags, IReferenceAppId Reference1, IReferenceAppId Reference2);
    [SecurityCriticalAttribute]
public abstract virtual bool AreTextualDefinitionsEqual(UInt32 Flags, string AppIdLeft, string AppIdRight);
    [SecurityCriticalAttribute]
public abstract virtual bool AreTextualReferencesEqual(UInt32 Flags, string AppIdLeft, string AppIdRight);
    [SecurityCriticalAttribute]
public abstract virtual bool DoesDefinitionMatchReference(UInt32 Flags, IDefinitionAppId DefinitionIdentity, IReferenceAppId ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual bool DoesTextualDefinitionMatchTextualReference(UInt32 Flags, string Definition, string Reference);
    [SecurityCriticalAttribute]
public abstract virtual ulong HashReference(UInt32 Flags, IReferenceAppId ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual ulong HashDefinition(UInt32 Flags, IDefinitionAppId DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual string GenerateDefinitionKey(UInt32 Flags, IDefinitionAppId DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual string GenerateReferenceKey(UInt32 Flags, IReferenceAppId ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionAppId CreateDefinition();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceAppId CreateReference();
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS : Enum {
    public int value__;
    public static IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAG_IGNORE_VERSION;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS : Enum {
    public int value__;
    public static IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAG_IGNORE_VERSION;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("285a8860-c84a-11d7-850f-005cd062464f")]
internal interface System.Deployment.Internal.Isolation.ICDF {
    public object _NewEnum { get; }
    public UInt32 Count { get; }
    public abstract virtual ISection GetRootSection(UInt32 SectionId);
    public abstract virtual ISectionEntry GetRootSectionEntry(UInt32 SectionId);
    public abstract virtual object get__NewEnum();
    public abstract virtual UInt32 get_Count();
    public abstract virtual object GetItem(UInt32 SectionId);
}
[GuidAttribute("d91e12d8-98ed-47fa-9936-39421283d59b")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IDefinitionAppId {
    [SecurityCriticalAttribute]
public abstract virtual string get_SubscriptionId();
    public abstract virtual void put_SubscriptionId(string Subscription);
    [SecurityCriticalAttribute]
public abstract virtual string get_Codebase();
    [SecurityCriticalAttribute]
public abstract virtual void put_Codebase(string CodeBase);
    [SecurityCriticalAttribute]
public abstract virtual IEnumDefinitionIdentity EnumAppPath();
    [SecurityCriticalAttribute]
public abstract virtual void SetAppPath(UInt32 cIDefinitionIdentity, IDefinitionIdentity[] DefinitionIdentity);
}
[GuidAttribute("587bf538-4d90-4a3c-9ef1-58a200a8a9e7")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IDefinitionIdentity {
    [SecurityCriticalAttribute]
public abstract virtual string GetAttribute(string Namespace, string Name);
    [SecurityCriticalAttribute]
public abstract virtual void SetAttribute(string Namespace, string Name, string Value);
    [SecurityCriticalAttribute]
public abstract virtual IEnumIDENTITY_ATTRIBUTE EnumAttributes();
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity Clone(IntPtr cDeltas, IDENTITY_ATTRIBUTE[] Deltas);
}
internal class System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE : ValueType {
    public string Namespace;
    public string Name;
    public string Value;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("f3549d9c-fc73-4793-9c00-1cd204254c0c")]
internal interface System.Deployment.Internal.Isolation.IEnumDefinitionIdentity {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, IDefinitionIdentity[] DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumDefinitionIdentity Clone();
}
[GuidAttribute("9cdaae75-246e-4b00-a26d-b9aec137a3eb")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumIDENTITY_ATTRIBUTE {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, IDENTITY_ATTRIBUTE[] rgAttributes);
    [SecurityCriticalAttribute]
public abstract virtual IntPtr CurrentIntoBuffer(IntPtr Available, Byte[] Data);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumIDENTITY_ATTRIBUTE Clone();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("b30352cf-23da-4577-9b3f-b4e6573be53b")]
internal interface System.Deployment.Internal.Isolation.IEnumReferenceIdentity {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, IReferenceIdentity[] ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumReferenceIdentity Clone();
}
[GuidAttribute("a5c637bf-6eaa-4e5f-b535-55299657e33e")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_ASSEMBLY {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, STORE_ASSEMBLY[] rgelt);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_ASSEMBLY Clone();
}
[GuidAttribute("a5c6aaa3-03e4-478d-b9f5-2e45908d5e4f")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_ASSEMBLY_FILE {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, STORE_ASSEMBLY_FILE[] rgelt);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_ASSEMBLY_FILE Clone();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("d8b1aacb-5142-4abb-bcc1-e9dc9052a89e")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, StoreApplicationReference[] rgelt);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE Clone();
}
[GuidAttribute("b840a2f5-a497-4a6d-9038-cd3ec2fbd222")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_CATEGORY {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, STORE_CATEGORY[] rgElements);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 ulElements);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_CATEGORY Clone();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("5ba7cb30-8508-4114-8c77-262fcda4fadb")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_CATEGORY_INSTANCE {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 ulElements, STORE_CATEGORY_INSTANCE[] rgInstances);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 ulElements);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_CATEGORY_INSTANCE Clone();
}
[GuidAttribute("19be1967-b2fc-4dc1-9627-f3cb6305d2a7")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_CATEGORY_SUBCATEGORY {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, STORE_CATEGORY_SUBCATEGORY[] rgElements);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 ulElements);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_CATEGORY_SUBCATEGORY Clone();
}
[GuidAttribute("f9fd4090-93db-45c0-af87-624940f19cff")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_DEPLOYMENT_METADATA {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, IDefinitionAppId[] AppIds);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_DEPLOYMENT_METADATA Clone();
}
[GuidAttribute("5fa4f590-a416-4b22-ac79-7c3f0d31f303")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY {
    [SecurityCriticalAttribute]
public abstract virtual UInt32 Next(UInt32 celt, StoreOperationMetadataProperty[] AppIds);
    [SecurityCriticalAttribute]
public abstract virtual void Skip(UInt32 celt);
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public abstract virtual IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY Clone();
}
[GuidAttribute("00000100-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IEnumUnknown {
    public abstract virtual int Next(UInt32 celt, Object[] rgelt, UInt32& celtFetched);
    public abstract virtual int Skip(UInt32 celt);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IEnumUnknown& enumUnknown);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("261a6983-c35d-4d0d-aa5b-7867259e77bc")]
internal interface System.Deployment.Internal.Isolation.IIdentityAuthority {
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity TextToDefinition(UInt32 Flags, string Identity);
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity TextToReference(UInt32 Flags, string Identity);
    [SecurityCriticalAttribute]
public abstract virtual string DefinitionToText(UInt32 Flags, IDefinitionIdentity DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual UInt32 DefinitionToTextBuffer(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, UInt32 BufferSize, Char[] Buffer);
    [SecurityCriticalAttribute]
public abstract virtual string ReferenceToText(UInt32 Flags, IReferenceIdentity ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual UInt32 ReferenceToTextBuffer(UInt32 Flags, IReferenceIdentity ReferenceIdentity, UInt32 BufferSize, Char[] Buffer);
    [SecurityCriticalAttribute]
public abstract virtual bool AreDefinitionsEqual(UInt32 Flags, IDefinitionIdentity Definition1, IDefinitionIdentity Definition2);
    [SecurityCriticalAttribute]
public abstract virtual bool AreReferencesEqual(UInt32 Flags, IReferenceIdentity Reference1, IReferenceIdentity Reference2);
    [SecurityCriticalAttribute]
public abstract virtual bool AreTextualDefinitionsEqual(UInt32 Flags, string IdentityLeft, string IdentityRight);
    [SecurityCriticalAttribute]
public abstract virtual bool AreTextualReferencesEqual(UInt32 Flags, string IdentityLeft, string IdentityRight);
    [SecurityCriticalAttribute]
public abstract virtual bool DoesDefinitionMatchReference(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, IReferenceIdentity ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual bool DoesTextualDefinitionMatchTextualReference(UInt32 Flags, string Definition, string Reference);
    [SecurityCriticalAttribute]
public abstract virtual ulong HashReference(UInt32 Flags, IReferenceIdentity ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual ulong HashDefinition(UInt32 Flags, IDefinitionIdentity DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual string GenerateDefinitionKey(UInt32 Flags, IDefinitionIdentity DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual string GenerateReferenceKey(UInt32 Flags, IReferenceIdentity ReferenceIdentity);
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity CreateDefinition();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity CreateReference();
}
internal enum System.Deployment.Internal.Isolation.IIDENTITYAUTHORITY_DEFINITION_IDENTITY_TO_TEXT_FLAGS : Enum {
    public int value__;
    public static IIDENTITYAUTHORITY_DEFINITION_IDENTITY_TO_TEXT_FLAGS IIDENTITYAUTHORITY_DEFINITION_IDENTITY_TO_TEXT_FLAG_CANONICAL;
}
internal enum System.Deployment.Internal.Isolation.IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAGS : Enum {
    public int value__;
    public static IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAGS IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAG_EXACT_MATCH_REQUIRED;
}
internal enum System.Deployment.Internal.Isolation.IIDENTITYAUTHORITY_REFERENCE_IDENTITY_TO_TEXT_FLAGS : Enum {
    public int value__;
    public static IIDENTITYAUTHORITY_REFERENCE_IDENTITY_TO_TEXT_FLAGS IIDENTITYAUTHORITY_REFERENCE_IDENTITY_TO_TEXT_FLAG_CANONICAL;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("81c85208-fe61-4c15-b5bb-ff5ea66baad9")]
internal interface System.Deployment.Internal.Isolation.IManifestInformation {
    [SecurityCriticalAttribute]
public abstract virtual void get_FullPath(String& FullPath);
}
[GuidAttribute("ace1b703-1aac-4956-ab87-90cac8b93ce6")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IManifestParseErrorCallback {
    [SecurityCriticalAttribute]
public abstract virtual void OnError(UInt32 StartLine, UInt32 nStartColumn, UInt32 cCharacterCount, int hr, string ErrorStatusHostFile, UInt32 ParameterCount, String[] Parameters);
}
[GuidAttribute("054f0bef-9e45-4363-8f5a-2f8e142d9a3b")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IReferenceAppId {
    [SecurityCriticalAttribute]
public abstract virtual string get_SubscriptionId();
    public abstract virtual void put_SubscriptionId(string Subscription);
    [SecurityCriticalAttribute]
public abstract virtual string get_Codebase();
    public abstract virtual void put_Codebase(string CodeBase);
    [SecurityCriticalAttribute]
public abstract virtual IEnumReferenceIdentity EnumAppPath();
}
[GuidAttribute("6eaf5ace-7917-4f3c-b129-e046a9704766")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IReferenceIdentity {
    [SecurityCriticalAttribute]
public abstract virtual string GetAttribute(string Namespace, string Name);
    [SecurityCriticalAttribute]
public abstract virtual void SetAttribute(string Namespace, string Name, string Value);
    [SecurityCriticalAttribute]
public abstract virtual IEnumIDENTITY_ATTRIBUTE EnumAttributes();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity Clone(IntPtr cDeltas, IDENTITY_ATTRIBUTE[] Deltas);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("285a8862-c84a-11d7-850f-005cd062464f")]
internal interface System.Deployment.Internal.Isolation.ISection {
    public object _NewEnum { get; }
    public UInt32 Count { get; }
    public UInt32 SectionID { get; }
    public string SectionName { get; }
    public abstract virtual object get__NewEnum();
    public abstract virtual UInt32 get_Count();
    public abstract virtual UInt32 get_SectionID();
    public abstract virtual string get_SectionName();
}
[GuidAttribute("285a8861-c84a-11d7-850f-005cd062464f")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.ISectionEntry {
    public abstract virtual object GetField(UInt32 fieldId);
    public abstract virtual string GetFieldName(UInt32 fieldId);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("285a8876-c84a-11d7-850f-005cd062464f")]
internal interface System.Deployment.Internal.Isolation.ISectionWithReferenceIdentityKey {
    public abstract virtual void Lookup(IReferenceIdentity ReferenceIdentityKey, Object& ppUnknown);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("285a8871-c84a-11d7-850f-005cd062464f")]
internal interface System.Deployment.Internal.Isolation.ISectionWithStringKey {
    public bool IsCaseInsensitive { get; }
    public abstract virtual void Lookup(string wzStringKey, Object& ppUnknown);
    public abstract virtual bool get_IsCaseInsensitive();
}
internal static class System.Deployment.Internal.Isolation.IsolationInterop : object {
    public static string IsolationDllName;
    public static Guid IID_ICMS;
    public static Guid IID_IDefinitionIdentity;
    public static Guid IID_IManifestInformation;
    public static Guid IID_IEnumSTORE_ASSEMBLY;
    public static Guid IID_IEnumSTORE_ASSEMBLY_FILE;
    public static Guid IID_IEnumSTORE_CATEGORY;
    public static Guid IID_IEnumSTORE_CATEGORY_INSTANCE;
    public static Guid IID_IEnumSTORE_DEPLOYMENT_METADATA;
    public static Guid IID_IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY;
    public static Guid IID_IStore;
    public static Guid GUID_SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    public static Guid SXS_INSTALL_REFERENCE_SCHEME_SXS_STRONGNAME_SIGNED_PRIVATE_ASSEMBLY;
    public static IIdentityAuthority IdentityAuthority { get; }
    public static IAppIdAuthority AppIdAuthority { get; }
    private static IsolationInterop();
    [SecuritySafeCriticalAttribute]
public static Store GetUserStore();
    [SecuritySafeCriticalAttribute]
public static IIdentityAuthority get_IdentityAuthority();
    [SecuritySafeCriticalAttribute]
public static IAppIdAuthority get_AppIdAuthority();
    [SecuritySafeCriticalAttribute]
internal static IActContext CreateActContext(IDefinitionAppId AppId);
    internal static object CreateActContext(CreateActContextParameters& Params);
    [SecurityCriticalAttribute]
internal static object CreateCMSFromXml(Byte[] buffer, UInt32 bufferSize, IManifestParseErrorCallback Callback, Guid& riid);
    [SecurityCriticalAttribute]
internal static object ParseManifest(string pszManifestPath, IManifestParseErrorCallback pIManifestParseErrorCallback, Guid& riid);
    internal static Guid GetGuidOfType(Type type);
}
[GuidAttribute("07662534-750b-4ed5-9cfb-1c5bc5acfd07")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IStateManager {
    [SecurityCriticalAttribute]
public abstract virtual void PrepareApplicationState(UIntPtr Inputs, UIntPtr& Outputs);
    [SecurityCriticalAttribute]
public abstract virtual void SetApplicationRunningState(UInt32 Flags, IActContext Context, UInt32 RunningState, UInt32& Disposition);
    [SecurityCriticalAttribute]
public abstract virtual void GetApplicationStateFilesystemLocation(UInt32 Flags, IDefinitionAppId Appidentity, IDefinitionIdentity ComponentIdentity, UIntPtr Coordinates, String& Path);
    [SecurityCriticalAttribute]
public abstract virtual void Scavenge(UInt32 Flags, UInt32& Disposition);
}
[GuidAttribute("a5c62f6d-5e3e-4cd9-b345-6b281d7a1d1e")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.IStore {
    [SecurityCriticalAttribute]
public abstract virtual void Transact(IntPtr cOperation, StoreTransactionOperation[] rgOperations, UInt32[] rgDispositions, Int32[] rgResults);
    [SecurityCriticalAttribute]
public abstract virtual object BindReferenceToAssembly(UInt32 Flags, IReferenceIdentity ReferenceIdentity, UInt32 cDeploymentsToIgnore, IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual void CalculateDelimiterOfDeploymentsBasedOnQuota(UInt32 dwFlags, IntPtr cDeployments, IDefinitionAppId[] rgpIDefinitionAppId_Deployments, StoreApplicationReference& InstallerReference, ulong ulonglongQuota, IntPtr& Delimiter, UInt64& SizeSharedWithExternalDeployment, UInt64& SizeConsumedByInputDeploymentArray);
    [SecurityCriticalAttribute]
public abstract virtual IntPtr BindDefinitions(UInt32 Flags, IntPtr Count, IDefinitionIdentity[] DefsToBind, UInt32 DeploymentsToIgnore, IDefinitionIdentity[] DefsToIgnore);
    [SecurityCriticalAttribute]
public abstract virtual object GetAssemblyInformation(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumAssemblies(UInt32 Flags, IReferenceIdentity ReferenceIdentity_ToMatch, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumFiles(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumInstallationReferences(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual string LockAssemblyPath(UInt32 Flags, IDefinitionIdentity DefinitionIdentity, IntPtr& Cookie);
    [SecurityCriticalAttribute]
public abstract virtual void ReleaseAssemblyPath(IntPtr Cookie);
    [SecurityCriticalAttribute]
public abstract virtual ulong QueryChangeID(IDefinitionIdentity DefinitionIdentity);
    [SecurityCriticalAttribute]
public abstract virtual object EnumCategories(UInt32 Flags, IReferenceIdentity ReferenceIdentity_ToMatch, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumSubcategories(UInt32 Flags, IDefinitionIdentity CategoryId, string SubcategoryPathPattern, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumCategoryInstances(UInt32 Flags, IDefinitionIdentity CategoryId, string SubcategoryPath, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual void GetDeploymentProperty(UInt32 Flags, IDefinitionAppId DeploymentInPackage, StoreApplicationReference& Reference, Guid& PropertySet, string pcwszPropertyName, BLOB& blob);
    [SecurityCriticalAttribute]
public abstract virtual string LockApplicationPath(UInt32 Flags, IDefinitionAppId ApId, IntPtr& Cookie);
    [SecurityCriticalAttribute]
public abstract virtual void ReleaseApplicationPath(IntPtr Cookie);
    [SecurityCriticalAttribute]
public abstract virtual object EnumPrivateFiles(UInt32 Flags, IDefinitionAppId Application, IDefinitionIdentity DefinitionIdentity, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumInstallerDeploymentMetadata(UInt32 Flags, StoreApplicationReference& Reference, IReferenceAppId Filter, Guid& riid);
    [SecurityCriticalAttribute]
public abstract virtual object EnumInstallerDeploymentMetadataProperties(UInt32 Flags, StoreApplicationReference& Reference, IDefinitionAppId Filter, Guid& riid);
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.ISTORE_BIND_REFERENCE_TO_ASSEMBLY_FLAGS : Enum {
    public int value__;
    public static ISTORE_BIND_REFERENCE_TO_ASSEMBLY_FLAGS ISTORE_BIND_REFERENCE_TO_ASSEMBLY_FLAG_FORCE_LIBRARY_SEMANTICS;
}
internal class System.Deployment.Internal.Isolation.IStore_BindingResult : ValueType {
    public UInt32 Flags;
    public UInt32 Disposition;
    public IStore_BindingResult_BoundVersion Component;
    public Guid CacheCoherencyGuid;
    public IntPtr Reserved;
}
internal class System.Deployment.Internal.Isolation.IStore_BindingResult_BoundVersion : ValueType {
    public ushort Revision;
    public ushort Build;
    public ushort Minor;
    public ushort Major;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.ISTORE_ENUM_ASSEMBLIES_FLAGS : Enum {
    public int value__;
    public static ISTORE_ENUM_ASSEMBLIES_FLAGS ISTORE_ENUM_ASSEMBLIES_FLAG_LIMIT_TO_VISIBLE_ONLY;
    public static ISTORE_ENUM_ASSEMBLIES_FLAGS ISTORE_ENUM_ASSEMBLIES_FLAG_MATCH_SERVICING;
    public static ISTORE_ENUM_ASSEMBLIES_FLAGS ISTORE_ENUM_ASSEMBLIES_FLAG_FORCE_LIBRARY_SEMANTICS;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.ISTORE_ENUM_FILES_FLAGS : Enum {
    public int value__;
    public static ISTORE_ENUM_FILES_FLAGS ISTORE_ENUM_FILES_FLAG_INCLUDE_INSTALLED_FILES;
    public static ISTORE_ENUM_FILES_FLAGS ISTORE_ENUM_FILES_FLAG_INCLUDE_MISSING_FILES;
}
internal class System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceDependentAssemblyEntry : object {
    public string Group;
    public string Codebase;
    public ulong Size;
    public IntPtr HashValue;
    public UInt32 HashValueSize;
    public UInt32 HashAlgorithm;
    public UInt32 Flags;
    public string ResourceFallbackCulture;
    public string Description;
    public string SupportUrl;
    public ISection HashElements;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceDependentAssemblyEntryFieldId : Enum {
    public int value__;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_Group;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_Codebase;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_Size;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_HashValue;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_HashValueSize;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_HashAlgorithm;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_Flags;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_ResourceFallbackCulture;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_Description;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_SupportUrl;
    public static AssemblyReferenceDependentAssemblyEntryFieldId AssemblyReferenceDependentAssembly_HashElements;
}
internal class System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceEntry : object {
    public IReferenceIdentity ReferenceIdentity;
    public UInt32 Flags;
    public AssemblyReferenceDependentAssemblyEntry DependentAssembly;
}
internal enum System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceEntryFieldId : Enum {
    public int value__;
    public static AssemblyReferenceEntryFieldId AssemblyReference_Flags;
    public static AssemblyReferenceEntryFieldId AssemblyReference_DependentAssembly;
}
internal class System.Deployment.Internal.Isolation.Manifest.AssemblyRequestEntry : object {
    public string Name;
    public string permissionSetID;
}
internal enum System.Deployment.Internal.Isolation.Manifest.AssemblyRequestEntryFieldId : Enum {
    public int value__;
    public static AssemblyRequestEntryFieldId AssemblyRequest_permissionSetID;
}
internal class System.Deployment.Internal.Isolation.Manifest.CategoryMembershipDataEntry : object {
    public UInt32 index;
    public string Xml;
    public string Description;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CategoryMembershipDataEntryFieldId : Enum {
    public int value__;
    public static CategoryMembershipDataEntryFieldId CategoryMembershipData_Xml;
    public static CategoryMembershipDataEntryFieldId CategoryMembershipData_Description;
}
internal class System.Deployment.Internal.Isolation.Manifest.CategoryMembershipEntry : object {
    public IDefinitionIdentity Identity;
    public ISection SubcategoryMembership;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CategoryMembershipEntryFieldId : Enum {
    public int value__;
    public static CategoryMembershipEntryFieldId CategoryMembership_SubcategoryMembership;
}
internal class System.Deployment.Internal.Isolation.Manifest.CLRSurrogateEntry : object {
    public Guid Clsid;
    public string RuntimeVersion;
    public string ClassName;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CLRSurrogateEntryFieldId : Enum {
    public int value__;
    public static CLRSurrogateEntryFieldId CLRSurrogate_RuntimeVersion;
    public static CLRSurrogateEntryFieldId CLRSurrogate_ClassName;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_ASSEMBLY_DEPLOYMENT_FLAG : Enum {
    public int value__;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_BEFORE_APPLICATION_STARTUP;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_RUN_AFTER_INSTALL;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_INSTALL;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_TRUST_URL_PARAMETERS;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_DISALLOW_URL_ACTIVATION;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_MAP_FILE_EXTENSIONS;
    public static CMS_ASSEMBLY_DEPLOYMENT_FLAG CMS_ASSEMBLY_DEPLOYMENT_FLAG_CREATE_DESKTOP_SHORTCUT;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG : Enum {
    public int value__;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_OPTIONAL;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_VISIBLE;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_PREREQUISITE;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_RESOURCE_FALLBACK_CULTURE_INTERNAL;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_INSTALL;
    public static CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_ALLOW_DELAYED_BINDING;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_ASSEMBLY_REFERENCE_FLAG : Enum {
    public int value__;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_OPTIONAL;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_VISIBLE;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_FOLLOW;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_IS_PLATFORM;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_CULTURE_WILDCARDED;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_PROCESSOR_ARCHITECTURE_WILDCARDED;
    public static CMS_ASSEMBLY_REFERENCE_FLAG CMS_ASSEMBLY_REFERENCE_FLAG_PREREQUISITE;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_COM_SERVER_FLAG : Enum {
    public int value__;
    public static CMS_COM_SERVER_FLAG CMS_COM_SERVER_FLAG_IS_CLR_CLASS;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_ENTRY_POINT_FLAG : Enum {
    public int value__;
    public static CMS_ENTRY_POINT_FLAG CMS_ENTRY_POINT_FLAG_HOST_IN_BROWSER;
    public static CMS_ENTRY_POINT_FLAG CMS_ENTRY_POINT_FLAG_CUSTOMHOSTSPECIFIED;
    public static CMS_ENTRY_POINT_FLAG CMS_ENTRY_POINT_FLAG_CUSTOMUX;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_FILE_FLAG : Enum {
    public int value__;
    public static CMS_FILE_FLAG CMS_FILE_FLAG_OPTIONAL;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_FILE_HASH_ALGORITHM : Enum {
    public int value__;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_SHA1;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_SHA256;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_SHA384;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_SHA512;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_MD5;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_MD4;
    public static CMS_FILE_HASH_ALGORITHM CMS_FILE_HASH_ALGORITHM_MD2;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_FILE_WRITABLE_TYPE : Enum {
    public int value__;
    public static CMS_FILE_WRITABLE_TYPE CMS_FILE_WRITABLE_TYPE_NOT_WRITABLE;
    public static CMS_FILE_WRITABLE_TYPE CMS_FILE_WRITABLE_TYPE_APPLICATION_DATA;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD : Enum {
    public int value__;
    public static CMS_HASH_DIGESTMETHOD CMS_HASH_DIGESTMETHOD_SHA1;
    public static CMS_HASH_DIGESTMETHOD CMS_HASH_DIGESTMETHOD_SHA256;
    public static CMS_HASH_DIGESTMETHOD CMS_HASH_DIGESTMETHOD_SHA384;
    public static CMS_HASH_DIGESTMETHOD CMS_HASH_DIGESTMETHOD_SHA512;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM : Enum {
    public int value__;
    public static CMS_HASH_TRANSFORM CMS_HASH_TRANSFORM_IDENTITY;
    public static CMS_HASH_TRANSFORM CMS_HASH_TRANSFORM_MANIFESTINVARIANT;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_SCHEMA_VERSION : Enum {
    public int value__;
    public static CMS_SCHEMA_VERSION CMS_SCHEMA_VERSION_V1;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_TIME_UNIT_TYPE : Enum {
    public int value__;
    public static CMS_TIME_UNIT_TYPE CMS_TIME_UNIT_TYPE_HOURS;
    public static CMS_TIME_UNIT_TYPE CMS_TIME_UNIT_TYPE_DAYS;
    public static CMS_TIME_UNIT_TYPE CMS_TIME_UNIT_TYPE_WEEKS;
    public static CMS_TIME_UNIT_TYPE CMS_TIME_UNIT_TYPE_MONTHS;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMS_USAGE_PATTERN : Enum {
    public int value__;
    public static CMS_USAGE_PATTERN CMS_USAGE_PATTERN_SCOPE_APPLICATION;
    public static CMS_USAGE_PATTERN CMS_USAGE_PATTERN_SCOPE_PROCESS;
    public static CMS_USAGE_PATTERN CMS_USAGE_PATTERN_SCOPE_MACHINE;
    public static CMS_USAGE_PATTERN CMS_USAGE_PATTERN_SCOPE_MASK;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CMSSECTIONID : Enum {
    public int value__;
    public static CMSSECTIONID CMSSECTIONID_FILE_SECTION;
    public static CMSSECTIONID CMSSECTIONID_CATEGORY_INSTANCE_SECTION;
    public static CMSSECTIONID CMSSECTIONID_COM_REDIRECTION_SECTION;
    public static CMSSECTIONID CMSSECTIONID_PROGID_REDIRECTION_SECTION;
    public static CMSSECTIONID CMSSECTIONID_CLR_SURROGATE_SECTION;
    public static CMSSECTIONID CMSSECTIONID_ASSEMBLY_REFERENCE_SECTION;
    public static CMSSECTIONID CMSSECTIONID_WINDOW_CLASS_SECTION;
    public static CMSSECTIONID CMSSECTIONID_STRING_SECTION;
    public static CMSSECTIONID CMSSECTIONID_ENTRYPOINT_SECTION;
    public static CMSSECTIONID CMSSECTIONID_PERMISSION_SET_SECTION;
    public static CMSSECTIONID CMSSECTIONENTRYID_METADATA;
    public static CMSSECTIONID CMSSECTIONID_ASSEMBLY_REQUEST_SECTION;
    public static CMSSECTIONID CMSSECTIONID_REGISTRY_KEY_SECTION;
    public static CMSSECTIONID CMSSECTIONID_DIRECTORY_SECTION;
    public static CMSSECTIONID CMSSECTIONID_FILE_ASSOCIATION_SECTION;
    public static CMSSECTIONID CMSSECTIONID_COMPATIBLE_FRAMEWORKS_SECTION;
    public static CMSSECTIONID CMSSECTIONID_EVENT_SECTION;
    public static CMSSECTIONID CMSSECTIONID_EVENT_MAP_SECTION;
    public static CMSSECTIONID CMSSECTIONID_EVENT_TAG_SECTION;
    public static CMSSECTIONID CMSSECTIONID_COUNTERSET_SECTION;
    public static CMSSECTIONID CMSSECTIONID_COUNTER_SECTION;
}
[SecuritySafeCriticalAttribute]
internal static class System.Deployment.Internal.Isolation.Manifest.CmsUtils : object {
    internal static void GetEntryPoint(ActivationContext activationContext, String& fileName, String& parameters);
    internal static IAssemblyReferenceEntry[] GetDependentAssemblies(ActivationContext activationContext);
    internal static string GetEntryPointFullPath(ActivationArguments activationArguments);
    internal static string GetEntryPointFullPath(ActivationContext activationContext);
    internal static bool CompareIdentities(ActivationContext activationContext1, ActivationContext activationContext2);
    internal static bool CompareIdentities(ApplicationIdentity applicationIdentity1, ApplicationIdentity applicationIdentity2, ApplicationVersionMatch versionMatch);
    internal static string GetFriendlyName(ActivationContext activationContext);
    internal static void CreateActivationContext(string fullName, String[] manifestPaths, bool useFusionActivationContext, ApplicationIdentity& applicationIdentity, ActivationContext& activationContext);
    internal static Evidence MergeApplicationEvidence(Evidence evidence, ApplicationIdentity applicationIdentity, ActivationContext activationContext, String[] activationData);
    internal static Evidence MergeApplicationEvidence(Evidence evidence, ApplicationIdentity applicationIdentity, ActivationContext activationContext, String[] activationData, ApplicationTrust applicationTrust);
}
internal class System.Deployment.Internal.Isolation.Manifest.CompatibleFrameworksMetadataEntry : object {
    public string SupportUrl;
}
internal enum System.Deployment.Internal.Isolation.Manifest.CompatibleFrameworksMetadataEntryFieldId : Enum {
    public int value__;
    public static CompatibleFrameworksMetadataEntryFieldId CompatibleFrameworksMetadata_SupportUrl;
}
internal class System.Deployment.Internal.Isolation.Manifest.COMServerEntry : object {
    public Guid Clsid;
    public UInt32 Flags;
    public Guid ConfiguredGuid;
    public Guid ImplementedClsid;
    public Guid TypeLibrary;
    public UInt32 ThreadingModel;
    public string RuntimeVersion;
    public string HostFile;
}
internal enum System.Deployment.Internal.Isolation.Manifest.COMServerEntryFieldId : Enum {
    public int value__;
    public static COMServerEntryFieldId COMServer_Flags;
    public static COMServerEntryFieldId COMServer_ConfiguredGuid;
    public static COMServerEntryFieldId COMServer_ImplementedClsid;
    public static COMServerEntryFieldId COMServer_TypeLibrary;
    public static COMServerEntryFieldId COMServer_ThreadingModel;
    public static COMServerEntryFieldId COMServer_RuntimeVersion;
    public static COMServerEntryFieldId COMServer_HostFile;
}
internal class System.Deployment.Internal.Isolation.Manifest.DependentOSMetadataEntry : object {
    public string SupportUrl;
    public string Description;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public ushort BuildNumber;
    public byte ServicePackMajor;
    public byte ServicePackMinor;
}
internal enum System.Deployment.Internal.Isolation.Manifest.DependentOSMetadataEntryFieldId : Enum {
    public int value__;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_SupportUrl;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_Description;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_MajorVersion;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_MinorVersion;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_BuildNumber;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_ServicePackMajor;
    public static DependentOSMetadataEntryFieldId DependentOSMetadata_ServicePackMinor;
}
internal class System.Deployment.Internal.Isolation.Manifest.DeploymentMetadataEntry : object {
    public string DeploymentProviderCodebase;
    public string MinimumRequiredVersion;
    public ushort MaximumAge;
    public byte MaximumAge_Unit;
    public UInt32 DeploymentFlags;
}
internal enum System.Deployment.Internal.Isolation.Manifest.DeploymentMetadataEntryFieldId : Enum {
    public int value__;
    public static DeploymentMetadataEntryFieldId DeploymentMetadata_DeploymentProviderCodebase;
    public static DeploymentMetadataEntryFieldId DeploymentMetadata_MinimumRequiredVersion;
    public static DeploymentMetadataEntryFieldId DeploymentMetadata_MaximumAge;
    public static DeploymentMetadataEntryFieldId DeploymentMetadata_MaximumAge_Unit;
    public static DeploymentMetadataEntryFieldId DeploymentMetadata_DeploymentFlags;
}
internal class System.Deployment.Internal.Isolation.Manifest.DescriptionMetadataEntry : object {
    public string Publisher;
    public string Product;
    public string SupportUrl;
    public string IconFile;
    public string ErrorReportUrl;
    public string SuiteName;
}
internal enum System.Deployment.Internal.Isolation.Manifest.DescriptionMetadataEntryFieldId : Enum {
    public int value__;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_Publisher;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_Product;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_SupportUrl;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_IconFile;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_ErrorReportUrl;
    public static DescriptionMetadataEntryFieldId DescriptionMetadata_SuiteName;
}
internal class System.Deployment.Internal.Isolation.Manifest.EntryPointEntry : object {
    public string Name;
    public string CommandLine_File;
    public string CommandLine_Parameters;
    public IReferenceIdentity Identity;
    public UInt32 Flags;
}
internal enum System.Deployment.Internal.Isolation.Manifest.EntryPointEntryFieldId : Enum {
    public int value__;
    public static EntryPointEntryFieldId EntryPoint_CommandLine_File;
    public static EntryPointEntryFieldId EntryPoint_CommandLine_Parameters;
    public static EntryPointEntryFieldId EntryPoint_Identity;
    public static EntryPointEntryFieldId EntryPoint_Flags;
}
internal class System.Deployment.Internal.Isolation.Manifest.FileAssociationEntry : object {
    public string Extension;
    public string Description;
    public string ProgID;
    public string DefaultIcon;
    public string Parameter;
}
internal enum System.Deployment.Internal.Isolation.Manifest.FileAssociationEntryFieldId : Enum {
    public int value__;
    public static FileAssociationEntryFieldId FileAssociation_Description;
    public static FileAssociationEntryFieldId FileAssociation_ProgID;
    public static FileAssociationEntryFieldId FileAssociation_DefaultIcon;
    public static FileAssociationEntryFieldId FileAssociation_Parameter;
}
internal class System.Deployment.Internal.Isolation.Manifest.FileEntry : object {
    public string Name;
    public UInt32 HashAlgorithm;
    public string LoadFrom;
    public string SourcePath;
    public string ImportPath;
    public string SourceName;
    public string Location;
    public IntPtr HashValue;
    public UInt32 HashValueSize;
    public ulong Size;
    public string Group;
    public UInt32 Flags;
    public MuiResourceMapEntry MuiMapping;
    public UInt32 WritableType;
    public ISection HashElements;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.FileEntryFieldId : Enum {
    public int value__;
    public static FileEntryFieldId File_HashAlgorithm;
    public static FileEntryFieldId File_LoadFrom;
    public static FileEntryFieldId File_SourcePath;
    public static FileEntryFieldId File_ImportPath;
    public static FileEntryFieldId File_SourceName;
    public static FileEntryFieldId File_Location;
    public static FileEntryFieldId File_HashValue;
    public static FileEntryFieldId File_HashValueSize;
    public static FileEntryFieldId File_Size;
    public static FileEntryFieldId File_Group;
    public static FileEntryFieldId File_Flags;
    public static FileEntryFieldId File_MuiMapping;
    public static FileEntryFieldId File_WritableType;
    public static FileEntryFieldId File_HashElements;
}
internal class System.Deployment.Internal.Isolation.Manifest.HashElementEntry : object {
    public UInt32 index;
    public byte Transform;
    public IntPtr TransformMetadata;
    public UInt32 TransformMetadataSize;
    public byte DigestMethod;
    public IntPtr DigestValue;
    public UInt32 DigestValueSize;
    public string Xml;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.HashElementEntryFieldId : Enum {
    public int value__;
    public static HashElementEntryFieldId HashElement_Transform;
    public static HashElementEntryFieldId HashElement_TransformMetadata;
    public static HashElementEntryFieldId HashElement_TransformMetadataSize;
    public static HashElementEntryFieldId HashElement_DigestMethod;
    public static HashElementEntryFieldId HashElement_DigestValue;
    public static HashElementEntryFieldId HashElement_DigestValueSize;
    public static HashElementEntryFieldId HashElement_Xml;
}
[GuidAttribute("C31FF59E-CD25-47b8-9EF3-CF4433EB97CC")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceDependentAssemblyEntry {
    public AssemblyReferenceDependentAssemblyEntry AllData { get; }
    public string Group { get; }
    public string Codebase { get; }
    public ulong Size { get; }
    public object HashValue { get; }
    public UInt32 HashAlgorithm { get; }
    public UInt32 Flags { get; }
    public string ResourceFallbackCulture { get; }
    public string Description { get; }
    public string SupportUrl { get; }
    public ISection HashElements { get; }
    [SecurityCriticalAttribute]
public abstract virtual AssemblyReferenceDependentAssemblyEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Group();
    [SecurityCriticalAttribute]
public abstract virtual string get_Codebase();
    [SecurityCriticalAttribute]
public abstract virtual ulong get_Size();
    [SecurityCriticalAttribute]
public abstract virtual object get_HashValue();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_HashAlgorithm();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Flags();
    [SecurityCriticalAttribute]
public abstract virtual string get_ResourceFallbackCulture();
    [SecurityCriticalAttribute]
public abstract virtual string get_Description();
    [SecurityCriticalAttribute]
public abstract virtual string get_SupportUrl();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_HashElements();
}
[GuidAttribute("FD47B733-AFBC-45e4-B7C2-BBEB1D9F766C")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceEntry {
    public AssemblyReferenceEntry AllData { get; }
    public IReferenceIdentity ReferenceIdentity { get; }
    public UInt32 Flags { get; }
    public IAssemblyReferenceDependentAssemblyEntry DependentAssembly { get; }
    [SecurityCriticalAttribute]
public abstract virtual AssemblyReferenceEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity get_ReferenceIdentity();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Flags();
    [SecurityCriticalAttribute]
public abstract virtual IAssemblyReferenceDependentAssemblyEntry get_DependentAssembly();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2474ECB4-8EFD-4410-9F31-B3E7C4A07731")]
internal interface System.Deployment.Internal.Isolation.Manifest.IAssemblyRequestEntry {
    public AssemblyRequestEntry AllData { get; }
    public string Name { get; }
    public string permissionSetID { get; }
    [SecurityCriticalAttribute]
public abstract virtual AssemblyRequestEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Name();
    [SecurityCriticalAttribute]
public abstract virtual string get_permissionSetID();
}
[GuidAttribute("DA0C3B27-6B6B-4b80-A8F8-6CE14F4BC0A4")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICategoryMembershipDataEntry {
    public CategoryMembershipDataEntry AllData { get; }
    public UInt32 index { get; }
    public string Xml { get; }
    public string Description { get; }
    [SecurityCriticalAttribute]
public abstract virtual CategoryMembershipDataEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_index();
    [SecurityCriticalAttribute]
public abstract virtual string get_Xml();
    [SecurityCriticalAttribute]
public abstract virtual string get_Description();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("97FDCA77-B6F2-4718-A1EB-29D0AECE9C03")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICategoryMembershipEntry {
    public CategoryMembershipEntry AllData { get; }
    public IDefinitionIdentity Identity { get; }
    public ISection SubcategoryMembership { get; }
    [SecurityCriticalAttribute]
public abstract virtual CategoryMembershipEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity get_Identity();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_SubcategoryMembership();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("1E0422A1-F0D2-44ae-914B-8A2DECCFD22B")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICLRSurrogateEntry {
    public CLRSurrogateEntry AllData { get; }
    public Guid Clsid { get; }
    public string RuntimeVersion { get; }
    public string ClassName { get; }
    [SecurityCriticalAttribute]
public abstract virtual CLRSurrogateEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_Clsid();
    [SecurityCriticalAttribute]
public abstract virtual string get_RuntimeVersion();
    [SecurityCriticalAttribute]
public abstract virtual string get_ClassName();
}
[GuidAttribute("a504e5b0-8ccf-4cb4-9902-c9d1b9abd033")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICMS {
    public IDefinitionIdentity Identity { get; }
    public ISection FileSection { get; }
    public ISection CategoryMembershipSection { get; }
    public ISection COMRedirectionSection { get; }
    public ISection ProgIdRedirectionSection { get; }
    public ISection CLRSurrogateSection { get; }
    public ISection AssemblyReferenceSection { get; }
    public ISection WindowClassSection { get; }
    public ISection StringSection { get; }
    public ISection EntryPointSection { get; }
    public ISection PermissionSetSection { get; }
    public ISectionEntry MetadataSectionEntry { get; }
    public ISection AssemblyRequestSection { get; }
    public ISection RegistryKeySection { get; }
    public ISection DirectorySection { get; }
    public ISection FileAssociationSection { get; }
    public ISection CompatibleFrameworksSection { get; }
    public ISection EventSection { get; }
    public ISection EventMapSection { get; }
    public ISection EventTagSection { get; }
    public ISection CounterSetSection { get; }
    public ISection CounterSection { get; }
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity get_Identity();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_FileSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CategoryMembershipSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_COMRedirectionSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_ProgIdRedirectionSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CLRSurrogateSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_AssemblyReferenceSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_WindowClassSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_StringSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_EntryPointSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_PermissionSetSection();
    [SecurityCriticalAttribute]
public abstract virtual ISectionEntry get_MetadataSectionEntry();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_AssemblyRequestSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_RegistryKeySection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_DirectorySection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_FileAssociationSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CompatibleFrameworksSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_EventSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_EventMapSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_EventTagSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CounterSetSection();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CounterSection();
}
[GuidAttribute("4A33D662-2210-463A-BE9F-FBDF1AA554E3")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICompatibleFrameworksMetadataEntry {
    public CompatibleFrameworksMetadataEntry AllData { get; }
    public string SupportUrl { get; }
    [SecurityCriticalAttribute]
public abstract virtual CompatibleFrameworksMetadataEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_SupportUrl();
}
[GuidAttribute("3903B11B-FBE8-477c-825F-DB828B5FD174")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.ICOMServerEntry {
    public COMServerEntry AllData { get; }
    public Guid Clsid { get; }
    public UInt32 Flags { get; }
    public Guid ConfiguredGuid { get; }
    public Guid ImplementedClsid { get; }
    public Guid TypeLibrary { get; }
    public UInt32 ThreadingModel { get; }
    public string RuntimeVersion { get; }
    public string HostFile { get; }
    [SecurityCriticalAttribute]
public abstract virtual COMServerEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_Clsid();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Flags();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_ConfiguredGuid();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_ImplementedClsid();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_TypeLibrary();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_ThreadingModel();
    [SecurityCriticalAttribute]
public abstract virtual string get_RuntimeVersion();
    [SecurityCriticalAttribute]
public abstract virtual string get_HostFile();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CF168CF4-4E8F-4d92-9D2A-60E5CA21CF85")]
internal interface System.Deployment.Internal.Isolation.Manifest.IDependentOSMetadataEntry {
    public DependentOSMetadataEntry AllData { get; }
    public string SupportUrl { get; }
    public string Description { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public ushort BuildNumber { get; }
    public byte ServicePackMajor { get; }
    public byte ServicePackMinor { get; }
    [SecurityCriticalAttribute]
public abstract virtual DependentOSMetadataEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_SupportUrl();
    [SecurityCriticalAttribute]
public abstract virtual string get_Description();
    [SecurityCriticalAttribute]
public abstract virtual ushort get_MajorVersion();
    [SecurityCriticalAttribute]
public abstract virtual ushort get_MinorVersion();
    [SecurityCriticalAttribute]
public abstract virtual ushort get_BuildNumber();
    [SecurityCriticalAttribute]
public abstract virtual byte get_ServicePackMajor();
    [SecurityCriticalAttribute]
public abstract virtual byte get_ServicePackMinor();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CFA3F59F-334D-46bf-A5A5-5D11BB2D7EBC")]
internal interface System.Deployment.Internal.Isolation.Manifest.IDeploymentMetadataEntry {
    public DeploymentMetadataEntry AllData { get; }
    public string DeploymentProviderCodebase { get; }
    public string MinimumRequiredVersion { get; }
    public ushort MaximumAge { get; }
    public byte MaximumAge_Unit { get; }
    public UInt32 DeploymentFlags { get; }
    [SecurityCriticalAttribute]
public abstract virtual DeploymentMetadataEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_DeploymentProviderCodebase();
    [SecurityCriticalAttribute]
public abstract virtual string get_MinimumRequiredVersion();
    [SecurityCriticalAttribute]
public abstract virtual ushort get_MaximumAge();
    [SecurityCriticalAttribute]
public abstract virtual byte get_MaximumAge_Unit();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_DeploymentFlags();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CB73147E-5FC2-4c31-B4E6-58D13DBE1A08")]
internal interface System.Deployment.Internal.Isolation.Manifest.IDescriptionMetadataEntry {
    public DescriptionMetadataEntry AllData { get; }
    public string Publisher { get; }
    public string Product { get; }
    public string SupportUrl { get; }
    public string IconFile { get; }
    public string ErrorReportUrl { get; }
    public string SuiteName { get; }
    [SecurityCriticalAttribute]
public abstract virtual DescriptionMetadataEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Publisher();
    [SecurityCriticalAttribute]
public abstract virtual string get_Product();
    [SecurityCriticalAttribute]
public abstract virtual string get_SupportUrl();
    [SecurityCriticalAttribute]
public abstract virtual string get_IconFile();
    [SecurityCriticalAttribute]
public abstract virtual string get_ErrorReportUrl();
    [SecurityCriticalAttribute]
public abstract virtual string get_SuiteName();
}
[GuidAttribute("1583EFE9-832F-4d08-B041-CAC5ACEDB948")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.IEntryPointEntry {
    public EntryPointEntry AllData { get; }
    public string Name { get; }
    public string CommandLine_File { get; }
    public string CommandLine_Parameters { get; }
    public IReferenceIdentity Identity { get; }
    public UInt32 Flags { get; }
    [SecurityCriticalAttribute]
public abstract virtual EntryPointEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Name();
    [SecurityCriticalAttribute]
public abstract virtual string get_CommandLine_File();
    [SecurityCriticalAttribute]
public abstract virtual string get_CommandLine_Parameters();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity get_Identity();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Flags();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0C66F299-E08E-48c5-9264-7CCBEB4D5CBB")]
internal interface System.Deployment.Internal.Isolation.Manifest.IFileAssociationEntry {
    public FileAssociationEntry AllData { get; }
    public string Extension { get; }
    public string Description { get; }
    public string ProgID { get; }
    public string DefaultIcon { get; }
    public string Parameter { get; }
    [SecurityCriticalAttribute]
public abstract virtual FileAssociationEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Extension();
    [SecurityCriticalAttribute]
public abstract virtual string get_Description();
    [SecurityCriticalAttribute]
public abstract virtual string get_ProgID();
    [SecurityCriticalAttribute]
public abstract virtual string get_DefaultIcon();
    [SecurityCriticalAttribute]
public abstract virtual string get_Parameter();
}
[GuidAttribute("A2A55FAD-349B-469b-BF12-ADC33D14A937")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.IFileEntry {
    public FileEntry AllData { get; }
    public string Name { get; }
    public UInt32 HashAlgorithm { get; }
    public string LoadFrom { get; }
    public string SourcePath { get; }
    public string ImportPath { get; }
    public string SourceName { get; }
    public string Location { get; }
    public object HashValue { get; }
    public ulong Size { get; }
    public string Group { get; }
    public UInt32 Flags { get; }
    public IMuiResourceMapEntry MuiMapping { get; }
    public UInt32 WritableType { get; }
    public ISection HashElements { get; }
    [SecurityCriticalAttribute]
public abstract virtual FileEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Name();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_HashAlgorithm();
    [SecurityCriticalAttribute]
public abstract virtual string get_LoadFrom();
    [SecurityCriticalAttribute]
public abstract virtual string get_SourcePath();
    [SecurityCriticalAttribute]
public abstract virtual string get_ImportPath();
    [SecurityCriticalAttribute]
public abstract virtual string get_SourceName();
    [SecurityCriticalAttribute]
public abstract virtual string get_Location();
    [SecurityCriticalAttribute]
public abstract virtual object get_HashValue();
    [SecurityCriticalAttribute]
public abstract virtual ulong get_Size();
    [SecurityCriticalAttribute]
public abstract virtual string get_Group();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Flags();
    [SecurityCriticalAttribute]
public abstract virtual IMuiResourceMapEntry get_MuiMapping();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_WritableType();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_HashElements();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9D46FB70-7B54-4f4f-9331-BA9E87833FF5")]
internal interface System.Deployment.Internal.Isolation.Manifest.IHashElementEntry {
    public HashElementEntry AllData { get; }
    public UInt32 index { get; }
    public byte Transform { get; }
    public object TransformMetadata { get; }
    public byte DigestMethod { get; }
    public object DigestValue { get; }
    public string Xml { get; }
    [SecurityCriticalAttribute]
public abstract virtual HashElementEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_index();
    [SecurityCriticalAttribute]
public abstract virtual byte get_Transform();
    [SecurityCriticalAttribute]
public abstract virtual object get_TransformMetadata();
    [SecurityCriticalAttribute]
public abstract virtual byte get_DigestMethod();
    [SecurityCriticalAttribute]
public abstract virtual object get_DigestValue();
    [SecurityCriticalAttribute]
public abstract virtual string get_Xml();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("AB1ED79F-943E-407d-A80B-0744E3A95B28")]
internal interface System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry {
    public MetadataSectionEntry AllData { get; }
    public UInt32 SchemaVersion { get; }
    public UInt32 ManifestFlags { get; }
    public UInt32 UsagePatterns { get; }
    public IDefinitionIdentity CdfIdentity { get; }
    public string LocalPath { get; }
    public UInt32 HashAlgorithm { get; }
    public object ManifestHash { get; }
    public string ContentType { get; }
    public string RuntimeImageVersion { get; }
    public object MvidValue { get; }
    public IDescriptionMetadataEntry DescriptionData { get; }
    public IDeploymentMetadataEntry DeploymentData { get; }
    public IDependentOSMetadataEntry DependentOSData { get; }
    public string defaultPermissionSetID { get; }
    public string RequestedExecutionLevel { get; }
    public bool RequestedExecutionLevelUIAccess { get; }
    public IReferenceIdentity ResourceTypeResourcesDependency { get; }
    public IReferenceIdentity ResourceTypeManifestResourcesDependency { get; }
    public string KeyInfoElement { get; }
    public ICompatibleFrameworksMetadataEntry CompatibleFrameworksData { get; }
    [SecurityCriticalAttribute]
public abstract virtual MetadataSectionEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_SchemaVersion();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_ManifestFlags();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_UsagePatterns();
    [SecurityCriticalAttribute]
public abstract virtual IDefinitionIdentity get_CdfIdentity();
    [SecurityCriticalAttribute]
public abstract virtual string get_LocalPath();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_HashAlgorithm();
    [SecurityCriticalAttribute]
public abstract virtual object get_ManifestHash();
    [SecurityCriticalAttribute]
public abstract virtual string get_ContentType();
    [SecurityCriticalAttribute]
public abstract virtual string get_RuntimeImageVersion();
    [SecurityCriticalAttribute]
public abstract virtual object get_MvidValue();
    [SecurityCriticalAttribute]
public abstract virtual IDescriptionMetadataEntry get_DescriptionData();
    [SecurityCriticalAttribute]
public abstract virtual IDeploymentMetadataEntry get_DeploymentData();
    [SecurityCriticalAttribute]
public abstract virtual IDependentOSMetadataEntry get_DependentOSData();
    [SecurityCriticalAttribute]
public abstract virtual string get_defaultPermissionSetID();
    [SecurityCriticalAttribute]
public abstract virtual string get_RequestedExecutionLevel();
    [SecurityCriticalAttribute]
public abstract virtual bool get_RequestedExecutionLevelUIAccess();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity get_ResourceTypeResourcesDependency();
    [SecurityCriticalAttribute]
public abstract virtual IReferenceIdentity get_ResourceTypeManifestResourcesDependency();
    [SecurityCriticalAttribute]
public abstract virtual string get_KeyInfoElement();
    [SecurityCriticalAttribute]
public abstract virtual ICompatibleFrameworksMetadataEntry get_CompatibleFrameworksData();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("24abe1f7-a396-4a03-9adf-1d5b86a5569f")]
internal interface System.Deployment.Internal.Isolation.Manifest.IMuiResourceIdLookupMapEntry {
    public MuiResourceIdLookupMapEntry AllData { get; }
    public UInt32 Count { get; }
    [SecurityCriticalAttribute]
public abstract virtual MuiResourceIdLookupMapEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual UInt32 get_Count();
}
[GuidAttribute("397927f5-10f2-4ecb-bfe1-3c264212a193")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.IMuiResourceMapEntry {
    public MuiResourceMapEntry AllData { get; }
    public object ResourceTypeIdInt { get; }
    public object ResourceTypeIdString { get; }
    [SecurityCriticalAttribute]
public abstract virtual MuiResourceMapEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual object get_ResourceTypeIdInt();
    [SecurityCriticalAttribute]
public abstract virtual object get_ResourceTypeIdString();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("55b2dec1-d0f6-4bf4-91b1-30f73ad8e4df")]
internal interface System.Deployment.Internal.Isolation.Manifest.IMuiResourceTypeIdIntEntry {
    public MuiResourceTypeIdIntEntry AllData { get; }
    public object StringIds { get; }
    public object IntegerIds { get; }
    [SecurityCriticalAttribute]
public abstract virtual MuiResourceTypeIdIntEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual object get_StringIds();
    [SecurityCriticalAttribute]
public abstract virtual object get_IntegerIds();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("11df5cad-c183-479b-9a44-3842b71639ce")]
internal interface System.Deployment.Internal.Isolation.Manifest.IMuiResourceTypeIdStringEntry {
    public MuiResourceTypeIdStringEntry AllData { get; }
    public object StringIds { get; }
    public object IntegerIds { get; }
    [SecurityCriticalAttribute]
public abstract virtual MuiResourceTypeIdStringEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual object get_StringIds();
    [SecurityCriticalAttribute]
public abstract virtual object get_IntegerIds();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("EBE5A1ED-FEBC-42c4-A9E1-E087C6E36635")]
internal interface System.Deployment.Internal.Isolation.Manifest.IPermissionSetEntry {
    public PermissionSetEntry AllData { get; }
    public string Id { get; }
    public string XmlSegment { get; }
    [SecurityCriticalAttribute]
public abstract virtual PermissionSetEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Id();
    [SecurityCriticalAttribute]
public abstract virtual string get_XmlSegment();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("54F198EC-A63A-45ea-A984-452F68D9B35B")]
internal interface System.Deployment.Internal.Isolation.Manifest.IProgIdRedirectionEntry {
    public ProgIdRedirectionEntry AllData { get; }
    public string ProgId { get; }
    public Guid RedirectedGuid { get; }
    [SecurityCriticalAttribute]
public abstract virtual ProgIdRedirectionEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_ProgId();
    [SecurityCriticalAttribute]
public abstract virtual Guid get_RedirectedGuid();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("70A4ECEE-B195-4c59-85BF-44B6ACA83F07")]
internal interface System.Deployment.Internal.Isolation.Manifest.IResourceTableMappingEntry {
    public ResourceTableMappingEntry AllData { get; }
    public string id { get; }
    public string FinalStringMapped { get; }
    [SecurityCriticalAttribute]
public abstract virtual ResourceTableMappingEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_id();
    [SecurityCriticalAttribute]
public abstract virtual string get_FinalStringMapped();
}
[GuidAttribute("5A7A54D7-5AD5-418e-AB7A-CF823A8D48D0")]
[InterfaceTypeAttribute("1")]
internal interface System.Deployment.Internal.Isolation.Manifest.ISubcategoryMembershipEntry {
    public SubcategoryMembershipEntry AllData { get; }
    public string Subcategory { get; }
    public ISection CategoryMembershipData { get; }
    [SecurityCriticalAttribute]
public abstract virtual SubcategoryMembershipEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_Subcategory();
    [SecurityCriticalAttribute]
public abstract virtual ISection get_CategoryMembershipData();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("8AD3FC86-AFD3-477a-8FD5-146C291195BA")]
internal interface System.Deployment.Internal.Isolation.Manifest.IWindowClassEntry {
    public WindowClassEntry AllData { get; }
    public string ClassName { get; }
    public string HostDll { get; }
    public bool fVersioned { get; }
    [SecurityCriticalAttribute]
public abstract virtual WindowClassEntry get_AllData();
    [SecurityCriticalAttribute]
public abstract virtual string get_ClassName();
    [SecurityCriticalAttribute]
public abstract virtual string get_HostDll();
    [SecurityCriticalAttribute]
public abstract virtual bool get_fVersioned();
}
internal class System.Deployment.Internal.Isolation.Manifest.MetadataSectionEntry : object {
    public UInt32 SchemaVersion;
    public UInt32 ManifestFlags;
    public UInt32 UsagePatterns;
    public IDefinitionIdentity CdfIdentity;
    public string LocalPath;
    public UInt32 HashAlgorithm;
    public IntPtr ManifestHash;
    public UInt32 ManifestHashSize;
    public string ContentType;
    public string RuntimeImageVersion;
    public IntPtr MvidValue;
    public UInt32 MvidValueSize;
    public DescriptionMetadataEntry DescriptionData;
    public DeploymentMetadataEntry DeploymentData;
    public DependentOSMetadataEntry DependentOSData;
    public string defaultPermissionSetID;
    public string RequestedExecutionLevel;
    public bool RequestedExecutionLevelUIAccess;
    public IReferenceIdentity ResourceTypeResourcesDependency;
    public IReferenceIdentity ResourceTypeManifestResourcesDependency;
    public string KeyInfoElement;
    public CompatibleFrameworksMetadataEntry CompatibleFrameworksData;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.MetadataSectionEntryFieldId : Enum {
    public int value__;
    public static MetadataSectionEntryFieldId MetadataSection_SchemaVersion;
    public static MetadataSectionEntryFieldId MetadataSection_ManifestFlags;
    public static MetadataSectionEntryFieldId MetadataSection_UsagePatterns;
    public static MetadataSectionEntryFieldId MetadataSection_CdfIdentity;
    public static MetadataSectionEntryFieldId MetadataSection_LocalPath;
    public static MetadataSectionEntryFieldId MetadataSection_HashAlgorithm;
    public static MetadataSectionEntryFieldId MetadataSection_ManifestHash;
    public static MetadataSectionEntryFieldId MetadataSection_ManifestHashSize;
    public static MetadataSectionEntryFieldId MetadataSection_ContentType;
    public static MetadataSectionEntryFieldId MetadataSection_RuntimeImageVersion;
    public static MetadataSectionEntryFieldId MetadataSection_MvidValue;
    public static MetadataSectionEntryFieldId MetadataSection_MvidValueSize;
    public static MetadataSectionEntryFieldId MetadataSection_DescriptionData;
    public static MetadataSectionEntryFieldId MetadataSection_DeploymentData;
    public static MetadataSectionEntryFieldId MetadataSection_DependentOSData;
    public static MetadataSectionEntryFieldId MetadataSection_defaultPermissionSetID;
    public static MetadataSectionEntryFieldId MetadataSection_RequestedExecutionLevel;
    public static MetadataSectionEntryFieldId MetadataSection_RequestedExecutionLevelUIAccess;
    public static MetadataSectionEntryFieldId MetadataSection_ResourceTypeResourcesDependency;
    public static MetadataSectionEntryFieldId MetadataSection_ResourceTypeManifestResourcesDependency;
    public static MetadataSectionEntryFieldId MetadataSection_KeyInfoElement;
    public static MetadataSectionEntryFieldId MetadataSection_CompatibleFrameworksData;
}
internal class System.Deployment.Internal.Isolation.Manifest.MuiResourceIdLookupMapEntry : object {
    public UInt32 Count;
}
internal enum System.Deployment.Internal.Isolation.Manifest.MuiResourceIdLookupMapEntryFieldId : Enum {
    public int value__;
    public static MuiResourceIdLookupMapEntryFieldId MuiResourceIdLookupMap_Count;
}
internal class System.Deployment.Internal.Isolation.Manifest.MuiResourceMapEntry : object {
    public IntPtr ResourceTypeIdInt;
    public UInt32 ResourceTypeIdIntSize;
    public IntPtr ResourceTypeIdString;
    public UInt32 ResourceTypeIdStringSize;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.MuiResourceMapEntryFieldId : Enum {
    public int value__;
    public static MuiResourceMapEntryFieldId MuiResourceMap_ResourceTypeIdInt;
    public static MuiResourceMapEntryFieldId MuiResourceMap_ResourceTypeIdIntSize;
    public static MuiResourceMapEntryFieldId MuiResourceMap_ResourceTypeIdString;
    public static MuiResourceMapEntryFieldId MuiResourceMap_ResourceTypeIdStringSize;
}
internal class System.Deployment.Internal.Isolation.Manifest.MuiResourceTypeIdIntEntry : object {
    public IntPtr StringIds;
    public UInt32 StringIdsSize;
    public IntPtr IntegerIds;
    public UInt32 IntegerIdsSize;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.MuiResourceTypeIdIntEntryFieldId : Enum {
    public int value__;
    public static MuiResourceTypeIdIntEntryFieldId MuiResourceTypeIdInt_StringIds;
    public static MuiResourceTypeIdIntEntryFieldId MuiResourceTypeIdInt_StringIdsSize;
    public static MuiResourceTypeIdIntEntryFieldId MuiResourceTypeIdInt_IntegerIds;
    public static MuiResourceTypeIdIntEntryFieldId MuiResourceTypeIdInt_IntegerIdsSize;
}
internal class System.Deployment.Internal.Isolation.Manifest.MuiResourceTypeIdStringEntry : object {
    public IntPtr StringIds;
    public UInt32 StringIdsSize;
    public IntPtr IntegerIds;
    public UInt32 IntegerIdsSize;
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
public void Dispose(bool fDisposing);
}
internal enum System.Deployment.Internal.Isolation.Manifest.MuiResourceTypeIdStringEntryFieldId : Enum {
    public int value__;
    public static MuiResourceTypeIdStringEntryFieldId MuiResourceTypeIdString_StringIds;
    public static MuiResourceTypeIdStringEntryFieldId MuiResourceTypeIdString_StringIdsSize;
    public static MuiResourceTypeIdStringEntryFieldId MuiResourceTypeIdString_IntegerIds;
    public static MuiResourceTypeIdStringEntryFieldId MuiResourceTypeIdString_IntegerIdsSize;
}
internal class System.Deployment.Internal.Isolation.Manifest.PermissionSetEntry : object {
    public string Id;
    public string XmlSegment;
}
internal enum System.Deployment.Internal.Isolation.Manifest.PermissionSetEntryFieldId : Enum {
    public int value__;
    public static PermissionSetEntryFieldId PermissionSet_XmlSegment;
}
internal class System.Deployment.Internal.Isolation.Manifest.ProgIdRedirectionEntry : object {
    public string ProgId;
    public Guid RedirectedGuid;
}
internal enum System.Deployment.Internal.Isolation.Manifest.ProgIdRedirectionEntryFieldId : Enum {
    public int value__;
    public static ProgIdRedirectionEntryFieldId ProgIdRedirection_RedirectedGuid;
}
internal class System.Deployment.Internal.Isolation.Manifest.ResourceTableMappingEntry : object {
    public string id;
    public string FinalStringMapped;
}
internal enum System.Deployment.Internal.Isolation.Manifest.ResourceTableMappingEntryFieldId : Enum {
    public int value__;
    public static ResourceTableMappingEntryFieldId ResourceTableMapping_FinalStringMapped;
}
internal class System.Deployment.Internal.Isolation.Manifest.SubcategoryMembershipEntry : object {
    public string Subcategory;
    public ISection CategoryMembershipData;
}
internal enum System.Deployment.Internal.Isolation.Manifest.SubcategoryMembershipEntryFieldId : Enum {
    public int value__;
    public static SubcategoryMembershipEntryFieldId SubcategoryMembership_CategoryMembershipData;
}
internal class System.Deployment.Internal.Isolation.Manifest.WindowClassEntry : object {
    public string ClassName;
    public string HostDll;
    public bool fVersioned;
}
internal enum System.Deployment.Internal.Isolation.Manifest.WindowClassEntryFieldId : Enum {
    public int value__;
    public static WindowClassEntryFieldId WindowClass_HostDll;
    public static WindowClassEntryFieldId WindowClass_fVersioned;
}
internal enum System.Deployment.Internal.Isolation.StateManager_RunningState : Enum {
    public int value__;
    public static StateManager_RunningState Undefined;
    public static StateManager_RunningState Starting;
    public static StateManager_RunningState Running;
}
internal class System.Deployment.Internal.Isolation.Store : object {
    public IStore InternalStore { get; }
    public Store(IStore pStore);
    public IStore get_InternalStore();
    [SecuritySafeCriticalAttribute]
public UInt32[] Transact(StoreTransactionOperation[] operations);
    [SecuritySafeCriticalAttribute]
public IDefinitionIdentity BindReferenceToAssemblyIdentity(UInt32 Flags, IReferenceIdentity ReferenceIdentity, UInt32 cDeploymentsToIgnore, IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore);
    [SecuritySafeCriticalAttribute]
public void CalculateDelimiterOfDeploymentsBasedOnQuota(UInt32 dwFlags, UInt32 cDeployments, IDefinitionAppId[] rgpIDefinitionAppId_Deployments, StoreApplicationReference& InstallerReference, ulong ulonglongQuota, UInt32& Delimiter, UInt64& SizeSharedWithExternalDeployment, UInt64& SizeConsumedByInputDeploymentArray);
    [SecuritySafeCriticalAttribute]
public ICMS BindReferenceToAssemblyManifest(UInt32 Flags, IReferenceIdentity ReferenceIdentity, UInt32 cDeploymentsToIgnore, IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore);
    [SecuritySafeCriticalAttribute]
public ICMS GetAssemblyManifest(UInt32 Flags, IDefinitionIdentity DefinitionIdentity);
    [SecuritySafeCriticalAttribute]
public IDefinitionIdentity GetAssemblyIdentity(UInt32 Flags, IDefinitionIdentity DefinitionIdentity);
    public StoreAssemblyEnumeration EnumAssemblies(EnumAssembliesFlags Flags);
    [SecuritySafeCriticalAttribute]
public StoreAssemblyEnumeration EnumAssemblies(EnumAssembliesFlags Flags, IReferenceIdentity refToMatch);
    [SecuritySafeCriticalAttribute]
public StoreAssemblyFileEnumeration EnumFiles(EnumAssemblyFilesFlags Flags, IDefinitionIdentity Assembly);
    [SecuritySafeCriticalAttribute]
public StoreAssemblyFileEnumeration EnumPrivateFiles(EnumApplicationPrivateFiles Flags, IDefinitionAppId Application, IDefinitionIdentity Assembly);
    [SecuritySafeCriticalAttribute]
public IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE EnumInstallationReferences(EnumAssemblyInstallReferenceFlags Flags, IDefinitionIdentity Assembly);
    [SecuritySafeCriticalAttribute]
public IPathLock LockAssemblyPath(IDefinitionIdentity asm);
    [SecuritySafeCriticalAttribute]
public IPathLock LockApplicationPath(IDefinitionAppId app);
    [SecuritySafeCriticalAttribute]
public ulong QueryChangeID(IDefinitionIdentity asm);
    [SecuritySafeCriticalAttribute]
public StoreCategoryEnumeration EnumCategories(EnumCategoriesFlags Flags, IReferenceIdentity CategoryMatch);
    public StoreSubcategoryEnumeration EnumSubcategories(EnumSubcategoriesFlags Flags, IDefinitionIdentity CategoryMatch);
    [SecuritySafeCriticalAttribute]
public StoreSubcategoryEnumeration EnumSubcategories(EnumSubcategoriesFlags Flags, IDefinitionIdentity Category, string SearchPattern);
    [SecuritySafeCriticalAttribute]
public StoreCategoryInstanceEnumeration EnumCategoryInstances(EnumCategoryInstancesFlags Flags, IDefinitionIdentity Category, string SubCat);
    [SecurityCriticalAttribute]
public Byte[] GetDeploymentProperty(GetPackagePropertyFlags Flags, IDefinitionAppId Deployment, StoreApplicationReference Reference, Guid PropertySet, string PropertyName);
    [SecuritySafeCriticalAttribute]
public StoreDeploymentMetadataEnumeration EnumInstallerDeployments(Guid InstallerId, string InstallerName, string InstallerMetadata, IReferenceAppId DeploymentFilter);
    [SecuritySafeCriticalAttribute]
public StoreDeploymentMetadataPropertyEnumeration EnumInstallerDeploymentProperties(Guid InstallerId, string InstallerName, string InstallerMetadata, IDefinitionAppId Deployment);
}
internal class System.Deployment.Internal.Isolation.STORE_ASSEMBLY : ValueType {
    public UInt32 Status;
    public IDefinitionIdentity DefinitionIdentity;
    public string ManifestPath;
    public ulong AssemblySize;
    public ulong ChangeId;
}
internal class System.Deployment.Internal.Isolation.STORE_ASSEMBLY_FILE : ValueType {
    public UInt32 Size;
    public UInt32 Flags;
    public string FileName;
    public UInt32 FileStatusFlags;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.STORE_ASSEMBLY_FILE_STATUS_FLAGS : Enum {
    public int value__;
    public static STORE_ASSEMBLY_FILE_STATUS_FLAGS STORE_ASSEMBLY_FILE_STATUS_FLAG_PRESENT;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.Isolation.STORE_ASSEMBLY_STATUS_FLAGS : Enum {
    public int value__;
    public static STORE_ASSEMBLY_STATUS_FLAGS STORE_ASSEMBLY_STATUS_MANIFEST_ONLY;
    public static STORE_ASSEMBLY_STATUS_FLAGS STORE_ASSEMBLY_STATUS_PAYLOAD_RESIDENT;
    public static STORE_ASSEMBLY_STATUS_FLAGS STORE_ASSEMBLY_STATUS_PARTIAL_INSTALL;
}
internal class System.Deployment.Internal.Isolation.STORE_CATEGORY : ValueType {
    public IDefinitionIdentity DefinitionIdentity;
}
internal class System.Deployment.Internal.Isolation.STORE_CATEGORY_INSTANCE : ValueType {
    public IDefinitionAppId DefinitionAppId_Application;
    public string XMLSnippet;
}
internal class System.Deployment.Internal.Isolation.STORE_CATEGORY_SUBCATEGORY : ValueType {
    public string Subcategory;
}
internal class System.Deployment.Internal.Isolation.StoreApplicationReference : ValueType {
    public UInt32 Size;
    public RefFlags Flags;
    public Guid GuidScheme;
    public string Identifier;
    public string NonCanonicalData;
    public StoreApplicationReference(Guid RefScheme, string Id, string NcData);
    [SecurityCriticalAttribute]
public IntPtr ToIntPtr();
    [SecurityCriticalAttribute]
public static void Destroy(IntPtr ip);
}
internal class System.Deployment.Internal.Isolation.StoreAssemblyEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public STORE_ASSEMBLY Current { get; }
    public StoreAssemblyEnumeration(IEnumSTORE_ASSEMBLY pI);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public STORE_ASSEMBLY get_Current();
    public IEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreAssemblyFileEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public STORE_ASSEMBLY_FILE Current { get; }
    public StoreAssemblyFileEnumeration(IEnumSTORE_ASSEMBLY_FILE pI);
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public STORE_ASSEMBLY_FILE get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreCategoryEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public STORE_CATEGORY Current { get; }
    public StoreCategoryEnumeration(IEnumSTORE_CATEGORY pI);
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public STORE_CATEGORY get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreCategoryInstanceEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public STORE_CATEGORY_INSTANCE Current { get; }
    public StoreCategoryInstanceEnumeration(IEnumSTORE_CATEGORY_INSTANCE pI);
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public STORE_CATEGORY_INSTANCE get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreDeploymentMetadataEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public IDefinitionAppId Current { get; }
    public StoreDeploymentMetadataEnumeration(IEnumSTORE_DEPLOYMENT_METADATA pI);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public IDefinitionAppId get_Current();
    public IEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreDeploymentMetadataPropertyEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public StoreOperationMetadataProperty Current { get; }
    public StoreDeploymentMetadataPropertyEnumeration(IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY pI);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public StoreOperationMetadataProperty get_Current();
    public IEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreOperationInstallDeployment : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public IntPtr Reference;
    public StoreOperationInstallDeployment(IDefinitionAppId App, StoreApplicationReference reference);
    [SecuritySafeCriticalAttribute]
public StoreOperationInstallDeployment(IDefinitionAppId App, bool UninstallOthers, StoreApplicationReference reference);
    [SecurityCriticalAttribute]
public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationMetadataProperty : ValueType {
    public Guid GuidPropertySet;
    public string Name;
    public IntPtr ValueSize;
    public string Value;
    public StoreOperationMetadataProperty(Guid PropertySet, string Name);
    public StoreOperationMetadataProperty(Guid PropertySet, string Name, string Value);
}
internal class System.Deployment.Internal.Isolation.StoreOperationPinDeployment : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public long ExpirationTime;
    public IntPtr Reference;
    [SecuritySafeCriticalAttribute]
public StoreOperationPinDeployment(IDefinitionAppId AppId, StoreApplicationReference Ref);
    public StoreOperationPinDeployment(IDefinitionAppId AppId, DateTime Expiry, StoreApplicationReference Ref);
    [SecurityCriticalAttribute]
public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationScavenge : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public ulong SizeReclaimationLimit;
    public ulong RuntimeLimit;
    public UInt32 ComponentCountLimit;
    public StoreOperationScavenge(bool Light, ulong SizeLimit, ulong RunLimit, UInt32 ComponentLimit);
    public StoreOperationScavenge(bool Light);
    public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationSetCanonicalizationContext : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public string BaseAddressFilePath;
    public string ExportsFilePath;
    [SecurityCriticalAttribute]
public StoreOperationSetCanonicalizationContext(string Bases, string Exports);
    public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Deployment;
    public IntPtr InstallerReference;
    public IntPtr cPropertiesToTest;
    public IntPtr PropertiesToTest;
    public IntPtr cPropertiesToSet;
    public IntPtr PropertiesToSet;
    public StoreOperationSetDeploymentMetadata(IDefinitionAppId Deployment, StoreApplicationReference Reference, StoreOperationMetadataProperty[] SetProperties);
    [SecuritySafeCriticalAttribute]
public StoreOperationSetDeploymentMetadata(IDefinitionAppId Deployment, StoreApplicationReference Reference, StoreOperationMetadataProperty[] SetProperties, StoreOperationMetadataProperty[] TestProperties);
    [SecurityCriticalAttribute]
public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationStageComponent : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public IDefinitionIdentity Component;
    public string ManifestPath;
    public StoreOperationStageComponent(IDefinitionAppId app, string Manifest);
    public StoreOperationStageComponent(IDefinitionAppId app, IDefinitionIdentity comp, string Manifest);
    public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationStageComponentFile : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public IDefinitionIdentity Component;
    public string ComponentRelativePath;
    public string SourceFilePath;
    public StoreOperationStageComponentFile(IDefinitionAppId App, string CompRelPath, string SrcFile);
    public StoreOperationStageComponentFile(IDefinitionAppId App, IDefinitionIdentity Component, string CompRelPath, string SrcFile);
    public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public IntPtr Reference;
    [SecuritySafeCriticalAttribute]
public StoreOperationUninstallDeployment(IDefinitionAppId appid, StoreApplicationReference AppRef);
    [SecurityCriticalAttribute]
public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment : ValueType {
    public UInt32 Size;
    public OpFlags Flags;
    public IDefinitionAppId Application;
    public IntPtr Reference;
    [SecuritySafeCriticalAttribute]
public StoreOperationUnpinDeployment(IDefinitionAppId app, StoreApplicationReference reference);
    [SecurityCriticalAttribute]
public void Destroy();
}
internal class System.Deployment.Internal.Isolation.StoreSubcategoryEnumeration : object {
    private object System.Collections.IEnumerator.Current { get; }
    public STORE_CATEGORY_SUBCATEGORY Current { get; }
    public StoreSubcategoryEnumeration(IEnumSTORE_CATEGORY_SUBCATEGORY pI);
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public STORE_CATEGORY_SUBCATEGORY get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Reset();
}
internal class System.Deployment.Internal.Isolation.StoreTransaction : object {
    public StoreTransactionOperation[] Operations { get; }
    public void Add(StoreOperationInstallDeployment o);
    public void Add(StoreOperationPinDeployment o);
    public void Add(StoreOperationSetCanonicalizationContext o);
    public void Add(StoreOperationSetDeploymentMetadata o);
    public void Add(StoreOperationStageComponent o);
    public void Add(StoreOperationStageComponentFile o);
    public void Add(StoreOperationUninstallDeployment o);
    public void Add(StoreOperationUnpinDeployment o);
    public void Add(StoreOperationScavenge o);
    protected virtual void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    public StoreTransactionOperation[] get_Operations();
}
internal class System.Deployment.Internal.Isolation.StoreTransactionData : ValueType {
    public IntPtr DataPtr;
}
internal class System.Deployment.Internal.Isolation.StoreTransactionOperation : ValueType {
    public StoreTransactionOperationType Operation;
    public StoreTransactionData Data;
}
internal enum System.Deployment.Internal.Isolation.StoreTransactionOperationType : Enum {
    public int value__;
    public static StoreTransactionOperationType Invalid;
    public static StoreTransactionOperationType SetCanonicalizationContext;
    public static StoreTransactionOperationType StageComponent;
    public static StoreTransactionOperationType PinDeployment;
    public static StoreTransactionOperationType UnpinDeployment;
    public static StoreTransactionOperationType StageComponentFile;
    public static StoreTransactionOperationType InstallDeployment;
    public static StoreTransactionOperationType UninstallDeployment;
    public static StoreTransactionOperationType SetDeploymentMetadata;
    public static StoreTransactionOperationType Scavenge;
}
internal static class System.Diagnostics.Assert : object {
    internal static int COR_E_FAILFAST;
    private static Assert();
    internal static void Check(bool condition, string conditionString, string message);
    internal static void Check(bool condition, string conditionString, string message, int exitCode);
    internal static void Fail(string conditionString, string message);
    internal static void Fail(string conditionString, string message, string windowTitle, int exitCode);
    internal static void Fail(string conditionString, string message, int exitCode, TraceFormat stackTraceFormat);
    [SecuritySafeCriticalAttribute]
internal static void Fail(string conditionString, string message, string windowTitle, int exitCode, TraceFormat stackTraceFormat, int numStackFramesToSkip);
    [SecurityCriticalAttribute]
internal static int ShowDefaultAssertDialog(string conditionString, string message, string stackTrace, string windowTitle);
}
internal abstract class System.Diagnostics.AssertFilter : object {
    public abstract virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
internal enum System.Diagnostics.AssertFilters : Enum {
    public int value__;
    public static AssertFilters FailDebug;
    public static AssertFilters FailIgnore;
    public static AssertFilters FailTerminate;
    public static AssertFilters FailContinueFilter;
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    public string get_Category();
    public string get_CheckId();
    public string get_Scope();
    public void set_Scope(string value);
    public string get_Target();
    public void set_Target(string value);
    public string get_MessageId();
    public void set_MessageId(string value);
    public string get_Justification();
    public void set_Justification(string value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition);
    [ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void EnsuresOnThrow(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "2")]
public static T Result();
    [ReliabilityContractAttribute("3", "2")]
public static T ValueAtReturn(T& value);
    [ReliabilityContractAttribute("3", "2")]
public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Invariant(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "2")]
public static void EndContractBlock();
    [SecuritySafeCriticalAttribute]
private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "1")]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [SecurityCriticalAttribute]
public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[AttributeUsageAttribute("5124")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
internal class System.Diagnostics.Contracts.ContractException : Exception {
    public ContractFailureKind Kind { get; }
    public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    public ContractFailureKind get_Kind();
    public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    [ReliabilityContractAttribute("3", "1")]
public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    [SecurityCriticalAttribute]
public void SetHandled();
    public bool get_Unwind();
    [SecurityCriticalAttribute]
public void SetUnwind();
}
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    public string get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("256")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ObsoleteAttribute("Use the ContractHelper class in the System.Runtime.CompilerServices namespace instead.")]
public static class System.Diagnostics.Contracts.Internal.ContractHelper : object {
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "1")]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
}
[AttributeUsageAttribute("6884")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
[AttributeUsageAttribute("3")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    public DebuggingModes get_DebuggingFlags();
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    [SecuritySafeCriticalAttribute]
public static void Break();
    [SecuritySafeCriticalAttribute]
public static bool Launch();
    [ComVisibleAttribute("False")]
public static void NotifyOfCrossThreadDependency();
    public static bool get_IsAttached();
    [SecuritySafeCriticalAttribute]
public static void Log(int level, string category, string message);
    [SecuritySafeCriticalAttribute]
public static bool IsLogging();
}
[AttributeUsageAttribute("384")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    public DebuggerBrowsableState get_State();
}
[ComVisibleAttribute("True")]
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    public string get_Value();
    public string get_Name();
    public void set_Name(string value);
    public string get_Type();
    public void set_Type(string value);
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(Type type);
    public DebuggerTypeProxyAttribute(string typeName);
    public string get_ProxyTypeName();
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    public string VisualizerObjectSourceTypeName { get; }
    public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerVisualizerAttribute(string visualizerTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer);
    public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    public string get_VisualizerObjectSourceTypeName();
    public string get_VisualizerTypeName();
    public string get_Description();
    public void set_Description(string value);
    public void set_Target(Type value);
    public Type get_Target();
    public void set_TargetTypeName(string value);
    public string get_TargetTypeName();
}
internal class System.Diagnostics.DefaultFilter : AssertFilter {
    [SecuritySafeCriticalAttribute]
public virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
internal class System.Diagnostics.EditAndContinueHelper : object {
}
internal interface System.Diagnostics.ICustomDebuggerNotification {
}
internal static class System.Diagnostics.Log : object {
    internal static Hashtable m_Hashtable;
    public static LogSwitch GlobalSwitch;
    public static bool IsConsoleEnabled { get; public set; }
    private static Log();
    public static void AddOnLogMessage(LogMessageEventHandler handler);
    public static void RemoveOnLogMessage(LogMessageEventHandler handler);
    public static void AddOnLogSwitchLevel(LogSwitchLevelHandler handler);
    public static void RemoveOnLogSwitchLevel(LogSwitchLevelHandler handler);
    internal static void InvokeLogSwitchLevelHandlers(LogSwitch ls, LoggingLevels newLevel);
    public static bool get_IsConsoleEnabled();
    public static void set_IsConsoleEnabled(bool value);
    public static void LogMessage(LoggingLevels level, string message);
    public static void LogMessage(LoggingLevels level, LogSwitch logswitch, string message);
    public static void Trace(LogSwitch logswitch, string message);
    public static void Trace(string switchname, string message);
    public static void Trace(string message);
    public static void Status(LogSwitch logswitch, string message);
    public static void Status(string switchname, string message);
    public static void Status(string message);
    public static void Warning(LogSwitch logswitch, string message);
    public static void Warning(string switchname, string message);
    public static void Warning(string message);
    public static void Error(LogSwitch logswitch, string message);
    public static void Error(string switchname, string message);
    public static void Error(string message);
    public static void Panic(string message);
    [SecurityCriticalAttribute]
internal static void AddLogSwitch(LogSwitch logSwitch);
    [SecurityCriticalAttribute]
internal static void ModifyLogSwitch(int iNewLevel, string strSwitchName, string strParentName);
}
internal enum System.Diagnostics.LoggingLevels : Enum {
    public int value__;
    public static LoggingLevels TraceLevel0;
    public static LoggingLevels TraceLevel1;
    public static LoggingLevels TraceLevel2;
    public static LoggingLevels TraceLevel3;
    public static LoggingLevels TraceLevel4;
    public static LoggingLevels StatusLevel0;
    public static LoggingLevels StatusLevel1;
    public static LoggingLevels StatusLevel2;
    public static LoggingLevels StatusLevel3;
    public static LoggingLevels StatusLevel4;
    public static LoggingLevels WarningLevel;
    public static LoggingLevels ErrorLevel;
    public static LoggingLevels PanicLevel;
}
internal class System.Diagnostics.LogMessageEventHandler : MulticastDelegate {
    public LogMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(LoggingLevels level, LogSwitch category, string message, StackTrace location);
    public virtual IAsyncResult BeginInvoke(LoggingLevels level, LogSwitch category, string message, StackTrace location, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Diagnostics.LogSwitch : object {
    internal string strName;
    internal string strDescription;
    internal LoggingLevels modreq(System.Runtime.CompilerServices.IsVolatile) iLevel;
    internal LoggingLevels modreq(System.Runtime.CompilerServices.IsVolatile) iOldLevel;
    public string Name { get; }
    public string Description { get; }
    public LogSwitch Parent { get; }
    public LoggingLevels MinimumLevel { get; public set; }
    [SecuritySafeCriticalAttribute]
public LogSwitch(string name, string description, LogSwitch parent);
    [SecuritySafeCriticalAttribute]
internal LogSwitch(string name, string description);
    public virtual string get_Name();
    public virtual string get_Description();
    public virtual LogSwitch get_Parent();
    public virtual LoggingLevels get_MinimumLevel();
    [SecuritySafeCriticalAttribute]
public virtual void set_MinimumLevel(LoggingLevels value);
    public virtual bool CheckLevel(LoggingLevels level);
    public static LogSwitch GetSwitch(string name);
}
internal class System.Diagnostics.LogSwitchLevelHandler : MulticastDelegate {
    public LogSwitchLevelHandler(object object, IntPtr method);
    public virtual void Invoke(LogSwitch ls, LoggingLevels newLevel);
    public virtual IAsyncResult BeginInvoke(LogSwitch ls, LoggingLevels newLevel, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.StackFrame : object {
    public static int OFFSET_UNKNOWN;
    public StackFrame(bool fNeedFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool fNeedFileInfo);
    internal StackFrame(bool DummyFlag1, bool DummyFlag2);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    internal void InitMembers();
    internal virtual void SetMethodBase(MethodBase mb);
    internal virtual void SetOffset(int iOffset);
    internal virtual void SetILOffset(int iOffset);
    internal virtual void SetFileName(string strFName);
    internal virtual void SetLineNumber(int iLine);
    internal virtual void SetColumnNumber(int iCol);
    internal virtual void SetIsLastFrameFromForeignExceptionStackTrace(bool fIsLastFrame);
    internal virtual bool GetIsLastFrameFromForeignExceptionStackTrace();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    [SecuritySafeCriticalAttribute]
public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
internal class System.Diagnostics.StackFrameHelper : object {
    public StackFrameHelper(bool fNeedFileLineColInfo, Thread target);
    [SecuritySafeCriticalAttribute]
public virtual MethodBase GetMethodBase(int i);
    public virtual int GetOffset(int i);
    public virtual int GetILOffset(int i);
    public virtual string GetFilename(int i);
    public virtual int GetLineNumber(int i);
    public virtual int GetColumnNumber(int i);
    public virtual bool IsLastFrameFromForeignExceptionStackTrace(int i);
    public virtual int GetNumberOfFrames();
    public virtual void SetNumberOfFrames(int i);
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use a constructor that does not require a Thread parameter.  http://go.microsoft.com/fwlink/?linkid=14202")]
public StackTrace(Thread targetThread, bool needFileInfo);
    [SecuritySafeCriticalAttribute]
internal static void GetStackFramesInternal(StackFrameHelper sfh, int iSkip, Exception e);
    internal static int CalculateFramesToSkip(StackFrameHelper StackF, int iNumFrames);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    [ComVisibleAttribute("False")]
public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolBinder {
    [ObsoleteAttribute("The recommended alternative is ISymbolBinder1.GetReader. ISymbolBinder1.GetReader takes the importer interface pointer as an IntPtr instead of an Int32, and thus works on both 32-bit and 64-bit architectures. http://go.microsoft.com/fwlink/?linkid=14202=14202")]
public abstract virtual ISymbolReader GetReader(int importer, string filename, string searchPath);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolBinder1 {
    public abstract virtual ISymbolReader GetReader(IntPtr importer, string filename, string searchPath);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolDocument {
    public string URL { get; }
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid CheckSumAlgorithmId { get; }
    public bool HasEmbeddedSource { get; }
    public int SourceLength { get; }
    public abstract virtual string get_URL();
    public abstract virtual Guid get_DocumentType();
    public abstract virtual Guid get_Language();
    public abstract virtual Guid get_LanguageVendor();
    public abstract virtual Guid get_CheckSumAlgorithmId();
    public abstract virtual Byte[] GetCheckSum();
    public abstract virtual int FindClosestLine(int line);
    public abstract virtual bool get_HasEmbeddedSource();
    public abstract virtual int get_SourceLength();
    public abstract virtual Byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetSource(Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolMethod {
    public SymbolToken Token { get; }
    public int SequencePointCount { get; }
    public ISymbolScope RootScope { get; }
    public abstract virtual SymbolToken get_Token();
    public abstract virtual int get_SequencePointCount();
    public abstract virtual void GetSequencePoints(Int32[] offsets, ISymbolDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual ISymbolScope get_RootScope();
    public abstract virtual ISymbolScope GetScope(int offset);
    public abstract virtual int GetOffset(ISymbolDocument document, int line, int column);
    public abstract virtual Int32[] GetRanges(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolVariable[] GetParameters();
    public abstract virtual ISymbolNamespace GetNamespace();
    public abstract virtual bool GetSourceStartEnd(ISymbolDocument[] docs, Int32[] lines, Int32[] columns);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolNamespace {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
    public abstract virtual ISymbolVariable[] GetVariables();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolReader {
    public SymbolToken UserEntryPoint { get; }
    public abstract virtual ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual ISymbolDocument[] GetDocuments();
    public abstract virtual SymbolToken get_UserEntryPoint();
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method);
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method, int version);
    public abstract virtual ISymbolVariable[] GetVariables(SymbolToken parent);
    public abstract virtual ISymbolVariable[] GetGlobalVariables();
    public abstract virtual ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column);
    public abstract virtual Byte[] GetSymAttribute(SymbolToken parent, string name);
    public abstract virtual ISymbolNamespace[] GetNamespaces();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolScope {
    public ISymbolMethod Method { get; }
    public ISymbolScope Parent { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public abstract virtual ISymbolMethod get_Method();
    public abstract virtual ISymbolScope get_Parent();
    public abstract virtual ISymbolScope[] GetChildren();
    public abstract virtual int get_StartOffset();
    public abstract virtual int get_EndOffset();
    public abstract virtual ISymbolVariable[] GetLocals();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolVariable {
    public string Name { get; }
    public object Attributes { get; }
    public SymAddressKind AddressKind { get; }
    public int AddressField1 { get; }
    public int AddressField2 { get; }
    public int AddressField3 { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public abstract virtual string get_Name();
    public abstract virtual object get_Attributes();
    public abstract virtual Byte[] GetSignature();
    public abstract virtual SymAddressKind get_AddressKind();
    public abstract virtual int get_AddressField1();
    public abstract virtual int get_AddressField2();
    public abstract virtual int get_AddressField3();
    public abstract virtual int get_StartOffset();
    public abstract virtual int get_EndOffset();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual void Initialize(IntPtr emitter, string filename, bool fFullBuild);
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void SetUserEntryPoint(SymbolToken entryMethod);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void CloseMethod();
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
    public abstract virtual void SetUnderlyingWriter(IntPtr underlyingWriter);
}
[ComVisibleAttribute("True")]
public enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeStackRegister;
    public static SymAddressKind BitField;
    public static SymAddressKind NativeSectionOffset;
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    internal int m_token;
    public SymbolToken(int val);
    public int GetToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SymbolToken obj);
    public static bool op_Equality(SymbolToken a, SymbolToken b);
    public static bool op_Inequality(SymbolToken a, SymbolToken b);
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymDocumentType : object {
    public static Guid Text;
    private static SymDocumentType();
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymLanguageType : object {
    public static Guid C;
    public static Guid CPlusPlus;
    public static Guid CSharp;
    public static Guid Basic;
    public static Guid Java;
    public static Guid Cobol;
    public static Guid Pascal;
    public static Guid ILAssembly;
    public static Guid JScript;
    public static Guid SMC;
    public static Guid MCPlusPlus;
    private static SymLanguageType();
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymLanguageVendor : object {
    public static Guid Microsoft;
    private static SymLanguageVendor();
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    public EventTask Task { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
public EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
public void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    public EventCommand Command { get; private set; }
    public IDictionary`2<string, string> Arguments { get; private set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventDispatcher dispatcher);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
private void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
internal class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public abstract class System.Diagnostics.Tracing.EventListener : object {
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    internal static object EventListenersLock { get; }
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal abstract virtual void OnEventWritten(EventWrittenEventArgs eventData);
    protected static int EventSourceIndex(EventSource eventSource);
    internal static void AddEventSource(EventSource newEventSource);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
}
[FriendAccessAllowedAttribute]
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    [SecurityCriticalAttribute]
protected EventProvider(Guid providerGuid);
    [SecurityCriticalAttribute]
internal void Register(Guid providerGuid);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual void Finalize();
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    [SecuritySafeCriticalAttribute]
public bool WriteEvent(EventDescriptor& eventDescriptor, Object[] eventPayload);
    [SecurityCriticalAttribute]
public bool WriteEvent(EventDescriptor& eventDescriptor, string data);
    [SecurityCriticalAttribute]
protected internal bool WriteEvent(EventDescriptor& eventDescriptor, int dataCount, IntPtr data);
}
public class System.Diagnostics.Tracing.EventSource : object {
    internal int m_id;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    public string Name { get; }
    public Guid Guid { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    public string get_Name();
    public Guid get_Guid();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static IEnumerable`1<EventSource> GetSources();
    public virtual string ToString();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, string arg1, long arg2);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [SecuritySafeCriticalAttribute]
protected void WriteEvent(int eventId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Finalize();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    internal static void SendCommand(EventSource eventSource, EventListener eventListener, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void SendCommand(EventListener listener, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, int eventId, bool value);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType);
    internal void AddListener(EventListener listener);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
[FriendAccessAllowedAttribute]
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    public int EventId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public string Message { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    internal EventWrittenEventArgs(EventSource eventSource);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public string get_Message();
    public byte get_Version();
    public EventLevel get_Level();
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.FrameworkEventSource : EventSource {
    public static FrameworkEventSource Log;
    public static bool IsInitialized { get; }
    private static FrameworkEventSource();
    public static bool get_IsInitialized();
    [EventAttribute("1")]
public void ResourceManagerLookupStarted(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("2")]
public void ResourceManagerLookingForResourceSet(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("3")]
public void ResourceManagerFoundResourceSetInCache(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("4")]
public void ResourceManagerFoundResourceSetInCacheUnexpected(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("5")]
public void ResourceManagerStreamFound(string baseName, string mainAssemblyName, string cultureName, string loadedAssemblyName, string resourceFileName);
    [EventAttribute("6")]
public void ResourceManagerStreamNotFound(string baseName, string mainAssemblyName, string cultureName, string loadedAssemblyName, string resourceFileName);
    [EventAttribute("7")]
public void ResourceManagerGetSatelliteAssemblySucceeded(string baseName, string mainAssemblyName, string cultureName, string assemblyName);
    [EventAttribute("8")]
public void ResourceManagerGetSatelliteAssemblyFailed(string baseName, string mainAssemblyName, string cultureName, string assemblyName);
    [EventAttribute("9")]
public void ResourceManagerCaseInsensitiveResourceStreamLookupSucceeded(string baseName, string mainAssemblyName, string assemblyName, string resourceFileName);
    [EventAttribute("10")]
public void ResourceManagerCaseInsensitiveResourceStreamLookupFailed(string baseName, string mainAssemblyName, string assemblyName, string resourceFileName);
    [EventAttribute("11")]
public void ResourceManagerManifestResourceAccessDenied(string baseName, string mainAssemblyName, string assemblyName, string canonicalName);
    [EventAttribute("12")]
public void ResourceManagerNeutralResourcesSufficient(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("13")]
public void ResourceManagerNeutralResourceAttributeMissing(string mainAssemblyName);
    [EventAttribute("14")]
public void ResourceManagerCreatingResourceSet(string baseName, string mainAssemblyName, string cultureName, string fileName);
    [EventAttribute("15")]
public void ResourceManagerNotCreatingResourceSet(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("16")]
public void ResourceManagerLookupFailed(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("17")]
public void ResourceManagerReleasingResources(string baseName, string mainAssemblyName);
    [EventAttribute("18")]
public void ResourceManagerNeutralResourcesNotFound(string baseName, string mainAssemblyName, string resName);
    [EventAttribute("19")]
public void ResourceManagerNeutralResourcesFound(string baseName, string mainAssemblyName, string resName);
    [EventAttribute("20")]
public void ResourceManagerAddingCultureFromConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("21")]
public void ResourceManagerCultureNotFoundInConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("22")]
public void ResourceManagerCultureFoundInConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookupStarted(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookingForResourceSet(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerFoundResourceSetInCache(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerFoundResourceSetInCacheUnexpected(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerStreamFound(string baseName, Assembly mainAssembly, string cultureName, Assembly loadedAssembly, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerStreamNotFound(string baseName, Assembly mainAssembly, string cultureName, Assembly loadedAssembly, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerGetSatelliteAssemblySucceeded(string baseName, Assembly mainAssembly, string cultureName, string assemblyName);
    [NonEventAttribute]
public void ResourceManagerGetSatelliteAssemblyFailed(string baseName, Assembly mainAssembly, string cultureName, string assemblyName);
    [NonEventAttribute]
public void ResourceManagerCaseInsensitiveResourceStreamLookupSucceeded(string baseName, Assembly mainAssembly, string assemblyName, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerCaseInsensitiveResourceStreamLookupFailed(string baseName, Assembly mainAssembly, string assemblyName, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerManifestResourceAccessDenied(string baseName, Assembly mainAssembly, string assemblyName, string canonicalName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesSufficient(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourceAttributeMissing(Assembly mainAssembly);
    [NonEventAttribute]
public void ResourceManagerCreatingResourceSet(string baseName, Assembly mainAssembly, string cultureName, string fileName);
    [NonEventAttribute]
public void ResourceManagerNotCreatingResourceSet(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookupFailed(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerReleasingResources(string baseName, Assembly mainAssembly);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesNotFound(string baseName, Assembly mainAssembly, string resName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesFound(string baseName, Assembly mainAssembly, string resName);
    [NonEventAttribute]
public void ResourceManagerAddingCultureFromConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerCultureNotFoundInConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerCultureFoundInConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    [EventAttribute("30")]
public void ThreadPoolEnqueueWork(long workID);
    [NonEventAttribute]
[SecuritySafeCriticalAttribute]
internal void ThreadPoolEnqueueWorkObject(object workID);
    [EventAttribute("31")]
public void ThreadPoolDequeueWork(long workID);
    [NonEventAttribute]
[SecuritySafeCriticalAttribute]
internal void ThreadPoolDequeueWorkObject(object workID);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources);
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public Byte[] CreateManifest();
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Double : ValueType {
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    internal double m_value;
    internal static double NegativeZero;
    private static Double();
    [SecuritySafeCriticalAttribute]
public static bool IsInfinity(double d);
    public static bool IsPositiveInfinity(double d);
    public static bool IsNegativeInfinity(double d);
    [SecuritySafeCriticalAttribute]
internal static bool IsNegative(double d);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static bool IsNaN(double d);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(double left, double right);
    public static bool op_Inequality(double left, double right);
    public static bool op_LessThan(double left, double right);
    public static bool op_GreaterThan(double left, double right);
    public static bool op_LessThanOrEqual(double left, double right);
    public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, IFormatProvider provider);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
internal class System.DTSubString : ValueType {
    internal string s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
[ComVisibleAttribute("True")]
public class System.DuplicateWaitObjectException : ArgumentException {
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    private static DuplicateWaitObjectException();
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public abstract class System.Enum : ValueType {
    private static Enum();
    internal static ulong ToUInt64(object value);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    [ComVisibleAttribute("True")]
public static object Parse(Type enumType, string value);
    [ComVisibleAttribute("True")]
public static object Parse(Type enumType, string value, bool ignoreCase);
    [ComVisibleAttribute("True")]
public static Type GetUnderlyingType(Type enumType);
    [ComVisibleAttribute("True")]
public static Array GetValues(Type enumType);
    internal static UInt64[] InternalGetValues(RuntimeType enumType);
    [ComVisibleAttribute("True")]
public static string GetName(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static String[] GetNames(Type enumType);
    internal static String[] InternalGetNames(RuntimeType enumType);
    [ComVisibleAttribute("True")]
public static object ToObject(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static bool IsDefined(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static string Format(Type enumType, object value, string format);
    [SecuritySafeCriticalAttribute]
internal object GetValue();
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(object target);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public bool HasFlag(Enum flag);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public static object ToObject(Type enumType, sbyte value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, short value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, int value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, byte value);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, long value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
}
[ComVisibleAttribute("True")]
public static class System.Environment : object {
    public static int TickCount { get; }
    public static int ExitCode { get; public set; }
    internal static bool IsCLRHosted { get; }
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static string SystemDirectory { get; }
    internal static string InternalWindowsDirectory { get; }
    public static string MachineName { get; }
    public static int ProcessorCount { get; }
    public static int SystemPageSize { get; }
    public static string NewLine { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    public static OperatingSystem OSVersion { get; }
    internal static bool IsWindowsVista { get; }
    internal static bool IsWindows8OrAbove { get; }
    internal static bool IsW2k3 { get; }
    internal static bool RunningOnWinNT { get; }
    internal static bool IsWinRTSupported { get; }
    internal static OSName OSInfo { get; }
    public static string StackTrace { get; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool HasShutdownStarted { get; }
    public static string UserName { get; }
    public static bool UserInteractive { get; }
    public static string UserDomainName { get; }
    public static int CurrentManagedThreadId { get; }
    [SecuritySafeCriticalAttribute]
public static int get_TickCount();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void _Exit(int exitCode);
    [SecuritySafeCriticalAttribute]
public static void Exit(int exitCode);
    [SecuritySafeCriticalAttribute]
public static int get_ExitCode();
    [SecuritySafeCriticalAttribute]
public static void set_ExitCode(int value);
    [SecurityCriticalAttribute]
public static void FailFast(string message);
    [SecurityCriticalAttribute]
internal static void FailFast(string message, UInt32 exitCode);
    [SecurityCriticalAttribute]
public static void FailFast(string message, Exception exception);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static void TriggerCodeContractFailure(ContractFailureKind failureKind, string message, string condition, string exceptionAsString);
    [SecuritySafeCriticalAttribute]
internal static bool get_IsCLRHosted();
    [SecuritySafeCriticalAttribute]
public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    [SecuritySafeCriticalAttribute]
public static string get_SystemDirectory();
    [SecurityCriticalAttribute]
internal static string get_InternalWindowsDirectory();
    [SecuritySafeCriticalAttribute]
public static string ExpandEnvironmentVariables(string name);
    [SecuritySafeCriticalAttribute]
public static string get_MachineName();
    [SecuritySafeCriticalAttribute]
public static int get_ProcessorCount();
    [SecuritySafeCriticalAttribute]
public static int get_SystemPageSize();
    [SecuritySafeCriticalAttribute]
public static String[] GetCommandLineArgs();
    [SecurityCriticalAttribute]
internal static string nativeGetEnvironmentVariable(string variable);
    [SecuritySafeCriticalAttribute]
public static string GetEnvironmentVariable(string variable);
    [SecuritySafeCriticalAttribute]
public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    [SecuritySafeCriticalAttribute]
public static IDictionary GetEnvironmentVariables();
    internal static IDictionary GetRegistryKeyNameValuePairs(RegistryKey registryKey);
    [SecuritySafeCriticalAttribute]
public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    [SecuritySafeCriticalAttribute]
public static void SetEnvironmentVariable(string variable, string value);
    [SecuritySafeCriticalAttribute]
public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    [SecuritySafeCriticalAttribute]
public static String[] GetLogicalDrives();
    public static string get_NewLine();
    public static Version get_Version();
    [SecuritySafeCriticalAttribute]
public static long get_WorkingSet();
    [SecuritySafeCriticalAttribute]
public static OperatingSystem get_OSVersion();
    internal static bool get_IsWindowsVista();
    internal static bool get_IsWindows8OrAbove();
    internal static bool get_IsW2k3();
    internal static bool get_RunningOnWinNT();
    [SecuritySafeCriticalAttribute]
internal static bool get_IsWinRTSupported();
    [SecurityCriticalAttribute]
internal static bool GetVersion(OSVERSIONINFO osVer);
    [SecurityCriticalAttribute]
internal static bool GetVersionEx(OSVERSIONINFOEX osVer);
    [SecuritySafeCriticalAttribute]
internal static OSName get_OSInfo();
    [SecuritySafeCriticalAttribute]
public static string get_StackTrace();
    internal static string GetStackTrace(Exception e, bool needFileInfo);
    [SecurityCriticalAttribute]
internal static string GetResourceFromDefault(string key);
    internal static string GetResourceStringLocal(string key);
    [SecuritySafeCriticalAttribute]
internal static string GetResourceString(string key);
    [SecuritySafeCriticalAttribute]
internal static string GetResourceString(string key, Object[] values);
    [SecuritySafeCriticalAttribute]
internal static string GetRuntimeResourceString(string key);
    [SecuritySafeCriticalAttribute]
internal static string GetRuntimeResourceString(string key, Object[] values);
    public static bool get_Is64BitProcess();
    [SecuritySafeCriticalAttribute]
public static bool get_Is64BitOperatingSystem();
    [SecuritySafeCriticalAttribute]
public static bool get_HasShutdownStarted();
    [SecurityCriticalAttribute]
internal static bool GetCompatibilityFlag(CompatibilityFlag flag);
    [SecuritySafeCriticalAttribute]
public static string get_UserName();
    [SecuritySafeCriticalAttribute]
public static bool get_UserInteractive();
    [SecuritySafeCriticalAttribute]
public static string GetFolderPath(SpecialFolder folder);
    [SecuritySafeCriticalAttribute]
public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    [SecurityCriticalAttribute]
internal static string UnsafeGetFolderPath(SpecialFolder folder);
    [SecuritySafeCriticalAttribute]
public static string get_UserDomainName();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static int get_CurrentManagedThreadId();
}
[ComVisibleAttribute("True")]
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[ComVisibleAttribute("True")]
public class System.EventArgs : object {
    public static EventArgs Empty;
    private static EventArgs();
}
[ComVisibleAttribute("True")]
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Exception")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Exception : object {
    internal string _message;
    internal int _HResult;
    public string Message { get; }
    public IDictionary Data { get; }
    public Exception InnerException { get; }
    public MethodBase TargetSite { get; }
    public string StackTrace { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal string RemoteStackTrace { get; }
    public int HResult { get; protected set; }
    internal bool IsTransient { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    public virtual string get_Message();
    [SecuritySafeCriticalAttribute]
public virtual IDictionary get_Data();
    [FriendAccessAllowedAttribute]
internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject);
    public virtual Exception GetBaseException();
    public sealed virtual Exception get_InnerException();
    [SecuritySafeCriticalAttribute]
public sealed virtual MethodBase get_TargetSite();
    public virtual string get_StackTrace();
    [FriendAccessAllowedAttribute]
internal void SetErrorCode(int hr);
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string ToString();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Exception PrepForRemoting();
    internal void InternalPreserveStackTrace();
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal string get_RemoteStackTrace();
    [SecurityCriticalAttribute]
internal static void SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray);
    [SecuritySafeCriticalAttribute]
internal object DeepCopyStackTrace(object currentStackTrace);
    [SecuritySafeCriticalAttribute]
internal object DeepCopyDynamicMethods(object currentDynamicMethods);
    [SecuritySafeCriticalAttribute]
internal void GetStackTracesDeepCopy(Object& currentStackTrace, Object& dynamicMethodArray);
    [SecuritySafeCriticalAttribute]
internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo);
    public int get_HResult();
    protected void set_HResult(int value);
    [SecurityCriticalAttribute]
internal virtual string InternalToString();
    public sealed virtual Type GetType();
    [SecuritySafeCriticalAttribute]
internal bool get_IsTransient();
    [SecuritySafeCriticalAttribute]
internal static string GetMessageFromNativeResources(ExceptionMessageKind kind);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument dictionaryCreationThreshold;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument collection;
    public static ExceptionArgument list;
    public static ExceptionArgument match;
    public static ExceptionArgument converter;
    public static ExceptionArgument queue;
    public static ExceptionArgument stack;
    public static ExceptionArgument capacity;
    public static ExceptionArgument index;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument value;
    public static ExceptionArgument count;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument name;
    public static ExceptionArgument mode;
    public static ExceptionArgument item;
    public static ExceptionArgument options;
    public static ExceptionArgument view;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_ImplementIComparable;
    public static ExceptionResource Argument_InvalidType;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Argument_InvalidRegistryKeyPermissionCheck;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_RegKeyDelHive;
    public static ExceptionResource Arg_RegKeyStrLenBug;
    public static ExceptionResource Arg_RegSetStrArrNull;
    public static ExceptionResource Arg_RegSetMismatchedKind;
    public static ExceptionResource Arg_RegSubKeyAbsent;
    public static ExceptionResource Arg_RegSubKeyValueAbsent;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Serialization_InvalidOnDeser;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource Argument_InvalidArrayType;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_ItemNotExist;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource ArgumentOutOfRange_InvalidThreshold;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
    public static ExceptionResource InvalidOperation_EmptyQueue;
    public static ExceptionResource InvalidOperation_EnumOpCantHappen;
    public static ExceptionResource InvalidOperation_EnumFailedVersion;
    public static ExceptionResource InvalidOperation_EmptyStack;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource InvalidOperation_EnumNotStarted;
    public static ExceptionResource InvalidOperation_EnumEnded;
    public static ExceptionResource NotSupported_SortedListNestedWrite;
    public static ExceptionResource InvalidOperation_NoValue;
    public static ExceptionResource InvalidOperation_RegRemoveSubKey;
    public static ExceptionResource Security_RegistryPermission;
    public static ExceptionResource UnauthorizedAccess_RegistryNoWrite;
    public static ExceptionResource ObjectDisposed_RegKeyClosed;
    public static ExceptionResource NotSupported_InComparableType;
    public static ExceptionResource Argument_InvalidRegistryOptionsCheck;
    public static ExceptionResource Argument_InvalidRegistryViewCheck;
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
[ComVisibleAttribute("True")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    [SecurityCriticalAttribute]
internal static int GetGCLatencyMode();
    [SecurityCriticalAttribute]
internal static void SetGCLatencyMode(int newLatencyMode);
    [SecurityCriticalAttribute]
internal static bool IsServerGC();
    [SecurityCriticalAttribute]
public static void AddMemoryPressure(long bytesAllocated);
    [SecurityCriticalAttribute]
public static void RemoveMemoryPressure(long bytesAllocated);
    [SecuritySafeCriticalAttribute]
public static int GetGeneration(object obj);
    public static void Collect(int generation);
    [SecuritySafeCriticalAttribute]
public static void Collect();
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode);
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static int CollectionCount(int generation);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
internal static int CollectionCount(int generation, bool getSpecialGCCount);
    [ReliabilityContractAttribute("3", "2")]
public static void KeepAlive(object obj);
    [SecuritySafeCriticalAttribute]
public static int GetGeneration(WeakReference wo);
    [SecuritySafeCriticalAttribute]
public static int get_MaxGeneration();
    [SecuritySafeCriticalAttribute]
public static void WaitForPendingFinalizers();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void SuppressFinalize(object obj);
    [SecuritySafeCriticalAttribute]
public static void ReRegisterForFinalize(object obj);
    [SecuritySafeCriticalAttribute]
public static long GetTotalMemory(bool forceFullCollection);
    [SecurityCriticalAttribute]
public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    [SecurityCriticalAttribute]
public static void CancelFullGCNotification();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCApproach();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCComplete();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Globalization.AppDomainSortingSetupInfo : object {
    internal IntPtr _pfnIsNLSDefinedString;
    internal IntPtr _pfnCompareStringEx;
    internal IntPtr _pfnLCMapStringEx;
    internal IntPtr _pfnFindNLSStringEx;
    internal IntPtr _pfnCompareStringOrdinal;
    internal IntPtr _pfnGetNLSVersionEx;
    internal IntPtr _pfnFindStringOrdinal;
    internal bool _useV2LegacySorting;
    internal bool _useV4LegacySorting;
    internal AppDomainSortingSetupInfo(AppDomainSortingSetupInfo copy);
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
}
[ComVisibleAttribute("True")]
public abstract class System.Globalization.Calendar : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int CAL_GREGORIAN;
    internal static int CAL_GREGORIAN_US;
    internal static int CAL_JAPAN;
    internal static int CAL_TAIWAN;
    internal static int CAL_KOREA;
    internal static int CAL_HIJRI;
    internal static int CAL_THAI;
    internal static int CAL_HEBREW;
    internal static int CAL_GREGORIAN_ME_FRENCH;
    internal static int CAL_GREGORIAN_ARABIC;
    internal static int CAL_GREGORIAN_XLIT_ENGLISH;
    internal static int CAL_GREGORIAN_XLIT_FRENCH;
    internal static int CAL_JULIAN;
    internal static int CAL_JAPANESELUNISOLAR;
    internal static int CAL_CHINESELUNISOLAR;
    internal static int CAL_SAKA;
    internal static int CAL_LUNAR_ETO_CHN;
    internal static int CAL_LUNAR_ETO_KOR;
    internal static int CAL_LUNAR_ETO_ROKUYOU;
    internal static int CAL_KOREANLUNISOLAR;
    internal static int CAL_TAIWANLUNISOLAR;
    internal static int CAL_PERSIAN;
    internal static int CAL_UMALQURA;
    public static int CurrentEra;
    internal int m_currentEraValue;
    internal int twoDigitYearMax;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    internal int ID { get; }
    internal int BaseCalendarID { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    internal virtual int get_ID();
    internal virtual int get_BaseCalendarID();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public bool get_IsReadOnly();
    [ComVisibleAttribute("False")]
public virtual object Clone();
    [ComVisibleAttribute("False")]
public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    [SecuritySafeCriticalAttribute]
internal static int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue);
}
[ComVisibleAttribute("True")]
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal static int MAX_CALENDARS;
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    private static CalendarData();
    internal CalendarData(string localeName, int calendarId, bool bUseUserOverrides);
    internal static CalendarData GetCalendarData(int calendarId);
    internal void FixupWin7MonthDaySemicolonBug();
    [SecurityCriticalAttribute]
internal static int nativeGetTwoDigitYearMax(int calID);
    [SecuritySafeCriticalAttribute]
internal static int nativeGetCalendars(string localeName, bool useUserOverride, Int32[] calendars);
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
[ComVisibleAttribute("True")]
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
public static class System.Globalization.CharUnicodeInfo : object {
    internal static char HIGH_SURROGATE_START;
    internal static char HIGH_SURROGATE_END;
    internal static char LOW_SURROGATE_START;
    internal static char LOW_SURROGATE_END;
    internal static int UNICODE_CATEGORY_OFFSET;
    internal static int BIDI_CATEGORY_OFFSET;
    internal static string UNICODE_INFO_FILE_NAME;
    internal static int UNICODE_PLANE01_START;
    private static CharUnicodeInfo();
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static bool IsWhiteSpace(string s, int index);
    internal static bool IsWhiteSpace(char c);
    [SecuritySafeCriticalAttribute]
internal static double InternalGetNumericValue(int ch);
    [SecuritySafeCriticalAttribute]
internal static DigitValues* InternalGetDigitValues(int ch);
    [SecuritySafeCriticalAttribute]
internal static sbyte InternalGetDecimalDigitValue(int ch);
    [SecuritySafeCriticalAttribute]
internal static sbyte InternalGetDigitValue(int ch);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(int ch);
    [SecuritySafeCriticalAttribute]
internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int ID { get; }
    internal int BaseCalendarID { get; }
    [ComVisibleAttribute("False")]
public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetEra(DateTime time);
    internal virtual int get_ID();
    internal virtual int get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
internal class System.Globalization.CodePageDataItem : object {
    internal int m_dataIndex;
    internal int m_uiFamilyCodePage;
    internal string m_webName;
    internal string m_headerName;
    internal string m_bodyName;
    internal UInt32 m_flags;
    public string WebName { get; }
    public int UIFamilyCodePage { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public UInt32 Flags { get; }
    [SecurityCriticalAttribute]
internal CodePageDataItem(int dataIndex);
    [SecurityCriticalAttribute]
internal static string CreateString(SByte* pStrings, UInt32 index);
    [SecuritySafeCriticalAttribute]
public string get_WebName();
    public virtual int get_UIFamilyCodePage();
    [SecuritySafeCriticalAttribute]
public string get_HeaderName();
    [SecuritySafeCriticalAttribute]
public string get_BodyName();
    public UInt32 get_Flags();
}
[ComVisibleAttribute("True")]
public class System.Globalization.CompareInfo : object {
    internal static int NORM_LINGUISTIC_CASING;
    [ComVisibleAttribute("False")]
public string Name { get; }
    public int LCID { get; }
    internal static bool IsLegacy20SortingBehaviorRequested { get; }
    public SortVersion Version { get; }
    internal CompareInfo(CultureInfo culture);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    [ComVisibleAttribute("False")]
public static bool IsSortable(char ch);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public static bool IsSortable(string text);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string get_Name();
    internal static int GetNativeCompareFlags(CompareOptions options);
    public virtual int Compare(string string1, string string2);
    [SecuritySafeCriticalAttribute]
public virtual int Compare(string string1, string string2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    [SecuritySafeCriticalAttribute]
public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    [SecuritySafeCriticalAttribute]
public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    [SecuritySafeCriticalAttribute]
public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    [SecuritySafeCriticalAttribute]
public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    [SecuritySafeCriticalAttribute]
public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal int GetHashCodeOfString(string source, CompareOptions options);
    [SecuritySafeCriticalAttribute]
internal int GetHashCodeOfString(string source, CompareOptions options, bool forceRandomizedHashing, long additionalEntropy);
    public virtual string ToString();
    public int get_LCID();
    [SecuritySafeCriticalAttribute]
internal static IntPtr InternalInitSortHandle(string localeName, IntPtr& handleOrigin);
    internal static bool get_IsLegacy20SortingBehaviorRequested();
    [SecuritySafeCriticalAttribute]
public SortVersion get_Version();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
[FriendAccessAllowedAttribute]
internal class System.Globalization.CultureData : object {
    internal static UInt32 TIME_NOSECONDS;
    internal static ResourceSet modreq(System.Runtime.CompilerServices.IsVolatile) MscorlibResourceSet;
    internal static CultureInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) specificCultures;
    internal static String[] modreq(System.Runtime.CompilerServices.IsVolatile) s_replacementCultureNames;
    internal static CultureData Invariant { get; }
    internal bool IsReplacementCulture { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string SNAME { get; }
    internal string SPARENT { get; }
    internal string SLOCALIZEDDISPLAYNAME { get; }
    internal string SENGDISPLAYNAME { get; }
    internal string SNATIVEDISPLAYNAME { get; }
    internal string SSPECIFICCULTURE { get; }
    internal string SISO639LANGNAME { get; }
    internal string SISO639LANGNAME2 { get; }
    internal string SABBREVLANGNAME { get; }
    internal string SLOCALIZEDLANGUAGE { get; }
    internal string SENGLISHLANGUAGE { get; }
    internal string SNATIVELANGUAGE { get; }
    internal string SREGIONNAME { get; }
    internal int ICOUNTRY { get; }
    internal int IGEOID { get; }
    internal string SLOCALIZEDCOUNTRY { get; }
    internal string SENGCOUNTRY { get; }
    internal string SNATIVECOUNTRY { get; }
    internal string SISO3166CTRYNAME { get; }
    internal string SISO3166CTRYNAME2 { get; }
    internal string SABBREVCTRYNAME { get; }
    internal int IINPUTLANGUAGEHANDLE { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] WAGROUPING { get; }
    internal string SNAN { get; }
    internal string SPOSINFINITY { get; }
    internal string SNEGINFINITY { get; }
    internal int INEGATIVEPERCENT { get; }
    internal int IPOSITIVEPERCENT { get; }
    internal string SPERCENT { get; }
    internal string SPERMILLE { get; }
    internal string SCURRENCY { get; }
    internal string SINTLSYMBOL { get; }
    internal string SENGLISHCURRENCY { get; }
    internal string SNATIVECURRENCY { get; }
    internal Int32[] WAMONGROUPING { get; }
    internal int IMEASURE { get; }
    internal string SLIST { get; }
    internal string SAM1159 { get; }
    internal string SPM2359 { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal String[] SADURATION { get; }
    internal int IFIRSTDAYOFWEEK { get; }
    internal int IFIRSTWEEKOFYEAR { get; }
    internal Int32[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    internal string STEXTINFO { get; }
    internal string SCOMPAREINFO { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int IDEFAULTANSICODEPAGE { get; }
    internal int IDEFAULTOEMCODEPAGE { get; }
    internal int IDEFAULTMACCODEPAGE { get; }
    internal int IDEFAULTEBCDICCODEPAGE { get; }
    internal int ILANGUAGE { get; }
    internal bool IsWin32Installed { get; }
    internal bool IsFramework { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    private static CultureData();
    internal static CultureData get_Invariant();
    [FriendAccessAllowedAttribute]
internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    [SecurityCriticalAttribute]
internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    [SecuritySafeCriticalAttribute]
internal static string LCIDToLocaleName(int lcid);
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal static void ClearCachedData();
    [SecuritySafeCriticalAttribute]
internal static CultureInfo[] GetCultures(CultureTypes types);
    internal bool get_IsReplacementCulture();
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_SNAME();
    [SecurityCriticalAttribute]
internal string get_SPARENT();
    [SecurityCriticalAttribute]
internal string get_SLOCALIZEDDISPLAYNAME();
    [SecurityCriticalAttribute]
internal string get_SENGDISPLAYNAME();
    [SecurityCriticalAttribute]
internal string get_SNATIVEDISPLAYNAME();
    internal string get_SSPECIFICCULTURE();
    [SecurityCriticalAttribute]
internal string get_SISO639LANGNAME();
    [SecurityCriticalAttribute]
internal string get_SISO639LANGNAME2();
    [SecurityCriticalAttribute]
internal string get_SABBREVLANGNAME();
    [SecurityCriticalAttribute]
internal string get_SLOCALIZEDLANGUAGE();
    [SecurityCriticalAttribute]
internal string get_SENGLISHLANGUAGE();
    [SecurityCriticalAttribute]
internal string get_SNATIVELANGUAGE();
    [SecurityCriticalAttribute]
internal string get_SREGIONNAME();
    internal int get_ICOUNTRY();
    internal int get_IGEOID();
    [SecurityCriticalAttribute]
internal string get_SLOCALIZEDCOUNTRY();
    [SecurityCriticalAttribute]
internal string get_SENGCOUNTRY();
    [SecurityCriticalAttribute]
internal string get_SNATIVECOUNTRY();
    [SecurityCriticalAttribute]
internal string get_SISO3166CTRYNAME();
    [SecurityCriticalAttribute]
internal string get_SISO3166CTRYNAME2();
    [SecurityCriticalAttribute]
internal string get_SABBREVCTRYNAME();
    internal int get_IINPUTLANGUAGEHANDLE();
    [SecurityCriticalAttribute]
internal string get_SCONSOLEFALLBACKNAME();
    [SecurityCriticalAttribute]
internal Int32[] get_WAGROUPING();
    [SecurityCriticalAttribute]
internal string get_SNAN();
    [SecurityCriticalAttribute]
internal string get_SPOSINFINITY();
    [SecurityCriticalAttribute]
internal string get_SNEGINFINITY();
    internal int get_INEGATIVEPERCENT();
    internal int get_IPOSITIVEPERCENT();
    [SecurityCriticalAttribute]
internal string get_SPERCENT();
    [SecurityCriticalAttribute]
internal string get_SPERMILLE();
    [SecurityCriticalAttribute]
internal string get_SCURRENCY();
    [SecurityCriticalAttribute]
internal string get_SINTLSYMBOL();
    [SecurityCriticalAttribute]
internal string get_SENGLISHCURRENCY();
    [SecurityCriticalAttribute]
internal string get_SNATIVECURRENCY();
    [SecurityCriticalAttribute]
internal Int32[] get_WAMONGROUPING();
    internal int get_IMEASURE();
    [SecurityCriticalAttribute]
internal string get_SLIST();
    [SecurityCriticalAttribute]
internal string get_SAM1159();
    [SecurityCriticalAttribute]
internal string get_SPM2359();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    [SecurityCriticalAttribute]
internal String[] get_SADURATION();
    internal int get_IFIRSTDAYOFWEEK();
    internal int get_IFIRSTWEEKOFYEAR();
    internal String[] ShortDates(int calendarId);
    internal String[] LongDates(int calendarId);
    internal String[] YearMonths(int calendarId);
    internal String[] DayNames(int calendarId);
    internal String[] AbbreviatedDayNames(int calendarId);
    internal String[] SuperShortDayNames(int calendarId);
    internal String[] MonthNames(int calendarId);
    internal String[] GenitiveMonthNames(int calendarId);
    internal String[] AbbreviatedMonthNames(int calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(int calendarId);
    internal String[] LeapYearMonthNames(int calendarId);
    internal string MonthDay(int calendarId);
    internal Int32[] get_CalendarIds();
    internal string CalendarName(int calendarId);
    internal CalendarData GetCalendar(int calendarId);
    internal int CurrentEra(int calendarId);
    internal bool get_IsRightToLeft();
    [SecuritySafeCriticalAttribute]
internal string get_STEXTINFO();
    [SecuritySafeCriticalAttribute]
internal string get_SCOMPAREINFO();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_IDEFAULTANSICODEPAGE();
    internal int get_IDEFAULTOEMCODEPAGE();
    internal int get_IDEFAULTMACCODEPAGE();
    internal int get_IDEFAULTEBCDICCODEPAGE();
    [SecuritySafeCriticalAttribute]
internal static int LocaleNameToLCID(string localeName);
    internal int get_ILANGUAGE();
    internal bool get_IsWin32Installed();
    internal bool get_IsFramework();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(int calendarId);
    internal String[] AbbrevEraNames(int calendarId);
    internal String[] AbbreviatedEnglishEraNames(int calendarId);
    [SecuritySafeCriticalAttribute]
internal string get_TimeSeparator();
    internal string DateSeparator(int calendarId);
    internal static string ReescapeWin32String(string str);
    internal static String[] ReescapeWin32Strings(String[] array);
    internal static bool IsCustomCultureId(int cultureId);
    [SecurityCriticalAttribute]
internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    [SecuritySafeCriticalAttribute]
internal static bool nativeInitCultureData(CultureData cultureData);
    [SecuritySafeCriticalAttribute]
internal static bool nativeGetNumberFormatInfoValues(string localeName, NumberFormatInfo nfi, bool useUserOverride);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int nativeEnumCultureNames(int cultureTypes, ObjectHandleOnStack retStringArray);
}
[ComVisibleAttribute("True")]
public class System.Globalization.CultureInfo : object {
    internal static int LOCALE_NEUTRAL;
    internal static int LOCALE_CUSTOM_DEFAULT;
    internal static int LOCALE_CUSTOM_UNSPECIFIED;
    internal static int LOCALE_INVARIANT;
    internal bool m_isReadOnly;
    internal CompareInfo compareInfo;
    internal TextInfo textInfo;
    internal RegionInfo regionInfo;
    internal NumberFormatInfo numInfo;
    internal DateTimeFormatInfo dateTimeInfo;
    internal Calendar calendar;
    [OptionalFieldAttribute]
internal int m_dataItem;
    [OptionalFieldAttribute]
internal int cultureID;
    internal CultureData m_cultureData;
    internal bool m_isInherited;
    internal string m_name;
    internal bool IsSafeCrossDomain { get; }
    internal int CreatedDomainID { get; }
    public static CultureInfo CurrentCulture { get; }
    internal static CultureInfo UserDefaultCulture { get; }
    internal static CultureInfo UserDefaultUICulture { get; }
    public static CultureInfo CurrentUICulture { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    [ComVisibleAttribute("False")]
public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    [ComVisibleAttribute("False")]
public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    [ComVisibleAttribute("False")]
public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    internal static bool IsTaiwanSku { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    [SecuritySafeCriticalAttribute]
internal static CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
    internal static void CheckDomainSafetyObject(object obj, object container);
    internal bool get_IsSafeCrossDomain();
    internal int get_CreatedDomainID();
    internal bool CanSendCrossDomain();
    internal void StartCrossDomainTracking();
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static CultureInfo get_CurrentCulture();
    internal static CultureInfo get_UserDefaultCulture();
    internal static CultureInfo get_UserDefaultUICulture();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static CultureInfo get_CurrentUICulture();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_DefaultThreadCurrentCulture();
    [SecuritySafeCriticalAttribute]
public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    [SecuritySafeCriticalAttribute]
public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static CultureInfo get_InvariantCulture();
    [SecuritySafeCriticalAttribute]
public virtual CultureInfo get_Parent();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    public string get_IetfLanguageTag();
    [SecuritySafeCriticalAttribute]
public virtual string get_DisplayName();
    [SecuritySafeCriticalAttribute]
public virtual string get_NativeName();
    [SecuritySafeCriticalAttribute]
public virtual string get_EnglishName();
    [SecuritySafeCriticalAttribute]
public virtual string get_TwoLetterISOLanguageName();
    [SecuritySafeCriticalAttribute]
public virtual string get_ThreeLetterISOLanguageName();
    [SecuritySafeCriticalAttribute]
public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    public virtual TextInfo get_TextInfo();
    public virtual bool Equals(object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    public virtual string ToString();
    public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(int calType);
    internal static Calendar GetCalendarInstanceRare(int calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    internal bool get_HasInvariantCultureName();
    internal static CultureInfo GetCultureInfoHelper(int lcid, string name, string altName);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    internal static bool get_IsTaiwanSku();
    [SecurityCriticalAttribute]
internal static string nativeGetLocaleInfoEx(string localeName, UInt32 field);
    [SecuritySafeCriticalAttribute]
internal static int nativeGetLocaleInfoExInt(string localeName, UInt32 field);
    [SecurityCriticalAttribute]
internal static bool nativeSetThreadLocale(string localeName);
}
[ComVisibleAttribute("True")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    public virtual string get_Message();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
[ComVisibleAttribute("True")]
public class System.Globalization.DateTimeFormatInfo : object {
    internal static string rfc1123Pattern;
    internal static string sortableDateTimePattern;
    internal static string universalSortableDateTimePattern;
    internal static DateTimeStyles InvalidDateTimeStyles;
    internal static string IgnorablePeriod;
    internal static string IgnorableComma;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal static string LocalTimeMark;
    internal static string KoreanLangName;
    internal static string JapaneseLangName;
    internal static string EnglishLangName;
    [OptionalFieldAttribute]
internal string m_name;
    internal string amDesignator;
    internal string pmDesignator;
    [OptionalFieldAttribute]
internal string dateSeparator;
    [OptionalFieldAttribute]
internal string generalShortTimePattern;
    [OptionalFieldAttribute]
internal string generalLongTimePattern;
    [OptionalFieldAttribute]
internal string timeSeparator;
    internal string monthDayPattern;
    [OptionalFieldAttribute]
internal string dateTimeOffsetPattern;
    internal Calendar calendar;
    internal int firstDayOfWeek;
    internal int calendarWeekRule;
    [OptionalFieldAttribute]
internal string fullDateTimePattern;
    internal String[] abbreviatedDayNames;
    [OptionalFieldAttribute]
internal String[] m_superShortDayNames;
    internal String[] dayNames;
    internal String[] abbreviatedMonthNames;
    internal String[] monthNames;
    [OptionalFieldAttribute]
internal String[] genitiveMonthNames;
    [OptionalFieldAttribute]
internal String[] m_genitiveAbbreviatedMonthNames;
    [OptionalFieldAttribute]
internal String[] leapYearMonthNames;
    internal string longDatePattern;
    internal string shortDatePattern;
    internal string yearMonthPattern;
    internal string longTimePattern;
    internal string shortTimePattern;
    internal String[] allShortDatePatterns;
    internal String[] allLongDatePatterns;
    internal String[] allShortTimePatterns;
    internal String[] allLongTimePatterns;
    internal String[] m_eraNames;
    internal String[] m_abbrevEraNames;
    internal String[] m_abbrevEnglishEraNames;
    internal Int32[] optionalCalendars;
    internal bool m_isReadOnly;
    [OptionalFieldAttribute]
internal DateTimeFormatFlags formatFlags;
    [OptionalFieldAttribute]
internal bool m_isDefaultCalendar;
    [OptionalFieldAttribute]
internal String[] m_dateWords;
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    [ComVisibleAttribute("False")]
public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    public bool IsReadOnly { get; }
    [ComVisibleAttribute("False")]
public string NativeCalendarName { get; }
    [ComVisibleAttribute("False")]
public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    [ComVisibleAttribute("False")]
public String[] MonthGenitiveNames { get; public set; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    internal String[] internalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    [ComVisibleAttribute("False")]
public string GetShortestDayName(DayOfWeek dayOfWeek);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    [ComVisibleAttribute("False")]
public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    [SecurityCriticalAttribute]
internal TokenHashValue[] CreateTokenHashTable();
    [SecurityCriticalAttribute]
internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal static char MonthPostfixChar;
    internal static char IgnorableSymbolChar;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal List`1<string> m_dateWords;
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
[ComVisibleAttribute("True")]
public class System.Globalization.DaylightTime : object {
    internal DateTime m_start;
    internal DateTime m_end;
    internal TimeSpan m_delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[ComVisibleAttribute("True")]
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
[ComVisibleAttribute("True")]
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    internal static int LeapMonth;
    internal static int Jan1Month;
    internal static int Jan1Date;
    internal static int nDaysPerMonth;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate);
    internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay);
    internal DateTime LunarToTime(DateTime time, int year, int month, int day);
    internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.EncodingTable : object {
    [SecurityCriticalAttribute]
internal static InternalEncodingDataItem* encodingDataPtr;
    [SecurityCriticalAttribute]
internal static InternalCodePageDataItem* codePageDataPtr;
    [SecuritySafeCriticalAttribute]
private static EncodingTable();
    [SecuritySafeCriticalAttribute]
internal static EncodingInfo[] GetEncodings();
    internal static int GetCodePageFromName(string name);
    [SecuritySafeCriticalAttribute]
internal static CodePageDataItem GetCodePageDataItem(int codepage);
    [SecurityCriticalAttribute]
internal static Byte* nativeCreateOpenFileMapping(string inSectionName, int inBytesToAllocate, IntPtr& mappedFileHandle);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    [OptionalFieldAttribute]
internal string eraName;
    [OptionalFieldAttribute]
internal string abbrevEraName;
    [OptionalFieldAttribute]
internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
internal class System.Globalization.GlobalizationAssembly : object {
    [SecurityCriticalAttribute]
internal static Byte* GetGlobalizationResourceBytePtr(Assembly assembly, string tableName);
}
[ComVisibleAttribute("True")]
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxYear;
    internal GregorianCalendarTypes m_type;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual int get_ID();
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    [OptionalFieldAttribute]
internal int m_maxYear;
    [OptionalFieldAttribute]
internal int m_minYear;
    internal Calendar m_Cal;
    [OptionalFieldAttribute]
internal EraInfo[] m_EraInfo;
    [OptionalFieldAttribute]
internal Int32[] m_eras;
    [OptionalFieldAttribute]
internal DateTime m_minDate;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
[ComVisibleAttribute("True")]
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
[ComVisibleAttribute("True")]
public class System.Globalization.HebrewCalendar : Calendar {
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int DatePartDayOfWeek;
    public static int HebrewEra;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    internal static void CheckEraRange(int era);
    internal static int GetResult(__DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.HebrewNumber : object {
    private static HebrewNumber();
    internal static string ToString(int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
[ComVisibleAttribute("True")]
public class System.Globalization.HijriCalendar : Calendar {
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MinAdvancedHijri;
    internal static int MaxAdvancedHijri;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    public static int HijriEra;
    internal static Int32[] HijriMonthDays;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    [SecuritySafeCriticalAttribute]
public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.IdnMapping : object {
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private static IdnMapping();
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Globalization.InternalCodePageDataItem : ValueType {
    internal ushort codePage;
    internal ushort uiFamilyCodePage;
    internal UInt32 flags;
    [SecurityCriticalAttribute]
internal SByte* Names;
}
internal class System.Globalization.InternalEncodingDataItem : ValueType {
    [SecurityCriticalAttribute]
internal SByte* webName;
    internal ushort codePage;
}
[ComVisibleAttribute("True")]
public class System.Globalization.JapaneseCalendar : Calendar {
    internal static DateTime calendarMinValue;
    internal static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal GregorianCalendarHelper helper;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[ComVisibleAttribute("True")]
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    internal int MaxYear;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[ComVisibleAttribute("True")]
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    internal static EraInfo[] koreanEraInfo;
    internal GregorianCalendarHelper helper;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
[ComVisibleAttribute("True")]
public class System.Globalization.NumberFormatInfo : object {
    internal Int32[] numberGroupSizes;
    internal Int32[] currencyGroupSizes;
    internal Int32[] percentGroupSizes;
    internal string positiveSign;
    internal string negativeSign;
    internal string numberDecimalSeparator;
    internal string numberGroupSeparator;
    internal string currencyGroupSeparator;
    internal string currencyDecimalSeparator;
    internal string currencySymbol;
    internal string ansiCurrencySymbol;
    internal string nanSymbol;
    internal string positiveInfinitySymbol;
    internal string negativeInfinitySymbol;
    internal string percentDecimalSeparator;
    internal string percentGroupSeparator;
    internal string percentSymbol;
    internal string perMilleSymbol;
    [OptionalFieldAttribute]
internal String[] nativeDigits;
    [OptionalFieldAttribute]
internal int m_dataItem;
    internal int numberDecimalDigits;
    internal int currencyDecimalDigits;
    internal int currencyPositivePattern;
    internal int currencyNegativePattern;
    internal int numberNegativePattern;
    internal int percentPositivePattern;
    internal int percentNegativePattern;
    internal int percentDecimalDigits;
    [OptionalFieldAttribute]
internal int digitSubstitution;
    internal bool isReadOnly;
    [OptionalFieldAttribute]
internal bool m_useUserOverride;
    [OptionalFieldAttribute]
internal bool m_isInvariant;
    [OptionalFieldAttribute]
internal bool validForParseAsNumber;
    [OptionalFieldAttribute]
internal bool validForParseAsCurrency;
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    [ComVisibleAttribute("False")]
public String[] NativeDigits { get; public set; }
    [ComVisibleAttribute("False")]
public DigitShapes DigitSubstitution { get; public set; }
    [SecuritySafeCriticalAttribute]
internal NumberFormatInfo(CultureData cultureData);
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
public class System.Globalization.PersianCalendar : Calendar {
    internal static int DateCycle;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int LeapYearsPerCycle;
    internal static long GregorianOffset;
    internal static long DaysPerCycle;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    public static int PersianEra;
    internal static Int32[] DaysToMonth;
    internal static Int32[] LeapYears33;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[ComVisibleAttribute("True")]
public class System.Globalization.RegionInfo : object {
    internal string m_name;
    internal CultureData m_cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    [OptionalFieldAttribute]
internal int m_dataItem;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    [ComVisibleAttribute("False")]
public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    [ComVisibleAttribute("False")]
public int GeoId { get; }
    [ComVisibleAttribute("False")]
public string CurrencyEnglishName { get; }
    [ComVisibleAttribute("False")]
public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    [SecuritySafeCriticalAttribute]
public RegionInfo(string name);
    [SecuritySafeCriticalAttribute]
public RegionInfo(int culture);
    [SecuritySafeCriticalAttribute]
internal RegionInfo(CultureData cultureData);
    private static RegionInfo();
    [SecuritySafeCriticalAttribute]
public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public virtual string get_EnglishName();
    [SecuritySafeCriticalAttribute]
public virtual string get_DisplayName();
    [SecuritySafeCriticalAttribute]
public virtual string get_NativeName();
    [SecuritySafeCriticalAttribute]
public virtual string get_TwoLetterISORegionName();
    [SecuritySafeCriticalAttribute]
public virtual string get_ThreeLetterISORegionName();
    [SecuritySafeCriticalAttribute]
public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    [SecuritySafeCriticalAttribute]
public virtual string get_CurrencyEnglishName();
    [SecuritySafeCriticalAttribute]
public virtual string get_CurrencyNativeName();
    [SecuritySafeCriticalAttribute]
public virtual string get_CurrencySymbol();
    [SecuritySafeCriticalAttribute]
public virtual string get_ISOCurrencySymbol();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Globalization.SortKey : object {
    [OptionalFieldAttribute]
internal string localeName;
    [OptionalFieldAttribute]
internal int win32LCID;
    internal CompareOptions options;
    internal string m_String;
    internal Byte[] m_KeyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortVersion : object {
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
[ComVisibleAttribute("True")]
public class System.Globalization.StringInfo : object {
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object value);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
[ComVisibleAttribute("True")]
public class System.Globalization.TaiwanCalendar : Calendar {
    internal static EraInfo[] taiwanEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    internal static DateTime calendarMinValue;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static EraInfo[] taiwanLunisolarEraInfo;
    internal GregorianCalendarHelper helper;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[ComVisibleAttribute("True")]
public class System.Globalization.TextElementEnumerator : object {
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
public class System.Globalization.TextInfo : object {
    internal static TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    [OptionalFieldAttribute]
internal int m_nDataItem;
    [OptionalFieldAttribute]
internal bool m_useUserOverride;
    [OptionalFieldAttribute]
internal int m_win32LangID;
    internal static TextInfo Invariant { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    [ComVisibleAttribute("False")]
public int LCID { get; }
    [ComVisibleAttribute("False")]
public string CultureName { get; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    [ComVisibleAttribute("False")]
public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    internal static TextInfo get_Invariant();
    internal static int GetHashCodeOrdinalIgnoreCase(string s);
    internal static int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy);
    [SecuritySafeCriticalAttribute]
internal static bool TryFastFindStringOrdinalIgnoreCase(int searchFlags, string source, int startIndex, string value, int count, Int32& foundIndex);
    [SecuritySafeCriticalAttribute]
internal static int CompareOrdinalIgnoreCase(string str1, string str2);
    [SecuritySafeCriticalAttribute]
internal static int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB);
    internal static int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    internal static int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    [ComVisibleAttribute("False")]
public virtual object Clone();
    [ComVisibleAttribute("False")]
public static TextInfo ReadOnly(TextInfo textInfo);
    internal void SetReadOnlyState(bool readOnly);
    [SecuritySafeCriticalAttribute]
public virtual string get_ListSeparator();
    [ComVisibleAttribute("False")]
public virtual void set_ListSeparator(string value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public virtual char ToLower(char c);
    [SecuritySafeCriticalAttribute]
public virtual string ToLower(string str);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public virtual char ToUpper(char c);
    [SecuritySafeCriticalAttribute]
public virtual string ToUpper(string str);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsRightToLeft();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecuritySafeCriticalAttribute]
internal int GetCaseInsensitiveHashCode(string str);
    [SecuritySafeCriticalAttribute]
internal int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy);
}
[ComVisibleAttribute("True")]
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    public static int ThaiBuddhistEra;
    internal static EraInfo[] thaiBuddhistEraInfo;
    internal GregorianCalendarHelper helper;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static string FormatCustomized(TimeSpan value, string format, DateTimeFormatInfo dtfi);
}
internal static class System.Globalization.TimeSpanParse : object {
    internal static int unlimitedDigits;
    internal static int maxFractionDigits;
    internal static int maxDays;
    internal static int maxHours;
    internal static int maxMinutes;
    internal static int maxSeconds;
    internal static int maxFraction;
    private static TimeSpanParse();
    internal static void ValidateStyles(TimeSpanStyles style, string parameterName);
    internal static TimeSpan Parse(string input, IFormatProvider formatProvider);
    internal static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
internal class System.Globalization.TokenHashValue : object {
    internal string tokenString;
    internal TokenType tokenType;
    internal int tokenValue;
    internal TokenHashValue(string tokenString, TokenType tokenType, int tokenValue);
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    internal static int MinCalendarYear;
    internal static int MaxCalendarYear;
    public static int UmAlQuraEra;
    internal static int DateCycle;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[ComVisibleAttribute("True")]
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[ComVisibleAttribute("True")]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    public Guid(Byte[] b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(string g);
    private static Guid();
    public static Guid Parse(string input);
    public static bool TryParse(string input, Guid& result);
    public static Guid ParseExact(string input, string format);
    public static bool TryParseExact(string input, string format, Guid& result);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    [SecuritySafeCriticalAttribute]
public static Guid NewGuid();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("27FFF232-A7A8-40dd-8D4A-734AD59FCD41")]
public interface System.IAppDomainSetup {
    public string ApplicationBase { get; public set; }
    public string ApplicationName { get; public set; }
    public string CachePath { get; public set; }
    public string ConfigurationFile { get; public set; }
    public string DynamicBase { get; public set; }
    public string LicenseFile { get; public set; }
    public string PrivateBinPath { get; public set; }
    public string PrivateBinPathProbe { get; public set; }
    public string ShadowCopyDirectories { get; public set; }
    public string ShadowCopyFiles { get; public set; }
    public abstract virtual string get_ApplicationBase();
    public abstract virtual void set_ApplicationBase(string value);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_CachePath();
    public abstract virtual void set_CachePath(string value);
    public abstract virtual string get_ConfigurationFile();
    public abstract virtual void set_ConfigurationFile(string value);
    public abstract virtual string get_DynamicBase();
    public abstract virtual void set_DynamicBase(string value);
    public abstract virtual string get_LicenseFile();
    public abstract virtual void set_LicenseFile(string value);
    public abstract virtual string get_PrivateBinPath();
    public abstract virtual void set_PrivateBinPath(string value);
    public abstract virtual string get_PrivateBinPathProbe();
    public abstract virtual void set_PrivateBinPathProbe(string value);
    public abstract virtual string get_ShadowCopyDirectories();
    public abstract virtual void set_ShadowCopyDirectories(string value);
    public abstract virtual string get_ShadowCopyFiles();
    public abstract virtual void set_ShadowCopyFiles(string value);
}
[ComVisibleAttribute("True")]
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
[ComVisibleAttribute("True")]
public interface System.ICloneable {
    public abstract virtual object Clone();
}
[ComVisibleAttribute("True")]
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
[ComVisibleAttribute("True")]
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
[ComVisibleAttribute("True")]
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
[ComVisibleAttribute("True")]
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[ComVisibleAttribute("True")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
}
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
}
[ComVisibleAttribute("True")]
public class System.Int16 : ValueType {
    public static short MaxValue;
    public static short MinValue;
    internal short m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, IFormatProvider provider);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public class System.Int32 : ValueType {
    public static int MaxValue;
    public static int MinValue;
    internal int m_value;
    public sealed virtual int CompareTo(object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int CompareTo(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool Equals(int obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Parse(string s, IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32& result);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ComVisibleAttribute("True")]
public class System.Int64 : ValueType {
    public static long MaxValue;
    public static long MinValue;
    internal long m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, IFormatProvider provider);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal static class System.Internal : object {
}
internal enum System.InternalGCCollectionMode : Enum {
    public int value__;
    public static InternalGCCollectionMode NonBlocking;
    public static InternalGCCollectionMode Blocking;
    public static InternalGCCollectionMode Optimized;
}
[ComVisibleAttribute("True")]
public class System.IntPtr : ValueType {
    [SecurityCriticalAttribute]
private Void* m_value;
    public static IntPtr Zero;
    public static int Size { get; }
    [ReliabilityContractAttribute("2", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public IntPtr(int value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("2", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public IntPtr(long value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("2", "1")]
public IntPtr(Void* value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal bool IsNull();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public int ToInt32();
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public long ToInt64();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [ReliabilityContractAttribute("2", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static IntPtr op_Explicit(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Explicit(long value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Explicit(Void* value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public static Void* op_Explicit(IntPtr value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public static int op_Explicit(IntPtr value);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long op_Explicit(IntPtr value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("2", "1")]
public static IntPtr Add(IntPtr pointer, int offset);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("2", "1")]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("2", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Void* ToPointer();
}
[ComVisibleAttribute("True")]
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
    public InvalidCastException(string message, int errorCode);
}
[ComVisibleAttribute("True")]
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.__ConsoleStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [SecurityCriticalAttribute]
internal __ConsoleStream(SafeFileHandle handle, FileAccess access, bool useFileAPIs);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual void Flush();
    public virtual void SetLength(long value);
    [SecuritySafeCriticalAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    [SecuritySafeCriticalAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
}
internal static class System.IO.__Error : object {
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_PARAMETER;
    internal static void EndOfFile();
    internal static void FileNotOpen();
    internal static void StreamIsClosed();
    internal static void MemoryStreamNotExpandable();
    internal static void ReaderClosed();
    internal static void ReadNotSupported();
    internal static void SeekNotSupported();
    internal static void WrongAsyncResult();
    internal static void EndReadCalledTwice();
    internal static void EndWriteCalledTwice();
    [SecurityCriticalAttribute]
internal static string GetDisplayablePath(string path, bool isInvalidPath);
    [SecuritySafeCriticalAttribute]
internal static void WinIOError();
    [SecurityCriticalAttribute]
internal static void WinIOError(int errorCode, string maybeFullPath);
    [SecuritySafeCriticalAttribute]
internal static void WinIODriveError(string driveName);
    [SecurityCriticalAttribute]
internal static void WinIODriveError(string driveName, int errorCode);
    internal static void WriteNotSupported();
    internal static void WriterClosed();
}
internal static class System.IO.__HResults : object {
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_PATHTOOLONG;
    public static int COR_E_IO;
}
[ComVisibleAttribute("True")]
public class System.IO.BinaryReader : object {
    public Stream BaseStream { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    private static BinaryReader();
    public virtual Stream get_BaseStream();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual int PeekChar();
    public virtual int Read();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    [CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual sbyte ReadSByte();
    public virtual char ReadChar();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    [SecuritySafeCriticalAttribute]
public virtual float ReadSingle();
    [SecuritySafeCriticalAttribute]
public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    [SecuritySafeCriticalAttribute]
public virtual int Read(Char[] buffer, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual Byte[] ReadBytes(int count);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
[ComVisibleAttribute("True")]
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    public Stream BaseStream { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    [SecuritySafeCriticalAttribute]
public virtual void Write(float value);
    [SecuritySafeCriticalAttribute]
public virtual void Write(string value);
    protected void Write7BitEncodedInt(int value);
}
[ComVisibleAttribute("True")]
public class System.IO.BufferedStream : Stream {
    internal Stream UnderlyingStream { get; }
    internal int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    [FriendAccessAllowedAttribute]
internal Stream get_UnderlyingStream();
    [FriendAccessAllowedAttribute]
internal int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
[ComVisibleAttribute("True")]
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    [SecuritySafeCriticalAttribute]
public static DirectoryInfo CreateDirectory(string path);
    [SecurityCriticalAttribute]
internal static DirectoryInfo UnsafeCreateDirectory(string path);
    [SecurityCriticalAttribute]
internal static DirectoryInfo InternalCreateDirectoryHelper(string path, bool checkHost);
    [SecuritySafeCriticalAttribute]
public static DirectoryInfo CreateDirectory(string path, DirectorySecurity directorySecurity);
    internal static string GetDemandDir(string fullPath, bool thisDirOnly);
    internal static void InternalCreateDirectory(string fullPath, string path, object dirSecurityObj);
    [SecuritySafeCriticalAttribute]
internal static void InternalCreateDirectory(string fullPath, string path, object dirSecurityObj, bool checkHost);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string path);
    [SecurityCriticalAttribute]
internal static bool UnsafeExists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExistsHelper(string path, bool checkHost);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path, Int32& lastError);
    public static void SetCreationTime(string path, DateTime creationTime);
    [SecuritySafeCriticalAttribute]
public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    [SecuritySafeCriticalAttribute]
public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    [SecuritySafeCriticalAttribute]
public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DirectorySecurity GetAccessControl(string path);
    public static DirectorySecurity GetAccessControl(string path, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
public static void SetAccessControl(string path, DirectorySecurity directorySecurity);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    [SecurityCriticalAttribute]
internal static String[] UnsafeGetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    [SecurityCriticalAttribute]
internal static String[] UnsafeGetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    internal static String[] InternalGetFileDirectoryNames(string path, string userPathOriginal, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    [SecuritySafeCriticalAttribute]
public static String[] GetLogicalDrives();
    [SecuritySafeCriticalAttribute]
public static string GetDirectoryRoot(string path);
    internal static string InternalGetDirectoryRoot(string path);
    [SecuritySafeCriticalAttribute]
public static string GetCurrentDirectory();
    [SecurityCriticalAttribute]
internal static string UnsafeGetCurrentDirectory();
    [SecuritySafeCriticalAttribute]
public static void SetCurrentDirectory(string path);
    [SecuritySafeCriticalAttribute]
public static void Move(string sourceDirName, string destDirName);
    [SecurityCriticalAttribute]
internal static void UnsafeMove(string sourceDirName, string destDirName);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path, bool recursive);
    [SecurityCriticalAttribute]
internal static void UnsafeDelete(string path, bool recursive);
    [SecurityCriticalAttribute]
internal static void Delete(string fullPath, string userPath, bool recursive, bool checkHost);
}
[ComVisibleAttribute("True")]
public class System.IO.DirectoryInfo : FileSystemInfo {
    public string Name { get; }
    public DirectoryInfo Parent { get; }
    public bool Exists { get; }
    public DirectoryInfo Root { get; }
    [SecuritySafeCriticalAttribute]
public DirectoryInfo(string path);
    internal DirectoryInfo(string fullPath, bool junk);
    public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    [SecuritySafeCriticalAttribute]
public DirectoryInfo CreateSubdirectory(string path, DirectorySecurity directorySecurity);
    public void Create();
    public void Create(DirectorySecurity directorySecurity);
    [SecuritySafeCriticalAttribute]
public virtual bool get_Exists();
    public DirectorySecurity GetAccessControl();
    public DirectorySecurity GetAccessControl(AccessControlSections includeSections);
    public void SetAccessControl(DirectorySecurity directorySecurity);
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles();
    public DirectoryInfo[] GetDirectories();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    [SecuritySafeCriticalAttribute]
public DirectoryInfo get_Root();
    [SecuritySafeCriticalAttribute]
public void MoveTo(string destDirName);
    [SecuritySafeCriticalAttribute]
public virtual void Delete();
    [SecuritySafeCriticalAttribute]
public void Delete(bool recursive);
    public virtual string ToString();
}
internal class System.IO.DirectoryInfoResultHandler : SearchResultHandler`1<DirectoryInfo> {
    [SecurityCriticalAttribute]
internal virtual bool IsResultIncluded(SearchResult result);
    [SecurityCriticalAttribute]
internal virtual DirectoryInfo CreateObject(SearchResult result);
}
[ComVisibleAttribute("True")]
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.IO.DriveInfo : object {
    public string Name { get; }
    public DriveType DriveType { get; }
    public string DriveFormat { get; }
    public bool IsReady { get; }
    public long AvailableFreeSpace { get; }
    public long TotalFreeSpace { get; }
    public long TotalSize { get; }
    public DirectoryInfo RootDirectory { get; }
    public string VolumeLabel { get; public set; }
    [SecuritySafeCriticalAttribute]
public DriveInfo(string driveName);
    public string get_Name();
    [SecuritySafeCriticalAttribute]
public DriveType get_DriveType();
    [SecuritySafeCriticalAttribute]
public string get_DriveFormat();
    [SecuritySafeCriticalAttribute]
public bool get_IsReady();
    [SecuritySafeCriticalAttribute]
public long get_AvailableFreeSpace();
    [SecuritySafeCriticalAttribute]
public long get_TotalFreeSpace();
    [SecuritySafeCriticalAttribute]
public long get_TotalSize();
    public static DriveInfo[] GetDrives();
    public DirectoryInfo get_RootDirectory();
    [SecuritySafeCriticalAttribute]
public string get_VolumeLabel();
    [SecuritySafeCriticalAttribute]
public void set_VolumeLabel(string value);
    public virtual string ToString();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.IO.DriveNotFoundException : IOException {
    public DriveNotFoundException(string message);
    public DriveNotFoundException(string message, Exception innerException);
    protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public enum System.IO.DriveType : Enum {
    public int value__;
    public static DriveType Unknown;
    public static DriveType NoRootDirectory;
    public static DriveType Removable;
    public static DriveType Fixed;
    public static DriveType Network;
    public static DriveType CDRom;
    public static DriveType Ram;
}
[ComVisibleAttribute("True")]
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public static class System.IO.File : object {
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    [SecurityCriticalAttribute]
internal static void UnsafeCopy(string sourceFileName, string destFileName, bool overwrite);
    [SecuritySafeCriticalAttribute]
internal static string InternalCopy(string sourceFileName, string destFileName, bool overwrite, bool checkHost);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static FileStream Create(string path, int bufferSize, FileOptions options, FileSecurity fileSecurity);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path);
    [SecurityCriticalAttribute]
internal static void UnsafeDelete(string path);
    [SecurityCriticalAttribute]
internal static void InternalDelete(string path, bool checkHost);
    [SecuritySafeCriticalAttribute]
public static void Decrypt(string path);
    [SecuritySafeCriticalAttribute]
public static void Encrypt(string path);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string path);
    [SecurityCriticalAttribute]
internal static bool UnsafeExists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    public static void SetCreationTime(string path, DateTime creationTime);
    [SecuritySafeCriticalAttribute]
public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    [SecuritySafeCriticalAttribute]
public static DateTime GetCreationTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    [SecuritySafeCriticalAttribute]
public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastAccessTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    [SecuritySafeCriticalAttribute]
public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastWriteTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastWriteTimeUtc(string path);
    [SecuritySafeCriticalAttribute]
public static FileAttributes GetAttributes(string path);
    [SecuritySafeCriticalAttribute]
public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileSecurity GetAccessControl(string path);
    public static FileSecurity GetAccessControl(string path, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
public static void SetAccessControl(string path, FileSecurity fileSecurity);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    [SecuritySafeCriticalAttribute]
public static string ReadAllText(string path);
    [SecuritySafeCriticalAttribute]
public static string ReadAllText(string path, Encoding encoding);
    [SecurityCriticalAttribute]
internal static string UnsafeReadAllText(string path);
    [SecuritySafeCriticalAttribute]
public static void WriteAllText(string path, string contents);
    [SecuritySafeCriticalAttribute]
public static void WriteAllText(string path, string contents, Encoding encoding);
    [SecurityCriticalAttribute]
internal static void UnsafeWriteAllText(string path, string contents);
    [SecuritySafeCriticalAttribute]
public static Byte[] ReadAllBytes(string path);
    [SecurityCriticalAttribute]
internal static Byte[] UnsafeReadAllBytes(string path);
    [SecuritySafeCriticalAttribute]
public static void WriteAllBytes(string path, Byte[] bytes);
    [SecurityCriticalAttribute]
internal static void UnsafeWriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    [SecuritySafeCriticalAttribute]
public static void Move(string sourceFileName, string destFileName);
    [SecurityCriticalAttribute]
internal static void UnsafeMove(string sourceFileName, string destFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    [SecurityCriticalAttribute]
internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool tryagain, bool returnErrorOnNotFound);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes ReadOnly;
    public static FileAttributes Hidden;
    public static FileAttributes System;
    public static FileAttributes Directory;
    public static FileAttributes Archive;
    public static FileAttributes Device;
    public static FileAttributes Normal;
    public static FileAttributes Temporary;
    public static FileAttributes SparseFile;
    public static FileAttributes ReparsePoint;
    public static FileAttributes Compressed;
    public static FileAttributes Offline;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Encrypted;
    [ComVisibleAttribute("False")]
public static FileAttributes IntegrityStream;
    [ComVisibleAttribute("False")]
public static FileAttributes NoScrubData;
}
[ComVisibleAttribute("True")]
public class System.IO.FileInfo : FileSystemInfo {
    public string Name { get; }
    public long Length { get; }
    public string DirectoryName { get; }
    public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public bool Exists { get; }
    [SecuritySafeCriticalAttribute]
public FileInfo(string fileName);
    internal FileInfo(string fullPath, bool ignoreThis);
    public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public long get_Length();
    [SecuritySafeCriticalAttribute]
public string get_DirectoryName();
    public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public FileSecurity GetAccessControl();
    public FileSecurity GetAccessControl(AccessControlSections includeSections);
    public void SetAccessControl(FileSecurity fileSecurity);
    [SecuritySafeCriticalAttribute]
public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    [SecuritySafeCriticalAttribute]
public virtual void Delete();
    [ComVisibleAttribute("False")]
public void Decrypt();
    [ComVisibleAttribute("False")]
public void Encrypt();
    [SecuritySafeCriticalAttribute]
public virtual bool get_Exists();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    [SecuritySafeCriticalAttribute]
public void MoveTo(string destFileName);
    [ComVisibleAttribute("False")]
public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    [ComVisibleAttribute("False")]
public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public virtual string ToString();
}
internal class System.IO.FileInfoResultHandler : SearchResultHandler`1<FileInfo> {
    [SecurityCriticalAttribute]
internal virtual bool IsResultIncluded(SearchResult result);
    [SecurityCriticalAttribute]
internal virtual FileInfo CreateObject(SearchResult result);
}
[ComVisibleAttribute("True")]
public class System.IO.FileLoadException : IOException {
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_FileName();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string get_FusionLog();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
}
[ComVisibleAttribute("True")]
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[ComVisibleAttribute("True")]
public class System.IO.FileNotFoundException : IOException {
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_FileName();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string get_FusionLog();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
[ComVisibleAttribute("True")]
public class System.IO.FileStream : Stream {
    internal static int DefaultBufferSize;
    internal static int GENERIC_READ;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_NO_DATA;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public string Name { get; }
    internal string NameInternal { get; }
    public long Position { get; public set; }
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public SafeFileHandle SafeFileHandle { get; }
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileAccess access);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity);
    [SecuritySafeCriticalAttribute]
public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options);
    [SecurityCriticalAttribute]
internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy);
    [SecurityCriticalAttribute]
internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy, bool useLongPath);
    [SecurityCriticalAttribute]
internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy, bool useLongPath, bool checkHost);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    [SecuritySafeCriticalAttribute]
public FileStream(SafeFileHandle handle, FileAccess access);
    [SecuritySafeCriticalAttribute]
public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    [SecuritySafeCriticalAttribute]
public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    private static FileStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_IsAsync();
    [SecuritySafeCriticalAttribute]
public virtual long get_Length();
    [SecuritySafeCriticalAttribute]
public string get_Name();
    internal string get_NameInternal();
    [SecuritySafeCriticalAttribute]
public virtual long get_Position();
    public virtual void set_Position(long value);
    [SecuritySafeCriticalAttribute]
public FileSecurity GetAccessControl();
    [SecuritySafeCriticalAttribute]
public void SetAccessControl(FileSecurity fileSecurity);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    public virtual void Flush();
    [SecuritySafeCriticalAttribute]
public virtual void Flush(bool flushToDisk);
    [SecurityCriticalAttribute]
public virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
public virtual SafeFileHandle get_SafeFileHandle();
    [SecuritySafeCriticalAttribute]
public virtual void SetLength(long value);
    [SecuritySafeCriticalAttribute]
public virtual int Read(Byte[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    [SecuritySafeCriticalAttribute]
public virtual void Write(Byte[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    [SecuritySafeCriticalAttribute]
public virtual int EndRead(IAsyncResult asyncResult);
    [SecuritySafeCriticalAttribute]
public virtual int ReadByte();
    [SecuritySafeCriticalAttribute]
public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    [SecuritySafeCriticalAttribute]
public virtual void EndWrite(IAsyncResult asyncResult);
    [SecuritySafeCriticalAttribute]
public virtual void WriteByte(byte value);
    [SecuritySafeCriticalAttribute]
public virtual void Lock(long position, long length);
    [SecuritySafeCriticalAttribute]
public virtual void Unlock(long position, long length);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
}
internal class System.IO.FileStreamAsyncResult : object {
    internal int _EndXxxCalled;
    internal NativeOverlapped* OverLapped { get; }
    internal bool IsAsync { get; }
    internal int NumBytes { get; }
    internal int ErrorCode { get; }
    internal int NumBufferedBytes { get; }
    internal int NumBytesRead { get; }
    internal bool IsWrite { get; }
    public object AsyncState { get; }
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    [SecuritySafeCriticalAttribute]
internal FileStreamAsyncResult(int numBufferedBytes, Byte[] bytes, SafeFileHandle handle, AsyncCallback userCallback, object userStateObject, bool isWrite);
    [SecurityCriticalAttribute]
internal NativeOverlapped* get_OverLapped();
    [SecuritySafeCriticalAttribute]
internal bool get_IsAsync();
    internal int get_NumBytes();
    internal int get_ErrorCode();
    internal int get_NumBufferedBytes();
    internal int get_NumBytesRead();
    internal bool get_IsWrite();
    internal static FileStreamAsyncResult CreateBufferedReadResult(int numBufferedBytes, AsyncCallback userCallback, object userStateObject, bool isWrite);
    public sealed virtual object get_AsyncState();
    public sealed virtual bool get_IsCompleted();
    [SecuritySafeCriticalAttribute]
public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    internal void CallUserCallback();
    [SecurityCriticalAttribute]
internal void ReleaseNativeResource();
    internal void Wait();
    [SecuritySafeCriticalAttribute]
internal void Cancel();
}
internal static class System.IO.FileSystemEnumerableFactory : object {
    internal static IEnumerable`1<string> CreateFileNameIterator(string path, string originalUserPath, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost);
    internal static IEnumerable`1<FileInfo> CreateFileInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
    internal static IEnumerable`1<DirectoryInfo> CreateDirectoryInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
    internal static IEnumerable`1<FileSystemInfo> CreateFileSystemInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
}
internal static class System.IO.FileSystemEnumerableHelpers : object {
    [SecurityCriticalAttribute]
internal static bool IsDir(WIN32_FIND_DATA data);
    [SecurityCriticalAttribute]
internal static bool IsFile(WIN32_FIND_DATA data);
}
internal class System.IO.FileSystemEnumerableIterator`1 : Iterator`1<TSource> {
    [SecuritySafeCriticalAttribute]
internal FileSystemEnumerableIterator`1(string path, string originalUserPath, string searchPattern, SearchOption searchOption, SearchResultHandler`1<TSource> resultHandler, bool checkHost);
    protected virtual Iterator`1<TSource> Clone();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual bool MoveNext();
    [SecurityCriticalAttribute]
internal void DoDemand(string fullPathToDemand);
}
[ComVisibleAttribute("True")]
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    internal static int ERROR_ACCESS_DENIED;
    [SecurityCriticalAttribute]
internal WIN32_FILE_ATTRIBUTE_DATA _data;
    internal int _dataInitialised;
    protected string FullPath;
    protected string OriginalPath;
    public string FullName { get; }
    internal string UnsafeGetFullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    [ComVisibleAttribute("False")]
public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    [ComVisibleAttribute("False")]
public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    [ComVisibleAttribute("False")]
public DateTime LastWriteTimeUtc { get; public set; }
    public FileAttributes Attributes { get; public set; }
    internal string DisplayPath { get; internal set; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal void InitializeFrom(WIN32_FIND_DATA findData);
    [SecuritySafeCriticalAttribute]
public virtual string get_FullName();
    [SecurityCriticalAttribute]
internal virtual string get_UnsafeGetFullName();
    public string get_Extension();
    public abstract virtual string get_Name();
    public abstract virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    [SecuritySafeCriticalAttribute]
public void Refresh();
    [SecuritySafeCriticalAttribute]
public FileAttributes get_Attributes();
    [SecuritySafeCriticalAttribute]
public void set_Attributes(FileAttributes value);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string get_DisplayPath();
    internal void set_DisplayPath(string value);
}
internal class System.IO.FileSystemInfoResultHandler : SearchResultHandler`1<FileSystemInfo> {
    [SecurityCriticalAttribute]
internal virtual bool IsResultIncluded(SearchResult result);
    [SecurityCriticalAttribute]
internal virtual FileSystemInfo CreateObject(SearchResult result);
}
[ComVisibleAttribute("True")]
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    internal IOException(string message, int hresult, string maybeFullPath);
    public IOException(string message, Exception innerException);
    protected IOException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.IsolatedStorage.__HResults : object {
    public static int COR_E_ISOSTORE;
}
[ComVisibleAttribute("True")]
public interface System.IO.IsolatedStorage.INormalizeForIsolatedStorage {
    public abstract virtual object Normalize();
}
[ComVisibleAttribute("True")]
public abstract class System.IO.IsolatedStorage.IsolatedStorage : MarshalByRefObject {
    internal static IsolatedStorageScope c_Assembly;
    internal static IsolatedStorageScope c_Domain;
    internal static IsolatedStorageScope c_AssemblyRoaming;
    internal static IsolatedStorageScope c_DomainRoaming;
    internal static IsolatedStorageScope c_MachineAssembly;
    internal static IsolatedStorageScope c_MachineDomain;
    internal static IsolatedStorageScope c_AppUser;
    internal static IsolatedStorageScope c_AppMachine;
    internal static IsolatedStorageScope c_AppUserRoaming;
    protected char SeparatorExternal { get; }
    protected char SeparatorInternal { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorage.MaximumSize has been deprecated because it is not CLS Compliant.  To get the maximum size use IsolatedStorage.Quota")]
public ulong MaximumSize { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorage.CurrentSize has been deprecated because it is not CLS Compliant.  To get the current size use IsolatedStorage.UsedSize")]
public ulong CurrentSize { get; }
    [ComVisibleAttribute("False")]
public long UsedSize { get; }
    [ComVisibleAttribute("False")]
public long Quota { get; internal set; }
    [ComVisibleAttribute("False")]
public long AvailableFreeSpace { get; }
    public object DomainIdentity { get; }
    [ComVisibleAttribute("False")]
public object ApplicationIdentity { get; }
    public object AssemblyIdentity { get; }
    public IsolatedStorageScope Scope { get; }
    internal string DomainName { get; }
    internal string AssemName { get; }
    internal string AppName { get; }
    internal static bool IsRoaming(IsolatedStorageScope scope);
    internal bool IsRoaming();
    internal static bool IsDomain(IsolatedStorageScope scope);
    internal bool IsDomain();
    internal static bool IsMachine(IsolatedStorageScope scope);
    internal bool IsAssembly();
    internal static bool IsApp(IsolatedStorageScope scope);
    internal bool IsApp();
    internal static string GetHash(Stream s);
    protected virtual char get_SeparatorExternal();
    protected virtual char get_SeparatorInternal();
    public virtual ulong get_MaximumSize();
    public virtual ulong get_CurrentSize();
    public virtual long get_UsedSize();
    public virtual long get_Quota();
    internal virtual void set_Quota(long value);
    public virtual long get_AvailableFreeSpace();
    [SecuritySafeCriticalAttribute]
public object get_DomainIdentity();
    [SecuritySafeCriticalAttribute]
public object get_ApplicationIdentity();
    [SecuritySafeCriticalAttribute]
public object get_AssemblyIdentity();
    [ComVisibleAttribute("False")]
public virtual bool IncreaseQuotaTo(long newQuotaSize);
    [SecurityCriticalAttribute]
internal MemoryStream GetIdentityStream(IsolatedStorageScope scope);
    public IsolatedStorageScope get_Scope();
    internal string get_DomainName();
    internal string get_AssemName();
    internal string get_AppName();
    [SecuritySafeCriticalAttribute]
protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    [SecuritySafeCriticalAttribute]
protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType);
    [SecuritySafeCriticalAttribute]
internal void InitStore(IsolatedStorageScope scope, object domain, object assem, object app);
    [SecurityCriticalAttribute]
internal void InitStore(IsolatedStorageScope scope, Evidence domainEv, Type domainEvidenceType, Evidence assemEv, Type assemEvidenceType, Evidence appEv, Type appEvidenceType);
    [SecuritySafeCriticalAttribute]
internal bool InitStore(IsolatedStorageScope scope, Stream domain, Stream assem, Stream app, string domainName, string assemName, string appName);
    internal static void VerifyScope(IsolatedStorageScope scope);
    [SecurityCriticalAttribute]
internal virtual void SetQuota(PermissionSet psAllowed, PermissionSet psDenied);
    public abstract virtual void Remove();
    protected abstract virtual IsolatedStoragePermission GetPermission(PermissionSet ps);
    [SecuritySafeCriticalAttribute]
internal static RuntimeAssembly GetCaller();
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageException : Exception {
    public IsolatedStorageException(string message);
    public IsolatedStorageException(string message, Exception inner);
    protected IsolatedStorageException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageFile : IsolatedStorage {
    internal static string s_Files;
    internal static string s_AssemFiles;
    internal static string s_AppFiles;
    internal static string s_IDFile;
    internal static string s_InfoFile;
    internal static string s_AppInfoFile;
    public long UsedSize { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("IsolatedStorageFile.CurrentSize has been deprecated because it is not CLS Compliant.  To get the current size use IsolatedStorageFile.UsedSize")]
public ulong CurrentSize { get; }
    [ComVisibleAttribute("False")]
public long AvailableFreeSpace { get; }
    [ComVisibleAttribute("False")]
public long Quota { get; internal set; }
    [ComVisibleAttribute("False")]
public static bool IsEnabled { get; }
    [ObsoleteAttribute("IsolatedStorageFile.MaximumSize has been deprecated because it is not CLS Compliant.  To get the maximum size use IsolatedStorageFile.Quota")]
[CLSCompliantAttribute("False")]
public ulong MaximumSize { get; }
    internal string RootDirectory { get; }
    internal bool Disposed { get; }
    public static IsolatedStorageFile GetUserStoreForDomain();
    public static IsolatedStorageFile GetUserStoreForAssembly();
    public static IsolatedStorageFile GetUserStoreForApplication();
    [ComVisibleAttribute("False")]
public static IsolatedStorageFile GetUserStoreForSite();
    public static IsolatedStorageFile GetMachineStoreForDomain();
    public static IsolatedStorageFile GetMachineStoreForAssembly();
    public static IsolatedStorageFile GetMachineStoreForApplication();
    [SecuritySafeCriticalAttribute]
public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    internal void EnsureStoreIsValid();
    [SecuritySafeCriticalAttribute]
public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);
    [SecuritySafeCriticalAttribute]
public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Evidence domainEvidence, Type domainEvidenceType, Evidence assemblyEvidence, Type assemblyEvidenceType);
    [SecuritySafeCriticalAttribute]
public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType);
    [SecuritySafeCriticalAttribute]
public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity);
    [SecuritySafeCriticalAttribute]
public virtual long get_UsedSize();
    [SecuritySafeCriticalAttribute]
public virtual ulong get_CurrentSize();
    [SecuritySafeCriticalAttribute]
public virtual long get_AvailableFreeSpace();
    public virtual long get_Quota();
    [SecuritySafeCriticalAttribute]
internal virtual void set_Quota(long value);
    public static bool get_IsEnabled();
    public virtual ulong get_MaximumSize();
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public virtual bool IncreaseQuotaTo(long newQuotaSize);
    [SecuritySafeCriticalAttribute]
internal void Reserve(ulong lReserve);
    internal void Unreserve(ulong lFree);
    [SecuritySafeCriticalAttribute]
internal void Unreserve(ulong lFree, ulong quota);
    [SecuritySafeCriticalAttribute]
public void DeleteFile(string file);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public bool FileExists(string path);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public bool DirectoryExists(string path);
    [SecuritySafeCriticalAttribute]
public void CreateDirectory(string dir);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public DateTimeOffset GetCreationTime(string path);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public DateTimeOffset GetLastAccessTime(string path);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public DateTimeOffset GetLastWriteTime(string path);
    [ComVisibleAttribute("False")]
public void CopyFile(string sourceFileName, string destinationFileName);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void CopyFile(string sourceFileName, string destinationFileName, bool overwrite);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void MoveFile(string sourceFileName, string destinationFileName);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName);
    [SecuritySafeCriticalAttribute]
public void DeleteDirectory(string dir);
    [ComVisibleAttribute("False")]
public String[] GetFileNames();
    [SecuritySafeCriticalAttribute]
public String[] GetFileNames(string searchPattern);
    [ComVisibleAttribute("False")]
public String[] GetDirectoryNames();
    [SecuritySafeCriticalAttribute]
public String[] GetDirectoryNames(string searchPattern);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream CreateFile(string path);
    [SecuritySafeCriticalAttribute]
public virtual void Remove();
    [SecuritySafeCriticalAttribute]
public void Close();
    public sealed virtual void Dispose();
    protected virtual void Finalize();
    internal static bool NotAssemFilesDir(string dir);
    internal static bool NotAppFilesDir(string dir);
    [SecuritySafeCriticalAttribute]
public static void Remove(IsolatedStorageScope scope);
    [SecuritySafeCriticalAttribute]
public static IEnumerator GetEnumerator(IsolatedStorageScope scope);
    internal string get_RootDirectory();
    internal string GetFullPath(string path);
    [SecuritySafeCriticalAttribute]
internal void Init(IsolatedStorageScope scope);
    [SecuritySafeCriticalAttribute]
internal bool InitExistingStore(IsolatedStorageScope scope);
    protected virtual IsolatedStoragePermission GetPermission(PermissionSet ps);
    internal void UndoReserveOperation(ulong oldLen, ulong newLen);
    internal void Reserve(ulong oldLen, ulong newLen);
    internal void ReserveOneBlock();
    internal void UnreserveOneBlock();
    internal static ulong RoundToBlockSize(ulong num);
    internal static ulong RoundToBlockSizeFloor(ulong num);
    [SecurityCriticalAttribute]
internal static string GetRootDir(IsolatedStorageScope scope);
    internal bool get_Disposed();
    [SecuritySafeCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static string MigrateOldIsoStoreDirectory(string rootDir, string oldRandomDirectory);
    [SecuritySafeCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static string CreateRandomDirectory(string rootDir);
    internal static string GetRandomDirectory(string rootDir, Boolean& bMigrateNeeded, String& sOldStoreLocation);
    internal static string GetMachineRandomDirectory(string rootDir);
    [SecurityCriticalAttribute]
internal static Mutex CreateMutexNotOwned(string pathName);
    internal static string GetStrongHashSuitableForObjectName(string name);
    [SecuritySafeCriticalAttribute]
internal void Lock(Boolean& locked);
    [SecuritySafeCriticalAttribute]
internal void Unlock();
    [SecurityCriticalAttribute]
internal static FileIOPermission GetGlobalFileIOPerm(IsolatedStorageScope scope);
    internal static void VerifyGlobalScope(IsolatedStorageScope scope);
    [SecuritySafeCriticalAttribute]
internal void CreateIDFile(string path, IsolatedStorageScope scope);
    [SecuritySafeCriticalAttribute]
internal static String[] GetFileDirectoryNames(string path, string userSearchPattern, bool file);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static ulong GetUsage(SafeIsolatedStorageFileHandle handle);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static SafeIsolatedStorageFileHandle Open(string infoFile, string syncName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void Reserve(SafeIsolatedStorageFileHandle handle, ulong plQuota, ulong plReserve, bool fFree);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void GetRootDir(IsolatedStorageScope scope, StringHandleOnStack retRootDir);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool Lock(SafeIsolatedStorageFileHandle handle, bool fLock);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void CreateDirectoryWithDacl(string path);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetQuota(SafeIsolatedStorageFileHandle scope, Int64& quota);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetQuota(SafeIsolatedStorageFileHandle scope, long quota);
}
internal class System.IO.IsolatedStorage.IsolatedStorageFileEnumerator : object {
    public object Current { get; }
    [SecurityCriticalAttribute]
internal IsolatedStorageFileEnumerator(IsolatedStorageScope scope);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageFileStream : FileStream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [ObsoleteAttribute("This property has been deprecated.  Please use IsolatedStorageFileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public IsolatedStorageFileStream(string path, FileMode mode);
    public IsolatedStorageFileStream(string path, FileMode mode, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    [SecuritySafeCriticalAttribute]
public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    [SecurityCriticalAttribute]
public virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
public virtual SafeFileHandle get_SafeFileHandle();
    [SecuritySafeCriticalAttribute]
public virtual void SetLength(long value);
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [SecuritySafeCriticalAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    [SecuritySafeCriticalAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual int EndRead(IAsyncResult asyncResult);
    [SecuritySafeCriticalAttribute]
public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal void NotPermittedError(string str);
    internal void NotPermittedError();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.IO.IsolatedStorage.IsolatedStorageScope : Enum {
    public int value__;
    public static IsolatedStorageScope None;
    public static IsolatedStorageScope User;
    public static IsolatedStorageScope Domain;
    public static IsolatedStorageScope Assembly;
    public static IsolatedStorageScope Roaming;
    public static IsolatedStorageScope Machine;
    public static IsolatedStorageScope Application;
}
public enum System.IO.IsolatedStorage.IsolatedStorageSecurityOptions : Enum {
    public int value__;
    public static IsolatedStorageSecurityOptions IncreaseQuotaForApplication;
}
[SecurityCriticalAttribute]
public class System.IO.IsolatedStorage.IsolatedStorageSecurityState : SecurityState {
    public IsolatedStorageSecurityOptions Options { get; }
    public long UsedSize { get; }
    public long Quota { get; public set; }
    internal static IsolatedStorageSecurityState CreateStateToIncreaseQuotaForApplication(long newQuota, long usedSize);
    public IsolatedStorageSecurityOptions get_Options();
    public long get_UsedSize();
    public long get_Quota();
    public void set_Quota(long value);
    [SecurityCriticalAttribute]
public virtual void EnsureState();
}
[SecurityCriticalAttribute]
internal class System.IO.IsolatedStorage.SafeIsolatedStorageFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.IO.IsolatedStorage.TwoLevelFileEnumerator : object {
    public object Current { get; }
    public TwoLevelFileEnumerator(string root);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
internal class System.IO.IsolatedStorage.TwoPaths : object {
    public string Path1;
    public string Path2;
}
internal abstract class System.IO.Iterator`1 : object {
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[ComVisibleAttribute("False")]
internal static class System.IO.LongPath : object {
    [SecurityCriticalAttribute]
internal static string NormalizePath(string path);
    [SecurityCriticalAttribute]
internal static string NormalizePath(string path, bool fullCheck);
    internal static string InternalCombine(string path1, string path2);
    internal static int GetRootLength(string path);
    internal static bool IsPathRooted(string path);
    [SecurityCriticalAttribute]
internal static string GetPathRoot(string path);
    [SecurityCriticalAttribute]
internal static string GetDirectoryName(string path);
    internal static string TryRemoveLongPathPrefix(string path, Boolean& removed);
}
[ComVisibleAttribute("False")]
internal static class System.IO.LongPathDirectory : object {
    [SecurityCriticalAttribute]
internal static void CreateDirectory(string path);
    [SecurityCriticalAttribute]
internal static void Move(string sourceDirName, string destDirName);
    [SecurityCriticalAttribute]
internal static void Delete(string path, bool recursive);
    [SecurityCriticalAttribute]
internal static bool Exists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path, Int32& lastError);
}
[ComVisibleAttribute("False")]
internal static class System.IO.LongPathFile : object {
    [SecurityCriticalAttribute]
internal static void Copy(string sourceFileName, string destFileName, bool overwrite);
    [SecurityCriticalAttribute]
internal static void Delete(string path);
    [SecurityCriticalAttribute]
internal static bool Exists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path);
    [SecurityCriticalAttribute]
internal static DateTimeOffset GetCreationTime(string path);
    [SecurityCriticalAttribute]
internal static DateTimeOffset GetLastAccessTime(string path);
    [SecurityCriticalAttribute]
internal static DateTimeOffset GetLastWriteTime(string path);
    [SecurityCriticalAttribute]
internal static void Move(string sourceFileName, string destFileName);
    [SecurityCriticalAttribute]
internal static long GetLength(string path);
}
[ComVisibleAttribute("True")]
public class System.IO.MemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Byte[] GetBuffer();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal Byte[] InternalGetBuffer();
    [FriendAccessAllowedAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal void InternalGetOriginAndLength(Int32& origin, Int32& length);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal int InternalGetPosition();
    internal int InternalReadInt32();
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual long get_Length();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
[ComVisibleAttribute("True")]
public static class System.IO.Path : object {
    internal static int MAX_PATH;
    internal static int MAX_DIRECTORY_PATH;
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    internal static Char[] TrimEndChars;
    public static char PathSeparator;
    internal static int MaxPath;
    internal static int MaxLongPath;
    private static Path();
    public static string ChangeExtension(string path, string extension);
    public static string GetDirectoryName(string path);
    internal static int GetRootLength(string path);
    internal static bool IsDirectorySeparator(char c);
    public static Char[] GetInvalidPathChars();
    public static Char[] GetInvalidFileNameChars();
    public static string GetExtension(string path);
    [SecuritySafeCriticalAttribute]
public static string GetFullPath(string path);
    [SecurityCriticalAttribute]
internal static string UnsafeGetFullPath(string path);
    internal static string GetFullPathInternal(string path);
    [SecuritySafeCriticalAttribute]
internal static string NormalizePath(string path, bool fullCheck);
    [SecurityCriticalAttribute]
internal static string NormalizePath(string path, bool fullCheck, int maxPathLength);
    internal static bool HasLongPathPrefix(string path);
    internal static string AddLongPathPrefix(string path);
    internal static string RemoveLongPathPrefix(string path);
    internal static StringBuilder RemoveLongPathPrefix(StringBuilder path);
    public static string GetFileName(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetPathRoot(string path);
    [SecuritySafeCriticalAttribute]
public static string GetTempPath();
    internal static bool IsRelative(string path);
    public static string GetRandomFileName();
    [SecuritySafeCriticalAttribute]
public static string GetTempFileName();
    [SecurityCriticalAttribute]
internal static string UnsafeGetTempFileName();
    public static bool HasExtension(string path);
    public static bool IsPathRooted(string path);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    internal static string ToBase32StringSuitableForDirName(Byte[] buff);
    internal static void CheckSearchPattern(string searchPattern);
    internal static bool HasIllegalCharacters(string path, bool checkAdditional);
    internal static void CheckInvalidPathChars(string path, bool checkAdditional);
    internal static string InternalCombine(string path1, string path2);
}
[DefaultMemberAttribute("Item")]
internal class System.IO.PathHelper : object {
    internal int Length { get; internal set; }
    internal int Capacity { get; }
    internal char Item { get; internal set; }
    [SecurityCriticalAttribute]
internal PathHelper(Char* charArrayPtr, int length);
    internal PathHelper(int capacity, int maxPath);
    internal int get_Length();
    internal void set_Length(int value);
    internal int get_Capacity();
    [SecurityCriticalAttribute]
internal char get_Item(int index);
    [SecurityCriticalAttribute]
internal void set_Item(int index, char value);
    [SecurityCriticalAttribute]
internal void Append(char value);
    [SecurityCriticalAttribute]
internal int GetFullPathName();
    [SecurityCriticalAttribute]
internal bool TryExpandShortFileName();
    [SecurityCriticalAttribute]
internal void Fixup(int lenSavedName, int lastSlash);
    [SecurityCriticalAttribute]
internal bool OrdinalStartsWith(string compareTo, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    [SecurityCriticalAttribute]
internal PinnedBufferMemoryStream(Byte[] array);
    protected virtual void Finalize();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
}
[ComVisibleAttribute("True")]
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal class System.IO.SearchResult : object {
    internal string FullPath { get; }
    internal string UserPath { get; }
    internal WIN32_FIND_DATA FindData { get; }
    [SecurityCriticalAttribute]
internal SearchResult(string fullPath, string userPath, WIN32_FIND_DATA findData);
    internal string get_FullPath();
    internal string get_UserPath();
    [SecurityCriticalAttribute]
internal WIN32_FIND_DATA get_FindData();
}
internal abstract class System.IO.SearchResultHandler`1 : object {
    [SecurityCriticalAttribute]
internal abstract virtual bool IsResultIncluded(SearchResult result);
    [SecurityCriticalAttribute]
internal abstract virtual TSource CreateObject(SearchResult result);
}
[ComVisibleAttribute("True")]
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
[ComVisibleAttribute("True")]
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    [ComVisibleAttribute("False")]
public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [ComVisibleAttribute("False")]
public int ReadTimeout { get; public set; }
    [ComVisibleAttribute("False")]
public int WriteTimeout { get; public set; }
    private static Stream();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    [ComVisibleAttribute("False")]
public Task CopyToAsync(Stream destination);
    [ComVisibleAttribute("False")]
public Task CopyToAsync(Stream destination, int bufferSize);
    [ComVisibleAttribute("False")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public void CopyTo(Stream destination, int bufferSize);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    [ComVisibleAttribute("False")]
public Task FlushAsync();
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously);
    public virtual int EndRead(IAsyncResult asyncResult);
    [ComVisibleAttribute("False")]
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [ComVisibleAttribute("False")]
public Task WriteAsync(Byte[] buffer, int offset, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
}
[ComVisibleAttribute("True")]
public class System.IO.StreamReader : TextReader {
    internal static int DefaultBufferSize;
    public static StreamReader Null;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    [SecuritySafeCriticalAttribute]
public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    [SecurityCriticalAttribute]
internal StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool checkHost);
    private static StreamReader();
    internal void Init(Stream stream);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    internal virtual int ReadBuffer();
    public virtual string ReadLine();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__1e")]
internal virtual Task`1<int> ReadAsyncInternal(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
}
[ComVisibleAttribute("True")]
public class System.IO.StreamWriter : TextWriter {
    internal static int DefaultBufferSize;
    public static StreamWriter Null;
    internal static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    unknown bool HaveWrittenPreamble {internal set; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    [SecuritySafeCriticalAttribute]
public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    [SecurityCriticalAttribute]
internal StreamWriter(string path, bool append, Encoding encoding, int bufferSize, bool checkHost);
    private static StreamWriter();
    [FriendAccessAllowedAttribute]
internal static Encoding get_UTF8NoBOM();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    internal void set_HaveWrittenPreamble(bool value);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync();
}
[ComVisibleAttribute("True")]
public class System.IO.StringReader : TextReader {
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
}
internal class System.IO.StringResultHandler : SearchResultHandler`1<string> {
    internal StringResultHandler(bool includeFiles, bool includeDirs);
    [SecurityCriticalAttribute]
internal virtual bool IsResultIncluded(SearchResult result);
    [SecurityCriticalAttribute]
internal virtual string CreateObject(SearchResult result);
}
[ComVisibleAttribute("True")]
public class System.IO.StringWriter : TextWriter {
    public Encoding Encoding { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringWriter(IFormatProvider formatProvider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    private static StringWriter();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Close();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual void Dispose(bool disposing);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Encoding get_Encoding();
    public virtual StringBuilder GetStringBuilder();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual void Write(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__0")]
[DebuggerStepThroughAttribute]
[ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    internal virtual Task`1<int> ReadAsyncInternal(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public static TextReader Synchronized(TextReader reader);
}
[ComVisibleAttribute("True")]
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    protected Char[] CoreNewLine;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public static TextWriter Synchronized(TextWriter writer);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(string value);
    [ComVisibleAttribute("False")]
public Task WriteAsync(Char[] buffer);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(string value);
    [ComVisibleAttribute("False")]
public Task WriteLineAsync(Char[] buffer);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync();
}
public class System.IO.UnmanagedMemoryAccessor : object {
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    [SecuritySafeCriticalAttribute]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    [SecuritySafeCriticalAttribute]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    [SecuritySafeCriticalAttribute]
protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    [SecuritySafeCriticalAttribute]
public char ReadChar(long position);
    [SecuritySafeCriticalAttribute]
public short ReadInt16(long position);
    [SecuritySafeCriticalAttribute]
public int ReadInt32(long position);
    [SecuritySafeCriticalAttribute]
public long ReadInt64(long position);
    [SecuritySafeCriticalAttribute]
public decimal ReadDecimal(long position);
    [SecuritySafeCriticalAttribute]
public float ReadSingle(long position);
    [SecuritySafeCriticalAttribute]
public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public sbyte ReadSByte(long position);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public ulong ReadUInt64(long position);
    [SecurityCriticalAttribute]
public void Read(long position, T& structure);
    [SecurityCriticalAttribute]
public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, char value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, short value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, int value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, long value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, decimal value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, float value);
    [SecuritySafeCriticalAttribute]
public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public void Write(long position, ushort value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    [SecurityCriticalAttribute]
public void Write(long position, T& structure);
    [SecurityCriticalAttribute]
public void WriteArray(long position, T[] array, int offset, int count);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    internal bool _isOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    internal Byte* Pointer { get; }
    [SecuritySafeCriticalAttribute]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    [SecuritySafeCriticalAttribute]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [SecurityCriticalAttribute]
internal UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access, bool skipSecurityCheck);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    [SecurityCriticalAttribute]
internal UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck);
    [SecuritySafeCriticalAttribute]
protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [SecurityCriticalAttribute]
internal void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access, bool skipSecurityCheck);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    [SecurityCriticalAttribute]
internal void Initialize(Byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_CanRead();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_CanSeek();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_CanWrite();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual long get_Length();
    public long get_Capacity();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual long get_Position();
    [SecuritySafeCriticalAttribute]
public virtual void set_Position(long value);
    [SecurityCriticalAttribute]
public Byte* get_PositionPointer();
    [SecurityCriticalAttribute]
public void set_PositionPointer(Byte* value);
    [SecurityCriticalAttribute]
internal Byte* get_Pointer();
    [SecuritySafeCriticalAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    [SecuritySafeCriticalAttribute]
public virtual void SetLength(long value);
    [SecuritySafeCriticalAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.IRuntimeFieldInfo {
    public RuntimeFieldHandleInternal Value { get; }
    public abstract virtual RuntimeFieldHandleInternal get_Value();
}
internal interface System.IRuntimeMethodInfo {
    public RuntimeMethodHandleInternal Value { get; }
    public abstract virtual RuntimeMethodHandleInternal get_Value();
}
public interface System.IServiceProvider {
    public abstract virtual object GetService(Type serviceType);
}
internal interface System.ITuple {
    public int Size { get; }
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual int get_Size();
}
internal interface System.IWellKnownStringEqualityComparer {
    public abstract virtual IEqualityComparer GetRandomizedEqualityComparer();
    public abstract virtual IEqualityComparer GetEqualityComparerForSerialization();
}
[DebuggerTypeProxyAttribute("System.System_LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
[ComVisibleAttribute("False")]
public class System.Lazy`1 : object {
    internal T ValueForDebugDisplay { get; }
    internal LazyThreadSafetyMode Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private static Lazy`1();
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal LazyThreadSafetyMode get_Mode();
    internal bool get_IsValueFaulted();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsValueCreated();
    public T get_Value();
}
[ComVisibleAttribute("True")]
public enum System.LoaderOptimization : Enum {
    public int value__;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    internal byte _val;
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
internal class System.LocalDataStore : object {
    public LocalDataStore(LocalDataStoreMgr mgr, int InitialCapacity);
    internal void Dispose();
    public object GetData(LocalDataStoreSlot slot);
    public void SetData(LocalDataStoreSlot slot, object data);
    internal void FreeData(int slot, long cookie);
}
internal class System.LocalDataStoreElement : object {
    public object Value { get; public set; }
    public long Cookie { get; }
    public LocalDataStoreElement(long cookie);
    public object get_Value();
    public void set_Value(object value);
    public long get_Cookie();
}
internal class System.LocalDataStoreHolder : object {
    public LocalDataStore Store { get; }
    public LocalDataStoreHolder(LocalDataStore store);
    protected virtual void Finalize();
    public LocalDataStore get_Store();
}
internal class System.LocalDataStoreMgr : object {
    [SecuritySafeCriticalAttribute]
public LocalDataStoreHolder CreateLocalDataStore();
    [SecuritySafeCriticalAttribute]
public void DeleteLocalDataStore(LocalDataStore store);
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot AllocateDataSlot();
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot AllocateNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot GetNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
public void FreeNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
internal void FreeDataSlot(int slot, long cookie);
    public void ValidateSlot(LocalDataStoreSlot slot);
    internal int GetSlotTableLength();
}
[ComVisibleAttribute("True")]
public class System.LocalDataStoreSlot : object {
    internal LocalDataStoreMgr Manager { get; }
    internal int Slot { get; }
    internal long Cookie { get; }
    internal LocalDataStoreSlot(LocalDataStoreMgr mgr, int slot, long cookie);
    internal LocalDataStoreMgr get_Manager();
    internal int get_Slot();
    internal long get_Cookie();
    protected virtual void Finalize();
}
internal enum System.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Status;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Panic;
}
[ComVisibleAttribute("True")]
public abstract class System.MarshalByRefObject : object {
    [SecuritySafeCriticalAttribute]
internal IntPtr GetComIUnknown(bool fIsBeingMarshalled);
    [SecurityCriticalAttribute]
internal static IntPtr GetComIUnknown(MarshalByRefObject o);
    internal bool IsInstanceOfType(Type T);
    internal object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
    [SecuritySafeCriticalAttribute]
internal static Identity GetIdentity(MarshalByRefObject obj, Boolean& fServer);
    internal static Identity GetIdentity(MarshalByRefObject obj);
    internal ServerIdentity __RaceSetServerIdentity(ServerIdentity id);
    internal void __ResetServerIdentity();
    [SecurityCriticalAttribute]
public sealed virtual object GetLifetimeService();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
public virtual ObjRef CreateObjRef(Type requestedType);
    [SecuritySafeCriticalAttribute]
internal bool CanCastToXmlType(string xmlTypeName, string xmlTypeNamespace);
    [SecuritySafeCriticalAttribute]
internal static bool CanCastToXmlTypeHelper(RuntimeType castType, MarshalByRefObject o);
}
public static class System.Math : object {
    public static double PI;
    public static double E;
    private static Math();
    [SecuritySafeCriticalAttribute]
public static double Acos(double d);
    [SecuritySafeCriticalAttribute]
public static double Asin(double d);
    [SecuritySafeCriticalAttribute]
public static double Atan(double d);
    [SecuritySafeCriticalAttribute]
public static double Atan2(double y, double x);
    public static decimal Ceiling(decimal d);
    [SecuritySafeCriticalAttribute]
public static double Ceiling(double a);
    [SecuritySafeCriticalAttribute]
public static double Cos(double d);
    [SecuritySafeCriticalAttribute]
public static double Cosh(double value);
    public static decimal Floor(decimal d);
    [SecuritySafeCriticalAttribute]
public static double Floor(double d);
    [SecuritySafeCriticalAttribute]
public static double Sin(double a);
    [SecuritySafeCriticalAttribute]
public static double Tan(double a);
    [SecuritySafeCriticalAttribute]
public static double Sinh(double value);
    [SecuritySafeCriticalAttribute]
public static double Tanh(double value);
    [SecuritySafeCriticalAttribute]
public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static double Sqrt(double d);
    [SecuritySafeCriticalAttribute]
public static double Log(double d);
    [SecuritySafeCriticalAttribute]
public static double Log10(double d);
    [SecuritySafeCriticalAttribute]
public static double Exp(double d);
    [SecuritySafeCriticalAttribute]
public static double Pow(double x, double y);
    public static double IEEERemainder(double x, double y);
    [CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static sbyte Abs(sbyte value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static short Abs(short value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Abs(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long Abs(long value);
    [SecuritySafeCriticalAttribute]
public static float Abs(float value);
    [SecuritySafeCriticalAttribute]
public static double Abs(double value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static decimal Abs(decimal value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
public static sbyte Max(sbyte val1, sbyte val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static byte Max(byte val1, byte val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static short Max(short val1, short val2);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static ushort Max(ushort val1, ushort val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static int Max(int val1, int val2);
    [CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long Max(long val1, long val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
public static ulong Max(ulong val1, ulong val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static float Max(float val1, float val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static double Max(double val1, double val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static decimal Max(decimal val1, decimal val2);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static sbyte Min(sbyte val1, sbyte val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static byte Min(byte val1, byte val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static short Min(short val1, short val2);
    [CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static ushort Min(ushort val1, ushort val2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static int Min(int val1, int val2);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long Min(long val1, long val2);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static ulong Min(ulong val1, ulong val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static float Min(float val1, float val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static double Min(double val1, double val2);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static decimal Min(decimal val1, decimal val2);
    public static double Log(double a, double newBase);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(short value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(long value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(float value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(double value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Sign(decimal value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long BigMul(int a, int b);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int DivRem(int a, int b, Int32& result);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long DivRem(long a, long b, Int64& result);
}
internal static class System.Mda : object {
    [SecurityCriticalAttribute]
internal static void ReportStreamWriterBufferedDataLost(string text);
    [SecurityCriticalAttribute]
internal static bool IsStreamWriterBufferedDataLostEnabled();
    [SecurityCriticalAttribute]
internal static bool IsStreamWriterBufferedDataLostCaptureAllocatedCallStack();
    [SecurityCriticalAttribute]
internal static void MemberInfoCacheCreation();
    [SecurityCriticalAttribute]
internal static void DateTimeInvalidLocalFormat();
    [SecurityCriticalAttribute]
internal static bool IsInvalidGCHandleCookieProbeEnabled();
    [SecurityCriticalAttribute]
internal static void FireInvalidGCHandleCookieProbe(IntPtr cookie);
    [SecurityCriticalAttribute]
internal static void ReportErrorSafeHandleRelease(Exception ex);
}
[ComVisibleAttribute("True")]
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
[ComVisibleAttribute("True")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public MissingFieldException(string className, string fieldName);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
}
[ComVisibleAttribute("True")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string className, string memberName);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
    [SecurityCriticalAttribute]
internal static string FormatSignature(Byte[] signature);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public MissingMethodException(string className, string methodName);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
}
[ComVisibleAttribute("True")]
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    private RuntimeModule m_ptr;
    public int MDStreamVersion { get; }
    internal ModuleHandle(RuntimeModule module);
    private static ModuleHandle();
    internal RuntimeModule GetRuntimeModule();
    internal bool IsNullHandle();
    public virtual int GetHashCode();
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(ModuleHandle handle);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    [SecurityCriticalAttribute]
internal static IRuntimeMethodInfo GetDynamicMethod(DynamicMethod method, RuntimeModule module, string name, Byte[] sig, Resolver resolver);
    [SecurityCriticalAttribute]
internal static int GetToken(RuntimeModule module);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType ResolveTypeHandleInternal(RuntimeModule module, int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SecurityCriticalAttribute]
internal static RuntimeMethodHandleInternal ResolveMethodHandleInternalCore(RuntimeModule module, int methodToken, IntPtr[] typeInstantiationContext, int typeInstCount, IntPtr[] methodInstantiationContext, int methodInstCount);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeFieldInfo ResolveFieldHandleInternal(RuntimeModule module, int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SecurityCriticalAttribute]
internal static bool ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    [SecuritySafeCriticalAttribute]
internal static RuntimeAssembly GetAssembly(RuntimeModule module);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void GetModuleType(RuntimeModule handle, ObjectHandleOnStack type);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetModuleType(RuntimeModule module);
    [SecuritySafeCriticalAttribute]
internal static void GetPEKind(RuntimeModule module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
    [SecurityCriticalAttribute]
internal static int GetMDStreamVersion(RuntimeModule module);
    [SecuritySafeCriticalAttribute]
public int get_MDStreamVersion();
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static MetadataImport GetMetadataImport(RuntimeModule module);
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.MTAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public abstract class System.MulticastDelegate : Delegate {
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    [SecuritySafeCriticalAttribute]
internal bool IsUnmanagedFunctionPtr();
    [SecuritySafeCriticalAttribute]
internal bool InvocationListLogicallyNull();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool Equals(object obj);
    [SecurityCriticalAttribute]
internal MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount);
    [SecurityCriticalAttribute]
internal void StoreDynamicMethod(MethodInfo dynamicMethod);
    [SecuritySafeCriticalAttribute]
protected sealed virtual Delegate CombineImpl(Delegate follow);
    [SecuritySafeCriticalAttribute]
protected sealed virtual Delegate RemoveImpl(Delegate value);
    [SecuritySafeCriticalAttribute]
public sealed virtual Delegate[] GetInvocationList();
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    [SecuritySafeCriticalAttribute]
public sealed virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
internal virtual object GetTarget();
    [SecuritySafeCriticalAttribute]
protected virtual MethodInfo GetMethodImpl();
}
[ComVisibleAttribute("True")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    internal static bool IsDefined(RuntimeFieldInfo field);
}
[ComVisibleAttribute("True")]
public class System.NotFiniteNumberException : ArithmeticException {
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public static class System.Nullable : object {
    [ComVisibleAttribute("True")]
public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    [ComVisibleAttribute("True")]
public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Nullable`1(T value);
    public bool get_HasValue();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public T get_Value();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Nullable`1<T> op_Implicit(T value);
    public static T op_Explicit(Nullable`1<T> value);
}
[ComVisibleAttribute("True")]
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
[FriendAccessAllowedAttribute]
internal class System.Number : object {
    [SecurityCriticalAttribute]
public static string FormatDecimal(decimal value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatDouble(double value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatInt32(int value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatUInt32(UInt32 value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatInt64(long value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatUInt64(ulong value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static string FormatSingle(float value, string format, NumberFormatInfo info);
    [SecurityCriticalAttribute]
public static bool NumberBufferToDecimal(Byte* number, Decimal& value);
    [SecurityCriticalAttribute]
internal static bool NumberBufferToDouble(Byte* number, Double& value);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static string FormatNumberBuffer(Byte* number, string format, NumberFormatInfo info, Char* allDigits);
    [SecuritySafeCriticalAttribute]
internal static decimal ParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static double ParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static int ParseInt32(string s, NumberStyles style, NumberFormatInfo info);
    [SecuritySafeCriticalAttribute]
internal static long ParseInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static float ParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static UInt32 ParseUInt32(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static ulong ParseUInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt, Decimal& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt, Double& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseInt32(string s, NumberStyles style, NumberFormatInfo info, Int32& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseInt64(string s, NumberStyles style, NumberFormatInfo info, Int64& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt, Single& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseUInt32(string s, NumberStyles style, NumberFormatInfo info, UInt32& result);
    [SecuritySafeCriticalAttribute]
internal static bool TryParseUInt64(string s, NumberStyles style, NumberFormatInfo info, UInt64& result);
    internal static bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, NumberFormatInfo numfmt, bool parseDecimal);
    [SecuritySafeCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
public class System.Object {
    public virtual string ToString();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool Equals(object objA, object objB);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static bool ReferenceEquals(object objA, object objB);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public Type GetType();
    [ReliabilityContractAttribute("3", "2")]
protected virtual void Finalize();
    [SecuritySafeCriticalAttribute]
protected object MemberwiseClone();
}
[ComVisibleAttribute("True")]
public class System.ObjectDisposedException : InvalidOperationException {
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string objectName, string message);
    public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("6140")]
[ComVisibleAttribute("True")]
public class System.ObsoleteAttribute : Attribute {
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
internal class System.OleAutBinder : DefaultBinder {
    [SecuritySafeCriticalAttribute]
public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
}
[ComVisibleAttribute("True")]
public class System.OperatingSystem : object {
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
[ComVisibleAttribute("True")]
public class System.OperationCanceledException : SystemException {
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalComparer : StringComparer {
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
internal class System.OrdinalRandomizedComparer : StringComparer {
    internal OrdinalRandomizedComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetRandomizedEqualityComparer();
    private sealed virtual override IEqualityComparer System.IWellKnownStringEqualityComparer.GetEqualityComparerForSerialization();
}
[ComVisibleAttribute("True")]
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.ParamArrayAttribute : Attribute {
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    internal static int PrintAsI1;
    internal static int PrintAsI2;
    internal static int PrintAsI4;
    internal static int TreatAsUnsigned;
    internal static int TreatAsI1;
    internal static int TreatAsI2;
    internal static int IsTight;
    internal static int NoSpace;
    [SecuritySafeCriticalAttribute]
public static long StringToLong(string s, int radix, int flags);
    [SecurityCriticalAttribute]
public static long StringToLong(string s, int radix, int flags, Int32* currPos);
    [SecuritySafeCriticalAttribute]
public static long StringToLong(string s, int radix, int flags, Int32& currPos);
    [SecuritySafeCriticalAttribute]
public static int StringToInt(string s, int radix, int flags);
    [SecurityCriticalAttribute]
public static int StringToInt(string s, int radix, int flags, Int32* currPos);
    [SecuritySafeCriticalAttribute]
public static int StringToInt(string s, int radix, int flags, Int32& currPos);
    [SecurityCriticalAttribute]
public static string IntToString(int l, int radix, int width, char paddingChar, int flags);
    [SecurityCriticalAttribute]
public static string LongToString(long l, int radix, int width, char paddingChar, int flags);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
[ComVisibleAttribute("True")]
public enum System.PlatformID : Enum {
    public int value__;
    public static PlatformID Win32S;
    public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    public static PlatformID WinCE;
    public static PlatformID Unix;
    public static PlatformID Xbox;
    public static PlatformID MacOSX;
}
[ComVisibleAttribute("True")]
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    public Progress`1(Action`1<T> handler);
    public void add_ProgressChanged(EventHandler`1<T> value);
    public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
[ComVisibleAttribute("True")]
public class System.Random : object {
    public Random(int Seed);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual double Sample();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int Next();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
}
[ComVisibleAttribute("True")]
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
internal class System.Reflection.__Filters : object {
    public virtual bool FilterTypeName(Type cls, object filterCriteria);
    public virtual bool FilterTypeNameIgnoreCase(Type cls, object filterCriteria);
}
[ComVisibleAttribute("True")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Assembly")]
public abstract class System.Reflection.Assembly : object {
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public Evidence Evidence { get; }
    public PermissionSet PermissionSet { get; }
    public bool IsFullyTrusted { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    [ComVisibleAttribute("False")]
public Module ManifestModule { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    [ComVisibleAttribute("False")]
public bool ReflectionOnly { get; }
    public IEnumerable`1<Module> Modules { get; }
    public string Location { get; }
    [ComVisibleAttribute("False")]
public string ImageRuntimeVersion { get; }
    public bool GlobalAssemblyCache { get; }
    [ComVisibleAttribute("False")]
public long HostContext { get; }
    public bool IsDynamic { get; }
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static Assembly LoadFrom(string assemblyFile);
    [SecuritySafeCriticalAttribute]
public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [SecuritySafeCriticalAttribute]
public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [SecurityCriticalAttribute]
public static Assembly UnsafeLoadFrom(string assemblyFile);
    [SecuritySafeCriticalAttribute]
public static Assembly Load(string assemblyString);
    [SecuritySafeCriticalAttribute]
internal static Type GetType_Compat(string assemblyString, string typeName);
    [SecuritySafeCriticalAttribute]
public static Assembly ReflectionOnlyLoad(string assemblyString);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static Assembly Load(string assemblyString, Evidence assemblySecurity);
    [SecuritySafeCriticalAttribute]
public static Assembly Load(AssemblyName assemblyRef);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence);
    [SecuritySafeCriticalAttribute]
public static Assembly Load(Byte[] rawAssembly);
    [SecuritySafeCriticalAttribute]
public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    [SecuritySafeCriticalAttribute]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    [SecuritySafeCriticalAttribute]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, SecurityContextSource securityContextSource);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    [SecuritySafeCriticalAttribute]
public static Assembly LoadFile(string path);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static Assembly LoadFile(string path, Evidence securityEvidence);
    [SecuritySafeCriticalAttribute]
public static Assembly GetExecutingAssembly();
    [SecuritySafeCriticalAttribute]
public static Assembly GetCallingAssembly();
    [SecuritySafeCriticalAttribute]
public static Assembly GetEntryAssembly();
    [SecurityCriticalAttribute]
public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [SecurityCriticalAttribute]
public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual string get_CodeBase();
    [SecuritySafeCriticalAttribute]
public virtual string get_EscapedCodeBase();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual MethodInfo get_EntryPoint();
    private sealed virtual override Type System.Runtime.InteropServices._Assembly.GetType();
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual Type[] GetExportedTypes();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Type[] GetTypes();
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Evidence get_Evidence();
    [SecurityCriticalAttribute]
public virtual PermissionSet get_PermissionSet();
    [SecuritySafeCriticalAttribute]
public bool get_IsFullyTrusted();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Module get_ManifestModule();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool get_ReflectionOnly();
    public sealed virtual Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public sealed virtual object CreateInstance(string typeName);
    public sealed virtual object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public virtual IEnumerable`1<Module> get_Modules();
    public sealed virtual Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public sealed virtual Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module GetModule(string name);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual String[] GetManifestResourceNames();
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string ToString();
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual bool get_IsDynamic();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    public UInt32 get_AlgorithmId();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    public string get_Company();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    public string get_Configuration();
}
[ComVisibleAttribute("False")]
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    public string get_Copyright();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    public string get_Culture();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    public string get_Description();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    [ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string get_InformationalVersion();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    public string get_KeyFile();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    public string get_Key();
    public string get_Value();
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._AssemblyName")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.AssemblyName : object {
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    [ComVisibleAttribute("False")]
public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public string FullName { get; }
    [SecuritySafeCriticalAttribute]
public AssemblyName(string assemblyName);
    internal AssemblyName(SerializationInfo info, StreamingContext context);
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public string get_CodeBase();
    public void set_CodeBase(string value);
    [SecuritySafeCriticalAttribute]
public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public sealed virtual object Clone();
    [SecuritySafeCriticalAttribute]
public static AssemblyName GetAssemblyName(string assemblyFile);
    internal void SetHashControl(Byte[] hash, AssemblyHashAlgorithm hashAlgorithm);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    [SecuritySafeCriticalAttribute]
public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    [SecuritySafeCriticalAttribute]
public string get_FullName();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    [SecuritySafeCriticalAttribute]
public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    [SecuritySafeCriticalAttribute]
internal static bool ReferenceMatchesDefinitionInternal(AssemblyName reference, AssemblyName definition, bool parse);
    [SecurityCriticalAttribute]
internal void nInit(RuntimeAssembly& assembly, bool forIntrospection, bool raiseResolveEvent);
    [SecurityCriticalAttribute]
internal void nInit();
    internal void SetProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm);
    internal static ProcessorArchitecture CalculateProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm, AssemblyNameFlags flags);
    internal void Init(string name, Byte[] publicKey, Byte[] publicKeyToken, Version version, CultureInfo cultureInfo, AssemblyHashAlgorithm hashAlgorithm, AssemblyVersionCompatibility versionCompatibility, string codeBase, AssemblyNameFlags flags, StrongNameKeyPair keyPair);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal string GetNameWithPublicKey();
    [SecurityCriticalAttribute]
internal static AssemblyName nGetFileInformation(string s);
    [SecurityCriticalAttribute]
internal static string EscapeCodeBase(string codeBase);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string get_PublicKey();
    public string get_Countersignature();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    public string get_Title();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    public string get_Trademark();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    public string get_Version();
}
internal static class System.Reflection.Associates : object {
    internal static bool IncludeAccessor(MethodInfo associate, bool nonPublic);
    [SecurityCriticalAttribute]
internal static void AssignAssociates(MetadataImport scope, int mdPropEvent, RuntimeType declaringType, RuntimeType reflectedType, RuntimeMethodInfo& addOn, RuntimeMethodInfo& removeOn, RuntimeMethodInfo& fireOn, RuntimeMethodInfo& getter, RuntimeMethodInfo& setter, MethodInfo[]& other, Boolean& composedOfAllPrivateMethods, BindingFlags& bindingFlags);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
public abstract class System.Reflection.Binder : object {
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.CerHashtable`2 : ValueType {
    private static int MinSize;
    private Table<K, V> m_Table;
    internal V Item { get; internal set; }
    internal void set_Item(K key, V value);
    internal V get_Item(K key);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.ConstArray : ValueType {
    internal int m_length;
    internal IntPtr m_constArray;
    public IntPtr Signature { get; }
    public int Length { get; }
    public byte Item { get; }
    public IntPtr get_Signature();
    public int get_Length();
    [SecuritySafeCriticalAttribute]
public byte get_Item(int index);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ConstructorInfo")]
[ComVisibleAttribute("True")]
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    [ComVisibleAttribute("True")]
public static string ConstructorName;
    [ComVisibleAttribute("True")]
public static string TypeConstructorName;
    [ComVisibleAttribute("True")]
public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(Object[] parameters);
    private sealed virtual override Type System.Runtime.InteropServices._ConstructorInfo.GetType();
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, Object[] parameters);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(Object[] parameters);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType End;
    public static CorElementType Void;
    public static CorElementType Boolean;
    public static CorElementType Char;
    public static CorElementType I1;
    public static CorElementType U1;
    public static CorElementType I2;
    public static CorElementType U2;
    public static CorElementType I4;
    public static CorElementType U4;
    public static CorElementType I8;
    public static CorElementType U8;
    public static CorElementType R4;
    public static CorElementType R8;
    public static CorElementType String;
    public static CorElementType Ptr;
    public static CorElementType ByRef;
    public static CorElementType ValueType;
    public static CorElementType Class;
    public static CorElementType Var;
    public static CorElementType Array;
    public static CorElementType GenericInst;
    public static CorElementType TypedByRef;
    public static CorElementType I;
    public static CorElementType U;
    public static CorElementType FnPtr;
    public static CorElementType Object;
    public static CorElementType SzArray;
    public static CorElementType MVar;
    public static CorElementType CModReqd;
    public static CorElementType CModOpt;
    public static CorElementType Internal;
    public static CorElementType Max;
    public static CorElementType Modifier;
    public static CorElementType Sentinel;
    public static CorElementType Pinned;
}
internal static class System.Reflection.CustomAttribute : object {
    private static CustomAttribute();
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeType type, RuntimeType caType, bool inherit);
    [SecuritySafeCriticalAttribute]
internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool inherit);
    [SecurityCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static Object[] GetCustomAttributes(RuntimeModule module, RuntimeType caType);
    [SecuritySafeCriticalAttribute]
internal static bool IsAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, int attributeCtorToken);
    [SecurityCriticalAttribute]
internal static AttributeUsageAttribute GetAttributeUsage(RuntimeType decoratedAttribute);
}
internal class System.Reflection.CustomAttributeCtorParameter : ValueType {
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument CustomAttributeEncodedArgument { get; }
    public CustomAttributeCtorParameter(CustomAttributeType type);
    public CustomAttributeEncodedArgument get_CustomAttributeEncodedArgument();
}
[ComVisibleAttribute("True")]
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    [ComVisibleAttribute("True")]
public ConstructorInfo Constructor { get; }
    [ComVisibleAttribute("True")]
public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    internal CustomAttributeData(Attribute attribute);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeFieldInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeMethodInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeConstructorInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeEventInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimePropertyInfo target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeModule target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeAssembly target);
    [SecuritySafeCriticalAttribute]
internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeParameterInfo target);
    [SecurityCriticalAttribute]
internal static CustomAttributeRecord[] GetCustomAttributeRecords(RuntimeModule module, int targetToken);
    internal static CustomAttributeTypedArgument Filter(IList`1<CustomAttributeData> attrs, Type caType, int parameter);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
internal class System.Reflection.CustomAttributeEncodedArgument : ValueType {
    private long m_primitiveValue;
    private CustomAttributeEncodedArgument[] m_arrayValue;
    private string m_stringValue;
    private CustomAttributeType m_type;
    public CustomAttributeType CustomAttributeType { get; }
    public long PrimitiveValue { get; }
    public CustomAttributeEncodedArgument[] ArrayValue { get; }
    public string StringValue { get; }
    [SecurityCriticalAttribute]
internal static void ParseAttributeArguments(ConstArray attributeBlob, CustomAttributeCtorParameter[]& customAttributeCtorParameters, CustomAttributeNamedParameter[]& customAttributeNamedParameters, RuntimeModule customAttributeModule);
    public CustomAttributeType get_CustomAttributeType();
    public long get_PrimitiveValue();
    public CustomAttributeEncodedArgument[] get_ArrayValue();
    public string get_StringValue();
}
internal enum System.Reflection.CustomAttributeEncoding : Enum {
    public int value__;
    public static CustomAttributeEncoding Undefined;
    public static CustomAttributeEncoding Boolean;
    public static CustomAttributeEncoding Char;
    public static CustomAttributeEncoding SByte;
    public static CustomAttributeEncoding Byte;
    public static CustomAttributeEncoding Int16;
    public static CustomAttributeEncoding UInt16;
    public static CustomAttributeEncoding Int32;
    public static CustomAttributeEncoding UInt32;
    public static CustomAttributeEncoding Int64;
    public static CustomAttributeEncoding UInt64;
    public static CustomAttributeEncoding Float;
    public static CustomAttributeEncoding Double;
    public static CustomAttributeEncoding String;
    public static CustomAttributeEncoding Array;
    public static CustomAttributeEncoding Type;
    public static CustomAttributeEncoding Object;
    public static CustomAttributeEncoding Field;
    public static CustomAttributeEncoding Property;
    public static CustomAttributeEncoding Enum;
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[ComVisibleAttribute("True")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private MemberInfo m_memberInfo;
    private CustomAttributeTypedArgument m_value;
    internal Type ArgumentType { get; }
    public MemberInfo MemberInfo { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public string MemberName { get; }
    public bool IsField { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal Type get_ArgumentType();
    public MemberInfo get_MemberInfo();
    public CustomAttributeTypedArgument get_TypedValue();
    public string get_MemberName();
    public bool get_IsField();
}
internal class System.Reflection.CustomAttributeNamedParameter : ValueType {
    private string m_argumentName;
    private CustomAttributeEncoding m_fieldOrProperty;
    private CustomAttributeEncoding m_padding;
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument EncodedArgument { get; }
    public CustomAttributeNamedParameter(string argumentName, CustomAttributeEncoding fieldOrProperty, CustomAttributeType type);
    public CustomAttributeEncodedArgument get_EncodedArgument();
}
internal class System.Reflection.CustomAttributeRecord : ValueType {
    internal ConstArray blob;
    internal MetadataToken tkCtor;
}
internal class System.Reflection.CustomAttributeType : ValueType {
    private string m_enumName;
    private CustomAttributeEncoding m_encodedType;
    private CustomAttributeEncoding m_encodedEnumType;
    private CustomAttributeEncoding m_encodedArrayType;
    private CustomAttributeEncoding m_padding;
    public CustomAttributeEncoding EncodedType { get; }
    public CustomAttributeEncoding EncodedEnumType { get; }
    public CustomAttributeEncoding EncodedArrayType { get; }
    [ComVisibleAttribute("True")]
public string EnumName { get; }
    public CustomAttributeType(CustomAttributeEncoding encodedType, CustomAttributeEncoding encodedArrayType, CustomAttributeEncoding encodedEnumType, string enumName);
    public CustomAttributeEncoding get_EncodedType();
    public CustomAttributeEncoding get_EncodedEnumType();
    public CustomAttributeEncoding get_EncodedArrayType();
    public string get_EnumName();
}
[ComVisibleAttribute("True")]
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object m_value;
    private Type m_argumentType;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public CustomAttributeTypedArgument(object value);
    internal CustomAttributeTypedArgument(RuntimeModule scope, CustomAttributeEncodedArgument encodedArg);
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
    internal string ToString(bool typed);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_ArgumentType();
    public object get_Value();
}
[AttributeUsageAttribute("1036")]
[ComVisibleAttribute("True")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    public string get_MemberName();
}
internal class System.Reflection.Emit.__ExceptionInfo : object {
    internal static int None;
    internal static int Filter;
    internal static int Finally;
    internal static int Fault;
    internal static int PreserveStack;
    internal static int State_Try;
    internal static int State_Filter;
    internal static int State_Catch;
    internal static int State_Finally;
    internal static int State_Fault;
    internal static int State_Done;
    internal int m_startAddr;
    internal Int32[] m_filterAddr;
    internal Int32[] m_catchAddr;
    internal Int32[] m_catchEndAddr;
    internal Int32[] m_type;
    internal Type[] m_catchClass;
    internal Label m_endLabel;
    internal Label m_finallyEndLabel;
    internal int m_endAddr;
    internal int m_endFinally;
    internal int m_currentCatch;
    internal __ExceptionInfo(int startAddr, Label endLabel);
    internal void MarkFilterAddr(int filterAddr);
    internal void MarkFaultAddr(int faultAddr);
    internal void MarkCatchAddr(int catchAddr, Type catchException);
    internal void MarkFinallyAddr(int finallyAddr, int endCatchAddr);
    internal void Done(int endAddr);
    internal int GetStartAddress();
    internal int GetEndAddress();
    internal int GetFinallyEndAddress();
    internal Label GetEndLabel();
    internal Int32[] GetFilterAddresses();
    internal Int32[] GetCatchAddresses();
    internal Int32[] GetCatchEndAddresses();
    internal Type[] GetCatchClass();
    internal int GetNumberOfCatches();
    internal Int32[] GetExceptionTypes();
    internal void SetFinallyEndLabel(Label lbl);
    internal Label GetFinallyEndLabel();
    internal bool IsInner(__ExceptionInfo exc);
    internal int GetCurrentState();
}
internal class System.Reflection.Emit.__FixupData : ValueType {
    internal Label m_fixupLabel;
    internal int m_fixupPos;
    internal int m_fixupInstSize;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._AssemblyBuilder")]
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    internal static string MANIFEST_MODULE_NAME;
    internal AssemblyBuilderData m_assemblyData;
    internal object SyncRoot { get; }
    internal InternalAssemblyBuilder InternalAssembly { get; }
    internal bool ProfileAPICheck { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public Evidence Evidence { get; }
    public PermissionSet PermissionSet { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    [SecurityCriticalAttribute]
internal AssemblyBuilder(AppDomain domain, AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes, SecurityContextSource securityContextSource);
    internal ModuleBuilder GetModuleBuilder(InternalModuleBuilder module);
    internal object get_SyncRoot();
    internal InternalAssemblyBuilder get_InternalAssembly();
    internal RuntimeAssembly GetNativeHandle();
    [SecurityCriticalAttribute]
internal Version GetVersion();
    internal bool get_ProfileAPICheck();
    [SecuritySafeCriticalAttribute]
public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    [SecuritySafeCriticalAttribute]
public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    [SecurityCriticalAttribute]
internal static AssemblyBuilder InternalDefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes, SecurityContextSource securityContextSource);
    [SecuritySafeCriticalAttribute]
public ModuleBuilder DefineDynamicModule(string name);
    [SecuritySafeCriticalAttribute]
public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
    [SecuritySafeCriticalAttribute]
public ModuleBuilder DefineDynamicModule(string name, string fileName);
    [SecuritySafeCriticalAttribute]
public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    public IResourceWriter DefineResource(string name, string description, string fileName);
    public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute);
    public void AddResourceFile(string name, string fileName);
    public void AddResourceFile(string name, string fileName, ResourceAttributes attribute);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual Type[] GetExportedTypes();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Evidence get_Evidence();
    [SecurityCriticalAttribute]
public virtual PermissionSet get_PermissionSet();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual bool get_IsDynamic();
    public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark);
    public void DefineVersionInfoResource();
    public void DefineUnmanagedResource(Byte[] resource);
    [SecuritySafeCriticalAttribute]
public void DefineUnmanagedResource(string resourceFileName);
    public ModuleBuilder GetDynamicModule(string name);
    public void SetEntryPoint(MethodInfo entryMethod);
    public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void Save(string assemblyFileName);
    [SecuritySafeCriticalAttribute]
public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
    internal bool IsPersistable();
    [SecurityCriticalAttribute]
internal int DefineExportedTypeInMemory(Type type, int tkResolutionScope, int tkTypeDef);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess Save;
    public static AssemblyBuilderAccess RunAndSave;
    public static AssemblyBuilderAccess ReflectionOnly;
    public static AssemblyBuilderAccess RunAndCollect;
}
internal class System.Reflection.Emit.AssemblyBuilderData : object {
    internal static int m_iInitialSize;
    internal static int m_tkAssembly;
    internal List`1<ModuleBuilder> m_moduleBuilderList;
    internal List`1<ResWriterData> m_resWriterList;
    internal string m_strAssemblyName;
    internal AssemblyBuilderAccess m_access;
    internal Type[] m_publicComTypeList;
    internal int m_iPublicComTypeCount;
    internal bool m_isSaved;
    internal string m_strDir;
    internal PermissionSet m_RequiredPset;
    internal PermissionSet m_OptionalPset;
    internal PermissionSet m_RefusedPset;
    internal CustomAttributeBuilder[] m_CABuilders;
    internal int m_iCABuilder;
    internal Byte[][] m_CABytes;
    internal ConstructorInfo[] m_CACons;
    internal int m_iCAs;
    internal PEFileKinds m_peFileKind;
    internal MethodInfo m_entryPointMethod;
    internal Assembly m_ISymWrapperAssembly;
    internal ModuleBuilder m_entryPointModule;
    internal string m_strResourceFileName;
    internal Byte[] m_resourceBytes;
    internal NativeVersionInfo m_nativeVersion;
    internal bool m_hasUnmanagedVersionInfo;
    internal bool m_OverrideUnmanagedVersionInfo;
    [SecurityCriticalAttribute]
internal AssemblyBuilderData(InternalAssemblyBuilder assembly, string strAssemblyName, AssemblyBuilderAccess access, string dir);
    internal void AddModule(ModuleBuilder dynModule);
    internal void AddResWriter(ResWriterData resData);
    internal void AddCustomAttribute(CustomAttributeBuilder customBuilder);
    internal void AddCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecurityCriticalAttribute]
internal void FillUnmanagedVersionInfo();
    internal void CheckResNameConflict(string strNewResName);
    internal void CheckNameConflict(string strNewModuleName);
    internal void CheckTypeNameConflict(string strTypeName, TypeBuilder enclosingType);
    internal void CheckFileNameConflict(string strFileName);
    internal ModuleBuilder FindModuleWithFileName(string strFileName);
    internal ModuleBuilder FindModuleWithName(string strName);
    internal void AddPublicComType(Type type);
    internal void AddPermissionRequests(PermissionSet required, PermissionSet optional, PermissionSet refused);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ConstructorBuilder")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    internal bool m_isDefaultConstructor;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public CallingConventions CallingConvention { get; }
    [ObsoleteAttribute("This property has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public Type ReturnType { get; }
    public string Signature { get; }
    public bool InitLocals { get; public set; }
    [SecurityCriticalAttribute]
internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers, ModuleBuilder mod, TypeBuilder type);
    [SecurityCriticalAttribute]
internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, ModuleBuilder mod, TypeBuilder type);
    internal virtual Type[] GetParameterTypes();
    internal ModuleBuilder GetModuleBuilder();
    public virtual string ToString();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public MethodToken GetToken();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public void SetSymCustomAttribute(string name, Byte[] data);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups);
    [SecuritySafeCriticalAttribute]
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    public virtual CallingConventions get_CallingConvention();
    public Module GetModule();
    public Type get_ReturnType();
    internal virtual Type GetReturnType();
    public string get_Signature();
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInstantiation : ConstructorInfo {
    internal ConstructorInfo m_ctor;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    internal ConstructorOnTypeBuilderInstantiation(ConstructorInfo constructor, TypeBuilderInstantiation type);
    internal static ConstructorInfo GetConstructor(ConstructorInfo Constructor, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public Type GetType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._CustomAttributeBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    internal ConstructorInfo m_con;
    internal Object[] m_constructorArgs;
    internal Byte[] m_blob;
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    internal void InitCustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    [SecurityCriticalAttribute]
internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner);
    [SecurityCriticalAttribute]
internal int PrepareCreateCustomAttributeToDisk(ModuleBuilder mod);
    [SecurityCriticalAttribute]
internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner, int tkAttrib, bool toDisk);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
internal enum System.Reflection.Emit.DynamicAssemblyFlags : Enum {
    public int value__;
    public static DynamicAssemblyFlags None;
    public static DynamicAssemblyFlags AllCritical;
    public static DynamicAssemblyFlags Aptca;
    public static DynamicAssemblyFlags Critical;
    public static DynamicAssemblyFlags Transparent;
    public static DynamicAssemblyFlags TreatAsSafe;
}
internal class System.Reflection.Emit.DynamicILGenerator : ILGenerator {
    internal DynamicScope m_scope;
    internal DynamicILGenerator(DynamicMethod method, Byte[] methodSignature, int size);
    [SecurityCriticalAttribute]
internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    [SecuritySafeCriticalAttribute]
public virtual void Emit(OpCode opcode, MethodInfo meth);
    [ComVisibleAttribute("True")]
public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type type);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    [SecuritySafeCriticalAttribute]
public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual Label BeginExceptionBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void UsingNamespace(string ns);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    [SecurityCriticalAttribute]
internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    internal virtual void RecordTokenFixup();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.DynamicILInfo : object {
    internal Byte[] LocalSignature { get; }
    internal Byte[] Exceptions { get; }
    internal Byte[] Code { get; }
    internal int MaxStackSize { get; }
    public DynamicMethod DynamicMethod { get; }
    internal DynamicScope DynamicScope { get; }
    internal DynamicILInfo(DynamicScope scope, DynamicMethod method, Byte[] methodSignature);
    [SecurityCriticalAttribute]
internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    internal Byte[] get_LocalSignature();
    internal Byte[] get_Exceptions();
    internal Byte[] get_Code();
    internal int get_MaxStackSize();
    public DynamicMethod get_DynamicMethod();
    internal DynamicScope get_DynamicScope();
    public void SetCode(Byte[] code, int maxStackSize);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public void SetCode(Byte* code, int codeSize, int maxStackSize);
    public void SetExceptions(Byte[] exceptions);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public void SetExceptions(Byte* exceptions, int exceptionsSize);
    public void SetLocalSignature(Byte[] localSignature);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public void SetLocalSignature(Byte* localSignature, int signatureSize);
    [SecuritySafeCriticalAttribute]
public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    internal IRuntimeMethodInfo m_methodHandle;
    internal bool m_skipVisibility;
    internal RuntimeType m_typeOwner;
    internal DynamicResolver m_resolver;
    internal bool m_restrictedSkipVisibility;
    internal CompressedStack m_creationContext;
    internal bool ProfileAPICheck { get; internal set; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool InitLocals { get; public set; }
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    [SecuritySafeCriticalAttribute]
public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    private static DynamicMethod();
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public sealed virtual Delegate CreateDelegate(Type delegateType);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    internal bool get_ProfileAPICheck();
    [FriendAccessAllowedAttribute]
internal void set_ProfileAPICheck(bool value);
    [SecurityCriticalAttribute]
internal RuntimeMethodHandle GetMethodDescriptor();
    public virtual string ToString();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSecurityCritical();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSecuritySafeCritical();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSecurityTransparent();
    [SecuritySafeCriticalAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    [SecuritySafeCriticalAttribute]
public DynamicILInfo GetDynamicILInfo();
    [SecurityCriticalAttribute]
internal DynamicILInfo GetDynamicILInfo(DynamicScope scope);
    public ILGenerator GetILGenerator();
    [SecuritySafeCriticalAttribute]
public ILGenerator GetILGenerator(int streamSize);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal MethodInfo GetMethodInfo();
}
internal class System.Reflection.Emit.DynamicResolver : Resolver {
    internal DynamicResolver(DynamicILGenerator ilGenerator);
    internal DynamicResolver(DynamicILInfo dynamicILInfo);
    protected virtual void Finalize();
    internal virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    internal virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal virtual Byte[] GetLocalsSignature();
    internal virtual Byte[] GetRawEHInfo();
    [SecurityCriticalAttribute]
internal virtual void GetEHInfo(int excNumber, Void* exc);
    internal virtual string GetStringLiteral(int token);
    internal virtual CompressedStack GetSecurityContext();
    [SecurityCriticalAttribute]
internal virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal virtual MethodInfo GetDynamicMethod();
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Emit.DynamicScope : object {
    internal List`1<object> m_tokens;
    internal object Item { get; }
    internal object get_Item(int token);
    internal int GetTokenFor(VarArgMethod varArgMethod);
    internal string GetString(int token);
    internal Byte[] ResolveSignature(int token, int fromMethod);
    [SecuritySafeCriticalAttribute]
public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle typeContext);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle typeContext);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._EnumBuilder")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    internal TypeBuilder m_typeBuilder;
    public TypeToken TypeToken { get; }
    public FieldBuilder UnderlyingField { get; }
    public string Name { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    [SecurityCriticalAttribute]
internal EnumBuilder(string name, Type underlyingType, TypeAttributes visibility, ModuleBuilder module);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    public TypeInfo CreateTypeInfo();
    public Type CreateType();
    public TypeToken get_TypeToken();
    public FieldBuilder get_UnderlyingField();
    public virtual string get_Name();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type GetEnumUnderlyingType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._EventBuilder")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.EventBuilder : object {
    internal EventBuilder(ModuleBuilder mod, string name, EventAttributes attr, TypeBuilder type, EventToken evToken);
    public EventToken GetEventToken();
    [SecuritySafeCriticalAttribute]
public void SetAddOnMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
public void SetRaiseMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
public void AddOtherMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.EventToken : ValueType {
    public static EventToken Empty;
    internal int m_event;
    public int Token { get; }
    internal EventToken(int str);
    private static EventToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(EventToken obj);
    public static bool op_Equality(EventToken a, EventToken b);
    public static bool op_Inequality(EventToken a, EventToken b);
}
[ComVisibleAttribute("False")]
public class System.Reflection.Emit.ExceptionHandler : ValueType {
    internal int m_exceptionClass;
    internal int m_tryStartOffset;
    internal int m_tryEndOffset;
    internal int m_filterOffset;
    internal int m_handlerStartOffset;
    internal int m_handlerEndOffset;
    internal ExceptionHandlingClauseOptions m_kind;
    public int ExceptionTypeToken { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int FilterOffset { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public ExceptionHandlingClauseOptions Kind { get; }
    public ExceptionHandler(int tryOffset, int tryLength, int filterOffset, int handlerOffset, int handlerLength, ExceptionHandlingClauseOptions kind, int exceptionTypeToken);
    internal ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
    public int get_ExceptionTypeToken();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_FilterOffset();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public ExceptionHandlingClauseOptions get_Kind();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExceptionHandler other);
    public static bool op_Equality(ExceptionHandler left, ExceptionHandler right);
    public static bool op_Inequality(ExceptionHandler left, ExceptionHandler right);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._FieldBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    [SecurityCriticalAttribute]
internal FieldBuilder(TypeBuilder typeBuilder, string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    [SecurityCriticalAttribute]
internal void SetData(Byte[] data, int size);
    internal TypeBuilder GetTypeBuilder();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public FieldToken GetToken();
    [SecuritySafeCriticalAttribute]
public void SetOffset(int iOffset);
    [ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[SecuritySafeCriticalAttribute]
public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
    [SecuritySafeCriticalAttribute]
public void SetConstant(object defaultValue);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInstantiation : FieldInfo {
    internal FieldInfo FieldInfo { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    internal FieldOnTypeBuilderInstantiation(FieldInfo field, TypeBuilderInstantiation type);
    internal static FieldInfo GetField(FieldInfo Field, TypeBuilderInstantiation type);
    internal FieldInfo get_FieldInfo();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public Type GetType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual FieldAttributes get_Attributes();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.FieldToken : ValueType {
    public static FieldToken Empty;
    internal int m_fieldTok;
    internal object m_class;
    public int Token { get; }
    internal FieldToken(int field, Type fieldClass);
    private static FieldToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(FieldToken obj);
    public static bool op_Equality(FieldToken a, FieldToken b);
    public static bool op_Inequality(FieldToken a, FieldToken b);
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class System.Reflection.Emit.GenericFieldInfo : object {
    internal RuntimeFieldHandle m_fieldHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericFieldInfo(RuntimeFieldHandle fieldHandle, RuntimeTypeHandle context);
}
internal class System.Reflection.Emit.GenericMethodInfo : object {
    internal RuntimeMethodHandle m_methodHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericMethodInfo(RuntimeMethodHandle methodHandle, RuntimeTypeHandle context);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    internal TypeBuilder m_type;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MethodBase DeclaringMethod { get; }
    internal GenericTypeParameterBuilder(TypeBuilder type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] typeArguments);
    protected virtual bool IsValueTypeImpl();
    public virtual bool IsAssignableFrom(Type c);
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    [ComVisibleAttribute("True")]
public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ILGenerator")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.ILGenerator : object {
    internal ScopeTree m_ScopeTree;
    internal LineNumberInfo m_LineNumberInfo;
    internal MethodInfo m_methodBuilder;
    internal int m_localCount;
    internal SignatureHelper m_localSignature;
    internal int CurrExcStackCount { get; }
    internal __ExceptionInfo[] CurrExcStack { get; }
    public int ILOffset { get; }
    internal ILGenerator(MethodInfo methodBuilder);
    internal ILGenerator(MethodInfo methodBuilder, int size);
    internal static Int32[] EnlargeArray(Int32[] incoming);
    internal int get_CurrExcStackCount();
    internal __ExceptionInfo[] get_CurrExcStack();
    internal virtual void RecordTokenFixup();
    internal void InternalEmit(OpCode opcode);
    internal void UpdateStackSize(OpCode opcode, int stackchange);
    [SecurityCriticalAttribute]
internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    internal Byte[] BakeByteArray();
    internal __ExceptionInfo[] GetExceptions();
    internal void EnsureCapacity(int size);
    internal void PutInteger4(int value);
    internal int GetMaxStackSize();
    internal Int32[] GetTokenFixups();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    [SecuritySafeCriticalAttribute]
public virtual void Emit(OpCode opcode, MethodInfo meth);
    [SecuritySafeCriticalAttribute]
public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void Emit(OpCode opcode, ConstructorInfo con);
    [SecuritySafeCriticalAttribute]
public virtual void Emit(OpCode opcode, Type cls);
    public virtual void Emit(OpCode opcode, long arg);
    [SecuritySafeCriticalAttribute]
public virtual void Emit(OpCode opcode, float arg);
    [SecuritySafeCriticalAttribute]
public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual Label BeginExceptionBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    public virtual void EmitWriteLine(string value);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void UsingNamespace(string usingNamespace);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual int get_ILOffset();
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.InternalAssemblyBuilder : RuntimeAssembly {
    public string Location { get; }
    public string CodeBase { get; }
    public string ImageRuntimeVersion { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_CodeBase();
    public virtual Type[] GetExportedTypes();
    public virtual string get_ImageRuntimeVersion();
}
internal class System.Reflection.Emit.InternalModuleBuilder : RuntimeModule {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    internal int GetLabelValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
internal class System.Reflection.Emit.LineNumberInfo : object {
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._LocalBuilder")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    public bool IsPinned { get; }
    public Type LocalType { get; }
    public int LocalIndex { get; }
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder);
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder, bool isPinned);
    internal int GetLocalIndex();
    internal MethodInfo GetMethodBuilder();
    public virtual bool get_IsPinned();
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public void SetLocalSymInfo(string name);
    public void SetLocalSymInfo(string name, int startOffset, int endOffset);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.LocalSymInfo : object {
    internal static int InitialSize;
    internal String[] m_strName;
    internal Byte[][] m_ubSignature;
    internal Int32[] m_iLocalSlot;
    internal Int32[] m_iStartOffset;
    internal Int32[] m_iEndOffset;
    internal int m_iLocalSymCount;
    internal String[] m_namespace;
    internal int m_iNameSpaceCount;
    internal void AddLocalSymInfo(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespace(string strNamespace);
    internal virtual void EmitLocalSymInfo(ISymbolWriter symWriter);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodBuilder")]
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    internal string m_strName;
    internal TypeBuilder m_containingType;
    internal LocalSymInfo m_localSymInfo;
    internal ILGenerator m_ilGenerator;
    internal bool m_bIsBaked;
    internal Type[] m_parameterTypes;
    internal bool m_canBeRuntimeImpl;
    internal bool m_isDllImport;
    internal int ExceptionHandlerCount { get; }
    public string Name { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool InitLocals { get; public set; }
    public string Signature { get; }
    internal MethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    internal MethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    [SecurityCriticalAttribute]
internal void CreateMethodBodyHelper(ILGenerator il);
    internal void ReleaseBakedStructures();
    internal virtual Type[] GetParameterTypes();
    internal static Type GetMethodBaseReturnType(MethodBase method);
    internal void SetToken(MethodToken token);
    internal Byte[] GetBody();
    internal Int32[] GetTokenFixups();
    [SecurityCriticalAttribute]
internal SignatureHelper GetMethodSignature();
    internal Byte[] GetLocalSignature(Int32& signatureLength);
    internal int GetMaxStack();
    internal ExceptionHandler[] GetExceptionHandlers();
    internal int get_ExceptionHandlerCount();
    internal int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal bool IsTypeCreated();
    internal TypeBuilder GetTypeBuilder();
    internal ModuleBuilder GetModuleBuilder();
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public virtual string get_Name();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Type get_ReflectedType();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    internal void ThrowIfGeneric();
    [SecuritySafeCriticalAttribute]
public MethodToken GetToken();
    public void SetParameters(Type[] parameterTypes);
    public void SetReturnType(Type returnType);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [SecuritySafeCriticalAttribute]
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
    public void SetSymCustomAttribute(string name, Byte[] data);
    [SecuritySafeCriticalAttribute]
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups);
    public void CreateMethodBody(Byte[] il, int count);
    [SecuritySafeCriticalAttribute]
public void SetImplementationFlags(MethodImplAttributes attributes);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public Module GetModule();
    [SecuritySafeCriticalAttribute]
public string get_Signature();
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.MethodBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodBuilderInstantiation(MethodInfo method, Type[] inst);
    internal static MethodInfo MakeGenericMethod(MethodInfo method, Type[] inst);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public Type GetType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] arguments);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, TypeBuilderInstantiation type);
    internal static MethodInfo GetMethod(MethodInfo method, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public Type GetType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodRental")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.MethodRental : object {
    public static int JitOnDemand;
    public static int JitImmediate;
    [SecuritySafeCriticalAttribute]
public static void SwapMethodBody(Type cls, int methodtoken, IntPtr rgIL, int methodSize, int flags);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.MethodToken : ValueType {
    public static MethodToken Empty;
    internal int m_method;
    public int Token { get; }
    internal MethodToken(int str);
    private static MethodToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(MethodToken obj);
    public static bool op_Equality(MethodToken a, MethodToken b);
    public static bool op_Inequality(MethodToken a, MethodToken b);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ModuleBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.ModuleBuilder : Module {
    internal ModuleBuilderData m_moduleData;
    internal InternalModuleBuilder m_internalModuleBuilder;
    internal AssemblyBuilder ContainingAssemblyBuilder { get; }
    internal object SyncRoot { get; }
    internal InternalModuleBuilder InternalModule { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    internal ModuleBuilder(AssemblyBuilder assemblyBuilder, InternalModuleBuilder internalModuleBuilder);
    internal static IntPtr nCreateISymWriterForDynamicModule(Module module, string filename);
    internal static string UnmangleTypeName(string typeName);
    internal AssemblyBuilder get_ContainingAssemblyBuilder();
    internal void AddType(string name, Type type);
    internal void CheckTypeNameConflict(string strTypeName, Type enclosingType);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetFieldRVAContent(RuntimeModule module, int fdToken, Byte[] data, int length);
    [SecurityCriticalAttribute]
internal void DefineNativeResource(PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
    internal virtual Type FindTypeBuilderWithName(string strTypeName, bool ignoreCase);
    internal void SetEntryPoint(MethodToken entryPoint);
    [SecurityCriticalAttribute]
internal void PreSave(string fileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
    [SecurityCriticalAttribute]
internal void Save(string fileName, bool isAssemblyFile, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
    [SecurityCriticalAttribute]
internal MethodToken InternalGetConstructorToken(ConstructorInfo con, bool usingRef);
    [SecurityCriticalAttribute]
internal void Init(string strModuleName, string strFileName, int tkFile);
    [SecurityCriticalAttribute]
internal void ModifyModuleName(string name);
    internal void SetSymWriter(ISymbolWriter writer);
    internal object get_SyncRoot();
    internal InternalModuleBuilder get_InternalModule();
    internal virtual ModuleHandle GetModuleHandle();
    internal RuntimeModule GetNativeHandle();
    [SecurityCriticalAttribute]
internal SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, IEnumerable`1<Type> optionalParameterTypes, int cGenericParameters);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetTypes();
    internal Type[] GetTypesNoLock();
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool ignoreCase);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
public virtual string get_FullyQualifiedName();
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public virtual X509Certificate GetSignerCertificate();
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name, TypeAttributes attr);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    [SecuritySafeCriticalAttribute]
public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    public IResourceWriter DefineResource(string name, string description);
    public IResourceWriter DefineResource(string name, string description, ResourceAttributes attribute);
    public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute);
    public void DefineUnmanagedResource(Byte[] resource);
    internal void DefineUnmanagedResourceInternalNoLock(Byte[] resource);
    [SecuritySafeCriticalAttribute]
public void DefineUnmanagedResource(string resourceFileName);
    [SecurityCriticalAttribute]
internal void DefineUnmanagedResourceFileInternalNoLock(string resourceFileName);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public void CreateGlobalFunctions();
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    [SecurityCriticalAttribute]
internal TypeToken GetTypeTokenInternal(Type type);
    [SecuritySafeCriticalAttribute]
public TypeToken GetTypeToken(Type type);
    public TypeToken GetTypeToken(string name);
    [SecuritySafeCriticalAttribute]
public MethodToken GetMethodToken(MethodInfo method);
    [SecurityCriticalAttribute]
internal MethodToken GetMethodTokenInternal(MethodInfo method);
    [SecuritySafeCriticalAttribute]
public MethodToken GetConstructorToken(ConstructorInfo constructor, IEnumerable`1<Type> optionalParameterTypes);
    [SecuritySafeCriticalAttribute]
public MethodToken GetMethodToken(MethodInfo method, IEnumerable`1<Type> optionalParameterTypes);
    [SecurityCriticalAttribute]
internal int GetMethodTokenInternal(MethodBase method, IEnumerable`1<Type> optionalParameterTypes, bool useMethodDef);
    [SecuritySafeCriticalAttribute]
public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public MethodToken GetConstructorToken(ConstructorInfo con);
    [SecuritySafeCriticalAttribute]
public FieldToken GetFieldToken(FieldInfo field);
    [SecuritySafeCriticalAttribute]
public StringToken GetStringConstant(string str);
    [SecuritySafeCriticalAttribute]
public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
    [SecuritySafeCriticalAttribute]
public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public ISymbolWriter GetSymWriter();
    public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    [SecuritySafeCriticalAttribute]
public void SetUserEntryPoint(MethodInfo entryPoint);
    public void SetSymCustomAttribute(string name, Byte[] data);
    public bool IsTransient();
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.ModuleBuilderData : object {
    internal static string MULTI_BYTE_VALUE_CLASS;
    internal string m_strModuleName;
    internal string m_strFileName;
    internal bool m_fGlobalBeenCreated;
    internal bool m_fHasGlobal;
    internal TypeBuilder m_globalTypeBuilder;
    internal ModuleBuilder m_module;
    internal bool m_isSaved;
    internal ResWriterData m_embeddedRes;
    internal string m_strResourceFileName;
    internal Byte[] m_resourceBytes;
    internal int FileToken { get; internal set; }
    [SecurityCriticalAttribute]
internal ModuleBuilderData(ModuleBuilder module, string strModuleName, string strFileName, int tkFile);
    [SecurityCriticalAttribute]
internal virtual void ModifyModuleName(string strModuleName);
    internal int get_FileToken();
    internal void set_FileToken(int value);
}
internal class System.Reflection.Emit.NativeVersionInfo : object {
    internal string m_strDescription;
    internal string m_strCompany;
    internal string m_strTitle;
    internal string m_strCopyright;
    internal string m_strTrademark;
    internal string m_strProduct;
    internal string m_strProductVersion;
    internal string m_strFileVersion;
    internal int m_lcid;
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.OpCode : ValueType {
    internal static int OperandTypeMask;
    internal static int FlowControlShift;
    internal static int FlowControlMask;
    internal static int OpCodeTypeShift;
    internal static int OpCodeTypeMask;
    internal static int StackBehaviourPopShift;
    internal static int StackBehaviourPushShift;
    internal static int StackBehaviourMask;
    internal static int SizeShift;
    internal static int SizeMask;
    internal static int EndsUncondJmpBlkFlag;
    internal static int StackChangeShift;
    private string m_stringname;
    private StackBehaviour m_pop;
    private StackBehaviour m_push;
    private OperandType m_operand;
    private OpCodeType m_type;
    private int m_size;
    private byte m_s1;
    private byte m_s2;
    private FlowControl m_ctrl;
    private bool m_endsUncondJmpBlk;
    private int m_stackChange;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    internal bool EndsUncondJmpBlk();
    internal int StackChange();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    [ComVisibleAttribute("True")]
public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ParameterBuilder")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.ParameterBuilder : object {
    internal int MetadataTokenInternal { get; }
    public string Name { get; }
    public int Position { get; }
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsOptional { get; }
    [SecurityCriticalAttribute]
internal ParameterBuilder(MethodBuilder methodBuilder, int sequence, ParameterAttributes attributes, string strParamName);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual void SetMarshal(UnmanagedMarshal unmanagedMarshal);
    [SecuritySafeCriticalAttribute]
public virtual void SetConstant(object defaultValue);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual ParameterToken GetToken();
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal int get_MetadataTokenInternal();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsOptional();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.ParameterToken : ValueType {
    public static ParameterToken Empty;
    internal int m_tkParameter;
    public int Token { get; }
    internal ParameterToken(int tkParam);
    private static ParameterToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ParameterToken obj);
    public static bool op_Equality(ParameterToken a, ParameterToken b);
    public static bool op_Inequality(ParameterToken a, ParameterToken b);
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._PropertyBuilder")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    public PropertyToken PropertyToken { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal PropertyBuilder(ModuleBuilder mod, string name, SignatureHelper sig, PropertyAttributes attr, Type returnType, PropertyToken prToken, TypeBuilder containingType);
    [SecuritySafeCriticalAttribute]
public void SetConstant(object defaultValue);
    public PropertyToken get_PropertyToken();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    [SecuritySafeCriticalAttribute]
public void SetGetMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
public void SetSetMethod(MethodBuilder mdBuilder);
    [SecuritySafeCriticalAttribute]
public void AddOtherMethod(MethodBuilder mdBuilder);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.PropertyToken : ValueType {
    public static PropertyToken Empty;
    internal int m_property;
    public int Token { get; }
    internal PropertyToken(int str);
    private static PropertyToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PropertyToken obj);
    public static bool op_Equality(PropertyToken a, PropertyToken b);
    public static bool op_Inequality(PropertyToken a, PropertyToken b);
}
internal class System.Reflection.Emit.REDocument : object {
    internal ISymbolDocumentWriter m_document;
    internal REDocument(ISymbolDocumentWriter document);
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
internal class System.Reflection.Emit.ResWriterData : object {
    internal ResourceWriter m_resWriter;
    internal string m_strName;
    internal string m_strFileName;
    internal string m_strFullFileName;
    internal Stream m_memoryStream;
    internal ResWriterData m_nextResWriter;
    internal ResourceAttributes m_attribute;
    internal ResWriterData(ResourceWriter resWriter, Stream memoryStream, string strName, string strFileName, string strFullFileName, ResourceAttributes attribute);
}
internal enum System.Reflection.Emit.ScopeAction : Enum {
    public int value__;
    public static ScopeAction Open;
    public static ScopeAction Close;
}
internal class System.Reflection.Emit.ScopeTree : object {
    internal static int InitialSize;
    internal Int32[] m_iOffsets;
    internal ScopeAction[] m_ScopeActions;
    internal int m_iCount;
    internal int m_iOpenScopeCount;
    internal LocalSymInfo[] m_localSymInfos;
    internal int GetCurrentActiveScopeIndex();
    internal void AddLocalSymInfoToCurrentScope(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespaceToCurrentScope(string strNamespace);
    internal void AddScopeInfo(ScopeAction sa, int iOffset);
    internal void EnsureCapacity();
    internal void EmitScopeTree(ISymbolWriter symWriter);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._SignatureHelper")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.SignatureHelper : object {
    internal int ArgumentCount { get; }
    [SecuritySafeCriticalAttribute]
public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [SecurityCriticalAttribute]
internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType, int cGenericParam);
    [SecuritySafeCriticalAttribute]
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    internal static SignatureHelper GetMethodSpecSigHelper(Module scope, Type[] inst);
    [SecurityCriticalAttribute]
internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [SecurityCriticalAttribute]
internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, int cGenericParam, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [SecuritySafeCriticalAttribute]
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [SecuritySafeCriticalAttribute]
public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [SecurityCriticalAttribute]
internal static SignatureHelper GetTypeSigToken(Module mod, Type type);
    internal int get_ArgumentCount();
    internal static bool IsSimpleType(CorElementType type);
    internal Byte[] InternalGetSignature(Int32& length);
    internal Byte[] InternalGetSignatureArray();
    public void AddArgument(Type clsArgument);
    [SecuritySafeCriticalAttribute]
public void AddArgument(Type argument, bool pinned);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    [SecuritySafeCriticalAttribute]
public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddSentinel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetSignature();
    internal Byte[] GetSignature(bool appendEndOfSig);
    public virtual string ToString();
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.SignatureToken : ValueType {
    public static SignatureToken Empty;
    internal int m_signature;
    internal ModuleBuilder m_moduleBuilder;
    public int Token { get; }
    internal SignatureToken(int str, ModuleBuilder mod);
    private static SignatureToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SignatureToken obj);
    public static bool op_Equality(SignatureToken a, SignatureToken b);
    public static bool op_Inequality(SignatureToken a, SignatureToken b);
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.StringToken : ValueType {
    internal int m_string;
    public int Token { get; }
    internal StringToken(int str);
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(StringToken obj);
    public static bool op_Equality(StringToken a, StringToken b);
    public static bool op_Inequality(StringToken a, StringToken b);
}
internal class System.Reflection.Emit.SymbolMethod : MethodInfo {
    public Module Module { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    [SecurityCriticalAttribute]
internal SymbolMethod(ModuleBuilder mod, MethodToken token, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    internal virtual Type[] GetParameterTypes();
    internal MethodToken GetToken(ModuleBuilder mod);
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public Module GetModule();
    public MethodToken GetToken();
}
internal class System.Reflection.Emit.SymbolType : TypeInfo {
    internal TypeKind m_typeKind;
    internal Type m_baseType;
    internal int m_cRank;
    internal Int32[] m_iaLowerBound;
    internal Int32[] m_iaUpperBound;
    internal bool IsSzArray { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    internal SymbolType(TypeKind typeKind);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type FormCompoundType(Char[] bFormat, Type baseType, int curIndex);
    internal void SetElementType(Type baseType);
    internal void SetFormat(Char[] bFormat, int curIndex, int length);
    internal virtual bool get_IsSzArray();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual int GetArrayRank();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._TypeBuilder")]
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    internal List`1<MethodBuilder> m_listMethods;
    internal int m_lastTokenizedMethod;
    internal bool m_isHiddenGlobalType;
    internal object SyncRoot { get; }
    internal RuntimeType BakedRuntimeType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type UnderlyingSystemType { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    public int Size { get; }
    public PackingSize PackingSize { get; }
    public TypeToken TypeToken { get; }
    internal TypeBuilder(ModuleBuilder module);
    internal TypeBuilder(string szName, int genParamPos, MethodBuilder declMeth);
    [SecurityCriticalAttribute]
internal TypeBuilder(string name, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    public static FieldInfo GetField(Type type, FieldInfo field);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int DefineMethod(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, MethodAttributes attributes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineMethodSpec(RuntimeModule module, int tkParent, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int DefineField(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, FieldAttributes attributes);
    [SecurityCriticalAttribute]
internal static void DefineCustomAttribute(ModuleBuilder module, int tkAssociate, int tkConstructor, Byte[] attr, bool toDisk, bool updateCompilerFlags);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetPInvokeData(RuntimeModule module, string DllName, string name, int token, int linkFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineProperty(RuntimeModule module, int tkParent, string name, PropertyAttributes attributes, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int DefineEvent(RuntimeModule module, int tkParent, string name, EventAttributes attributes, int tkEventType);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void DefineMethodSemantics(RuntimeModule module, int tkAssociation, MethodSemanticsAttributes semantics, int tkMethod);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void DefineMethodImpl(RuntimeModule module, int tkType, int tkBody, int tkDecl);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetMethodImpl(RuntimeModule module, int tkMethod, MethodImplAttributes MethodImplAttributes);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int SetParamInfo(RuntimeModule module, int tkMethod, int iSequence, ParameterAttributes iParamAttributes, string strParamName);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int GetTokenFromSig(RuntimeModule module, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetFieldLayoutOffset(RuntimeModule module, int fdToken, int iOffset);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetClassLayout(RuntimeModule module, int tk, PackingSize iPackingSize, int iTypeSize);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetFieldMarshal(RuntimeModule module, int tk, Byte[] ubMarshal, int ubSize);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void AddDeclarativeSecurity(RuntimeModule module, int parent, SecurityAction action, Byte[] blob, int cb);
    internal static bool IsTypeEqual(Type t1, Type t2);
    [SecurityCriticalAttribute]
internal static void SetConstantValue(ModuleBuilder module, int tk, Type destType, object value);
    public bool IsCreated();
    internal void ThrowIfCreated();
    internal object get_SyncRoot();
    internal ModuleBuilder GetModuleBuilder();
    internal RuntimeType get_BakedRuntimeType();
    internal void SetGenParamAttributes(GenericParameterAttributes genericParameterAttributes);
    internal void SetGenParamCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void SetGenParamCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal void SetInterfaces(Type[] interfaces);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    [SecuritySafeCriticalAttribute]
public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public ConstructorBuilder DefineTypeInitializer();
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    [SecuritySafeCriticalAttribute]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [SecuritySafeCriticalAttribute]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [SecuritySafeCriticalAttribute]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    [SecuritySafeCriticalAttribute]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    [SecuritySafeCriticalAttribute]
public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    [SecuritySafeCriticalAttribute]
public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    [SecuritySafeCriticalAttribute]
public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [SecuritySafeCriticalAttribute]
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [SecuritySafeCriticalAttribute]
public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    [SecuritySafeCriticalAttribute]
public TypeInfo CreateTypeInfo();
    [SecuritySafeCriticalAttribute]
public Type CreateType();
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    public int get_Size();
    public PackingSize get_PackingSize();
    public void SetParent(Type parent);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public void AddInterfaceImplementation(Type interfaceType);
    [SecuritySafeCriticalAttribute]
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    public TypeToken get_TypeToken();
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [SecuritySafeCriticalAttribute]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    internal Hashtable m_hashtable;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] inst);
    public virtual bool IsAssignableFrom(Type c);
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
internal class System.Reflection.Emit.TypeNameBuilder : object {
    [SecuritySafeCriticalAttribute]
internal static string ToString(Type type, Format format);
    [SecurityCriticalAttribute]
internal void Dispose();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.TypeToken : ValueType {
    public static TypeToken Empty;
    internal int m_class;
    public int Token { get; }
    internal TypeToken(int str);
    private static TypeToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(TypeToken obj);
    public static bool op_Equality(TypeToken a, TypeToken b);
    public static bool op_Inequality(TypeToken a, TypeToken b);
}
[ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.UnmanagedMarshal : object {
    internal UnmanagedType m_unmanagedType;
    internal Guid m_guid;
    internal int m_numElem;
    internal UnmanagedType m_baseType;
    public UnmanagedType GetUnmanagedType { get; }
    public Guid IIDGuid { get; }
    public int ElementCount { get; }
    public UnmanagedType BaseType { get; }
    public static UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType);
    public static UnmanagedMarshal DefineByValTStr(int elemCount);
    public static UnmanagedMarshal DefineSafeArray(UnmanagedType elemType);
    public static UnmanagedMarshal DefineByValArray(int elemCount);
    public static UnmanagedMarshal DefineLPArray(UnmanagedType elemType);
    public UnmanagedType get_GetUnmanagedType();
    public Guid get_IIDGuid();
    public int get_ElementCount();
    public UnmanagedType get_BaseType();
    internal Byte[] InternalGetBytes();
}
internal class System.Reflection.Emit.VarArgMethod : object {
    internal RuntimeMethodInfo m_method;
    internal DynamicMethod m_dynamicMethod;
    internal SignatureHelper m_signature;
    internal VarArgMethod(DynamicMethod dm, SignatureHelper signature);
    internal VarArgMethod(RuntimeMethodInfo method, SignatureHelper signature);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes ReservedMask;
    public static EventAttributes RTSpecialName;
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._EventInfo")]
[ComVisibleAttribute("True")]
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public Type EventHandlerType { get; }
    public bool IsSpecialName { get; }
    public bool IsMulticast { get; }
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual MemberTypes get_MemberType();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public abstract virtual EventAttributes get_Attributes();
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo[] GetOtherMethods();
    public sealed virtual MethodInfo GetAddMethod();
    public sealed virtual MethodInfo GetRemoveMethod();
    public sealed virtual MethodInfo GetRaiseMethod();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual Type get_EventHandlerType();
    public sealed virtual bool get_IsSpecialName();
    public virtual bool get_IsMulticast();
    private sealed virtual override Type System.Runtime.InteropServices._EventInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.ExceptionHandlingClause : object {
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes ReservedMask;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._FieldInfo")]
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsSpecialName { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    [ComVisibleAttribute("False")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual MemberTypes get_MemberType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public abstract virtual Type get_FieldType();
    public abstract virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public abstract virtual FieldAttributes get_Attributes();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual void SetValue(object obj, object value);
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsPinvokeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    private sealed virtual override Type System.Runtime.InteropServices._FieldInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
[ComVisibleAttribute("True")]
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
[ComVisibleAttribute("True")]
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
[ComVisibleAttribute("True")]
public class System.Reflection.InterfaceMapping : ValueType {
    [ComVisibleAttribute("True")]
public Type TargetType;
    [ComVisibleAttribute("True")]
public Type InterfaceType;
    [ComVisibleAttribute("True")]
public MethodInfo[] TargetMethods;
    [ComVisibleAttribute("True")]
public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
[ComVisibleAttribute("True")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Reflection.INVOCATION_FLAGS : Enum {
    public UInt32 value__;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_UNKNOWN;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_INITIALIZED;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NEED_SECURITY;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_CTOR_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_RISKY_METHOD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NON_W8P_FX_API;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_DELEGATE_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONTAINS_STACK_POINTERS;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_SPECIAL_FIELD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_FIELD_SPECIAL_CAST;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONSTRUCTOR_INVOKE;
}
[GuidAttribute("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
[ComVisibleAttribute("True")]
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
internal enum System.Reflection.LoadContext : Enum {
    public int value__;
    public static LoadContext DEFAULT;
    public static LoadContext LOADFROM;
    public static LoadContext UNKNOWN;
    public static LoadContext HOSTED;
}
internal class System.Reflection.LoaderAllocator : object {
    internal CerHashtable`2<RuntimeMethodInfo, RuntimeMethodInfo> m_methodInstantiations;
}
internal class System.Reflection.LoaderAllocatorScout : object {
    internal IntPtr m_nativeLoaderAllocator;
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
}
[ComVisibleAttribute("True")]
public class System.Reflection.LocalVariableInfo : object {
    public Type LocalType { get; }
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public virtual string ToString();
    public virtual Type get_LocalType();
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
}
[ComVisibleAttribute("True")]
public class System.Reflection.ManifestResourceInfo : object {
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    public virtual Assembly get_ReferencedAssembly();
    public virtual string get_FileName();
    public virtual ResourceLocation get_ResourceLocation();
}
internal static class System.Reflection.MdConstant : object {
    [SecurityCriticalAttribute]
public static object GetValue(MetadataImport scope, int token, RuntimeTypeHandle fieldTypeHandle, bool raw);
}
internal class System.Reflection.MdFieldInfo : RuntimeFieldInfo {
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type FieldType { get; }
    internal MdFieldInfo(int tkField, FieldAttributes fieldAttributes, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    [ReliabilityContractAttribute("3", "2")]
internal virtual bool CacheEquals(object o);
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
[FlagsAttribute]
internal enum System.Reflection.MdSigCallingConvention : Enum {
    public byte value__;
    public static MdSigCallingConvention CallConvMask;
    public static MdSigCallingConvention Default;
    public static MdSigCallingConvention C;
    public static MdSigCallingConvention StdCall;
    public static MdSigCallingConvention ThisCall;
    public static MdSigCallingConvention FastCall;
    public static MdSigCallingConvention Vararg;
    public static MdSigCallingConvention Field;
    public static MdSigCallingConvention LocalSig;
    public static MdSigCallingConvention Property;
    public static MdSigCallingConvention Unmgd;
    public static MdSigCallingConvention GenericInst;
    public static MdSigCallingConvention Generic;
    public static MdSigCallingConvention HasThis;
    public static MdSigCallingConvention ExplicitThis;
}
[ComVisibleAttribute("True")]
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MemberInfo")]
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    internal virtual bool CacheEquals(object o);
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    private sealed virtual override Type System.Runtime.InteropServices._MemberInfo.GetType();
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(MemberInfo left, MemberInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Reflection.MemberInfoSerializationHolder : object {
    internal MemberInfoSerializationHolder(SerializationInfo info, StreamingContext context);
    public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, MemberTypes type);
    public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, string signature2, MemberTypes type, Type[] genericArguments);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.MetadataEnumResult : ValueType {
    private Int32[] largeResult;
    private int length;
    [FixedBufferAttribute("System.Int32", "16")]
private <smallResult>e__FixedBuffer0 smallResult;
    public int Length { get; }
    public int Item { get; }
    public int get_Length();
    [SecurityCriticalAttribute]
public int get_Item(int index);
}
internal class System.Reflection.MetadataException : Exception {
    internal MetadataException(int hr);
    public virtual string ToString();
}
internal class System.Reflection.MetadataImport : ValueType {
    private IntPtr m_metadataImport2;
    private object m_keepalive;
    internal static MetadataImport EmptyImport;
    internal MetadataImport(IntPtr metadataImport2, object keepalive);
    private static MetadataImport();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [SecurityCriticalAttribute]
internal static void GetMarshalAs(ConstArray nativeType, UnmanagedType& unmanagedType, VarEnum& safeArraySubType, String& safeArrayUserDefinedSubType, UnmanagedType& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void ThrowError(int hResult);
    [SecurityCriticalAttribute]
public void Enum(MetadataTokenType type, int parent, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumNestedTypes(int mdTypeDef, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumCustomAttributes(int mdToken, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumParams(int mdMethodDef, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumFields(int mdTypeDef, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumProperties(int mdTypeDef, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public void EnumEvents(int mdTypeDef, MetadataEnumResult& result);
    [SecurityCriticalAttribute]
public string GetDefaultValue(int mdToken, Int64& value, Int32& length, CorElementType& corElementType);
    [SecurityCriticalAttribute]
public string GetUserString(int mdToken);
    [SecurityCriticalAttribute]
public Utf8String GetName(int mdToken);
    [SecurityCriticalAttribute]
public Utf8String GetNamespace(int mdToken);
    [SecurityCriticalAttribute]
public void GetEventProps(int mdToken, Void*& name, EventAttributes& eventAttributes);
    [SecurityCriticalAttribute]
public void GetFieldDefProps(int mdToken, FieldAttributes& fieldAttributes);
    [SecurityCriticalAttribute]
public void GetPropertyProps(int mdToken, Void*& name, PropertyAttributes& propertyAttributes, ConstArray& signature);
    [SecurityCriticalAttribute]
public int GetParentToken(int tkToken);
    [SecurityCriticalAttribute]
public void GetParamDefProps(int parameterToken, Int32& sequence, ParameterAttributes& attributes);
    [SecurityCriticalAttribute]
public void GetGenericParamProps(int genericParameter, GenericParameterAttributes& attributes);
    [SecurityCriticalAttribute]
public void GetScopeProps(Guid& mvid);
    [SecurityCriticalAttribute]
public ConstArray GetMethodSignature(MetadataToken token);
    [SecurityCriticalAttribute]
public ConstArray GetSigOfMethodDef(int methodToken);
    [SecurityCriticalAttribute]
public ConstArray GetSignatureFromToken(int token);
    [SecurityCriticalAttribute]
public ConstArray GetMemberRefProps(int memberTokenRef);
    [SecurityCriticalAttribute]
public void GetCustomAttributeProps(int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    [SecurityCriticalAttribute]
public void GetClassLayout(int typeTokenDef, Int32& packSize, Int32& classSize);
    [SecurityCriticalAttribute]
public bool GetFieldOffset(int typeTokenDef, int fieldTokenDef, Int32& offset);
    [SecurityCriticalAttribute]
public ConstArray GetSigOfFieldDef(int fieldToken);
    [SecurityCriticalAttribute]
public ConstArray GetFieldMarshal(int fieldToken);
    [SecurityCriticalAttribute]
public void GetPInvokeMap(int token, PInvokeAttributes& attributes, String& importName, String& importDll);
    [SecurityCriticalAttribute]
public bool IsValidToken(int token);
}
internal class System.Reflection.MetadataToken : ValueType {
    public int Value;
    public bool IsGlobalTypeDefToken { get; }
    public MetadataTokenType TokenType { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeDef { get; }
    public bool IsFieldDef { get; }
    public bool IsMethodDef { get; }
    public bool IsMemberRef { get; }
    public bool IsEvent { get; }
    public bool IsProperty { get; }
    public bool IsParamDef { get; }
    public bool IsTypeSpec { get; }
    public bool IsMethodSpec { get; }
    public bool IsString { get; }
    public bool IsSignature { get; }
    public bool IsModule { get; }
    public bool IsAssembly { get; }
    public bool IsGenericPar { get; }
    public MetadataToken(int token);
    public static int op_Implicit(MetadataToken token);
    public static MetadataToken op_Implicit(int token);
    public static bool IsTokenOfType(int token, MetadataTokenType[] types);
    public static bool IsNullToken(int token);
    public bool get_IsGlobalTypeDefToken();
    public MetadataTokenType get_TokenType();
    public bool get_IsTypeRef();
    public bool get_IsTypeDef();
    public bool get_IsFieldDef();
    public bool get_IsMethodDef();
    public bool get_IsMemberRef();
    public bool get_IsEvent();
    public bool get_IsProperty();
    public bool get_IsParamDef();
    public bool get_IsTypeSpec();
    public bool get_IsMethodSpec();
    public bool get_IsString();
    public bool get_IsSignature();
    public bool get_IsModule();
    public bool get_IsAssembly();
    public bool get_IsGenericPar();
    public virtual string ToString();
}
internal enum System.Reflection.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldDef;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamDef;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType Permission;
    public static MetadataTokenType Signature;
    public static MetadataTokenType Event;
    public static MetadataTokenType Property;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType GenericPar;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType String;
    public static MetadataTokenType Name;
    public static MetadataTokenType BaseType;
    public static MetadataTokenType Invalid;
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes ReservedMask;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodBase")]
public abstract class System.Reflection.MethodBase : MemberInfo {
    internal bool IsDynamicallyInvokable { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }
    private bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsFinal { get; }
    public bool IsVirtual { get; }
    public bool IsHideBySig { get; }
    public bool IsAbstract { get; }
    public bool IsSpecialName { get; }
    [ComVisibleAttribute("True")]
public bool IsConstructor { get; }
    internal string FullName { get; }
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    [ComVisibleAttribute("False")]
public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public static MethodBase GetCurrentMethod();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool get_IsDynamicallyInvokable();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public abstract virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    [ComVisibleAttribute("True")]
public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    private sealed virtual override Type System.Runtime.InteropServices._MethodBase.GetType();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsPublic();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsPrivate();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsFamily();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsAssembly();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsFamilyAndAssembly();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsFamilyOrAssembly();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsStatic();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsFinal();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsVirtual();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsHideBySig();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsAbstract();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsSpecialName();
    private sealed virtual override bool System.Runtime.InteropServices._MethodBase.get_IsConstructor();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public sealed virtual object Invoke(object obj, Object[] parameters);
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsConstructor();
    [SecuritySafeCriticalAttribute]
public virtual MethodBody GetMethodBody();
    internal static string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization);
    internal string get_FullName();
    internal string FormatNameAndSig();
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual Type[] GetParameterTypes();
    [SecuritySafeCriticalAttribute]
internal Object[] CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.MethodBody : object {
    internal MethodBase m_methodBase;
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
[ComVisibleAttribute("True")]
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    [ComVisibleAttribute("False")]
public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodInfo")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(MethodInfo left, MethodInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public abstract virtual MethodInfo GetBaseDefinition();
    [ComVisibleAttribute("True")]
public virtual Type[] GetGenericArguments();
    [ComVisibleAttribute("True")]
public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    private sealed virtual override Type System.Runtime.InteropServices._MethodInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
[ComVisibleAttribute("True")]
public class System.Reflection.Missing : object {
    public static Missing Value;
    private static Missing();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Module")]
[ComVisibleAttribute("True")]
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MDStreamVersion { get; }
    public string FullyQualifiedName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    public ModuleHandle ModuleHandle { get; }
    private static Module();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool ignoreCase);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual string get_FullyQualifiedName();
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Type[] GetTypes();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public ModuleHandle get_ModuleHandle();
    internal virtual ModuleHandle GetModuleHandle();
    public virtual X509Certificate GetSignerCertificate();
    private sealed virtual override void System.Runtime.InteropServices._Module.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Module.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Module.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    public bool get_AssemblyIsPrivate();
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
    public bool get_Exclude();
    public void set_Exclude(bool value);
    public bool get_ApplyToMembers();
    public void set_ApplyToMembers(bool value);
    public string get_Feature();
    public void set_Feature(string value);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes ReservedMask;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ParameterInfo")]
public class System.Reflection.ParameterInfo : object {
    protected string NameImpl;
    protected Type ClassImpl;
    protected int PositionImpl;
    protected ParameterAttributes AttrsImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    public Type ParameterType { get; }
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int Position { get; }
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsLcid { get; }
    public bool IsRetval { get; }
    public bool IsOptional { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal void SetName(string name);
    internal void SetAttributes(ParameterAttributes attributes);
    public virtual Type get_ParameterType();
    public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual int get_Position();
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsLcid();
    public bool get_IsRetval();
    public bool get_IsOptional();
    public virtual int get_MetadataToken();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual string ToString();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    internal Boolean[] IsByRefArray { get; }
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    internal Boolean[] get_IsByRefArray();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    [SecurityCriticalAttribute]
public static object Box(Void* ptr, Type type);
    [SecurityCriticalAttribute]
public static Void* Unbox(object ptr);
    internal RuntimeType GetPointerType();
    [SecurityCriticalAttribute]
internal object GetPointerValue();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    [ComVisibleAttribute("False")]
public static PortableExecutableKinds Preferred32Bit;
}
[ComVisibleAttribute("True")]
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes ReservedMask;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._PropertyInfo")]
[ClassInterfaceAttribute("0")]
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public bool IsSpecialName { get; }
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual MemberTypes get_MemberType();
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public abstract virtual Type get_PropertyType();
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public void SetValue(object obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual MethodInfo[] GetAccessors();
    public virtual MethodInfo get_GetMethod();
    public virtual MethodInfo get_SetMethod();
    public sealed virtual MethodInfo GetGetMethod();
    public sealed virtual MethodInfo GetSetMethod();
    public sealed virtual bool get_IsSpecialName();
    private sealed virtual override Type System.Runtime.InteropServices._PropertyInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal static class System.Reflection.PseudoCustomAttribute : object {
    [SecurityCriticalAttribute]
private static PseudoCustomAttribute();
    [SecurityCriticalAttribute]
internal static void GetSecurityAttributes(RuntimeModule module, int token, bool assembly, Object[]& securityAttributes);
    internal static bool IsSecurityAttribute(RuntimeType type);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool includeSecCa, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeType type, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool includeSecCa, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType, bool includeSecCa, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeModule module, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    [SecurityCriticalAttribute]
internal static Attribute[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType, bool includeSecCa, Int32& count);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
}
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
[ComVisibleAttribute("True")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    public Type[] Types { get; }
    public Exception[] LoaderExceptions { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    internal ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    public Type[] get_Types();
    public Exception[] get_LoaderExceptions();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation Embedded;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
}
internal class System.Reflection.RtFieldInfo : RuntimeFieldInfo {
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    public string Name { get; }
    internal string FullName { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    [SecurityCriticalAttribute]
internal RtFieldInfo(RuntimeFieldHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    [SecuritySafeCriticalAttribute]
private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
    internal void CheckConsistency(object target);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
internal virtual bool CacheEquals(object o);
    [DebuggerStepThroughAttribute]
[SecurityCriticalAttribute]
[DebuggerHiddenAttribute]
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerHiddenAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
internal object InternalGetValue(object obj, StackCrawlMark& stackMark);
    [DebuggerHiddenAttribute]
[SecurityCriticalAttribute]
[DebuggerStepThroughAttribute]
internal object UnsafeGetValue(object obj);
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    internal string get_FullName();
    [SecuritySafeCriticalAttribute]
public virtual int get_MetadataToken();
    [SecuritySafeCriticalAttribute]
internal virtual RuntimeModule GetRuntimeModule();
    public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    [DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerHiddenAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
[SecuritySafeCriticalAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual RuntimeFieldHandle get_FieldHandle();
    internal IntPtr GetFieldHandle();
    public virtual FieldAttributes get_Attributes();
    [SecuritySafeCriticalAttribute]
public virtual Type get_FieldType();
    [SecuritySafeCriticalAttribute]
public virtual Type[] GetRequiredCustomModifiers();
    [SecuritySafeCriticalAttribute]
public virtual Type[] GetOptionalCustomModifiers();
}
[ForceTokenStabilizationAttribute]
internal class System.Reflection.RuntimeAssembly : Assembly {
    internal int InvocableAttributeCtorToken { get; }
    internal object SyncRoot { get; }
    public string CodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public Evidence Evidence { get; }
    internal Evidence EvidenceNoDemand { get; }
    public PermissionSet PermissionSet { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public Module ManifestModule { get; }
    [ComVisibleAttribute("False")]
public bool ReflectionOnly { get; }
    public string Location { get; }
    [ComVisibleAttribute("False")]
public string ImageRuntimeVersion { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    internal bool IsStrongNameVerified { get; }
    public bool IsDynamic { get; }
    private static RuntimeAssembly();
    [SecurityCriticalAttribute]
private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    internal int get_InvocableAttributeCtorToken();
    internal object get_SyncRoot();
    [SecurityCriticalAttribute]
public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [SecurityCriticalAttribute]
public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    [SecurityCriticalAttribute]
internal string GetCodeBase(bool copiedName);
    [SecuritySafeCriticalAttribute]
public virtual string get_CodeBase();
    internal RuntimeAssembly GetNativeHandle();
    [SecuritySafeCriticalAttribute]
public virtual AssemblyName GetName(bool copiedName);
    [SecuritySafeCriticalAttribute]
public virtual string get_FullName();
    [SecuritySafeCriticalAttribute]
public virtual MethodInfo get_EntryPoint();
    [SecuritySafeCriticalAttribute]
public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void GetForwardedTypes(RuntimeAssembly assembly, ObjectHandleOnStack retTypes);
    [SecuritySafeCriticalAttribute]
public virtual Type[] GetExportedTypes();
    [SecuritySafeCriticalAttribute]
public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    [SecuritySafeCriticalAttribute]
public virtual Stream GetManifestResourceStream(Type type, string name);
    [SecuritySafeCriticalAttribute]
public virtual Stream GetManifestResourceStream(string name);
    [SecuritySafeCriticalAttribute]
public virtual Evidence get_Evidence();
    [SecurityCriticalAttribute]
internal Evidence get_EvidenceNoDemand();
    [SecurityCriticalAttribute]
public virtual PermissionSet get_PermissionSet();
    [SecuritySafeCriticalAttribute]
public virtual SecurityRuleSet get_SecurityRuleSet();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Module get_ManifestModule();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [SecurityCriticalAttribute]
internal static RuntimeAssembly InternalLoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm, bool forIntrospection, bool suppressSecurityChecks, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly InternalLoad(string assemblyString, Evidence assemblySecurity, StackCrawlMark& stackMark, bool forIntrospection);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly InternalLoad(string assemblyString, Evidence assemblySecurity, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool forIntrospection);
    [SecurityCriticalAttribute]
internal static AssemblyName CreateAssemblyName(string assemblyString, bool forIntrospection, RuntimeAssembly& assemblyFromResolveEvent);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks);
    [SecuritySafeCriticalAttribute]
internal bool IsFrameworkAssembly();
    internal bool IsSafeForReflection();
    [SecurityCriticalAttribute]
internal static bool IsNewPortableAssembly(AssemblyName assemblyName);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly LoadWithPartialNameInternal(string partialName, Evidence securityEvidence, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly LoadWithPartialNameInternal(AssemblyName an, Evidence securityEvidence, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public virtual bool get_ReflectionOnly();
    [SecuritySafeCriticalAttribute]
public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    [SecuritySafeCriticalAttribute]
public virtual Module GetModule(string name);
    [SecuritySafeCriticalAttribute]
public virtual FileStream GetFile(string name);
    [SecuritySafeCriticalAttribute]
public virtual FileStream[] GetFiles(bool getResourceModules);
    [SecuritySafeCriticalAttribute]
public virtual String[] GetManifestResourceNames();
    [SecurityCriticalAttribute]
internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public virtual AssemblyName[] GetReferencedAssemblies();
    [SecuritySafeCriticalAttribute]
public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    [SecuritySafeCriticalAttribute]
public virtual string get_Location();
    [SecuritySafeCriticalAttribute]
public virtual string get_ImageRuntimeVersion();
    [SecuritySafeCriticalAttribute]
public virtual bool get_GlobalAssemblyCache();
    [SecuritySafeCriticalAttribute]
public virtual long get_HostContext();
    [SecurityCriticalAttribute]
internal Stream GetManifestResourceStream(Type type, string name, bool skipSecurityCheck, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal bool get_IsStrongNameVerified();
    [SecurityCriticalAttribute]
internal Stream GetManifestResourceStream(string name, StackCrawlMark& stackMark, bool skipSecurityCheck);
    [SecurityCriticalAttribute]
internal Version GetVersion();
    [SecurityCriticalAttribute]
internal CultureInfo GetLocale();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsDynamic();
    [SecuritySafeCriticalAttribute]
internal string GetSimpleName();
    [SecuritySafeCriticalAttribute]
internal Byte[] GetRawBytes();
    [SecurityCriticalAttribute]
internal Byte[] GetPublicKey();
    [SecurityCriticalAttribute]
internal void GetGrantSet(PermissionSet& newGrant, PermissionSet& newDenied);
    [SecuritySafeCriticalAttribute]
internal bool IsAllSecurityCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsAllSecuritySafeCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsAllPublicAreaSecuritySafeCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsAllSecurityTransparent();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    [SecuritySafeCriticalAttribute]
internal Assembly InternalGetSatelliteAssembly(CultureInfo culture, Version version, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal RuntimeAssembly InternalGetSatelliteAssembly(string name, CultureInfo culture, Version version, bool throwOnFileNotFound, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly nLoadFile(string path, Evidence evidence);
    [SecurityCriticalAttribute]
internal static RuntimeAssembly nLoadImage(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence evidence, StackCrawlMark& stackMark, bool fIntrospection, SecurityContextSource securityContextSource);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    [SecuritySafeCriticalAttribute]
internal static RuntimeModule GetManifestModule(RuntimeAssembly assembly);
    [SecuritySafeCriticalAttribute]
internal static bool AptcaCheck(RuntimeAssembly targetAssembly, RuntimeAssembly sourceAssembly);
    [SecurityCriticalAttribute]
internal static int GetToken(RuntimeAssembly assembly);
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    internal bool IsDynamicallyInvokable { get; }
    internal INVOCATION_FLAGS InvocationFlags { get; }
    internal RemotingMethodCachedData RemotingCache { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    internal BindingFlags BindingFlags { get; }
    internal bool IsOverloaded { get; }
    public string Name { get; }
    [ComVisibleAttribute("True")]
public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool ContainsGenericParameters { get; }
    [SecurityCriticalAttribute]
internal RuntimeConstructorInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags);
    internal virtual bool get_IsDynamicallyInvokable();
    [SecuritySafeCriticalAttribute]
internal INVOCATION_FLAGS get_InvocationFlags();
    internal RemotingMethodCachedData get_RemotingCache();
    [SecuritySafeCriticalAttribute]
private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal virtual bool CacheEquals(object o);
    internal BindingFlags get_BindingFlags();
    internal RuntimeMethodHandle GetMethodHandle();
    internal bool get_IsOverloaded();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    [SecuritySafeCriticalAttribute]
public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal RuntimeAssembly GetRuntimeAssembly();
    internal virtual Type GetReturnType();
    [SecuritySafeCriticalAttribute]
internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    internal static void CheckCanCreateInstance(Type declaringType, bool isVarArg);
    internal void ThrowNoInvokeException();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public virtual MethodBody GetMethodBody();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    internal void SerializationInvoke(object target, SerializationInfo info, StreamingContext context);
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public EventAttributes Attributes { get; }
    [SecurityCriticalAttribute]
internal RuntimeEventInfo(int tkEvent, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    [ReliabilityContractAttribute("3", "2")]
internal virtual bool CacheEquals(object o);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual EventAttributes get_Attributes();
}
internal abstract class System.Reflection.RuntimeFieldInfo : FieldInfo {
    protected RuntimeTypeCache m_reflectedTypeCache;
    protected RuntimeType m_declaringType;
    internal RemotingFieldCachedData RemotingCache { get; }
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    protected RuntimeFieldInfo(RuntimeTypeCache reflectedTypeCache, RuntimeType declaringType, BindingFlags bindingFlags);
    internal RemotingFieldCachedData get_RemotingCache();
    internal BindingFlags get_BindingFlags();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeType GetRuntimeType();
    internal abstract virtual RuntimeModule GetRuntimeModule();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    internal bool IsDynamicallyInvokable { get; }
    internal INVOCATION_FLAGS InvocationFlags { get; }
    internal RemotingMethodCachedData RemotingCache { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    internal bool IsOverloaded { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    [SecurityCriticalAttribute]
internal RuntimeMethodInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags, object keepalive);
    internal virtual bool get_IsDynamicallyInvokable();
    [SecuritySafeCriticalAttribute]
internal INVOCATION_FLAGS get_InvocationFlags();
    internal RemotingMethodCachedData get_RemotingCache();
    [SecuritySafeCriticalAttribute]
private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    internal virtual string FormatNameAndSig(bool serialization);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal BindingFlags get_BindingFlags();
    internal RuntimeMethodHandle GetMethodHandle();
    [SecuritySafeCriticalAttribute]
internal RuntimeMethodInfo GetParentDefinition();
    internal RuntimeType GetDeclaringTypeInternal();
    public virtual string ToString();
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual MemberTypes get_MemberType();
    [SecuritySafeCriticalAttribute]
public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal RuntimeAssembly GetRuntimeAssembly();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
internal virtual ParameterInfo[] GetParametersNoCopy();
    [SecuritySafeCriticalAttribute]
public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    internal bool get_IsOverloaded();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    [SecuritySafeCriticalAttribute]
public virtual MethodBody GetMethodBody();
    [DebuggerHiddenAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [SecurityCriticalAttribute]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal object UnsafeInvoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [SecuritySafeCriticalAttribute]
public virtual ParameterInfo get_ReturnParameter();
    [SecuritySafeCriticalAttribute]
public virtual MethodInfo GetBaseDefinition();
    [SecuritySafeCriticalAttribute]
public virtual Delegate CreateDelegate(Type delegateType);
    [SecuritySafeCriticalAttribute]
public virtual Delegate CreateDelegate(Type delegateType, object target);
    [SecuritySafeCriticalAttribute]
public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    internal static MethodBase InternalGetCurrentMethod(StackCrawlMark& stackMark);
}
[ForceTokenStabilizationAttribute]
internal class System.Reflection.RuntimeModule : Module {
    public int MDStreamVersion { get; }
    internal RuntimeType RuntimeType { get; }
    internal MetadataImport MetadataImport { get; }
    public string FullyQualifiedName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    [SecuritySafeCriticalAttribute]
internal RuntimeType[] GetDefinedTypes();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] ResolveSignature(int metadataToken);
    [SecuritySafeCriticalAttribute]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [SecuritySafeCriticalAttribute]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [SecuritySafeCriticalAttribute]
public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [SecuritySafeCriticalAttribute]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [SecuritySafeCriticalAttribute]
public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    [SecuritySafeCriticalAttribute]
public virtual int get_MDStreamVersion();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal MethodInfo GetMethodInternal(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal RuntimeType get_RuntimeType();
    [SecuritySafeCriticalAttribute]
internal bool IsTransientInternal();
    [SecurityCriticalAttribute]
internal MetadataImport get_MetadataImport();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    [SecurityCriticalAttribute]
internal string GetFullyQualifiedName();
    [SecuritySafeCriticalAttribute]
public virtual string get_FullyQualifiedName();
    [SecuritySafeCriticalAttribute]
public virtual Type[] GetTypes();
    [SecuritySafeCriticalAttribute]
public virtual Guid get_ModuleVersionId();
    [SecuritySafeCriticalAttribute]
public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    [SecuritySafeCriticalAttribute]
public virtual string get_ScopeName();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    internal virtual ModuleHandle GetModuleHandle();
    internal RuntimeModule GetNativeHandle();
    [SecuritySafeCriticalAttribute]
public virtual X509Certificate GetSignerCertificate();
}
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    internal MethodBase DefiningMethod { get; }
    public Type ParameterType { get; }
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    internal RemotingParameterCachedData RemotingCache { get; }
    internal RuntimeParameterInfo(RuntimeParameterInfo accessor, RuntimePropertyInfo property);
    internal RuntimeParameterInfo(MethodInfo owner, string name, Type parameterType, int position);
    private static RuntimeParameterInfo();
    [SecurityCriticalAttribute]
internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    [SecurityCriticalAttribute]
internal static ParameterInfo GetReturnParameter(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    [SecurityCriticalAttribute]
internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo& returnParameter, bool fetchReturnParameter);
    internal MethodBase get_DefiningMethod();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type get_ParameterType();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    internal RuntimeModule GetRuntimeModule();
    public virtual int get_MetadataToken();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal RemotingParameterCachedData get_RemotingCache();
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    [SecurityCriticalAttribute]
internal RuntimePropertyInfo(int tkProperty, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    [ReliabilityContractAttribute("3", "2")]
internal virtual bool CacheEquals(object o);
    [SecuritySafeCriticalAttribute]
internal Signature get_Signature();
    internal bool EqualsSig(RuntimePropertyInfo target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    [SecuritySafeCriticalAttribute]
internal object GetConstantValue(bool raw);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    internal ParameterInfo[] GetIndexParametersNoCopy();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual object GetValue(object obj, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [DebuggerHiddenAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
}
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
}
internal class System.Reflection.SecurityContextFrame : ValueType {
    private IntPtr m_GSCookie;
    private IntPtr __VFN_table;
    private IntPtr m_Next;
    private IntPtr m_Assembly;
    [SecurityCriticalAttribute]
public void Push(RuntimeAssembly assembly);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void Pop();
}
[ComVisibleAttribute("True")]
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    [SecuritySafeCriticalAttribute]
public StrongNameKeyPair(FileStream keyPairFile);
    [SecuritySafeCriticalAttribute]
public StrongNameKeyPair(Byte[] keyPairArray);
    [SecuritySafeCriticalAttribute]
public StrongNameKeyPair(string keyPairContainer);
    [SecuritySafeCriticalAttribute]
protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public Byte[] get_PublicKey();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[ComVisibleAttribute("True")]
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    [ComVisibleAttribute("False")]
public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes ReservedMask;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
}
[ComVisibleAttribute("True")]
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
[ComVisibleAttribute("True")]
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public abstract class System.Reflection.TypeInfo : Type {
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
}
internal class System.ReflectionOnlyType : RuntimeType {
    public RuntimeTypeHandle TypeHandle { get; }
    public virtual RuntimeTypeHandle get_TypeHandle();
}
internal static class System.ResId : object {
    internal static string Arg_ArrayLengthsDiffer;
    internal static string Argument_InvalidNumberOfMembers;
    internal static string Argument_UnequalMembers;
    internal static string Argument_SpecifyValueSize;
    internal static string Argument_UnmatchingSymScope;
    internal static string Argument_NotInExceptionBlock;
    internal static string Argument_NotExceptionType;
    internal static string Argument_InvalidLabel;
    internal static string Argument_UnclosedExceptionBlock;
    internal static string Argument_MissingDefaultConstructor;
    internal static string Argument_TooManyFinallyClause;
    internal static string Argument_NotInTheSameModuleBuilder;
    internal static string Argument_BadCurrentLocalVariable;
    internal static string Argument_DuplicateModuleName;
    internal static string Argument_BadPersistableModuleInTransientAssembly;
    internal static string Argument_HasToBeArrayClass;
    internal static string Argument_InvalidDirectory;
    internal static string MissingType;
    internal static string MissingModule;
    internal static string ArgumentOutOfRange_Index;
    internal static string ArgumentOutOfRange_Range;
    internal static string ExecutionEngine_YoureHosed;
    internal static string Format_NeedSingleChar;
    internal static string Format_StringZeroLength;
    internal static string InvalidOperation_EnumEnded;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumNotStarted;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string InvalidOperation_InternalState;
    internal static string InvalidOperation_ModifyRONumFmtInfo;
    internal static string InvalidOperation_MethodBaked;
    internal static string InvalidOperation_NotADebugModule;
    internal static string InvalidOperation_MethodHasBody;
    internal static string InvalidOperation_OpenLocalVariableScope;
    internal static string InvalidOperation_TypeHasBeenCreated;
    internal static string InvalidOperation_RefedAssemblyNotSaved;
    internal static string InvalidOperation_AssemblyHasBeenSaved;
    internal static string InvalidOperation_ModuleHasBeenSaved;
    internal static string InvalidOperation_CannotAlterAssembly;
    internal static string NotSupported_CannotSaveModuleIndividually;
    internal static string NotSupported_Constructor;
    internal static string NotSupported_Method;
    internal static string NotSupported_NYI;
    internal static string NotSupported_DynamicModule;
    internal static string NotSupported_NotDynamicModule;
    internal static string NotSupported_NotAllTypesAreBaked;
    internal static string NotSupported_SortedListNestedWrite;
    internal static string Serialization_ArrayInvalidLength;
    internal static string Serialization_ArrayNoLength;
    internal static string Serialization_CannotGetType;
    internal static string Serialization_InsufficientState;
    internal static string Serialization_InvalidID;
    internal static string Serialization_MalformedArray;
    internal static string Serialization_MultipleMembers;
    internal static string Serialization_NoID;
    internal static string Serialization_NoType;
    internal static string Serialization_NoBaseType;
    internal static string Serialization_NullSignature;
    internal static string Serialization_UnknownMember;
    internal static string Serialization_BadParameterInfo;
    internal static string Serialization_NoParameterInfo;
    internal static string WeakReference_NoLongerValid;
    internal static string Loader_InvalidPath;
}
[ComVisibleAttribute("True")]
public class System.ResolveEventArgs : EventArgs {
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    public string get_Name();
    public Assembly get_RequestingAssembly();
}
[ComVisibleAttribute("True")]
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal abstract class System.Resolver : object {
    internal abstract virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    internal abstract virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal abstract virtual Byte[] GetLocalsSignature();
    [SecurityCriticalAttribute]
internal abstract virtual void GetEHInfo(int EHNumber, Void* exception);
    internal abstract virtual Byte[] GetRawEHInfo();
    internal abstract virtual string GetStringLiteral(int token);
    [SecurityCriticalAttribute]
internal abstract virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal abstract virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal abstract virtual MethodInfo GetDynamicMethod();
    internal abstract virtual CompressedStack GetSecurityContext();
}
internal static class System.Resources.__HResults : object {
    public static int ERROR_MRM_MAP_NOT_FOUND;
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    [SecurityCriticalAttribute]
public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    [SecurityCriticalAttribute]
public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    [SecurityCriticalAttribute]
internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    [SecuritySafeCriticalAttribute]
public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public sealed virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public abstract virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
}
[ComVisibleAttribute("True")]
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
public interface System.Resources.IResourceWriter {
    public abstract virtual void AddResource(string name, string value);
    public abstract virtual void AddResource(string name, object value);
    public abstract virtual void AddResource(string name, Byte[] value);
    public abstract virtual void Close();
    public abstract virtual void Generate();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    [SecuritySafeCriticalAttribute]
public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public sealed virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
    [SecurityCriticalAttribute]
internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    [SecurityCriticalAttribute]
internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetNeutralResourcesLanguageAttribute(RuntimeAssembly assemblyHandle, StringHandleOnStack cultureName, Int16& fallbackLocation);
}
[ComVisibleAttribute("True")]
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    public string get_CultureName();
    public UltimateResourceFallbackLocation get_Location();
}
[FriendAccessAllowedAttribute]
internal class System.Resources.PRIExceptionInfo : object {
    public string _PackageSimpleName;
    public string _ResWFile;
}
internal class System.Resources.ResourceFallbackManager : object {
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceManager : object {
    internal static string ResFileExtension;
    internal static int ResFileExtensionLength;
    protected string BaseNameField;
    [ObsoleteAttribute("call InternalGetResourceSet instead")]
protected Hashtable ResourceSets;
    protected Assembly MainAssembly;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    internal static string ResReaderTypeName;
    internal static string ResSetTypeName;
    internal static string MscorlibName;
    internal static int DEBUG;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    [SecuritySafeCriticalAttribute]
protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected static Version GetSatelliteContractVersion(Assembly a);
    [SecuritySafeCriticalAttribute]
protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
    [SecurityCriticalAttribute]
internal static WindowsRuntimeResourceManagerBase GetWinRTResourceManager();
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    [ComVisibleAttribute("False")]
public UnmanagedMemoryStream GetStream(string name);
    [ComVisibleAttribute("False")]
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceReader : object {
    internal Dictionary`2<string, ResourceLocator> _resCache;
    [SecuritySafeCriticalAttribute]
public ResourceReader(string fileName);
    [SecurityCriticalAttribute]
public ResourceReader(Stream stream);
    [SecurityCriticalAttribute]
internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    private static ResourceReader();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
internal static int ReadUnalignedI4(Int32* p);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceSet : object {
    protected IResourceReader Reader;
    protected Hashtable Table;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    [SecurityCriticalAttribute]
public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    [ComVisibleAttribute("False")]
public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceWriter : object {
    public Func`2<Type, string> TypeNameConverter { get; public set; }
    public ResourceWriter(string fileName);
    public ResourceWriter(Stream stream);
    public Func`2<Type, string> get_TypeNameConverter();
    public void set_TypeNameConverter(Func`2<Type, string> value);
    public sealed virtual void AddResource(string name, string value);
    public sealed virtual void AddResource(string name, object value);
    public void AddResource(string name, Stream value);
    public void AddResource(string name, Stream value, bool closeAfterWrite);
    public sealed virtual void AddResource(string name, Byte[] value);
    public void AddResourceData(string name, string typeName, Byte[] serializedData);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Generate();
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    internal static int Version;
    [SecurityCriticalAttribute]
internal RuntimeResourceSet(string fileName);
    [SecurityCriticalAttribute]
internal RuntimeResourceSet(Stream stream);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    public string get_Version();
}
[ComVisibleAttribute("True")]
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal class System.Resources.WindowsRuntimeResourceManagerBase : object {
    public CultureInfo GlobalResourceContextBestFitCultureInfo { get; }
    [SecurityCriticalAttribute]
public virtual bool Initialize(string libpath, string reswFilename, PRIExceptionInfo& exceptionInfo);
    [SecurityCriticalAttribute]
public virtual string GetString(string stringName, string startingCulture, string neutralResourcesCulture);
    [SecurityCriticalAttribute]
public virtual CultureInfo get_GlobalResourceContextBestFitCultureInfo();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    public string get_TargetedPatchBand();
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    public string get_PropertyName();
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHere : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereM : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereS : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereSM : object {
}
internal class System.Runtime.CompilerServices.AsyncMethodBuilderCore : ValueType {
    internal IAsyncStateMachine m_stateMachine;
    internal Action m_defaultContextAction;
    [DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
internal void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    [SecuritySafeCriticalAttribute]
internal Action GetCompletionAction(TMethodBuilder& builder, TStateMachine& stateMachine);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static int INCLUSIVE_INT32_MIN;
    internal static int EXCLUSIVE_INT32_MAX;
    internal static Task`1<bool> TrueTask;
    internal static Task`1<bool> FalseTask;
    internal static Task`1[] Int32Tasks;
    private static AsyncTaskCache();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;
    public Task Task { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    private sealed virtual override void System.Runtime.CompilerServices.IAsyncMethodBuilder.PreBoxInitialization();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_defaultResultTask;
    private AsyncMethodBuilderCore m_coreState;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    private static AsyncTaskMethodBuilder`1();
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    private sealed virtual override void System.Runtime.CompilerServices.IAsyncMethodBuilder.PreBoxInitialization();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task`1<TResult> get_Task();
    public void SetResult(TResult result);
    internal void SetResult(Task`1<TResult> completedTask);
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext m_synchronizationContext;
    private AsyncMethodBuilderCore m_coreState;
    private object m_objectIdForDebugger;
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    private sealed virtual override void System.Runtime.CompilerServices.IAsyncMethodBuilder.PreBoxInitialization();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvCdecl : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvFastcall : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvStdcall : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvThiscall : object {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.CompilerMarshalOverride : object {
}
[ComVisibleAttribute("False")]
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    internal ICollection`1<TKey> Keys { get; }
    internal ICollection`1<TValue> Values { get; }
    [SecuritySafeCriticalAttribute]
public bool TryGetValue(TKey key, TValue& value);
    [SecuritySafeCriticalAttribute]
public void Add(TKey key, TValue value);
    [SecuritySafeCriticalAttribute]
public bool Remove(TKey key);
    [SecuritySafeCriticalAttribute]
public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    [SecuritySafeCriticalAttribute]
internal TKey FindEquivalentKeyUnsafe(TKey key, TValue& value);
    [SecuritySafeCriticalAttribute]
internal ICollection`1<TKey> get_Keys();
    [SecuritySafeCriticalAttribute]
internal ICollection`1<TValue> get_Values();
    [SecuritySafeCriticalAttribute]
internal void Clear();
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public ConfiguredTaskAwaiter GetAwaiter();
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    internal static int COR_E_CODECONTRACTFAILED;
    private static ContractHelper();
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "1")]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    [SecurityCriticalAttribute]
internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [SecurityCriticalAttribute]
internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
    internal static object GetRawConstant(CustomAttributeData attr);
}
[AttributeUsageAttribute("2304")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
    internal static DateTime GetRawDateTimeConstant(CustomAttributeData attr);
}
[AttributeUsageAttribute("2304")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
    internal static decimal GetRawDecimalConstant(CustomAttributeData attr);
}
[ComVisibleAttribute("False")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.DecoratedNameAttribute : Attribute {
    public DecoratedNameAttribute(string decoratedName);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    public string get_DependentAssembly();
    public LoadHint get_LoadHint();
}
[ComVisibleAttribute("False")]
internal class System.Runtime.CompilerServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    [SecurityCriticalAttribute]
public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    [SecurityCriticalAttribute]
public object GetPrimary();
    [SecurityCriticalAttribute]
public void GetPrimaryAndSecondary(Object& primary, Object& secondary);
    [SecurityCriticalAttribute]
public void Free();
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    public Type get_ElementType();
    public int get_Length();
}
[FriendAccessAllowedAttribute]
[AttributeUsageAttribute("2044")]
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.HasCopySemanticsAttribute : Attribute {
}
internal interface System.Runtime.CompilerServices.IAsyncMethodBuilder {
    public abstract virtual void PreBoxInitialization();
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    [SecurityCriticalAttribute]
public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("2304")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.IDispatchConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public virtual object get_Value();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    public string get_AssemblyName();
    public bool get_AllInternalsVisible();
    public void set_AllInternalsVisible(bool value);
}
public static class System.Runtime.CompilerServices.IsBoxed : object {
}
public static class System.Runtime.CompilerServices.IsByValue : object {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[ComVisibleAttribute("True")]
public static class System.Runtime.CompilerServices.IsCopyConstructed : object {
}
public static class System.Runtime.CompilerServices.IsExplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsImplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsJitIntrinsic : object {
}
public static class System.Runtime.CompilerServices.IsLong : object {
}
public static class System.Runtime.CompilerServices.IsPinned : object {
}
public static class System.Runtime.CompilerServices.IsSignUnspecifiedByte : object {
}
public static class System.Runtime.CompilerServices.IsUdtReturn : object {
}
[ComVisibleAttribute("True")]
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.IUnknownConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public virtual object get_Value();
}
[FriendAccessAllowedAttribute]
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    internal static string QCall;
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static StringHandleOnStack GetStringHandleOnStack(String& s);
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static ObjectHandleOnStack GetObjectHandleOnStack(T& o);
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static StackCrawlMarkHandle GetStackCrawlMarkHandle(StackCrawlMark& stackMark);
    [FriendAccessAllowedAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecurityCriticalAttribute]
internal static T UnsafeCast(object o);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static int UnsafeEnumCast(T val);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static long UnsafeEnumCastLong(T val);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecurityCriticalAttribute]
internal static IntPtr UnsafeCastToStackPointer(T& val);
    [SecurityCriticalAttribute]
internal static void UnsafeSetArrayElement(Object[] target, int index, object element);
    [SecurityCriticalAttribute]
internal static PinningHelper GetPinningHelper(object o);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    internal MethodImplOptions _val;
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    internal MethodImplAttribute(MethodImplAttributes methodImplAttributes);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions InternalCall;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoInlining;
    [ComVisibleAttribute("False")]
public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions NoOptimization;
}
[AttributeUsageAttribute("8")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.NativeCppClassAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.ObjectHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal ObjectHandleOnStack(IntPtr pObject);
}
internal class System.Runtime.CompilerServices.PinningHelper : object {
    [ForceTokenStabilizationAttribute]
public byte m_data;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    public string get_Description();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1052")]
public class System.Runtime.CompilerServices.RequiredAttributeAttribute : Attribute {
    public Type RequiredContract { get; }
    public RequiredAttributeAttribute(Type requiredContract);
    public Type get_RequiredContract();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    public bool WrapNonExceptionThrows { get; public set; }
    public bool get_WrapNonExceptionThrows();
    public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    [SecuritySafeCriticalAttribute]
public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    [SecuritySafeCriticalAttribute]
public static object GetObjectValue(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void RunModuleConstructor(ModuleHandle module);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void _CompileMethod(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
public static void PrepareMethod(RuntimeMethodHandle method);
    [SecurityCriticalAttribute]
public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    [SecurityCriticalAttribute]
public static void PrepareDelegate(Delegate d);
    [SecurityCriticalAttribute]
public static void PrepareContractedDelegate(Delegate d);
    [SecuritySafeCriticalAttribute]
public static int GetHashCode(object o);
    [SecuritySafeCriticalAttribute]
public static bool Equals(object o1, object o2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int get_OffsetToStringData();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static void EnsureSufficientExecutionStack();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void ProbeForSufficientStack();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public static void PrepareConstrainedRegions();
    [ReliabilityContractAttribute("3", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecurityCriticalAttribute]
public static void PrepareConstrainedRegionsNoOP();
    [SecurityCriticalAttribute]
public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    [PrePrepareMethodAttribute]
internal static void ExecuteBackoutCodeHelper(object backoutCode, object userData, bool exceptionThrown);
}
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    public object WrappedException { get; }
    internal RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.Runtime.CompilerServices.ScopelessEnumAttribute : Attribute {
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StackCrawlMarkHandle : ValueType {
    private IntPtr m_ptr;
    internal StackCrawlMarkHandle(IntPtr stackMark);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    public Type StateMachineType { get; private set; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
    [CompilerGeneratedAttribute]
private void set_StateMachineType(Type value);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StringHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal StringHandleOnStack(IntPtr pString);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[AttributeUsageAttribute("996")]
internal class System.Runtime.CompilerServices.SuppressMergeCheckAttribute : Attribute {
}
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    private Task m_task;
    public bool IsCompleted { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal TaskAwaiter(Task task);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsCompleted();
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void GetResult();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static void ValidateEnd(Task task);
    [SecurityCriticalAttribute]
internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
}
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal TaskAwaiter`1(Task`1<TResult> task);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsCompleted();
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TResult GetResult();
}
[AttributeUsageAttribute("1036")]
internal class System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
    public TypeDependencyAttribute(string typeName);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    public Type get_Destination();
    [SecurityCriticalAttribute]
internal static TypeForwardedToAttribute[] GetCustomAttribute(RuntimeAssembly assembly);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
[ComVisibleAttribute("True")]
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    [ReliabilityContractAttribute("3", "2")]
protected virtual void Finalize();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    public Consistency get_ConsistencyGuarantee();
    public Cer get_Cer();
}
public class System.Runtime.DesignerServices.WindowsRuntimeDesignerContext : object {
    public string Name { get; }
    [SecurityCriticalAttribute]
public WindowsRuntimeDesignerContext(IEnumerable`1<string> paths, string name);
    private static WindowsRuntimeDesignerContext();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static IntPtr CreateDesignerContext(String[] paths, int count, bool shared);
    [SecurityCriticalAttribute]
internal static IntPtr CreateDesignerContext(IEnumerable`1<string> paths, bool shared);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetCurrentContext(bool isDesignerContext, IntPtr context);
    [SecurityCriticalAttribute]
public static void InitializeSharedContext(IEnumerable`1<string> paths);
    [SecurityCriticalAttribute]
public static void SetIterationContext(WindowsRuntimeDesignerContext context);
    [SecurityCriticalAttribute]
public Assembly GetAssembly(string assemblyName);
    [SecurityCriticalAttribute]
public Type GetType(string typeName);
    public string get_Name();
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal object BinaryStackTraceArray { get; }
    internal object DynamicMethodArray { get; }
    internal string RemoteStackTrace { get; }
    public Exception SourceException { get; }
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal object get_BinaryStackTraceArray();
    internal object get_DynamicMethodArray();
    internal string get_RemoteStackTrace();
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    public void Throw();
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [ReliabilityContractAttribute("3", "2")]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
[AttributeUsageAttribute("5484")]
internal class System.Runtime.ForceTokenStabilizationAttribute : Attribute {
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
}
public static class System.Runtime.GCSettings : object {
    public static GCLatencyMode LatencyMode { get; public set; }
    public static bool IsServerGC { get; }
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static GCLatencyMode get_LatencyMode();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void set_LatencyMode(GCLatencyMode value);
    [SecuritySafeCriticalAttribute]
public static bool get_IsServerGC();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Hosting.ActivationArguments : EvidenceBase {
    internal bool UseFusionActivationContext { get; }
    internal bool ActivateInstance { get; internal set; }
    internal string ApplicationFullName { get; }
    internal String[] ApplicationManifestPaths { get; }
    public ApplicationIdentity ApplicationIdentity { get; }
    public ActivationContext ActivationContext { get; }
    public String[] ActivationData { get; }
    public ActivationArguments(ApplicationIdentity applicationIdentity);
    public ActivationArguments(ApplicationIdentity applicationIdentity, String[] activationData);
    public ActivationArguments(ActivationContext activationData);
    public ActivationArguments(ActivationContext activationContext, String[] activationData);
    internal ActivationArguments(string appFullName, String[] appManifestPaths, String[] activationData);
    internal bool get_UseFusionActivationContext();
    internal bool get_ActivateInstance();
    internal void set_ActivateInstance(bool value);
    internal string get_ApplicationFullName();
    internal String[] get_ApplicationManifestPaths();
    public ApplicationIdentity get_ApplicationIdentity();
    public ActivationContext get_ActivationContext();
    public String[] get_ActivationData();
    public virtual EvidenceBase Clone();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Hosting.ApplicationActivator : object {
    public virtual ObjectHandle CreateInstance(ActivationContext activationContext);
    [SecuritySafeCriticalAttribute]
public virtual ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData);
    [SecuritySafeCriticalAttribute]
protected static ObjectHandle CreateInstanceHelper(AppDomainSetup adSetup);
}
internal class System.Runtime.Hosting.ManifestRunner : object {
    internal RuntimeAssembly EntryAssembly { get; }
    [SecurityCriticalAttribute]
internal ManifestRunner(AppDomain domain, ActivationContext activationContext);
    [SecurityCriticalAttribute]
internal RuntimeAssembly get_EntryAssembly();
    [SecurityCriticalAttribute]
internal int ExecuteAsAssembly();
}
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Activator")]
[ComVisibleAttribute("True")]
[GuidAttribute("03973551-57A1-3900-A2B5-9083E3FF2943")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._Activator {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Assembly")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("0")]
[CLSCompliantAttribute("False")]
[GuidAttribute("17156360-2f1a-384a-bc52-fde93c215c5b")]
public interface System.Runtime.InteropServices._Assembly {
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public string Location { get; }
    public Evidence Evidence { get; }
    public bool GlobalAssemblyCache { get; }
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual string get_CodeBase();
    public abstract virtual string get_EscapedCodeBase();
    public abstract virtual AssemblyName GetName();
    public abstract virtual AssemblyName GetName(bool copiedName);
    public abstract virtual string get_FullName();
    public abstract virtual MethodInfo get_EntryPoint();
    public abstract virtual Type GetType(string name);
    public abstract virtual Type GetType(string name, bool throwOnError);
    public abstract virtual Type[] GetExportedTypes();
    public abstract virtual Type[] GetTypes();
    public abstract virtual Stream GetManifestResourceStream(Type type, string name);
    public abstract virtual Stream GetManifestResourceStream(string name);
    public abstract virtual FileStream GetFile(string name);
    public abstract virtual FileStream[] GetFiles();
    public abstract virtual FileStream[] GetFiles(bool getResourceModules);
    public abstract virtual String[] GetManifestResourceNames();
    public abstract virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public abstract virtual string get_Location();
    public abstract virtual Evidence get_Evidence();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    [SecurityCriticalAttribute]
public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public abstract virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public abstract virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public abstract virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public abstract virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public abstract virtual Module LoadModule(string moduleName, Byte[] rawModule);
    public abstract virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public abstract virtual object CreateInstance(string typeName);
    public abstract virtual object CreateInstance(string typeName, bool ignoreCase);
    public abstract virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public abstract virtual Module[] GetLoadedModules();
    public abstract virtual Module[] GetLoadedModules(bool getResourceModules);
    public abstract virtual Module[] GetModules();
    public abstract virtual Module[] GetModules(bool getResourceModules);
    public abstract virtual Module GetModule(string name);
    public abstract virtual AssemblyName[] GetReferencedAssemblies();
    public abstract virtual bool get_GlobalAssemblyCache();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BEBB2505-8B54-3443-AEAD-142A16DD9CC7")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.Emit.AssemblyBuilder")]
public interface System.Runtime.InteropServices._AssemblyBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("B42B6AAC-317E-34D5-9FA9-093BB4160C50")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.AssemblyName")]
public interface System.Runtime.InteropServices._AssemblyName {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("917B14D0-2D9E-38B8-92A9-381ACF52F7C0")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Attribute")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._Attribute {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.ConstructorBuilder")]
[GuidAttribute("ED3E4384-D7E2-3FA7-8FFD-8940D330519A")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._ConstructorBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("E9A19478-9646-3679-9B10-8411AE1FD57D")]
[TypeLibImportClassAttribute("System.Reflection.ConstructorInfo")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._ConstructorInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsFinal { get; }
    public bool IsVirtual { get; }
    public bool IsHideBySig { get; }
    public bool IsAbstract { get; }
    public bool IsSpecialName { get; }
    public bool IsConstructor { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual object Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual object Invoke_3(object obj, Object[] parameters);
    public abstract virtual object Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual object Invoke_5(Object[] parameters);
}
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.Emit.CustomAttributeBuilder")]
[GuidAttribute("BE9ACCE8-AAFF-3B91-81AE-8211663F5CAD")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._CustomAttributeBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("C7BD73DE-9F85-3290-88EE-090B8BDFE2DF")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.Emit.EnumBuilder")]
public interface System.Runtime.InteropServices._EnumBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.EventBuilder")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("AADABA99-895D-3D65-9760-B1F12621FAE8")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._EventBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("9DE59C64-D889-35A1-B897-587D74469E5B")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.EventInfo")]
public interface System.Runtime.InteropServices._EventInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public EventAttributes Attributes { get; }
    public Type EventHandlerType { get; }
    public bool IsSpecialName { get; }
    public bool IsMulticast { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public abstract virtual EventAttributes get_Attributes();
    public abstract virtual MethodInfo GetAddMethod();
    public abstract virtual MethodInfo GetRemoveMethod();
    public abstract virtual MethodInfo GetRaiseMethod();
    public abstract virtual void AddEventHandler(object target, Delegate handler);
    public abstract virtual void RemoveEventHandler(object target, Delegate handler);
    public abstract virtual Type get_EventHandlerType();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsMulticast();
}
[ComVisibleAttribute("True")]
[GuidAttribute("b36b5c63-42ef-38bc-a07e-0b34c98f164a")]
[InterfaceTypeAttribute("0")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._Exception {
    public string Message { get; }
    public string StackTrace { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    public Exception InnerException { get; }
    public MethodBase TargetSite { get; }
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual string get_Message();
    public abstract virtual Exception GetBaseException();
    public abstract virtual string get_StackTrace();
    public abstract virtual string get_HelpLink();
    public abstract virtual void set_HelpLink(string value);
    public abstract virtual string get_Source();
    public abstract virtual void set_Source(string value);
    [SecurityCriticalAttribute]
public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual Exception get_InnerException();
    public abstract virtual MethodBase get_TargetSite();
}
[CLSCompliantAttribute("False")]
[GuidAttribute("CE1A3BF5-975E-30CC-97C9-1EF70F8F3993")]
[TypeLibImportClassAttribute("System.Reflection.Emit.FieldBuilder")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._FieldBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.FieldInfo")]
[GuidAttribute("8A7C1442-A9FB-366B-80D8-4939FFA6DBE0")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._FieldInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsSpecialName { get; }
    public bool IsPinvokeImpl { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Type get_FieldType();
    public abstract virtual object GetValue(object obj);
    public abstract virtual object GetValueDirect(TypedReference obj);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public abstract virtual void SetValueDirect(TypedReference obj, object value);
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual void SetValue(object obj, object value);
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool get_IsNotSerialized();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsPinvokeImpl();
}
[GuidAttribute("A4924B27-6E3B-37F7-9B83-A4501955E6A7")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.Emit.ILGenerator")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._ILGenerator {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.LocalBuilder")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[GuidAttribute("4E6350D1-A08B-3DEC-9A3E-C465F9AEEC0C")]
public interface System.Runtime.InteropServices._LocalBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[GuidAttribute("f7102fa9-cabb-3a74-a6da-b4567ef1b079")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.MemberInfo")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._MemberInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
[TypeLibImportClassAttribute("System.Reflection.MethodBase")]
[ComVisibleAttribute("True")]
[GuidAttribute("6240837A-707F-3181-8E98-A36AE086766B")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._MethodBase {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsFinal { get; }
    public bool IsVirtual { get; }
    public bool IsHideBySig { get; }
    public bool IsAbstract { get; }
    public bool IsSpecialName { get; }
    public bool IsConstructor { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual object Invoke(object obj, Object[] parameters);
}
[GuidAttribute("007D8A14-FDF3-363E-9A0B-FEC0618260A2")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.Emit.MethodBuilder")]
public interface System.Runtime.InteropServices._MethodBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("FFCC1B5D-ECB8-38DD-9B01-3DC8ABC2AA5F")]
[TypeLibImportClassAttribute("System.Reflection.MethodInfo")]
public interface System.Runtime.InteropServices._MethodInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsFinal { get; }
    public bool IsVirtual { get; }
    public bool IsHideBySig { get; }
    public bool IsAbstract { get; }
    public bool IsSpecialName { get; }
    public bool IsConstructor { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual object Invoke(object obj, Object[] parameters);
    public abstract virtual Type get_ReturnType();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public abstract virtual MethodInfo GetBaseDefinition();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("C2323C25-F57F-3880-8A4D-12EBEA7A5852")]
[TypeLibImportClassAttribute("System.Reflection.Emit.MethodRental")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._MethodRental {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Module")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("D002E9BA-D9E3-3749-B1D3-D565A08B13E7")]
public interface System.Runtime.InteropServices._Module {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.Emit.ModuleBuilder")]
[ComVisibleAttribute("True")]
[GuidAttribute("D05FFA9A-04AF-3519-8EE1-8D93AD73430B")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._ModuleBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.ParameterBuilder")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("36329EBA-F97A-3565-BC07-0ED5C6EF19FC")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._ParameterBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("993634C4-E47A-32CC-BE08-85F567DC27D6")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.ParameterInfo")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._ParameterInfo {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[GuidAttribute("15F9A479-9397-3A63-ACBD-F51977FB0F02")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.Emit.PropertyBuilder")]
public interface System.Runtime.InteropServices._PropertyBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("F59ED4E4-E68F-3218-BD77-061AA82824BF")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.PropertyInfo")]
public interface System.Runtime.InteropServices._PropertyInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool IsSpecialName { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Type get_PropertyType();
    public abstract virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetSetMethod();
    public abstract virtual bool get_IsSpecialName();
}
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.Emit.SignatureHelper")]
[GuidAttribute("7D13DD37-5A04-393C-BBCA-A5FEA802893D")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._SignatureHelper {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Threading.Thread")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("C281C7F1-4AA9-3517-961A-463CFED57E75")]
public interface System.Runtime.InteropServices._Thread {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Type")]
[GuidAttribute("BCA8B44D-AAD6-3A86-8AB7-03349F4F2DA2")]
public interface System.Runtime.InteropServices._Type {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public ConstructorInfo TypeInitializer { get; }
    public TypeAttributes Attributes { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsAutoLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsExplicitLayout { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsEnum { get; }
    public bool IsSpecialName { get; }
    public bool IsImport { get; }
    public bool IsSerializable { get; }
    public bool IsAnsiClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsAutoClass { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsCOMObject { get; }
    public bool HasElementType { get; }
    public bool IsContextful { get; }
    public bool IsMarshalByRef { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Guid get_GUID();
    public abstract virtual Module get_Module();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual RuntimeTypeHandle get_TypeHandle();
    public abstract virtual string get_FullName();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type get_BaseType();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public abstract virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public abstract virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetDefaultMembers();
    public abstract virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public abstract virtual Type GetElementType();
    public abstract virtual bool IsSubclassOf(Type c);
    public abstract virtual bool IsInstanceOfType(object o);
    public abstract virtual bool IsAssignableFrom(Type c);
    public abstract virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    public abstract virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual ConstructorInfo GetConstructor(Type[] types);
    public abstract virtual ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo get_TypeInitializer();
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, Type[] types);
    public abstract virtual MethodInfo GetMethod(string name);
    public abstract virtual MethodInfo[] GetMethods();
    public abstract virtual FieldInfo GetField(string name);
    public abstract virtual FieldInfo[] GetFields();
    public abstract virtual Type GetInterface(string name);
    public abstract virtual EventInfo GetEvent(string name);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public abstract virtual PropertyInfo GetProperty(string name, Type[] types);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType);
    public abstract virtual PropertyInfo GetProperty(string name);
    public abstract virtual PropertyInfo[] GetProperties();
    public abstract virtual Type[] GetNestedTypes();
    public abstract virtual Type GetNestedType(string name);
    public abstract virtual MemberInfo[] GetMember(string name);
    public abstract virtual MemberInfo[] GetMembers();
    public abstract virtual TypeAttributes get_Attributes();
    public abstract virtual bool get_IsNotPublic();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsNestedPublic();
    public abstract virtual bool get_IsNestedPrivate();
    public abstract virtual bool get_IsNestedFamily();
    public abstract virtual bool get_IsNestedAssembly();
    public abstract virtual bool get_IsNestedFamANDAssem();
    public abstract virtual bool get_IsNestedFamORAssem();
    public abstract virtual bool get_IsAutoLayout();
    public abstract virtual bool get_IsLayoutSequential();
    public abstract virtual bool get_IsExplicitLayout();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsImport();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsAnsiClass();
    public abstract virtual bool get_IsUnicodeClass();
    public abstract virtual bool get_IsAutoClass();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsByRef();
    public abstract virtual bool get_IsPointer();
    public abstract virtual bool get_IsPrimitive();
    public abstract virtual bool get_IsCOMObject();
    public abstract virtual bool get_HasElementType();
    public abstract virtual bool get_IsContextful();
    public abstract virtual bool get_IsMarshalByRef();
    public abstract virtual bool Equals(Type o);
}
[GuidAttribute("7E5678EE-48B3-3F83-B076-C58543498A58")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.Emit.TypeBuilder")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._TypeBuilder {
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    [ForceTokenStabilizationAttribute]
private object m_array;
    [ForceTokenStabilizationAttribute]
private int m_offset;
    [ForceTokenStabilizationAttribute]
private int m_count;
    [SecuritySafeCriticalAttribute]
public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.AssemblyRegistrationFlags : Enum {
    public int value__;
    public static AssemblyRegistrationFlags None;
    public static AssemblyRegistrationFlags SetCodeBase;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1029")]
public class System.Runtime.InteropServices.AutomationProxyAttribute : Attribute {
    internal bool _val;
    public bool Value { get; }
    public AutomationProxyAttribute(bool val);
    public bool get_Value();
}
[AttributeUsageAttribute("1037")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    internal bool _bestFitMapping;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    public bool get_BestFitMapping();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.BIND_OPTS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.BINDPTR instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.BStrWrapper : object {
    public string WrappedObject { get; }
    [SecuritySafeCriticalAttribute]
public BStrWrapper(string value);
    [SecuritySafeCriticalAttribute]
public BStrWrapper(object value);
    public string get_WrappedObject();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.CALLCONV instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    internal ClassInterfaceType _val;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceType get_Value();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    internal Type _CoClass;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
[AttributeUsageAttribute("10624")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComAliasNameAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComAliasNameAttribute(string alias);
    public string get_Value();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComCompatibleVersionAttribute : Attribute {
    internal int _major;
    internal int _minor;
    internal int _build;
    internal int _revision;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int BuildNumber { get; }
    public int RevisionNumber { get; }
    public ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
    public int get_MajorVersion();
    public int get_MinorVersion();
    public int get_BuildNumber();
    public int get_RevisionNumber();
}
[AttributeUsageAttribute("32767")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComConversionLossAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    internal Type _val;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
[AttributeUsageAttribute("1024")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    internal Type _SourceInterface;
    internal Type _EventProvider;
    public Type SourceInterface { get; }
    public Type EventProvider { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    public Type get_SourceInterface();
    public Type get_EventProvider();
}
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    [SecurityCriticalAttribute]
public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    [SecurityCriticalAttribute]
public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
    [SecurityCriticalAttribute]
internal static object UnwrapIfTransparentProxy(object rcw);
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.ComEventsInfo : object {
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
internal static ComEventsInfo Find(object rcw);
    [SecurityCriticalAttribute]
internal static ComEventsInfo FromObject(object rcw);
    internal ComEventsSink FindSink(Guid& iid);
    internal ComEventsSink AddSink(Guid& iid);
    [SecurityCriticalAttribute]
internal ComEventsSink RemoveSink(ComEventsSink sink);
}
internal class System.Runtime.InteropServices.ComEventsMethod : object {
    internal int DispId { get; }
    internal bool Empty { get; }
    internal ComEventsMethod(int dispid);
    internal static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    internal static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    internal static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    internal int get_DispId();
    internal bool get_Empty();
    internal void AddDelegate(Delegate d);
    internal void RemoveDelegate(Delegate d);
    internal object Invoke(Object[] args);
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.ComEventsSink : object {
    internal ComEventsSink(object rcw, Guid iid);
    private static ComEventsSink();
    internal static ComEventsSink Find(ComEventsSink sinks, Guid& iid);
    internal static ComEventsSink Add(ComEventsSink sinks, ComEventsSink sink);
    [SecurityCriticalAttribute]
internal static ComEventsSink RemoveAll(ComEventsSink sinks);
    [SecurityCriticalAttribute]
internal static ComEventsSink Remove(ComEventsSink sinks, ComEventsSink sink);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.NativeMethods.IDispatch.GetTypeInfoCount(UInt32& pctinfo);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.NativeMethods.IDispatch.GetTypeInfo(UInt32 iTInfo, int lcid, IntPtr& info);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.NativeMethods.IDispatch.GetIDsOfNames(Guid& iid, String[] names, UInt32 cNames, int lcid, Int32[] rgDispId);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.NativeMethods.IDispatch.Invoke(int dispid, Guid& riid, int lcid, INVOKEKIND wFlags, DISPPARAMS& pDispParams, IntPtr pvarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    [SecurityCriticalAttribute]
private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.COMException : ExternalException {
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    [SecuritySafeCriticalAttribute]
internal COMException(int hresult);
    internal COMException(string message, int hresult, Exception inner);
    protected COMException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    [ComVisibleAttribute("False")]
public static ComInterfaceType InterfaceIsIInspectable;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.ComRegisterFunctionAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.ComTypes.IEnumerable {
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[GuidAttribute("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.ComTypes.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.ComTypes.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual PropertyInfo AddProperty(string name);
    public abstract virtual MethodInfo AddMethod(string name, Delegate method);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[GuidAttribute("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.ComTypes.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComUnregisterFunctionAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    internal bool _val;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.CONNECTDATA instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    [ForceTokenStabilizationAttribute]
protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected CriticalHandle(IntPtr invalidHandleValue);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual void Finalize();
    [ReliabilityContractAttribute("3", "2")]
protected void SetHandle(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsClosed();
    [ReliabilityContractAttribute("3", "2")]
public abstract virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public void Close();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [ReliabilityContractAttribute("3", "2")]
public void SetHandleAsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected abstract virtual bool ReleaseHandle();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
[ComVisibleAttribute("False")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    internal CharSet _CharSet;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    public CharSet get_CharSet();
}
[ComVisibleAttribute("False")]
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    internal DllImportSearchPath _paths;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    public DllImportSearchPath get_Paths();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.DESCKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.DispatchWrapper : object {
    public object WrappedObject { get; }
    [SecuritySafeCriticalAttribute]
public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.DISPPARAMS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    internal string _val;
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public bool PreserveSig;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    internal DllImportAttribute(string dllName, string entryPoint, CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
    public DllImportAttribute(string dllName);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ELEMDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ErrorWrapper : object {
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    [SecuritySafeCriticalAttribute]
public ErrorWrapper(Exception e);
    public int get_ErrorCode();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.EXCEPINFO instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
}
[ComVisibleAttribute("True")]
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
public interface System.Runtime.InteropServices.Expando.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual PropertyInfo AddProperty(string name);
    public abstract virtual MethodInfo AddMethod(string name, Delegate method);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ExporterEventKind : Enum {
    public int value__;
    public static ExporterEventKind NOTIF_TYPECONVERTED;
    public static ExporterEventKind NOTIF_CONVERTWARNING;
    public static ExporterEventKind ERROR_REFTOINVALIDASSEMBLY;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ExtensibleClassFactory : object {
    [SecuritySafeCriticalAttribute]
public static void RegisterObjectCreationCallback(ObjectCreationDelegate callback);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeFieldInfo field);
    public int get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FILETIME instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private static GCHandleType MaxHandleType;
    private IntPtr m_handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    [SecuritySafeCriticalAttribute]
private static GCHandle();
    [SecurityCriticalAttribute]
internal GCHandle(object value, GCHandleType type);
    [SecurityCriticalAttribute]
internal GCHandle(IntPtr handle);
    [SecurityCriticalAttribute]
public static GCHandle Alloc(object value);
    [SecurityCriticalAttribute]
public static GCHandle Alloc(object value, GCHandleType type);
    [SecurityCriticalAttribute]
public void Free();
    [SecurityCriticalAttribute]
public object get_Target();
    [SecurityCriticalAttribute]
public void set_Target(object value);
    [SecurityCriticalAttribute]
public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    [SecurityCriticalAttribute]
public static GCHandle op_Explicit(IntPtr value);
    [SecurityCriticalAttribute]
public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    internal IntPtr GetHandleValue();
    internal bool IsPinned();
    internal void SetIsPinned();
    [SecurityCriticalAttribute]
internal static IntPtr InternalAlloc(object value, GCHandleType type);
    [SecurityCriticalAttribute]
internal static void InternalFree(IntPtr handle);
    [SecurityCriticalAttribute]
internal static object InternalGet(IntPtr handle);
    [SecurityCriticalAttribute]
internal static void InternalSet(IntPtr handle, object value, bool isPinned);
    [SecurityCriticalAttribute]
internal static object InternalCompareExchange(IntPtr handle, object value, object oldValue, bool isPinned);
    [SecurityCriticalAttribute]
internal static IntPtr InternalAddrOfPinnedObject(IntPtr handle);
    [SecurityCriticalAttribute]
internal static void InternalCheckDomain(IntPtr handle);
    [SecurityCriticalAttribute]
internal static GCHandleType InternalGetHandleType(IntPtr handle);
}
internal class System.Runtime.InteropServices.GCHandleCookieTable : object {
    internal IntPtr FindOrAddHandle(IntPtr handle);
    internal IntPtr GetHandle(IntPtr cookie);
    internal void RemoveHandleIfPresent(IntPtr handle);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public GuidAttribute(string guid);
    public string get_Value();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    internal object m_wrapper;
    internal IntPtr m_handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
[ComVisibleAttribute("False")]
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    [SecurityCriticalAttribute]
public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[ObsoleteAttribute("This attribute is deprecated and will be removed in a future version.", "False")]
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.IDispatchImplAttribute : Attribute {
    internal IDispatchImplType _val;
    public IDispatchImplType Value { get; }
    public IDispatchImplAttribute(IDispatchImplType implType);
    public IDispatchImplAttribute(short implType);
    public IDispatchImplType get_Value();
}
[ObsoleteAttribute("The IDispatchImplAttribute is deprecated.", "False")]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.IDispatchImplType : Enum {
    public int value__;
    public static IDispatchImplType SystemDefinedImpl;
    public static IDispatchImplType InternalImpl;
    public static IDispatchImplType CompatibleImpl;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IDLDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.IDLDESC : ValueType {
    public int dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IDLFLAG instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.ImportedFromTypeLibAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ImportedFromTypeLibAttribute(string tlbFile);
    public string get_Value();
}
internal class System.Runtime.InteropServices.ImporterCallback : object {
    public sealed virtual void ReportEvent(ImporterEventKind EventKind, int EventCode, string EventMsg);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly ResolveRef(object TypeLib);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ImporterEventKind : Enum {
    public int value__;
    public static ImporterEventKind NOTIF_TYPECONVERTED;
    public static ImporterEventKind NOTIF_CONVERTWARNING;
    public static ImporterEventKind ERROR_REFTOINVALIDTYPELIB;
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[AttributeUsageAttribute("1024")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    internal ComInterfaceType _val;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    public ComInterfaceType get_Value();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.INVOKEKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[GuidAttribute("CCBD682C-73A5-4568-B8B0-C7007E11ABA2")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.IRegistrationServices {
    [SecurityCriticalAttribute]
public abstract virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
    [SecurityCriticalAttribute]
public abstract virtual bool UnregisterAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public abstract virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public abstract virtual string GetProgIdForType(Type type);
    [SecurityCriticalAttribute]
public abstract virtual void RegisterTypeForComClients(Type type, Guid& g);
    public abstract virtual Guid GetManagedCategoryGuid();
    [SecurityCriticalAttribute]
public abstract virtual bool TypeRequiresRegistration(Type type);
    public abstract virtual bool TypeRepresentsComType(Type type);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("F1C3BF78-C3E4-11d3-88E7-00902754C43A")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.ITypeLibConverter {
    public abstract virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
    public abstract virtual object ConvertAssemblyToTypeLib(Assembly assembly, string typeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
    public abstract virtual bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase);
    public abstract virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
}
[GuidAttribute("FA1F3615-ACB9-486d-9EAC-1BEF87E36B09")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibExporterNameProvider {
    public abstract virtual String[] GetNames();
}
[GuidAttribute("F1C3BF77-C3E4-11d3-88E7-00902754C43A")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibExporterNotifySink {
    public abstract virtual void ReportEvent(ExporterEventKind eventKind, int eventCode, string eventMsg);
    public abstract virtual object ResolveRef(Assembly assembly);
}
[GuidAttribute("F1C3BF76-C3E4-11d3-88E7-00902754C43A")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibImporterNotifySink {
    public abstract virtual void ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg);
    public abstract virtual Assembly ResolveRef(object typeLib);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.LIBFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
[ComVisibleAttribute("False")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute : Attribute {
    internal Type _classType;
    internal string _methodName;
    public Type ClassType { get; }
    public string MethodName { get; }
    public ManagedToNativeComInteropStubAttribute(Type classType, string methodName);
    public Type get_ClassType();
    public string get_MethodName();
}
public static class System.Runtime.InteropServices.Marshal : object {
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    internal static Guid ManagedNameGuid;
    private static Marshal();
    [SecurityCriticalAttribute]
public static string PtrToStringAnsi(IntPtr ptr);
    [SecurityCriticalAttribute]
public static string PtrToStringAnsi(IntPtr ptr, int len);
    [SecurityCriticalAttribute]
public static string PtrToStringUni(IntPtr ptr, int len);
    [SecurityCriticalAttribute]
public static string PtrToStringAuto(IntPtr ptr, int len);
    [SecurityCriticalAttribute]
public static string PtrToStringUni(IntPtr ptr);
    [SecurityCriticalAttribute]
public static string PtrToStringAuto(IntPtr ptr);
    [ComVisibleAttribute("True")]
public static int SizeOf(object structure);
    public static int SizeOf(Type t);
    [ReliabilityContractAttribute("3", "2")]
internal static UInt32 SizeOf();
    [ReliabilityContractAttribute("3", "1")]
internal static UInt32 AlignedSizeOf();
    [SecuritySafeCriticalAttribute]
internal static int SizeOfHelper(Type t, bool throwIfNotMarshalable);
    public static IntPtr OffsetOf(Type t, string fieldName);
    [SecurityCriticalAttribute]
public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    [SecurityCriticalAttribute]
public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static byte ReadByte(object ptr, int ofs);
    [SecurityCriticalAttribute]
public static byte ReadByte(IntPtr ptr, int ofs);
    [SecurityCriticalAttribute]
public static byte ReadByte(IntPtr ptr);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static short ReadInt16(object ptr, int ofs);
    [SecurityCriticalAttribute]
public static short ReadInt16(IntPtr ptr, int ofs);
    [SecurityCriticalAttribute]
public static short ReadInt16(IntPtr ptr);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int ReadInt32(object ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public static int ReadInt32(IntPtr ptr, int ofs);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int ReadInt32(IntPtr ptr);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public static IntPtr ReadIntPtr(object ptr, int ofs);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public static IntPtr ReadIntPtr(IntPtr ptr);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
[SuppressUnmanagedCodeSecurityAttribute]
public static long ReadInt64(object ptr, int ofs);
    [SecurityCriticalAttribute]
public static long ReadInt64(IntPtr ptr, int ofs);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static long ReadInt64(IntPtr ptr);
    [SecurityCriticalAttribute]
public static void WriteByte(IntPtr ptr, int ofs, byte val);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static void WriteByte(object ptr, int ofs, byte val);
    [SecurityCriticalAttribute]
public static void WriteByte(IntPtr ptr, byte val);
    [SecurityCriticalAttribute]
public static void WriteInt16(IntPtr ptr, int ofs, short val);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt16(object ptr, int ofs, short val);
    [SecurityCriticalAttribute]
public static void WriteInt16(IntPtr ptr, short val);
    [SecurityCriticalAttribute]
public static void WriteInt16(IntPtr ptr, int ofs, char val);
    [SecurityCriticalAttribute]
public static void WriteInt16(object ptr, int ofs, char val);
    [SecurityCriticalAttribute]
public static void WriteInt16(IntPtr ptr, char val);
    [SecurityCriticalAttribute]
public static void WriteInt32(IntPtr ptr, int ofs, int val);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt32(object ptr, int ofs, int val);
    [SecurityCriticalAttribute]
public static void WriteInt32(IntPtr ptr, int val);
    [SecurityCriticalAttribute]
public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    [SecurityCriticalAttribute]
public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    [SecurityCriticalAttribute]
public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    [SecurityCriticalAttribute]
public static void WriteInt64(IntPtr ptr, int ofs, long val);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt64(object ptr, int ofs, long val);
    [SecurityCriticalAttribute]
public static void WriteInt64(IntPtr ptr, long val);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int GetLastWin32Error();
    [ReliabilityContractAttribute("3", "2")]
internal static void SetLastWin32Error(int error);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int GetHRForLastWin32Error();
    [SecurityCriticalAttribute]
public static void Prelink(MethodInfo m);
    [SecurityCriticalAttribute]
public static void PrelinkAll(Type c);
    [SecurityCriticalAttribute]
public static int NumParamBytes(MethodInfo m);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public static IntPtr GetExceptionPointers();
    [SecurityCriticalAttribute]
public static int GetExceptionCode();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public static void PtrToStructure(IntPtr ptr, object structure);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public static object PtrToStructure(IntPtr ptr, Type structureType);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public static void DestroyStructure(IntPtr ptr, Type structuretype);
    [SecurityCriticalAttribute]
public static IntPtr GetHINSTANCE(Module m);
    [SecurityCriticalAttribute]
public static void ThrowExceptionForHR(int errorCode);
    [SecurityCriticalAttribute]
public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static void ThrowExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    [SecurityCriticalAttribute]
public static Exception GetExceptionForHR(int errorCode);
    [SecurityCriticalAttribute]
public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static Exception GetExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    [SecurityCriticalAttribute]
public static int GetHRForException(Exception e);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static int GetHRForException_WinRT(Exception e);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("The GetUnmanagedThunkForManagedMethodPtr method has been deprecated and will be removed in a future release.", "False")]
public static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
    [ObsoleteAttribute("The GetManagedThunkForUnmanagedMethodPtr method has been deprecated and will be removed in a future release.", "False")]
[SecurityCriticalAttribute]
public static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("The GetThreadFromFiberCookie method has been deprecated.  Use the hosting API to perform this operation.", "False")]
public static Thread GetThreadFromFiberCookie(int cookie);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static IntPtr AllocHGlobal(IntPtr cb);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public static IntPtr AllocHGlobal(int cb);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void FreeHGlobal(IntPtr hglobal);
    [SecurityCriticalAttribute]
public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    [SecurityCriticalAttribute]
public static IntPtr StringToHGlobalAnsi(string s);
    [SecurityCriticalAttribute]
public static IntPtr StringToHGlobalUni(string s);
    [SecurityCriticalAttribute]
public static IntPtr StringToHGlobalAuto(string s);
    [ObsoleteAttribute("Use System.Runtime.InteropServices.Marshal.GetTypeLibName(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", "False")]
[SecurityCriticalAttribute]
public static string GetTypeLibName(UCOMITypeLib pTLB);
    [SecurityCriticalAttribute]
public static string GetTypeLibName(ITypeLib typelib);
    [SecurityCriticalAttribute]
internal static string GetTypeLibNameInternal(ITypeLib typelib);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.Marshal.GetTypeLibGuid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", "False")]
public static Guid GetTypeLibGuid(UCOMITypeLib pTLB);
    [SecurityCriticalAttribute]
public static Guid GetTypeLibGuid(ITypeLib typelib);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.Marshal.GetTypeLibLcid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", "False")]
public static int GetTypeLibLcid(UCOMITypeLib pTLB);
    [SecurityCriticalAttribute]
public static int GetTypeLibLcid(ITypeLib typelib);
    internal static void GetTypeLibVersion(ITypeLib typeLibrary, Int32& major, Int32& minor);
    [SecurityCriticalAttribute]
internal static Guid GetTypeInfoGuid(ITypeInfo typeInfo);
    [SecurityCriticalAttribute]
public static Guid GetTypeLibGuidForAssembly(Assembly asm);
    [SecurityCriticalAttribute]
public static void GetTypeLibVersionForAssembly(Assembly inputAssembly, Int32& majorVersion, Int32& minorVersion);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.Marshal.GetTypeInfoName(ITypeInfo pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&ID=0000011.", "False")]
public static string GetTypeInfoName(UCOMITypeInfo pTI);
    [SecurityCriticalAttribute]
public static string GetTypeInfoName(ITypeInfo typeInfo);
    [SecurityCriticalAttribute]
internal static string GetTypeInfoNameInternal(ITypeInfo typeInfo, Boolean& hasManagedName);
    [SecurityCriticalAttribute]
internal static string GetManagedTypeInfoNameInternal(ITypeLib typeLib, ITypeInfo typeInfo);
    [SecurityCriticalAttribute]
public static Type GetTypeForITypeInfo(IntPtr piTypeInfo);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid);
    [SecurityCriticalAttribute]
public static IntPtr GetITypeInfoForType(Type t);
    [SecurityCriticalAttribute]
public static IntPtr GetIUnknownForObject(object o);
    [SecurityCriticalAttribute]
public static IntPtr GetIUnknownForObjectInContext(object o);
    internal static IntPtr GetRawIUnknownForComObjectNoAddRef(object o);
    [SecurityCriticalAttribute]
public static IntPtr GetIDispatchForObject(object o);
    [SecurityCriticalAttribute]
public static IntPtr GetIDispatchForObjectInContext(object o);
    [SecurityCriticalAttribute]
public static IntPtr GetComInterfaceForObject(object o, Type T);
    [SecurityCriticalAttribute]
public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    [SecurityCriticalAttribute]
public static IntPtr GetComInterfaceForObjectInContext(object o, Type t);
    [SecurityCriticalAttribute]
public static object GetObjectForIUnknown(IntPtr pUnk);
    [SecurityCriticalAttribute]
public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    [SecurityCriticalAttribute]
public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    [SecurityCriticalAttribute]
public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    [SecurityCriticalAttribute]
public static void CleanupUnusedObjectsInCurrentContext();
    [SecurityCriticalAttribute]
public static bool AreComObjectsAvailableForCleanup();
    [SecuritySafeCriticalAttribute]
public static bool IsComObject(object o);
    [SecurityCriticalAttribute]
public static IntPtr AllocCoTaskMem(int cb);
    [SecurityCriticalAttribute]
public static IntPtr StringToCoTaskMemUni(string s);
    [SecurityCriticalAttribute]
public static IntPtr StringToCoTaskMemAuto(string s);
    [SecurityCriticalAttribute]
public static IntPtr StringToCoTaskMemAnsi(string s);
    [SecurityCriticalAttribute]
public static void FreeCoTaskMem(IntPtr ptr);
    [SecurityCriticalAttribute]
public static int ReleaseComObject(object o);
    internal static int InternalReleaseComObject(object o);
    [SecurityCriticalAttribute]
public static int FinalReleaseComObject(object o);
    internal static void InternalFinalReleaseComObject(object o);
    [SecurityCriticalAttribute]
public static object GetComObjectData(object obj, object key);
    [SecurityCriticalAttribute]
public static bool SetComObjectData(object obj, object key, object data);
    [SecurityCriticalAttribute]
public static object CreateWrapperOfType(object o, Type t);
    [ObsoleteAttribute("This API did not perform any operation and will be removed in future versions of the CLR.", "False")]
[SecurityCriticalAttribute]
public static void ReleaseThreadCache();
    [SecuritySafeCriticalAttribute]
public static bool IsTypeVisibleFromCom(Type t);
    [SecurityCriticalAttribute]
public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    [SecurityCriticalAttribute]
public static int AddRef(IntPtr pUnk);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int Release(IntPtr pUnk);
    [SecurityCriticalAttribute]
public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    [SecurityCriticalAttribute]
public static void FreeBSTR(IntPtr ptr);
    [SecurityCriticalAttribute]
public static IntPtr StringToBSTR(string s);
    [SecurityCriticalAttribute]
public static string PtrToStringBSTR(IntPtr ptr);
    [SecurityCriticalAttribute]
public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    [SecurityCriticalAttribute]
public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [SecurityCriticalAttribute]
public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    [SecurityCriticalAttribute]
public static int GetStartComSlot(Type t);
    [SecurityCriticalAttribute]
public static int GetEndComSlot(Type t);
    [SecurityCriticalAttribute]
public static MemberInfo GetMethodInfoForComSlot(Type t, int slot, ComMemberType& memberType);
    [SecurityCriticalAttribute]
public static int GetComSlotForMethodInfo(MemberInfo m);
    [SecurityCriticalAttribute]
public static Guid GenerateGuidForType(Type type);
    [SecurityCriticalAttribute]
public static string GenerateProgIdForType(Type type);
    [SecurityCriticalAttribute]
public static object BindToMoniker(string monikerName);
    [SecurityCriticalAttribute]
public static object GetActiveObject(string progID);
    internal static bool InternalSwitchCCW(object oldtp, object newtp);
    internal static object InternalWrapIUnknownWithComObject(IntPtr i);
    [SecurityCriticalAttribute]
public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void InitializeWrapperForWinRT(object o, IntPtr& pUnk);
    [SecurityCriticalAttribute]
internal static void InitializeManagedWinRTFactoryObject(object o, RuntimeType runtimeClassType);
    [SecurityCriticalAttribute]
internal static object GetNativeActivationFactory(Type type);
    [SecurityCriticalAttribute]
internal static Guid[] GetInspectableIids(object obj);
    [SecurityCriticalAttribute]
internal static Type GetCachedWinRTTypeByIid(AppDomain ad, Guid iid);
    [SecurityCriticalAttribute]
internal static Type[] GetCachedWinRTTypes(AppDomain ad, Int32& epoch);
    [SecurityCriticalAttribute]
internal static Type[] GetCachedWinRTTypes(AppDomain ad);
    [SecurityCriticalAttribute]
public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    internal static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    [SecurityCriticalAttribute]
public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    internal static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    [SecurityCriticalAttribute]
public static IntPtr SecureStringToBSTR(SecureString s);
    [SecurityCriticalAttribute]
public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    [SecurityCriticalAttribute]
public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    [SecurityCriticalAttribute]
public static void ZeroFreeBSTR(IntPtr s);
    [SecurityCriticalAttribute]
public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    [SecurityCriticalAttribute]
public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    [SecurityCriticalAttribute]
public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    [SecurityCriticalAttribute]
public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    [SecurityCriticalAttribute]
public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    [SecurityCriticalAttribute]
public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
}
[AttributeUsageAttribute("10496")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    internal UnmanagedType _val;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    [ComVisibleAttribute("True")]
public string MarshalType;
    [ComVisibleAttribute("True")]
public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    internal MarshalAsAttribute(UnmanagedType val, VarEnum safeArraySubType, RuntimeType safeArrayUserDefinedSubType, UnmanagedType arraySubType, short sizeParamIndex, int sizeConst, string marshalType, RuntimeType marshalTypeRef, string marshalCookie, int iidParamIndex);
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeParameterInfo parameter);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeFieldInfo field);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(int token, RuntimeModule scope);
    public UnmanagedType get_Value();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
internal static class System.Runtime.InteropServices.NativeMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void VariantClear(IntPtr variant);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ObjectCreationDelegate : MulticastDelegate {
    public ObjectCreationDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr aggregator);
    public virtual IAsyncResult BeginInvoke(IntPtr aggregator, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.PARAMDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.PARAMFLAG instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
internal enum System.Runtime.InteropServices.PInvokeMap : Enum {
    public int value__;
    public static PInvokeMap NoMangle;
    public static PInvokeMap CharSetMask;
    public static PInvokeMap CharSetNotSpec;
    public static PInvokeMap CharSetAnsi;
    public static PInvokeMap CharSetUnicode;
    public static PInvokeMap CharSetAuto;
    public static PInvokeMap PinvokeOLE;
    public static PInvokeMap SupportsLastError;
    public static PInvokeMap BestFitMask;
    public static PInvokeMap BestFitEnabled;
    public static PInvokeMap BestFitDisabled;
    public static PInvokeMap BestFitUseAsm;
    public static PInvokeMap ThrowOnUnmappableCharMask;
    public static PInvokeMap ThrowOnUnmappableCharEnabled;
    public static PInvokeMap ThrowOnUnmappableCharDisabled;
    public static PInvokeMap ThrowOnUnmappableCharUseAsm;
    public static PInvokeMap CallConvMask;
    public static PInvokeMap CallConvWinapi;
    public static PInvokeMap CallConvCdecl;
    public static PInvokeMap CallConvStdcall;
    public static PInvokeMap CallConvThiscall;
    public static PInvokeMap CallConvFastcall;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute : Attribute {
    internal int _major;
    internal int _minor;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public PrimaryInteropAssemblyAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.RegistrationClassContext : Enum {
    public int value__;
    public static RegistrationClassContext InProcessServer;
    public static RegistrationClassContext InProcessHandler;
    public static RegistrationClassContext LocalServer;
    public static RegistrationClassContext InProcessServer16;
    public static RegistrationClassContext RemoteServer;
    public static RegistrationClassContext InProcessHandler16;
    public static RegistrationClassContext Reserved1;
    public static RegistrationClassContext Reserved2;
    public static RegistrationClassContext Reserved3;
    public static RegistrationClassContext Reserved4;
    public static RegistrationClassContext NoCodeDownload;
    public static RegistrationClassContext Reserved5;
    public static RegistrationClassContext NoCustomMarshal;
    public static RegistrationClassContext EnableCodeDownload;
    public static RegistrationClassContext NoFailureLog;
    public static RegistrationClassContext DisableActivateAsActivator;
    public static RegistrationClassContext EnableActivateAsActivator;
    public static RegistrationClassContext FromDefaultContext;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.RegistrationConnectionType : Enum {
    public int value__;
    public static RegistrationConnectionType SingleUse;
    public static RegistrationConnectionType MultipleUse;
    public static RegistrationConnectionType MultiSeparate;
    public static RegistrationConnectionType Suspended;
    public static RegistrationConnectionType Surrogate;
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[GuidAttribute("475E398F-8AFA-43a7-A3BE-F4EF8D6787C9")]
public class System.Runtime.InteropServices.RegistrationServices : object {
    private static RegistrationServices();
    [SecurityCriticalAttribute]
public virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
    [SecurityCriticalAttribute]
public virtual bool UnregisterAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public virtual string GetProgIdForType(Type type);
    [SecurityCriticalAttribute]
public virtual void RegisterTypeForComClients(Type type, Guid& g);
    public virtual Guid GetManagedCategoryGuid();
    [SecurityCriticalAttribute]
public virtual bool TypeRequiresRegistration(Type type);
    [SecuritySafeCriticalAttribute]
public virtual bool TypeRepresentsComType(Type type);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int RegisterTypeForComClients(Type type, RegistrationClassContext classContext, RegistrationConnectionType flags);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public virtual void UnregisterTypeForComClients(int cookie);
    [SecurityCriticalAttribute]
internal static bool TypeRequiresRegistrationHelper(Type type);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.RuntimeEnvironment : object {
    public static string SystemConfigurationFile { get; }
    [SecurityCriticalAttribute]
internal static string GetModuleFileName();
    [SecurityCriticalAttribute]
internal static string GetDeveloperPath();
    [SecurityCriticalAttribute]
internal static string GetHostBindingFile();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void _GetSystemVersion(StringHandleOnStack retVer);
    public static bool FromGlobalAccessCache(Assembly a);
    [SecuritySafeCriticalAttribute]
public static string GetSystemVersion();
    [SecuritySafeCriticalAttribute]
public static string GetRuntimeDirectory();
    [SecurityCriticalAttribute]
internal static string GetRuntimeDirectoryImpl();
    [SecuritySafeCriticalAttribute]
public static string get_SystemConfigurationFile();
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public static IntPtr GetRuntimeInterfaceAsIntPtr(Guid clsid, Guid riid);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public static object GetRuntimeInterfaceAsObject(Guid clsid, Guid riid);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "1")]
public void AcquirePointer(Byte*& pointer);
    [ReliabilityContractAttribute("3", "2")]
public void ReleasePointer();
    [ReliabilityContractAttribute("3", "1")]
[CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "1")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "1")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "1")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    [ReliabilityContractAttribute("3", "2")]
public ulong get_ByteLength();
    [ReliabilityContractAttribute("3", "2")]
internal static void GenericPtrToStructure(Byte* ptr, T& structure, UInt32 sizeofT);
    [ReliabilityContractAttribute("3", "2")]
internal static void GenericStructureToPtr(T& structure, Byte* ptr, UInt32 sizeofT);
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    [ForceTokenStabilizationAttribute]
protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
protected void SetHandle(IntPtr handle);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public IntPtr DangerousGetHandle();
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsClosed();
    [ReliabilityContractAttribute("3", "2")]
public abstract virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public void Close();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void SetHandleAsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected abstract virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public void DangerousAddRef(Boolean& success);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void DangerousRelease();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
[ObsoleteAttribute("This attribute has been deprecated.  Application Domains no longer respect Activation Context boundaries in IDispatch calls.", "False")]
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute : Attribute {
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.STATSTG instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
[AttributeUsageAttribute("12")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    internal LayoutKind _val;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    internal StructLayoutAttribute(LayoutKind layoutKind, int pack, int size, CharSet charSet);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
    public LayoutKind get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.SYSKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
}
internal class System.Runtime.InteropServices.TCEAdapterGen.EventItfInfo : object {
    public EventItfInfo(string strEventItfName, string strSrcItfName, string strEventProviderName, RuntimeAssembly asmImport, RuntimeAssembly asmSrcItf);
    public Type GetEventItfType();
    public Type GetSrcItfType();
    public string GetEventProviderName();
}
internal class System.Runtime.InteropServices.TCEAdapterGen.EventProviderWriter : object {
    public EventProviderWriter(ModuleBuilder OutputModule, string strDestTypeName, Type EventItfType, Type SrcItfType, Type SinkHelperType);
    public Type Perform();
}
internal class System.Runtime.InteropServices.TCEAdapterGen.EventSinkHelperWriter : object {
    public static string GeneratedTypeNamePostfix;
    public EventSinkHelperWriter(ModuleBuilder OutputModule, Type InputType, Type EventItfType);
    private static EventSinkHelperWriter();
    public Type Perform();
}
internal static class System.Runtime.InteropServices.TCEAdapterGen.NameSpaceExtractor : object {
    private static NameSpaceExtractor();
    public static string ExtractNameSpace(string FullyQualifiedTypeName);
}
internal class System.Runtime.InteropServices.TCEAdapterGen.TCEAdapterGenerator : object {
    private static TCEAdapterGenerator();
    public void Process(ModuleBuilder ModBldr, ArrayList EventItfList);
    internal static void SetClassInterfaceTypeToNone(TypeBuilder tb);
    internal static TypeBuilder DefineUniqueType(string strInitFullName, TypeAttributes attrs, Type BaseType, Type[] aInterfaceTypes, ModuleBuilder mb);
    internal static void SetHiddenAttribute(TypeBuilder tb);
    internal static MethodInfo[] GetNonPropertyMethods(Type type);
    internal static MethodInfo[] GetPropertyMethods(Type type);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEATTR instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
[AttributeUsageAttribute("5144")]
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    internal string Scope_;
    internal string Identifier_;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Scope();
    public string get_Identifier();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPELIBATTR instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
[GuidAttribute("F1C3BF79-C3E4-11d3-88E7-00902754C43A")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Runtime.InteropServices.TypeLibConverter : object {
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
    [SecuritySafeCriticalAttribute]
public sealed virtual object ConvertAssemblyToTypeLib(Assembly assembly, string strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
    public sealed virtual bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase);
    [SecurityCriticalAttribute]
internal static AssemblyName GetAssemblyNameFromTypelib(object typeLib, string asmFileName, Byte[] publicKey, StrongNameKeyPair keyPair, Version asmVersion, AssemblyNameFlags asmNameFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void LoadInMemoryTypeByName(RuntimeModule module, string className);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibExporterFlags : Enum {
    public int value__;
    public static TypeLibExporterFlags None;
    public static TypeLibExporterFlags OnlyReferenceRegistered;
    public static TypeLibExporterFlags CallerResolvedReferences;
    public static TypeLibExporterFlags OldNames;
    public static TypeLibExporterFlags ExportAs32Bit;
    public static TypeLibExporterFlags ExportAs64Bit;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibFuncAttribute : Attribute {
    internal TypeLibFuncFlags _val;
    public TypeLibFuncFlags Value { get; }
    public TypeLibFuncAttribute(TypeLibFuncFlags flags);
    public TypeLibFuncAttribute(short flags);
    public TypeLibFuncFlags get_Value();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibFuncFlags : Enum {
    public int value__;
    public static TypeLibFuncFlags FRestricted;
    public static TypeLibFuncFlags FSource;
    public static TypeLibFuncFlags FBindable;
    public static TypeLibFuncFlags FRequestEdit;
    public static TypeLibFuncFlags FDisplayBind;
    public static TypeLibFuncFlags FDefaultBind;
    public static TypeLibFuncFlags FHidden;
    public static TypeLibFuncFlags FUsesGetLastError;
    public static TypeLibFuncFlags FDefaultCollelem;
    public static TypeLibFuncFlags FUiDefault;
    public static TypeLibFuncFlags FNonBrowsable;
    public static TypeLibFuncFlags FReplaceable;
    public static TypeLibFuncFlags FImmediateBind;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.TypeLibImportClassAttribute : Attribute {
    internal string _importClassName;
    public string Value { get; }
    public TypeLibImportClassAttribute(Type importClass);
    public string get_Value();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibImporterFlags : Enum {
    public int value__;
    public static TypeLibImporterFlags None;
    public static TypeLibImporterFlags PrimaryInteropAssembly;
    public static TypeLibImporterFlags UnsafeInterfaces;
    public static TypeLibImporterFlags SafeArrayAsSystemArray;
    public static TypeLibImporterFlags TransformDispRetVals;
    public static TypeLibImporterFlags PreventClassMembers;
    public static TypeLibImporterFlags SerializableValueClasses;
    public static TypeLibImporterFlags ImportAsX86;
    public static TypeLibImporterFlags ImportAsX64;
    public static TypeLibImporterFlags ImportAsItanium;
    public static TypeLibImporterFlags ImportAsAgnostic;
    public static TypeLibImporterFlags ReflectionOnlyLoading;
    public static TypeLibImporterFlags NoDefineVersionResource;
    public static TypeLibImporterFlags ImportAsArm;
}
[AttributeUsageAttribute("1052")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibTypeAttribute : Attribute {
    internal TypeLibTypeFlags _val;
    public TypeLibTypeFlags Value { get; }
    public TypeLibTypeAttribute(TypeLibTypeFlags flags);
    public TypeLibTypeAttribute(short flags);
    public TypeLibTypeFlags get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibTypeFlags : Enum {
    public int value__;
    public static TypeLibTypeFlags FAppObject;
    public static TypeLibTypeFlags FCanCreate;
    public static TypeLibTypeFlags FLicensed;
    public static TypeLibTypeFlags FPreDeclId;
    public static TypeLibTypeFlags FHidden;
    public static TypeLibTypeFlags FControl;
    public static TypeLibTypeFlags FDual;
    public static TypeLibTypeFlags FNonExtensible;
    public static TypeLibTypeFlags FOleAutomation;
    public static TypeLibTypeFlags FRestricted;
    public static TypeLibTypeFlags FAggregatable;
    public static TypeLibTypeFlags FReplaceable;
    public static TypeLibTypeFlags FDispatchable;
    public static TypeLibTypeFlags FReverseBind;
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibVarAttribute : Attribute {
    internal TypeLibVarFlags _val;
    public TypeLibVarFlags Value { get; }
    public TypeLibVarAttribute(TypeLibVarFlags flags);
    public TypeLibVarAttribute(short flags);
    public TypeLibVarFlags get_Value();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.TypeLibVarFlags : Enum {
    public int value__;
    public static TypeLibVarFlags FReadOnly;
    public static TypeLibVarFlags FSource;
    public static TypeLibVarFlags FBindable;
    public static TypeLibVarFlags FRequestEdit;
    public static TypeLibVarFlags FDisplayBind;
    public static TypeLibVarFlags FDefaultBind;
    public static TypeLibVarFlags FHidden;
    public static TypeLibVarFlags FRestricted;
    public static TypeLibVarFlags FDefaultCollelem;
    public static TypeLibVarFlags FUiDefault;
    public static TypeLibVarFlags FNonBrowsable;
    public static TypeLibVarFlags FReplaceable;
    public static TypeLibVarFlags FImmediateBind;
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibVersionAttribute : Attribute {
    internal int _major;
    internal int _minor;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public TypeLibVersionAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IBindCtx instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(UCOMIRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(UCOMIEnumString& ppenum);
    public abstract virtual void RevokeObjectParam(string pszKey);
}
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IConnectionPoint instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public interface System.Runtime.InteropServices.UCOMIConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(UCOMIConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(UCOMIEnumConnections& ppEnum);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IConnectionPointContainer instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.UCOMIConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(UCOMIEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, UCOMIConnectionPoint& ppCP);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIEnumConnectionPoints {
    public abstract virtual int Next(int celt, UCOMIConnectionPoint[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumConnectionPoints& ppenum);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumConnections instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.UCOMIEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(UCOMIEnumConnections& ppenum);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumerable instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.UCOMIEnumerable {
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumerator instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.UCOMIEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumMoniker instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIEnumMoniker {
    public abstract virtual int Next(int celt, UCOMIMoniker[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumMoniker& ppenum);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumString instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumString& ppenum);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumVARIANT instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIEnumVARIANT {
    public abstract virtual int Next(int celt, int rgvar, int pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(int ppenum);
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IExpando instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
internal interface System.Runtime.InteropServices.UCOMIExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual PropertyInfo AddProperty(string name);
    public abstract virtual MethodInfo AddMethod(string name, Delegate method);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IMoniker instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(UCOMIStream pStm);
    public abstract virtual void Save(UCOMIStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, UCOMIMoniker& ppmkToLeft, UCOMIMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, UCOMIMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, UCOMIEnumMoniker& ppenumMoniker);
    public abstract virtual void IsEqual(UCOMIMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(UCOMIMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, UCOMIMoniker& ppmkOut);
    public abstract virtual void IsSystemMoniker(Int32& pdwMksys);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IPersistFile instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IReflect instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.UCOMIReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IRunningObjectTable instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public interface System.Runtime.InteropServices.UCOMIRunningObjectTable {
    public abstract virtual void Register(int grfFlags, object punkObject, UCOMIMoniker pmkObjectName, Int32& pdwRegister);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual void IsRunning(UCOMIMoniker pmkObjectName);
    public abstract virtual void GetObject(UCOMIMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(UCOMIEnumMoniker& ppenumMoniker);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IStream instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(UCOMIStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(UCOMIStream& ppstm);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ITypeComp instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.UCOMITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, UCOMITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, UCOMITypeInfo& ppTInfo, UCOMITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ITypeInfo instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public interface System.Runtime.InteropServices.UCOMITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(UCOMITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, Int32& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, Object& pVarResult, EXCEPINFO& pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, String& pBstrDllName, String& pBstrName, Int16& pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, UCOMITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(UCOMITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ITypeLib instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.UCOMITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, UCOMITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, UCOMITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(UCOMITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, UCOMITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.UnknownWrapper : object {
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("4096")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    public CharSet CharSet;
    public bool BestFitMapping;
    public bool ThrowOnUnmappableChar;
    public bool SetLastError;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    public CallingConvention get_CallingConvention();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    [ComVisibleAttribute("False")]
public static UnmanagedType IInspectable;
    [ComVisibleAttribute("False")]
public static UnmanagedType HString;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.VARDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VarEnum varkind;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.VARFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    internal bool IsEmpty { get; }
    internal bool IsByRef { get; }
    public sbyte AsI1 { get; public set; }
    public short AsI2 { get; public set; }
    public int AsI4 { get; public set; }
    public long AsI8 { get; public set; }
    public byte AsUi1 { get; public set; }
    public ushort AsUi2 { get; public set; }
    public UInt32 AsUi4 { get; public set; }
    public ulong AsUi8 { get; public set; }
    public int AsInt { get; public set; }
    public UInt32 AsUint { get; public set; }
    public bool AsBool { get; public set; }
    public int AsError { get; public set; }
    public float AsR4 { get; public set; }
    public double AsR8 { get; public set; }
    public decimal AsDecimal { get; public set; }
    public decimal AsCy { get; public set; }
    public DateTime AsDate { get; public set; }
    public string AsBstr { get; public set; }
    public object AsUnknown { get; public set; }
    public object AsDispatch { get; public set; }
    internal static bool IsPrimitiveType(VarEnum varEnum);
    public void CopyFromIndirect(object value);
    public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    internal bool get_IsEmpty();
    internal bool get_IsByRef();
    public void SetAsNULL();
    public sbyte get_AsI1();
    public void set_AsI1(sbyte value);
    public short get_AsI2();
    public void set_AsI2(short value);
    public int get_AsI4();
    public void set_AsI4(int value);
    public long get_AsI8();
    public void set_AsI8(long value);
    public byte get_AsUi1();
    public void set_AsUi1(byte value);
    public ushort get_AsUi2();
    public void set_AsUi2(ushort value);
    public UInt32 get_AsUi4();
    public void set_AsUi4(UInt32 value);
    public ulong get_AsUi8();
    public void set_AsUi8(ulong value);
    public int get_AsInt();
    public void set_AsInt(int value);
    public UInt32 get_AsUint();
    public void set_AsUint(UInt32 value);
    public bool get_AsBool();
    public void set_AsBool(bool value);
    public int get_AsError();
    public void set_AsError(int value);
    public float get_AsR4();
    public void set_AsR4(float value);
    public double get_AsR8();
    public void set_AsR8(double value);
    public decimal get_AsDecimal();
    public void set_AsDecimal(decimal value);
    public decimal get_AsCy();
    public void set_AsCy(decimal value);
    public DateTime get_AsDate();
    public void set_AsDate(DateTime value);
    public string get_AsBstr();
    public void set_AsBstr(string value);
    public object get_AsUnknown();
    public void set_AsUnknown(object value);
    public object get_AsDispatch();
    public void set_AsDispatch(object value);
}
public class System.Runtime.InteropServices.VariantWrapper : object {
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableIterableToEnumerableAdapter : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal IEnumerator GetEnumerator_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToCollectionAdapter : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal int Count();
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal bool IsSynchronized();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal object SyncRoot();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void CopyTo(Array array, int arrayIndex);
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToListAdapter : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal object Indexer_Get(int index);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void Indexer_Set(int index, object value);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal int Add(object value);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal bool Contains(object item);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal bool IsFixedSize();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal bool IsReadOnly();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal int IndexOf(object item);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void Insert(int index, object item);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void Remove(object item);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void RemoveAt(int index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIKeyValuePairImpl`2 : object {
    public K Key { get; }
    public V Value { get; }
    public CLRIKeyValuePairImpl`2(KeyValuePair`2& pair);
    public sealed virtual K get_Key();
    public sealed virtual V get_Value();
    internal static object BoxHelper(object pair);
    internal static object UnboxHelper(object wrapper);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIPropertyValueImpl : object {
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    internal CLRIPropertyValueImpl(PropertyType type, object data);
    public sealed virtual PropertyType get_Type();
    public sealed virtual bool get_IsNumericScalar();
    public sealed virtual byte GetUInt8();
    public sealed virtual short GetInt16();
    public sealed virtual ushort GetUInt16();
    public sealed virtual int GetInt32();
    public sealed virtual UInt32 GetUInt32();
    public sealed virtual long GetInt64();
    public sealed virtual ulong GetUInt64();
    public sealed virtual float GetSingle();
    public sealed virtual double GetDouble();
    public sealed virtual char GetChar16();
    public sealed virtual bool GetBoolean();
    public sealed virtual string GetString();
    public object GetInspectable();
    public sealed virtual Guid GetGuid();
    public sealed virtual DateTimeOffset GetDateTime();
    public sealed virtual TimeSpan GetTimeSpan();
    [SecuritySafeCriticalAttribute]
public sealed virtual Point GetPoint();
    [SecuritySafeCriticalAttribute]
public sealed virtual Size GetSize();
    [SecuritySafeCriticalAttribute]
public sealed virtual Rect GetRect();
    public sealed virtual Byte[] GetUInt8Array();
    public sealed virtual Int16[] GetInt16Array();
    public sealed virtual UInt16[] GetUInt16Array();
    public sealed virtual Int32[] GetInt32Array();
    public sealed virtual UInt32[] GetUInt32Array();
    public sealed virtual Int64[] GetInt64Array();
    public sealed virtual UInt64[] GetUInt64Array();
    public sealed virtual Single[] GetSingleArray();
    public sealed virtual Double[] GetDoubleArray();
    public sealed virtual Char[] GetChar16Array();
    public sealed virtual Boolean[] GetBooleanArray();
    public sealed virtual String[] GetStringArray();
    public sealed virtual Object[] GetInspectableArray();
    public sealed virtual Guid[] GetGuidArray();
    public sealed virtual DateTimeOffset[] GetDateTimeArray();
    public sealed virtual TimeSpan[] GetTimeSpanArray();
    [SecuritySafeCriticalAttribute]
public sealed virtual Point[] GetPointArray();
    [SecuritySafeCriticalAttribute]
public sealed virtual Size[] GetSizeArray();
    [SecuritySafeCriticalAttribute]
public sealed virtual Rect[] GetRectArray();
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceArrayImpl`1 : CLRIPropertyValueImpl {
    public T[] Value { get; }
    private Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.Type { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public CLRIReferenceArrayImpl`1(PropertyType type, T[] obj);
    public sealed virtual T[] get_Value();
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetCustomProperty(string name);
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetIndexedProperty(string name, Type indexParameterType);
    private sealed virtual override string System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetStringRepresentation();
    private sealed virtual override Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.get_Type();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    internal static object UnboxHelper(object wrapper);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceImpl`1 : CLRIPropertyValueImpl {
    public T Value { get; }
    private Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.Type { get; }
    public CLRIReferenceImpl`1(PropertyType type, T obj);
    public sealed virtual T get_Value();
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetCustomProperty(string name);
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetIndexedProperty(string name, Type indexParameterType);
    private sealed virtual override string System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetStringRepresentation();
    private sealed virtual override Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.get_Type();
    internal static object UnboxHelper(object wrapper);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ConstantSplittableMap`2 : object {
    public int Count { get; }
    public UInt32 Size { get; }
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    internal ConstantSplittableMap`2(IReadOnlyDictionary`2<TKey, TValue> data);
    internal ConstantSplittableMap`2(IMapView`2<TKey, TValue> data);
    private static ConstantSplittableMap`2();
    public int get_Count();
    public sealed virtual UInt32 get_Size();
    public sealed virtual TValue Lookup(TKey key);
    public sealed virtual bool HasKey(TKey key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IIterator`1<IKeyValuePair`2<TKey, TValue>> First();
    public sealed virtual IEnumerator`1<IKeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Split(IMapView`2& firstPartition, IMapView`2& secondPartition);
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue get_Item(TKey key);
    public IEnumerable`1<TKey> get_Keys();
    public IEnumerable`1<TValue> get_Values();
}
internal class System.Runtime.InteropServices.WindowsRuntime.CustomPropertyImpl : object {
    public string Name { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    public CustomPropertyImpl(PropertyInfo propertyInfo);
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual object GetValue(object target);
    public sealed virtual object GetValue(object target, object indexValue);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual void SetValue(object target, object value, object indexValue);
    public sealed virtual Type get_Type();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
    public Type DefaultInterface { get; }
    public DefaultInterfaceAttribute(Type defaultInterface);
    public Type get_DefaultInterface();
}
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs : EventArgs {
    public string NamespaceName { get; }
    public Collection`1<string> ResolvedAssemblyFiles { get; }
    public DesignerNamespaceResolveEventArgs(string namespaceName);
    public string get_NamespaceName();
    public Collection`1<string> get_ResolvedAssemblyFiles();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyCollection`2 : object {
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
    public DictionaryKeyCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TKey[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Clear();
    public sealed virtual bool Contains(TKey item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyEnumerator`2 : object {
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public DictionaryKeyEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryToMapAdapter : object {
    [SecurityCriticalAttribute]
internal V Lookup(K key);
    [SecurityCriticalAttribute]
internal UInt32 Size();
    [SecurityCriticalAttribute]
internal bool HasKey(K key);
    [SecurityCriticalAttribute]
internal IReadOnlyDictionary`2<K, V> GetView();
    [SecurityCriticalAttribute]
internal bool Insert(K key, V value);
    [SecurityCriticalAttribute]
internal void Remove(K key);
    [SecurityCriticalAttribute]
internal void Clear();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueCollection`2 : object {
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
    public DictionaryValueCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TValue[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Clear();
    public sealed virtual bool Contains(TValue item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueEnumerator`2 : object {
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public DictionaryValueEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToBindableIterableAdapter : object {
    [SecurityCriticalAttribute]
internal IBindableIterator First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToIterableAdapter : object {
    [SecurityCriticalAttribute]
internal IIterator`1<T> First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumeratorToIteratorAdapter`1 : object {
    public T Current { get; }
    private object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.Current { get; }
    public bool HasCurrent { get; }
    internal EnumeratorToIteratorAdapter`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.get_Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual int GetMany(T[] items);
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
    internal ulong m_value;
    internal ulong Value { get; }
    internal EventRegistrationToken(ulong value);
    internal ulong get_Value();
    public static bool op_Equality(EventRegistrationToken left, EventRegistrationToken right);
    public static bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
    public T InvocationList { get; public set; }
    public T get_InvocationList();
    public void set_InvocationList(T value);
    public EventRegistrationToken AddEventHandler(T handler);
    [FriendAccessAllowedAttribute]
internal T ExtractHandler(EventRegistrationToken token);
    public void RemoveEventHandler(EventRegistrationToken token);
    public void RemoveEventHandler(T handler);
    public static EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable);
}
internal class System.Runtime.InteropServices.WindowsRuntime.GetEnumerator_Delegate`1 : MulticastDelegate {
    public GetEnumerator_Delegate`1(object object, IntPtr method);
    public virtual IEnumerator`1<T> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IEnumerator`1<T> EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.WindowsRuntime.HSTRING_HEADER : ValueType {
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
    public abstract virtual object ActivateInstance();
}
[GuidAttribute("036d2c08-df29-41af-8aa2-d774be62ba6f")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterable {
    public abstract virtual IBindableIterator First();
}
[GuidAttribute("6a1d6c07-076d-49f2-8314-f52c9c9a8331")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterator {
    public object Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
}
[GuidAttribute("393de7de-6fd0-4c0d-bb71-47244a113e93")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVector {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IBindableVectorView GetView();
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, object value);
    public abstract virtual void InsertAt(UInt32 index, object value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(object value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
}
[GuidAttribute("346dd6e7-976e-4bc3-815d-ece243bc0f33")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(object value, UInt32& index);
}
[ForceTokenStabilizationAttribute]
[GuidAttribute("30d5a829-7fa4-4026-83bb-d75bae4ea99e")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IClosable {
    public abstract virtual void Close();
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.IClosableToIDisposableAdapter : object {
}
[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICustomProperty {
    public Type Type { get; }
    public string Name { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public abstract virtual Type get_Type();
    public abstract virtual string get_Name();
    public abstract virtual object GetValue(object target);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target, object indexValue);
    public abstract virtual void SetValue(object target, object value, object indexValue);
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanRead();
}
[GuidAttribute("7C925755-3E48-42B4-8677-76372267033F")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider {
    public Type Type { get; }
    public abstract virtual ICustomProperty GetCustomProperty(string name);
    public abstract virtual ICustomProperty GetIndexedProperty(string name, Type indexParameterType);
    public abstract virtual string GetStringRepresentation();
    public abstract virtual Type get_Type();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderImpl : object {
    internal static ICustomProperty CreateProperty(object target, string propertyName);
    [SecurityCriticalAttribute]
internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, TypeNameNative* pIndexedParamType);
    internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, Type indexedParamType);
    [SecurityCriticalAttribute]
internal static void GetType(object target, TypeNameNative* pIndexedParamType);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderProxy`2 : object {
    private Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.Type { get; }
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Size { get; }
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.Size { get; }
    internal ICustomPropertyProviderProxy`2(object target, InterfaceForwardingSupport flags);
    internal static object CreateInstance(object target);
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetCustomProperty(string name);
    private sealed virtual override ICustomProperty System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetIndexedProperty(string name, Type indexParameterType);
    private sealed virtual override string System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.GetStringRepresentation();
    private sealed virtual override Type System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProvider.get_Type();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    [SecurityCriticalAttribute]
public sealed virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.get_Size();
    private sealed virtual override IBindableVectorView System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetView();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVector.IndexOf(object value, UInt32& index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.SetAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.InsertAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAt(UInt32 index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Append(object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAtEnd();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Clear();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.get_Size();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.IndexOf(object value, UInt32& index);
    private sealed virtual override IBindableIterator System.Runtime.InteropServices.WindowsRuntime.IBindableIterable.First();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IDisposableToIClosableAdapter : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
public void Close();
}
internal interface System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget {
    public abstract virtual object GetTarget();
}
[ForceTokenStabilizationAttribute]
[GuidAttribute("faa585ea-6214-4217-afda-7f46de5869b3")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterable`1 {
    public abstract virtual IIterator`1<T> First();
}
[GuidAttribute("6a79e863-4300-459a-9966-cbb660963ee1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterator`1 {
    public T Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
    public abstract virtual int GetMany(T[] items);
}
[GuidAttribute("02b51929-c1c4-4a7e-8940-0312b5c18500")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IKeyValuePair`2 {
    public K Key { get; }
    public V Value { get; }
    public abstract virtual K get_Key();
    public abstract virtual V get_Value();
}
[GuidAttribute("60D27C8D-5F61-4CCE-B751-690FAE66AA53")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory {
    public abstract virtual void RunClassConstructor();
}
[ForceTokenStabilizationAttribute]
[GuidAttribute("3c2925fe-8519-45c1-aa79-197b6718c1c1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMap`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual IReadOnlyDictionary`2<K, V> GetView();
    public abstract virtual bool Insert(K key, V value);
    public abstract virtual void Remove(K key);
    public abstract virtual void Clear();
}
[GuidAttribute("e480ce40-a338-4ada-adcf-272272e48cb9")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMapView`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IMapViewToIReadOnlyDictionaryAdapter : object {
    [SecurityCriticalAttribute]
internal V Indexer_Get(K key);
    [SecurityCriticalAttribute]
internal IEnumerable`1<K> Keys();
    [SecurityCriticalAttribute]
internal IEnumerable`1<V> Values();
    [SecurityCriticalAttribute]
internal bool ContainsKey(K key);
    [SecurityCriticalAttribute]
internal bool TryGetValue(K key, V& value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Indexer_Get_Delegate`1 : MulticastDelegate {
    public Indexer_Get_Delegate`1(object object, IntPtr method);
    public virtual T Invoke(int index);
    public virtual IAsyncResult BeginInvoke(int index, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.WindowsRuntime.InterfaceForwardingSupport : Enum {
    public int value__;
    public static InterfaceForwardingSupport None;
    public static InterfaceForwardingSupport IBindableVector;
    public static InterfaceForwardingSupport IVector;
    public static InterfaceForwardingSupport IBindableVectorView;
    public static InterfaceForwardingSupport IVectorView;
    public static InterfaceForwardingSupport IBindableIterableOrIIterable;
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
    public Type InterfaceType { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public byte BuildVersion { get; }
    public byte RevisionVersion { get; }
    public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
    public Type get_InterfaceType();
    public byte get_MajorVersion();
    public byte get_MinorVersion();
    public byte get_BuildVersion();
    public byte get_RevisionVersion();
}
[GuidAttribute("4bd682dd-7554-40e9-9a9b-82654ede7e62")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyValue {
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    public abstract virtual PropertyType get_Type();
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual Byte[] GetUInt8Array();
    public abstract virtual Int16[] GetInt16Array();
    public abstract virtual UInt16[] GetUInt16Array();
    public abstract virtual Int32[] GetInt32Array();
    public abstract virtual UInt32[] GetUInt32Array();
    public abstract virtual Int64[] GetInt64Array();
    public abstract virtual UInt64[] GetUInt64Array();
    public abstract virtual Single[] GetSingleArray();
    public abstract virtual Double[] GetDoubleArray();
    public abstract virtual Char[] GetChar16Array();
    public abstract virtual Boolean[] GetBooleanArray();
    public abstract virtual String[] GetStringArray();
    public abstract virtual Object[] GetInspectableArray();
    public abstract virtual Guid[] GetGuidArray();
    public abstract virtual DateTimeOffset[] GetDateTimeArray();
    public abstract virtual TimeSpan[] GetTimeSpanArray();
    public abstract virtual Point[] GetPointArray();
    public abstract virtual Size[] GetSizeArray();
    public abstract virtual Rect[] GetRectArray();
}
[GuidAttribute("629bdbc8-d932-4ff4-96b9-8d96c5c1e858")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyValueFactory {
    public abstract virtual IPropertyValue CreateEmpty();
    public abstract virtual IPropertyValue CreateUInt8(byte value);
    public abstract virtual IPropertyValue CreateInt16(short value);
    public abstract virtual IPropertyValue CreateUInt16(ushort value);
    public abstract virtual IPropertyValue CreateInt32(int value);
    public abstract virtual IPropertyValue CreateUInt32(UInt32 value);
    public abstract virtual IPropertyValue CreateInt64(long value);
    public abstract virtual IPropertyValue CreateUInt64(ulong value);
    public abstract virtual IPropertyValue CreateSingle(float value);
    public abstract virtual IPropertyValue CreateDouble(double value);
    public abstract virtual IPropertyValue CreateChar16(char value);
    public abstract virtual IPropertyValue CreateBoolean(bool value);
    public abstract virtual IPropertyValue CreateString(string value);
    public abstract virtual IPropertyValue CreateInspectable(object value);
    public abstract virtual IPropertyValue CreateGuid(Guid value);
    public abstract virtual IPropertyValue CreateDateTime(DateTimeOffset value);
    public abstract virtual IPropertyValue CreateTimeSpan(TimeSpan value);
    public abstract virtual IPropertyValue CreatePoint(Point value);
    public abstract virtual IPropertyValue CreateSize(Size value);
    public abstract virtual IPropertyValue CreateRect(Rect value);
    public abstract virtual IPropertyValue CreateUInt8Array(Byte[] value);
    public abstract virtual IPropertyValue CreateInt16Array(Int16[] value);
    public abstract virtual IPropertyValue CreateUInt16Array(UInt16[] value);
    public abstract virtual IPropertyValue CreateInt32Array(Int32[] value);
    public abstract virtual IPropertyValue CreateUInt32Array(UInt32[] value);
    public abstract virtual IPropertyValue CreateInt64Array(Int64[] value);
    public abstract virtual IPropertyValue CreateUInt64Array(UInt64[] value);
    public abstract virtual IPropertyValue CreateSingleArray(Single[] value);
    public abstract virtual IPropertyValue CreateDoubleArray(Double[] value);
    public abstract virtual IPropertyValue CreateChar16Array(Char[] value);
    public abstract virtual IPropertyValue CreateBooleanArray(Boolean[] value);
    public abstract virtual IPropertyValue CreateStringArray(String[] value);
    public abstract virtual IPropertyValue CreateInspectableArray(Object[] value);
    public abstract virtual IPropertyValue CreateGuidArray(Guid[] value);
    public abstract virtual IPropertyValue CreateDateTimeArray(DateTimeOffset[] value);
    public abstract virtual IPropertyValue CreateTimeSpanArray(TimeSpan[] value);
    public abstract virtual IPropertyValue CreatePointArray(Point[] value);
    public abstract virtual IPropertyValue CreateSizeArray(Size[] value);
    public abstract virtual IPropertyValue CreateRectArray(Rect[] value);
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyDictionaryToIMapViewAdapter : object {
    [SecurityCriticalAttribute]
internal V Lookup(K key);
    [SecurityCriticalAttribute]
internal UInt32 Size();
    [SecurityCriticalAttribute]
internal bool HasKey(K key);
    [SecurityCriticalAttribute]
internal void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyListToIVectorViewAdapter : object {
    [SecurityCriticalAttribute]
internal T GetAt(UInt32 index);
    [SecurityCriticalAttribute]
internal UInt32 Size();
    [SecurityCriticalAttribute]
internal bool IndexOf(T value, UInt32& index);
    [SecurityCriticalAttribute]
internal UInt32 GetMany(UInt32 startIndex, T[] items);
}
[GuidAttribute("61c17706-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReference`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[GuidAttribute("61c17707-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.IReferenceFactory : object {
    internal static Type s_pointType;
    internal static Type s_rectType;
    internal static Type s_sizeType;
    private static IReferenceFactory();
    [SecuritySafeCriticalAttribute]
internal static object CreateIReference(object obj);
    [SecuritySafeCriticalAttribute]
internal static object CreateIReferenceArray(Array obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IterableToEnumerableAdapter : object {
    [SecurityCriticalAttribute]
internal IEnumerator`1<T> GetEnumerator_Stub();
    [SecurityCriticalAttribute]
internal IEnumerator`1<T> GetEnumerator_Variance_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IteratorToEnumeratorAdapter`1 : object {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal IteratorToEnumeratorAdapter`1(IIterator`1<T> iterator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector_Raw`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IVectorView`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
    public abstract virtual void ReplaceAll(T[] items);
}
[ForceTokenStabilizationAttribute]
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IReadOnlyList`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
    public abstract virtual void ReplaceAll(T[] items);
}
[GuidAttribute("bbe1fa4c-b0e3-4583-baef-1f1b2e483e56")]
[ForceTokenStabilizationAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVectorView`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IVectorViewToIReadOnlyListAdapter : object {
    [SecurityCriticalAttribute]
internal T Indexer_Get(int index);
    [SecurityCriticalAttribute]
internal T Indexer_Get_Variance(int index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorAdapter : object {
    [SecurityCriticalAttribute]
internal object GetAt(UInt32 index);
    [SecurityCriticalAttribute]
internal UInt32 Size();
    [SecurityCriticalAttribute]
internal IBindableVectorView GetView();
    [SecurityCriticalAttribute]
internal bool IndexOf(object value, UInt32& index);
    [SecurityCriticalAttribute]
internal void SetAt(UInt32 index, object value);
    [SecurityCriticalAttribute]
internal void InsertAt(UInt32 index, object value);
    [SecurityCriticalAttribute]
internal void RemoveAt(UInt32 index);
    [SecurityCriticalAttribute]
internal void Append(object value);
    [SecurityCriticalAttribute]
internal void RemoveAtEnd();
    [SecurityCriticalAttribute]
internal void Clear();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorViewAdapter : object {
    public UInt32 Size { get; }
    internal ListToBindableVectorViewAdapter(IList list);
    public sealed virtual IBindableIterator First();
    public sealed virtual object GetAt(UInt32 index);
    public sealed virtual UInt32 get_Size();
    public sealed virtual bool IndexOf(object value, UInt32& index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToVectorAdapter : object {
    [SecurityCriticalAttribute]
internal T GetAt(UInt32 index);
    [SecurityCriticalAttribute]
internal UInt32 Size();
    [SecurityCriticalAttribute]
internal IReadOnlyList`1<T> GetView();
    [SecurityCriticalAttribute]
internal bool IndexOf(T value, UInt32& index);
    [SecurityCriticalAttribute]
internal void SetAt(UInt32 index, T value);
    [SecurityCriticalAttribute]
internal void InsertAt(UInt32 index, T value);
    [SecurityCriticalAttribute]
internal void RemoveAt(UInt32 index);
    [SecurityCriticalAttribute]
internal void Append(T value);
    [SecurityCriticalAttribute]
internal void RemoveAtEnd();
    [SecurityCriticalAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
internal UInt32 GetMany(UInt32 startIndex, T[] items);
    [SecurityCriticalAttribute]
internal void ReplaceAll(T[] items);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class System.Runtime.InteropServices.WindowsRuntime.ManagedActivationFactory : object {
    [SecurityCriticalAttribute]
internal ManagedActivationFactory(Type type);
    public sealed virtual object ActivateInstance();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory.RunClassConstructor();
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToCollectionAdapter : object {
    [SecurityCriticalAttribute]
internal int Count();
    [SecurityCriticalAttribute]
internal bool IsReadOnly();
    [SecurityCriticalAttribute]
internal void Add(KeyValuePair`2<K, V> item);
    [SecurityCriticalAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
internal bool Contains(KeyValuePair`2<K, V> item);
    [SecurityCriticalAttribute]
internal void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [SecurityCriticalAttribute]
internal bool Remove(KeyValuePair`2<K, V> item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToDictionaryAdapter : object {
    [SecurityCriticalAttribute]
internal V Indexer_Get(K key);
    [SecurityCriticalAttribute]
internal void Indexer_Set(K key, V value);
    [SecurityCriticalAttribute]
internal ICollection`1<K> Keys();
    [SecurityCriticalAttribute]
internal ICollection`1<V> Values();
    [SecurityCriticalAttribute]
internal bool ContainsKey(K key);
    [SecurityCriticalAttribute]
internal void Add(K key, V value);
    [SecurityCriticalAttribute]
internal bool Remove(K key);
    [SecurityCriticalAttribute]
internal bool TryGetValue(K key, V& value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapViewToReadOnlyCollectionAdapter : object {
    [SecurityCriticalAttribute]
internal int Count();
}
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs : EventArgs {
    public string NamespaceName { get; }
    public Assembly RequestingAssembly { get; }
    public Collection`1<Assembly> ResolvedAssemblies { get; }
    public NamespaceResolveEventArgs(string namespaceName, Assembly requestingAssembly);
    public string get_NamespaceName();
    public Assembly get_RequestingAssembly();
    public Collection`1<Assembly> get_ResolvedAssemblies();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Point : ValueType {
}
internal enum System.Runtime.InteropServices.WindowsRuntime.PropertyType : Enum {
    public int value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType Other;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherArray;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyCollection`2 : object {
    public ReadOnlyDictionaryKeyCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyEnumerator`2 : object {
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public ReadOnlyDictionaryKeyEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueCollection`2 : object {
    public ReadOnlyDictionaryValueCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueEnumerator`2 : object {
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public ReadOnlyDictionaryValueEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Rect : ValueType {
}
[AttributeUsageAttribute("12288")]
public class System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
    public string Name { get; }
    public ReturnValueNameAttribute(string name);
    public string get_Name();
}
internal abstract class System.Runtime.InteropServices.WindowsRuntime.RuntimeClass : __ComObject {
    [SecurityCriticalAttribute]
internal IntPtr GetRedirectedGetHashCodeMD();
    [SecurityCriticalAttribute]
internal int RedirectGetHashCode(IntPtr pMD);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
internal IntPtr GetRedirectedToStringMD();
    [SecurityCriticalAttribute]
internal string RedirectToString(IntPtr pMD);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecurityCriticalAttribute]
internal IntPtr GetRedirectedEqualsMD();
    [SecurityCriticalAttribute]
internal bool RedirectEquals(object obj, IntPtr pMD);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Size : ValueType {
}
internal static class System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int WindowsCreateString(string sourceString, int length, IntPtr* hstring);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int WindowsCreateStringReference(Char* sourceString, int length, HSTRING_HEADER* hstringHeader, IntPtr* hstring);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int WindowsDeleteString(IntPtr hstring);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToCollectionAdapter : object {
    [SecurityCriticalAttribute]
internal int Count();
    [SecurityCriticalAttribute]
internal bool IsReadOnly();
    [SecurityCriticalAttribute]
internal void Add(T item);
    [SecurityCriticalAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
internal bool Contains(T item);
    [SecurityCriticalAttribute]
internal void CopyTo(T[] array, int arrayIndex);
    [SecurityCriticalAttribute]
internal bool Remove(T item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToListAdapter : object {
    [SecurityCriticalAttribute]
internal T Indexer_Get(int index);
    [SecurityCriticalAttribute]
internal void Indexer_Set(int index, T value);
    [SecurityCriticalAttribute]
internal int IndexOf(T item);
    [SecurityCriticalAttribute]
internal void Insert(int index, T item);
    [SecurityCriticalAttribute]
internal void RemoveAt(int index);
    internal static T GetAt(IVector`1<T> _this, UInt32 index);
    internal static void RemoveAtHelper(IVector`1<T> _this, UInt32 index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorViewToReadOnlyCollectionAdapter : object {
    [SecurityCriticalAttribute]
internal int Count();
}
[ForceTokenStabilizationAttribute]
[GuidAttribute("9de1c535-6ae1-11e0-84e1-18a905bcc53f")]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsFoundationEventHandler`1 : MulticastDelegate {
    public WindowsFoundationEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, T args);
    public virtual IAsyncResult BeginInvoke(object sender, T args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferHelper : object {
    [FriendAccessAllowedAttribute]
[ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal static void StoreOverlappedInCCW(object windowsRuntimeBuffer, NativeOverlapped* overlapped);
}
[AttributeUsageAttribute("5148")]
[FriendAccessAllowedAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeImportAttribute : Attribute {
}
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
    [SecurityCriticalAttribute]
public static void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler);
    [SecurityCriticalAttribute]
public static void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler);
    [SecurityCriticalAttribute]
public static void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod);
    internal static int GetRegistrationTokenCacheSize();
    internal static void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove);
    [SecurityCriticalAttribute]
internal static string HStringToString(IntPtr hstring);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException, string messageResource);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException);
    [SecurityCriticalAttribute]
internal static IntPtr GetActivationFactoryForType(Type type);
    [SecurityCriticalAttribute]
internal static ManagedActivationFactory GetManagedActivationFactory(Type type);
    [SecurityCriticalAttribute]
public static IActivationFactory GetActivationFactory(Type type);
    [SecurityCriticalAttribute]
public static IntPtr StringToHString(string s);
    [SecurityCriticalAttribute]
public static string PtrToStringHString(IntPtr ptr);
    [SecurityCriticalAttribute]
public static void FreeHString(IntPtr ptr);
}
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMetadata : object {
    [SecurityCriticalAttribute]
public static IEnumerable`1<string> ResolveNamespace(string namespaceName, IEnumerable`1<string> packageGraphFilePaths);
    [SecurityCriticalAttribute]
public static IEnumerable`1<string> ResolveNamespace(string namespaceName, string windowsSdkFilePath, IEnumerable`1<string> packageGraphFilePaths);
    [SecurityCriticalAttribute]
public static void add_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value);
    internal static RuntimeAssembly[] OnReflectionOnlyNamespaceResolveEvent(AppDomain appDomain, RuntimeAssembly assembly, string namespaceName);
    [SecurityCriticalAttribute]
public static void add_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value);
    internal static String[] OnDesignerNamespaceResolveEvent(AppDomain appDomain, string namespaceName);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    [SecuritySafeCriticalAttribute]
private static MemoryFailPoint();
    [SecurityCriticalAttribute]
public MemoryFailPoint(int sizeInMegabytes);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
}
public static class System.Runtime.ProfileOptimization : object {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void InternalSetProfileRoot(string directoryPath);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void InternalStartProfile(string profile);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void InternalAbortProfile();
    [SecurityCriticalAttribute]
public static void SetProfileRoot(string directoryPath);
    [SecurityCriticalAttribute]
public static void StartProfile(string profile);
}
internal class System.Runtime.Remoting.__HResults : object {
    public static int COR_E_REMOTING;
    public static int COR_E_SERVER;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ActivatedClientTypeEntry : TypeEntry {
    public string ApplicationUrl { get; }
    public Type ObjectType { get; }
    public IContextAttribute[] ContextAttributes { get; public set; }
    public ActivatedClientTypeEntry(string typeName, string assemblyName, string appUrl);
    public ActivatedClientTypeEntry(Type type, string appUrl);
    public string get_ApplicationUrl();
    public Type get_ObjectType();
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ActivatedServiceTypeEntry : TypeEntry {
    public Type ObjectType { get; }
    public IContextAttribute[] ContextAttributes { get; public set; }
    public ActivatedServiceTypeEntry(string typeName, string assemblyName);
    public ActivatedServiceTypeEntry(Type type);
    public Type get_ObjectType();
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public virtual string ToString();
}
internal class System.Runtime.Remoting.Activation.ActivationAttributeStack : object {
    internal void Push(Type typ, Object[] attr);
    internal Object[] Peek(Type typ);
    internal void Pop(Type typ);
}
internal class System.Runtime.Remoting.Activation.ActivationListener : MarshalByRefObject {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
public virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public virtual ActivatorLevel get_Level();
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorMsg);
}
internal static class System.Runtime.Remoting.Activation.ActivationServices : object {
    internal static string ActivationServiceURI;
    internal static string RemoteActivateKey;
    internal static string PermissionKey;
    internal static string ConnectKey;
    [ThreadStaticAttribute]
internal static ActivationAttributeStack _attributeStack;
    internal static Assembly s_MscorlibAssembly;
    internal static ProxyAttribute DefaultProxyAttribute { get; }
    [SecuritySafeCriticalAttribute]
private static ActivationServices();
    [SecurityCriticalAttribute]
internal static void GetPropertiesFromAttributes(IConstructionCallMessage ctorMsg, Object[] attributes);
    [SecurityCriticalAttribute]
internal static ProxyAttribute get_DefaultProxyAttribute();
    [SecurityCriticalAttribute]
internal static ProxyAttribute GetProxyAttribute(Type serverType);
    [SecurityCriticalAttribute]
internal static MarshalByRefObject CreateInstance(RuntimeType serverType);
    [SecurityCriticalAttribute]
internal static IConstructionReturnMessage Activate(RemotingProxy remProxy, IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
internal static IConstructionReturnMessage DoCrossContextActivation(IConstructionCallMessage reqMsg);
    [SecurityCriticalAttribute]
internal static object DoCrossContextActivationCallback(Object[] args);
    [SecurityCriticalAttribute]
internal static IConstructionReturnMessage DoServerContextActivation(IConstructionCallMessage reqMsg);
    [SecurityCriticalAttribute]
internal static IConstructionReturnMessage SetupConstructionReply(object serverObj, IConstructionCallMessage ctorMsg, Exception e);
    [SecurityCriticalAttribute]
internal static object ActivateWithMessage(Type serverType, IMessage msg, ServerIdentity srvIdToBind, Exception& e);
    [SecurityCriticalAttribute]
internal static void StartListeningForRemoteRequests();
    [SecurityCriticalAttribute]
internal static IActivator GetActivator();
    [SecurityCriticalAttribute]
internal static void Initialize();
    [SecurityCriticalAttribute]
internal static ContextAttribute GetGlobalAttribute();
    [SecurityCriticalAttribute]
internal static IContextAttribute[] GetContextAttributesForType(Type serverType);
    [SecurityCriticalAttribute]
internal static object ConnectIfNecessary(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
internal static object CheckIfConnected(RemotingProxy proxy, IConstructionCallMessage ctorMsg);
    internal static void PushActivationAttributes(Type serverType, Object[] attributes);
    internal static Object[] PeekActivationAttributes(Type serverType);
    internal static void PopActivationAttributes(Type serverType);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Activation.ActivatorLevel : Enum {
    public int value__;
    public static ActivatorLevel Construction;
    public static ActivatorLevel Context;
    public static ActivatorLevel AppDomain;
    public static ActivatorLevel Process;
    public static ActivatorLevel Machine;
}
internal class System.Runtime.Remoting.Activation.AppDomainLevelActivator : object {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    internal AppDomainLevelActivator(string remActivatorURL);
    internal AppDomainLevelActivator(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public virtual ActivatorLevel get_Level();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorMsg);
}
internal class System.Runtime.Remoting.Activation.ConstructionLevelActivator : object {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    [SecurityCriticalAttribute]
public virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public virtual ActivatorLevel get_Level();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorMsg);
}
internal class System.Runtime.Remoting.Activation.ContextLevelActivator : object {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    internal ContextLevelActivator(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public virtual ActivatorLevel get_Level();
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorMsg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IActivator {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    [SecurityCriticalAttribute]
public abstract virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public abstract virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public abstract virtual IConstructionReturnMessage Activate(IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual ActivatorLevel get_Level();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IConstructionCallMessage {
    public IActivator Activator { get; public set; }
    public Object[] CallSiteActivationAttributes { get; }
    public string ActivationTypeName { get; }
    public Type ActivationType { get; }
    public IList ContextProperties { get; }
    [SecurityCriticalAttribute]
public abstract virtual IActivator get_Activator();
    [SecurityCriticalAttribute]
public abstract virtual void set_Activator(IActivator value);
    [SecurityCriticalAttribute]
public abstract virtual Object[] get_CallSiteActivationAttributes();
    [SecurityCriticalAttribute]
public abstract virtual string get_ActivationTypeName();
    [SecurityCriticalAttribute]
public abstract virtual Type get_ActivationType();
    [SecurityCriticalAttribute]
public abstract virtual IList get_ContextProperties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IConstructionReturnMessage {
}
[SecurityCriticalAttribute]
internal class System.Runtime.Remoting.Activation.LocalActivator : ContextAttribute {
    public IActivator NextActivator { get; public set; }
    public ActivatorLevel Level { get; }
    [SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual IActivator get_NextActivator();
    [SecurityCriticalAttribute]
public virtual void set_NextActivator(IActivator value);
    [SecurityCriticalAttribute]
public virtual ActivatorLevel get_Level();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorMsg);
    internal static IConstructionReturnMessage DoRemoteActivation(IConstructionCallMessage ctorMsg);
}
internal class System.Runtime.Remoting.Activation.RemotePropertyHolderAttribute : object {
    internal RemotePropertyHolderAttribute(IList cp);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
}
internal class System.Runtime.Remoting.Activation.RemotingXmlConfigFileData : object {
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) LoadTypes;
    internal string ApplicationName;
    internal LifetimeEntry Lifetime;
    internal bool UrlObjRefMode;
    internal CustomErrorsEntry CustomErrors;
    internal ArrayList ChannelEntries;
    internal ArrayList InteropXmlElementEntries;
    internal ArrayList InteropXmlTypeEntries;
    internal ArrayList PreLoadEntries;
    internal ArrayList RemoteAppEntries;
    internal ArrayList ServerActivatedEntries;
    internal ArrayList ServerWellKnownEntries;
    private static RemotingXmlConfigFileData();
    internal void AddInteropXmlElementEntry(string xmlElementName, string xmlElementNamespace, string urtTypeName, string urtAssemblyName);
    internal void AddInteropXmlTypeEntry(string xmlTypeName, string xmlTypeNamespace, string urtTypeName, string urtAssemblyName);
    internal void AddPreLoadEntry(string typeName, string assemblyName);
    internal RemoteAppEntry AddRemoteAppEntry(string appUri);
    internal void AddServerActivatedEntry(string typeName, string assemName, ArrayList contextAttributes);
    internal ServerWellKnownEntry AddServerWellKnownEntry(string typeName, string assemName, ArrayList contextAttributes, string objURI, WellKnownObjectMode objMode);
}
internal static class System.Runtime.Remoting.Activation.RemotingXmlConfigFileParser : object {
    private static RemotingXmlConfigFileParser();
    public static RemotingXmlConfigFileData ParseDefaultConfiguration();
    public static RemotingXmlConfigFileData ParseConfigFile(string filename);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Activation.UrlAttribute : ContextAttribute {
    public string UrlValue { get; }
    [SecurityCriticalAttribute]
public UrlAttribute(string callsiteURL);
    private static UrlAttribute();
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object o);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public string get_UrlValue();
}
internal class System.Runtime.Remoting.ChannelInfo : object {
    public Object[] ChannelData { get; public set; }
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_ChannelData();
    [SecurityCriticalAttribute]
public sealed virtual void set_ChannelData(Object[] value);
}
internal class System.Runtime.Remoting.Channels.ADAsyncWorkItem : object {
    [SecurityCriticalAttribute]
internal ADAsyncWorkItem(IMessage reqMsg, IMessageSink nextSink, IMessageSink replySink);
    [SecurityCriticalAttribute]
internal virtual void FinishAsyncWork(object stateIgnored);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Remoting.Channels.AggregateDictionary : object {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public AggregateDictionary(ICollection dictionaries);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual bool Contains(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual void Remove(object key);
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual object get_SyncRoot();
    public virtual bool get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Runtime.Remoting.Channels.AsyncMessageHelper : object {
    internal static void GetOutArgs(ParameterInfo[] syncParams, Object[] syncArgs, Object[] endArgs);
}
internal class System.Runtime.Remoting.Channels.AsyncWorkItem : object {
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal AsyncWorkItem(IMessageSink replySink, Context oldCtx);
    [SecurityCriticalAttribute]
internal AsyncWorkItem(IMessage reqMsg, IMessageSink replySink, Context oldCtx, ServerIdentity srvID);
    [SecurityCriticalAttribute]
internal static object SyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    [SecurityCriticalAttribute]
internal static object FinishAsyncWorkCallback(Object[] args);
    [SecurityCriticalAttribute]
internal virtual void FinishAsyncWork(object stateIgnored);
}
[DefaultMemberAttribute("Item")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties : object {
    public IDictionary Properties { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecuritySafeCriticalAttribute]
public virtual object get_Item(object key);
    [SecuritySafeCriticalAttribute]
public virtual void set_Item(object key, object value);
    [SecuritySafeCriticalAttribute]
public virtual ICollection get_Keys();
    [SecuritySafeCriticalAttribute]
public virtual ICollection get_Values();
    [SecuritySafeCriticalAttribute]
public virtual bool Contains(object key);
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsReadOnly();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsFixedSize();
    [SecuritySafeCriticalAttribute]
public virtual void Add(object key, object value);
    [SecuritySafeCriticalAttribute]
public virtual void Clear();
    [SecuritySafeCriticalAttribute]
public virtual void Remove(object key);
    [SecuritySafeCriticalAttribute]
public virtual IDictionaryEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
public virtual void CopyTo(Array array, int index);
    [SecuritySafeCriticalAttribute]
public virtual int get_Count();
    [SecuritySafeCriticalAttribute]
public virtual object get_SyncRoot();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSynchronized();
    [SecuritySafeCriticalAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public abstract class System.Runtime.Remoting.Channels.BaseChannelSinkWithProperties : BaseChannelObjectWithProperties {
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public abstract class System.Runtime.Remoting.Channels.BaseChannelWithProperties : BaseChannelObjectWithProperties {
    protected IChannelSinkBase SinksWithProperties;
    public IDictionary Properties { get; }
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
}
[DefaultMemberAttribute("Item")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ChannelDataStore : object {
    public String[] ChannelUris { get; public set; }
    public object Item { get; public set; }
    public ChannelDataStore(String[] channelURIs);
    [SecurityCriticalAttribute]
internal ChannelDataStore InternalShallowCopy();
    [SecurityCriticalAttribute]
public sealed virtual String[] get_ChannelUris();
    public void set_ChannelUris(String[] value);
    [SecurityCriticalAttribute]
public sealed virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public sealed virtual void set_Item(object key, object value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ChannelServices : object {
    internal static Object[] CurrentChannelData { get; }
    public static IChannel[] RegisteredChannels { get; }
    [SecuritySafeCriticalAttribute]
private static ChannelServices();
    [SecurityCriticalAttribute]
internal static Object[] get_CurrentChannelData();
    [SecuritySafeCriticalAttribute]
public static void RegisterChannel(IChannel chnl, bool ensureSecurity);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Use System.Runtime.Remoting.ChannelServices.RegisterChannel(IChannel chnl, bool ensureSecurity) instead.", "False")]
public static void RegisterChannel(IChannel chnl);
    [SecurityCriticalAttribute]
internal static void RegisterChannelInternal(IChannel chnl, bool ensureSecurity);
    [SecuritySafeCriticalAttribute]
public static void UnregisterChannel(IChannel chnl);
    [SecurityCriticalAttribute]
public static IChannel[] get_RegisteredChannels();
    [SecurityCriticalAttribute]
internal static IMessageSink CreateMessageSink(string url, object data, String& objectURI);
    [SecurityCriticalAttribute]
internal static IMessageSink CreateMessageSink(object data);
    [SecurityCriticalAttribute]
public static IChannel GetChannel(string name);
    [SecurityCriticalAttribute]
public static String[] GetUrlsForObject(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static IMessageSink GetChannelSinkForProxy(object obj);
    [SecuritySafeCriticalAttribute]
public static IDictionary GetChannelSinkProperties(object obj);
    internal static IMessageSink GetCrossContextChannelSink();
    [SecurityCriticalAttribute]
internal static void IncrementRemoteCalls(long cCalls);
    [SecurityCriticalAttribute]
internal static void IncrementRemoteCalls();
    [SecurityCriticalAttribute]
internal static void RefreshChannelData();
    [SecurityCriticalAttribute]
public static ServerProcessing DispatchMessage(IServerChannelSinkStack sinkStack, IMessage msg, IMessage& replyMsg);
    [SecurityCriticalAttribute]
public static IMessage SyncDispatchMessage(IMessage msg);
    [SecurityCriticalAttribute]
public static IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public static IServerChannelSink CreateServerChannelSinkChain(IServerChannelSinkProvider provider, IChannelReceiver channel);
    [SecurityCriticalAttribute]
internal static ServerIdentity CheckDisconnectedOrCreateWellKnownObject(IMessage msg);
    [SecurityCriticalAttribute]
internal static void UnloadHandler(object sender, EventArgs e);
    [SecurityCriticalAttribute]
internal static void NotifyProfiler(IMessage msg, RemotingProfilerEvent profilerEvent);
    [SecurityCriticalAttribute]
internal static string FindFirstHttpUrlForObject(string objectUri);
}
internal class System.Runtime.Remoting.Channels.ChannelServicesData : object {
    internal long remoteCalls;
    internal CrossContextChannel xctxmessageSink;
    internal CrossAppDomainChannel xadmessageSink;
    internal bool fRegisterWellKnownChannels;
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ClientChannelSinkStack : object {
    public ClientChannelSinkStack(IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual void Push(IClientChannelSink sink, object state);
    [SecurityCriticalAttribute]
public sealed virtual object Pop(IClientChannelSink sink);
    [SecurityCriticalAttribute]
public sealed virtual void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public sealed virtual void DispatchReplyMessage(IMessage msg);
    [SecurityCriticalAttribute]
public sealed virtual void DispatchException(Exception e);
}
internal class System.Runtime.Remoting.Channels.CrossAppDomainChannel : object {
    internal static CrossAppDomainChannel AppDomainChannel { get; }
    public string ChannelName { get; }
    public string ChannelURI { get; }
    public int ChannelPriority { get; }
    public object ChannelData { get; }
    private static CrossAppDomainChannel();
    internal static CrossAppDomainChannel get_AppDomainChannel();
    [SecurityCriticalAttribute]
internal static void RegisterChannel();
    [SecurityCriticalAttribute]
public virtual string get_ChannelName();
    public virtual string get_ChannelURI();
    [SecurityCriticalAttribute]
public virtual int get_ChannelPriority();
    [SecurityCriticalAttribute]
public sealed virtual string Parse(string url, String& objectURI);
    [SecurityCriticalAttribute]
public virtual object get_ChannelData();
    [SecurityCriticalAttribute]
public virtual IMessageSink CreateMessageSink(string url, object data, String& objectURI);
    [SecurityCriticalAttribute]
public virtual String[] GetUrlsForUri(string objectURI);
    [SecurityCriticalAttribute]
public virtual void StartListening(object data);
    [SecurityCriticalAttribute]
public virtual void StopListening(object data);
}
internal class System.Runtime.Remoting.Channels.CrossAppDomainData : object {
    internal IntPtr ContextID { get; }
    internal int DomainID { get; }
    internal string ProcessGuid { get; }
    internal CrossAppDomainData(IntPtr ctxId, int domainID, string processGuid);
    internal virtual IntPtr get_ContextID();
    [ReliabilityContractAttribute("3", "2")]
internal virtual int get_DomainID();
    internal virtual string get_ProcessGuid();
    internal bool IsFromThisProcess();
    [SecurityCriticalAttribute]
internal bool IsFromThisAppDomain();
}
internal static class System.Runtime.Remoting.Channels.CrossAppDomainSerializer : object {
    [SecurityCriticalAttribute]
internal static MemoryStream SerializeMessage(IMessage msg);
    [SecurityCriticalAttribute]
internal static MemoryStream SerializeMessageParts(ArrayList argsToSerialize);
    [SecurityCriticalAttribute]
internal static void SerializeObject(object obj, MemoryStream stm);
    [SecurityCriticalAttribute]
internal static MemoryStream SerializeObject(object obj);
    [SecurityCriticalAttribute]
internal static IMessage DeserializeMessage(MemoryStream stm);
    [SecurityCriticalAttribute]
internal static IMessage DeserializeMessage(MemoryStream stm, IMethodCallMessage reqMsg);
    [SecurityCriticalAttribute]
internal static ArrayList DeserializeMessageParts(MemoryStream stm);
    [SecurityCriticalAttribute]
internal static object DeserializeObject(MemoryStream stm);
}
internal class System.Runtime.Remoting.Channels.CrossAppDomainSink : InternalSink {
    internal static int GROW_BY;
    internal static string LCC_DATA_KEY;
    internal static Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) _sinkKeys;
    internal static CrossAppDomainSink[] modreq(System.Runtime.CompilerServices.IsVolatile) _sinks;
    internal CrossAppDomainData _xadData;
    public IMessageSink NextSink { get; }
    [SecuritySafeCriticalAttribute]
private static CrossAppDomainSink();
    internal CrossAppDomainSink(CrossAppDomainData xadData);
    internal static void GrowArrays(int oldSize);
    internal static CrossAppDomainSink FindOrCreateSink(CrossAppDomainData xadData);
    internal static void DomainUnloaded(int domainID);
    [SecurityCriticalAttribute]
internal static Byte[] DoDispatch(Byte[] reqStmBuff, SmuggledMethodCallMessage smuggledMcm, SmuggledMethodReturnMessage& smuggledMrm);
    [SecurityCriticalAttribute]
internal static object DoTransitionDispatchCallback(Object[] args);
    [SecurityCriticalAttribute]
internal Byte[] DoTransitionDispatch(Byte[] reqStmBuff, SmuggledMethodCallMessage smuggledMcm, SmuggledMethodReturnMessage& smuggledMrm);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Channels.CrossContextChannel : InternalSink {
    internal static IMessageSink MessageSink { get; }
    public IMessageSink NextSink { get; }
    [SecuritySafeCriticalAttribute]
private static CrossContextChannel();
    internal static IMessageSink get_MessageSink();
    [SecurityCriticalAttribute]
internal static object SyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static object AsyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
internal static object DoAsyncDispatchCallback(Object[] args);
    [SecurityCriticalAttribute]
internal static IMessageCtrl DoAsyncDispatch(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Channels.DictionaryEnumeratorByKeys : object {
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public DictionaryEnumeratorByKeys(IDictionary properties);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
}
internal class System.Runtime.Remoting.Channels.DispatchChannelSink : object {
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    [SecurityCriticalAttribute]
public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
    [SecurityCriticalAttribute]
public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    [SecurityCriticalAttribute]
public sealed virtual IServerChannelSink get_NextChannelSink();
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
}
internal class System.Runtime.Remoting.Channels.DispatchChannelSinkProvider : object {
    public IServerChannelSinkProvider Next { get; public set; }
    [SecurityCriticalAttribute]
public sealed virtual void GetChannelData(IChannelDataStore channelData);
    [SecurityCriticalAttribute]
public sealed virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    [SecurityCriticalAttribute]
public sealed virtual IServerChannelSinkProvider get_Next();
    [SecurityCriticalAttribute]
public sealed virtual void set_Next(IServerChannelSinkProvider value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannel {
    public int ChannelPriority { get; }
    public string ChannelName { get; }
    [SecurityCriticalAttribute]
public abstract virtual int get_ChannelPriority();
    [SecurityCriticalAttribute]
public abstract virtual string get_ChannelName();
    [SecurityCriticalAttribute]
public abstract virtual string Parse(string url, String& objectURI);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelDataStore {
    public String[] ChannelUris { get; }
    public object Item { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual String[] get_ChannelUris();
    [SecurityCriticalAttribute]
public abstract virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public abstract virtual void set_Item(object key, object value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelReceiver {
    public object ChannelData { get; }
    [SecurityCriticalAttribute]
public abstract virtual object get_ChannelData();
    [SecurityCriticalAttribute]
public abstract virtual String[] GetUrlsForUri(string objectURI);
    [SecurityCriticalAttribute]
public abstract virtual void StartListening(object data);
    [SecurityCriticalAttribute]
public abstract virtual void StopListening(object data);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelReceiverHook {
    public string ChannelScheme { get; }
    public bool WantsToListen { get; }
    public IServerChannelSink ChannelSinkChain { get; }
    [SecurityCriticalAttribute]
public abstract virtual string get_ChannelScheme();
    [SecurityCriticalAttribute]
public abstract virtual bool get_WantsToListen();
    [SecurityCriticalAttribute]
public abstract virtual IServerChannelSink get_ChannelSinkChain();
    [SecurityCriticalAttribute]
public abstract virtual void AddHookChannelUri(string channelUri);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelSender {
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelSinkBase {
    public IDictionary Properties { get; }
    [SecurityCriticalAttribute]
public abstract virtual IDictionary get_Properties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSink {
    public IClientChannelSink NextChannelSink { get; }
    [SecurityCriticalAttribute]
public abstract virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
    [SecurityCriticalAttribute]
public abstract virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public abstract virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public abstract virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    [SecurityCriticalAttribute]
public abstract virtual IClientChannelSink get_NextChannelSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSinkProvider {
    public IClientChannelSinkProvider Next { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
    [SecurityCriticalAttribute]
public abstract virtual IClientChannelSinkProvider get_Next();
    [SecurityCriticalAttribute]
public abstract virtual void set_Next(IClientChannelSinkProvider value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSinkStack {
    [SecurityCriticalAttribute]
public abstract virtual void Push(IClientChannelSink sink, object state);
    [SecurityCriticalAttribute]
public abstract virtual object Pop(IClientChannelSink sink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientFormatterSink {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientFormatterSinkProvider {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack {
    [SecurityCriticalAttribute]
public abstract virtual void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public abstract virtual void DispatchReplyMessage(IMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual void DispatchException(Exception e);
}
public interface System.Runtime.Remoting.Channels.ISecurableChannel {
    public bool IsSecured { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual bool get_IsSecured();
    [SecurityCriticalAttribute]
public abstract virtual void set_IsSecured(bool value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSink {
    public IServerChannelSink NextChannelSink { get; }
    [SecurityCriticalAttribute]
public abstract virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
    [SecurityCriticalAttribute]
public abstract virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public abstract virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    [SecurityCriticalAttribute]
public abstract virtual IServerChannelSink get_NextChannelSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSinkProvider {
    public IServerChannelSinkProvider Next { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual void GetChannelData(IChannelDataStore channelData);
    [SecurityCriticalAttribute]
public abstract virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    [SecurityCriticalAttribute]
public abstract virtual IServerChannelSinkProvider get_Next();
    [SecurityCriticalAttribute]
public abstract virtual void set_Next(IServerChannelSinkProvider value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSinkStack {
    [SecurityCriticalAttribute]
public abstract virtual void Push(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public abstract virtual object Pop(IServerChannelSink sink);
    [SecurityCriticalAttribute]
public abstract virtual void Store(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public abstract virtual void StoreAndDispatch(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public abstract virtual void ServerCallback(IAsyncResult ar);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerFormatterSinkProvider {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack {
    [SecurityCriticalAttribute]
public abstract virtual void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public abstract virtual Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.ITransportHeaders {
    public object Item { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public abstract virtual void set_Item(object key, object value);
    [SecurityCriticalAttribute]
public abstract virtual IEnumerator GetEnumerator();
}
internal class System.Runtime.Remoting.Channels.Perf_Contexts : ValueType {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) cRemoteCalls;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) cChannels;
}
internal class System.Runtime.Remoting.Channels.RegisteredChannel : object {
    internal IChannel Channel { get; }
    internal RegisteredChannel(IChannel chnl);
    internal virtual IChannel get_Channel();
    internal virtual bool IsSender();
    internal virtual bool IsReceiver();
}
internal class System.Runtime.Remoting.Channels.RegisteredChannelList : object {
    internal RegisteredChannel[] RegisteredChannels { get; }
    internal int Count { get; }
    internal int ReceiverCount { get; }
    internal RegisteredChannelList(RegisteredChannel[] channels);
    internal RegisteredChannel[] get_RegisteredChannels();
    internal int get_Count();
    internal IChannel GetChannel(int index);
    internal bool IsSender(int index);
    internal bool IsReceiver(int index);
    internal int get_ReceiverCount();
    internal int FindChannelIndex(IChannel channel);
    [SecurityCriticalAttribute]
internal int FindChannelIndex(string name);
}
internal enum System.Runtime.Remoting.Channels.RemotingProfilerEvent : Enum {
    public int value__;
    public static RemotingProfilerEvent ClientSend;
    public static RemotingProfilerEvent ClientReceive;
}
internal class System.Runtime.Remoting.Channels.ServerAsyncReplyTerminatorSink : object {
    internal IMessageSink _nextSink;
    public IMessageSink NextSink { get; }
    internal ServerAsyncReplyTerminatorSink(IMessageSink nextSink);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage replyMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage replyMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Channels.ServerChannelSinkStack : object {
    unknown object ServerObject {internal set; }
    [SecurityCriticalAttribute]
public sealed virtual void Push(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public sealed virtual object Pop(IServerChannelSink sink);
    [SecurityCriticalAttribute]
public sealed virtual void Store(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public sealed virtual void StoreAndDispatch(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public sealed virtual void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public sealed virtual Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
    internal void set_ServerObject(object value);
    [SecurityCriticalAttribute]
public sealed virtual void ServerCallback(IAsyncResult ar);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Channels.ServerProcessing : Enum {
    public int value__;
    public static ServerProcessing Complete;
    public static ServerProcessing OneWay;
    public static ServerProcessing Async;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.SinkProviderData : object {
    public string Name { get; }
    public IDictionary Properties { get; }
    public IList Children { get; }
    public SinkProviderData(string name);
    public string get_Name();
    public IDictionary get_Properties();
    public IList get_Children();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
[DefaultMemberAttribute("Item")]
public class System.Runtime.Remoting.Channels.TransportHeaders : object {
    public object Item { get; public set; }
    [SecurityCriticalAttribute]
public sealed virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public sealed virtual void set_Item(object key, object value);
    [SecurityCriticalAttribute]
public sealed virtual IEnumerator GetEnumerator();
}
internal class System.Runtime.Remoting.ComRedirectionProxy : MarshalByRefObject {
    public IMessageSink NextSink { get; }
    internal ComRedirectionProxy(MarshalByRefObject comObject, Type serverType);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Contexts.ArrayWithSize : object {
    internal IDynamicMessageSink[] Sinks;
    internal int Count;
    internal ArrayWithSize(IDynamicMessageSink[] sinks, int count);
}
internal class System.Runtime.Remoting.Contexts.CallBackHelper : object {
    internal static int RequestedFromEE;
    internal static int XDomainTransition;
    internal bool IsEERequested { get; internal set; }
    unknown bool IsCrossDomain {internal set; }
    internal CallBackHelper(IntPtr privateData, bool bFromEE, int targetDomainID);
    internal bool get_IsEERequested();
    internal void set_IsEERequested(bool value);
    internal void set_IsCrossDomain(bool value);
    [SecurityCriticalAttribute]
internal void Func();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.Context : object {
    internal static int CTX_DEFAULT_CONTEXT;
    internal static int CTX_FROZEN;
    internal static int CTX_THREADPOOL_AWARE;
    public int ContextID { get; }
    internal IntPtr InternalContextID { get; }
    internal AppDomain AppDomain { get; }
    internal bool IsDefaultContext { get; }
    public static Context DefaultContext { get; }
    internal bool IsThreadPoolAware { get; }
    public IContextProperty[] ContextProperties { get; }
    internal IDynamicProperty[] PerContextDynamicProperties { get; }
    internal static ArrayWithSize GlobalDynamicSinks { get; }
    internal ArrayWithSize DynamicSinks { get; }
    private static Context();
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
public virtual int get_ContextID();
    internal virtual IntPtr get_InternalContextID();
    internal virtual AppDomain get_AppDomain();
    internal bool get_IsDefaultContext();
    [SecurityCriticalAttribute]
public static Context get_DefaultContext();
    [SecurityCriticalAttribute]
internal static Context CreateDefaultContext();
    [SecurityCriticalAttribute]
public virtual IContextProperty GetProperty(string name);
    [SecurityCriticalAttribute]
public virtual void SetProperty(IContextProperty prop);
    [SecurityCriticalAttribute]
internal virtual void InternalFreeze();
    [SecurityCriticalAttribute]
public virtual void Freeze();
    internal virtual void SetThreadPoolAware();
    internal virtual bool get_IsThreadPoolAware();
    [SecurityCriticalAttribute]
public virtual IContextProperty[] get_ContextProperties();
    [SecurityCriticalAttribute]
internal static void CheckPropertyNameClash(string name, IContextProperty[] props, int count);
    internal static IContextProperty[] GrowPropertiesArray(IContextProperty[] props);
    [SecurityCriticalAttribute]
internal virtual IMessageSink GetServerContextChain();
    [SecurityCriticalAttribute]
internal virtual IMessageSink GetClientContextChain();
    [SecurityCriticalAttribute]
internal virtual IMessageSink CreateServerObjectChain(MarshalByRefObject serverObj);
    [SecurityCriticalAttribute]
internal virtual IMessageSink CreateEnvoyChain(MarshalByRefObject objectOrProxy);
    [SecurityCriticalAttribute]
internal IMessage NotifyActivatorProperties(IMessage msg, bool bServerSide);
    public virtual string ToString();
    [SecurityCriticalAttribute]
public void DoCallBack(CrossContextDelegate deleg);
    [SecurityCriticalAttribute]
internal static void DoCallBackFromEE(IntPtr targetCtxID, IntPtr privateData, int targetDomainID);
    [SecurityCriticalAttribute]
internal void DoCallBackGeneric(IntPtr targetCtxID, CrossContextDelegate deleg);
    [SecurityCriticalAttribute]
internal static void ExecuteCallBackInEE(IntPtr privateData);
    [SecurityCriticalAttribute]
public static LocalDataStoreSlot AllocateDataSlot();
    [SecurityCriticalAttribute]
public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public static LocalDataStoreSlot GetNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public static void FreeNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public static void SetData(LocalDataStoreSlot slot, object data);
    [SecurityCriticalAttribute]
public static object GetData(LocalDataStoreSlot slot);
    [SecuritySafeCriticalAttribute]
public static bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx);
    [SecuritySafeCriticalAttribute]
public static bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx);
    [SecurityCriticalAttribute]
internal static bool AddDynamicProperty(Context ctx, IDynamicProperty prop);
    [SecurityCriticalAttribute]
internal static bool RemoveDynamicProperty(Context ctx, string name);
    internal virtual IDynamicProperty[] get_PerContextDynamicProperties();
    [SecurityCriticalAttribute]
internal static ArrayWithSize get_GlobalDynamicSinks();
    [SecurityCriticalAttribute]
internal virtual ArrayWithSize get_DynamicSinks();
    [SecurityCriticalAttribute]
internal virtual bool NotifyDynamicSinks(IMessage msg, bool bCliSide, bool bStart, bool bAsync, bool bNotifyGlobals);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.Runtime.Remoting.Contexts.ContextAttribute : Attribute {
    protected string AttributeName;
    public string Name { get; }
    public ContextAttribute(string name);
    [SecurityCriticalAttribute]
public virtual string get_Name();
    [SecurityCriticalAttribute]
public virtual bool IsNewContextOK(Context newCtx);
    [SecurityCriticalAttribute]
public virtual void Freeze(Context newContext);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object o);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.ContextProperty : object {
    internal string _name;
    internal object _property;
    public string Name { get; }
    public object Property { get; }
    internal ContextProperty(string name, object prop);
    public virtual string get_Name();
    public virtual object get_Property();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.CrossContextDelegate : MulticastDelegate {
    public CrossContextDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Remoting.Contexts.DynamicPropertyHolder : object {
    internal IDynamicProperty[] DynamicProperties { get; }
    internal ArrayWithSize DynamicSinks { get; }
    [SecurityCriticalAttribute]
internal virtual bool AddDynamicProperty(IDynamicProperty prop);
    [SecurityCriticalAttribute]
internal virtual bool RemoveDynamicProperty(string name);
    internal virtual IDynamicProperty[] get_DynamicProperties();
    [SecurityCriticalAttribute]
internal virtual ArrayWithSize get_DynamicSinks();
    [SecurityCriticalAttribute]
internal static void NotifyDynamicSinks(IMessage msg, ArrayWithSize dynSinks, bool bCliSide, bool bStart, bool bAsync);
    [SecurityCriticalAttribute]
internal static void CheckPropertyNameClash(string name, IDynamicProperty[] props, int count);
    internal static IDynamicProperty[] GrowPropertiesArray(IDynamicProperty[] props);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextAttribute {
    [SecurityCriticalAttribute]
public abstract virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual void GetPropertiesForNewContext(IConstructionCallMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextProperty {
    public string Name { get; }
    [SecurityCriticalAttribute]
public abstract virtual string get_Name();
    [SecurityCriticalAttribute]
public abstract virtual bool IsNewContextOK(Context newCtx);
    [SecurityCriticalAttribute]
public abstract virtual void Freeze(Context newContext);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextPropertyActivator {
    [SecurityCriticalAttribute]
public abstract virtual bool IsOKToActivate(IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual void CollectFromClientContext(IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual bool DeliverClientContextToServerContext(IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual void CollectFromServerContext(IConstructionReturnMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual bool DeliverServerContextToClientContext(IConstructionReturnMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeClientContextSink {
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink GetClientContextSink(IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeDynamicSink {
    [SecurityCriticalAttribute]
public abstract virtual IDynamicMessageSink GetDynamicSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeEnvoySink {
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeObjectSink {
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeServerContextSink {
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink GetServerContextSink(IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IDynamicMessageSink {
    [SecurityCriticalAttribute]
public abstract virtual void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync);
    [SecurityCriticalAttribute]
public abstract virtual void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IDynamicProperty {
    public string Name { get; }
    [SecurityCriticalAttribute]
public abstract virtual string get_Name();
}
[SecurityCriticalAttribute]
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.SynchronizationAttribute : ContextAttribute {
    public static int NOT_SUPPORTED;
    public static int SUPPORTED;
    public static int REQUIRED;
    public static int REQUIRES_NEW;
    internal AutoResetEvent _asyncWorkEvent;
    internal Queue _workItemQueue;
    internal bool _locked;
    internal bool _bReEntrant;
    internal int _flavor;
    public bool Locked { get; public set; }
    public bool IsReEntrant { get; }
    internal string SyncCallOutLCID { get; internal set; }
    internal ArrayList AsyncCallOutLCIDList { get; }
    public SynchronizationAttribute(bool reEntrant);
    public SynchronizationAttribute(int flag);
    public SynchronizationAttribute(int flag, bool reEntrant);
    private static SynchronizationAttribute();
    public virtual bool get_Locked();
    public virtual void set_Locked(bool value);
    public virtual bool get_IsReEntrant();
    internal string get_SyncCallOutLCID();
    internal void set_SyncCallOutLCID(string value);
    internal ArrayList get_AsyncCallOutLCIDList();
    internal bool IsKnownLCID(IMessage reqMsg);
    internal void Dispose();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    internal virtual void InitIfNecessary();
    internal virtual void HandleThreadExit();
    internal virtual void HandleThreadReEntry();
    internal virtual void HandleWorkCompletion();
    internal virtual void HandleWorkRequest(WorkItem work);
    internal void ExecuteWorkItem(WorkItem work);
    internal bool IsNestedCall(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageSink GetServerContextSink(IMessageSink nextSink);
    [SecurityCriticalAttribute]
public virtual IMessageSink GetClientContextSink(IMessageSink nextSink);
}
internal class System.Runtime.Remoting.Contexts.SynchronizedClientContextSink : InternalSink {
    internal IMessageSink _nextSink;
    [SecurityCriticalAttribute]
internal SynchronizationAttribute _property;
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal SynchronizedClientContextSink(SynchronizationAttribute prop, IMessageSink nextSink);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Contexts.SynchronizedServerContextSink : InternalSink {
    internal IMessageSink _nextSink;
    [SecurityCriticalAttribute]
internal SynchronizationAttribute _property;
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal SynchronizedServerContextSink(SynchronizationAttribute prop, IMessageSink nextSink);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Contexts.WorkItem : object {
    internal int _flags;
    internal IMessage _reqMsg;
    internal IMessageSink _nextSink;
    internal IMessageSink _replySink;
    internal IMessage _replyMsg;
    internal Context _ctx;
    [SecurityCriticalAttribute]
internal LogicalCallContext _callCtx;
    internal static InternalCrossContextDelegate _xctxDel;
    internal IMessage ReplyMessage { get; }
    [SecuritySafeCriticalAttribute]
private static WorkItem();
    [SecurityCriticalAttribute]
internal WorkItem(IMessage reqMsg, IMessageSink nextSink, IMessageSink replySink);
    internal virtual void SetWaiting();
    internal virtual bool IsWaiting();
    internal virtual void SetSignaled();
    internal virtual bool IsSignaled();
    internal virtual void SetAsync();
    internal virtual bool IsAsync();
    internal virtual void SetDummy();
    internal virtual bool IsDummy();
    [SecurityCriticalAttribute]
internal static object ExecuteCallback(Object[] args);
    [SecurityCriticalAttribute]
internal virtual void Execute();
    internal virtual IMessage get_ReplyMessage();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.CustomErrorsModes : Enum {
    public int value__;
    public static CustomErrorsModes On;
    public static CustomErrorsModes Off;
    public static CustomErrorsModes RemoteOnly;
}
internal class System.Runtime.Remoting.DelayLoadClientChannelEntry : object {
    internal IChannelSender Channel { get; }
    internal DelayLoadClientChannelEntry(ChannelEntry entry, bool ensureSecurity);
    [SecurityCriticalAttribute]
internal IChannelSender get_Channel();
    internal void RegisterChannel();
}
internal class System.Runtime.Remoting.DomainSpecificRemotingData : object {
    internal LeaseManager LeaseManager { get; internal set; }
    internal object ConfigLock { get; }
    internal ReaderWriterLock IDTableLock { get; }
    internal LocalActivator LocalActivator { get; internal set; }
    internal ActivationListener ActivationListener { get; internal set; }
    internal bool InitializingActivation { get; internal set; }
    internal bool ActivationInitialized { get; internal set; }
    internal bool ActivatorListening { get; internal set; }
    internal IContextProperty[] AppDomainContextProperties { get; }
    internal ChannelServicesData ChannelServicesData { get; }
    internal LeaseManager get_LeaseManager();
    internal void set_LeaseManager(LeaseManager value);
    internal object get_ConfigLock();
    internal ReaderWriterLock get_IDTableLock();
    [SecurityCriticalAttribute]
internal LocalActivator get_LocalActivator();
    [SecurityCriticalAttribute]
internal void set_LocalActivator(LocalActivator value);
    internal ActivationListener get_ActivationListener();
    internal void set_ActivationListener(ActivationListener value);
    internal bool get_InitializingActivation();
    internal void set_InitializingActivation(bool value);
    internal bool get_ActivationInitialized();
    internal void set_ActivationInitialized(bool value);
    internal bool get_ActivatorListening();
    internal void set_ActivatorListening(bool value);
    internal IContextProperty[] get_AppDomainContextProperties();
    internal ChannelServicesData get_ChannelServicesData();
}
internal enum System.Runtime.Remoting.DuplicateIdentityOption : Enum {
    public int value__;
    public static DuplicateIdentityOption Unique;
    public static DuplicateIdentityOption UseExisting;
}
internal class System.Runtime.Remoting.DynamicTypeInfo : TypeInfo {
    [SecurityCriticalAttribute]
internal DynamicTypeInfo(RuntimeType typeOfObj);
    [SecurityCriticalAttribute]
public virtual bool CanCastTo(Type castType, object o);
}
internal class System.Runtime.Remoting.EnvoyInfo : object {
    public IMessageSink EnvoySinks { get; public set; }
    [SecurityCriticalAttribute]
internal static IEnvoyInfo CreateEnvoyInfo(ServerIdentity serverID);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_EnvoySinks();
    [SecurityCriticalAttribute]
public sealed virtual void set_EnvoySinks(IMessageSink value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IChannelInfo {
    public Object[] ChannelData { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual Object[] get_ChannelData();
    [SecurityCriticalAttribute]
public abstract virtual void set_ChannelData(Object[] value);
}
internal class System.Runtime.Remoting.Identity : object {
    protected static int IDFLG_DISCONNECTED_FULL;
    protected static int IDFLG_DISCONNECTED_REM;
    protected static int IDFLG_IN_IDTABLE;
    protected static int IDFLG_CONTEXT_BOUND;
    protected static int IDFLG_WELLKNOWN;
    protected static int IDFLG_SERVER_SINGLECALL;
    protected static int IDFLG_SERVER_SINGLETON;
    internal int _flags;
    internal object _tpOrObject;
    protected string _ObjURI;
    protected string _URL;
    internal object _objRef;
    internal object _channelSink;
    internal object _envoyChain;
    internal DynamicPropertyHolder _dph;
    internal Lease _lease;
    internal static string ProcessIDGuid { get; }
    internal static string AppDomainUniqueId { get; }
    internal static string IDGuidString { get; }
    internal static string ProcessGuid { get; }
    internal bool IsContextBound { get; }
    internal string URI { get; }
    internal string ObjURI { get; }
    internal MarshalByRefObject TPOrObject { get; }
    internal ObjRef ObjectRef { get; }
    internal IMessageSink ChannelSink { get; }
    internal IMessageSink EnvoyChain { get; }
    internal Lease Lease { get; internal set; }
    internal ArrayWithSize ProxySideDynamicSinks { get; }
    internal Identity(string objURI, string URL);
    internal Identity(bool bContextBound);
    private static Identity();
    internal static string get_ProcessIDGuid();
    internal static string get_AppDomainUniqueId();
    internal static string get_IDGuidString();
    internal static string RemoveAppNameOrAppGuidIfNecessary(string uri);
    internal static string get_ProcessGuid();
    internal bool get_IsContextBound();
    internal bool IsWellKnown();
    internal void SetInIDTable();
    [SecurityCriticalAttribute]
internal void ResetInIDTable(bool bResetURI);
    internal bool IsInIDTable();
    internal void SetFullyConnected();
    internal bool IsFullyDisconnected();
    internal bool IsRemoteDisconnected();
    internal bool IsDisconnected();
    internal string get_URI();
    internal string get_ObjURI();
    internal MarshalByRefObject get_TPOrObject();
    internal object RaceSetTransparentProxy(object tpObj);
    [SecurityCriticalAttribute]
internal ObjRef get_ObjectRef();
    [SecurityCriticalAttribute]
internal ObjRef RaceSetObjRef(ObjRef objRefGiven);
    internal IMessageSink get_ChannelSink();
    internal IMessageSink RaceSetChannelSink(IMessageSink channelSink);
    internal IMessageSink get_EnvoyChain();
    internal Lease get_Lease();
    internal void set_Lease(Lease value);
    internal IMessageSink RaceSetEnvoyChain(IMessageSink envoyChain);
    internal void SetOrCreateURI(string uri);
    internal void SetOrCreateURI(string uri, bool bIdCtor);
    internal static string GetNewLogicalCallID();
    [ConditionalAttribute("_DEBUG")]
[SecurityCriticalAttribute]
internal virtual void AssertValid();
    [SecurityCriticalAttribute]
internal bool AddProxySideDynamicProperty(IDynamicProperty prop);
    [SecurityCriticalAttribute]
internal bool RemoveProxySideDynamicProperty(string name);
    [SecurityCriticalAttribute]
internal ArrayWithSize get_ProxySideDynamicSinks();
}
internal class System.Runtime.Remoting.IdentityHolder : object {
    internal static Hashtable URITable { get; }
    internal static Context DefaultContext { get; }
    internal static ReaderWriterLock TableLock { get; }
    private static IdentityHolder();
    internal static Hashtable get_URITable();
    [SecurityCriticalAttribute]
internal static Context get_DefaultContext();
    internal static ReaderWriterLock get_TableLock();
    [SecurityCriticalAttribute]
internal static void FlushIdentityTable();
    [SecurityCriticalAttribute]
internal static Identity ResolveIdentity(string URI);
    [SecurityCriticalAttribute]
internal static Identity CasualResolveIdentity(string uri);
    [SecurityCriticalAttribute]
internal static ServerIdentity FindOrCreateServerIdentity(MarshalByRefObject obj, string objURI, int flags);
    [SecurityCriticalAttribute]
internal static ServerIdentity FindOrCreateServerIdentity(MarshalByRefObject obj, string objURI, int flags, Enum wkoMode);
    [SecurityCriticalAttribute]
internal static Identity FindOrCreateIdentity(string objURI, string URL, ObjRef objectRef);
    [SecurityCriticalAttribute]
internal static void RemoveIdentity(string uri);
    [SecurityCriticalAttribute]
internal static void RemoveIdentity(string uri, bool bResetURI);
    [SecurityCriticalAttribute]
internal static bool AddDynamicProperty(MarshalByRefObject obj, IDynamicProperty prop);
    [SecurityCriticalAttribute]
internal static bool RemoveDynamicProperty(MarshalByRefObject obj, string name);
}
internal class System.Runtime.Remoting.IdOps : ValueType {
    internal static int None;
    internal static int GenerateURI;
    internal static int StrongIdentity;
    internal static bool bStrongIdentity(int flags);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IEnvoyInfo {
    public IMessageSink EnvoySinks { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink get_EnvoySinks();
    [SecurityCriticalAttribute]
public abstract virtual void set_EnvoySinks(IMessageSink value);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.InternalRemotingServices : object {
    [ConditionalAttribute("_LOGGING")]
[SecurityCriticalAttribute]
public static void DebugOutChnl(string s);
    [ConditionalAttribute("_LOGGING")]
public static void RemotingTrace(Object[] messages);
    [ConditionalAttribute("_DEBUG")]
public static void RemotingAssert(bool condition, string message);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static void SetServerIdentity(MethodCall m, object srvID);
    internal static RemotingMethodCachedData GetReflectionCachedData(MethodBase mi);
    internal static RemotingTypeCachedData GetReflectionCachedData(RuntimeType type);
    internal static RemotingCachedData GetReflectionCachedData(MemberInfo mi);
    internal static RemotingCachedData GetReflectionCachedData(RuntimeParameterInfo reflectionObject);
    [SecurityCriticalAttribute]
public static SoapAttribute GetCachedSoapAttribute(object reflectionObject);
}
[GuidAttribute("C460E2B4-E199-412a-8456-84DC3E4838C3")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.Remoting.IObjectHandle {
    public abstract virtual object Unwrap();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IRemotingTypeInfo {
    public string TypeName { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual string get_TypeName();
    [SecurityCriticalAttribute]
public abstract virtual void set_TypeName(string value);
    [SecurityCriticalAttribute]
public abstract virtual bool CanCastTo(Type fromType, object o);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Lifetime.ClientSponsor : MarshalByRefObject {
    public TimeSpan RenewalTime { get; public set; }
    public ClientSponsor(TimeSpan renewalTime);
    public TimeSpan get_RenewalTime();
    public void set_RenewalTime(TimeSpan value);
    [SecurityCriticalAttribute]
public bool Register(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
public void Unregister(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan Renewal(ILease lease);
    [SecurityCriticalAttribute]
public void Close();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Lifetime.ILease {
    public TimeSpan RenewOnCallTime { get; public set; }
    public TimeSpan SponsorshipTimeout { get; public set; }
    public TimeSpan InitialLeaseTime { get; public set; }
    public TimeSpan CurrentLeaseTime { get; }
    public LeaseState CurrentState { get; }
    [SecurityCriticalAttribute]
public abstract virtual void Register(ISponsor obj, TimeSpan renewalTime);
    [SecurityCriticalAttribute]
public abstract virtual void Register(ISponsor obj);
    [SecurityCriticalAttribute]
public abstract virtual void Unregister(ISponsor obj);
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan Renew(TimeSpan renewalTime);
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan get_RenewOnCallTime();
    [SecurityCriticalAttribute]
public abstract virtual void set_RenewOnCallTime(TimeSpan value);
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan get_SponsorshipTimeout();
    [SecurityCriticalAttribute]
public abstract virtual void set_SponsorshipTimeout(TimeSpan value);
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan get_InitialLeaseTime();
    [SecurityCriticalAttribute]
public abstract virtual void set_InitialLeaseTime(TimeSpan value);
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan get_CurrentLeaseTime();
    [SecurityCriticalAttribute]
public abstract virtual LeaseState get_CurrentState();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Lifetime.ISponsor {
    [SecurityCriticalAttribute]
public abstract virtual TimeSpan Renewal(ILease lease);
}
internal class System.Runtime.Remoting.Lifetime.Lease : MarshalByRefObject {
    internal int id;
    internal DateTime leaseTime;
    internal TimeSpan initialLeaseTime;
    internal TimeSpan renewOnCallTime;
    internal TimeSpan sponsorshipTimeout;
    internal Hashtable sponsorTable;
    internal int sponsorCallThread;
    internal LeaseManager leaseManager;
    internal MarshalByRefObject managedObject;
    internal LeaseState state;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) nextId;
    public TimeSpan RenewOnCallTime { get; public set; }
    public TimeSpan SponsorshipTimeout { get; public set; }
    public TimeSpan InitialLeaseTime { get; public set; }
    public TimeSpan CurrentLeaseTime { get; }
    public LeaseState CurrentState { get; }
    internal Lease(TimeSpan initialLeaseTime, TimeSpan renewOnCallTime, TimeSpan sponsorshipTimeout, MarshalByRefObject managedObject);
    private static Lease();
    internal void ActivateLease();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan get_RenewOnCallTime();
    [SecurityCriticalAttribute]
public sealed virtual void set_RenewOnCallTime(TimeSpan value);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan get_SponsorshipTimeout();
    [SecurityCriticalAttribute]
public sealed virtual void set_SponsorshipTimeout(TimeSpan value);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan get_InitialLeaseTime();
    [SecurityCriticalAttribute]
public sealed virtual void set_InitialLeaseTime(TimeSpan value);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan get_CurrentLeaseTime();
    [SecurityCriticalAttribute]
public sealed virtual LeaseState get_CurrentState();
    [SecurityCriticalAttribute]
public sealed virtual void Register(ISponsor obj);
    [SecurityCriticalAttribute]
public sealed virtual void Register(ISponsor obj, TimeSpan renewalTime);
    [SecurityCriticalAttribute]
public sealed virtual void Unregister(ISponsor sponsor);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan Renew(TimeSpan renewalTime);
    internal TimeSpan RenewInternal(TimeSpan renewalTime);
    internal void Remove();
    [SecurityCriticalAttribute]
internal void Cancel();
    internal void RenewOnCall();
    [SecurityCriticalAttribute]
internal void LeaseExpired(DateTime now);
    [SecurityCriticalAttribute]
internal void SponsorCall(ISponsor sponsor);
    [SecurityCriticalAttribute]
internal void SponsorTimeout(object sponsorId);
    [SecurityCriticalAttribute]
internal void SponsorCallback(object obj);
    [SecurityCriticalAttribute]
internal void SponsorCallback(IAsyncResult iar);
}
internal class System.Runtime.Remoting.Lifetime.LeaseLifeTimeServiceProperty : object {
    public string Name { get; }
    [SecurityCriticalAttribute]
public sealed virtual string get_Name();
    [SecurityCriticalAttribute]
public sealed virtual bool IsNewContextOK(Context newCtx);
    [SecurityCriticalAttribute]
public sealed virtual void Freeze(Context newContext);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink);
}
internal class System.Runtime.Remoting.Lifetime.LeaseManager : object {
    internal static bool IsInitialized();
    [SecurityCriticalAttribute]
internal static LeaseManager GetLeaseManager(TimeSpan pollTime);
    internal static LeaseManager GetLeaseManager();
    internal void ChangePollTime(TimeSpan pollTime);
    internal void ActivateLease(Lease lease);
    internal void DeleteLease(Lease lease);
    [ConditionalAttribute("_LOGGING")]
internal void DumpLeases(Lease[] leases);
    internal ILease GetLease(MarshalByRefObject obj);
    internal void ChangedLeaseTime(Lease lease, DateTime newTime);
    internal void RegisterSponsorCall(Lease lease, object sponsorId, TimeSpan sponsorshipTimeOut);
    internal void DeleteSponsor(object sponsorId);
}
internal class System.Runtime.Remoting.Lifetime.LeaseSink : object {
    public IMessageSink NextSink { get; }
    public LeaseSink(Lease lease, IMessageSink nextSink);
    [SecurityCriticalAttribute]
public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Lifetime.LeaseState : Enum {
    public int value__;
    public static LeaseState Null;
    public static LeaseState Initial;
    public static LeaseState Active;
    public static LeaseState Renewing;
    public static LeaseState Expired;
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Lifetime.LifetimeServices : object {
    public static TimeSpan LeaseTime { get; public set; }
    public static TimeSpan RenewOnCallTime { get; public set; }
    public static TimeSpan SponsorshipTimeout { get; public set; }
    public static TimeSpan LeaseManagerPollTime { get; public set; }
    private static LifetimeServices();
    public static TimeSpan get_LeaseTime();
    [SecurityCriticalAttribute]
public static void set_LeaseTime(TimeSpan value);
    public static TimeSpan get_RenewOnCallTime();
    [SecurityCriticalAttribute]
public static void set_RenewOnCallTime(TimeSpan value);
    public static TimeSpan get_SponsorshipTimeout();
    [SecurityCriticalAttribute]
public static void set_SponsorshipTimeout(TimeSpan value);
    public static TimeSpan get_LeaseManagerPollTime();
    [SecurityCriticalAttribute]
public static void set_LeaseManagerPollTime(TimeSpan value);
    [SecurityCriticalAttribute]
internal static ILease GetLeaseInitial(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static ILease GetLease(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static ILease CreateLease(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static ILease CreateLease(TimeSpan leaseTime, TimeSpan renewOnCallTime, TimeSpan sponsorshipTimeout, MarshalByRefObject obj);
}
internal class System.Runtime.Remoting.Messaging.ArgMapper : object {
    internal Int32[] Map { get; }
    internal int ArgCount { get; }
    internal Object[] Args { get; }
    internal Type[] ArgTypes { get; }
    internal String[] ArgNames { get; }
    [SecurityCriticalAttribute]
internal ArgMapper(IMethodMessage mm, bool fOut);
    [SecurityCriticalAttribute]
internal ArgMapper(MethodBase mb, bool fOut);
    internal Int32[] get_Map();
    internal int get_ArgCount();
    [SecurityCriticalAttribute]
internal object GetArg(int argNum);
    [SecurityCriticalAttribute]
internal string GetArgName(int argNum);
    [SecurityCriticalAttribute]
internal Object[] get_Args();
    internal Type[] get_ArgTypes();
    internal String[] get_ArgNames();
    internal static void GetParameterMaps(ParameterInfo[] parameters, Int32[]& inRefArgMap, Int32[]& outRefArgMap, Int32[]& outOnlyArgMap, Int32[]& nonRefOutArgMap, Int32[]& marshalRequestMap, Int32[]& marshalResponseMap);
    internal static Object[] ExpandAsyncEndArgsToSyncArgs(RemotingMethodCachedData syncMethod, Object[] asyncEndArgs);
}
internal class System.Runtime.Remoting.Messaging.AsyncReplySink : object {
    public IMessageSink NextSink { get; }
    internal AsyncReplySink(IMessageSink replySink, Context cliCtx);
    [SecurityCriticalAttribute]
internal static object SyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.AsyncResult : object {
    public bool IsCompleted { get; }
    public object AsyncDelegate { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public bool EndInvokeCalled { get; public set; }
    public WaitHandle AsyncWaitHandle { get; }
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal AsyncResult(Message m);
    public virtual bool get_IsCompleted();
    public virtual object get_AsyncDelegate();
    public virtual object get_AsyncState();
    public virtual bool get_CompletedSynchronously();
    public bool get_EndInvokeCalled();
    public void set_EndInvokeCalled(bool value);
    public virtual WaitHandle get_AsyncWaitHandle();
    public virtual void SetMessageCtrl(IMessageCtrl mc);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    public virtual IMessage GetReplyMessage();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.CallContext : object {
    internal static IPrincipal Principal { get; internal set; }
    public static object HostContext { get; public set; }
    internal static LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx);
    [SecurityCriticalAttribute]
public static void FreeNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public static object LogicalGetData(string name);
    [SecurityCriticalAttribute]
internal static IPrincipal get_Principal();
    [SecurityCriticalAttribute]
internal static void set_Principal(IPrincipal value);
    [SecurityCriticalAttribute]
public static object get_HostContext();
    [SecurityCriticalAttribute]
public static void set_HostContext(object value);
    [SecurityCriticalAttribute]
public static object GetData(string name);
    [SecurityCriticalAttribute]
public static void SetData(string name, object data);
    [SecurityCriticalAttribute]
public static void LogicalSetData(string name, object data);
    [SecurityCriticalAttribute]
public static Header[] GetHeaders();
    [SecurityCriticalAttribute]
public static void SetHeaders(Header[] headers);
}
internal class System.Runtime.Remoting.Messaging.CallContextRemotingData : object {
    internal string LogicalCallID { get; internal set; }
    internal bool HasInfo { get; }
    internal string get_LogicalCallID();
    internal void set_LogicalCallID(string value);
    internal bool get_HasInfo();
    public sealed virtual object Clone();
}
internal class System.Runtime.Remoting.Messaging.CallContextSecurityData : object {
    internal IPrincipal Principal { get; internal set; }
    internal bool HasInfo { get; }
    internal IPrincipal get_Principal();
    internal void set_Principal(IPrincipal value);
    internal bool get_HasInfo();
    public sealed virtual object Clone();
}
internal class System.Runtime.Remoting.Messaging.CCMDictionary : MessageDictionary {
    public static String[] CCMkeys;
    internal IConstructionCallMessage _ccmsg;
    public CCMDictionary(IConstructionCallMessage msg, IDictionary idict);
    private static CCMDictionary();
    [SecuritySafeCriticalAttribute]
internal virtual object GetMessageValue(int i);
    [SecurityCriticalAttribute]
internal virtual void SetSpecialKey(int keyNum, object value);
}
internal class System.Runtime.Remoting.Messaging.ClientAsyncReplyTerminatorSink : object {
    internal IMessageSink _nextSink;
    public IMessageSink NextSink { get; }
    internal ClientAsyncReplyTerminatorSink(IMessageSink nextSink);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage replyMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage replyMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ClientContextTerminatorSink : InternalSink {
    internal static IMessageSink MessageSink { get; }
    public IMessageSink NextSink { get; }
    private static ClientContextTerminatorSink();
    internal static IMessageSink get_MessageSink();
    [SecurityCriticalAttribute]
internal static object SyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static object AsyncProcessMessageCallback(Object[] args);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.ConstructionCall : MethodCall {
    internal Type _activationType;
    internal string _activationTypeName;
    internal IList _contextProperties;
    internal Object[] _callSiteActivationAttributes;
    internal IActivator _activator;
    public Object[] CallSiteActivationAttributes { get; }
    public Type ActivationType { get; }
    public string ActivationTypeName { get; }
    public IList ContextProperties { get; }
    public IDictionary Properties { get; }
    public IActivator Activator { get; public set; }
    public ConstructionCall(Header[] headers);
    public ConstructionCall(IMessage m);
    internal ConstructionCall(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal virtual bool FillSpecialHeader(string key, object value);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_CallSiteActivationAttributes();
    [SecurityCriticalAttribute]
public sealed virtual Type get_ActivationType();
    [SecurityCriticalAttribute]
public sealed virtual string get_ActivationTypeName();
    [SecurityCriticalAttribute]
public sealed virtual IList get_ContextProperties();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual IActivator get_Activator();
    [SecurityCriticalAttribute]
public sealed virtual void set_Activator(IActivator value);
}
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.ConstructionResponse : MethodResponse {
    public IDictionary Properties { get; }
    public ConstructionResponse(Header[] h, IMethodCallMessage mcm);
    internal ConstructionResponse(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
}
internal class System.Runtime.Remoting.Messaging.ConstructorCallMessage : object {
    public Object[] CallSiteActivationAttributes { get; }
    public Type ActivationType { get; }
    public string ActivationTypeName { get; }
    public IList ContextProperties { get; }
    public string Uri { get; public set; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public int ArgCount { get; }
    public bool HasVarArgs { get; }
    public Object[] Args { get; }
    public IDictionary Properties { get; }
    public IActivator Activator { get; public set; }
    public LogicalCallContext LogicalCallContext { get; }
    internal bool ActivateInContext { get; internal set; }
    [SecurityCriticalAttribute]
internal ConstructorCallMessage(Object[] callSiteActivationAttributes, Object[] womAttr, Object[] typeAttr, RuntimeType serverType);
    [SecurityCriticalAttribute]
public object GetThisPtr();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_CallSiteActivationAttributes();
    internal Object[] GetWOMAttributes();
    internal Object[] GetTypeAttributes();
    [SecurityCriticalAttribute]
public sealed virtual Type get_ActivationType();
    [SecurityCriticalAttribute]
public sealed virtual string get_ActivationTypeName();
    [SecurityCriticalAttribute]
public sealed virtual IList get_ContextProperties();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual IActivator get_Activator();
    [SecurityCriticalAttribute]
public sealed virtual void set_Activator(IActivator value);
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    internal bool get_ActivateInContext();
    internal void set_ActivateInContext(bool value);
    [SecurityCriticalAttribute]
internal void SetFrame(MessageData msgData);
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    [SecurityCriticalAttribute]
internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx);
    internal Message GetMessage();
}
[SecurityCriticalAttribute]
internal class System.Runtime.Remoting.Messaging.ConstructorReturnMessage : ReturnMessage {
    public object ReturnValue { get; }
    public IDictionary Properties { get; }
    public ConstructorReturnMessage(MarshalByRefObject o, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IConstructionCallMessage ccm);
    public ConstructorReturnMessage(Exception e, IConstructionCallMessage ccm);
    [SecurityCriticalAttribute]
public virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    internal object GetObject();
}
internal class System.Runtime.Remoting.Messaging.CRMDictionary : MessageDictionary {
    public static String[] CRMkeysFault;
    public static String[] CRMkeysNoFault;
    internal IConstructionReturnMessage _crmsg;
    internal bool fault;
    [SecurityCriticalAttribute]
public CRMDictionary(IConstructionReturnMessage msg, IDictionary idict);
    private static CRMDictionary();
    [SecuritySafeCriticalAttribute]
internal virtual object GetMessageValue(int i);
    [SecurityCriticalAttribute]
internal virtual void SetSpecialKey(int keyNum, object value);
}
internal class System.Runtime.Remoting.Messaging.DisposeSink : object {
    public IMessageSink NextSink { get; }
    internal DisposeSink(IDisposable iDis, IMessageSink replySink);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.EnvoyTerminatorSink : InternalSink {
    internal static IMessageSink MessageSink { get; }
    public IMessageSink NextSink { get; }
    private static EnvoyTerminatorSink();
    internal static IMessageSink get_MessageSink();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ErrorMessage : object {
    public IDictionary Properties { get; }
    public string Uri { get; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public sealed virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.Header : object {
    public string Name;
    public object Value;
    public bool MustUnderstand;
    public string HeaderNamespace;
    public Header(string _Name, object _Value);
    public Header(string _Name, object _Value, bool _MustUnderstand);
    public Header(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.HeaderHandler : MulticastDelegate {
    public HeaderHandler(object object, IntPtr method);
    public virtual object Invoke(Header[] headers);
    public virtual IAsyncResult BeginInvoke(Header[] headers, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal interface System.Runtime.Remoting.Messaging.IInternalMessage {
    public ServerIdentity ServerIdentityObject { get; public set; }
    public Identity IdentityObject { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual ServerIdentity get_ServerIdentityObject();
    [SecurityCriticalAttribute]
public abstract virtual void set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
public abstract virtual Identity get_IdentityObject();
    [SecurityCriticalAttribute]
public abstract virtual void set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
public abstract virtual void SetURI(string uri);
    [SecurityCriticalAttribute]
public abstract virtual void SetCallContext(LogicalCallContext callContext);
    [SecurityCriticalAttribute]
public abstract virtual bool HasProperties();
}
internal class System.Runtime.Remoting.Messaging.IllogicalCallContext : object {
    internal object HostContext { get; internal set; }
    internal bool HasUserData { get; }
    internal object get_HostContext();
    internal void set_HostContext(object value);
    internal bool get_HasUserData();
    public void FreeNamedDataSlot(string name);
    public object GetData(string name);
    public void SetData(string name, object data);
    public IllogicalCallContext CreateCopy();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.ILogicalThreadAffinative {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessage {
    public IDictionary Properties { get; }
    [SecurityCriticalAttribute]
public abstract virtual IDictionary get_Properties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessageCtrl {
    [SecurityCriticalAttribute]
public abstract virtual void Cancel(int msToCancel);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessageSink {
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
public abstract virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public abstract virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public abstract virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodCallMessage {
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    [SecurityCriticalAttribute]
public abstract virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public abstract virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public abstract virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public abstract virtual Object[] get_InArgs();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodMessage {
    public string Uri { get; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    [SecurityCriticalAttribute]
public abstract virtual string get_Uri();
    [SecurityCriticalAttribute]
public abstract virtual string get_MethodName();
    [SecurityCriticalAttribute]
public abstract virtual string get_TypeName();
    [SecurityCriticalAttribute]
public abstract virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public abstract virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public abstract virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public abstract virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public abstract virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public abstract virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public abstract virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public abstract virtual MethodBase get_MethodBase();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodReturnMessage {
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public Exception Exception { get; }
    public object ReturnValue { get; }
    [SecurityCriticalAttribute]
public abstract virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public abstract virtual string GetOutArgName(int index);
    [SecurityCriticalAttribute]
public abstract virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public abstract virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public abstract virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public abstract virtual object get_ReturnValue();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.InternalMessageWrapper : object {
    protected IMessage WrappedMessage;
    public InternalMessageWrapper(IMessage msg);
    [SecurityCriticalAttribute]
internal object GetIdentityObject();
    [SecurityCriticalAttribute]
internal object GetServerIdentityObject();
}
internal class System.Runtime.Remoting.Messaging.InternalSink : object {
    [SecurityCriticalAttribute]
internal static IMessage ValidateMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static IMessage DisallowAsyncActivation(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static Identity GetIdentity(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static ServerIdentity GetServerIdentity(IMessage reqMsg);
    [SecurityCriticalAttribute]
internal static string GetURI(IMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IRemotingFormatter {
    public abstract virtual object Deserialize(Stream serializationStream, HeaderHandler handler);
    public abstract virtual void Serialize(Stream serializationStream, object graph, Header[] headers);
}
internal interface System.Runtime.Remoting.Messaging.ISerializationRootObject {
    [SecurityCriticalAttribute]
public abstract virtual void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.LogicalCallContext : object {
    public bool HasInfo { get; }
    internal CallContextRemotingData RemotingData { get; }
    internal CallContextSecurityData SecurityData { get; }
    internal object HostContext { get; internal set; }
    internal IPrincipal Principal { get; internal set; }
    [SecurityCriticalAttribute]
internal LogicalCallContext(SerializationInfo info, StreamingContext context);
    private static LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public sealed virtual object Clone();
    [SecurityCriticalAttribute]
internal void Merge(LogicalCallContext lc);
    [SecurityCriticalAttribute]
public bool get_HasInfo();
    internal CallContextRemotingData get_RemotingData();
    internal CallContextSecurityData get_SecurityData();
    internal object get_HostContext();
    internal void set_HostContext(object value);
    internal IPrincipal get_Principal();
    [SecurityCriticalAttribute]
internal void set_Principal(IPrincipal value);
    [SecurityCriticalAttribute]
public void FreeNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public object GetData(string name);
    [SecurityCriticalAttribute]
public void SetData(string name, object data);
    internal void InternalSetHeaders(Header[] headers);
    internal Header[] InternalGetHeaders();
    [SecurityCriticalAttribute]
internal IPrincipal RemovePrincipalIfNotSerializable();
    [SecurityCriticalAttribute]
internal void PropagateOutgoingHeadersToMessage(IMessage msg);
    internal static string GetPropertyKeyForHeader(Header header);
    [SecurityCriticalAttribute]
internal void PropagateIncomingHeadersToCallContext(IMessage msg);
}
internal class System.Runtime.Remoting.Messaging.MCMDictionary : MessageDictionary {
    public static String[] MCMkeys;
    internal IMethodCallMessage _mcmsg;
    public MCMDictionary(IMethodCallMessage msg, IDictionary idict);
    private static MCMDictionary();
    [SecuritySafeCriticalAttribute]
internal virtual object GetMessageValue(int i);
    [SecurityCriticalAttribute]
internal virtual void SetSpecialKey(int keyNum, object value);
}
internal class System.Runtime.Remoting.Messaging.Message : object {
    internal static int Sync;
    internal static int BeginAsync;
    internal static int EndAsync;
    internal static int Ctor;
    internal static int OneWay;
    internal static int CallMask;
    internal static int FixedArgs;
    internal static int VarArgs;
    internal static string CallContextKey;
    internal static string UriKey;
    private ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.ServerIdentityObject { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.IdentityObject { get; private set; }
    public IDictionary Properties { get; }
    public string Uri { get; public set; }
    public bool HasVarArgs { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    private static Message();
    public virtual Exception GetFault();
    public virtual void SetFault(Exception e);
    internal virtual void SetOneWay();
    public virtual int GetCallType();
    internal IntPtr GetFramePtr();
    [SecurityCriticalAttribute]
public void GetAsyncBeginInfo(AsyncCallback& acbd, Object& state);
    [SecurityCriticalAttribute]
public object GetThisPtr();
    [SecurityCriticalAttribute]
public IAsyncResult GetAsyncResult();
    public void Init();
    [SecurityCriticalAttribute]
public object GetReturnValue();
    [SecurityCriticalAttribute]
internal void InitFields(MessageData msgData);
    [SecurityCriticalAttribute]
private sealed virtual override ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.get_ServerIdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_IdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetURI(string URI);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetCallContext(LogicalCallContext callContext);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal MethodBase GetMethodBase();
    [SecurityCriticalAttribute]
internal LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx);
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    [SecurityCriticalAttribute]
internal static Type[] GenerateMethodSignature(MethodBase mb);
    [SecurityCriticalAttribute]
internal static Object[] CoerceArgs(IMethodMessage m);
    [SecurityCriticalAttribute]
internal static Object[] CoerceArgs(IMethodMessage m, ParameterInfo[] pi);
    [SecurityCriticalAttribute]
internal static Object[] CoerceArgs(MethodBase mb, Object[] args, ParameterInfo[] pi);
    [SecurityCriticalAttribute]
internal static object CoerceArg(object value, Type pt);
    [SecurityCriticalAttribute]
internal static object SoapCoerceArg(object value, Type pt, Hashtable keyToNamespaceTable);
    [SecurityCriticalAttribute]
internal bool InternalHasVarArgs();
    [SecurityCriticalAttribute]
internal int InternalGetArgCount();
    [SecurityCriticalAttribute]
public void PropagateOutParameters(Object[] OutArgs, object retVal);
    [SecurityCriticalAttribute]
public bool Dispatch(object target);
    [ConditionalAttribute("_REMOTING_DEBUG")]
[SecurityCriticalAttribute]
public static void DebugOut(string s);
    [SecurityCriticalAttribute]
internal static void OutToUnmanagedDebugger(string s);
    [SecurityCriticalAttribute]
internal static LogicalCallContext PropagateCallContextFromMessageToThread(IMessage msg);
    [SecurityCriticalAttribute]
internal static void PropagateCallContextFromThreadToMessage(IMessage msg);
    [SecurityCriticalAttribute]
internal static void PropagateCallContextFromThreadToMessage(IMessage msg, LogicalCallContext oldcctx);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Runtime.Remoting.Messaging.MessageDictionary : object {
    internal String[] _keys;
    internal IDictionary _dict;
    internal IDictionary InternalDictionary { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    internal MessageDictionary(String[] keys, IDictionary idict);
    internal bool HasUserData();
    internal IDictionary get_InternalDictionary();
    internal abstract virtual object GetMessageValue(int i);
    [SecurityCriticalAttribute]
internal abstract virtual void SetSpecialKey(int keyNum, object value);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsFixedSize();
    public virtual object get_SyncRoot();
    public virtual bool Contains(object key);
    protected virtual bool ContainsSpecialKey(object key);
    public virtual void CopyTo(Array array, int index);
    public virtual object get_Item(object key);
    [SecuritySafeCriticalAttribute]
public virtual void set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual void Remove(object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual int get_Count();
}
internal class System.Runtime.Remoting.Messaging.MessageDictionaryEnumerator : object {
    public object Key { get; }
    public object Value { get; }
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public MessageDictionaryEnumerator(MessageDictionary md, IDictionary hashtable);
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual void Reset();
}
internal class System.Runtime.Remoting.Messaging.MessageSmuggler : object {
    [SecurityCriticalAttribute]
protected static Object[] FixupArgs(Object[] args, ArrayList& argsToSerialize);
    [SecurityCriticalAttribute]
protected static object FixupArg(object arg, ArrayList& argsToSerialize);
    [SecurityCriticalAttribute]
protected static Object[] UndoFixupArgs(Object[] args, ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
protected static object UndoFixupArg(object arg, ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
protected static int StoreUserPropertiesForMethodMessage(IMethodMessage msg, ArrayList& argsToSerialize);
}
internal class System.Runtime.Remoting.Messaging.MessageSurrogate : object {
    [SecuritySafeCriticalAttribute]
private static MessageSurrogate();
    [SecurityCriticalAttribute]
internal MessageSurrogate(RemotingSurrogateSelector ss);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MessageSurrogateFilter : MulticastDelegate {
    public MessageSurrogateFilter(object object, IntPtr method);
    public virtual bool Invoke(string key, object value);
    public virtual IAsyncResult BeginInvoke(string key, object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.MethodCall : object {
    protected IDictionary ExternalProperties;
    protected IDictionary InternalProperties;
    public int ArgCount { get; }
    public Object[] Args { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public string Uri { get; public set; }
    public bool HasVarArgs { get; }
    public IDictionary Properties { get; }
    public LogicalCallContext LogicalCallContext { get; }
    private ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.ServerIdentityObject { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.IdentityObject { get; private set; }
    [SecurityCriticalAttribute]
public MethodCall(Header[] h1);
    [SecurityCriticalAttribute]
public MethodCall(IMessage msg);
    [SecurityCriticalAttribute]
internal MethodCall(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal MethodCall(SmuggledMethodCallMessage smuggledMsg, ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal MethodCall(object handlerObject, BinaryMethodCallMessage smuggledMsg);
    [SecurityCriticalAttribute]
public sealed virtual void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
    [SecurityCriticalAttribute]
internal void SetObjectData(SerializationInfo info, StreamingContext context);
    internal Type ResolveType();
    [SecurityCriticalAttribute]
public void ResolveMethod();
    [SecurityCriticalAttribute]
internal void ResolveMethod(bool bThrowIfNotResolved);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal void SetObjectFromSoapData(SerializationInfo info);
    public virtual void Init();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx);
    [SecurityCriticalAttribute]
private sealed virtual override ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.get_ServerIdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_IdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetURI(string val);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetCallContext(LogicalCallContext newCallContext);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    [SecurityCriticalAttribute]
internal void FillHeaders(Header[] h);
    [SecurityCriticalAttribute]
internal virtual bool FillSpecialHeader(string key, object value);
    [SecurityCriticalAttribute]
internal void FillHeader(string key, object value);
    [SecurityCriticalAttribute]
public virtual object HeaderHandler(Header[] h);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MethodCallMessageWrapper : InternalMessageWrapper {
    public string Uri { get; public set; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public int ArgCount { get; }
    public Object[] Args { get; public set; }
    public bool HasVarArgs { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public IDictionary Properties { get; }
    public MethodCallMessageWrapper(IMethodCallMessage msg);
    [SecurityCriticalAttribute]
public virtual string get_Uri();
    public virtual void set_Uri(string value);
    [SecurityCriticalAttribute]
public virtual string get_MethodName();
    [SecurityCriticalAttribute]
public virtual string get_TypeName();
    [SecurityCriticalAttribute]
public virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public virtual Object[] get_Args();
    public virtual void set_Args(Object[] value);
    [SecurityCriticalAttribute]
public virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetInArgName(int index);
    [SecurityCriticalAttribute]
public virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
}
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MethodResponse : object {
    protected IDictionary InternalProperties;
    protected IDictionary ExternalProperties;
    public string Uri { get; public set; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public bool HasVarArgs { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public Exception Exception { get; }
    public object ReturnValue { get; }
    public IDictionary Properties { get; }
    public LogicalCallContext LogicalCallContext { get; }
    private ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.ServerIdentityObject { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.IdentityObject { get; private set; }
    [SecurityCriticalAttribute]
public MethodResponse(Header[] h1, IMethodCallMessage mcm);
    [SecurityCriticalAttribute]
internal MethodResponse(IMethodCallMessage msg, SmuggledMethodReturnMessage smuggledMrm, ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal MethodResponse(IMethodCallMessage msg, object handlerObject, BinaryMethodReturnMessage smuggledMrm);
    [SecurityCriticalAttribute]
internal MethodResponse(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object HeaderHandler(Header[] h);
    [SecurityCriticalAttribute]
public sealed virtual void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
    [SecurityCriticalAttribute]
internal void SetObjectData(SerializationInfo info, StreamingContext ctx);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal void SetObjectFromSoapData(SerializationInfo info);
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx);
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetOutArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public sealed virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal void FillHeaders(Header[] h);
    [SecurityCriticalAttribute]
internal void FillHeader(string name, object value);
    [SecurityCriticalAttribute]
private sealed virtual override ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.get_ServerIdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_IdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetURI(string val);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetCallContext(LogicalCallContext newCallContext);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.MethodReturnMessageWrapper : InternalMessageWrapper {
    public string Uri { get; public set; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public int ArgCount { get; }
    public Object[] Args { get; public set; }
    public bool HasVarArgs { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public Exception Exception { get; public set; }
    public object ReturnValue { get; public set; }
    public IDictionary Properties { get; }
    public MethodReturnMessageWrapper(IMethodReturnMessage msg);
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public virtual string get_MethodName();
    [SecurityCriticalAttribute]
public virtual string get_TypeName();
    [SecurityCriticalAttribute]
public virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public virtual Object[] get_Args();
    public virtual void set_Args(Object[] value);
    [SecurityCriticalAttribute]
public virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetOutArgName(int index);
    [SecurityCriticalAttribute]
public virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public virtual Exception get_Exception();
    public virtual void set_Exception(Exception value);
    [SecurityCriticalAttribute]
public virtual object get_ReturnValue();
    public virtual void set_ReturnValue(object value);
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
}
internal class System.Runtime.Remoting.Messaging.MRMDictionary : MessageDictionary {
    public static String[] MCMkeysFault;
    public static String[] MCMkeysNoFault;
    internal IMethodReturnMessage _mrmsg;
    internal bool fault;
    [SecurityCriticalAttribute]
public MRMDictionary(IMethodReturnMessage msg, IDictionary idict);
    private static MRMDictionary();
    [SecuritySafeCriticalAttribute]
internal virtual object GetMessageValue(int i);
    [SecurityCriticalAttribute]
internal virtual void SetSpecialKey(int keyNum, object value);
}
internal class System.Runtime.Remoting.Messaging.ObjRefSurrogate : object {
    [SecurityCriticalAttribute]
public virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Remoting.Messaging.OneWayAttribute : Attribute {
}
internal class System.Runtime.Remoting.Messaging.RemotingSurrogate : object {
    [SecurityCriticalAttribute]
public virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.RemotingSurrogateSelector : object {
    public MessageSurrogateFilter Filter { get; public set; }
    private static RemotingSurrogateSelector();
    public void set_Filter(MessageSurrogateFilter value);
    public MessageSurrogateFilter get_Filter();
    public void SetRootObject(object obj);
    public object GetRootObject();
    [SecurityCriticalAttribute]
public virtual void ChainSelector(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& ssout);
    [SecurityCriticalAttribute]
public virtual ISurrogateSelector GetNextSelector();
    public virtual void UseSoapFormat();
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.ReturnMessage : object {
    internal object _ret;
    internal object _properties;
    internal string _URI;
    internal Exception _e;
    internal Object[] _outArgs;
    internal int _outArgsCount;
    internal string _methodName;
    internal string _typeName;
    internal Type[] _methodSignature;
    internal bool _hasVarArgs;
    internal LogicalCallContext _callContext;
    internal ArgMapper _argMapper;
    internal MethodBase _methodBase;
    public string Uri { get; public set; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public bool HasVarArgs { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public Exception Exception { get; }
    public object ReturnValue { get; }
    public IDictionary Properties { get; }
    public LogicalCallContext LogicalCallContext { get; }
    [SecurityCriticalAttribute]
public ReturnMessage(object ret, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm);
    [SecurityCriticalAttribute]
public ReturnMessage(Exception e, IMethodCallMessage mcm);
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetOutArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    internal LogicalCallContext SetLogicalCallContext(LogicalCallContext ctx);
    internal bool HasProperties();
    [SecurityCriticalAttribute]
internal static bool IsCustomErrorEnabled();
}
internal class System.Runtime.Remoting.Messaging.SerializationMonkey : object {
    internal ISerializationRootObject _obj;
    internal String[] fieldNames;
    internal Type[] fieldTypes;
    public String[] FieldNames { get; public set; }
    public Type[] FieldTypes { get; public set; }
    [SecurityCriticalAttribute]
internal SerializationMonkey(SerializationInfo info, StreamingContext ctx);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual String[] get_FieldNames();
    [SecurityCriticalAttribute]
public sealed virtual void set_FieldNames(String[] value);
    [SecurityCriticalAttribute]
public sealed virtual Type[] get_FieldTypes();
    [SecurityCriticalAttribute]
public sealed virtual void set_FieldTypes(Type[] value);
}
internal class System.Runtime.Remoting.Messaging.ServerContextTerminatorSink : InternalSink {
    internal static IMessageSink MessageSink { get; }
    public IMessageSink NextSink { get; }
    private static ServerContextTerminatorSink();
    internal static IMessageSink get_MessageSink();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    [SecurityCriticalAttribute]
internal virtual IMessageSink GetObjectChain(IMessage reqMsg, MarshalByRefObject& obj);
}
internal class System.Runtime.Remoting.Messaging.ServerObjectTerminatorSink : InternalSink {
    internal StackBuilderSink _stackBuilderSink;
    public IMessageSink NextSink { get; }
    internal ServerObjectTerminatorSink(MarshalByRefObject srvObj);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage reqMsg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage : MessageSmuggler {
    internal string Uri { get; }
    internal string MethodName { get; }
    internal string TypeName { get; }
    internal int MessagePropertyCount { get; }
    [SecurityCriticalAttribute]
internal static SmuggledMethodCallMessage SmuggleIfPossible(IMessage msg);
    [SecurityCriticalAttribute]
internal ArrayList FixupForNewAppDomain();
    internal string get_Uri();
    internal string get_MethodName();
    internal string get_TypeName();
    internal Type[] GetInstantiation(ArrayList deserializedArgs);
    internal Object[] GetMethodSignature(ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal Object[] GetArgs(ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal LogicalCallContext GetCallContext(ArrayList deserializedArgs);
    internal int get_MessagePropertyCount();
    internal void PopulateMessageProperties(IDictionary dict, ArrayList deserializedArgs);
}
internal class System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage : MessageSmuggler {
    internal int MessagePropertyCount { get; }
    [SecurityCriticalAttribute]
internal static SmuggledMethodReturnMessage SmuggleIfPossible(IMessage msg);
    [SecurityCriticalAttribute]
internal ArrayList FixupForNewAppDomain();
    [SecurityCriticalAttribute]
internal object GetReturnValue(ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal Object[] GetArgs(ArrayList deserializedArgs);
    internal Exception GetException(ArrayList deserializedArgs);
    [SecurityCriticalAttribute]
internal LogicalCallContext GetCallContext(ArrayList deserializedArgs);
    internal int get_MessagePropertyCount();
    internal void PopulateMessageProperties(IDictionary dict, ArrayList deserializedArgs);
}
internal class System.Runtime.Remoting.Messaging.SmuggledObjRef : object {
    public ObjRef ObjRef { get; }
    [SecurityCriticalAttribute]
public SmuggledObjRef(ObjRef objRef);
    [SecurityCriticalAttribute]
public ObjRef get_ObjRef();
}
internal class System.Runtime.Remoting.Messaging.SoapMessageSurrogate : object {
    [SecurityCriticalAttribute]
internal SoapMessageSurrogate(RemotingSurrogateSelector ss);
    private static SoapMessageSurrogate();
    internal void SetRootObject(object obj);
    [SecurityCriticalAttribute]
internal virtual String[] GetInArgNames(IMethodCallMessage m, int c);
    [SecurityCriticalAttribute]
internal virtual String[] GetNames(IMethodCallMessage m, int c);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
internal class System.Runtime.Remoting.Messaging.StackBasedReturnMessage : object {
    public string Uri { get; }
    public string MethodName { get; }
    public string TypeName { get; }
    public object MethodSignature { get; }
    public MethodBase MethodBase { get; }
    public bool HasVarArgs { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public Exception Exception { get; }
    public object ReturnValue { get; }
    public IDictionary Properties { get; }
    private ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.ServerIdentityObject { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.IdentityObject { get; private set; }
    internal void InitFields(Message m);
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal LogicalCallContext GetLogicalCallContext();
    [SecurityCriticalAttribute]
internal LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx);
    [SecurityCriticalAttribute]
public sealed virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public sealed virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetOutArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public sealed virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
private sealed virtual override ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.get_ServerIdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_IdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetURI(string val);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetCallContext(LogicalCallContext newCallContext);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
}
internal class System.Runtime.Remoting.Messaging.StackBuilderSink : object {
    public IMessageSink NextSink { get; }
    internal object ServerObject { get; }
    public StackBuilderSink(MarshalByRefObject server);
    public StackBuilderSink(object server);
    private static StackBuilderSink();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    [SecurityCriticalAttribute]
internal bool IsOKToStackBlt(IMethodMessage mcMsg, object server);
    internal void CopyNonByrefOutArgsFromOriginalArgs(RemotingMethodCachedData methodCache, Object[] args, Object[]& marshalResponseArgs);
    [SecurityCriticalAttribute]
internal static void PreserveThreadPrincipalIfNecessary(LogicalCallContext messageCallContext, LogicalCallContext threadCallContext);
    internal object get_ServerObject();
    [SecurityCriticalAttribute]
public object PrivateProcessMessage(RuntimeMethodHandle md, Object[] args, object server, Object[]& outArgs);
}
internal class System.Runtime.Remoting.Messaging.TransitionCall : object {
    public IDictionary Properties { get; }
    private ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.ServerIdentityObject { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.IdentityObject { get; private set; }
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal TransitionCall(IntPtr targetCtxID, CrossContextDelegate deleg);
    [SecurityCriticalAttribute]
internal TransitionCall(IntPtr targetCtxID, IntPtr eeData, int targetDomainID);
    internal TransitionCall(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
private sealed virtual override ServerIdentity System.Runtime.Remoting.Messaging.IInternalMessage.get_ServerIdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_ServerIdentityObject(ServerIdentity value);
    [SecurityCriticalAttribute]
private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_IdentityObject();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetURI(string uri);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.SetCallContext(LogicalCallContext callContext);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    [SecurityCriticalAttribute]
public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal abstract class System.Runtime.Remoting.Metadata.RemotingCachedData : object {
    internal SoapAttribute GetSoapAttribute();
    internal abstract virtual SoapAttribute GetSoapAttributeNoLock();
}
internal class System.Runtime.Remoting.Metadata.RemotingFieldCachedData : RemotingCachedData {
    internal RemotingFieldCachedData(RuntimeFieldInfo ri);
    internal RemotingFieldCachedData(SerializationFieldInfo ri);
    internal virtual SoapAttribute GetSoapAttributeNoLock();
}
internal class System.Runtime.Remoting.Metadata.RemotingMethodCachedData : RemotingCachedData {
    internal string TypeAndAssemblyName { get; }
    internal string MethodName { get; }
    internal ParameterInfo[] Parameters { get; }
    internal Int32[] OutRefArgMap { get; }
    internal Int32[] OutOnlyArgMap { get; }
    internal Int32[] NonRefOutArgMap { get; }
    internal Int32[] MarshalRequestArgMap { get; }
    internal Int32[] MarshalResponseArgMap { get; }
    internal Type ReturnType { get; }
    internal RemotingMethodCachedData(RuntimeMethodInfo ri);
    internal RemotingMethodCachedData(RuntimeConstructorInfo ri);
    internal virtual SoapAttribute GetSoapAttributeNoLock();
    [SecurityCriticalAttribute]
internal string get_TypeAndAssemblyName();
    [SecurityCriticalAttribute]
internal string get_MethodName();
    internal ParameterInfo[] get_Parameters();
    internal Int32[] get_OutRefArgMap();
    internal Int32[] get_OutOnlyArgMap();
    internal Int32[] get_NonRefOutArgMap();
    internal Int32[] get_MarshalRequestArgMap();
    internal Int32[] get_MarshalResponseArgMap();
    internal bool IsOneWayMethod();
    internal bool IsOverloaded();
    internal Type get_ReturnType();
}
internal class System.Runtime.Remoting.Metadata.RemotingParameterCachedData : RemotingCachedData {
    internal RemotingParameterCachedData(RuntimeParameterInfo ri);
    internal virtual SoapAttribute GetSoapAttributeNoLock();
}
internal class System.Runtime.Remoting.Metadata.RemotingTypeCachedData : RemotingCachedData {
    internal TypeInfo TypeInfo { get; }
    internal string QualifiedTypeName { get; }
    internal string AssemblyName { get; }
    internal string SimpleAssemblyName { get; }
    internal RemotingTypeCachedData(RuntimeType ri);
    internal virtual SoapAttribute GetSoapAttributeNoLock();
    internal MethodBase GetLastCalledMethod(string newMeth);
    internal void SetLastCalledMethod(string newMethName, MethodBase newMB);
    [SecurityCriticalAttribute]
internal TypeInfo get_TypeInfo();
    [SecurityCriticalAttribute]
internal string get_QualifiedTypeName();
    internal string get_AssemblyName();
    [SecurityCriticalAttribute]
internal string get_SimpleAssemblyName();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapAttribute : Attribute {
    protected string ProtXmlNamespace;
    protected object ReflectInfo;
    public string XmlNamespace { get; public set; }
    public bool UseAttribute { get; public set; }
    public bool Embedded { get; public set; }
    internal void SetReflectInfo(object info);
    public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
    public virtual bool get_Embedded();
    public virtual void set_Embedded(bool value);
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapFieldAttribute : SoapAttribute {
    public string XmlElementName { get; public set; }
    public int Order { get; public set; }
    public bool IsInteropXmlElement();
    public string get_XmlElementName();
    public void set_XmlElementName(string value);
    public int get_Order();
    public void set_Order(int value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Remoting.Metadata.SoapMethodAttribute : SoapAttribute {
    internal bool SoapActionExplicitySet { get; }
    public string SoapAction { get; public set; }
    public bool UseAttribute { get; public set; }
    public string XmlNamespace { get; public set; }
    public string ResponseXmlElementName { get; public set; }
    public string ResponseXmlNamespace { get; public set; }
    public string ReturnXmlElementName { get; public set; }
    internal bool get_SoapActionExplicitySet();
    [SecuritySafeCriticalAttribute]
public string get_SoapAction();
    public void set_SoapAction(string value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
    [SecuritySafeCriticalAttribute]
public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    public string get_ResponseXmlElementName();
    public void set_ResponseXmlElementName(string value);
    public string get_ResponseXmlNamespace();
    public void set_ResponseXmlNamespace(string value);
    public string get_ReturnXmlElementName();
    public void set_ReturnXmlElementName(string value);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.Remoting.Metadata.SoapOption : Enum {
    public int value__;
    public static SoapOption None;
    public static SoapOption AlwaysIncludeTypes;
    public static SoapOption XsdString;
    public static SoapOption EmbedAll;
    public static SoapOption Option1;
    public static SoapOption Option2;
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapParameterAttribute : SoapAttribute {
}
[AttributeUsageAttribute("1052")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapTypeAttribute : SoapAttribute {
    public SoapOption SoapOptions { get; public set; }
    public string XmlElementName { get; public set; }
    public string XmlNamespace { get; public set; }
    public string XmlTypeName { get; public set; }
    public string XmlTypeNamespace { get; public set; }
    public XmlFieldOrderOption XmlFieldOrder { get; public set; }
    public bool UseAttribute { get; public set; }
    internal bool IsInteropXmlElement();
    internal bool IsInteropXmlType();
    public SoapOption get_SoapOptions();
    public void set_SoapOptions(SoapOption value);
    public string get_XmlElementName();
    public void set_XmlElementName(string value);
    public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    public string get_XmlTypeName();
    public void set_XmlTypeName(string value);
    [SecuritySafeCriticalAttribute]
public string get_XmlTypeNamespace();
    public void set_XmlTypeNamespace(string value);
    public XmlFieldOrderOption get_XmlFieldOrder();
    public void set_XmlFieldOrder(XmlFieldOrderOption value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd {
    public abstract virtual string GetXsdType();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapAnyUri(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapAnyUri Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary : object {
    public static string XsdType { get; }
    public Byte[] Value { get; public set; }
    public SoapBase64Binary(Byte[] value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    public virtual string ToString();
    public static SoapBase64Binary Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public int Sign { get; public set; }
    public SoapDate(DateTime value);
    public SoapDate(DateTime value, int sign);
    private static SoapDate();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public int get_Sign();
    public void set_Sign(int value);
    public virtual string ToString();
    public static SoapDate Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDateTime : object {
    public static string XsdType { get; }
    private static SoapDateTime();
    public static string get_XsdType();
    public static string ToString(DateTime value);
    public static DateTime Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public SoapDay(DateTime value);
    private static SoapDay();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public virtual string ToString();
    public static SoapDay Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDuration : object {
    public static string XsdType { get; }
    public static string get_XsdType();
    [SecuritySafeCriticalAttribute]
public static string ToString(TimeSpan timeSpan);
    public static TimeSpan Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapEntities(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapEntities Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapEntity(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapEntity Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary : object {
    public static string XsdType { get; }
    public Byte[] Value { get; public set; }
    public SoapHexBinary(Byte[] value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    public virtual string ToString();
    public static SoapHexBinary Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapId(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapId Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapIdref(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapIdref Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapIdrefs(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapIdrefs Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger : object {
    public static string XsdType { get; }
    public decimal Value { get; public set; }
    public SoapInteger(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public decimal get_Value();
    public void set_Value(decimal value);
    public virtual string ToString();
    public static SoapInteger Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapLanguage(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapLanguage Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public SoapMonth(DateTime value);
    private static SoapMonth();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public virtual string ToString();
    public static SoapMonth Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public SoapMonthDay(DateTime value);
    private static SoapMonthDay();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public virtual string ToString();
    public static SoapMonthDay Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapName(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapName Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapNcName(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapNcName Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger : object {
    public static string XsdType { get; }
    public decimal Value { get; public set; }
    public SoapNegativeInteger(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public decimal get_Value();
    public void set_Value(decimal value);
    public virtual string ToString();
    public static SoapNegativeInteger Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapNmtoken(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapNmtoken Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapNmtokens(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapNmtokens Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger : object {
    public static string XsdType { get; }
    public decimal Value { get; public set; }
    public SoapNonNegativeInteger(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public decimal get_Value();
    public void set_Value(decimal value);
    public virtual string ToString();
    public static SoapNonNegativeInteger Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger : object {
    public static string XsdType { get; }
    public decimal Value { get; public set; }
    public SoapNonPositiveInteger(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public decimal get_Value();
    public void set_Value(decimal value);
    public virtual string ToString();
    public static SoapNonPositiveInteger Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapNormalizedString(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapNormalizedString Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapNotation(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapNotation Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger : object {
    public static string XsdType { get; }
    public decimal Value { get; public set; }
    public SoapPositiveInteger(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public decimal get_Value();
    public void set_Value(decimal value);
    public virtual string ToString();
    public static SoapPositiveInteger Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName : object {
    public static string XsdType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public string Key { get; public set; }
    public SoapQName(string value);
    public SoapQName(string key, string name);
    public SoapQName(string key, string name, string namespaceValue);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Key();
    public void set_Key(string value);
    public virtual string ToString();
    public static SoapQName Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public SoapTime(DateTime value);
    private static SoapTime();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public virtual string ToString();
    public static SoapTime Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken : object {
    public static string XsdType { get; }
    public string Value { get; public set; }
    public SoapToken(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public string get_Value();
    public void set_Value(string value);
    public virtual string ToString();
    public static SoapToken Parse(string value);
}
internal static class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapType : object {
    internal static Type typeofSoapTime;
    internal static Type typeofSoapDate;
    internal static Type typeofSoapYearMonth;
    internal static Type typeofSoapYear;
    internal static Type typeofSoapMonthDay;
    internal static Type typeofSoapDay;
    internal static Type typeofSoapMonth;
    internal static Type typeofSoapHexBinary;
    internal static Type typeofSoapBase64Binary;
    internal static Type typeofSoapInteger;
    internal static Type typeofSoapPositiveInteger;
    internal static Type typeofSoapNonPositiveInteger;
    internal static Type typeofSoapNonNegativeInteger;
    internal static Type typeofSoapNegativeInteger;
    internal static Type typeofSoapAnyUri;
    internal static Type typeofSoapQName;
    internal static Type typeofSoapNotation;
    internal static Type typeofSoapNormalizedString;
    internal static Type typeofSoapToken;
    internal static Type typeofSoapLanguage;
    internal static Type typeofSoapName;
    internal static Type typeofSoapIdrefs;
    internal static Type typeofSoapEntities;
    internal static Type typeofSoapNmtoken;
    internal static Type typeofSoapNmtokens;
    internal static Type typeofSoapNcName;
    internal static Type typeofSoapId;
    internal static Type typeofSoapIdref;
    internal static Type typeofSoapEntity;
    internal static Type typeofISoapXsd;
    private static SoapType();
    internal static string FilterBin64(string value);
    internal static string LineFeedsBin64(string value);
    internal static string Escape(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public int Sign { get; public set; }
    public SoapYear(DateTime value);
    public SoapYear(DateTime value, int sign);
    private static SoapYear();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public int get_Sign();
    public void set_Sign(int value);
    public virtual string ToString();
    public static SoapYear Parse(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth : object {
    public static string XsdType { get; }
    public DateTime Value { get; public set; }
    public int Sign { get; public set; }
    public SoapYearMonth(DateTime value);
    public SoapYearMonth(DateTime value, int sign);
    private static SoapYearMonth();
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public int get_Sign();
    public void set_Sign(int value);
    public virtual string ToString();
    public static SoapYearMonth Parse(string value);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Metadata.XmlFieldOrderOption : Enum {
    public int value__;
    public static XmlFieldOrderOption All;
    public static XmlFieldOrderOption Sequence;
    public static XmlFieldOrderOption Choice;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    public ObjectHandle(object o);
    public sealed virtual object Unwrap();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ObjRef : object {
    internal static int FLG_MARSHALED_OBJECT;
    internal static int FLG_WELLKNOWN_OBJREF;
    internal static int FLG_LITE_OBJREF;
    internal static int FLG_PROXY_ATTRIBUTE;
    internal string uri;
    internal IRemotingTypeInfo typeInfo;
    internal IEnvoyInfo envoyInfo;
    internal IChannelInfo channelInfo;
    internal int objrefFlags;
    internal GCHandle srvIdentity;
    internal int domainID;
    public string URI { get; public set; }
    public IRemotingTypeInfo TypeInfo { get; public set; }
    public IEnvoyInfo EnvoyInfo { get; public set; }
    public IChannelInfo ChannelInfo { get; public set; }
    [SecurityCriticalAttribute]
public ObjRef(MarshalByRefObject o, Type requestedType);
    [SecurityCriticalAttribute]
protected ObjRef(SerializationInfo info, StreamingContext context);
    private static ObjRef();
    internal void SetServerIdentity(GCHandle hndSrvIdentity);
    internal GCHandle GetServerIdentity();
    internal void SetDomainID(int id);
    internal int GetDomainID();
    [SecurityCriticalAttribute]
internal bool CanSmuggle();
    [SecurityCriticalAttribute]
internal ObjRef CreateSmuggleableCopy();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_URI();
    public virtual void set_URI(string value);
    public virtual IRemotingTypeInfo get_TypeInfo();
    public virtual void set_TypeInfo(IRemotingTypeInfo value);
    public virtual IEnvoyInfo get_EnvoyInfo();
    public virtual void set_EnvoyInfo(IEnvoyInfo value);
    [ReliabilityContractAttribute("3", "2")]
public virtual IChannelInfo get_ChannelInfo();
    public virtual void set_ChannelInfo(IChannelInfo value);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
internal object GetRealObjectHelper();
    internal bool IsMarshaledObject();
    internal void SetMarshaledObject();
    [ReliabilityContractAttribute("3", "2")]
internal bool IsWellKnown();
    internal void SetWellKnown();
    internal bool HasProxyAttribute();
    internal void SetHasProxyAttribute();
    internal bool IsObjRefLite();
    internal void SetObjRefLite();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public bool IsFromThisProcess();
    [SecurityCriticalAttribute]
public bool IsFromThisAppDomain();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal int GetServerDomainId();
    [SecurityCriticalAttribute]
internal IntPtr GetServerContext(Int32& domainId);
    [SecurityCriticalAttribute]
internal void Init(object o, Identity idObj, RuntimeType requestedType);
    internal static bool ShouldUseUrlObjRef();
    [SecurityCriticalAttribute]
internal static bool IsWellFormed(ObjRef objectRef);
}
internal class System.Runtime.Remoting.Proxies.__TransparentProxy : object {
}
internal class System.Runtime.Remoting.Proxies.AgileAsyncWorkerItem : object {
    [SecurityCriticalAttribute]
public AgileAsyncWorkerItem(IMethodCallMessage message, AsyncResult ar, object target);
    [SecurityCriticalAttribute]
public static void ThreadPoolCallBack(object o);
    [SecurityCriticalAttribute]
public void DoAsyncCall();
}
internal enum System.Runtime.Remoting.Proxies.CallType : Enum {
    public int value__;
    public static CallType InvalidCall;
    public static CallType MethodCall;
    public static CallType ConstructorCall;
}
internal class System.Runtime.Remoting.Proxies.MessageData : ValueType {
    internal IntPtr pFrame;
    internal IntPtr pMethodDesc;
    internal IntPtr pDelegateMD;
    internal IntPtr pSig;
    internal IntPtr thGoverningType;
    internal int iFlags;
}
[SecurityCriticalAttribute]
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Proxies.ProxyAttribute : Attribute {
    [SecurityCriticalAttribute]
public virtual MarshalByRefObject CreateInstance(Type serverType);
    internal MarshalByRefObject CreateInstanceInternal(RuntimeType serverType);
    [SecurityCriticalAttribute]
public virtual RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public sealed virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public sealed virtual void GetPropertiesForNewContext(IConstructionCallMessage msg);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Proxies.RealProxy : object {
    internal GCHandle _srvIdentity;
    internal int _optFlags;
    internal int _domainID;
    internal bool Initialized { get; internal set; }
    internal MarshalByRefObject UnwrappedServerObject { get; }
    internal Identity IdentityObject { get; internal set; }
    [SecuritySafeCriticalAttribute]
private static RealProxy();
    [SecurityCriticalAttribute]
protected RealProxy(Type classToProxy);
    [SecurityCriticalAttribute]
protected RealProxy(Type classToProxy, IntPtr stub, object stubData);
    internal bool IsRemotingProxy();
    internal bool get_Initialized();
    internal void set_Initialized(bool value);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
protected MarshalByRefObject GetUnwrappedServer();
    [SecurityCriticalAttribute]
protected MarshalByRefObject DetachServer();
    [SecurityCriticalAttribute]
protected void AttachServer(MarshalByRefObject s);
    [SecurityCriticalAttribute]
internal bool DoContextsMatch();
    [SecurityCriticalAttribute]
internal void AttachServerHelper(MarshalByRefObject s);
    [SecurityCriticalAttribute]
public static void SetStubData(RealProxy rp, object stubData);
    internal void SetSrvInfo(GCHandle srvIdentity, int domainID);
    [SecurityCriticalAttribute]
public static object GetStubData(RealProxy rp);
    [SecurityCriticalAttribute]
public Type GetProxiedType();
    public abstract virtual IMessage Invoke(IMessage msg);
    [SecurityCriticalAttribute]
public virtual ObjRef CreateObjRef(Type requestedType);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal static void PropagateOutParameters(IMessage msg, Object[] outArgs, object returnValue);
    [SecurityCriticalAttribute]
internal static IMessage EndInvokeHelper(Message reqMsg, bool bProxyCase);
    [SecurityCriticalAttribute]
public virtual IntPtr GetCOMIUnknown(bool fIsMarshalled);
    public virtual void SetCOMIUnknown(IntPtr i);
    public virtual IntPtr SupportsInterface(Guid& iid);
    public virtual object GetTransparentProxy();
    internal MarshalByRefObject get_UnwrappedServerObject();
    [ReliabilityContractAttribute("3", "2")]
internal virtual Identity get_IdentityObject();
    internal virtual void set_IdentityObject(Identity value);
    [SecurityCriticalAttribute]
internal virtual void Wrap();
}
[FlagsAttribute]
internal enum System.Runtime.Remoting.Proxies.RealProxyFlags : Enum {
    public int value__;
    public static RealProxyFlags None;
    public static RealProxyFlags RemotingProxy;
    public static RealProxyFlags Initialized;
}
[SecurityCriticalAttribute]
internal class System.Runtime.Remoting.Proxies.RemotingProxy : RealProxy {
    internal int CtorThread { get; internal set; }
    internal ConstructorCallMessage ConstructorMessage { get; internal set; }
    public string TypeName { get; public set; }
    public RemotingProxy(Type serverType);
    private static RemotingProxy();
    internal int get_CtorThread();
    internal void set_CtorThread(int value);
    internal static IMessage CallProcessMessage(IMessageSink ms, IMessage reqMsg, ArrayWithSize proxySinks, Thread currentThread, Context currentContext, bool bSkippingContextChain);
    [SecurityCriticalAttribute]
public virtual IMessage Invoke(IMessage reqMsg);
    internal virtual IMessage InternalInvoke(IMethodCallMessage reqMcmMsg, bool useDispatchMessage, int callType);
    internal void InternalInvokeAsync(IMessageSink ar, Message reqMsg, bool useDispatchMessage, int callType);
    internal ConstructorCallMessage get_ConstructorMessage();
    internal void set_ConstructorMessage(ConstructorCallMessage value);
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual void set_TypeName(string value);
    [SecurityCriticalAttribute]
public virtual IntPtr GetCOMIUnknown(bool fIsBeingMarshalled);
    [SecurityCriticalAttribute]
public virtual void SetCOMIUnknown(IntPtr i);
    [SecurityCriticalAttribute]
public sealed virtual bool CanCastTo(Type castType, object o);
}
internal class System.Runtime.Remoting.RedirectionProxy : MarshalByRefObject {
    unknown WellKnownObjectMode ObjectMode {public set; }
    public IMessageSink NextSink { get; }
    [SecurityCriticalAttribute]
internal RedirectionProxy(MarshalByRefObject proxy, Type serverType);
    public void set_ObjectMode(WellKnownObjectMode value);
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.RemoteAppEntry : object {
    internal RemoteAppEntry(string appName, string appURI);
    internal string GetAppURI();
}
internal static class System.Runtime.Remoting.RemotingConfigHandler : object {
    public static RemotingConfigInfo Info;
    internal static string ApplicationName { get; internal set; }
    internal static bool UrlObjRefMode { get; }
    internal static CustomErrorsModes CustomErrorsMode { get; internal set; }
    private static RemotingConfigHandler();
    internal static string get_ApplicationName();
    internal static void set_ApplicationName(string value);
    internal static bool HasApplicationNameBeenSet();
    internal static bool get_UrlObjRefMode();
    internal static CustomErrorsModes get_CustomErrorsMode();
    internal static void set_CustomErrorsMode(CustomErrorsModes value);
    [SecurityCriticalAttribute]
internal static IMessageSink FindDelayLoadChannelForCreateMessageSink(string url, object data, String& objectURI);
    [SecurityCriticalAttribute]
internal static void DoConfiguration(string filename, bool ensureSecurity);
    [SecurityCriticalAttribute]
internal static IChannel CreateChannelFromConfigEntry(ChannelEntry entry);
    [SecurityCriticalAttribute]
internal static ActivatedClientTypeEntry IsRemotelyActivatedClientType(RuntimeType svrType);
    internal static ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName);
    [SecurityCriticalAttribute]
internal static WellKnownClientTypeEntry IsWellKnownClientType(RuntimeType svrType);
    internal static WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName);
    internal static void ParseType(string typeAssem, String& typeName, String& assemName);
    [SecurityCriticalAttribute]
internal static bool IsActivationAllowed(RuntimeType svrType);
    [SecurityCriticalAttribute]
internal static bool IsActivationAllowed(string TypeName);
    internal static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry);
    [SecurityCriticalAttribute]
internal static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry);
    internal static void RegisterActivatedClientType(ActivatedClientTypeEntry entry);
    internal static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry);
    [SecurityCriticalAttribute]
internal static Type GetServerTypeForUri(string URI);
    internal static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes();
    internal static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes();
    internal static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes();
    internal static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes();
    [SecurityCriticalAttribute]
internal static ServerIdentity CreateWellKnownObject(string uri);
}
[ComVisibleAttribute("True")]
public static class System.Runtime.Remoting.RemotingConfiguration : object {
    public static string ApplicationName { get; public set; }
    public static string ApplicationId { get; }
    public static string ProcessId { get; }
    public static CustomErrorsModes CustomErrorsMode { get; public set; }
    private static RemotingConfiguration();
    [ObsoleteAttribute("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", "False")]
[SecuritySafeCriticalAttribute]
public static void Configure(string filename);
    [SecuritySafeCriticalAttribute]
public static void Configure(string filename, bool ensureSecurity);
    public static string get_ApplicationName();
    [SecuritySafeCriticalAttribute]
public static void set_ApplicationName(string value);
    [SecurityCriticalAttribute]
public static string get_ApplicationId();
    [SecurityCriticalAttribute]
public static string get_ProcessId();
    public static CustomErrorsModes get_CustomErrorsMode();
    [SecuritySafeCriticalAttribute]
public static void set_CustomErrorsMode(CustomErrorsModes value);
    public static bool CustomErrorsEnabled(bool isLocalRequest);
    [SecuritySafeCriticalAttribute]
public static void RegisterActivatedServiceType(Type type);
    [SecuritySafeCriticalAttribute]
public static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry);
    [SecuritySafeCriticalAttribute]
public static void RegisterWellKnownServiceType(Type type, string objectUri, WellKnownObjectMode mode);
    [SecuritySafeCriticalAttribute]
public static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry);
    [SecuritySafeCriticalAttribute]
public static void RegisterActivatedClientType(Type type, string appUrl);
    [SecuritySafeCriticalAttribute]
public static void RegisterActivatedClientType(ActivatedClientTypeEntry entry);
    [SecuritySafeCriticalAttribute]
public static void RegisterWellKnownClientType(Type type, string objectUrl);
    [SecuritySafeCriticalAttribute]
public static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry);
    [SecuritySafeCriticalAttribute]
public static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes();
    [SecuritySafeCriticalAttribute]
public static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes();
    [SecuritySafeCriticalAttribute]
public static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes();
    [SecuritySafeCriticalAttribute]
public static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes();
    [SecuritySafeCriticalAttribute]
public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType);
    [SecuritySafeCriticalAttribute]
public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName);
    [SecuritySafeCriticalAttribute]
public static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType);
    [SecuritySafeCriticalAttribute]
public static WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName);
    [SecuritySafeCriticalAttribute]
public static bool IsActivationAllowed(Type svrType);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.RemotingException : SystemException {
    public RemotingException(string message);
    public RemotingException(string message, Exception InnerException);
    protected RemotingException(SerializationInfo info, StreamingContext context);
    private static RemotingException();
}
[ComVisibleAttribute("True")]
public static class System.Runtime.Remoting.RemotingServices : object {
    private static RemotingServices();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static bool IsTransparentProxy(object proxy);
    [SecuritySafeCriticalAttribute]
public static bool IsObjectOutOfContext(object tp);
    public static bool IsObjectOutOfAppDomain(object tp);
    internal static bool IsClientProxy(object obj);
    [SecurityCriticalAttribute]
internal static bool IsObjectOutOfProcess(object tp);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public static RealProxy GetRealProxy(object proxy);
    [SecurityCriticalAttribute]
internal static object CreateTransparentProxy(RealProxy rp, RuntimeType typeToProxy, IntPtr stub, object stubData);
    [SecurityCriticalAttribute]
internal static object CreateTransparentProxy(RealProxy rp, Type typeToProxy, IntPtr stub, object stubData);
    [SecurityCriticalAttribute]
internal static MarshalByRefObject AllocateUninitializedObject(RuntimeType objectType);
    [SecurityCriticalAttribute]
internal static void CallDefaultCtor(object o);
    [SecurityCriticalAttribute]
internal static MarshalByRefObject AllocateUninitializedObject(Type objectType);
    [SecurityCriticalAttribute]
internal static MarshalByRefObject AllocateInitializedObject(RuntimeType objectType);
    [SecurityCriticalAttribute]
internal static MarshalByRefObject AllocateInitializedObject(Type objectType);
    [SecurityCriticalAttribute]
internal static bool RegisterWellKnownChannels();
    [SecurityCriticalAttribute]
internal static void InternalSetRemoteActivationConfigured();
    [SecurityCriticalAttribute]
public static string GetSessionIdForMethodMessage(IMethodMessage msg);
    [SecuritySafeCriticalAttribute]
public static object GetLifetimeService(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
public static string GetObjectUri(MarshalByRefObject obj);
    [SecuritySafeCriticalAttribute]
public static void SetObjectUriForMarshal(MarshalByRefObject obj, string uri);
    [SecuritySafeCriticalAttribute]
public static ObjRef Marshal(MarshalByRefObject Obj);
    [SecuritySafeCriticalAttribute]
public static ObjRef Marshal(MarshalByRefObject Obj, string URI);
    [SecuritySafeCriticalAttribute]
public static ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    [SecurityCriticalAttribute]
internal static ObjRef MarshalInternal(MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    [SecurityCriticalAttribute]
internal static ObjRef MarshalInternal(MarshalByRefObject Obj, string ObjURI, Type RequestedType, Enum wkoMode);
    [SecurityCriticalAttribute]
internal static ObjRef MarshalInternal(MarshalByRefObject Obj, string ObjURI, Type RequestedType, bool updateChannelData);
    [SecurityCriticalAttribute]
internal static ObjRef MarshalInternal(MarshalByRefObject Obj, string ObjURI, Type RequestedType, bool updateChannelData, Enum wkoMode);
    [SecurityCriticalAttribute]
public static void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public static object Unmarshal(ObjRef objectRef);
    [SecurityCriticalAttribute]
public static object Unmarshal(ObjRef objectRef, bool fRefine);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public static object Connect(Type classToProxy, string url);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public static object Connect(Type classToProxy, string url, object data);
    [SecurityCriticalAttribute]
public static bool Disconnect(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static bool Disconnect(MarshalByRefObject obj, bool bResetURI);
    [SecurityCriticalAttribute]
public static IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
public static ObjRef GetObjRefForProxy(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static object Unmarshal(Type classToProxy, string url);
    [SecurityCriticalAttribute]
internal static object Unmarshal(Type classToProxy, string url, object data);
    [SecurityCriticalAttribute]
internal static object Wrap(ContextBoundObject obj);
    [SecurityCriticalAttribute]
internal static object Wrap(ContextBoundObject obj, object proxy, bool fCreateSinks);
    internal static string GetObjectUriFromFullUri(string fullUri);
    [SecurityCriticalAttribute]
internal static object Unwrap(ContextBoundObject obj);
    [SecurityCriticalAttribute]
internal static object AlwaysUnwrap(ContextBoundObject obj);
    [SecurityCriticalAttribute]
internal static object InternalUnmarshal(ObjRef objectRef, object proxy, bool fRefine);
    [SecurityCriticalAttribute]
internal static void CreateEnvoyAndChannelSinks(MarshalByRefObject tpOrObject, ObjRef objectRef, IMessageSink& chnlSink, IMessageSink& envoySink);
    [SecurityCriticalAttribute]
internal static string CreateEnvoyAndChannelSinks(string url, object data, IMessageSink& chnlSink, IMessageSink& envoySink);
    internal static void SetEnvoyAndChannelSinks(Identity idObj, IMessageSink chnlSink, IMessageSink envoySink);
    [SecurityCriticalAttribute]
internal static bool ProxyCheckCast(RealProxy rp, RuntimeType castType);
    [SecurityCriticalAttribute]
internal static object CheckCast(object objToExpand, RuntimeType type);
    [SecurityCriticalAttribute]
internal static GCHandle CreateDelegateInvocation(WaitCallback waitDelegate, object state);
    [SecurityCriticalAttribute]
internal static void DisposeDelegateInvocation(GCHandle delegateCallToken);
    [SecurityCriticalAttribute]
internal static object CreateProxyForDomain(int appDomainId, IntPtr defCtxID);
    [SecurityCriticalAttribute]
internal static object CreateDataForDomainCallback(Object[] args);
    [SecurityCriticalAttribute]
internal static ObjRef CreateDataForDomain(int appDomainId, IntPtr defCtxID);
    [SecurityCriticalAttribute]
public static MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg);
    [SecurityCriticalAttribute]
internal static MethodBase InternalGetMethodBaseFromMethodMessage(IMethodMessage msg);
    [SecurityCriticalAttribute]
public static bool IsMethodOverloaded(IMethodMessage msg);
    [SecurityCriticalAttribute]
internal static bool IsMethodAllowedRemotely(MethodBase method);
    [SecurityCriticalAttribute]
public static bool IsOneWay(MethodBase method);
    internal static bool FindAsyncMethodVersion(MethodInfo method, MethodInfo& beginMethod, MethodInfo& endMethod);
    [SecurityCriticalAttribute]
public static Type GetServerTypeForUri(string URI);
    [SecurityCriticalAttribute]
internal static void DomainUnloaded(int domainID);
    [SecurityCriticalAttribute]
internal static IntPtr GetServerContextForProxy(object tp);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static int GetServerDomainIdForProxy(object tp);
    [SecurityCriticalAttribute]
internal static void GetServerContextAndDomainIdForProxy(object tp, IntPtr& contextId, Int32& domainId);
    [SecurityCriticalAttribute]
internal static Context GetServerContext(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
internal static Byte[] MarshalToBuffer(object o, bool crossRuntime);
    [SecurityCriticalAttribute]
internal static object UnmarshalFromBuffer(Byte[] b, bool crossRuntime);
    internal static object UnmarshalReturnMessageFromBuffer(Byte[] b, IMethodCallMessage msg);
    [SecurityCriticalAttribute]
public static IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg);
    [SecurityCriticalAttribute]
internal static string DetermineDefaultQualifiedTypeName(Type type);
    [SecurityCriticalAttribute]
internal static string GetDefaultQualifiedTypeName(RuntimeType type);
    internal static string InternalGetClrTypeNameFromQualifiedTypeName(string qualifiedTypeName);
    [SecurityCriticalAttribute]
internal static string InternalGetSoapTypeNameFromQualifiedTypeName(string xmlTypeName, string xmlTypeNamespace);
    [SecurityCriticalAttribute]
internal static string InternalGetTypeNameFromQualifiedTypeName(string qualifiedTypeName);
    [SecurityCriticalAttribute]
internal static RuntimeType InternalGetTypeFromQualifiedTypeName(string qualifiedTypeName, bool partialFallback);
    [SecurityCriticalAttribute]
internal static Type InternalGetTypeFromQualifiedTypeName(string qualifiedTypeName);
    [SecurityCriticalAttribute]
internal static bool CORProfilerTrackRemoting();
    [SecurityCriticalAttribute]
internal static bool CORProfilerTrackRemotingCookie();
    [SecurityCriticalAttribute]
internal static bool CORProfilerTrackRemotingAsync();
    [SecurityCriticalAttribute]
internal static void CORProfilerRemotingClientSendingMessage(Guid& id, bool fIsAsync);
    [SecurityCriticalAttribute]
internal static void CORProfilerRemotingClientReceivingReply(Guid id, bool fIsAsync);
    [SecurityCriticalAttribute]
internal static void CORProfilerRemotingServerReceivingMessage(Guid id, bool fIsAsync);
    [SecurityCriticalAttribute]
internal static void CORProfilerRemotingServerSendingReply(Guid& id, bool fIsAsync);
    [SecurityCriticalAttribute]
[ConditionalAttribute("REMOTING_PERF")]
[ObsoleteAttribute("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")]
public static void LogRemotingStage(int stage);
    [SecurityCriticalAttribute]
internal static void ResetInterfaceCache(object proxy);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.RemotingTimeoutException : RemotingException {
    public RemotingTimeoutException(string message);
    public RemotingTimeoutException(string message, Exception InnerException);
    internal RemotingTimeoutException(SerializationInfo info, StreamingContext context);
    private static RemotingTimeoutException();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ServerException : SystemException {
    public ServerException(string message);
    public ServerException(string message, Exception InnerException);
    internal ServerException(SerializationInfo info, StreamingContext context);
    private static ServerException();
}
internal class System.Runtime.Remoting.ServerIdentity : Identity {
    internal Context _srvCtx;
    internal IMessageSink _serverObjectChain;
    internal StackBuilderSink _stackBuilderSink;
    internal DynamicPropertyHolder _dphSrv;
    internal Type _srvType;
    internal bool _bMarshaledAsSpecificType;
    internal int _firstCallDispatched;
    internal GCHandle _srvIdentityHandle;
    internal Context ServerContext { get; }
    internal Type ServerType { get; internal set; }
    internal bool MarshaledAsSpecificType { get; internal set; }
    internal ArrayWithSize ServerSideDynamicSinks { get; }
    [SecurityCriticalAttribute]
internal ServerIdentity(MarshalByRefObject obj, Context serverCtx);
    [SecurityCriticalAttribute]
internal ServerIdentity(MarshalByRefObject obj, Context serverCtx, string uri);
    internal Type GetLastCalledType(string newTypeName);
    internal void SetLastCalledType(string newTypeName, Type newType);
    [SecurityCriticalAttribute]
internal void SetHandle();
    [SecurityCriticalAttribute]
internal void ResetHandle();
    internal GCHandle GetHandle();
    [ReliabilityContractAttribute("3", "2")]
internal Context get_ServerContext();
    internal void SetSingleCallObjectMode();
    internal void SetSingletonObjectMode();
    internal bool IsSingleCall();
    internal bool IsSingleton();
    [SecurityCriticalAttribute]
internal IMessageSink GetServerObjectChain(MarshalByRefObject& obj);
    internal Type get_ServerType();
    internal void set_ServerType(Type value);
    internal bool get_MarshaledAsSpecificType();
    internal void set_MarshaledAsSpecificType(bool value);
    [SecurityCriticalAttribute]
internal IMessageSink RaceSetServerObjectChain(IMessageSink serverObjectChain);
    [SecurityCriticalAttribute]
internal bool AddServerSideDynamicProperty(IDynamicProperty prop);
    [SecurityCriticalAttribute]
internal bool RemoveServerSideDynamicProperty(string name);
    [SecurityCriticalAttribute]
internal ArrayWithSize get_ServerSideDynamicSinks();
    [SecurityCriticalAttribute]
internal virtual void AssertValid();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Services.EnterpriseServicesHelper : object {
    [SecurityCriticalAttribute]
public static object WrapIUnknownWithComObject(IntPtr punk);
    [ComVisibleAttribute("True")]
public static IConstructionReturnMessage CreateConstructionReturnMessage(IConstructionCallMessage ctorMsg, MarshalByRefObject retObj);
    [SecurityCriticalAttribute]
public static void SwitchWrappers(RealProxy oldcp, RealProxy newcp);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Services.ITrackingHandler {
    [SecurityCriticalAttribute]
public abstract virtual void MarshaledObject(object obj, ObjRef or);
    [SecurityCriticalAttribute]
public abstract virtual void UnmarshaledObject(object obj, ObjRef or);
    [SecurityCriticalAttribute]
public abstract virtual void DisconnectedObject(object obj);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Services.TrackingServices : object {
    public static ITrackingHandler[] RegisteredHandlers { get; }
    private static TrackingServices();
    [SecurityCriticalAttribute]
public static void RegisterTrackingHandler(ITrackingHandler handler);
    [SecurityCriticalAttribute]
public static void UnregisterTrackingHandler(ITrackingHandler handler);
    [SecurityCriticalAttribute]
public static ITrackingHandler[] get_RegisteredHandlers();
    [SecurityCriticalAttribute]
internal static void MarshaledObject(object obj, ObjRef or);
    [SecurityCriticalAttribute]
internal static void UnmarshaledObject(object obj, ObjRef or);
    [SecurityCriticalAttribute]
internal static void DisconnectedObject(object obj);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.SoapServices : object {
    internal static string startNS;
    internal static string assemblyNS;
    internal static string namespaceNS;
    internal static string fullNS;
    public static string XmlNsForClrType { get; }
    public static string XmlNsForClrTypeWithAssembly { get; }
    public static string XmlNsForClrTypeWithNs { get; }
    public static string XmlNsForClrTypeWithNsAndAssembly { get; }
    private static SoapServices();
    [SecurityCriticalAttribute]
public static void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type);
    [SecurityCriticalAttribute]
public static void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type);
    [SecurityCriticalAttribute]
public static void PreLoad(Type type);
    [SecurityCriticalAttribute]
public static void PreLoad(Assembly assembly);
    [SecurityCriticalAttribute]
public static Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace);
    [SecurityCriticalAttribute]
public static Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace);
    public static void GetInteropFieldTypeAndNameFromXmlElement(Type containingType, string xmlElement, string xmlNamespace, Type& type, String& name);
    public static void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType, string xmlAttribute, string xmlNamespace, Type& type, String& name);
    [SecurityCriticalAttribute]
public static bool GetXmlElementForInteropType(Type type, String& xmlElement, String& xmlNamespace);
    [SecurityCriticalAttribute]
public static bool GetXmlTypeForInteropType(Type type, String& xmlType, String& xmlTypeNamespace);
    [SecurityCriticalAttribute]
public static string GetXmlNamespaceForMethodCall(MethodBase mb);
    [SecurityCriticalAttribute]
public static string GetXmlNamespaceForMethodResponse(MethodBase mb);
    [SecurityCriticalAttribute]
public static void RegisterSoapActionForMethodBase(MethodBase mb);
    public static void RegisterSoapActionForMethodBase(MethodBase mb, string soapAction);
    [SecurityCriticalAttribute]
public static string GetSoapActionFromMethodBase(MethodBase mb);
    [SecurityCriticalAttribute]
public static bool IsSoapActionValidForMethodBase(string soapAction, MethodBase mb);
    public static bool GetTypeAndMethodNameFromSoapAction(string soapAction, String& typeName, String& methodName);
    public static string get_XmlNsForClrType();
    public static string get_XmlNsForClrTypeWithAssembly();
    public static string get_XmlNsForClrTypeWithNs();
    public static string get_XmlNsForClrTypeWithNsAndAssembly();
    public static bool IsClrTypeNamespace(string namespaceString);
    [SecurityCriticalAttribute]
public static string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
    [SecurityCriticalAttribute]
public static bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, String& typeNamespace, String& assemblyName);
    internal static void UriEncode(string value, StringBuilder sb);
    internal static string UriDecode(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.TypeEntry : object {
    public string TypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    internal void CacheRemoteAppEntry(RemoteAppEntry entry);
    internal RemoteAppEntry GetRemoteAppEntry();
}
internal class System.Runtime.Remoting.TypeInfo : object {
    public string TypeName { get; public set; }
    internal string ServerType { get; internal set; }
    [SecurityCriticalAttribute]
internal TypeInfo(RuntimeType typeOfObj);
    [SecurityCriticalAttribute]
public virtual string get_TypeName();
    [SecurityCriticalAttribute]
public virtual void set_TypeName(string value);
    [SecurityCriticalAttribute]
public virtual bool CanCastTo(Type castType, object o);
    [SecurityCriticalAttribute]
internal static string GetQualifiedTypeName(RuntimeType type);
    internal static bool ParseTypeAndAssembly(string typeAndAssembly, String& typeName, String& assemName);
    internal string get_ServerType();
    internal void set_ServerType(string value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.WellKnownClientTypeEntry : TypeEntry {
    public string ObjectUrl { get; }
    public Type ObjectType { get; }
    public string ApplicationUrl { get; public set; }
    public WellKnownClientTypeEntry(string typeName, string assemblyName, string objectUrl);
    public WellKnownClientTypeEntry(Type type, string objectUrl);
    public string get_ObjectUrl();
    public Type get_ObjectType();
    public string get_ApplicationUrl();
    public void set_ApplicationUrl(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.WellKnownObjectMode : Enum {
    public int value__;
    public static WellKnownObjectMode Singleton;
    public static WellKnownObjectMode SingleCall;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.WellKnownServiceTypeEntry : TypeEntry {
    public string ObjectUri { get; }
    public WellKnownObjectMode Mode { get; }
    public Type ObjectType { get; }
    public IContextAttribute[] ContextAttributes { get; public set; }
    public WellKnownServiceTypeEntry(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode);
    public WellKnownServiceTypeEntry(Type type, string objectUri, WellKnownObjectMode mode);
    public string get_ObjectUri();
    public WellKnownObjectMode get_Mode();
    public Type get_ObjectType();
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public virtual string ToString();
}
internal static class System.Runtime.Remoting.XmlNamespaceEncoder : object {
    [SecurityCriticalAttribute]
internal static string GetXmlNamespaceForType(RuntimeType type, string dynamicUrl);
    [SecurityCriticalAttribute]
internal static string GetXmlNamespaceForTypeNamespace(RuntimeType type, string dynamicUrl);
    [SecurityCriticalAttribute]
internal static string GetTypeNameForSoapActionNamespace(string uri, Boolean& assemblyIncluded);
}
internal class System.Runtime.Serialization.DeserializationEventHandler : MulticastDelegate {
    public DeserializationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.FixupHolder : object {
    internal static int ArrayFixup;
    internal static int MemberFixup;
    internal static int DelayedFixup;
    internal long m_id;
    internal object m_fixupInfo;
    internal int m_fixupType;
    internal FixupHolder(long id, object fixupInfo, int fixupType);
}
internal class System.Runtime.Serialization.FixupHolderList : object {
    internal static int InitialSize;
    internal FixupHolder[] m_values;
    internal int m_count;
    internal FixupHolderList(int startingSize);
    internal virtual void Add(long id, object fixupInfo);
    internal virtual void Add(FixupHolder fixup);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Serialization.Formatter : object {
    protected ObjectIDGenerator m_idGenerator;
    protected Queue m_objectQueue;
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public abstract virtual object Deserialize(Stream serializationStream);
    protected virtual object GetNext(Int64& objID);
    protected virtual long Schedule(object obj);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
    protected abstract virtual void WriteArray(object obj, string name, Type memberType);
    protected abstract virtual void WriteBoolean(bool val, string name);
    protected abstract virtual void WriteByte(byte val, string name);
    protected abstract virtual void WriteChar(char val, string name);
    protected abstract virtual void WriteDateTime(DateTime val, string name);
    protected abstract virtual void WriteDecimal(decimal val, string name);
    protected abstract virtual void WriteDouble(double val, string name);
    protected abstract virtual void WriteInt16(short val, string name);
    protected abstract virtual void WriteInt32(int val, string name);
    protected abstract virtual void WriteInt64(long val, string name);
    protected abstract virtual void WriteObjectRef(object obj, string name, Type memberType);
    protected virtual void WriteMember(string memberName, object data);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteSByte(sbyte val, string name);
    protected abstract virtual void WriteSingle(float val, string name);
    protected abstract virtual void WriteTimeSpan(TimeSpan val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt16(ushort val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt32(UInt32 val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt64(ulong val, string name);
    protected abstract virtual void WriteValueType(object obj, string name, Type memberType);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.FormatterConverter : object {
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual char ToChar(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual sbyte ToSByte(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual short ToInt16(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ushort ToUInt16(object value);
    public sealed virtual int ToInt32(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual long ToInt64(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ulong ToUInt64(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual string ToString(object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.__BinaryParser : object {
    internal ObjectReader objectReader;
    internal Stream input;
    internal long topId;
    internal long headerId;
    internal SizedArray objectMapIdTable;
    internal SizedArray assemIdToAssemblyTable;
    internal SerStack stack;
    internal BinaryTypeEnum expectedType;
    internal object expectedTypeInformation;
    internal ParseRecord PRS;
    internal BinaryObjectString objectString;
    internal BinaryCrossAppDomainString crossAppDomainString;
    internal MemberPrimitiveTyped memberPrimitiveTyped;
    internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
    internal MemberReference memberReference;
    internal ObjectNull objectNull;
    internal static MessageEnd modreq(System.Runtime.CompilerServices.IsVolatile) messageEnd;
    internal BinaryAssemblyInfo SystemAssemblyInfo { get; }
    internal SizedArray ObjectMapIdTable { get; }
    internal SizedArray AssemIdToAssemblyTable { get; }
    internal ParseRecord prs { get; }
    internal __BinaryParser(Stream stream, ObjectReader objectReader);
    private static __BinaryParser();
    internal BinaryAssemblyInfo get_SystemAssemblyInfo();
    internal SizedArray get_ObjectMapIdTable();
    internal SizedArray get_AssemIdToAssemblyTable();
    internal ParseRecord get_prs();
    [SecurityCriticalAttribute]
internal void Run();
    internal void ReadBegin();
    internal void ReadEnd();
    internal bool ReadBoolean();
    internal byte ReadByte();
    internal Byte[] ReadBytes(int length);
    internal void ReadBytes(Byte[] byteA, int offset, int size);
    internal char ReadChar();
    internal Char[] ReadChars(int length);
    internal decimal ReadDecimal();
    internal float ReadSingle();
    internal double ReadDouble();
    internal short ReadInt16();
    internal int ReadInt32();
    internal long ReadInt64();
    internal sbyte ReadSByte();
    internal string ReadString();
    internal TimeSpan ReadTimeSpan();
    internal DateTime ReadDateTime();
    internal ushort ReadUInt16();
    internal UInt32 ReadUInt32();
    internal ulong ReadUInt64();
    [SecurityCriticalAttribute]
internal void ReadSerializationHeaderRecord();
    [SecurityCriticalAttribute]
internal void ReadAssembly(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
internal void ReadMethodObject(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
internal void ReadCrossAppDomainMap();
    [SecurityCriticalAttribute]
internal void ReadObjectWithMap(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
internal void ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum);
    internal object ReadValue(InternalPrimitiveTypeE code);
}
internal class System.Runtime.Serialization.Formatters.Binary.__BinaryWriter : object {
    internal Stream sout;
    internal FormatterTypeStyle formatterTypeStyle;
    internal Hashtable objectMapTable;
    internal ObjectWriter objectWriter;
    internal BinaryWriter dataWriter;
    internal int m_nestedObjectCount;
    internal BinaryMethodCall binaryMethodCall;
    internal BinaryMethodReturn binaryMethodReturn;
    internal BinaryObject binaryObject;
    internal BinaryObjectWithMap binaryObjectWithMap;
    internal BinaryObjectWithMapTyped binaryObjectWithMapTyped;
    internal BinaryObjectString binaryObjectString;
    internal BinaryCrossAppDomainString binaryCrossAppDomainString;
    internal BinaryArray binaryArray;
    internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
    internal MemberPrimitiveTyped memberPrimitiveTyped;
    internal ObjectNull objectNull;
    internal MemberReference memberReference;
    internal BinaryAssembly binaryAssembly;
    internal BinaryCrossAppDomainAssembly crossAppDomainAssembly;
    internal __BinaryWriter(Stream sout, ObjectWriter objectWriter, FormatterTypeStyle formatterTypeStyle);
    internal void WriteBegin();
    internal void WriteEnd();
    internal void WriteBoolean(bool value);
    internal void WriteByte(byte value);
    internal void WriteChar(char value);
    internal void WriteChars(Char[] value);
    internal void WriteDecimal(decimal value);
    internal void WriteSingle(float value);
    internal void WriteDouble(double value);
    internal void WriteInt16(short value);
    internal void WriteInt32(int value);
    internal void WriteInt64(long value);
    internal void WriteSByte(sbyte value);
    internal void WriteString(string value);
    internal void WriteTimeSpan(TimeSpan value);
    internal void WriteDateTime(DateTime value);
    internal void WriteUInt16(ushort value);
    internal void WriteUInt32(UInt32 value);
    internal void WriteUInt64(ulong value);
    internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo);
    internal void WriteSerializationHeaderEnd();
    internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion);
    internal void WriteMethodCall();
    internal Object[] WriteCallArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties);
    internal void WriteMethodReturn();
    internal Object[] WriteReturnArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties);
    internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, String[] memberNames, Type[] memberTypes, WriteObjectInfo[] memberObjectInfos);
    internal void WriteObjectString(int objectId, string value);
    [SecurityCriticalAttribute]
internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array);
    internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound);
    internal void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, Int32[] lengthA, Int32[] lowerBoundA);
    [SecurityCriticalAttribute]
internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Byte[] byteA);
    internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, object value);
    internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo);
    internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef);
    internal void WriteMemberNested(NameInfo memberNameInfo);
    internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, string value);
    internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, object value);
    internal void WriteNullItem(NameInfo itemNameInfo, NameInfo typeNameInfo);
    internal void WriteDelayedNullItem();
    internal void WriteItemEnd();
    internal void WriteItemObjectRef(NameInfo nameInfo, int idRef);
    internal void WriteAssembly(Type type, string assemblyString, int assemId, bool isNew);
    internal void WriteValue(InternalPrimitiveTypeE code, object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryArray : object {
    internal int objectId;
    internal int rank;
    internal Int32[] lengthA;
    internal Int32[] lowerBoundA;
    internal BinaryTypeEnum binaryTypeEnum;
    internal object typeInformation;
    internal int assemId;
    internal BinaryArrayTypeEnum binaryArrayTypeEnum;
    internal BinaryArray(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, int rank, Int32[] lengthA, Int32[] lowerBoundA, BinaryTypeEnum binaryTypeEnum, object typeInformation, BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum : Enum {
    public int value__;
    public static BinaryArrayTypeEnum Single;
    public static BinaryArrayTypeEnum Jagged;
    public static BinaryArrayTypeEnum Rectangular;
    public static BinaryArrayTypeEnum SingleOffset;
    public static BinaryArrayTypeEnum JaggedOffset;
    public static BinaryArrayTypeEnum RectangularOffset;
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryAssembly : object {
    internal int assemId;
    internal string assemblyString;
    internal void Set(int assemId, string assemblyString);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo : object {
    internal string assemblyString;
    internal BinaryAssemblyInfo(string assemblyString);
    internal BinaryAssemblyInfo(string assemblyString, Assembly assembly);
    internal Assembly GetAssembly();
}
internal static class System.Runtime.Serialization.Formatters.Binary.BinaryConverter : object {
    internal static BinaryTypeEnum GetBinaryTypeInfo(Type type, WriteObjectInfo objectInfo, string typeName, ObjectWriter objectWriter, Object& typeInformation, Int32& assemId);
    internal static BinaryTypeEnum GetParserBinaryTypeInfo(Type type, Object& typeInformation);
    internal static void WriteTypeInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, __BinaryWriter sout);
    internal static object ReadTypeInfo(BinaryTypeEnum binaryTypeEnum, __BinaryParser input, Int32& assemId);
    [SecurityCriticalAttribute]
internal static void TypeFromInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, ObjectReader objectReader, BinaryAssemblyInfo assemblyInfo, InternalPrimitiveTypeE& primitiveTypeEnum, String& typeString, Type& type, Boolean& isVariant);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainAssembly : object {
    internal int assemId;
    internal int assemblyIndex;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainMap : object {
    internal int crossAppDomainArrayIndex;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainString : object {
    internal int objectId;
    internal int value;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.Binary.BinaryFormatter : object {
    internal ISurrogateSelector m_surrogates;
    internal StreamingContext m_context;
    internal SerializationBinder m_binder;
    internal FormatterTypeStyle m_typeFormat;
    internal FormatterAssemblyStyle m_assemblyFormat;
    internal TypeFilterLevel m_securityLevel;
    internal Object[] m_crossAppDomainArray;
    public FormatterTypeStyle TypeFormat { get; public set; }
    public FormatterAssemblyStyle AssemblyFormat { get; public set; }
    public TypeFilterLevel FilterLevel { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public BinaryFormatter(ISurrogateSelector selector, StreamingContext context);
    private static BinaryFormatter();
    public FormatterTypeStyle get_TypeFormat();
    public void set_TypeFormat(FormatterTypeStyle value);
    public FormatterAssemblyStyle get_AssemblyFormat();
    public void set_AssemblyFormat(FormatterAssemblyStyle value);
    public TypeFilterLevel get_FilterLevel();
    public void set_FilterLevel(TypeFilterLevel value);
    public sealed virtual ISurrogateSelector get_SurrogateSelector();
    public sealed virtual void set_SurrogateSelector(ISurrogateSelector value);
    public sealed virtual SerializationBinder get_Binder();
    public sealed virtual void set_Binder(SerializationBinder value);
    public sealed virtual StreamingContext get_Context();
    public sealed virtual void set_Context(StreamingContext value);
    public sealed virtual object Deserialize(Stream serializationStream);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck);
    [SecuritySafeCriticalAttribute]
public sealed virtual object Deserialize(Stream serializationStream, HeaderHandler handler);
    [SecuritySafeCriticalAttribute]
public object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage);
    public sealed virtual void Serialize(Stream serializationStream, object graph);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Serialize(Stream serializationStream, object graph, Header[] headers);
    [SecurityCriticalAttribute]
internal void Serialize(Stream serializationStream, object graph, Header[] headers, bool fCheck);
    internal static TypeInformation GetTypeInformation(Type type);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum : Enum {
    public int value__;
    public static BinaryHeaderEnum SerializedStreamHeader;
    public static BinaryHeaderEnum Object;
    public static BinaryHeaderEnum ObjectWithMap;
    public static BinaryHeaderEnum ObjectWithMapAssemId;
    public static BinaryHeaderEnum ObjectWithMapTyped;
    public static BinaryHeaderEnum ObjectWithMapTypedAssemId;
    public static BinaryHeaderEnum ObjectString;
    public static BinaryHeaderEnum Array;
    public static BinaryHeaderEnum MemberPrimitiveTyped;
    public static BinaryHeaderEnum MemberReference;
    public static BinaryHeaderEnum ObjectNull;
    public static BinaryHeaderEnum MessageEnd;
    public static BinaryHeaderEnum Assembly;
    public static BinaryHeaderEnum ObjectNullMultiple256;
    public static BinaryHeaderEnum ObjectNullMultiple;
    public static BinaryHeaderEnum ArraySinglePrimitive;
    public static BinaryHeaderEnum ArraySingleObject;
    public static BinaryHeaderEnum ArraySingleString;
    public static BinaryHeaderEnum CrossAppDomainMap;
    public static BinaryHeaderEnum CrossAppDomainString;
    public static BinaryHeaderEnum CrossAppDomainAssembly;
    public static BinaryHeaderEnum MethodCall;
    public static BinaryHeaderEnum MethodReturn;
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodCall : object {
    internal Object[] WriteArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties);
    internal void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
internal void Read(__BinaryParser input);
    [SecurityCriticalAttribute]
internal IMethodCallMessage ReadArray(Object[] callA, object handlerObject);
    internal void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodCallMessage : object {
    public string MethodName { get; }
    public string TypeName { get; }
    public Type[] InstantiationArgs { get; }
    public object MethodSignature { get; }
    public Object[] Args { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public bool HasProperties { get; }
    [SecurityCriticalAttribute]
internal BinaryMethodCallMessage(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, LogicalCallContext callContext, Object[] properties);
    public string get_MethodName();
    public string get_TypeName();
    public Type[] get_InstantiationArgs();
    public object get_MethodSignature();
    public Object[] get_Args();
    [SecurityCriticalAttribute]
public LogicalCallContext get_LogicalCallContext();
    public bool get_HasProperties();
    internal void PopulateMessageProperties(IDictionary dict);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturn : object {
    [SecuritySafeCriticalAttribute]
private static BinaryMethodReturn();
    internal Object[] WriteArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    [SecurityCriticalAttribute]
internal IMethodReturnMessage ReadArray(Object[] returnA, IMethodCallMessage methodCallMessage, object handlerObject);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturnMessage : object {
    public Exception Exception { get; }
    public object ReturnValue { get; }
    public Object[] Args { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public bool HasProperties { get; }
    [SecurityCriticalAttribute]
internal BinaryMethodReturnMessage(object returnValue, Object[] args, Exception e, LogicalCallContext callContext, Object[] properties);
    public Exception get_Exception();
    public object get_ReturnValue();
    public Object[] get_Args();
    [SecurityCriticalAttribute]
public LogicalCallContext get_LogicalCallContext();
    public bool get_HasProperties();
    internal void PopulateMessageProperties(IDictionary dict);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObject : object {
    internal int objectId;
    internal int mapId;
    internal void Set(int objectId, int mapId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectString : object {
    internal int objectId;
    internal string value;
    internal void Set(int objectId, string value);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap : object {
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int objectId;
    internal string name;
    internal int numMembers;
    internal String[] memberNames;
    internal int assemId;
    internal BinaryObjectWithMap(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, string name, int numMembers, String[] memberNames, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped : object {
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int objectId;
    internal string name;
    internal int numMembers;
    internal String[] memberNames;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal Int32[] memberAssemIds;
    internal int assemId;
    internal BinaryObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, string name, int numMembers, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum : Enum {
    public int value__;
    public static BinaryTypeEnum Primitive;
    public static BinaryTypeEnum String;
    public static BinaryTypeEnum Object;
    public static BinaryTypeEnum ObjectUrt;
    public static BinaryTypeEnum ObjectUser;
    public static BinaryTypeEnum ObjectArray;
    public static BinaryTypeEnum StringArray;
    public static BinaryTypeEnum PrimitiveArray;
}
internal static class System.Runtime.Serialization.Formatters.Binary.BinaryUtil : object {
    [ConditionalAttribute("_LOGGING")]
public static void NVTraceI(string name, string value);
    [ConditionalAttribute("_LOGGING")]
public static void NVTraceI(string name, object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.Converter : object {
    internal static Type typeofISerializable;
    internal static Type typeofString;
    internal static Type typeofConverter;
    internal static Type typeofBoolean;
    internal static Type typeofByte;
    internal static Type typeofChar;
    internal static Type typeofDecimal;
    internal static Type typeofDouble;
    internal static Type typeofInt16;
    internal static Type typeofInt32;
    internal static Type typeofInt64;
    internal static Type typeofSByte;
    internal static Type typeofSingle;
    internal static Type typeofTimeSpan;
    internal static Type typeofDateTime;
    internal static Type typeofUInt16;
    internal static Type typeofUInt32;
    internal static Type typeofUInt64;
    internal static Type typeofObject;
    internal static Type typeofSystemVoid;
    internal static Assembly urtAssembly;
    internal static string urtAssemblyString;
    internal static Type typeofTypeArray;
    internal static Type typeofObjectArray;
    internal static Type typeofStringArray;
    internal static Type typeofBooleanArray;
    internal static Type typeofByteArray;
    internal static Type typeofCharArray;
    internal static Type typeofDecimalArray;
    internal static Type typeofDoubleArray;
    internal static Type typeofInt16Array;
    internal static Type typeofInt32Array;
    internal static Type typeofInt64Array;
    internal static Type typeofSByteArray;
    internal static Type typeofSingleArray;
    internal static Type typeofTimeSpanArray;
    internal static Type typeofDateTimeArray;
    internal static Type typeofUInt16Array;
    internal static Type typeofUInt32Array;
    internal static Type typeofUInt64Array;
    internal static Type typeofMarshalByRefObject;
    private static Converter();
    internal static InternalPrimitiveTypeE ToCode(Type type);
    internal static bool IsWriteAsByteArray(InternalPrimitiveTypeE code);
    internal static int TypeLength(InternalPrimitiveTypeE code);
    internal static InternalNameSpaceE GetNameSpaceEnum(InternalPrimitiveTypeE code, Type type, WriteObjectInfo objectInfo, String& typeName);
    internal static Type ToArrayType(InternalPrimitiveTypeE code);
    internal static Type ToType(InternalPrimitiveTypeE code);
    internal static Array CreatePrimitiveArray(InternalPrimitiveTypeE code, int length);
    internal static bool IsPrimitiveArray(Type type, Object& typeInformation);
    internal static string ToComType(InternalPrimitiveTypeE code);
    internal static TypeCode ToTypeCode(InternalPrimitiveTypeE code);
    internal static InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode);
    internal static object FromString(string value, InternalPrimitiveTypeE code);
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE : Enum {
    public int value__;
    public static InternalArrayTypeE Empty;
    public static InternalArrayTypeE Single;
    public static InternalArrayTypeE Jagged;
    public static InternalArrayTypeE Rectangular;
    public static InternalArrayTypeE Base64;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalElementTypeE : Enum {
    public int value__;
    public static InternalElementTypeE ObjectBegin;
    public static InternalElementTypeE ObjectEnd;
    public static InternalElementTypeE Member;
}
internal class System.Runtime.Serialization.Formatters.Binary.InternalFE : object {
    internal FormatterTypeStyle FEtypeFormat;
    internal FormatterAssemblyStyle FEassemblyFormat;
    internal TypeFilterLevel FEsecurityLevel;
    internal InternalSerializerTypeE FEserializerTypeEnum;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE : Enum {
    public int value__;
    public static InternalMemberTypeE Empty;
    public static InternalMemberTypeE Header;
    public static InternalMemberTypeE Field;
    public static InternalMemberTypeE Item;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE : Enum {
    public int value__;
    public static InternalMemberValueE Empty;
    public static InternalMemberValueE InlineValue;
    public static InternalMemberValueE Nested;
    public static InternalMemberValueE Reference;
    public static InternalMemberValueE Null;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalNameSpaceE : Enum {
    public int value__;
    public static InternalNameSpaceE None;
    public static InternalNameSpaceE Soap;
    public static InternalNameSpaceE XdrPrimitive;
    public static InternalNameSpaceE XdrString;
    public static InternalNameSpaceE UrtSystem;
    public static InternalNameSpaceE UrtUser;
    public static InternalNameSpaceE UserNameSpace;
    public static InternalNameSpaceE MemberName;
    public static InternalNameSpaceE Interop;
    public static InternalNameSpaceE CallElement;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalObjectPositionE : Enum {
    public int value__;
    public static InternalObjectPositionE Empty;
    public static InternalObjectPositionE Top;
    public static InternalObjectPositionE Child;
    public static InternalObjectPositionE Headers;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE : Enum {
    public int value__;
    public static InternalObjectTypeE Empty;
    public static InternalObjectTypeE Object;
    public static InternalObjectTypeE Array;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalParseStateE : Enum {
    public int value__;
    public static InternalParseStateE Initial;
    public static InternalParseStateE Object;
    public static InternalParseStateE Member;
    public static InternalParseStateE MemberChild;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalParseTypeE : Enum {
    public int value__;
    public static InternalParseTypeE Empty;
    public static InternalParseTypeE SerializedStreamHeader;
    public static InternalParseTypeE Object;
    public static InternalParseTypeE Member;
    public static InternalParseTypeE ObjectEnd;
    public static InternalParseTypeE MemberEnd;
    public static InternalParseTypeE Headers;
    public static InternalParseTypeE HeadersEnd;
    public static InternalParseTypeE SerializedStreamHeaderEnd;
    public static InternalParseTypeE Envelope;
    public static InternalParseTypeE EnvelopeEnd;
    public static InternalParseTypeE Body;
    public static InternalParseTypeE BodyEnd;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE : Enum {
    public int value__;
    public static InternalPrimitiveTypeE Invalid;
    public static InternalPrimitiveTypeE Boolean;
    public static InternalPrimitiveTypeE Byte;
    public static InternalPrimitiveTypeE Char;
    public static InternalPrimitiveTypeE Currency;
    public static InternalPrimitiveTypeE Decimal;
    public static InternalPrimitiveTypeE Double;
    public static InternalPrimitiveTypeE Int16;
    public static InternalPrimitiveTypeE Int32;
    public static InternalPrimitiveTypeE Int64;
    public static InternalPrimitiveTypeE SByte;
    public static InternalPrimitiveTypeE Single;
    public static InternalPrimitiveTypeE TimeSpan;
    public static InternalPrimitiveTypeE DateTime;
    public static InternalPrimitiveTypeE UInt16;
    public static InternalPrimitiveTypeE UInt32;
    public static InternalPrimitiveTypeE UInt64;
    public static InternalPrimitiveTypeE Null;
    public static InternalPrimitiveTypeE String;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalSerializerTypeE : Enum {
    public int value__;
    public static InternalSerializerTypeE Soap;
    public static InternalSerializerTypeE Binary;
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.Formatters.Binary.IntSizedArray : object {
    internal Int32[] objects;
    internal Int32[] negObjects;
    internal int Item { get; internal set; }
    public sealed virtual object Clone();
    internal int get_Item(int index);
    internal void set_Item(int index, int value);
    internal void IncreaseCapacity(int index);
}
internal static class System.Runtime.Serialization.Formatters.Binary.IOUtil : object {
    internal static bool FlagTest(MessageEnum flag, MessageEnum target);
    internal static void WriteStringWithCode(string value, __BinaryWriter sout);
    internal static void WriteWithCode(Type type, object value, __BinaryWriter sout);
    internal static object ReadWithCode(__BinaryParser input);
    internal static Object[] ReadArgs(__BinaryParser input);
}
internal interface System.Runtime.Serialization.Formatters.Binary.IStreamable {
    [SecurityCriticalAttribute]
public abstract virtual void Read(__BinaryParser input);
    public abstract virtual void Write(__BinaryWriter sout);
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped : object {
    internal InternalPrimitiveTypeE primitiveTypeEnum;
    internal object value;
    internal void Set(InternalPrimitiveTypeE primitiveTypeEnum, object value);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped : object {
    internal InternalPrimitiveTypeE typeInformation;
    internal object value;
    internal void Set(InternalPrimitiveTypeE typeInformation, object value);
    internal void Set(InternalPrimitiveTypeE typeInformation);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberReference : object {
    internal int idRef;
    internal void Set(int idRef);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.MessageEnd : object {
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    public void Dump(Stream sout);
}
[FlagsAttribute]
internal enum System.Runtime.Serialization.Formatters.Binary.MessageEnum : Enum {
    public int value__;
    public static MessageEnum NoArgs;
    public static MessageEnum ArgsInline;
    public static MessageEnum ArgsIsArray;
    public static MessageEnum ArgsInArray;
    public static MessageEnum NoContext;
    public static MessageEnum ContextInline;
    public static MessageEnum ContextInArray;
    public static MessageEnum MethodSignatureInArray;
    public static MessageEnum PropertyInArray;
    public static MessageEnum NoReturnValue;
    public static MessageEnum ReturnValueVoid;
    public static MessageEnum ReturnValueInline;
    public static MessageEnum ReturnValueInArray;
    public static MessageEnum ExceptionInArray;
    public static MessageEnum GenericMethod;
}
internal class System.Runtime.Serialization.Formatters.Binary.NameCache : object {
    private static NameCache();
    internal object GetCachedValue(string name);
    internal void SetCachedValue(object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.NameInfo : object {
    internal string NIFullName;
    internal long NIobjectId;
    internal long NIassemId;
    internal InternalPrimitiveTypeE NIprimitiveTypeEnum;
    internal Type NItype;
    internal bool NIisSealed;
    internal bool NIisArray;
    internal bool NIisArrayItem;
    internal bool NItransmitTypeOnObject;
    internal bool NItransmitTypeOnMember;
    internal bool NIisParentTypeOnObject;
    internal InternalArrayTypeE NIarrayEnum;
    public bool IsSealed { get; }
    public string NIname { get; public set; }
    internal void Init();
    public bool get_IsSealed();
    public string get_NIname();
    public void set_NIname(string value);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectMap : object {
    internal string objectName;
    internal Type objectType;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal Type[] memberTypes;
    internal String[] memberNames;
    internal ReadObjectInfo objectInfo;
    internal bool isInitObjectInfo;
    internal ObjectReader objectReader;
    internal int objectId;
    internal BinaryAssemblyInfo assemblyInfo;
    [SecurityCriticalAttribute]
internal ObjectMap(string objectName, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
    [SecurityCriticalAttribute]
internal ObjectMap(string objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);
    internal ReadObjectInfo CreateObjectInfo(SerializationInfo& si, Object[]& memberData);
    [SecurityCriticalAttribute]
internal static ObjectMap Create(string name, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
    [SecurityCriticalAttribute]
internal static ObjectMap Create(string name, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectMapInfo : object {
    internal int objectId;
    internal ObjectMapInfo(int objectId, int numMembers, String[] memberNames, Type[] memberTypes);
    internal bool isCompatible(int numMembers, String[] memberNames, Type[] memberTypes);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectNull : object {
    internal int nullCount;
    internal void SetNullCount(int nullCount);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Read(__BinaryParser input, BinaryHeaderEnum binaryHeaderEnum);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectProgress : object {
    internal static int opRecordIdCount;
    internal int opRecordId;
    internal bool isInitial;
    internal int count;
    internal BinaryTypeEnum expectedType;
    internal object expectedTypeInformation;
    internal string name;
    internal InternalObjectTypeE objectTypeEnum;
    internal InternalMemberTypeE memberTypeEnum;
    internal InternalMemberValueE memberValueEnum;
    internal Type dtType;
    internal int numItems;
    internal BinaryTypeEnum binaryTypeEnum;
    internal object typeInformation;
    internal int nullCount;
    internal int memberLength;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal String[] memberNames;
    internal Type[] memberTypes;
    internal ParseRecord pr;
    private static ObjectProgress();
    internal void Init();
    internal void ArrayCountIncrement(int value);
    internal bool GetNext(BinaryTypeEnum& outBinaryTypeEnum, Object& outTypeInformation);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectReader : object {
    internal Stream m_stream;
    internal ISurrogateSelector m_surrogates;
    internal StreamingContext m_context;
    internal ObjectManager m_objectManager;
    internal InternalFE formatterEnums;
    internal SerializationBinder m_binder;
    internal long topId;
    internal bool bSimpleAssembly;
    internal object handlerObject;
    internal object m_topObject;
    internal Header[] headers;
    internal HeaderHandler handler;
    internal SerObjectInfoInit serObjectInfoInit;
    internal IFormatterConverter m_formatterConverter;
    internal SerStack stack;
    internal Object[] crossAppDomainArray;
    internal object TopObject { get; internal set; }
    internal ObjectReader(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
    private static ObjectReader();
    internal object get_TopObject();
    internal void set_TopObject(object value);
    internal void SetMethodCall(BinaryMethodCall binaryMethodCall);
    internal void SetMethodReturn(BinaryMethodReturn binaryMethodReturn);
    [SecurityCriticalAttribute]
internal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage);
    internal object CrossAppDomainArray(int index);
    [SecurityCriticalAttribute]
internal ReadObjectInfo CreateReadObjectInfo(Type objectType);
    [SecurityCriticalAttribute]
internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, Type[] memberTypes);
    [SecurityCriticalAttribute]
internal void Parse(ParseRecord pr);
    [SecurityCriticalAttribute]
internal void CheckSecurity(ParseRecord pr);
    [SecurityCriticalAttribute]
internal long GetId(long objectId);
    [SecurityCriticalAttribute]
internal Type Bind(string assemblyString, string typeString);
    [SecurityCriticalAttribute]
internal Type FastBindToType(string assemblyName, string typeName);
    [SecurityCriticalAttribute]
internal Type GetType(BinaryAssemblyInfo assemblyInfo, string name);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectWriter : object {
    internal Object[] crossAppDomainArray;
    internal ArrayList internalCrossAppDomainArray;
    internal SerializationObjectManager ObjectManager { get; }
    internal ObjectWriter(ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void Serialize(object graph, Header[] inHeaders, __BinaryWriter serWriter, bool fCheck);
    internal SerializationObjectManager get_ObjectManager();
    internal InternalPrimitiveTypeE ToCode(Type type);
}
internal class System.Runtime.Serialization.Formatters.Binary.ParseRecord : object {
    internal static int parseRecordIdCount;
    internal int PRparseRecordId;
    internal InternalParseTypeE PRparseTypeEnum;
    internal InternalObjectTypeE PRobjectTypeEnum;
    internal InternalArrayTypeE PRarrayTypeEnum;
    internal InternalMemberTypeE PRmemberTypeEnum;
    internal InternalMemberValueE PRmemberValueEnum;
    internal InternalObjectPositionE PRobjectPositionEnum;
    internal string PRname;
    internal string PRvalue;
    internal object PRvarValue;
    internal string PRkeyDt;
    internal Type PRdtType;
    internal InternalPrimitiveTypeE PRdtTypeCode;
    internal bool PRisVariant;
    internal bool PRisEnum;
    internal long PRobjectId;
    internal long PRidRef;
    internal string PRarrayElementTypeString;
    internal Type PRarrayElementType;
    internal bool PRisArrayVariant;
    internal InternalPrimitiveTypeE PRarrayElementTypeCode;
    internal int PRrank;
    internal Int32[] PRlengthA;
    internal Int32[] PRpositionA;
    internal Int32[] PRlowerBoundA;
    internal Int32[] PRupperBoundA;
    internal Int32[] PRindexMap;
    internal int PRmemberIndex;
    internal int PRlinearlength;
    internal Int32[] PRrectangularMap;
    internal bool PRisLowerBound;
    internal long PRtopId;
    internal long PRheaderId;
    internal ReadObjectInfo PRobjectInfo;
    internal bool PRisValueTypeFixup;
    internal object PRnewObj;
    internal Object[] PRobjectA;
    internal PrimitiveArray PRprimitiveArray;
    internal bool PRisRegistered;
    internal Object[] PRmemberData;
    internal SerializationInfo PRsi;
    internal int PRnullCount;
    private static ParseRecord();
    internal void Init();
}
internal class System.Runtime.Serialization.Formatters.Binary.PrimitiveArray : object {
    internal PrimitiveArray(InternalPrimitiveTypeE code, Array array);
    internal void Init(InternalPrimitiveTypeE code, Array array);
    internal void SetValue(string value, int index);
}
internal class System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo : object {
    internal int objectInfoId;
    internal static int readObjectInfoCounter;
    internal Type objectType;
    internal ObjectManager objectManager;
    internal int count;
    internal bool isSi;
    internal bool isNamed;
    internal bool isTyped;
    internal bool bSimpleAssembly;
    internal SerObjectInfoCache cache;
    internal String[] wireMemberNames;
    internal Type[] wireMemberTypes;
    internal ISurrogateSelector surrogateSelector;
    internal ISerializationSurrogate serializationSurrogate;
    internal StreamingContext context;
    internal List`1<Type> memberTypesList;
    internal SerObjectInfoInit serObjectInfoInit;
    internal IFormatterConverter formatterConverter;
    internal void ObjectEnd();
    internal void PrepareForReuse();
    [SecurityCriticalAttribute]
internal static ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal static ReadObjectInfo Create(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal void Init(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    internal MemberInfo GetMemberInfo(string name);
    internal Type GetType(string name);
    internal void AddValue(string name, object value, SerializationInfo& si, Object[]& memberData);
    internal void InitDataStore(SerializationInfo& si, Object[]& memberData);
    internal void RecordFixup(long objectId, string name, long idRef);
    [SecurityCriticalAttribute]
internal void PopulateObjectMembers(object obj, Object[] memberData);
    internal Type[] GetMemberTypes(String[] inMemberNames, Type objectType);
    internal Type GetMemberType(MemberInfo objMember);
}
internal class System.Runtime.Serialization.Formatters.Binary.SerializationHeaderRecord : object {
    internal int binaryFormatterMajorVersion;
    internal int binaryFormatterMinorVersion;
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int topId;
    internal int headerId;
    internal int majorVersion;
    internal int minorVersion;
    internal SerializationHeaderRecord(BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
}
internal class System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache : object {
    internal string fullTypeName;
    internal string assemblyString;
    internal bool hasTypeForwardedFrom;
    internal MemberInfo[] memberInfos;
    internal String[] memberNames;
    internal Type[] memberTypes;
    internal SerObjectInfoCache(string typeName, string assemblyName, bool hasTypeForwardedFrom);
    internal SerObjectInfoCache(Type type);
}
internal class System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit : object {
    internal Hashtable seenBeforeTable;
    internal int objectInfoIdCount;
    internal SerStack oiPool;
}
internal class System.Runtime.Serialization.Formatters.Binary.SerStack : object {
    internal Object[] objects;
    internal string stackId;
    internal int top;
    internal int next;
    internal SerStack(string stackId);
    internal void Push(object obj);
    internal object Pop();
    internal void IncreaseCapacity();
    internal object Peek();
    internal object PeekPeek();
    internal int Count();
    internal bool IsEmpty();
    [ConditionalAttribute("SER_LOGGING")]
internal void Dump();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.Formatters.Binary.SizedArray : object {
    internal Object[] objects;
    internal Object[] negObjects;
    internal object Item { get; internal set; }
    internal SizedArray(int length);
    public sealed virtual object Clone();
    internal object get_Item(int index);
    internal void set_Item(int index, object value);
    internal void IncreaseCapacity(int index);
}
internal enum System.Runtime.Serialization.Formatters.Binary.SoapAttributeType : Enum {
    public int value__;
    public static SoapAttributeType None;
    public static SoapAttributeType SchemaType;
    public static SoapAttributeType Embedded;
    public static SoapAttributeType XmlElement;
    public static SoapAttributeType XmlAttribute;
}
internal class System.Runtime.Serialization.Formatters.Binary.TypeInformation : object {
    internal string FullTypeName { get; }
    internal string AssemblyString { get; }
    internal bool HasTypeForwardedFrom { get; }
    internal TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
    internal string get_FullTypeName();
    internal string get_AssemblyString();
    internal bool get_HasTypeForwardedFrom();
}
internal class System.Runtime.Serialization.Formatters.Binary.ValueFixup : object {
    internal ValueFixupEnum valueFixupEnum;
    internal Array arrayObj;
    internal Int32[] indexMap;
    internal object header;
    internal object memberObject;
    internal static MemberInfo modreq(System.Runtime.CompilerServices.IsVolatile) valueInfo;
    internal ReadObjectInfo objectInfo;
    internal string memberName;
    internal ValueFixup(Array arrayObj, Int32[] indexMap);
    internal ValueFixup(object memberObject, string memberName, ReadObjectInfo objectInfo);
    [SecurityCriticalAttribute]
internal void Fixup(ParseRecord record, ParseRecord parent);
}
internal enum System.Runtime.Serialization.Formatters.Binary.ValueFixupEnum : Enum {
    public int value__;
    public static ValueFixupEnum Empty;
    public static ValueFixupEnum Array;
    public static ValueFixupEnum Header;
    public static ValueFixupEnum Member;
}
internal class System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo : object {
    internal int objectInfoId;
    internal object obj;
    internal Type objectType;
    internal bool isSi;
    internal bool isNamed;
    internal bool isTyped;
    internal bool isArray;
    internal SerializationInfo si;
    internal SerObjectInfoCache cache;
    internal Object[] memberData;
    internal ISerializationSurrogate serializationSurrogate;
    internal StreamingContext context;
    internal SerObjectInfoInit serObjectInfoInit;
    internal long objectId;
    internal long assemId;
    internal void ObjectEnd();
    [SecurityCriticalAttribute]
internal static WriteObjectInfo Serialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void InitSerialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal static WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
    internal string GetTypeFullName();
    internal string GetAssemblyString();
    internal Type GetMemberType(MemberInfo objMember);
    internal void GetMemberInfo(String[]& outMemberNames, Type[]& outMemberTypes, Object[]& outMemberData);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Serialization.Formatters.FormatterAssemblyStyle : Enum {
    public int value__;
    public static FormatterAssemblyStyle Simple;
    public static FormatterAssemblyStyle Full;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Serialization.Formatters.FormatterTypeStyle : Enum {
    public int value__;
    public static FormatterTypeStyle TypesWhenNeeded;
    public static FormatterTypeStyle TypesAlways;
    public static FormatterTypeStyle XsdString;
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.Formatters.IFieldInfo {
    public String[] FieldNames { get; public set; }
    public Type[] FieldTypes { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual String[] get_FieldNames();
    [SecurityCriticalAttribute]
public abstract virtual void set_FieldNames(String[] value);
    [SecurityCriticalAttribute]
public abstract virtual Type[] get_FieldTypes();
    [SecurityCriticalAttribute]
public abstract virtual void set_FieldTypes(Type[] value);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.InternalRM : object {
    [ConditionalAttribute("_LOGGING")]
public static void InfoSoap(Object[] messages);
    public static bool SoapCheckEnabled();
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.InternalST : object {
    [ConditionalAttribute("_LOGGING")]
public static void InfoSoap(Object[] messages);
    public static bool SoapCheckEnabled();
    [ConditionalAttribute("SER_LOGGING")]
public static void Soap(Object[] messages);
    [ConditionalAttribute("_DEBUG")]
public static void SoapAssert(bool condition, string message);
    public static void SerializationSetValue(FieldInfo fi, object target, object value);
    public static Assembly LoadAssemblyFromString(string assemblyString);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.Formatters.ISoapMessage {
    public String[] ParamNames { get; public set; }
    public Object[] ParamValues { get; public set; }
    public Type[] ParamTypes { get; public set; }
    public string MethodName { get; public set; }
    public string XmlNameSpace { get; public set; }
    public Header[] Headers { get; public set; }
    public abstract virtual String[] get_ParamNames();
    public abstract virtual void set_ParamNames(String[] value);
    public abstract virtual Object[] get_ParamValues();
    public abstract virtual void set_ParamValues(Object[] value);
    public abstract virtual Type[] get_ParamTypes();
    public abstract virtual void set_ParamTypes(Type[] value);
    public abstract virtual string get_MethodName();
    public abstract virtual void set_MethodName(string value);
    public abstract virtual string get_XmlNameSpace();
    public abstract virtual void set_XmlNameSpace(string value);
    public abstract virtual Header[] get_Headers();
    public abstract virtual void set_Headers(Header[] value);
}
internal static class System.Runtime.Serialization.Formatters.SerTrace : object {
    [ConditionalAttribute("_LOGGING")]
internal static void InfoLog(Object[] messages);
    [ConditionalAttribute("SER_LOGGING")]
internal static void Log(Object[] messages);
}
[ComVisibleAttribute("True")]
[SoapTypeAttribute]
public class System.Runtime.Serialization.Formatters.ServerFault : object {
    public string ExceptionType { get; public set; }
    public string ExceptionMessage { get; public set; }
    public string StackTrace { get; public set; }
    internal Exception Exception { get; }
    internal ServerFault(Exception exception);
    public ServerFault(string exceptionType, string message, string stackTrace);
    public string get_ExceptionType();
    public void set_ExceptionType(string value);
    public string get_ExceptionMessage();
    public void set_ExceptionMessage(string value);
    public string get_StackTrace();
    public void set_StackTrace(string value);
    internal Exception get_Exception();
}
[ComVisibleAttribute("True")]
[SoapTypeAttribute]
public class System.Runtime.Serialization.Formatters.SoapFault : object {
    public string FaultCode { get; public set; }
    public string FaultString { get; public set; }
    public string FaultActor { get; public set; }
    public object Detail { get; public set; }
    public SoapFault(string faultCode, string faultString, string faultActor, ServerFault serverFault);
    internal SoapFault(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_FaultCode();
    public void set_FaultCode(string value);
    public string get_FaultString();
    public void set_FaultString(string value);
    public string get_FaultActor();
    public void set_FaultActor(string value);
    public object get_Detail();
    public void set_Detail(object value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.SoapMessage : object {
    internal String[] paramNames;
    internal Object[] paramValues;
    internal Type[] paramTypes;
    internal string methodName;
    internal string xmlNameSpace;
    internal Header[] headers;
    public String[] ParamNames { get; public set; }
    public Object[] ParamValues { get; public set; }
    public Type[] ParamTypes { get; public set; }
    public string MethodName { get; public set; }
    public string XmlNameSpace { get; public set; }
    public Header[] Headers { get; public set; }
    public sealed virtual String[] get_ParamNames();
    public sealed virtual void set_ParamNames(String[] value);
    public sealed virtual Object[] get_ParamValues();
    public sealed virtual void set_ParamValues(Object[] value);
    public sealed virtual Type[] get_ParamTypes();
    public sealed virtual void set_ParamTypes(Type[] value);
    public sealed virtual string get_MethodName();
    public sealed virtual void set_MethodName(string value);
    public sealed virtual string get_XmlNameSpace();
    public sealed virtual void set_XmlNameSpace(string value);
    public sealed virtual Header[] get_Headers();
    public sealed virtual void set_Headers(Header[] value);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Serialization.Formatters.TypeFilterLevel : Enum {
    public int value__;
    public static TypeFilterLevel Low;
    public static TypeFilterLevel Full;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.FormatterServices : object {
    internal static Dictionary`2<MemberHolder, MemberInfo[]> m_MemberInfoTable;
    [SecuritySafeCriticalAttribute]
private static FormatterServices();
    [SecurityCriticalAttribute]
public static MemberInfo[] GetSerializableMembers(Type type);
    [SecurityCriticalAttribute]
public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);
    public static void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel);
    [SecurityCriticalAttribute]
public static object GetUninitializedObject(Type type);
    [SecurityCriticalAttribute]
public static object GetSafeUninitializedObject(Type type);
    [SecuritySafeCriticalAttribute]
internal static bool UnsafeTypeForwardersIsEnabled();
    [SecurityCriticalAttribute]
internal static void SerializationSetValue(MemberInfo fi, object target, object value);
    [SecurityCriticalAttribute]
public static object PopulateObjectMembers(object obj, MemberInfo[] members, Object[] data);
    [SecurityCriticalAttribute]
public static Object[] GetObjectData(object obj, MemberInfo[] members);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public static ISerializationSurrogate GetSurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
    [SecurityCriticalAttribute]
public static Type GetTypeFromAssembly(Assembly assem, string name);
    internal static Assembly LoadAssemblyFromString(string assemblyName);
    internal static Assembly LoadAssemblyFromStringNoThrow(string assemblyName);
    internal static string GetClrAssemblyName(Type type, Boolean& hasTypeForwardedFrom);
    internal static string GetClrTypeFullName(Type type);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.IFormatter {
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public abstract virtual object Deserialize(Stream serializationStream);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.IObjectReference {
    [SecurityCriticalAttribute]
public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.ISerializable {
    [SecurityCriticalAttribute]
public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.ISerializationSurrogate {
    [SecurityCriticalAttribute]
public abstract virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public abstract virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.ISurrogateSelector {
    [SecurityCriticalAttribute]
public abstract virtual void ChainSelector(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public abstract virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    [SecurityCriticalAttribute]
public abstract virtual ISurrogateSelector GetNextSelector();
}
internal class System.Runtime.Serialization.LongList : object {
    internal int Count { get; }
    internal long Current { get; }
    internal LongList(int startingSize);
    internal void Add(long value);
    internal int get_Count();
    internal void StartEnumeration();
    internal bool MoveNext();
    internal long get_Current();
    internal bool RemoveElement(long value);
}
internal class System.Runtime.Serialization.MemberHolder : object {
    internal MemberInfo[] members;
    internal Type memberType;
    internal StreamingContext context;
    internal MemberHolder(Type type, StreamingContext ctx);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class System.Runtime.Serialization.ObjectCloneHelper : object {
    private static ObjectCloneHelper();
    [SecurityCriticalAttribute]
internal static object GetObjectData(object serObj, String& typeName, String& assemName, String[]& fieldNames, Object[]& fieldValues);
    [SecurityCriticalAttribute]
internal static SerializationInfo PrepareConstructorArgs(object serObj, String[] fieldNames, Object[] fieldValues, StreamingContext& context);
}
internal class System.Runtime.Serialization.ObjectHolder : object {
    internal static int INCOMPLETE_OBJECT_REFERENCE;
    internal static int HAS_ISERIALIZABLE;
    internal static int HAS_SURROGATE;
    internal static int REQUIRES_VALUETYPE_FIXUP;
    internal static int REQUIRES_DELAYED_FIXUP;
    internal static int SER_INFO_FIXED;
    internal static int VALUETYPE_FIXUP_PERFORMED;
    internal long m_id;
    internal SerializationInfo m_serInfo;
    internal ISerializationSurrogate m_surrogate;
    internal FixupHolderList m_missingElements;
    internal LongList m_dependentObjects;
    internal ObjectHolder m_next;
    internal int m_flags;
    internal bool IsIncompleteObjectReference { get; internal set; }
    internal bool RequiresDelayedFixup { get; }
    internal bool RequiresValueTypeFixup { get; }
    internal bool ValueTypeFixupPerformed { get; internal set; }
    internal bool HasISerializable { get; }
    internal bool HasSurrogate { get; }
    internal bool CanSurrogatedObjectValueChange { get; }
    internal bool CanObjectValueChange { get; }
    internal int DirectlyDependentObjects { get; }
    internal int TotalDependentObjects { get; }
    internal bool Reachable { get; internal set; }
    internal bool TypeLoadExceptionReachable { get; }
    internal TypeLoadExceptionHolder TypeLoadException { get; internal set; }
    internal object ObjectValue { get; }
    internal SerializationInfo SerializationInfo { get; internal set; }
    internal ISerializationSurrogate Surrogate { get; }
    internal LongList DependentObjects { get; internal set; }
    internal bool RequiresSerInfoFixup { get; internal set; }
    internal ValueTypeFixupInfo ValueFixup { get; }
    internal bool CompletelyFixed { get; }
    internal long ContainerID { get; }
    internal ObjectHolder(long objID);
    internal ObjectHolder(object obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex);
    internal ObjectHolder(string obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex);
    internal void DecrementFixupsRemaining(ObjectManager manager);
    internal void RemoveDependency(long id);
    internal void AddFixup(FixupHolder fixup, ObjectManager manager);
    internal void AddDependency(long dependentObject);
    [SecurityCriticalAttribute]
internal void UpdateData(object obj, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainer, FieldInfo field, Int32[] arrayIndex, ObjectManager manager);
    internal void MarkForCompletionWhenAvailable();
    internal void SetFlags();
    internal bool get_IsIncompleteObjectReference();
    internal void set_IsIncompleteObjectReference(bool value);
    internal bool get_RequiresDelayedFixup();
    internal bool get_RequiresValueTypeFixup();
    internal bool get_ValueTypeFixupPerformed();
    internal void set_ValueTypeFixupPerformed(bool value);
    internal bool get_HasISerializable();
    internal bool get_HasSurrogate();
    internal bool get_CanSurrogatedObjectValueChange();
    internal bool get_CanObjectValueChange();
    internal int get_DirectlyDependentObjects();
    internal int get_TotalDependentObjects();
    internal bool get_Reachable();
    internal void set_Reachable(bool value);
    internal bool get_TypeLoadExceptionReachable();
    internal TypeLoadExceptionHolder get_TypeLoadException();
    internal void set_TypeLoadException(TypeLoadExceptionHolder value);
    internal object get_ObjectValue();
    [SecurityCriticalAttribute]
internal void SetObjectValue(object obj, ObjectManager manager);
    internal SerializationInfo get_SerializationInfo();
    internal void set_SerializationInfo(SerializationInfo value);
    internal ISerializationSurrogate get_Surrogate();
    internal LongList get_DependentObjects();
    internal void set_DependentObjects(LongList value);
    internal bool get_RequiresSerInfoFixup();
    internal void set_RequiresSerInfoFixup(bool value);
    internal ValueTypeFixupInfo get_ValueFixup();
    internal bool get_CompletelyFixed();
    internal long get_ContainerID();
}
internal class System.Runtime.Serialization.ObjectHolderList : object {
    internal static int DefaultInitialSize;
    internal ObjectHolder[] m_values;
    internal int m_count;
    internal int Version { get; }
    internal int Count { get; }
    internal ObjectHolderList(int startingSize);
    internal virtual void Add(ObjectHolder value);
    internal ObjectHolderListEnumerator GetFixupEnumerator();
    internal int get_Version();
    internal int get_Count();
}
internal class System.Runtime.Serialization.ObjectHolderListEnumerator : object {
    internal ObjectHolder Current { get; }
    internal ObjectHolderListEnumerator(ObjectHolderList list, bool isFixupEnumerator);
    internal bool MoveNext();
    internal ObjectHolder get_Current();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.ObjectIDGenerator : object {
    internal int m_currentCount;
    internal int m_currentSize;
    internal Int64[] m_ids;
    internal Object[] m_objs;
    private static ObjectIDGenerator();
    public virtual long GetId(object obj, Boolean& firstTime);
    public virtual long HasId(object obj, Boolean& firstTime);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.ObjectManager : object {
    internal ObjectHolder[] m_objects;
    internal object m_topObject;
    internal ObjectHolderList m_specialFixupObjects;
    internal long m_fixupCount;
    internal ISurrogateSelector m_selector;
    internal StreamingContext m_context;
    internal object TopObject { get; internal set; }
    internal ObjectHolderList SpecialFixupObjects { get; }
    [SecuritySafeCriticalAttribute]
public ObjectManager(ISurrogateSelector selector, StreamingContext context);
    [SecurityCriticalAttribute]
internal ObjectManager(ISurrogateSelector selector, StreamingContext context, bool checkSecurity, bool isCrossAppDomain);
    private static ObjectManager();
    internal void set_TopObject(object value);
    internal object get_TopObject();
    internal ObjectHolderList get_SpecialFixupObjects();
    internal ObjectHolder FindObjectHolder(long objectID);
    internal ObjectHolder FindOrCreateObjectHolder(long objectID);
    [SecurityCriticalAttribute]
internal void CompleteObject(ObjectHolder holder, bool bObjectFullyComplete);
    public virtual object GetObject(long objectID);
    [SecurityCriticalAttribute]
public virtual void RegisterObject(object obj, long objectID);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
    internal void RegisterString(string obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, Int32[] arrayIndex);
    [SecurityCriticalAttribute]
internal void CompleteISerializableObject(object obj, SerializationInfo info, StreamingContext context);
    internal static RuntimeConstructorInfo GetConstructor(RuntimeType t);
    [SecuritySafeCriticalAttribute]
public virtual void DoFixups();
    public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired);
    public virtual void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, Int32[] indices, long objectRequired);
    public virtual void RaiseDeserializationEvent();
    internal virtual void AddOnDeserialization(DeserializationEventHandler handler);
    internal virtual void RemoveOnDeserialization(DeserializationEventHandler handler);
    [SecuritySafeCriticalAttribute]
internal virtual void AddOnDeserialized(object obj);
    internal virtual void RaiseOnDeserializedEvent(object obj);
    public void RaiseOnDeserializingEvent(object obj);
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    internal IList`1<object> SerializedStates { get; }
    public StreamingContext StreamingContext { get; }
    internal SafeSerializationEventArgs(StreamingContext streamingContext);
    public void AddSerializedState(ISafeSerializationData serializedState);
    internal IList`1<object> get_SerializedStates();
    public StreamingContext get_StreamingContext();
}
internal class System.Runtime.Serialization.SafeSerializationManager : object {
    internal bool IsActive { get; }
    internal void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    internal void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    internal bool get_IsActive();
    [SecurityCriticalAttribute]
internal void CompleteSerialization(object serializedObject, SerializationInfo info, StreamingContext context);
    internal void CompleteDeserialization(object deserializedObject);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override object System.Runtime.Serialization.IObjectReference.GetRealObject(StreamingContext context);
}
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Serialization.SerializationBinder : object {
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public abstract virtual Type BindToType(string assemblyName, string typeName);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private Type m_type;
    private object m_value;
    private string m_name;
    public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
internal class System.Runtime.Serialization.SerializationEventHandler : MulticastDelegate {
    public SerializationEventHandler(object object, IntPtr method);
    public virtual void Invoke(StreamingContext context);
    public virtual IAsyncResult BeginInvoke(StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.SerializationEvents : object {
    internal bool HasOnSerializingEvents { get; }
    internal SerializationEvents(Type t);
    internal bool get_HasOnSerializingEvents();
    [SecuritySafeCriticalAttribute]
internal void InvokeOnSerializing(object obj, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal void InvokeOnDeserializing(object obj, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal void InvokeOnDeserialized(object obj, StreamingContext context);
    [SecurityCriticalAttribute]
internal SerializationEventHandler AddOnSerialized(object obj, SerializationEventHandler handler);
    [SecurityCriticalAttribute]
internal SerializationEventHandler AddOnDeserialized(object obj, SerializationEventHandler handler);
}
internal static class System.Runtime.Serialization.SerializationEventsCache : object {
    private static SerializationEventsCache();
    internal static SerializationEvents GetSerializationEventsForType(Type t);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    private static SerializationException();
}
internal class System.Runtime.Serialization.SerializationFieldInfo : FieldInfo {
    internal static string FakeNameSeparatorString;
    public Module Module { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    internal RuntimeFieldInfo FieldInfo { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    internal RemotingFieldCachedData RemotingCache { get; }
    internal SerializationFieldInfo(RuntimeFieldInfo field, string namePrefix);
    public virtual Module get_Module();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    [SecurityCriticalAttribute]
internal object InternalGetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [SecurityCriticalAttribute]
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    internal RuntimeFieldInfo get_FieldInfo();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    internal RemotingFieldCachedData get_RemotingCache();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SerializationInfo : object {
    internal String[] m_members;
    internal Object[] m_data;
    internal Type[] m_types;
    internal int m_currMember;
    internal IFormatterConverter m_converter;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public bool IsAssemblyNameSetExplicit { get; }
    internal String[] MemberNames { get; }
    internal Object[] MemberValues { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    [SecuritySafeCriticalAttribute]
public void set_AssemblyName(string value);
    [SecuritySafeCriticalAttribute]
public void SetType(Type type);
    [SecuritySafeCriticalAttribute]
internal static void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
    internal static bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName);
    public int get_MemberCount();
    public Type get_ObjectType();
    public bool get_IsFullTypeNameSetExplicit();
    public bool get_IsAssemblyNameSetExplicit();
    public SerializationInfoEnumerator GetEnumerator();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValue(string name, object value, Type type, int index);
    internal void UpdateValue(string name, object value, Type type);
    [SecuritySafeCriticalAttribute]
public object GetValue(string name, Type type);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
    internal String[] get_MemberNames();
    internal Object[] get_MemberValues();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    public object get_Value();
    public Type get_ObjectType();
}
public class System.Runtime.Serialization.SerializationObjectManager : object {
    public SerializationObjectManager(StreamingContext context);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj);
    public void RaiseOnSerializedEvent();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    internal object m_additionalContext;
    internal StreamingContextStates m_state;
    public object Context { get; }
    public StreamingContextStates State { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public object get_Context();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
internal class System.Runtime.Serialization.SurrogateForCyclicalReference : object {
    internal SurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
internal class System.Runtime.Serialization.SurrogateHashtable : Hashtable {
    internal SurrogateHashtable(int size);
    protected virtual bool KeyEquals(object key, object item);
}
internal class System.Runtime.Serialization.SurrogateKey : object {
    internal Type m_type;
    internal StreamingContext m_context;
    internal SurrogateKey(Type type, StreamingContext context);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SurrogateSelector : object {
    internal SurrogateHashtable m_surrogates;
    internal ISurrogateSelector m_nextSelector;
    public virtual void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate);
    [SecurityCriticalAttribute]
public virtual void ChainSelector(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public virtual ISurrogateSelector GetNextSelector();
    [SecurityCriticalAttribute]
public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    public virtual void RemoveSurrogate(Type type, StreamingContext context);
}
internal class System.Runtime.Serialization.TypeLoadExceptionHolder : object {
    internal string TypeName { get; }
    internal TypeLoadExceptionHolder(string typeName);
    internal string get_TypeName();
}
internal class System.Runtime.Serialization.ValueTypeFixupInfo : object {
    public long ContainerID { get; }
    public FieldInfo ParentField { get; }
    public Int32[] ParentIndex { get; }
    public ValueTypeFixupInfo(long containerID, FieldInfo member, Int32[] parentIndex);
    public long get_ContainerID();
    public FieldInfo get_ParentField();
    public Int32[] get_ParentIndex();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    public string get_Reason();
}
[FriendAccessAllowedAttribute]
internal static class System.Runtime.Versioning.BinaryCompatibility : object {
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Phone_V7_1 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Phone_V8_0 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V4_5 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V4_5_1 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V4_5_2 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V4_5_3 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V4_5_4 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Desktop_V5_0 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Silverlight_V4 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Silverlight_V5 { get; }
    [FriendAccessAllowedAttribute]
internal static bool TargetsAtLeast_Silverlight_V6 { get; }
    [FriendAccessAllowedAttribute]
internal static TargetFrameworkId AppWasBuiltForFramework { get; }
    [FriendAccessAllowedAttribute]
internal static int AppWasBuiltForVersion { get; }
    private static BinaryCompatibility();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Phone_V7_1();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Phone_V8_0();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V4_5();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V4_5_1();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V4_5_2();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V4_5_3();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V4_5_4();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Desktop_V5_0();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Silverlight_V4();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Silverlight_V5();
    [FriendAccessAllowedAttribute]
internal static bool get_TargetsAtLeast_Silverlight_V6();
    [FriendAccessAllowedAttribute]
internal static TargetFrameworkId get_AppWasBuiltForFramework();
    [FriendAccessAllowedAttribute]
internal static int get_AppWasBuiltForVersion();
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
internal static class System.Runtime.Versioning.MultitargetingHelpers : object {
    private static MultitargetingHelpers();
    internal static string GetAssemblyQualifiedName(Type type, Func`2<Type, string> converter);
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    public ResourceScope ResourceScope { get; }
    public ResourceScope ConsumptionScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    public ResourceScope get_ResourceScope();
    public ResourceScope get_ConsumptionScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[FlagsAttribute]
internal enum System.Runtime.Versioning.SxSRequirements : Enum {
    public int value__;
    public static SxSRequirements None;
    public static SxSRequirements AppDomainID;
    public static SxSRequirements ProcessID;
    public static SxSRequirements CLRInstanceID;
    public static SxSRequirements AssemblyName;
    public static SxSRequirements TypeName;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    public string FrameworkName { get; }
    public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
}
[FriendAccessAllowedAttribute]
internal enum System.Runtime.Versioning.TargetFrameworkId : Enum {
    public int value__;
    public static TargetFrameworkId NotYetChecked;
    public static TargetFrameworkId Unrecognized;
    public static TargetFrameworkId Unspecified;
    public static TargetFrameworkId NetFramework;
    public static TargetFrameworkId Portable;
    public static TargetFrameworkId NetCore;
    public static TargetFrameworkId Silverlight;
    public static TargetFrameworkId Phone;
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    [SecuritySafeCriticalAttribute]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
}
[ComVisibleAttribute("True")]
public class System.RuntimeArgumentHandle : ValueType {
    private IntPtr m_ptr;
    internal IntPtr Value { get; }
    internal IntPtr get_Value();
}
[ComVisibleAttribute("True")]
public class System.RuntimeFieldHandle : ValueType {
    [ForceTokenStabilizationAttribute]
private IRuntimeFieldInfo m_ptr;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IRuntimeFieldInfo fieldInfo);
    internal RuntimeFieldHandle GetNativeHandle();
    internal IRuntimeFieldInfo GetRuntimeFieldInfo();
    [SecurityCriticalAttribute]
public IntPtr get_Value();
    internal bool IsNullHandle();
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeFieldHandle handle);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    [SecurityCriticalAttribute]
internal static string GetName(RtFieldInfo field);
    [SecuritySafeCriticalAttribute]
internal static Utf8String GetUtf8Name(RuntimeFieldHandleInternal field);
    [SecurityCriticalAttribute]
internal static bool MatchesNameHash(RuntimeFieldHandleInternal handle, UInt32 hash);
    [SecurityCriticalAttribute]
internal static FieldAttributes GetAttributes(RuntimeFieldHandleInternal field);
    [SecurityCriticalAttribute]
internal static RuntimeType GetApproxDeclaringType(RuntimeFieldHandleInternal field);
    [SecurityCriticalAttribute]
internal static RuntimeType GetApproxDeclaringType(IRuntimeFieldInfo field);
    [SecurityCriticalAttribute]
internal static int GetToken(RtFieldInfo field);
    [SecurityCriticalAttribute]
internal static object GetValue(RtFieldInfo field, object instance, RuntimeType fieldType, RuntimeType declaringType, Boolean& domainInitialized);
    [SecurityCriticalAttribute]
internal static object GetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    [SecurityCriticalAttribute]
internal static void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized);
    [SecurityCriticalAttribute]
internal static void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
    [SecurityCriticalAttribute]
internal static RuntimeFieldHandleInternal GetStaticFieldForGenericType(RuntimeFieldHandleInternal field, RuntimeType declaringType);
    [SecurityCriticalAttribute]
internal static bool AcquiresContextFromThis(RuntimeFieldHandleInternal field);
    [SecuritySafeCriticalAttribute]
internal bool IsSecurityCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsSecuritySafeCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsSecurityTransparent();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void CheckAttributeAccess(RuntimeFieldHandle fieldHandle, RuntimeModule decoratedTarget);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.RuntimeFieldHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal static RuntimeFieldHandleInternal EmptyHandle { get; }
    internal IntPtr Value { get; }
    [SecurityCriticalAttribute]
internal RuntimeFieldHandleInternal(IntPtr value);
    internal static RuntimeFieldHandleInternal get_EmptyHandle();
    internal bool IsNullHandle();
    [SecurityCriticalAttribute]
internal IntPtr get_Value();
}
internal class System.RuntimeFieldInfoStub : object {
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    [SecuritySafeCriticalAttribute]
public RuntimeFieldInfoStub(IntPtr methodHandleValue, object keepalive);
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
}
[ComVisibleAttribute("True")]
public class System.RuntimeMethodHandle : ValueType {
    [ForceTokenStabilizationAttribute]
private IRuntimeMethodInfo m_value;
    internal static RuntimeMethodHandle EmptyHandle { get; }
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IRuntimeMethodInfo method);
    internal static IRuntimeMethodInfo EnsureNonNullMethodInfo(IRuntimeMethodInfo method);
    internal static RuntimeMethodHandle get_EmptyHandle();
    internal IRuntimeMethodInfo GetMethodInfo();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public IntPtr get_Value();
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeMethodHandle handle);
    internal bool IsNullHandle();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static IntPtr GetFunctionPointer(RuntimeMethodHandleInternal handle);
    [SecurityCriticalAttribute]
public IntPtr GetFunctionPointer();
    [SecurityCriticalAttribute]
internal static void CheckLinktimeDemands(IRuntimeMethodInfo method, RuntimeModule module, bool isDecoratedTargetSecurityTransparent);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool IsCAVisibleFromDecoratedType(RuntimeTypeHandle attrTypeHandle, IRuntimeMethodInfo attrCtor, RuntimeTypeHandle sourceTypeHandle, RuntimeModule sourceModule);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeMethodInfo GetCurrentMethod(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static MethodAttributes GetAttributes(RuntimeMethodHandleInternal method);
    [SecurityCriticalAttribute]
internal static MethodAttributes GetAttributes(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static MethodImplAttributes GetImplAttributes(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static string ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format);
    [SecurityCriticalAttribute]
internal static RuntimeType GetDeclaringType(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetDeclaringType(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static int GetSlot(RuntimeMethodHandleInternal method);
    [SecurityCriticalAttribute]
internal static int GetSlot(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static int GetMethodDef(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static string GetName(RuntimeMethodHandleInternal method);
    [SecurityCriticalAttribute]
internal static string GetName(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static Utf8String GetUtf8Name(RuntimeMethodHandleInternal method);
    [SecurityCriticalAttribute]
internal static bool MatchesNameHash(RuntimeMethodHandleInternal method, UInt32 hash);
    [SecuritySafeCriticalAttribute]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static object InvokeMethod(object target, Object[] arguments, Signature sig, bool constructor);
    [SecurityCriticalAttribute]
internal static INVOCATION_FLAGS GetSecurityFlags(IRuntimeMethodInfo handle);
    [SecurityCriticalAttribute]
internal static UInt32 GetSpecialSecurityFlags(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static void PerformSecurityCheck(object obj, RuntimeMethodHandleInternal method, RuntimeType parent, UInt32 invocationFlags);
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal static void PerformSecurityCheck(object obj, IRuntimeMethodInfo method, RuntimeType parent, UInt32 invocationFlags);
    [DebuggerHiddenAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
internal static void SerializationInvoke(IRuntimeMethodInfo method, object target, SerializationInfo info, StreamingContext& context);
    [SecurityCriticalAttribute]
internal static bool _IsTokenSecurityTransparent(RuntimeModule module, int metaDataToken);
    [SecurityCriticalAttribute]
internal static bool IsTokenSecurityTransparent(Module module, int metaDataToken);
    [SecuritySafeCriticalAttribute]
internal static bool IsSecurityCritical(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static bool IsSecuritySafeCritical(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static bool IsSecurityTransparent(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType[] GetMethodInstantiationInternal(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType[] GetMethodInstantiationInternal(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static Type[] GetMethodInstantiationPublic(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static bool HasMethodInstantiation(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static bool HasMethodInstantiation(IRuntimeMethodInfo method);
    [SecurityCriticalAttribute]
internal static RuntimeMethodHandleInternal GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation);
    [SecurityCriticalAttribute]
internal static RuntimeMethodHandleInternal GetMethodFromCanonical(RuntimeMethodHandleInternal method, RuntimeType declaringType);
    [SecurityCriticalAttribute]
internal static bool IsGenericMethodDefinition(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static bool IsGenericMethodDefinition(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static bool IsTypicalMethodDefinition(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeMethodInfo GetTypicalMethodDefinition(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeMethodInfo StripMethodInstantiation(IRuntimeMethodInfo method);
    [SecuritySafeCriticalAttribute]
internal static bool IsDynamicMethod(RuntimeMethodHandleInternal method);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void Destroy(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static Resolver GetResolver(RuntimeMethodHandleInternal method);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetCallerType(StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
internal static MethodBody GetMethodBody(IRuntimeMethodInfo method, RuntimeType declaringType);
    [SecurityCriticalAttribute]
internal static bool IsConstructor(RuntimeMethodHandleInternal method);
    [SecurityCriticalAttribute]
internal static LoaderAllocator GetLoaderAllocator(RuntimeMethodHandleInternal method);
}
internal class System.RuntimeMethodHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal static RuntimeMethodHandleInternal EmptyHandle { get; }
    internal IntPtr Value { get; }
    [SecurityCriticalAttribute]
internal RuntimeMethodHandleInternal(IntPtr value);
    internal static RuntimeMethodHandleInternal get_EmptyHandle();
    internal bool IsNullHandle();
    [SecurityCriticalAttribute]
internal IntPtr get_Value();
}
[ForceTokenStabilizationAttribute]
internal class System.RuntimeMethodInfoStub : object {
    [ForceTokenStabilizationAttribute]
public RuntimeMethodHandleInternal m_value;
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    public RuntimeMethodInfoStub(RuntimeMethodHandleInternal methodHandleValue, object keepalive);
    [SecurityCriticalAttribute]
public RuntimeMethodInfoStub(IntPtr methodHandleValue, object keepalive);
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
}
internal class System.RuntimeType : TypeInfo {
    [ForceTokenStabilizationAttribute]
internal IntPtr m_handle;
    internal static RuntimeType ValueType;
    internal static RuntimeType EnumType;
    internal RemotingTypeCachedData RemotingCache { get; }
    internal bool DomainInitialized { get; internal set; }
    internal INVOCATION_FLAGS InvocationFlags { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public MethodBase DeclaringMethod { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Guid GUID { get; }
    public bool IsEnum { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    internal bool IsSzArray { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool ContainsGenericParameters { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    private static RuntimeType();
    internal RemotingTypeCachedData get_RemotingCache();
    internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark);
    internal static MethodBase GetMethodBase(RuntimeModule scope, int typeMetadataToken);
    internal static MethodBase GetMethodBase(IRuntimeMethodInfo methodHandle);
    [SecuritySafeCriticalAttribute]
internal static MethodBase GetMethodBase(RuntimeType reflectedType, IRuntimeMethodInfo methodHandle);
    [SecurityCriticalAttribute]
internal static MethodBase GetMethodBase(RuntimeType reflectedType, RuntimeMethodHandleInternal methodHandle);
    internal bool get_DomainInitialized();
    internal void set_DomainInitialized(bool value);
    [SecuritySafeCriticalAttribute]
internal static FieldInfo GetFieldInfo(IRuntimeFieldInfo fieldHandle);
    [SecuritySafeCriticalAttribute]
internal static FieldInfo GetFieldInfo(RuntimeType reflectedType, IRuntimeFieldInfo field);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
    [SecuritySafeCriticalAttribute]
internal static void ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    internal bool IsNonW8PFrameworkAPI();
    internal INVOCATION_FLAGS get_InvocationFlags();
    [ReliabilityContractAttribute("3", "2")]
internal virtual bool CacheEquals(object o);
    internal bool IsSpecialSerializableType();
    internal RuntimeConstructorInfo GetSerializationCtor();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [SecuritySafeCriticalAttribute]
public virtual Type[] GetInterfaces();
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [SecuritySafeCriticalAttribute]
public virtual InterfaceMapping GetInterfaceMap(Type ifaceType);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetInterface(string fullname, bool ignoreCase);
    public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual Module get_Module();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal RuntimeModule GetRuntimeModule();
    public virtual Assembly get_Assembly();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal RuntimeAssembly GetRuntimeAssembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal sealed virtual RuntimeTypeHandle GetTypeHandleInternal();
    [SecuritySafeCriticalAttribute]
internal bool IsCollectible();
    [SecuritySafeCriticalAttribute]
protected virtual TypeCode GetTypeCodeImpl();
    public virtual MethodBase get_DeclaringMethod();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool IsInstanceOfType(object o);
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type get_BaseType();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Type get_UnderlyingSystemType();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string get_Namespace();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual TypeAttributes GetAttributeFlagsImpl();
    [SecuritySafeCriticalAttribute]
public virtual Guid get_GUID();
    [SecuritySafeCriticalAttribute]
protected virtual bool IsContextfulImpl();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
protected virtual bool IsCOMObjectImpl();
    [SecuritySafeCriticalAttribute]
internal virtual bool IsWindowsRuntimeObjectImpl();
    [SecuritySafeCriticalAttribute]
internal virtual bool IsExportedToWindowsRuntimeImpl();
    [SecuritySafeCriticalAttribute]
internal virtual bool HasProxyAttributeImpl();
    internal bool IsDelegate();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual bool IsValueTypeImpl();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsEnum();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual bool HasElementTypeImpl();
    [SecuritySafeCriticalAttribute]
public virtual GenericParameterAttributes get_GenericParameterAttributes();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsSecurityCritical();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsSecuritySafeCritical();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsSecurityTransparent();
    internal virtual bool get_IsSzArray();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual bool IsArrayImpl();
    [SecuritySafeCriticalAttribute]
public virtual int GetArrayRank();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Type GetElementType();
    public virtual String[] GetEnumNames();
    [SecuritySafeCriticalAttribute]
public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    [SecuritySafeCriticalAttribute]
public virtual Type MakeGenericType(Type[] instantiation);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsGenericTypeDefinition();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Type GetGenericTypeDefinition();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    [SecuritySafeCriticalAttribute]
public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    [SecuritySafeCriticalAttribute]
public virtual StructLayoutAttribute get_StructLayoutAttribute();
    [SecuritySafeCriticalAttribute]
internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    [DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerHiddenAttribute]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    public static bool op_Equality(RuntimeType left, RuntimeType right);
    public static bool op_Inequality(RuntimeType left, RuntimeType right);
    public virtual string ToString();
    public sealed virtual object Clone();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string get_Name();
    internal virtual string FormatTypeName(bool serialization);
    public virtual MemberTypes get_MemberType();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int get_MetadataToken();
    [SecurityCriticalAttribute]
internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
internal object CreateInstanceSlow(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark);
    internal void InvalidateCachedNestedType();
    [SecuritySafeCriticalAttribute]
internal bool IsGenericCOMObjectImpl();
    [SecuritySafeCriticalAttribute]
internal static object CreateEnum(RuntimeType enumType, long value);
    [SecurityCriticalAttribute]
internal static Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
    [SecurityCriticalAttribute]
internal static Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError);
}
[ComVisibleAttribute("True")]
public class System.RuntimeTypeHandle : ValueType {
    [ForceTokenStabilizationAttribute]
private RuntimeType m_type;
    internal static RuntimeTypeHandle EmptyHandle { get; }
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(RuntimeType type);
    internal RuntimeTypeHandle GetNativeHandle();
    internal RuntimeType GetTypeChecked();
    [SecurityCriticalAttribute]
internal static bool IsInstanceOfType(RuntimeType type, object o);
    [SecuritySafeCriticalAttribute]
internal static Type GetTypeHelper(Type typeStart, Type[] genericArgs, IntPtr pModifiers, int cModifiers);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    internal static RuntimeTypeHandle get_EmptyHandle();
    public virtual int GetHashCode();
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeTypeHandle handle);
    [SecurityCriticalAttribute]
public IntPtr get_Value();
    [ForceTokenStabilizationAttribute]
[SecuritySafeCriticalAttribute]
internal static IntPtr GetValueInternal(RuntimeTypeHandle handle);
    internal bool IsNullHandle();
    [SecuritySafeCriticalAttribute]
internal static bool IsPrimitive(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsByRef(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsPointer(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsArray(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsSzArray(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool HasElementType(RuntimeType type);
    [SecurityCriticalAttribute]
internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
    [SecurityCriticalAttribute]
internal static IntPtr[] CopyRuntimeTypeHandles(Type[] inHandles, Int32& length);
    [SecurityCriticalAttribute]
internal static object CreateInstance(RuntimeType type, bool publicOnly, bool noCheck, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor, Boolean& bNeedSecurityCheck);
    [SecurityCriticalAttribute]
internal static object CreateCaInstance(RuntimeType type, IRuntimeMethodInfo ctor);
    [SecurityCriticalAttribute]
internal static object Allocate(RuntimeType type);
    [SecurityCriticalAttribute]
internal static object CreateInstanceForAnotherGenericParameter(RuntimeType type, RuntimeType genericParameter);
    internal RuntimeType GetRuntimeType();
    [SecurityCriticalAttribute]
internal static CorElementType GetCorElementType(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static RuntimeAssembly GetAssembly(RuntimeType type);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
internal static RuntimeModule GetModule(RuntimeType type);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
public ModuleHandle GetModuleHandle();
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetBaseType(RuntimeType type);
    [SecurityCriticalAttribute]
internal static TypeAttributes GetAttributes(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetElementType(RuntimeType type);
    [SecurityCriticalAttribute]
internal static bool CompareCanonicalHandles(RuntimeType left, RuntimeType right);
    [SecurityCriticalAttribute]
internal static int GetArrayRank(RuntimeType type);
    [SecurityCriticalAttribute]
internal static int GetToken(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static RuntimeMethodHandleInternal GetMethodAt(RuntimeType type, int slot);
    internal static IntroducedMethodEnumerator GetIntroducedMethods(RuntimeType type);
    [SecurityCriticalAttribute]
internal static bool GetFields(RuntimeType type, IntPtr* result, Int32* count);
    [SecurityCriticalAttribute]
internal static Type[] GetInterfaces(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal Type[] GetConstraints();
    [SecurityCriticalAttribute]
internal IntPtr GetGCHandle(GCHandleType type);
    [SecurityCriticalAttribute]
internal static int GetNumVirtuals(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal void VerifyInterfaceIsImplemented(RuntimeTypeHandle interfaceHandle);
    [SecuritySafeCriticalAttribute]
internal int GetInterfaceMethodImplementationSlot(RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    [SecurityCriticalAttribute]
internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    [SecurityCriticalAttribute]
internal static bool IsContextful(RuntimeType type);
    [SecurityCriticalAttribute]
internal static bool IsInterface(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsVisible(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal bool IsSecurityCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsSecuritySafeCritical();
    [SecuritySafeCriticalAttribute]
internal bool IsSecurityTransparent();
    [SecurityCriticalAttribute]
internal static bool HasProxyAttribute(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsValueType(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal string ConstructName(TypeNameFormatFlags formatFlags);
    [SecuritySafeCriticalAttribute]
internal static Utf8String GetUtf8Name(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    [SecurityCriticalAttribute]
internal static RuntimeType GetDeclaringType(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static IRuntimeMethodInfo GetDeclaringMethod(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal IRuntimeMethodInfo GetDefaultConstructor();
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, bool loadTypeFromPartialName);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool loadTypeFromPartialName);
    internal static Type GetTypeByName(string name, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
internal static RuntimeType GetTypeByNameUsingCARules(string name, RuntimeModule scope);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void GetInstantiation(RuntimeTypeHandle type, ObjectHandleOnStack types, bool fAsRuntimeTypeArray);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
internal RuntimeType[] GetInstantiationInternal();
    [SecuritySafeCriticalAttribute]
internal Type[] GetInstantiationPublic();
    [SecurityCriticalAttribute]
internal RuntimeType Instantiate(Type[] inst);
    [SecuritySafeCriticalAttribute]
internal RuntimeType MakeArray(int rank);
    [SecuritySafeCriticalAttribute]
internal RuntimeType MakeSZArray();
    [SecuritySafeCriticalAttribute]
internal RuntimeType MakeByRef();
    [SecurityCriticalAttribute]
internal RuntimeType MakePointer();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool IsCollectible(RuntimeTypeHandle handle);
    internal static bool HasInstantiation(RuntimeType type);
    internal bool HasInstantiation();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
internal static RuntimeType GetGenericTypeDefinition(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsGenericTypeDefinition(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal static bool IsGenericVariable(RuntimeType type);
    internal bool IsGenericVariable();
    [SecuritySafeCriticalAttribute]
internal int GetGenericVariableIndex();
    [SecurityCriticalAttribute]
internal static bool ContainsGenericVariables(RuntimeType handle);
    [SecuritySafeCriticalAttribute]
internal bool ContainsGenericVariables();
    [SecurityCriticalAttribute]
internal static bool SatisfiesConstraints(RuntimeType paramType, RuntimeType[] typeContext, RuntimeType[] methodContext, RuntimeType toType);
    [SecurityCriticalAttribute]
internal static MetadataImport GetMetadataImport(RuntimeType type);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal static bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2);
    [SecuritySafeCriticalAttribute]
internal static bool IsEquivalentType(RuntimeType type);
}
[SecurityCriticalAttribute]
internal class System.SafeTypeNameParserHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    public static sbyte MaxValue;
    public static sbyte MinValue;
    private sbyte m_value;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlActions : Enum {
    public int value__;
    public static AccessControlActions None;
    public static AccessControlActions View;
    public static AccessControlActions Change;
}
public enum System.Security.AccessControl.AccessControlModification : Enum {
    public int value__;
    public static AccessControlModification Add;
    public static AccessControlModification Set;
    public static AccessControlModification Reset;
    public static AccessControlModification Remove;
    public static AccessControlModification RemoveAll;
    public static AccessControlModification RemoveSpecific;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlSections : Enum {
    public int value__;
    public static AccessControlSections None;
    public static AccessControlSections Audit;
    public static AccessControlSections Access;
    public static AccessControlSections Owner;
    public static AccessControlSections Group;
    public static AccessControlSections All;
}
public enum System.Security.AccessControl.AccessControlType : Enum {
    public int value__;
    public static AccessControlType Allow;
    public static AccessControlType Deny;
}
public abstract class System.Security.AccessControl.AccessRule : AuthorizationRule {
    public AccessControlType AccessControlType { get; }
    protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessControlType get_AccessControlType();
}
public class System.Security.AccessControl.AccessRule`1 : AccessRule {
    public T Rights { get; }
    public AccessRule`1(IdentityReference identity, T rights, AccessControlType type);
    public AccessRule`1(string identity, T rights, AccessControlType type);
    public AccessRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal AccessRule`1(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public T get_Rights();
}
public class System.Security.AccessControl.AceEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    public GenericAce Current { get; }
    internal AceEnumerator(GenericAcl collection);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public GenericAce get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[FlagsAttribute]
public enum System.Security.AccessControl.AceFlags : Enum {
    public byte value__;
    public static AceFlags None;
    public static AceFlags ObjectInherit;
    public static AceFlags ContainerInherit;
    public static AceFlags NoPropagateInherit;
    public static AceFlags InheritOnly;
    public static AceFlags Inherited;
    public static AceFlags SuccessfulAccess;
    public static AceFlags FailedAccess;
    public static AceFlags InheritanceFlags;
    public static AceFlags AuditFlags;
}
public enum System.Security.AccessControl.AceQualifier : Enum {
    public int value__;
    public static AceQualifier AccessAllowed;
    public static AceQualifier AccessDenied;
    public static AceQualifier SystemAudit;
    public static AceQualifier SystemAlarm;
}
public enum System.Security.AccessControl.AceType : Enum {
    public byte value__;
    public static AceType AccessAllowed;
    public static AceType AccessDenied;
    public static AceType SystemAudit;
    public static AceType SystemAlarm;
    public static AceType AccessAllowedCompound;
    public static AceType AccessAllowedObject;
    public static AceType AccessDeniedObject;
    public static AceType SystemAuditObject;
    public static AceType SystemAlarmObject;
    public static AceType AccessAllowedCallback;
    public static AceType AccessDeniedCallback;
    public static AceType AccessAllowedCallbackObject;
    public static AceType AccessDeniedCallbackObject;
    public static AceType SystemAuditCallback;
    public static AceType SystemAlarmCallback;
    public static AceType SystemAuditCallbackObject;
    public static AceType SystemAlarmCallbackObject;
    public static AceType MaxDefinedAceType;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AuditFlags : Enum {
    public int value__;
    public static AuditFlags None;
    public static AuditFlags Success;
    public static AuditFlags Failure;
}
public abstract class System.Security.AccessControl.AuditRule : AuthorizationRule {
    public AuditFlags AuditFlags { get; }
    protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    public AuditFlags get_AuditFlags();
}
public class System.Security.AccessControl.AuditRule`1 : AuditRule {
    public T Rights { get; }
    public AuditRule`1(IdentityReference identity, T rights, AuditFlags flags);
    public AuditRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public AuditRule`1(string identity, T rights, AuditFlags flags);
    public AuditRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AuditRule`1(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public T get_Rights();
}
public abstract class System.Security.AccessControl.AuthorizationRule : object {
    public IdentityReference IdentityReference { get; }
    protected internal int AccessMask { get; }
    public bool IsInherited { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public PropagationFlags PropagationFlags { get; }
    protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public IdentityReference get_IdentityReference();
    protected internal int get_AccessMask();
    public bool get_IsInherited();
    public InheritanceFlags get_InheritanceFlags();
    public PropagationFlags get_PropagationFlags();
}
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.AuthorizationRuleCollection : ReadOnlyCollectionBase {
    public AuthorizationRule Item { get; }
    internal void AddRule(AuthorizationRule rule);
    public void CopyTo(AuthorizationRule[] rules, int index);
    public AuthorizationRule get_Item(int index);
}
public class System.Security.AccessControl.CommonAce : QualifiedAce {
    public int BinaryLength { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, Byte[] opaque);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, AceQualifier& qualifier, Int32& accessMask, SecurityIdentifier& sid, Boolean& isCallback, Byte[]& opaque);
    public virtual int get_BinaryLength();
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual int get_MaxOpaqueLengthInternal();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.CommonAcl : GenericAcl {
    internal RawAcl RawAcl { get; }
    public byte Revision { get; }
    public int Count { get; }
    public int BinaryLength { get; }
    public bool IsCanonical { get; }
    public bool IsContainer { get; }
    public bool IsDS { get; }
    public GenericAce Item { get; public set; }
    private static CommonAcl();
    internal CommonAcl(bool isContainer, bool isDS, byte revision, int capacity);
    internal CommonAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted, bool isDacl);
    internal RawAcl get_RawAcl();
    internal void CheckAccessType(AccessControlType accessType);
    internal void CheckFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    internal void AddQualifiedAce(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal void SetQualifiedAce(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal bool RemoveQualifiedAces(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, bool saclSemantics, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal void RemoveQualifiedAcesSpecific(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal virtual void OnAclModificationTried();
    public sealed virtual byte get_Revision();
    public sealed virtual int get_Count();
    public sealed virtual int get_BinaryLength();
    public bool get_IsCanonical();
    public bool get_IsContainer();
    public bool get_IsDS();
    public sealed virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public sealed virtual GenericAce get_Item(int index);
    public sealed virtual void set_Item(int index, GenericAce value);
    public void RemoveInheritedAces();
    public void Purge(SecurityIdentifier sid);
}
public abstract class System.Security.AccessControl.CommonObjectSecurity : ObjectSecurity {
    protected CommonObjectSecurity(bool isContainer);
    internal CommonObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    protected void AddAccessRule(AccessRule rule);
    protected void SetAccessRule(AccessRule rule);
    protected void ResetAccessRule(AccessRule rule);
    protected bool RemoveAccessRule(AccessRule rule);
    protected void RemoveAccessRuleAll(AccessRule rule);
    protected void RemoveAccessRuleSpecific(AccessRule rule);
    protected void AddAuditRule(AuditRule rule);
    protected void SetAuditRule(AuditRule rule);
    protected bool RemoveAuditRule(AuditRule rule);
    protected void RemoveAuditRuleAll(AuditRule rule);
    protected void RemoveAuditRuleSpecific(AuditRule rule);
    public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
}
public class System.Security.AccessControl.CommonSecurityDescriptor : GenericSecurityDescriptor {
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    public bool IsContainer { get; }
    public bool IsDS { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public SystemAcl SystemAcl { get; public set; }
    public DiscretionaryAcl DiscretionaryAcl { get; public set; }
    public bool IsSystemAclCanonical { get; }
    public bool IsDiscretionaryAclCanonical { get; }
    internal bool IsSystemAclPresent { get; }
    internal bool IsDiscretionaryAclPresent { get; }
    public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
    internal CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor, bool trusted);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, Byte[] binaryForm, int offset);
    internal sealed virtual GenericAcl get_GenericSacl();
    internal sealed virtual GenericAcl get_GenericDacl();
    public bool get_IsContainer();
    public bool get_IsDS();
    public virtual ControlFlags get_ControlFlags();
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public SystemAcl get_SystemAcl();
    public void set_SystemAcl(SystemAcl value);
    public DiscretionaryAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(DiscretionaryAcl value);
    public bool get_IsSystemAclCanonical();
    public bool get_IsDiscretionaryAclCanonical();
    public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
    public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
    public void PurgeAccessControl(SecurityIdentifier sid);
    public void PurgeAudit(SecurityIdentifier sid);
    internal void UpdateControlFlags(ControlFlags flagsToUpdate, ControlFlags newFlags);
    internal void AddControlFlags(ControlFlags flags);
    internal void RemoveControlFlags(ControlFlags flags);
    internal bool get_IsSystemAclPresent();
    internal bool get_IsDiscretionaryAclPresent();
}
public class System.Security.AccessControl.CompoundAce : KnownAce {
    public CompoundAceType CompoundAceType { get; public set; }
    public int BinaryLength { get; }
    public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, Int32& accessMask, CompoundAceType& compoundAceType, SecurityIdentifier& sid);
    public CompoundAceType get_CompoundAceType();
    public void set_CompoundAceType(CompoundAceType value);
    public virtual int get_BinaryLength();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
public enum System.Security.AccessControl.CompoundAceType : Enum {
    public int value__;
    public static CompoundAceType Impersonation;
}
[FlagsAttribute]
public enum System.Security.AccessControl.ControlFlags : Enum {
    public int value__;
    public static ControlFlags None;
    public static ControlFlags OwnerDefaulted;
    public static ControlFlags GroupDefaulted;
    public static ControlFlags DiscretionaryAclPresent;
    public static ControlFlags DiscretionaryAclDefaulted;
    public static ControlFlags SystemAclPresent;
    public static ControlFlags SystemAclDefaulted;
    public static ControlFlags DiscretionaryAclUntrusted;
    public static ControlFlags ServerSecurity;
    public static ControlFlags DiscretionaryAclAutoInheritRequired;
    public static ControlFlags SystemAclAutoInheritRequired;
    public static ControlFlags DiscretionaryAclAutoInherited;
    public static ControlFlags SystemAclAutoInherited;
    public static ControlFlags DiscretionaryAclProtected;
    public static ControlFlags SystemAclProtected;
    public static ControlFlags RMControlValid;
    public static ControlFlags SelfRelative;
}
public class System.Security.AccessControl.CryptoKeyAccessRule : AccessRule {
    public CryptoKeyRights CryptoKeyRights { get; }
    public CryptoKeyAccessRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
    public CryptoKeyAccessRule(string identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
    public CryptoKeyRights get_CryptoKeyRights();
    internal static CryptoKeyRights RightsFromAccessMask(int accessMask);
}
public class System.Security.AccessControl.CryptoKeyAuditRule : AuditRule {
    public CryptoKeyRights CryptoKeyRights { get; }
    public CryptoKeyAuditRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
    public CryptoKeyAuditRule(string identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
    public CryptoKeyRights get_CryptoKeyRights();
    internal static CryptoKeyRights RightsFromAccessMask(int accessMask);
}
[FlagsAttribute]
public enum System.Security.AccessControl.CryptoKeyRights : Enum {
    public int value__;
    public static CryptoKeyRights ReadData;
    public static CryptoKeyRights WriteData;
    public static CryptoKeyRights ReadExtendedAttributes;
    public static CryptoKeyRights WriteExtendedAttributes;
    public static CryptoKeyRights ReadAttributes;
    public static CryptoKeyRights WriteAttributes;
    public static CryptoKeyRights Delete;
    public static CryptoKeyRights ReadPermissions;
    public static CryptoKeyRights ChangePermissions;
    public static CryptoKeyRights TakeOwnership;
    public static CryptoKeyRights Synchronize;
    public static CryptoKeyRights FullControl;
    public static CryptoKeyRights GenericAll;
    public static CryptoKeyRights GenericExecute;
    public static CryptoKeyRights GenericWrite;
    public static CryptoKeyRights GenericRead;
}
public class System.Security.AccessControl.CryptoKeySecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    internal AccessControlSections ChangedAccessControlSections { get; }
    [SecuritySafeCriticalAttribute]
public CryptoKeySecurity(CommonSecurityDescriptor securityDescriptor);
    public sealed virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAccessRule(CryptoKeyAccessRule rule);
    public void SetAccessRule(CryptoKeyAccessRule rule);
    public void ResetAccessRule(CryptoKeyAccessRule rule);
    public bool RemoveAccessRule(CryptoKeyAccessRule rule);
    public void RemoveAccessRuleAll(CryptoKeyAccessRule rule);
    public void RemoveAccessRuleSpecific(CryptoKeyAccessRule rule);
    public void AddAuditRule(CryptoKeyAuditRule rule);
    public void SetAuditRule(CryptoKeyAuditRule rule);
    public bool RemoveAuditRule(CryptoKeyAuditRule rule);
    public void RemoveAuditRuleAll(CryptoKeyAuditRule rule);
    public void RemoveAuditRuleSpecific(CryptoKeyAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    [SecurityCriticalAttribute]
internal AccessControlSections get_ChangedAccessControlSections();
}
public class System.Security.AccessControl.CustomAce : GenericAce {
    public static int MaxOpaqueLength;
    public int OpaqueLength { get; }
    public int BinaryLength { get; }
    public CustomAce(AceType type, AceFlags flags, Byte[] opaque);
    private static CustomAce();
    public int get_OpaqueLength();
    public virtual int get_BinaryLength();
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
public abstract class System.Security.AccessControl.DirectoryObjectSecurity : ObjectSecurity {
    protected DirectoryObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    protected void AddAccessRule(ObjectAccessRule rule);
    protected void SetAccessRule(ObjectAccessRule rule);
    protected void ResetAccessRule(ObjectAccessRule rule);
    protected bool RemoveAccessRule(ObjectAccessRule rule);
    protected void RemoveAccessRuleAll(ObjectAccessRule rule);
    protected void RemoveAccessRuleSpecific(ObjectAccessRule rule);
    protected void AddAuditRule(ObjectAuditRule rule);
    protected void SetAuditRule(ObjectAuditRule rule);
    protected bool RemoveAuditRule(ObjectAuditRule rule);
    protected void RemoveAuditRuleAll(ObjectAuditRule rule);
    protected void RemoveAuditRuleSpecific(ObjectAuditRule rule);
    public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
}
public class System.Security.AccessControl.DirectorySecurity : FileSystemSecurity {
    [SecuritySafeCriticalAttribute]
public DirectorySecurity(string name, AccessControlSections includeSections);
}
public class System.Security.AccessControl.DiscretionaryAcl : CommonAcl {
    internal bool EveryOneFullAccessForNullDacl { get; internal set; }
    public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
    public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
    public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    internal DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted);
    private static DiscretionaryAcl();
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal bool get_EveryOneFullAccessForNullDacl();
    internal void set_EveryOneFullAccessForNullDacl(bool value);
    internal virtual void OnAclModificationTried();
    internal static DiscretionaryAcl CreateAllowEveryoneFullAccess(bool isDS, bool isContainer);
}
public class System.Security.AccessControl.EventWaitHandleAccessRule : AccessRule {
    public EventWaitHandleRights EventWaitHandleRights { get; }
    public EventWaitHandleAccessRule(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type);
    public EventWaitHandleAccessRule(string identity, EventWaitHandleRights eventRights, AccessControlType type);
    internal EventWaitHandleAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public EventWaitHandleRights get_EventWaitHandleRights();
}
public class System.Security.AccessControl.EventWaitHandleAuditRule : AuditRule {
    public EventWaitHandleRights EventWaitHandleRights { get; }
    public EventWaitHandleAuditRule(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags);
    internal EventWaitHandleAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public EventWaitHandleRights get_EventWaitHandleRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.EventWaitHandleRights : Enum {
    public int value__;
    public static EventWaitHandleRights Modify;
    public static EventWaitHandleRights Delete;
    public static EventWaitHandleRights ReadPermissions;
    public static EventWaitHandleRights ChangePermissions;
    public static EventWaitHandleRights TakeOwnership;
    public static EventWaitHandleRights Synchronize;
    public static EventWaitHandleRights FullControl;
}
public class System.Security.AccessControl.EventWaitHandleSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    [SecurityCriticalAttribute]
internal EventWaitHandleSecurity(string name, AccessControlSections includeSections);
    [SecurityCriticalAttribute]
internal EventWaitHandleSecurity(SafeWaitHandle handle, AccessControlSections includeSections);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    [SecurityCriticalAttribute]
internal void Persist(SafeWaitHandle handle);
    public void AddAccessRule(EventWaitHandleAccessRule rule);
    public void SetAccessRule(EventWaitHandleAccessRule rule);
    public void ResetAccessRule(EventWaitHandleAccessRule rule);
    public bool RemoveAccessRule(EventWaitHandleAccessRule rule);
    public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule);
    public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule);
    public void AddAuditRule(EventWaitHandleAuditRule rule);
    public void SetAuditRule(EventWaitHandleAuditRule rule);
    public bool RemoveAuditRule(EventWaitHandleAuditRule rule);
    public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule);
    public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public class System.Security.AccessControl.FileSecurity : FileSystemSecurity {
    [SecuritySafeCriticalAttribute]
public FileSecurity(string fileName, AccessControlSections includeSections);
    [SecurityCriticalAttribute]
internal FileSecurity(SafeFileHandle handle, string fullPath, AccessControlSections includeSections);
}
public class System.Security.AccessControl.FileSystemAccessRule : AccessRule {
    public FileSystemRights FileSystemRights { get; }
    public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type);
    public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, AccessControlType type);
    public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal FileSystemAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public FileSystemRights get_FileSystemRights();
    internal static int AccessMaskFromRights(FileSystemRights fileSystemRights, AccessControlType controlType);
    internal static FileSystemRights RightsFromAccessMask(int accessMask);
}
public class System.Security.AccessControl.FileSystemAuditRule : AuditRule {
    public FileSystemRights FileSystemRights { get; }
    public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags);
    public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, AuditFlags flags);
    public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal FileSystemAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public FileSystemRights get_FileSystemRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.FileSystemRights : Enum {
    public int value__;
    public static FileSystemRights ReadData;
    public static FileSystemRights ListDirectory;
    public static FileSystemRights WriteData;
    public static FileSystemRights CreateFiles;
    public static FileSystemRights AppendData;
    public static FileSystemRights CreateDirectories;
    public static FileSystemRights ReadExtendedAttributes;
    public static FileSystemRights WriteExtendedAttributes;
    public static FileSystemRights ExecuteFile;
    public static FileSystemRights Traverse;
    public static FileSystemRights DeleteSubdirectoriesAndFiles;
    public static FileSystemRights ReadAttributes;
    public static FileSystemRights WriteAttributes;
    public static FileSystemRights Delete;
    public static FileSystemRights ReadPermissions;
    public static FileSystemRights ChangePermissions;
    public static FileSystemRights TakeOwnership;
    public static FileSystemRights Synchronize;
    public static FileSystemRights FullControl;
    public static FileSystemRights Read;
    public static FileSystemRights ReadAndExecute;
    public static FileSystemRights Write;
    public static FileSystemRights Modify;
}
public abstract class System.Security.AccessControl.FileSystemSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    [SecurityCriticalAttribute]
internal FileSystemSecurity(bool isContainer);
    [SecurityCriticalAttribute]
internal FileSystemSecurity(bool isContainer, string name, AccessControlSections includeSections, bool isDirectory);
    [SecurityCriticalAttribute]
internal FileSystemSecurity(bool isContainer, SafeFileHandle handle, AccessControlSections includeSections, bool isDirectory);
    public sealed virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    [SecurityCriticalAttribute]
internal void Persist(string fullPath);
    [SecuritySafeCriticalAttribute]
internal void Persist(SafeFileHandle handle, string fullPath);
    public void AddAccessRule(FileSystemAccessRule rule);
    public void SetAccessRule(FileSystemAccessRule rule);
    public void ResetAccessRule(FileSystemAccessRule rule);
    public bool RemoveAccessRule(FileSystemAccessRule rule);
    public void RemoveAccessRuleAll(FileSystemAccessRule rule);
    public void RemoveAccessRuleSpecific(FileSystemAccessRule rule);
    public void AddAuditRule(FileSystemAuditRule rule);
    public void SetAuditRule(FileSystemAuditRule rule);
    public bool RemoveAuditRule(FileSystemAuditRule rule);
    public void RemoveAuditRuleAll(FileSystemAuditRule rule);
    public void RemoveAuditRuleSpecific(FileSystemAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public abstract class System.Security.AccessControl.GenericAce : object {
    internal static int HeaderLength;
    internal ushort _indexInAcl;
    public AceType AceType { get; }
    public AceFlags AceFlags { get; public set; }
    public bool IsInherited { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public PropagationFlags PropagationFlags { get; }
    public AuditFlags AuditFlags { get; }
    public int BinaryLength { get; }
    internal GenericAce(AceType type, AceFlags flags);
    internal void MarshalHeader(Byte[] binaryForm, int offset);
    internal static AceFlags AceFlagsFromAuditFlags(AuditFlags auditFlags);
    internal static AceFlags AceFlagsFromInheritanceFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    internal static void VerifyHeader(Byte[] binaryForm, int offset);
    public static GenericAce CreateFromBinaryForm(Byte[] binaryForm, int offset);
    public AceType get_AceType();
    public AceFlags get_AceFlags();
    public void set_AceFlags(AceFlags value);
    public bool get_IsInherited();
    public InheritanceFlags get_InheritanceFlags();
    public PropagationFlags get_PropagationFlags();
    public AuditFlags get_AuditFlags();
    public abstract virtual int get_BinaryLength();
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public GenericAce Copy();
    public sealed virtual bool Equals(object o);
    public sealed virtual int GetHashCode();
    public static bool op_Equality(GenericAce left, GenericAce right);
    public static bool op_Inequality(GenericAce left, GenericAce right);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.GenericAcl : object {
    internal static int HeaderLength;
    public static byte AclRevision;
    public static byte AclRevisionDS;
    public static int MaxBinaryLength;
    public byte Revision { get; }
    public int BinaryLength { get; }
    public GenericAce Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private static GenericAcl();
    public abstract virtual byte get_Revision();
    public abstract virtual int get_BinaryLength();
    public abstract virtual GenericAce get_Item(int index);
    public abstract virtual void set_Item(int index, GenericAce value);
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(GenericAce[] array, int index);
    public abstract virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public AceEnumerator GetEnumerator();
}
public abstract class System.Security.AccessControl.GenericSecurityDescriptor : object {
    internal static int HeaderLength;
    internal static int OwnerFoundAt;
    internal static int GroupFoundAt;
    internal static int SaclFoundAt;
    internal static int DaclFoundAt;
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    public static byte Revision { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public int BinaryLength { get; }
    internal static int UnmarshalInt(Byte[] binaryForm, int offset);
    internal abstract virtual GenericAcl get_GenericSacl();
    internal abstract virtual GenericAcl get_GenericDacl();
    public static bool IsSddlConversionSupported();
    public static byte get_Revision();
    public abstract virtual ControlFlags get_ControlFlags();
    public abstract virtual SecurityIdentifier get_Owner();
    public abstract virtual void set_Owner(SecurityIdentifier value);
    public abstract virtual SecurityIdentifier get_Group();
    public abstract virtual void set_Group(SecurityIdentifier value);
    public int get_BinaryLength();
    [SecuritySafeCriticalAttribute]
public string GetSddlForm(AccessControlSections includeSections);
    public void GetBinaryForm(Byte[] binaryForm, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.InheritanceFlags : Enum {
    public int value__;
    public static InheritanceFlags None;
    public static InheritanceFlags ContainerInherit;
    public static InheritanceFlags ObjectInherit;
}
public abstract class System.Security.AccessControl.KnownAce : GenericAce {
    internal static int AccessMaskLength;
    public int AccessMask { get; public set; }
    public SecurityIdentifier SecurityIdentifier { get; public set; }
    internal KnownAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier securityIdentifier);
    public int get_AccessMask();
    public void set_AccessMask(int value);
    public SecurityIdentifier get_SecurityIdentifier();
    public void set_SecurityIdentifier(SecurityIdentifier value);
}
public class System.Security.AccessControl.MutexAccessRule : AccessRule {
    public MutexRights MutexRights { get; }
    public MutexAccessRule(IdentityReference identity, MutexRights eventRights, AccessControlType type);
    public MutexAccessRule(string identity, MutexRights eventRights, AccessControlType type);
    internal MutexAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public MutexRights get_MutexRights();
}
public class System.Security.AccessControl.MutexAuditRule : AuditRule {
    public MutexRights MutexRights { get; }
    public MutexAuditRule(IdentityReference identity, MutexRights eventRights, AuditFlags flags);
    internal MutexAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public MutexRights get_MutexRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.MutexRights : Enum {
    public int value__;
    public static MutexRights Modify;
    public static MutexRights Delete;
    public static MutexRights ReadPermissions;
    public static MutexRights ChangePermissions;
    public static MutexRights TakeOwnership;
    public static MutexRights Synchronize;
    public static MutexRights FullControl;
}
public class System.Security.AccessControl.MutexSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    [SecuritySafeCriticalAttribute]
public MutexSecurity(string name, AccessControlSections includeSections);
    [SecurityCriticalAttribute]
internal MutexSecurity(SafeWaitHandle handle, AccessControlSections includeSections);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    [SecurityCriticalAttribute]
internal void Persist(SafeWaitHandle handle);
    public void AddAccessRule(MutexAccessRule rule);
    public void SetAccessRule(MutexAccessRule rule);
    public void ResetAccessRule(MutexAccessRule rule);
    public bool RemoveAccessRule(MutexAccessRule rule);
    public void RemoveAccessRuleAll(MutexAccessRule rule);
    public void RemoveAccessRuleSpecific(MutexAccessRule rule);
    public void AddAuditRule(MutexAuditRule rule);
    public void SetAuditRule(MutexAuditRule rule);
    public bool RemoveAuditRule(MutexAuditRule rule);
    public void RemoveAuditRuleAll(MutexAuditRule rule);
    public void RemoveAuditRuleSpecific(MutexAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public abstract class System.Security.AccessControl.NativeObjectSecurity : CommonObjectSecurity {
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    [SecurityCriticalAttribute]
internal NativeObjectSecurity(ResourceType resourceType, CommonSecurityDescriptor securityDescriptor);
    [SecurityCriticalAttribute]
internal NativeObjectSecurity(ResourceType resourceType, CommonSecurityDescriptor securityDescriptor, ExceptionFromErrorCode exceptionFromErrorCode);
    [SecuritySafeCriticalAttribute]
protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    [SecuritySafeCriticalAttribute]
protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
    protected sealed virtual void Persist(string name, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
    [SecuritySafeCriticalAttribute]
protected sealed virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
}
public abstract class System.Security.AccessControl.ObjectAccessRule : AccessRule {
    public Guid ObjectType { get; }
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
    public Guid get_ObjectType();
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
}
public class System.Security.AccessControl.ObjectAce : QualifiedAce {
    internal static int AccessMaskWithObjectType;
    public ObjectAceFlags ObjectAceFlags { get; public set; }
    public Guid ObjectAceType { get; public set; }
    public Guid InheritedObjectAceType { get; public set; }
    public int BinaryLength { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, Byte[] opaque);
    private static ObjectAce();
    internal bool ObjectTypesMatch(ObjectAceFlags objectFlags, Guid objectType);
    internal bool InheritedObjectTypesMatch(ObjectAceFlags objectFlags, Guid inheritedObjectType);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, AceQualifier& qualifier, Int32& accessMask, SecurityIdentifier& sid, ObjectAceFlags& objectFlags, Guid& objectAceType, Guid& inheritedObjectAceType, Boolean& isCallback, Byte[]& opaque);
    public ObjectAceFlags get_ObjectAceFlags();
    public void set_ObjectAceFlags(ObjectAceFlags value);
    public Guid get_ObjectAceType();
    public void set_ObjectAceType(Guid value);
    public Guid get_InheritedObjectAceType();
    public void set_InheritedObjectAceType(Guid value);
    public virtual int get_BinaryLength();
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual int get_MaxOpaqueLengthInternal();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.ObjectAceFlags : Enum {
    public int value__;
    public static ObjectAceFlags None;
    public static ObjectAceFlags ObjectAceTypePresent;
    public static ObjectAceFlags InheritedObjectAceTypePresent;
}
public abstract class System.Security.AccessControl.ObjectAuditRule : AuditRule {
    public Guid ObjectType { get; }
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
    public Guid get_ObjectType();
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
}
public abstract class System.Security.AccessControl.ObjectSecurity : object {
    internal CommonSecurityDescriptor _securityDescriptor;
    protected bool OwnerModified { get; protected set; }
    protected bool GroupModified { get; protected set; }
    protected bool AuditRulesModified { get; protected set; }
    protected bool AccessRulesModified { get; protected set; }
    protected bool IsContainer { get; }
    protected bool IsDS { get; }
    public bool AreAccessRulesProtected { get; }
    public bool AreAuditRulesProtected { get; }
    public bool AreAccessRulesCanonical { get; }
    public bool AreAuditRulesCanonical { get; }
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    protected ObjectSecurity(bool isContainer, bool isDS);
    internal ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    private static ObjectSecurity();
    protected void ReadLock();
    protected void ReadUnlock();
    protected void WriteLock();
    protected void WriteUnlock();
    protected bool get_OwnerModified();
    protected void set_OwnerModified(bool value);
    protected bool get_GroupModified();
    protected void set_GroupModified(bool value);
    protected bool get_AuditRulesModified();
    protected void set_AuditRulesModified(bool value);
    protected bool get_AccessRulesModified();
    protected void set_AccessRulesModified(bool value);
    protected bool get_IsContainer();
    protected bool get_IsDS();
    protected virtual void Persist(string name, AccessControlSections includeSections);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecuritySafeCriticalAttribute]
protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    public IdentityReference GetOwner(Type targetType);
    public void SetOwner(IdentityReference identity);
    public IdentityReference GetGroup(Type targetType);
    public void SetGroup(IdentityReference identity);
    public virtual void PurgeAccessRules(IdentityReference identity);
    public virtual void PurgeAuditRules(IdentityReference identity);
    public bool get_AreAccessRulesProtected();
    public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
    public bool get_AreAuditRulesProtected();
    public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
    public bool get_AreAccessRulesCanonical();
    public bool get_AreAuditRulesCanonical();
    public static bool IsSddlConversionSupported();
    public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
    public void SetSecurityDescriptorSddlForm(string sddlForm);
    public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
    public Byte[] GetSecurityDescriptorBinaryForm();
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm);
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm, AccessControlSections includeSections);
    public abstract virtual Type get_AccessRightType();
    public abstract virtual Type get_AccessRuleType();
    public abstract virtual Type get_AuditRuleType();
    protected abstract virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected abstract virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, Boolean& modified);
    public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, Boolean& modified);
    public abstract virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public abstract virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
}
public abstract class System.Security.AccessControl.ObjectSecurity`1 : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    [SecuritySafeCriticalAttribute]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
    [SecuritySafeCriticalAttribute]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    [SecuritySafeCriticalAttribute]
protected internal void Persist(SafeHandle handle);
    [SecuritySafeCriticalAttribute]
protected internal void Persist(string name);
    public virtual void AddAccessRule(AccessRule`1<T> rule);
    public virtual void SetAccessRule(AccessRule`1<T> rule);
    public virtual void ResetAccessRule(AccessRule`1<T> rule);
    public virtual bool RemoveAccessRule(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleAll(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleSpecific(AccessRule`1<T> rule);
    public virtual void AddAuditRule(AuditRule`1<T> rule);
    public virtual void SetAuditRule(AuditRule`1<T> rule);
    public virtual bool RemoveAuditRule(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleAll(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleSpecific(AuditRule`1<T> rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
internal class System.Security.AccessControl.Privilege : object {
    public static string CreateToken;
    public static string AssignPrimaryToken;
    public static string LockMemory;
    public static string IncreaseQuota;
    public static string UnsolicitedInput;
    public static string MachineAccount;
    public static string TrustedComputingBase;
    public static string Security;
    public static string TakeOwnership;
    public static string LoadDriver;
    public static string SystemProfile;
    public static string SystemTime;
    public static string ProfileSingleProcess;
    public static string IncreaseBasePriority;
    public static string CreatePageFile;
    public static string CreatePermanent;
    public static string Backup;
    public static string Restore;
    public static string Shutdown;
    public static string Debug;
    public static string Audit;
    public static string SystemEnvironment;
    public static string ChangeNotify;
    public static string RemoteShutdown;
    public static string Undock;
    public static string SyncAgent;
    public static string EnableDelegation;
    public static string ManageVolume;
    public static string Impersonate;
    public static string CreateGlobal;
    public static string TrustedCredentialManagerAccess;
    public static string ReserveProcessor;
    public bool NeedToRevert { get; }
    [SecurityCriticalAttribute]
public Privilege(string privilegeName);
    private static Privilege();
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public void Enable();
    public bool get_NeedToRevert();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public void Revert();
}
public class System.Security.AccessControl.PrivilegeNotHeldException : UnauthorizedAccessException {
    public string PrivilegeName { get; }
    public PrivilegeNotHeldException(string privilege);
    public PrivilegeNotHeldException(string privilege, Exception inner);
    internal PrivilegeNotHeldException(SerializationInfo info, StreamingContext context);
    public string get_PrivilegeName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Security.AccessControl.PropagationFlags : Enum {
    public int value__;
    public static PropagationFlags None;
    public static PropagationFlags NoPropagateInherit;
    public static PropagationFlags InheritOnly;
}
public abstract class System.Security.AccessControl.QualifiedAce : KnownAce {
    public AceQualifier AceQualifier { get; }
    public bool IsCallback { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public int OpaqueLength { get; }
    internal QualifiedAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, Byte[] opaque);
    public AceQualifier get_AceQualifier();
    public bool get_IsCallback();
    internal abstract virtual int get_MaxOpaqueLengthInternal();
    public int get_OpaqueLength();
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
}
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.RawAcl : GenericAcl {
    public byte Revision { get; }
    public int Count { get; }
    public int BinaryLength { get; }
    public GenericAce Item { get; public set; }
    public RawAcl(byte revision, int capacity);
    public RawAcl(Byte[] binaryForm, int offset);
    internal void SetBinaryForm(Byte[] binaryForm, int offset);
    public virtual byte get_Revision();
    public virtual int get_Count();
    public virtual int get_BinaryLength();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public virtual GenericAce get_Item(int index);
    public virtual void set_Item(int index, GenericAce value);
    public void InsertAce(int index, GenericAce ace);
    public void RemoveAce(int index);
}
public class System.Security.AccessControl.RawSecurityDescriptor : GenericSecurityDescriptor {
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public RawAcl SystemAcl { get; public set; }
    public RawAcl DiscretionaryAcl { get; public set; }
    public byte ResourceManagerControl { get; public set; }
    public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
    [SecuritySafeCriticalAttribute]
public RawSecurityDescriptor(string sddlForm);
    public RawSecurityDescriptor(Byte[] binaryForm, int offset);
    internal virtual GenericAcl get_GenericSacl();
    internal virtual GenericAcl get_GenericDacl();
    public virtual ControlFlags get_ControlFlags();
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public RawAcl get_SystemAcl();
    public void set_SystemAcl(RawAcl value);
    public RawAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(RawAcl value);
    public byte get_ResourceManagerControl();
    public void set_ResourceManagerControl(byte value);
    public void SetFlags(ControlFlags flags);
}
public class System.Security.AccessControl.RegistryAccessRule : AccessRule {
    public RegistryRights RegistryRights { get; }
    public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, AccessControlType type);
    public RegistryAccessRule(string identity, RegistryRights registryRights, AccessControlType type);
    public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public RegistryAccessRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal RegistryAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public RegistryRights get_RegistryRights();
}
public class System.Security.AccessControl.RegistryAuditRule : AuditRule {
    public RegistryRights RegistryRights { get; }
    public RegistryAuditRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public RegistryAuditRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal RegistryAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public RegistryRights get_RegistryRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.RegistryRights : Enum {
    public int value__;
    public static RegistryRights QueryValues;
    public static RegistryRights SetValue;
    public static RegistryRights CreateSubKey;
    public static RegistryRights EnumerateSubKeys;
    public static RegistryRights Notify;
    public static RegistryRights CreateLink;
    public static RegistryRights ExecuteKey;
    public static RegistryRights ReadKey;
    public static RegistryRights WriteKey;
    public static RegistryRights Delete;
    public static RegistryRights ReadPermissions;
    public static RegistryRights ChangePermissions;
    public static RegistryRights TakeOwnership;
    public static RegistryRights FullControl;
}
public class System.Security.AccessControl.RegistrySecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    [SecurityCriticalAttribute]
internal RegistrySecurity(SafeRegistryHandle hKey, string name, AccessControlSections includeSections);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    [SecurityCriticalAttribute]
internal void Persist(SafeRegistryHandle hKey, string keyName);
    public void AddAccessRule(RegistryAccessRule rule);
    public void SetAccessRule(RegistryAccessRule rule);
    public void ResetAccessRule(RegistryAccessRule rule);
    public bool RemoveAccessRule(RegistryAccessRule rule);
    public void RemoveAccessRuleAll(RegistryAccessRule rule);
    public void RemoveAccessRuleSpecific(RegistryAccessRule rule);
    public void AddAuditRule(RegistryAuditRule rule);
    public void SetAuditRule(RegistryAuditRule rule);
    public bool RemoveAuditRule(RegistryAuditRule rule);
    public void RemoveAuditRuleAll(RegistryAuditRule rule);
    public void RemoveAuditRuleSpecific(RegistryAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public enum System.Security.AccessControl.ResourceType : Enum {
    public int value__;
    public static ResourceType Unknown;
    public static ResourceType FileObject;
    public static ResourceType Service;
    public static ResourceType Printer;
    public static ResourceType RegistryKey;
    public static ResourceType LMShare;
    public static ResourceType KernelObject;
    public static ResourceType WindowObject;
    public static ResourceType DSObject;
    public static ResourceType DSObjectAll;
    public static ResourceType ProviderDefined;
    public static ResourceType WmiGuidObject;
    public static ResourceType RegistryWow6432Key;
}
[FlagsAttribute]
public enum System.Security.AccessControl.SecurityInfos : Enum {
    public int value__;
    public static SecurityInfos Owner;
    public static SecurityInfos Group;
    public static SecurityInfos DiscretionaryAcl;
    public static SecurityInfos SystemAcl;
}
public class System.Security.AccessControl.SystemAcl : CommonAcl {
    public SystemAcl(bool isContainer, bool isDS, int capacity);
    public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
    public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    internal SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
}
internal static class System.Security.AccessControl.Win32 : object {
    internal static int TRUE;
    [SecurityCriticalAttribute]
internal static int ConvertSdToSddl(Byte[] binaryForm, int requestedRevision, SecurityInfos si, String& resultSddl);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static int GetSecurityInfo(ResourceType resourceType, string name, SafeHandle handle, AccessControlSections accessControlSections, RawSecurityDescriptor& resultSd);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecuritySafeCriticalAttribute]
internal static int SetSecurityInfo(ResourceType type, string name, SafeHandle handle, SecurityInfos securityInformation, SecurityIdentifier owner, SecurityIdentifier group, GenericAcl sacl, GenericAcl dacl);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
internal static class System.Security.BuiltInPermissionSets : object {
    internal static NamedPermissionSet Everything { get; }
    internal static NamedPermissionSet Execution { get; }
    internal static NamedPermissionSet FullTrust { get; }
    internal static NamedPermissionSet Internet { get; }
    internal static NamedPermissionSet LocalIntranet { get; }
    internal static NamedPermissionSet Nothing { get; }
    internal static NamedPermissionSet SkipVerification { get; }
    private static BuiltInPermissionSets();
    internal static NamedPermissionSet get_Everything();
    internal static NamedPermissionSet get_Execution();
    internal static NamedPermissionSet get_FullTrust();
    internal static NamedPermissionSet get_Internet();
    internal static NamedPermissionSet get_LocalIntranet();
    internal static NamedPermissionSet get_Nothing();
    internal static NamedPermissionSet get_SkipVerification();
}
public class System.Security.Claims.Claim : object {
    public string Issuer { get; }
    public string OriginalIssuer { get; }
    public IDictionary`2<string, string> Properties { get; }
    public ClaimsIdentity Subject { get; internal set; }
    public string Type { get; }
    public string Value { get; }
    public string ValueType { get; }
    public Claim(string type, string value);
    public Claim(string type, string value, string valueType);
    public Claim(string type, string value, string valueType, string issuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject);
    internal Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject, string propertyKey, string propertyValue);
    public string get_Issuer();
    public string get_OriginalIssuer();
    public IDictionary`2<string, string> get_Properties();
    public ClaimsIdentity get_Subject();
    internal void set_Subject(ClaimsIdentity value);
    public string get_Type();
    public string get_Value();
    public string get_ValueType();
    public virtual Claim Clone();
    public virtual Claim Clone(ClaimsIdentity identity);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Claims.ClaimsIdentity : object {
    public static string DefaultIssuer;
    public static string DefaultNameClaimType;
    public static string DefaultRoleClaimType;
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public ClaimsIdentity Actor { get; public set; }
    public object BootstrapContext { get; public set; }
    public IEnumerable`1<Claim> Claims { get; }
    internal Collection`1<IEnumerable`1<Claim>> ExternalClaims { get; }
    public string Label { get; public set; }
    public string Name { get; }
    public string NameClaimType { get; }
    public string RoleClaimType { get; }
    public ClaimsIdentity(IIdentity identity);
    public ClaimsIdentity(IEnumerable`1<Claim> claims);
    public ClaimsIdentity(string authenticationType);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims);
    public ClaimsIdentity(string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    internal ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType, bool checkAuthType);
    [SecurityCriticalAttribute]
protected ClaimsIdentity(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected ClaimsIdentity(SerializationInfo info);
    public virtual string get_AuthenticationType();
    public virtual bool get_IsAuthenticated();
    public ClaimsIdentity get_Actor();
    public void set_Actor(ClaimsIdentity value);
    public object get_BootstrapContext();
    [SecurityCriticalAttribute]
public void set_BootstrapContext(object value);
    public virtual IEnumerable`1<Claim> get_Claims();
    [FriendAccessAllowedAttribute]
internal Collection`1<IEnumerable`1<Claim>> get_ExternalClaims();
    public string get_Label();
    public void set_Label(string value);
    public virtual string get_Name();
    public string get_NameClaimType();
    public string get_RoleClaimType();
    public virtual ClaimsIdentity Clone();
    [SecurityCriticalAttribute]
public virtual void AddClaim(Claim claim);
    [SecurityCriticalAttribute]
public virtual void AddClaims(IEnumerable`1<Claim> claims);
    [SecurityCriticalAttribute]
public virtual bool TryRemoveClaim(Claim claim);
    [SecurityCriticalAttribute]
public virtual void RemoveClaim(Claim claim);
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Security.Claims.ClaimsPrincipal : object {
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector { get; public set; }
    public static Func`1<ClaimsPrincipal> ClaimsPrincipalSelector { get; public set; }
    public IEnumerable`1<Claim> Claims { get; }
    public static ClaimsPrincipal Current { get; }
    public IEnumerable`1<ClaimsIdentity> Identities { get; }
    public IIdentity Identity { get; }
    public ClaimsPrincipal(IEnumerable`1<ClaimsIdentity> identities);
    public ClaimsPrincipal(IIdentity identity);
    public ClaimsPrincipal(IPrincipal principal);
    [SecurityCriticalAttribute]
protected ClaimsPrincipal(SerializationInfo info, StreamingContext context);
    private static ClaimsPrincipal();
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> get_PrimaryIdentitySelector();
    [SecurityCriticalAttribute]
public static void set_PrimaryIdentitySelector(Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> value);
    public static Func`1<ClaimsPrincipal> get_ClaimsPrincipalSelector();
    [SecurityCriticalAttribute]
public static void set_ClaimsPrincipalSelector(Func`1<ClaimsPrincipal> value);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void AddIdentity(ClaimsIdentity identity);
    [SecurityCriticalAttribute]
public virtual void AddIdentities(IEnumerable`1<ClaimsIdentity> identities);
    public virtual IEnumerable`1<Claim> get_Claims();
    public static ClaimsPrincipal get_Current();
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual IEnumerable`1<ClaimsIdentity> get_Identities();
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(string role);
}
[ComVisibleAttribute("False")]
public static class System.Security.Claims.ClaimTypes : object {
    internal static string ClaimTypeNamespace;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string CookiePath;
    public static string DenyOnlyPrimarySid;
    public static string DenyOnlyPrimaryGroupSid;
    public static string DenyOnlyWindowsDeviceGroup;
    public static string Dsa;
    public static string Expiration;
    public static string Expired;
    public static string GroupSid;
    public static string IsPersistent;
    public static string PrimaryGroupSid;
    public static string PrimarySid;
    public static string Role;
    public static string SerialNumber;
    public static string UserData;
    public static string Version;
    public static string WindowsAccountName;
    public static string WindowsDeviceClaim;
    public static string WindowsDeviceGroup;
    public static string WindowsUserClaim;
    public static string WindowsFqbnVersion;
    public static string WindowsSubAuthority;
    internal static string ClaimType2005Namespace;
    public static string Anonymous;
    public static string Authentication;
    public static string AuthorizationDecision;
    public static string Country;
    public static string DateOfBirth;
    public static string Dns;
    public static string DenyOnlySid;
    public static string Email;
    public static string Gender;
    public static string GivenName;
    public static string Hash;
    public static string HomePhone;
    public static string Locality;
    public static string MobilePhone;
    public static string Name;
    public static string NameIdentifier;
    public static string OtherPhone;
    public static string PostalCode;
    public static string Rsa;
    public static string Sid;
    public static string Spn;
    public static string StateOrProvince;
    public static string StreetAddress;
    public static string Surname;
    public static string System;
    public static string Thumbprint;
    public static string Upn;
    public static string Uri;
    public static string Webpage;
    public static string X500DistinguishedName;
    internal static string ClaimType2009Namespace;
    public static string Actor;
}
[ComVisibleAttribute("False")]
public static class System.Security.Claims.ClaimValueTypes : object {
    public static string Base64Binary;
    public static string Base64Octet;
    public static string Boolean;
    public static string Date;
    public static string DateTime;
    public static string Double;
    public static string Fqbn;
    public static string HexBinary;
    public static string Integer;
    public static string Integer32;
    public static string Integer64;
    public static string Sid;
    public static string String;
    public static string Time;
    public static string UInteger32;
    public static string UInteger64;
    public static string DnsName;
    public static string Email;
    public static string Rsa;
    public static string UpnName;
    public static string DsaKeyValue;
    public static string KeyInfo;
    public static string RsaKeyValue;
    public static string DaytimeDuration;
    public static string YearMonthDuration;
    public static string Rfc822Name;
    public static string X500Name;
}
[ComVisibleAttribute("False")]
internal class System.Security.Claims.RoleClaimProvider : object {
    public IEnumerable`1<Claim> Claims { get; }
    public RoleClaimProvider(string issuer, String[] roles, ClaimsIdentity subject);
    public IEnumerable`1<Claim> get_Claims();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.CodeAccessPermission : object {
    [SecuritySafeCriticalAttribute]
public static void RevertAssert();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static void RevertDeny();
    [SecuritySafeCriticalAttribute]
public static void RevertPermitOnly();
    [SecuritySafeCriticalAttribute]
public static void RevertAll();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    [SecuritySafeCriticalAttribute]
internal static void Demand(PermissionType permissionType);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Assert();
    [SecuritySafeCriticalAttribute]
internal static void Assert(bool allPossible);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual void Deny();
    [SecuritySafeCriticalAttribute]
public sealed virtual void PermitOnly();
    public virtual IPermission Union(IPermission other);
    internal static SecurityElement CreatePermissionElement(IPermission perm, string permname);
    internal static void ValidateElement(SecurityElement elem, IPermission perm);
    public abstract virtual SecurityElement ToXml();
    public abstract virtual void FromXml(SecurityElement elem);
    public virtual string ToString();
    internal bool VerifyType(IPermission perm);
    public abstract virtual IPermission Copy();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    internal bool CheckDemand(CodeAccessPermission grant);
    internal bool CheckPermitOnly(CodeAccessPermission permitted);
    internal bool CheckDeny(CodeAccessPermission denied);
    internal bool CheckAssert(CodeAccessPermission asserted);
}
internal static class System.Security.CodeAccessSecurityEngine : object {
    internal static SecurityPermission AssertPermission;
    internal static PermissionToken AssertPermissionToken;
    private static CodeAccessSecurityEngine();
    [SecurityCriticalAttribute]
internal static void SpecialDemand(PermissionType whatPermission, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void CheckSetHelper(CompressedStack cs, PermissionSet grants, PermissionSet refused, PermissionSet demands, RuntimeMethodHandleInternal rmh, RuntimeAssembly asm, SecurityAction action);
    [SecurityCriticalAttribute]
internal static bool CheckSetHelper(PermissionSet grants, PermissionSet refused, PermissionSet demands, RuntimeMethodHandleInternal rmh, object assemblyOrString, SecurityAction action, bool throwException);
    [SecurityCriticalAttribute]
internal static void CheckHelper(CompressedStack cs, PermissionSet grantedSet, PermissionSet refusedSet, CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh, RuntimeAssembly asm, SecurityAction action);
    [SecurityCriticalAttribute]
internal static bool CheckHelper(PermissionSet grantedSet, PermissionSet refusedSet, CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh, object assemblyOrString, SecurityAction action, bool throwException);
    [SecurityCriticalAttribute]
internal static void ReflectionTargetDemandHelper(PermissionType permission, PermissionSet targetGrant);
    [SecurityCriticalAttribute]
internal static void GetZoneAndOriginHelper(CompressedStack cs, PermissionSet grantSet, PermissionSet refusedSet, ArrayList zoneList, ArrayList originList);
    [SecurityCriticalAttribute]
internal static void GetZoneAndOrigin(StackCrawlMark& mark, ArrayList& zone, ArrayList& origin);
    [SecurityCriticalAttribute]
internal static void CheckAssembly(RuntimeAssembly asm, CodeAccessPermission demand);
    [SecurityCriticalAttribute]
internal static bool QuickCheckForAllDemands();
    [SecurityCriticalAttribute]
internal static bool AllDomainsHomogeneousWithNoStackModifiers();
    [SecurityCriticalAttribute]
internal static void Check(CodeAccessPermission cap, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void Check(PermissionSet permSet, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static FrameSecurityDescriptor CheckNReturnSO(PermissionToken permToken, CodeAccessPermission demand, StackCrawlMark& stackMark, int create);
    [SecurityCriticalAttribute]
internal static void Assert(CodeAccessPermission cap, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void Deny(CodeAccessPermission cap, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void PermitOnly(CodeAccessPermission cap, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
internal static bool TryResolveGrantSet(Evidence evidence, PermissionSet& grantSet);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    private static Aes();
    public static Aes Create();
    public static Aes Create(string algorithmName);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    protected KeySizes[] LegalKeySizesValue;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    public string KeyExchangeAlgorithm { get; }
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual string get_KeyExchangeAlgorithm();
    public static AsymmetricAlgorithm Create();
    public static AsymmetricAlgorithm Create(string algName);
    public abstract virtual void FromXmlString(string xmlString);
    public abstract virtual string ToXmlString(bool includePrivateParameters);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    public string Parameters { get; }
    public abstract virtual string get_Parameters();
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    public static CipherMode ECB;
    public static CipherMode OFB;
    public static CipherMode CFB;
    public static CipherMode CTS;
}
internal static class System.Security.Cryptography.Constants : object {
    internal static int S_OK;
    internal static int NTE_FILENOTFOUND;
    internal static int NTE_NO_KEY;
    internal static int NTE_BAD_KEYSET;
    internal static int NTE_KEYSET_NOT_DEF;
    internal static int KP_IV;
    internal static int KP_MODE;
    internal static int KP_MODE_BITS;
    internal static int KP_EFFECTIVE_KEYLEN;
    internal static int ALG_CLASS_SIGNATURE;
    internal static int ALG_CLASS_DATA_ENCRYPT;
    internal static int ALG_CLASS_HASH;
    internal static int ALG_CLASS_KEY_EXCHANGE;
    internal static int ALG_TYPE_DSS;
    internal static int ALG_TYPE_RSA;
    internal static int ALG_TYPE_BLOCK;
    internal static int ALG_TYPE_STREAM;
    internal static int ALG_TYPE_ANY;
    internal static int CALG_MD5;
    internal static int CALG_SHA1;
    internal static int CALG_SHA_256;
    internal static int CALG_SHA_384;
    internal static int CALG_SHA_512;
    internal static int CALG_RSA_KEYX;
    internal static int CALG_RSA_SIGN;
    internal static int CALG_DSS_SIGN;
    internal static int CALG_DES;
    internal static int CALG_RC2;
    internal static int CALG_3DES;
    internal static int CALG_3DES_112;
    internal static int CALG_AES_128;
    internal static int CALG_AES_192;
    internal static int CALG_AES_256;
    internal static int CALG_RC4;
    internal static int PROV_RSA_FULL;
    internal static int PROV_DSS_DH;
    internal static int PROV_RSA_AES;
    internal static int AT_KEYEXCHANGE;
    internal static int AT_SIGNATURE;
    internal static int PUBLICKEYBLOB;
    internal static int PRIVATEKEYBLOB;
    internal static int CRYPT_OAEP;
    internal static UInt32 CRYPT_VERIFYCONTEXT;
    internal static UInt32 CRYPT_NEWKEYSET;
    internal static UInt32 CRYPT_DELETEKEYSET;
    internal static UInt32 CRYPT_MACHINE_KEYSET;
    internal static UInt32 CRYPT_SILENT;
    internal static UInt32 CRYPT_EXPORTABLE;
    internal static UInt32 CLR_KEYLEN;
    internal static UInt32 CLR_PUBLICKEYONLY;
    internal static UInt32 CLR_EXPORTABLE;
    internal static UInt32 CLR_REMOVABLE;
    internal static UInt32 CLR_HARDWARE;
    internal static UInt32 CLR_ACCESSIBLE;
    internal static UInt32 CLR_PROTECTED;
    internal static UInt32 CLR_UNIQUE_CONTAINER;
    internal static UInt32 CLR_ALGID;
    internal static UInt32 CLR_PP_CLIENT_HWND;
    internal static UInt32 CLR_PP_PIN;
    internal static string OID_RSA_SMIMEalgCMS3DESwrap;
    internal static string OID_RSA_MD5;
    internal static string OID_RSA_RC2CBC;
    internal static string OID_RSA_DES_EDE3_CBC;
    internal static string OID_OIWSEC_desCBC;
    internal static string OID_OIWSEC_SHA1;
    internal static string OID_OIWSEC_SHA256;
    internal static string OID_OIWSEC_SHA384;
    internal static string OID_OIWSEC_SHA512;
    internal static string OID_OIWSEC_RIPEMD160;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptoAPITransform : object {
    public IntPtr KeyHandle { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    [SecurityCriticalAttribute]
internal CryptoAPITransform(int algid, int cArgs, Int32[] rgArgIds, Object[] rgArgValues, Byte[] rgbKey, PaddingMode padding, CipherMode cipherChainingMode, int blockSize, int feedbackSize, bool useSalt, CryptoAPITransformMode encDecMode);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public void Clear();
    [SecuritySafeCriticalAttribute]
public IntPtr get_KeyHandle();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual bool get_CanReuseTransform();
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void Reset();
    [SecuritySafeCriticalAttribute]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [SecuritySafeCriticalAttribute]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal enum System.Security.Cryptography.CryptoAPITransformMode : Enum {
    public int value__;
    public static CryptoAPITransformMode Encrypt;
    public static CryptoAPITransformMode Decrypt;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptoConfig : object {
    public static bool AllowOnlyFipsAlgorithms { get; }
    private static CryptoConfig();
    [SecuritySafeCriticalAttribute]
public static bool get_AllowOnlyFipsAlgorithms();
    [SecurityCriticalAttribute]
public static void AddAlgorithm(Type algorithm, String[] names);
    [SecuritySafeCriticalAttribute]
public static object CreateFromName(string name, Object[] args);
    public static object CreateFromName(string name);
    [SecurityCriticalAttribute]
public static void AddOID(string oid, String[] names);
    public static string MapNameToOID(string name);
    [SecuritySafeCriticalAttribute]
internal static string MapNameToOID(string name, OidGroup oidGroup);
    public static Byte[] EncodeOID(string str);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(string message);
    public CryptographicException(string format, string insert);
    public CryptographicException(string message, Exception inner);
    [SecuritySafeCriticalAttribute]
public CryptographicException(int hr);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    public CryptographicUnexpectedOperationException(string message);
    public CryptographicUnexpectedOperationException(string format, string insert);
    public CryptographicUnexpectedOperationException(string message, Exception inner);
    protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptoStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool HasFlushedFinalBlock { get; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public bool get_HasFlushedFinalBlock();
    public void FlushFinalBlock();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public void Clear();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
internal enum System.Security.Cryptography.CspAlgorithmType : Enum {
    public int value__;
    public static CspAlgorithmType Rsa;
    public static CspAlgorithmType Dss;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    public bool MachineKeyStore { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public string KeyContainerName { get; }
    public string UniqueKeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public bool Removable { get; }
    public bool Accessible { get; }
    public bool Protected { get; }
    public CryptoKeySecurity CryptoKeySecurity { get; }
    public bool RandomlyGenerated { get; }
    [SecurityCriticalAttribute]
internal CspKeyContainerInfo(CspParameters parameters, bool randomKeyContainer);
    [SecuritySafeCriticalAttribute]
public CspKeyContainerInfo(CspParameters parameters);
    public bool get_MachineKeyStore();
    public string get_ProviderName();
    public int get_ProviderType();
    public string get_KeyContainerName();
    [SecuritySafeCriticalAttribute]
public string get_UniqueKeyContainerName();
    public KeyNumber get_KeyNumber();
    [SecuritySafeCriticalAttribute]
public bool get_Exportable();
    [SecuritySafeCriticalAttribute]
public bool get_HardwareDevice();
    [SecuritySafeCriticalAttribute]
public bool get_Removable();
    [SecuritySafeCriticalAttribute]
public bool get_Accessible();
    [SecuritySafeCriticalAttribute]
public bool get_Protected();
    [SecuritySafeCriticalAttribute]
public CryptoKeySecurity get_CryptoKeySecurity();
    public bool get_RandomlyGenerated();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CspParameters : object {
    public int ProviderType;
    public string ProviderName;
    public string KeyContainerName;
    public int KeyNumber;
    public CspProviderFlags Flags { get; public set; }
    public CryptoKeySecurity CryptoKeySecurity { get; public set; }
    public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, SecureString keyPassword);
    public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, IntPtr parentWindowHandle);
    internal CspParameters(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);
    internal CspParameters(CspParameters parameters);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    public CryptoKeySecurity get_CryptoKeySecurity();
    public void set_CryptoKeySecurity(CryptoKeySecurity value);
    public SecureString get_KeyPassword();
    public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DeriveBytes : object {
    public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    private static DES();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static DES Create();
    public static DES Create(string algName);
    public static bool IsWeakKey(Byte[] rgbKey);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public static DSA Create();
    public static DSA Create(string algName);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(DSAParameters parameters);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    [ComVisibleAttribute("False")]
public bool PublicOnly { get; }
    [ComVisibleAttribute("False")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public bool PersistKeyInCsp { get; public set; }
    public DSACryptoServiceProvider(int dwKeySize);
    public DSACryptoServiceProvider(CspParameters parameters);
    [SecuritySafeCriticalAttribute]
public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    private static DSACryptoServiceProvider();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public bool get_PublicOnly();
    [SecuritySafeCriticalAttribute]
public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [SecuritySafeCriticalAttribute]
public virtual int get_KeySize();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    [SecuritySafeCriticalAttribute]
public bool get_PersistKeyInCsp();
    [SecuritySafeCriticalAttribute]
public void set_PersistKeyInCsp(bool value);
    [SecuritySafeCriticalAttribute]
public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    [SecuritySafeCriticalAttribute]
public virtual void ImportParameters(DSAParameters parameters);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [SecuritySafeCriticalAttribute]
public Byte[] SignHash(Byte[] rgbHash, string str);
    [SecuritySafeCriticalAttribute]
public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
}
internal class System.Security.Cryptography.DSACspObject : object {
    internal Byte[] P;
    internal Byte[] Q;
    internal Byte[] G;
    internal Byte[] Y;
    internal Byte[] J;
    internal Byte[] X;
    internal Byte[] Seed;
    internal int Counter;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSAParameters : ValueType {
    public Byte[] P;
    public Byte[] Q;
    public Byte[] G;
    public Byte[] Y;
    public Byte[] J;
    public Byte[] X;
    public Byte[] Seed;
    public int Counter;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
internal class System.Security.Cryptography.DSASignatureDescription : SignatureDescription {
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.FromBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual void Finalize();
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    protected int HashSizeValue;
    protected internal Byte[] HashValue;
    protected int State;
    public int HashSize { get; }
    public Byte[] Hash { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public virtual int get_HashSize();
    public virtual Byte[] get_Hash();
    public static HashAlgorithm Create();
    public static HashAlgorithm Create(string hashName);
    public Byte[] ComputeHash(Stream inputStream);
    public Byte[] ComputeHash(Byte[] buffer);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Initialize();
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected abstract virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    internal string m_hashName;
    internal HashAlgorithm m_hash1;
    internal HashAlgorithm m_hash2;
    protected int BlockSizeValue { get; protected set; }
    public Byte[] Key { get; public set; }
    public string HashName { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    internal void InitializeKey(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public string get_HashName();
    public void set_HashName(string value);
    public static HMAC Create();
    public static HMAC Create(string algorithmName);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual Byte[] HashFinal();
    protected virtual void Dispose(bool disposing);
    internal static HashAlgorithm GetHashAlgorithmWithFipsFallback(Func`1<HashAlgorithm> createStandardHashAlgorithmCallback, Func`1<HashAlgorithm> createFipsHashAlgorithmCallback);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public HMACMD5(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACRIPEMD160 : HMAC {
    public HMACRIPEMD160(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public HMACSHA1(Byte[] key);
    public HMACSHA1(Byte[] key, bool useManagedSha1);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public HMACSHA256(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    public bool ProduceLegacyHmacValues { get; public set; }
    [SecuritySafeCriticalAttribute]
public HMACSHA384(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    public bool ProduceLegacyHmacValues { get; public set; }
    [SecuritySafeCriticalAttribute]
public HMACSHA512(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
}
[ComVisibleAttribute("True")]
public interface System.Security.Cryptography.ICryptoTransform {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[ComVisibleAttribute("True")]
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static KeyedHashAlgorithm Create();
    public static KeyedHashAlgorithm Create(string algName);
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.KeySizes : object {
    public int MinSize { get; }
    public int MaxSize { get; }
    public int SkipSize { get; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    public int get_MinSize();
    public int get_MaxSize();
    public int get_SkipSize();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.MACTripleDES : KeyedHashAlgorithm {
    [ComVisibleAttribute("False")]
public PaddingMode Padding { get; public set; }
    public MACTripleDES(Byte[] rgbKey);
    public MACTripleDES(string strTripleDES, Byte[] rgbKey);
    public virtual void Initialize();
    public PaddingMode get_Padding();
    public void set_Padding(PaddingMode value);
    protected virtual void HashCore(Byte[] rgbData, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    [ComVisibleAttribute("True")]
public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static MD5 Create();
    public static MD5 Create(string algName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    [SecuritySafeCriticalAttribute]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Byte[] data);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    public int EffectiveKeySize { get; public set; }
    public int KeySize { get; public set; }
    private static RC2();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public static RC2 Create();
    public static RC2 Create(string AlgName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    public int EffectiveKeySize { get; public set; }
    [ComVisibleAttribute("False")]
public bool UseSalt { get; public set; }
    private static RC2CryptoServiceProvider();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    public void set_UseSalt(bool value);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public Rfc2898DeriveBytes(string password, int saltSize);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    private static Rijndael();
    public static Rijndael Create();
    public static Rijndael Create(string algName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RijndaelManagedTransform : object {
    public int BlockSizeValue { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    internal RijndaelManagedTransform(Byte[] rgbKey, CipherMode mode, Byte[] rgbIV, int blockSize, int feedbackSize, PaddingMode PaddingValue, RijndaelManagedTransformMode transformMode);
    private static RijndaelManagedTransform();
    public sealed virtual void Dispose();
    public void Clear();
    public int get_BlockSizeValue();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public void Reset();
}
internal enum System.Security.Cryptography.RijndaelManagedTransformMode : Enum {
    public int value__;
    public static RijndaelManagedTransformMode Encrypt;
    public static RijndaelManagedTransformMode Decrypt;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RIPEMD160 : HashAlgorithm {
    public static RIPEMD160 Create();
    public static RIPEMD160 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RIPEMD160Managed : RIPEMD160 {
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    public RNGCryptoServiceProvider(string str);
    public RNGCryptoServiceProvider(Byte[] rgb);
    [SecuritySafeCriticalAttribute]
public RNGCryptoServiceProvider(CspParameters cspParams);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual void GetBytes(Byte[] data);
    [SecuritySafeCriticalAttribute]
public virtual void GetNonZeroBytes(Byte[] data);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    public static RSA Create();
    public static RSA Create(string algName);
    public abstract virtual Byte[] DecryptValue(Byte[] rgb);
    public abstract virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(RSAParameters parameters);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    [ComVisibleAttribute("False")]
public bool PublicOnly { get; }
    [ComVisibleAttribute("False")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public bool PersistKeyInCsp { get; public set; }
    [SecuritySafeCriticalAttribute]
public RSACryptoServiceProvider(int dwKeySize);
    [SecuritySafeCriticalAttribute]
public RSACryptoServiceProvider(CspParameters parameters);
    [SecuritySafeCriticalAttribute]
public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    private static RSACryptoServiceProvider();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public bool get_PublicOnly();
    [SecuritySafeCriticalAttribute]
public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [SecuritySafeCriticalAttribute]
public virtual int get_KeySize();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    [SecuritySafeCriticalAttribute]
public bool get_PersistKeyInCsp();
    [SecuritySafeCriticalAttribute]
public void set_PersistKeyInCsp(bool value);
    [SecuritySafeCriticalAttribute]
public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    [SecuritySafeCriticalAttribute]
public virtual void ImportParameters(RSAParameters parameters);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public Byte[] SignData(Stream inputStream, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    [SecuritySafeCriticalAttribute]
internal Byte[] SignHash(Byte[] rgbHash, int calgHash);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    [SecuritySafeCriticalAttribute]
internal bool VerifyHash(Byte[] rgbHash, int calgHash, Byte[] rgbSignature);
    [SecuritySafeCriticalAttribute]
public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    [SecuritySafeCriticalAttribute]
public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
}
internal class System.Security.Cryptography.RSACspObject : object {
    internal Byte[] Exponent;
    internal Byte[] Modulus;
    internal Byte[] P;
    internal Byte[] Q;
    internal Byte[] DP;
    internal Byte[] DQ;
    internal Byte[] InverseQ;
    internal Byte[] D;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] Exponent;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] InverseQ;
    public Byte[] D;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    public RandomNumberGenerator RNG { get; public set; }
    public string Parameters { get; public set; }
    public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
}
internal class System.Security.Cryptography.RSAPKCS1SHA1SignatureDescription : SignatureDescription {
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    [SecuritySafeCriticalAttribute]
public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[SecurityCriticalAttribute]
internal class System.Security.Cryptography.SafeHashHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeHashHandle InvalidHandle { get; }
    internal static SafeHashHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class System.Security.Cryptography.SafeKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeKeyHandle InvalidHandle { get; }
    internal static SafeKeyHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class System.Security.Cryptography.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeProvHandle InvalidHandle { get; }
    internal static SafeProvHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static SHA1 Create();
    public static SHA1 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static SHA256 Create();
    public static SHA256 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    private static SHA256Managed();
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static SHA384 Create();
    public static SHA384 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    private static SHA384Managed();
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static SHA512 Create();
    public static SHA512 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    private static SHA512Managed();
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SignatureDescription : object {
    public string KeyAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string DeformatterAlgorithm { get; public set; }
    public SignatureDescription(SecurityElement el);
    public string get_KeyAlgorithm();
    public void set_KeyAlgorithm(string value);
    public string get_DigestAlgorithm();
    public void set_DigestAlgorithm(string value);
    public string get_FormatterAlgorithm();
    public void set_FormatterAlgorithm(string value);
    public string get_DeformatterAlgorithm();
    public void set_DeformatterAlgorithm(string value);
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
    public virtual HashAlgorithm CreateDigest();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    protected Byte[] IVValue;
    protected Byte[] KeyValue;
    protected KeySizes[] LegalBlockSizesValue;
    protected KeySizes[] LegalKeySizesValue;
    protected int KeySizeValue;
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public bool ValidKeySize(int bitLength);
    public static SymmetricAlgorithm Create();
    public static SymmetricAlgorithm Create(string algName);
    public virtual ICryptoTransform CreateEncryptor();
    public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public abstract virtual void GenerateKey();
    public abstract virtual void GenerateIV();
}
internal class System.Security.Cryptography.TailStream : Stream {
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TailStream(int bufferSize);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.ToBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual void Finalize();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    public Byte[] Key { get; public set; }
    private static TripleDES();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static TripleDES Create();
    public static TripleDES Create(string str);
    public static bool IsWeakKey(Byte[] rgbKey);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
internal static class System.Security.Cryptography.Utils : object {
    internal static int DefaultRsaProviderType { get; }
    internal static SafeProvHandle StaticProvHandle { get; }
    internal static SafeProvHandle StaticDssProvHandle { get; }
    internal static RNGCryptoServiceProvider StaticRandomNumberGenerator { get; }
    [SecuritySafeCriticalAttribute]
private static Utils();
    internal static int get_DefaultRsaProviderType();
    [SecurityCriticalAttribute]
internal static SafeProvHandle get_StaticProvHandle();
    [SecurityCriticalAttribute]
internal static SafeProvHandle get_StaticDssProvHandle();
    [SecurityCriticalAttribute]
internal static SafeProvHandle AcquireProvHandle(CspParameters parameters);
    [SecurityCriticalAttribute]
internal static SafeProvHandle CreateProvHandle(CspParameters parameters, bool randomKeyContainer);
    [SecurityCriticalAttribute]
internal static CryptoKeySecurity GetKeySetSecurityInfo(SafeProvHandle hProv, AccessControlSections accessControlSections);
    [SecurityCriticalAttribute]
internal static void SetKeySetSecurityInfo(SafeProvHandle hProv, CryptoKeySecurity cryptoKeySecurity, AccessControlSections accessControlSections);
    [SecurityCriticalAttribute]
internal static Byte[] ExportCspBlobHelper(bool includePrivateParameters, CspParameters parameters, SafeKeyHandle safeKeyHandle);
    [SecuritySafeCriticalAttribute]
internal static void GetKeyPairHelper(CspAlgorithmType keyType, CspParameters parameters, bool randomKeyContainer, int dwKeySize, SafeProvHandle& safeProvHandle, SafeKeyHandle& safeKeyHandle);
    [SecurityCriticalAttribute]
internal static void ImportCspBlobHelper(CspAlgorithmType keyType, Byte[] keyBlob, bool publicOnly, CspParameters& parameters, bool randomKeyContainer, SafeProvHandle& safeProvHandle, SafeKeyHandle& safeKeyHandle);
    [SecurityCriticalAttribute]
internal static CspParameters SaveCspParameters(CspAlgorithmType keyType, CspParameters userParameters, CspProviderFlags defaultFlags, Boolean& randomKeyContainer);
    internal static RNGCryptoServiceProvider get_StaticRandomNumberGenerator();
    internal static Byte[] GenerateRandom(int keySize);
    [SecurityCriticalAttribute]
internal static bool ReadLegacyFipsPolicy();
    [SecurityCriticalAttribute]
internal static bool HasAlgorithm(int dwCalg, int dwKeySize);
    internal static int ObjToAlgId(object hashAlg, OidGroup group);
    internal static HashAlgorithm ObjToHashAlgorithm(object hashAlg);
    internal static string DiscardWhiteSpaces(string inputBuffer);
    internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
    internal static int ConvertByteArrayToInt(Byte[] input);
    internal static Byte[] ConvertIntToByteArray(int dwInput);
    internal static void ConvertIntToByteArray(UInt32 dwInput, Byte[]& counter);
    internal static Byte[] FixupKeyParity(Byte[] key);
    [SecurityCriticalAttribute]
internal static void DWORDFromLittleEndian(UInt32* x, int digits, Byte* block);
    internal static void DWORDToLittleEndian(Byte[] block, UInt32[] x, int digits);
    [SecurityCriticalAttribute]
internal static void DWORDFromBigEndian(UInt32* x, int digits, Byte* block);
    internal static void DWORDToBigEndian(Byte[] block, UInt32[] x, int digits);
    [SecurityCriticalAttribute]
internal static void QuadWordFromBigEndian(UInt64* x, int digits, Byte* block);
    internal static void QuadWordToBigEndian(Byte[] block, UInt64[] x, int digits);
    internal static Byte[] Int(UInt32 i);
    [SecurityCriticalAttribute]
internal static Byte[] RsaOaepEncrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, RandomNumberGenerator rng, Byte[] data);
    [SecurityCriticalAttribute]
internal static Byte[] RsaOaepDecrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, Byte[] encryptedData);
    [SecurityCriticalAttribute]
internal static Byte[] RsaPkcs1Padding(RSA rsa, Byte[] oid, Byte[] hash);
    internal static bool CompareBigIntArrays(Byte[] lhs, Byte[] rhs);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static SafeHashHandle CreateHash(SafeProvHandle hProv, int algid);
    [SecurityCriticalAttribute]
internal static Byte[] EndHash(SafeHashHandle hHash);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPersistKeyInCsp(SafeProvHandle hProv);
    [SecurityCriticalAttribute]
internal static void HashData(SafeHashHandle hHash, Byte[] data, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetKeyParamDw(SafeKeyHandle hKey, int param, int dwValue);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetKeyParamRgb(SafeKeyHandle hKey, int param, Byte[] value, int cbValue);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetPersistKeyInCsp(SafeProvHandle hProv, bool fPersistKeyInCsp);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetProviderParameter(SafeProvHandle hProv, int keyNumber, UInt32 paramID, IntPtr pbData);
    [SecurityCriticalAttribute]
internal static Byte[] SignValue(SafeKeyHandle hKey, int keyNumber, int calgKey, int calgHash, Byte[] hash);
    [SecurityCriticalAttribute]
internal static bool VerifySign(SafeKeyHandle hKey, int calgKey, int calgHash, Byte[] hash, Byte[] signature);
    [SecurityCriticalAttribute]
internal static void _CreateCSP(CspParameters param, bool randomKeyContainer, SafeProvHandle& hProv);
    [SecurityCriticalAttribute]
internal static int _DecryptData(SafeKeyHandle hKey, Byte[] data, int ib, int cb, Byte[]& outputBuffer, int outputOffset, PaddingMode PaddingMode, bool fDone);
    [SecurityCriticalAttribute]
internal static int _EncryptData(SafeKeyHandle hKey, Byte[] data, int ib, int cb, Byte[]& outputBuffer, int outputOffset, PaddingMode PaddingMode, bool fDone);
    [SecurityCriticalAttribute]
internal static void _ExportKey(SafeKeyHandle hKey, int blobType, object cspObject);
    [SecurityCriticalAttribute]
internal static void _GenerateKey(SafeProvHandle hProv, int algid, CspProviderFlags flags, int keySize, SafeKeyHandle& hKey);
    [SecurityCriticalAttribute]
internal static bool _GetEnforceFipsPolicySetting();
    [SecurityCriticalAttribute]
internal static Byte[] _GetKeyParameter(SafeKeyHandle hKey, UInt32 paramID);
    [SecurityCriticalAttribute]
internal static Byte[] _GetKeySetSecurityInfo(SafeProvHandle hProv, SecurityInfos securityInfo, Int32& error);
    [SecurityCriticalAttribute]
internal static object _GetProviderParameter(SafeProvHandle hProv, int keyNumber, UInt32 paramID);
    [SecurityCriticalAttribute]
internal static int _GetUserKey(SafeProvHandle hProv, int keyNumber, SafeKeyHandle& hKey);
    [SecurityCriticalAttribute]
internal static void _ImportBulkKey(SafeProvHandle hProv, int algid, bool useSalt, Byte[] key, SafeKeyHandle& hKey);
    [SecurityCriticalAttribute]
internal static int _ImportCspBlob(Byte[] keyBlob, SafeProvHandle hProv, CspProviderFlags flags, SafeKeyHandle& hKey);
    [SecurityCriticalAttribute]
internal static void _ImportKey(SafeProvHandle hCSP, int keyNumber, CspProviderFlags flags, object cspObject, SafeKeyHandle& hKey);
    [SecurityCriticalAttribute]
internal static bool _ProduceLegacyHmacValues();
    [SecurityCriticalAttribute]
internal static int _OpenCSP(CspParameters param, UInt32 flags, SafeProvHandle& hProv);
    [SecurityCriticalAttribute]
internal static void _AcquireCSP(CspParameters param, SafeProvHandle& hProv);
}
internal class System.Security.Cryptography.X509Certificates.CRYPT_OID_INFO : ValueType {
    internal int cbSize;
    internal string pszOID;
    internal string pwszName;
    internal OidGroup dwGroupId;
    internal int AlgId;
    internal int cbData;
    internal IntPtr pbData;
}
internal enum System.Security.Cryptography.X509Certificates.OidGroup : Enum {
    public int value__;
    public static OidGroup AllGroups;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
    public static OidGroup DisableSearchDS;
}
internal enum System.Security.Cryptography.X509Certificates.OidKeyType : Enum {
    public int value__;
    public static OidKeyType Oid;
    public static OidKeyType Name;
    public static OidKeyType AlgorithmID;
    public static OidKeyType SignatureID;
    public static OidKeyType CngAlgorithmID;
    public static OidKeyType CngSignatureID;
}
[SecurityCriticalAttribute]
internal class System.Security.Cryptography.X509Certificates.SafeCertContextHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertContextHandle InvalidHandle { get; }
    internal IntPtr pCertContext { get; }
    internal SafeCertContextHandle(IntPtr handle);
    internal static SafeCertContextHandle get_InvalidHandle();
    internal IntPtr get_pCertContext();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class System.Security.Cryptography.X509Certificates.SafeCertStoreHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertStoreHandle InvalidHandle { get; }
    internal SafeCertStoreHandle(IntPtr handle);
    internal static SafeCertStoreHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    [ComVisibleAttribute("False")]
public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal SafeCertContextHandle CertContext { get; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    public X509Certificate(Byte[] rawData, SecureString password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [SecuritySafeCriticalAttribute]
public X509Certificate(string fileName);
    [SecuritySafeCriticalAttribute]
public X509Certificate(string fileName, string password);
    [SecuritySafeCriticalAttribute]
public X509Certificate(string fileName, SecureString password);
    [SecuritySafeCriticalAttribute]
public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [SecuritySafeCriticalAttribute]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [SecurityCriticalAttribute]
public X509Certificate(IntPtr handle);
    [SecuritySafeCriticalAttribute]
public X509Certificate(X509Certificate cert);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public static X509Certificate CreateFromCertFile(string filename);
    public static X509Certificate CreateFromSignedFile(string filename);
    [SecurityCriticalAttribute]
public IntPtr get_Handle();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Subject property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[SecuritySafeCriticalAttribute]
public virtual string GetName();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method has been deprecated.  Please use the Issuer property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetIssuerName();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] GetKeyAlgorithmParameters();
    [SecuritySafeCriticalAttribute]
public virtual string GetKeyAlgorithmParametersString();
    [SecuritySafeCriticalAttribute]
public virtual string GetKeyAlgorithm();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] GetPublicKey();
    public virtual string GetPublicKeyString();
    [SecuritySafeCriticalAttribute]
public virtual Byte[] GetRawCertData();
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual string GetCertHashString();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(X509Certificate other);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public virtual string ToString(bool fVerbose);
    protected static string FormatDate(DateTime date);
    public virtual string GetFormat();
    [SecuritySafeCriticalAttribute]
public string get_Issuer();
    [SecuritySafeCriticalAttribute]
public string get_Subject();
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public virtual void Import(Byte[] rawData);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [SecurityCriticalAttribute]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual void Import(string fileName);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [SecurityCriticalAttribute]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public virtual Byte[] Export(X509ContentType contentType);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, string password);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public virtual void Reset();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
internal SafeCertContextHandle get_CertContext();
    [SecurityCriticalAttribute]
internal SafeCertContextHandle GetCertContextForCloning();
}
internal static class System.Security.Cryptography.X509Certificates.X509Constants : object {
    internal static UInt32 CRYPT_EXPORTABLE;
    internal static UInt32 CRYPT_USER_PROTECTED;
    internal static UInt32 CRYPT_MACHINE_KEYSET;
    internal static UInt32 CRYPT_USER_KEYSET;
    internal static UInt32 CERT_QUERY_CONTENT_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_STORE;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS10;
    internal static UInt32 CERT_QUERY_CONTENT_PFX;
    internal static UInt32 CERT_QUERY_CONTENT_CERT_PAIR;
    internal static UInt32 CERT_STORE_PROV_MEMORY;
    internal static UInt32 CERT_STORE_PROV_SYSTEM;
    internal static UInt32 CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    internal static UInt32 CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    internal static UInt32 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
    internal static UInt32 CERT_STORE_DELETE_FLAG;
    internal static UInt32 CERT_STORE_SHARE_STORE_FLAG;
    internal static UInt32 CERT_STORE_SHARE_CONTEXT_FLAG;
    internal static UInt32 CERT_STORE_MANIFOLD_FLAG;
    internal static UInt32 CERT_STORE_ENUM_ARCHIVED_FLAG;
    internal static UInt32 CERT_STORE_UPDATE_KEYID_FLAG;
    internal static UInt32 CERT_STORE_BACKUP_RESTORE_FLAG;
    internal static UInt32 CERT_STORE_READONLY_FLAG;
    internal static UInt32 CERT_STORE_OPEN_EXISTING_FLAG;
    internal static UInt32 CERT_STORE_CREATE_NEW_FLAG;
    internal static UInt32 CERT_STORE_MAXIMUM_ALLOWED_FLAG;
    internal static UInt32 CERT_NAME_EMAIL_TYPE;
    internal static UInt32 CERT_NAME_RDN_TYPE;
    internal static UInt32 CERT_NAME_SIMPLE_DISPLAY_TYPE;
    internal static UInt32 CERT_NAME_FRIENDLY_DISPLAY_TYPE;
    internal static UInt32 CERT_NAME_DNS_TYPE;
    internal static UInt32 CERT_NAME_URL_TYPE;
    internal static UInt32 CERT_NAME_UPN_TYPE;
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
}
internal static class System.Security.Cryptography.X509Certificates.X509Utils : object {
    [SecuritySafeCriticalAttribute]
internal static int GetAlgIdFromOid(string oid, OidGroup oidGroup);
    [SecuritySafeCriticalAttribute]
internal static string GetFriendlyNameFromOid(string oid, OidGroup oidGroup);
    [SecuritySafeCriticalAttribute]
internal static string GetOidFromFriendlyName(string friendlyName, OidGroup oidGroup);
    internal static int NameOrOidToAlgId(string oid, OidGroup oidGroup);
    internal static X509ContentType MapContentType(UInt32 contentType);
    internal static UInt32 MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    [SecurityCriticalAttribute]
internal static SafeCertStoreHandle ExportCertToMemoryStore(X509Certificate certificate);
    [SecurityCriticalAttribute]
internal static IntPtr PasswordToHGlobalUni(object password);
    [SecurityCriticalAttribute]
internal static void _AddCertificateToStore(SafeCertStoreHandle safeCertStoreHandle, SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static void _DuplicateCertContext(IntPtr handle, SafeCertContextHandle& safeCertContext);
    [SecurityCriticalAttribute]
internal static Byte[] _ExportCertificatesToBlob(SafeCertStoreHandle safeCertStoreHandle, X509ContentType contentType, IntPtr password);
    [SecurityCriticalAttribute]
internal static Byte[] _GetCertRawData(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static void _GetDateNotAfter(SafeCertContextHandle safeCertContext, FILE_TIME& fileTime);
    [SecurityCriticalAttribute]
internal static void _GetDateNotBefore(SafeCertContextHandle safeCertContext, FILE_TIME& fileTime);
    [SecurityCriticalAttribute]
internal static string _GetIssuerName(SafeCertContextHandle safeCertContext, bool legacyV1Mode);
    [SecurityCriticalAttribute]
internal static string _GetPublicKeyOid(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static Byte[] _GetPublicKeyParameters(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static Byte[] _GetPublicKeyValue(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static string _GetSubjectInfo(SafeCertContextHandle safeCertContext, UInt32 displayType, bool legacyV1Mode);
    [SecurityCriticalAttribute]
internal static Byte[] _GetSerialNumber(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static Byte[] _GetThumbprint(SafeCertContextHandle safeCertContext);
    [SecurityCriticalAttribute]
internal static void _LoadCertFromBlob(Byte[] rawData, IntPtr password, UInt32 dwFlags, bool persistKeySet, SafeCertContextHandle& pCertCtx);
    [SecurityCriticalAttribute]
internal static void _LoadCertFromFile(string fileName, IntPtr password, UInt32 dwFlags, bool persistKeySet, SafeCertContextHandle& pCertCtx);
    [SecurityCriticalAttribute]
internal static void _OpenX509Store(UInt32 storeType, UInt32 flags, string storeName, SafeCertStoreHandle& safeCertStoreHandle);
    [SecurityCriticalAttribute]
internal static UInt32 _QueryCertBlobType(Byte[] rawData);
    [SecurityCriticalAttribute]
internal static UInt32 _QueryCertFileType(string fileName);
}
[AttributeUsageAttribute("64")]
internal class System.Security.DynamicSecurityMethodAttribute : Attribute {
}
internal class System.Security.FrameSecurityDescriptor : object {
    internal bool HasImperativeAsserts();
    internal bool HasImperativeDenials();
    internal bool HasImperativeRestrictions();
    [SecurityCriticalAttribute]
internal void SetAssert(IPermission perm);
    [SecurityCriticalAttribute]
internal void SetAssert(PermissionSet permSet);
    internal PermissionSet GetAssertions(bool fDeclarative);
    [SecurityCriticalAttribute]
internal void SetAssertAllPossible();
    internal bool GetAssertAllPossible();
    [SecurityCriticalAttribute]
internal void SetDeny(IPermission perm);
    [SecurityCriticalAttribute]
internal void SetDeny(PermissionSet permSet);
    internal PermissionSet GetDenials(bool fDeclarative);
    [SecurityCriticalAttribute]
internal void SetPermitOnly(IPermission perm);
    [SecurityCriticalAttribute]
internal void SetPermitOnly(PermissionSet permSet);
    internal PermissionSet GetPermitOnly(bool fDeclarative);
    [SecurityCriticalAttribute]
internal void SetTokenHandles(SafeTokenHandle callerToken, SafeTokenHandle impToken);
    [SecurityCriticalAttribute]
internal void RevertAssert();
    [SecurityCriticalAttribute]
internal void RevertAssertAllPossible();
    [SecurityCriticalAttribute]
internal void RevertDeny();
    [SecurityCriticalAttribute]
internal void RevertPermitOnly();
    [SecurityCriticalAttribute]
internal void RevertAll();
    [SecurityCriticalAttribute]
internal bool CheckDemand(CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckDemand2(CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh, bool fDeclarative);
    [SecurityCriticalAttribute]
internal bool CheckSetDemand(PermissionSet demandSet, PermissionSet& alteredDemandSet, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckSetDemand2(PermissionSet demandSet, PermissionSet& alteredDemandSet, RuntimeMethodHandleInternal rmh, bool fDeclarative);
}
[ComVisibleAttribute("True")]
public class System.Security.HostProtectionException : SystemException {
    public HostProtectionResource ProtectedResources { get; }
    public HostProtectionResource DemandedResources { get; }
    public HostProtectionException(string message);
    public HostProtectionException(string message, Exception e);
    protected HostProtectionException(SerializationInfo info, StreamingContext context);
    public HostProtectionException(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources);
    public HostProtectionResource get_ProtectedResources();
    public HostProtectionResource get_DemandedResources();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Security.HostSecurityManager : object {
    public HostSecurityManagerOptions Flags { get; }
    [ObsoleteAttribute("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public PolicyLevel DomainPolicy { get; }
    public virtual HostSecurityManagerOptions get_Flags();
    public virtual PolicyLevel get_DomainPolicy();
    public virtual Evidence ProvideAppDomainEvidence(Evidence inputEvidence);
    public virtual Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence);
    [SecurityCriticalAttribute]
public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
    public virtual PermissionSet ResolvePolicy(Evidence evidence);
    public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes();
    public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly);
    public virtual EvidenceBase GenerateAppDomainEvidence(Type evidenceType);
    public virtual EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.HostSecurityManagerOptions : Enum {
    public int value__;
    public static HostSecurityManagerOptions None;
    public static HostSecurityManagerOptions HostAppDomainEvidence;
    [ObsoleteAttribute("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static HostSecurityManagerOptions HostPolicyLevel;
    public static HostSecurityManagerOptions HostAssemblyEvidence;
    public static HostSecurityManagerOptions HostDetermineApplicationTrust;
    public static HostSecurityManagerOptions HostResolvePolicy;
    public static HostSecurityManagerOptions AllFlags;
}
[ComVisibleAttribute("True")]
public interface System.Security.IEvidenceFactory {
    public Evidence Evidence { get; }
    public abstract virtual Evidence get_Evidence();
}
[ComVisibleAttribute("True")]
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual void Demand();
}
internal interface System.Security.ISecurityElementFactory {
    public abstract virtual SecurityElement CreateSecurityElement();
    public abstract virtual object Copy();
    public abstract virtual string GetTag();
    public abstract virtual string Attribute(string attributeName);
}
[ComVisibleAttribute("True")]
public interface System.Security.ISecurityEncodable {
    public abstract virtual SecurityElement ToXml();
    public abstract virtual void FromXml(SecurityElement e);
}
[ComVisibleAttribute("True")]
public interface System.Security.ISecurityPolicyEncodable {
    public abstract virtual SecurityElement ToXml(PolicyLevel level);
    public abstract virtual void FromXml(SecurityElement e, PolicyLevel level);
}
[ComVisibleAttribute("True")]
public interface System.Security.IStackWalk {
    public abstract virtual void Assert();
    public abstract virtual void Demand();
    public abstract virtual void Deny();
    public abstract virtual void PermitOnly();
}
[ComVisibleAttribute("True")]
public class System.Security.NamedPermissionSet : PermissionSet {
    [OptionalFieldAttribute]
internal string m_descrResource;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public NamedPermissionSet(string name);
    public NamedPermissionSet(string name, PermissionState state);
    public NamedPermissionSet(string name, PermissionSet permSet);
    public NamedPermissionSet(NamedPermissionSet permSet);
    internal NamedPermissionSet(SecurityElement permissionSetXml);
    public string get_Name();
    public void set_Name(string value);
    public string get_Description();
    public void set_Description(string value);
    public virtual PermissionSet Copy();
    public NamedPermissionSet Copy(string name);
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement et);
    internal virtual void FromXml(SecurityElement et, bool allowInternalOnly, bool ignoreTypeLoadFailures);
    internal void FromXmlNameOnly(SecurityElement et);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
internal class System.Security.PermissionListSet : object {
    [SecurityCriticalAttribute]
internal void UpdateDomainPLS(PermissionListSet adPLS);
    [SecurityCriticalAttribute]
internal void UpdateDomainPLS(PermissionSet grantSet, PermissionSet deniedSet);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
internal static PermissionListSet CreateCompressedState(CompressedStack cs, CompressedStack innerCS);
    [SecurityCriticalAttribute]
internal static PermissionListSet CreateCompressedState(IntPtr unmanagedDCS, Boolean& bHaltConstruction);
    [SecurityCriticalAttribute]
internal static PermissionListSet CreateCompressedState_HG();
    [SecurityCriticalAttribute]
internal bool CheckDemandNoThrow(CodeAccessPermission demand);
    [SecurityCriticalAttribute]
internal bool CheckSetDemandNoThrow(PermissionSet pSet);
    [SecurityCriticalAttribute]
internal bool CheckDemand(CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckSetDemand(PermissionSet pset, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal void DemandFlagsOrGrantSet(int flags, PermissionSet grantSet);
    internal void GetZoneAndOrigin(ArrayList zoneList, ArrayList originList, PermissionToken zoneToken, PermissionToken originToken);
}
internal enum System.Security.Permissions.BuiltInPermissionFlag : Enum {
    public int value__;
    public static BuiltInPermissionFlag EnvironmentPermission;
    public static BuiltInPermissionFlag FileDialogPermission;
    public static BuiltInPermissionFlag FileIOPermission;
    public static BuiltInPermissionFlag IsolatedStorageFilePermission;
    public static BuiltInPermissionFlag ReflectionPermission;
    public static BuiltInPermissionFlag RegistryPermission;
    public static BuiltInPermissionFlag SecurityPermission;
    public static BuiltInPermissionFlag UIPermission;
    public static BuiltInPermissionFlag PrincipalPermission;
    public static BuiltInPermissionFlag PublisherIdentityPermission;
    public static BuiltInPermissionFlag SiteIdentityPermission;
    public static BuiltInPermissionFlag StrongNameIdentityPermission;
    public static BuiltInPermissionFlag UrlIdentityPermission;
    public static BuiltInPermissionFlag ZoneIdentityPermission;
    public static BuiltInPermissionFlag KeyContainerPermission;
}
internal static class System.Security.Permissions.BuiltInPermissionIndex : object {
    internal static int NUM_BUILTIN_UNRESTRICTED;
    internal static int NUM_BUILTIN_NORMAL;
    internal static int EnvironmentPermissionIndex;
    internal static int FileDialogPermissionIndex;
    internal static int FileIOPermissionIndex;
    internal static int IsolatedStorageFilePermissionIndex;
    internal static int ReflectionPermissionIndex;
    internal static int RegistryPermissionIndex;
    internal static int SecurityPermissionIndex;
    internal static int UIPermissionIndex;
    internal static int PrincipalPermissionIndex;
    internal static int HostProtectionPermissionIndex;
    internal static int PublisherIdentityPermissionIndex;
    internal static int SiteIdentityPermissionIndex;
    internal static int StrongNameIdentityPermissionIndex;
    internal static int UrlIdentityPermissionIndex;
    internal static int ZoneIdentityPermissionIndex;
    internal static int GacIdentityPermissionIndex;
    internal static int KeyContainerPermissionIndex;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.EnvironmentPermission : CodeAccessPermission {
    public EnvironmentPermission(PermissionState state);
    public EnvironmentPermission(EnvironmentPermissionAccess flag, string pathList);
    public void SetPathList(EnvironmentPermissionAccess flag, string pathList);
    [SecuritySafeCriticalAttribute]
public void AddPathList(EnvironmentPermissionAccess flag, string pathList);
    public string GetPathList(EnvironmentPermissionAccess flag);
    public sealed virtual bool IsUnrestricted();
    [SecuritySafeCriticalAttribute]
public virtual bool IsSubsetOf(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Intersect(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Union(IPermission other);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.EnvironmentPermissionAccess : Enum {
    public int value__;
    public static EnvironmentPermissionAccess NoAccess;
    public static EnvironmentPermissionAccess Read;
    public static EnvironmentPermissionAccess Write;
    public static EnvironmentPermissionAccess AllAccess;
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
    public string Read { get; public set; }
    public string Write { get; public set; }
    public string All { get; public set; }
    public EnvironmentPermissionAttribute(SecurityAction action);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public string get_All();
    public void set_All(string value);
    public virtual IPermission CreatePermission();
}
internal class System.Security.Permissions.EnvironmentStringExpressionSet : StringExpressionSet {
    public EnvironmentStringExpressionSet(string str);
    protected virtual StringExpressionSet CreateNewEmpty();
    protected virtual bool StringSubsetString(string left, string right, bool ignoreCase);
    protected virtual string ProcessWholeString(string str);
    protected virtual string ProcessSingleString(string str);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileDialogPermission : CodeAccessPermission {
    public FileDialogPermissionAccess Access { get; public set; }
    public FileDialogPermission(PermissionState state);
    public FileDialogPermission(FileDialogPermissionAccess access);
    public FileDialogPermissionAccess get_Access();
    public void set_Access(FileDialogPermissionAccess value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.FileDialogPermissionAccess : Enum {
    public int value__;
    public static FileDialogPermissionAccess None;
    public static FileDialogPermissionAccess Open;
    public static FileDialogPermissionAccess Save;
    public static FileDialogPermissionAccess OpenSave;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
    public bool Open { get; public set; }
    public bool Save { get; public set; }
    public FileDialogPermissionAttribute(SecurityAction action);
    public bool get_Open();
    public void set_Open(bool value);
    public bool get_Save();
    public void set_Save(bool value);
    public virtual IPermission CreatePermission();
}
internal class System.Security.Permissions.FileIOAccess : object {
    public bool AllFiles { get; public set; }
    public bool AllLocalFiles { get; public set; }
    unknown bool PathDiscovery {public set; }
    public FileIOAccess(bool pathDiscovery);
    [SecurityCriticalAttribute]
public FileIOAccess(string value);
    public FileIOAccess(bool allFiles, bool allLocalFiles, bool pathDiscovery);
    public FileIOAccess(StringExpressionSet set, bool allFiles, bool allLocalFiles, bool pathDiscovery);
    [SecurityCriticalAttribute]
public void AddExpressions(ArrayList values, bool checkForDuplicates);
    public bool get_AllFiles();
    public void set_AllFiles(bool value);
    public bool get_AllLocalFiles();
    public void set_AllLocalFiles(bool value);
    public void set_PathDiscovery(bool value);
    public bool IsEmpty();
    public FileIOAccess Copy();
    [SecuritySafeCriticalAttribute]
public FileIOAccess Union(FileIOAccess operand);
    [SecuritySafeCriticalAttribute]
public FileIOAccess Intersect(FileIOAccess operand);
    [SecuritySafeCriticalAttribute]
public bool IsSubsetOf(FileIOAccess operand);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public String[] ToStringArray();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool IsLocalDrive(string path);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileIOPermission : CodeAccessPermission {
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermission(PermissionState state);
    [SecuritySafeCriticalAttribute]
public FileIOPermission(FileIOPermissionAccess access, string path);
    [SecuritySafeCriticalAttribute]
public FileIOPermission(FileIOPermissionAccess access, String[] pathList);
    [SecuritySafeCriticalAttribute]
public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, string path);
    [SecuritySafeCriticalAttribute]
public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, String[] pathList);
    [SecurityCriticalAttribute]
internal FileIOPermission(FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates, bool needFullPath);
    [SecurityCriticalAttribute]
internal FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, String[] pathList, bool checkForDuplicates, bool needFullPath);
    public void SetPathList(FileIOPermissionAccess access, string path);
    public void SetPathList(FileIOPermissionAccess access, String[] pathList);
    internal void SetPathList(FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates);
    [SecuritySafeCriticalAttribute]
internal void SetPathList(FileIOPermissionAccess access, AccessControlActions control, String[] pathList, bool checkForDuplicates);
    [SecuritySafeCriticalAttribute]
public void AddPathList(FileIOPermissionAccess access, string path);
    [SecuritySafeCriticalAttribute]
public void AddPathList(FileIOPermissionAccess access, String[] pathList);
    [SecurityCriticalAttribute]
internal void AddPathList(FileIOPermissionAccess access, String[] pathListOrig, bool checkForDuplicates, bool needFullPath, bool copyPathList);
    [SecurityCriticalAttribute]
internal void AddPathList(FileIOPermissionAccess access, AccessControlActions control, String[] pathListOrig, bool checkForDuplicates, bool needFullPath, bool copyPathList);
    [SecuritySafeCriticalAttribute]
public String[] GetPathList(FileIOPermissionAccess access);
    public FileIOPermissionAccess get_AllLocalFiles();
    public void set_AllLocalFiles(FileIOPermissionAccess value);
    public FileIOPermissionAccess get_AllFiles();
    public void set_AllFiles(FileIOPermissionAccess value);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission other);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    [SecuritySafeCriticalAttribute]
public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.FileIOPermissionAccess : Enum {
    public int value__;
    public static FileIOPermissionAccess NoAccess;
    public static FileIOPermissionAccess Read;
    public static FileIOPermissionAccess Write;
    public static FileIOPermissionAccess Append;
    public static FileIOPermissionAccess PathDiscovery;
    public static FileIOPermissionAccess AllAccess;
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileIOPermissionAttribute : CodeAccessSecurityAttribute {
    public string Read { get; public set; }
    public string Write { get; public set; }
    public string Append { get; public set; }
    public string PathDiscovery { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ChangeAccessControl { get; public set; }
    [ObsoleteAttribute("Please use the ViewAndModify property instead.")]
public string All { get; public set; }
    public string ViewAndModify { get; public set; }
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    public FileIOPermissionAttribute(SecurityAction action);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public string get_Append();
    public void set_Append(string value);
    public string get_PathDiscovery();
    public void set_PathDiscovery(string value);
    public string get_ViewAccessControl();
    public void set_ViewAccessControl(string value);
    public string get_ChangeAccessControl();
    public void set_ChangeAccessControl(string value);
    public void set_All(string value);
    public string get_All();
    public string get_ViewAndModify();
    public void set_ViewAndModify(string value);
    public FileIOPermissionAccess get_AllFiles();
    public void set_AllFiles(FileIOPermissionAccess value);
    public FileIOPermissionAccess get_AllLocalFiles();
    public void set_AllLocalFiles(FileIOPermissionAccess value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.GacIdentityPermission : CodeAccessPermission {
    public GacIdentityPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public GacIdentityPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4205")]
public class System.Security.Permissions.HostProtectionAttribute : CodeAccessSecurityAttribute {
    public HostProtectionResource Resources { get; public set; }
    public bool Synchronization { get; public set; }
    public bool SharedState { get; public set; }
    public bool ExternalProcessMgmt { get; public set; }
    public bool SelfAffectingProcessMgmt { get; public set; }
    public bool ExternalThreading { get; public set; }
    public bool SelfAffectingThreading { get; public set; }
    [ComVisibleAttribute("True")]
public bool SecurityInfrastructure { get; public set; }
    public bool UI { get; public set; }
    public bool MayLeakOnAbort { get; public set; }
    public HostProtectionAttribute(SecurityAction action);
    public HostProtectionResource get_Resources();
    public void set_Resources(HostProtectionResource value);
    public bool get_Synchronization();
    public void set_Synchronization(bool value);
    public bool get_SharedState();
    public void set_SharedState(bool value);
    public bool get_ExternalProcessMgmt();
    public void set_ExternalProcessMgmt(bool value);
    public bool get_SelfAffectingProcessMgmt();
    public void set_SelfAffectingProcessMgmt(bool value);
    public bool get_ExternalThreading();
    public void set_ExternalThreading(bool value);
    public bool get_SelfAffectingThreading();
    public void set_SelfAffectingThreading(bool value);
    public bool get_SecurityInfrastructure();
    public void set_SecurityInfrastructure(bool value);
    public bool get_UI();
    public void set_UI(bool value);
    public bool get_MayLeakOnAbort();
    public void set_MayLeakOnAbort(bool value);
    public virtual IPermission CreatePermission();
}
internal class System.Security.Permissions.HostProtectionPermission : CodeAccessPermission {
    internal static HostProtectionResource modreq(System.Runtime.CompilerServices.IsVolatile) protectedResources;
    public HostProtectionResource Resources { get; public set; }
    public HostProtectionPermission(PermissionState state);
    public HostProtectionPermission(HostProtectionResource resources);
    private static HostProtectionPermission();
    public sealed virtual bool IsUnrestricted();
    public void set_Resources(HostProtectionResource value);
    public HostProtectionResource get_Resources();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.HostProtectionResource : Enum {
    public int value__;
    public static HostProtectionResource None;
    public static HostProtectionResource Synchronization;
    public static HostProtectionResource SharedState;
    public static HostProtectionResource ExternalProcessMgmt;
    public static HostProtectionResource SelfAffectingProcessMgmt;
    public static HostProtectionResource ExternalThreading;
    public static HostProtectionResource SelfAffectingThreading;
    public static HostProtectionResource SecurityInfrastructure;
    public static HostProtectionResource UI;
    public static HostProtectionResource MayLeakOnAbort;
    public static HostProtectionResource All;
}
internal interface System.Security.Permissions.IBuiltInPermission {
    public abstract virtual int GetTokenIndex();
}
internal class System.Security.Permissions.IDRole : object {
    internal bool m_authenticated;
    internal string m_id;
    internal string m_role;
    internal SecurityIdentifier Sid { get; }
    [SecurityCriticalAttribute]
internal SecurityIdentifier get_Sid();
    internal SecurityElement ToXml();
    internal void FromXml(SecurityElement e);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.IsolatedStorageContainment : Enum {
    public int value__;
    public static IsolatedStorageContainment None;
    public static IsolatedStorageContainment DomainIsolationByUser;
    public static IsolatedStorageContainment ApplicationIsolationByUser;
    public static IsolatedStorageContainment AssemblyIsolationByUser;
    public static IsolatedStorageContainment DomainIsolationByMachine;
    public static IsolatedStorageContainment AssemblyIsolationByMachine;
    public static IsolatedStorageContainment ApplicationIsolationByMachine;
    public static IsolatedStorageContainment DomainIsolationByRoamingUser;
    public static IsolatedStorageContainment AssemblyIsolationByRoamingUser;
    public static IsolatedStorageContainment ApplicationIsolationByRoamingUser;
    public static IsolatedStorageContainment AdministerIsolatedStorageByUser;
    public static IsolatedStorageContainment UnrestrictedIsolatedStorage;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.IsolatedStorageFilePermission : IsolatedStoragePermission {
    public IsolatedStorageFilePermission(PermissionState state);
    internal IsolatedStorageFilePermission(IsolatedStorageContainment UsageAllowed, long ExpirationDays, bool PermanentData);
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
    [ComVisibleAttribute("False")]
public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
    public IsolatedStorageFilePermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Permissions.IsolatedStoragePermission : CodeAccessPermission {
    internal long m_userQuota;
    internal long m_machineQuota;
    internal long m_expirationDays;
    internal bool m_permanentData;
    internal IsolatedStorageContainment m_allowed;
    public long UserQuota { get; public set; }
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    protected IsolatedStoragePermission(PermissionState state);
    internal IsolatedStoragePermission(IsolatedStorageContainment UsageAllowed, long ExpirationDays, bool PermanentData);
    internal IsolatedStoragePermission(IsolatedStorageContainment UsageAllowed, long ExpirationDays, bool PermanentData, long UserQuota);
    public void set_UserQuota(long value);
    public long get_UserQuota();
    public void set_UsageAllowed(IsolatedStorageContainment value);
    public IsolatedStorageContainment get_UsageAllowed();
    public sealed virtual bool IsUnrestricted();
    internal static long min(long x, long y);
    internal static long max(long x, long y);
    public virtual SecurityElement ToXml();
    internal SecurityElement ToXml(string permName);
    public virtual void FromXml(SecurityElement esd);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
    internal long m_userQuota;
    internal IsolatedStorageContainment m_allowed;
    public long UserQuota { get; public set; }
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    protected IsolatedStoragePermissionAttribute(SecurityAction action);
    public void set_UserQuota(long value);
    public long get_UserQuota();
    public void set_UsageAllowed(IsolatedStorageContainment value);
    public IsolatedStorageContainment get_UsageAllowed();
}
[ComVisibleAttribute("True")]
public interface System.Security.Permissions.IUnrestrictedPermission {
    public abstract virtual bool IsUnrestricted();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermission : CodeAccessPermission {
    public KeyContainerPermissionFlags Flags { get; }
    public KeyContainerPermissionAccessEntryCollection AccessEntries { get; }
    public KeyContainerPermission(PermissionState state);
    public KeyContainerPermission(KeyContainerPermissionFlags flags);
    public KeyContainerPermission(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList);
    public KeyContainerPermissionFlags get_Flags();
    public KeyContainerPermissionAccessEntryCollection get_AccessEntries();
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static void VerifyFlags(KeyContainerPermissionFlags flags);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntry : object {
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public KeyContainerPermissionFlags Flags { get; public set; }
    internal KeyContainerPermissionAccessEntry(KeyContainerPermissionAccessEntry accessEntry);
    public KeyContainerPermissionAccessEntry(string keyContainerName, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(CspParameters parameters, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags);
    public string get_KeyStore();
    public void set_KeyStore(string value);
    public string get_ProviderName();
    public void set_ProviderName(string value);
    public int get_ProviderType();
    public void set_ProviderType(int value);
    public string get_KeyContainerName();
    public void set_KeyContainerName(string value);
    public int get_KeySpec();
    public void set_KeySpec(int value);
    public KeyContainerPermissionFlags get_Flags();
    public void set_Flags(KeyContainerPermissionFlags value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal bool IsSubsetOf(KeyContainerPermissionAccessEntry target);
    internal static bool IsUnrestrictedEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntryCollection : object {
    public KeyContainerPermissionAccessEntry Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal KeyContainerPermissionAccessEntryCollection(KeyContainerPermissionFlags globalFlags);
    public KeyContainerPermissionAccessEntry get_Item(int index);
    public sealed virtual int get_Count();
    public int Add(KeyContainerPermissionAccessEntry accessEntry);
    public void Clear();
    public int IndexOf(KeyContainerPermissionAccessEntry accessEntry);
    public void Remove(KeyContainerPermissionAccessEntry accessEntry);
    public KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator : object {
    public KeyContainerPermissionAccessEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal KeyContainerPermissionAccessEntryEnumerator(KeyContainerPermissionAccessEntryCollection entries);
    public KeyContainerPermissionAccessEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public KeyContainerPermissionFlags Flags { get; public set; }
    public KeyContainerPermissionAttribute(SecurityAction action);
    public string get_KeyStore();
    public void set_KeyStore(string value);
    public string get_ProviderName();
    public void set_ProviderName(string value);
    public int get_ProviderType();
    public void set_ProviderType(int value);
    public string get_KeyContainerName();
    public void set_KeyContainerName(string value);
    public int get_KeySpec();
    public void set_KeySpec(int value);
    public KeyContainerPermissionFlags get_Flags();
    public void set_Flags(KeyContainerPermissionFlags value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.KeyContainerPermissionFlags : Enum {
    public int value__;
    public static KeyContainerPermissionFlags NoFlags;
    public static KeyContainerPermissionFlags Create;
    public static KeyContainerPermissionFlags Open;
    public static KeyContainerPermissionFlags Delete;
    public static KeyContainerPermissionFlags Import;
    public static KeyContainerPermissionFlags Export;
    public static KeyContainerPermissionFlags Sign;
    public static KeyContainerPermissionFlags Decrypt;
    public static KeyContainerPermissionFlags ViewAcl;
    public static KeyContainerPermissionFlags ChangeAcl;
    public static KeyContainerPermissionFlags AllFlags;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.PermissionSetAttribute : CodeAccessSecurityAttribute {
    public string File { get; public set; }
    public bool UnicodeEncoded { get; public set; }
    public string Name { get; public set; }
    public string XML { get; public set; }
    public string Hex { get; public set; }
    public PermissionSetAttribute(SecurityAction action);
    public string get_File();
    public void set_File(string value);
    public bool get_UnicodeEncoded();
    public void set_UnicodeEncoded(bool value);
    public string get_Name();
    public void set_Name(string value);
    public string get_XML();
    public void set_XML(string value);
    public string get_Hex();
    public void set_Hex(string value);
    public virtual IPermission CreatePermission();
    [SecuritySafeCriticalAttribute]
public PermissionSet CreatePermissionSet();
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.PermissionState : Enum {
    public int value__;
    public static PermissionState Unrestricted;
    public static PermissionState None;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PrincipalPermission : object {
    public PrincipalPermission(PermissionState state);
    public PrincipalPermission(string name, string role);
    public PrincipalPermission(string name, string role, bool isAuthenticated);
    public sealed virtual bool IsUnrestricted();
    public sealed virtual bool IsSubsetOf(IPermission target);
    public sealed virtual IPermission Intersect(IPermission target);
    public sealed virtual IPermission Union(IPermission other);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    public sealed virtual IPermission Copy();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement elem);
    public virtual string ToString();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("68")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
    public string Name { get; public set; }
    public string Role { get; public set; }
    public bool Authenticated { get; public set; }
    public PrincipalPermissionAttribute(SecurityAction action);
    public string get_Name();
    public void set_Name(string value);
    public string get_Role();
    public void set_Role(string value);
    public bool get_Authenticated();
    public void set_Authenticated(bool value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PublisherIdentityPermission : CodeAccessPermission {
    public X509Certificate Certificate { get; public set; }
    public PublisherIdentityPermission(PermissionState state);
    public PublisherIdentityPermission(X509Certificate certificate);
    public void set_Certificate(X509Certificate value);
    public X509Certificate get_Certificate();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual void FromXml(SecurityElement esd);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public string X509Certificate { get; public set; }
    public string CertFile { get; public set; }
    public string SignedFile { get; public set; }
    public PublisherIdentityPermissionAttribute(SecurityAction action);
    public string get_X509Certificate();
    public void set_X509Certificate(string value);
    public string get_CertFile();
    public void set_CertFile(string value);
    public string get_SignedFile();
    public void set_SignedFile(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ReflectionPermission : CodeAccessPermission {
    internal static ReflectionPermissionFlag AllFlagsAndMore;
    public ReflectionPermissionFlag Flags { get; public set; }
    public ReflectionPermission(PermissionState state);
    public ReflectionPermission(ReflectionPermissionFlag flag);
    public void set_Flags(ReflectionPermissionFlag value);
    public ReflectionPermissionFlag get_Flags();
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Union(IPermission other);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
    public ReflectionPermissionFlag Flags { get; public set; }
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public bool TypeInformation { get; public set; }
    public bool MemberAccess { get; public set; }
    [ObsoleteAttribute("This permission is no longer used by the CLR.")]
public bool ReflectionEmit { get; public set; }
    public bool RestrictedMemberAccess { get; public set; }
    public ReflectionPermissionAttribute(SecurityAction action);
    public ReflectionPermissionFlag get_Flags();
    public void set_Flags(ReflectionPermissionFlag value);
    public bool get_TypeInformation();
    public void set_TypeInformation(bool value);
    public bool get_MemberAccess();
    public void set_MemberAccess(bool value);
    public bool get_ReflectionEmit();
    public void set_ReflectionEmit(bool value);
    public bool get_RestrictedMemberAccess();
    public void set_RestrictedMemberAccess(bool value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.ReflectionPermissionFlag : Enum {
    public int value__;
    public static ReflectionPermissionFlag NoFlags;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static ReflectionPermissionFlag TypeInformation;
    public static ReflectionPermissionFlag MemberAccess;
    [ObsoleteAttribute("This permission is no longer used by the CLR.")]
public static ReflectionPermissionFlag ReflectionEmit;
    [ComVisibleAttribute("False")]
public static ReflectionPermissionFlag RestrictedMemberAccess;
    [ObsoleteAttribute("This permission has been deprecated. Use PermissionState.Unrestricted to get full access.")]
public static ReflectionPermissionFlag AllFlags;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.RegistryPermission : CodeAccessPermission {
    public RegistryPermission(PermissionState state);
    public RegistryPermission(RegistryPermissionAccess access, string pathList);
    public RegistryPermission(RegistryPermissionAccess access, AccessControlActions control, string pathList);
    public void SetPathList(RegistryPermissionAccess access, string pathList);
    internal void SetPathList(AccessControlActions control, string pathList);
    public void AddPathList(RegistryPermissionAccess access, string pathList);
    [SecuritySafeCriticalAttribute]
public void AddPathList(RegistryPermissionAccess access, AccessControlActions control, string pathList);
    [SecuritySafeCriticalAttribute]
public string GetPathList(RegistryPermissionAccess access);
    public sealed virtual bool IsUnrestricted();
    [SecuritySafeCriticalAttribute]
public virtual bool IsSubsetOf(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Intersect(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Union(IPermission other);
    public virtual IPermission Copy();
    [SecuritySafeCriticalAttribute]
public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.RegistryPermissionAccess : Enum {
    public int value__;
    public static RegistryPermissionAccess NoAccess;
    public static RegistryPermissionAccess Read;
    public static RegistryPermissionAccess Write;
    public static RegistryPermissionAccess Create;
    public static RegistryPermissionAccess AllAccess;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.RegistryPermissionAttribute : CodeAccessSecurityAttribute {
    public string Read { get; public set; }
    public string Write { get; public set; }
    public string Create { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ChangeAccessControl { get; public set; }
    public string ViewAndModify { get; public set; }
    [ObsoleteAttribute("Please use the ViewAndModify property instead.")]
public string All { get; public set; }
    public RegistryPermissionAttribute(SecurityAction action);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public string get_Create();
    public void set_Create(string value);
    public string get_ViewAccessControl();
    public void set_ViewAccessControl(string value);
    public string get_ChangeAccessControl();
    public void set_ChangeAccessControl(string value);
    public string get_ViewAndModify();
    public void set_ViewAndModify(string value);
    public string get_All();
    public void set_All(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestRefuse;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    internal SecurityAction m_action;
    internal bool m_unrestricted;
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_Unrestricted();
    public void set_Unrestricted(bool value);
    public abstract virtual IPermission CreatePermission();
    [SecurityCriticalAttribute]
internal static IntPtr FindSecurityAttributeTypeHandle(string typeName);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SecurityPermission : CodeAccessPermission {
    public SecurityPermissionFlag Flags { get; public set; }
    public SecurityPermission(PermissionState state);
    public SecurityPermission(SecurityPermissionFlag flag);
    public void set_Flags(SecurityPermissionFlag value);
    public SecurityPermissionFlag get_Flags();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
    [SecurityCriticalAttribute]
internal static void MethodWithSkipVerificationLinkDemand();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Assertion { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool Execution { get; public set; }
    public bool ControlThread { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    [ComVisibleAttribute("True")]
public bool Infrastructure { get; public set; }
    public bool BindingRedirects { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    public SecurityPermissionFlag get_Flags();
    public void set_Flags(SecurityPermissionFlag value);
    public bool get_Assertion();
    public void set_Assertion(bool value);
    public bool get_UnmanagedCode();
    public void set_UnmanagedCode(bool value);
    public bool get_SkipVerification();
    public void set_SkipVerification(bool value);
    public bool get_Execution();
    public void set_Execution(bool value);
    public bool get_ControlThread();
    public void set_ControlThread(bool value);
    public bool get_ControlEvidence();
    public void set_ControlEvidence(bool value);
    public bool get_ControlPolicy();
    public void set_ControlPolicy(bool value);
    public bool get_SerializationFormatter();
    public void set_SerializationFormatter(bool value);
    public bool get_ControlDomainPolicy();
    public void set_ControlDomainPolicy(bool value);
    public bool get_ControlPrincipal();
    public void set_ControlPrincipal(bool value);
    public bool get_ControlAppDomain();
    public void set_ControlAppDomain(bool value);
    public bool get_RemotingConfiguration();
    public void set_RemotingConfiguration(bool value);
    public bool get_Infrastructure();
    public void set_Infrastructure(bool value);
    public bool get_BindingRedirects();
    public void set_BindingRedirects(bool value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag UnmanagedCode;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag AllFlags;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SiteIdentityPermission : CodeAccessPermission {
    public string Site { get; public set; }
    public SiteIdentityPermission(PermissionState state);
    public SiteIdentityPermission(string site);
    public void set_Site(string value);
    public string get_Site();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual void FromXml(SecurityElement esd);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public string Site { get; public set; }
    public SiteIdentityPermissionAttribute(SecurityAction action);
    public string get_Site();
    public void set_Site(string value);
    public virtual IPermission CreatePermission();
}
internal class System.Security.Permissions.StrongName2 : object {
    public StrongNamePublicKeyBlob m_publicKeyBlob;
    public string m_name;
    public Version m_version;
    public StrongName2(StrongNamePublicKeyBlob publicKeyBlob, string name, Version version);
    public StrongName2 Copy();
    public bool IsSubsetOf(StrongName2 target);
    public StrongName2 Intersect(StrongName2 target);
    public bool Equals(StrongName2 target);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.StrongNameIdentityPermission : CodeAccessPermission {
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public StrongNameIdentityPermission(PermissionState state);
    public StrongNameIdentityPermission(StrongNamePublicKeyBlob blob, string name, Version version);
    public void set_PublicKey(StrongNamePublicKeyBlob value);
    public StrongNamePublicKeyBlob get_PublicKey();
    public void set_Name(string value);
    public string get_Name();
    public void set_Version(Version value);
    public Version get_Version();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual void FromXml(SecurityElement e);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public string Name { get; public set; }
    public string Version { get; public set; }
    public string PublicKey { get; public set; }
    public StrongNameIdentityPermissionAttribute(SecurityAction action);
    public string get_Name();
    public void set_Name(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_PublicKey();
    public void set_PublicKey(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.StrongNamePublicKeyBlob : object {
    internal Byte[] PublicKey;
    public StrongNamePublicKeyBlob(Byte[] publicKey);
    internal StrongNamePublicKeyBlob(string publicKey);
    internal bool Equals(StrongNamePublicKeyBlob blob);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UIPermission : CodeAccessPermission {
    public UIPermissionWindow Window { get; public set; }
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermission(PermissionState state);
    public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag);
    public UIPermission(UIPermissionWindow windowFlag);
    public UIPermission(UIPermissionClipboard clipboardFlag);
    public void set_Window(UIPermissionWindow value);
    public UIPermissionWindow get_Window();
    public void set_Clipboard(UIPermissionClipboard value);
    public UIPermissionClipboard get_Clipboard();
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UIPermissionAttribute : CodeAccessSecurityAttribute {
    public UIPermissionWindow Window { get; public set; }
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermissionAttribute(SecurityAction action);
    public UIPermissionWindow get_Window();
    public void set_Window(UIPermissionWindow value);
    public UIPermissionClipboard get_Clipboard();
    public void set_Clipboard(UIPermissionClipboard value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.UIPermissionClipboard : Enum {
    public int value__;
    public static UIPermissionClipboard NoClipboard;
    public static UIPermissionClipboard OwnClipboard;
    public static UIPermissionClipboard AllClipboard;
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.UIPermissionWindow : Enum {
    public int value__;
    public static UIPermissionWindow NoWindows;
    public static UIPermissionWindow SafeSubWindows;
    public static UIPermissionWindow SafeTopLevelWindows;
    public static UIPermissionWindow AllWindows;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UrlIdentityPermission : CodeAccessPermission {
    public string Url { get; public set; }
    public UrlIdentityPermission(PermissionState state);
    public UrlIdentityPermission(string site);
    internal UrlIdentityPermission(URLString site);
    internal void AppendOrigin(ArrayList originList);
    public void set_Url(string value);
    public string get_Url();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual void FromXml(SecurityElement esd);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public string Url { get; public set; }
    public UrlIdentityPermissionAttribute(SecurityAction action);
    public string get_Url();
    public void set_Url(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ZoneIdentityPermission : CodeAccessPermission {
    public SecurityZone SecurityZone { get; public set; }
    public ZoneIdentityPermission(PermissionState state);
    public ZoneIdentityPermission(SecurityZone zone);
    internal ZoneIdentityPermission(UInt32 zones);
    internal void AppendZones(ArrayList zoneList);
    public void set_SecurityZone(SecurityZone value);
    public SecurityZone get_SecurityZone();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    internal static int GetTokenIndex();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public SecurityZone Zone { get; public set; }
    public ZoneIdentityPermissionAttribute(SecurityAction action);
    public SecurityZone get_Zone();
    public void set_Zone(SecurityZone value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.PermissionSet : object {
    [OptionalFieldAttribute]
internal TokenBasedSet m_permSet;
    internal static PermissionSet s_fullTrust;
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    unknown bool IgnoreTypeLoadFailures {internal set; }
    internal PermissionSet(bool fUnrestricted);
    public PermissionSet(PermissionState state);
    public PermissionSet(PermissionSet permSet);
    private static PermissionSet();
    public virtual void CopyTo(Array array, int index);
    public virtual object get_SyncRoot();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsReadOnly();
    internal void Reset();
    internal void CheckSet();
    public bool IsEmpty();
    internal bool FastIsEmpty();
    public virtual int get_Count();
    internal IPermission GetPermission(int index);
    internal IPermission GetPermission(PermissionToken permToken);
    internal IPermission GetPermission(IPermission perm);
    public IPermission GetPermission(Type permClass);
    protected virtual IPermission GetPermissionImpl(Type permClass);
    public IPermission SetPermission(IPermission perm);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
    public IPermission AddPermission(IPermission perm);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    public IPermission RemovePermission(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    internal void SetUnrestricted(bool unrestricted);
    public bool IsUnrestricted();
    internal bool IsSubsetOfHelper(PermissionSet target, IsSubsetOfType type, IPermission& firstPermThatFailed, bool ignoreNonCas);
    public bool IsSubsetOf(PermissionSet target);
    internal bool CheckDemand(PermissionSet target, IPermission& firstPermThatFailed);
    internal bool CheckPermitOnly(PermissionSet target, IPermission& firstPermThatFailed);
    internal bool CheckAssertion(PermissionSet target);
    internal bool CheckDeny(PermissionSet deniedSet, IPermission& firstPermThatFailed);
    internal void CheckDecoded(CodeAccessPermission demandedPerm, PermissionToken tokenDemandedPerm);
    internal void CheckDecoded(int index);
    internal void CheckDecoded(PermissionSet demandedSet);
    internal static void SafeChildAdd(SecurityElement parent, ISecurityElementFactory child, bool copy);
    internal void InplaceIntersect(PermissionSet other);
    public PermissionSet Intersect(PermissionSet other);
    internal void InplaceUnion(PermissionSet other);
    public PermissionSet Union(PermissionSet other);
    internal void MergeDeniedSet(PermissionSet denied);
    internal bool Contains(IPermission perm);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    [SecurityCriticalAttribute]
internal void DemandNonCAS();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Assert();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public sealed virtual void Deny();
    [SecuritySafeCriticalAttribute]
public sealed virtual void PermitOnly();
    internal IPermission GetFirstPerm();
    public virtual PermissionSet Copy();
    internal PermissionSet CopyWithNoIdentityPermissions();
    public sealed virtual IEnumerator GetEnumerator();
    protected virtual IEnumerator GetEnumeratorImpl();
    internal PermissionSetEnumeratorInternal GetEnumeratorInternal();
    public virtual string ToString();
    internal void FilterHostProtectionPermissions(HostProtectionResource fullTrustOnly, HostProtectionResource inaccessible);
    public virtual void FromXml(SecurityElement et);
    internal static bool IsPermissionTag(string tag, bool allowInternalOnly);
    internal virtual void FromXml(SecurityElement et, bool allowInternalOnly, bool ignoreTypeLoadFailures);
    internal virtual void FromXml(SecurityDocument doc, int position, bool allowInternalOnly);
    internal static IPermission CreatePerm(object obj, bool ignoreTypeLoadFailures);
    internal IPermission CreatePermission(object obj, int index);
    internal static SecurityElement CreateEmptyPermissionSetXml();
    internal SecurityElement ToXml(string permName);
    internal SecurityElement InternalToXml();
    public virtual SecurityElement ToXml();
    internal Byte[] EncodeXml();
    [ObsoleteAttribute("This method is obsolete and shoud no longer be used.")]
public static Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat);
    public bool ContainsNonCodeAccessPermissions();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecuritySafeCriticalAttribute]
public static void RevertAssert();
    internal static PermissionSet RemoveRefusedPermissionSet(PermissionSet assertSet, PermissionSet refusedSet, Boolean& bFailedToCompress);
    internal static void RemoveAssertedPermissionSet(PermissionSet demandSet, PermissionSet assertSet, PermissionSet& alteredDemandSet);
    internal static bool IsIntersectingAssertedPermissions(PermissionSet assertSet1, PermissionSet assertSet2);
    internal void set_IgnoreTypeLoadFailures(bool value);
}
internal class System.Security.PermissionSetEnumerator : object {
    public object Current { get; }
    internal PermissionSetEnumerator(PermissionSet permSet);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Security.PermissionSetEnumeratorInternal : ValueType {
    private PermissionSet m_permSet;
    private TokenBasedSetEnumerator enm;
    public object Current { get; }
    internal PermissionSetEnumeratorInternal(PermissionSet permSet);
    public object get_Current();
    public int GetCurrentIndex();
    public void Reset();
    public bool MoveNext();
}
internal class System.Security.PermissionSetTriple : object {
    internal PermissionSet AssertSet;
    internal PermissionSet GrantSet;
    internal PermissionSet RefusedSet;
    internal PermissionSetTriple(PermissionSetTriple triple);
    internal void Reset();
    internal bool IsEmpty();
    [SecurityCriticalAttribute]
internal bool Update(PermissionSetTriple psTriple, PermissionSetTriple& retTriple);
    [SecurityCriticalAttribute]
internal PermissionSetTriple UpdateAssert(PermissionSet in_a);
    [SecurityCriticalAttribute]
internal void UpdateGrant(PermissionSet in_g, ZoneIdentityPermission& z, UrlIdentityPermission& u);
    [SecurityCriticalAttribute]
internal void UpdateGrant(PermissionSet in_g);
    internal void UpdateRefused(PermissionSet in_r);
    [SecurityCriticalAttribute]
internal bool CheckDemand(CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckSetDemand(PermissionSet demandSet, PermissionSet& alteredDemandset, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckDemandNoThrow(CodeAccessPermission demand, PermissionToken permToken);
    [SecurityCriticalAttribute]
internal bool CheckSetDemandNoThrow(PermissionSet demandSet);
    [SecurityCriticalAttribute]
internal bool CheckFlags(Int32& flags);
}
internal class System.Security.PermissionToken : object {
    internal int m_index;
    internal PermissionTokenType modreq(System.Runtime.CompilerServices.IsVolatile) m_type;
    internal string m_strTypeName;
    internal static TokenBasedSet s_tokenSet;
    private static PermissionToken();
    internal PermissionToken(int index, PermissionTokenType type, string strTypeName);
    internal static bool IsMscorlibClassName(string className);
    [SecurityCriticalAttribute]
public static PermissionToken GetToken(Type cls);
    public static PermissionToken GetToken(IPermission perm);
    public static PermissionToken GetToken(string typeStr);
    public static PermissionToken GetToken(string typeStr, bool bCreateMscorlib);
    [SecuritySafeCriticalAttribute]
public static PermissionToken FindToken(Type cls);
    public static PermissionToken FindTokenByIndex(int i);
    public static bool IsTokenProperlyAssigned(IPermission perm, PermissionToken token);
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement elRoot);
}
internal class System.Security.PermissionTokenFactory : object {
    internal PermissionTokenFactory(int size);
    [SecuritySafeCriticalAttribute]
internal PermissionToken FindToken(Type cls);
    internal PermissionToken FindTokenByIndex(int i);
    [SecuritySafeCriticalAttribute]
internal PermissionToken GetToken(Type cls, IPermission perm);
    internal PermissionToken GetToken(string typeStr);
    internal PermissionToken BuiltInGetToken(int index, IPermission perm, Type cls);
}
internal class System.Security.PermissionTokenKeyComparer : object {
    [SecuritySafeCriticalAttribute]
public int Compare(object a, object b);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[FlagsAttribute]
internal enum System.Security.PermissionTokenType : Enum {
    public int value__;
    public static PermissionTokenType Normal;
    public static PermissionTokenType IUnrestricted;
    public static PermissionTokenType DontKnow;
    public static PermissionTokenType BuiltIn;
}
internal enum System.Security.PermissionType : Enum {
    public int value__;
    public static PermissionType SecurityUnmngdCodeAccess;
    public static PermissionType SecuritySkipVerification;
    public static PermissionType ReflectionTypeInfo;
    public static PermissionType SecurityAssert;
    public static PermissionType ReflectionMemberAccess;
    public static PermissionType SecuritySerialization;
    public static PermissionType ReflectionRestrictedMemberAccess;
    public static PermissionType FullTrust;
    public static PermissionType SecurityBindingRedirects;
    public static PermissionType UIPermission;
    public static PermissionType EnvironmentPermission;
    public static PermissionType FileDialogPermission;
    public static PermissionType FileIOPermission;
    public static PermissionType ReflectionPermission;
    public static PermissionType SecurityPermission;
    public static PermissionType SecurityControlEvidence;
    public static PermissionType SecurityControlPrincipal;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.AllMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Security.Policy.AppDomainEvidenceFactory : object {
    public IEvidenceFactory Target { get; }
    internal AppDomainEvidenceFactory(AppDomain target);
    public sealed virtual IEvidenceFactory get_Target();
    public sealed virtual IEnumerable`1<EvidenceBase> GetFactorySuppliedEvidence();
    [SecuritySafeCriticalAttribute]
public sealed virtual EvidenceBase GenerateEvidence(Type evidenceType);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationDirectory : EvidenceBase {
    public string Directory { get; }
    public ApplicationDirectory(string name);
    public string get_Directory();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationDirectoryMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Security.Policy.ApplicationSecurityInfo : object {
    public ApplicationId ApplicationId { get; public set; }
    public ApplicationId DeploymentId { get; public set; }
    public PermissionSet DefaultRequestSet { get; public set; }
    public Evidence ApplicationEvidence { get; public set; }
    public ApplicationSecurityInfo(ActivationContext activationContext);
    public ApplicationId get_ApplicationId();
    public void set_ApplicationId(ApplicationId value);
    public ApplicationId get_DeploymentId();
    public void set_DeploymentId(ApplicationId value);
    public PermissionSet get_DefaultRequestSet();
    public void set_DefaultRequestSet(PermissionSet value);
    public Evidence get_ApplicationEvidence();
    public void set_ApplicationEvidence(Evidence value);
}
[ComVisibleAttribute("True")]
public static class System.Security.Policy.ApplicationSecurityManager : object {
    public static ApplicationTrustCollection UserApplicationTrusts { get; }
    public static IApplicationTrustManager ApplicationTrustManager { get; }
    [SecuritySafeCriticalAttribute]
private static ApplicationSecurityManager();
    [SecurityCriticalAttribute]
public static bool DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
    [SecuritySafeCriticalAttribute]
public static ApplicationTrustCollection get_UserApplicationTrusts();
    [SecuritySafeCriticalAttribute]
public static IApplicationTrustManager get_ApplicationTrustManager();
    [SecurityCriticalAttribute]
internal static ApplicationTrust DetermineApplicationTrustInternal(ActivationContext activationContext, TrustManagerContext context);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationTrust : EvidenceBase {
    public ApplicationIdentity ApplicationIdentity { get; public set; }
    public PolicyStatement DefaultGrantSet { get; public set; }
    public IList`1<StrongName> FullTrustAssemblies { get; }
    public bool IsApplicationTrustedToRun { get; public set; }
    public bool Persist { get; public set; }
    public object ExtraInfo { get; public set; }
    public ApplicationTrust(ApplicationIdentity applicationIdentity);
    internal ApplicationTrust(PermissionSet defaultGrantSet);
    public ApplicationTrust(PermissionSet defaultGrantSet, IEnumerable`1<StrongName> fullTrustAssemblies);
    public ApplicationIdentity get_ApplicationIdentity();
    public void set_ApplicationIdentity(ApplicationIdentity value);
    public PolicyStatement get_DefaultGrantSet();
    public void set_DefaultGrantSet(PolicyStatement value);
    public IList`1<StrongName> get_FullTrustAssemblies();
    public bool get_IsApplicationTrustedToRun();
    public void set_IsApplicationTrustedToRun(bool value);
    public bool get_Persist();
    public void set_Persist(bool value);
    public object get_ExtraInfo();
    public void set_ExtraInfo(object value);
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement element);
    [SecuritySafeCriticalAttribute]
public virtual EvidenceBase Clone();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Security.Policy.ApplicationTrustCollection : object {
    public int Count { get; }
    public ApplicationTrust Item { get; }
    public ApplicationTrust Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal ApplicationTrustCollection(bool storeBounded);
    private static ApplicationTrustCollection();
    [SecuritySafeCriticalAttribute]
public sealed virtual int get_Count();
    [SecurityCriticalAttribute]
public ApplicationTrust get_Item(int index);
    [SecurityCriticalAttribute]
public ApplicationTrust get_Item(string appFullName);
    [SecurityCriticalAttribute]
public int Add(ApplicationTrust trust);
    [SecurityCriticalAttribute]
public void AddRange(ApplicationTrust[] trusts);
    [SecurityCriticalAttribute]
public void AddRange(ApplicationTrustCollection trusts);
    [SecurityCriticalAttribute]
public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    [SecurityCriticalAttribute]
public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    [SecurityCriticalAttribute]
public void Remove(ApplicationTrust trust);
    [SecurityCriticalAttribute]
public void RemoveRange(ApplicationTrust[] trusts);
    [SecurityCriticalAttribute]
public void RemoveRange(ApplicationTrustCollection trusts);
    [SecurityCriticalAttribute]
public void Clear();
    public ApplicationTrustEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecuritySafeCriticalAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ApplicationTrust[] array, int index);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool get_IsSynchronized();
    [SecuritySafeCriticalAttribute]
public sealed virtual object get_SyncRoot();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationTrustEnumerator : object {
    public ApplicationTrust Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    [SecurityCriticalAttribute]
internal ApplicationTrustEnumerator(ApplicationTrustCollection trusts);
    [SecuritySafeCriticalAttribute]
public ApplicationTrust get_Current();
    [SecuritySafeCriticalAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
public enum System.Security.Policy.ApplicationVersionMatch : Enum {
    public int value__;
    public static ApplicationVersionMatch MatchExactVersion;
    public static ApplicationVersionMatch MatchAllVersions;
}
internal class System.Security.Policy.AssemblyEvidenceFactory : object {
    internal SafePEFileHandle PEFile { get; }
    public IEvidenceFactory Target { get; }
    [SecurityCriticalAttribute]
internal SafePEFileHandle get_PEFile();
    public sealed virtual IEvidenceFactory get_Target();
    public sealed virtual EvidenceBase GenerateEvidence(Type evidenceType);
    public sealed virtual IEnumerable`1<EvidenceBase> GetFactorySuppliedEvidence();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.CodeConnectAccess : object {
    internal static int NoPort;
    internal static int AnyPort;
    public static int DefaultPort;
    public static int OriginPort;
    public static string OriginScheme;
    public static string AnyScheme;
    public string Scheme { get; }
    public int Port { get; }
    internal bool IsOriginScheme { get; }
    internal bool IsAnyScheme { get; }
    internal bool IsDefaultPort { get; }
    internal bool IsOriginPort { get; }
    internal string StrPort { get; }
    public CodeConnectAccess(string allowScheme, int allowPort);
    internal CodeConnectAccess(string allowScheme, string allowPort);
    private static CodeConnectAccess();
    public static CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
    public static CodeConnectAccess CreateAnySchemeAccess(int allowPort);
    public string get_Scheme();
    public int get_Port();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal bool get_IsOriginScheme();
    internal bool get_IsAnyScheme();
    internal bool get_IsDefaultPort();
    internal bool get_IsOriginPort();
    internal string get_StrPort();
    internal static bool IsValidScheme(string scheme);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Policy.CodeGroup : object {
    public IList Children { get; public set; }
    public IMembershipCondition MembershipCondition { get; public set; }
    public PolicyStatement PolicyStatement { get; public set; }
    public string Name { get; public set; }
    public string Description { get; public set; }
    public string PermissionSetName { get; }
    public string AttributeString { get; }
    public string MergeLogic { get; }
    internal CodeGroup(IMembershipCondition membershipCondition, PermissionSet permSet);
    protected CodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    [SecuritySafeCriticalAttribute]
public void AddChild(CodeGroup group);
    [SecurityCriticalAttribute]
internal void AddChildInternal(CodeGroup group);
    [SecuritySafeCriticalAttribute]
public void RemoveChild(CodeGroup group);
    [SecuritySafeCriticalAttribute]
public IList get_Children();
    public void set_Children(IList value);
    [SecurityCriticalAttribute]
internal IList GetChildrenInternal();
    [SecuritySafeCriticalAttribute]
public IMembershipCondition get_MembershipCondition();
    public void set_MembershipCondition(IMembershipCondition value);
    public PolicyStatement get_PolicyStatement();
    public void set_PolicyStatement(PolicyStatement value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Description();
    public void set_Description(string value);
    public abstract virtual PolicyStatement Resolve(Evidence evidence);
    public abstract virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public abstract virtual CodeGroup Copy();
    public virtual string get_PermissionSetName();
    public virtual string get_AttributeString();
    public abstract virtual string get_MergeLogic();
    public SecurityElement ToXml();
    public void FromXml(SecurityElement e);
    [SecuritySafeCriticalAttribute]
public SecurityElement ToXml(PolicyLevel level);
    internal virtual string GetTypeName();
    [SecurityCriticalAttribute]
internal SecurityElement ToXml(PolicyLevel level, string policyClassName);
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    public void FromXml(SecurityElement e, PolicyLevel level);
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    [SecurityCriticalAttribute]
internal void ParseChildren();
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object o);
    [SecuritySafeCriticalAttribute]
public bool Equals(CodeGroup cg, bool compareChildren);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
}
internal class System.Security.Policy.CodeGroupPositionMarker : object {
    internal int elementIndex;
    internal int groupIndex;
    internal SecurityElement element;
    internal CodeGroupPositionMarker(int elementIndex, int groupIndex, SecurityElement element);
}
internal class System.Security.Policy.CodeGroupStack : object {
    internal void Push(CodeGroupStackFrame element);
    internal CodeGroupStackFrame Pop();
    internal bool IsEmpty();
}
internal class System.Security.Policy.CodeGroupStackFrame : object {
    internal CodeGroup current;
    internal PolicyStatement policy;
    internal CodeGroupStackFrame parent;
}
internal enum System.Security.Policy.ConfigId : Enum {
    public int value__;
    public static ConfigId None;
    public static ConfigId MachinePolicyLevel;
    public static ConfigId UserPolicyLevel;
    public static ConfigId EnterprisePolicyLevel;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Evidence : object {
    internal static Type[] RuntimeEvidenceTypes { get; }
    internal bool IsUnmodified { get; }
    public bool Locked { get; public set; }
    internal IRuntimeEvidenceFactory Target { get; internal set; }
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Please use GetHostEnumerator and GetAssemblyEnumerator to iterate over the evidence to collect a count.")]
public int Count { get; }
    [ComVisibleAttribute("False")]
internal int RawCount { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public Evidence(Evidence evidence);
    [ObsoleteAttribute("This constructor is obsolete. Please use the constructor which takes arrays of EvidenceBase instead.")]
public Evidence(Object[] hostEvidence, Object[] assemblyEvidence);
    public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
    [SecuritySafeCriticalAttribute]
internal Evidence(IRuntimeEvidenceFactory target);
    internal static Type[] get_RuntimeEvidenceTypes();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete. Please use AddHostEvidence instead.")]
public void AddHost(object id);
    [ObsoleteAttribute("This method is obsolete. Please use AddAssemblyEvidence instead.")]
public void AddAssembly(object id);
    [ComVisibleAttribute("False")]
public void AddAssemblyEvidence(T evidence);
    [ComVisibleAttribute("False")]
public void AddHostEvidence(T evidence);
    internal bool get_IsUnmodified();
    public bool get_Locked();
    [SecuritySafeCriticalAttribute]
public void set_Locked(bool value);
    internal IRuntimeEvidenceFactory get_Target();
    [SecurityCriticalAttribute]
internal void set_Target(IRuntimeEvidenceFactory value);
    internal EvidenceTypeDescriptor GetEvidenceTypeDescriptor(Type evidenceType);
    [SecuritySafeCriticalAttribute]
public void Merge(Evidence evidence);
    internal void MergeWithNoDuplicates(Evidence evidence);
    [SecurityCriticalAttribute]
internal Byte[] RawSerialize();
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Please use the GetHostEnumerator and GetAssemblyEnumerator methods rather than using CopyTo.")]
public sealed virtual void CopyTo(Array array, int index);
    public IEnumerator GetHostEnumerator();
    public IEnumerator GetAssemblyEnumerator();
    internal RawEvidenceEnumerator GetRawAssemblyEvidenceEnumerator();
    internal RawEvidenceEnumerator GetRawHostEvidenceEnumerator();
    [ObsoleteAttribute("GetEnumerator is obsolete. Please use GetAssemblyEnumerator and GetHostEnumerator instead.")]
public sealed virtual IEnumerator GetEnumerator();
    [ComVisibleAttribute("False")]
public T GetAssemblyEvidence();
    internal EvidenceBase GetAssemblyEvidence(Type type);
    [ComVisibleAttribute("False")]
public T GetHostEvidence();
    internal T GetDelayEvaluatedHostEvidence();
    internal EvidenceBase GetHostEvidence(Type type);
    public sealed virtual int get_Count();
    internal int get_RawCount();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    [ComVisibleAttribute("False")]
public Evidence Clone();
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public void Clear();
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public void RemoveType(Type t);
    internal void MarkAllEvidenceAsUsed();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Policy.EvidenceBase : object {
    [SecuritySafeCriticalAttribute]
public virtual EvidenceBase Clone();
}
internal class System.Security.Policy.EvidenceTypeDescriptor : object {
    public EvidenceBase AssemblyEvidence { get; public set; }
    public bool Generated { get; public set; }
    public bool HostCanGenerate { get; public set; }
    public EvidenceBase HostEvidence { get; public set; }
    public EvidenceBase get_AssemblyEvidence();
    public void set_AssemblyEvidence(EvidenceBase value);
    public bool get_Generated();
    public void set_Generated(bool value);
    public bool get_HostCanGenerate();
    public void set_HostCanGenerate(bool value);
    public EvidenceBase get_HostEvidence();
    public void set_HostEvidence(EvidenceBase value);
    public EvidenceTypeDescriptor Clone();
}
internal enum System.Security.Policy.EvidenceTypeGenerated : Enum {
    public int value__;
    public static EvidenceTypeGenerated AssemblySupplied;
    public static EvidenceTypeGenerated Gac;
    public static EvidenceTypeGenerated Hash;
    public static EvidenceTypeGenerated PermissionRequest;
    public static EvidenceTypeGenerated Publisher;
    public static EvidenceTypeGenerated Site;
    public static EvidenceTypeGenerated StrongName;
    public static EvidenceTypeGenerated Url;
    public static EvidenceTypeGenerated Zone;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.FileCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public string PermissionSetName { get; }
    public string AttributeString { get; }
    public FileCodeGroup(IMembershipCondition membershipCondition, FileIOPermissionAccess access);
    [SecuritySafeCriticalAttribute]
public virtual PolicyStatement Resolve(Evidence evidence);
    private sealed virtual override PolicyStatement System.Security.Policy.IUnionSemanticCodeGroup.InternalResolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    internal PolicyStatement CalculatePolicy(Url url);
    public virtual CodeGroup Copy();
    public virtual string get_MergeLogic();
    public virtual string get_PermissionSetName();
    public virtual string get_AttributeString();
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal virtual string GetTypeName();
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute("This type is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public class System.Security.Policy.FirstMatchCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public FirstMatchCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    [SecuritySafeCriticalAttribute]
public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public virtual CodeGroup Copy();
    public virtual string get_MergeLogic();
    internal virtual string GetTypeName();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.GacInstalled : EvidenceBase {
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.GacMembershipCondition : object {
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Hash : EvidenceBase {
    public Byte[] SHA1 { get; }
    public Byte[] SHA256 { get; }
    public Byte[] MD5 { get; }
    [SecurityCriticalAttribute]
internal Hash(SerializationInfo info, StreamingContext context);
    public Hash(Assembly assembly);
    public static Hash CreateSHA1(Byte[] sha1);
    public static Hash CreateSHA256(Byte[] sha256);
    public static Hash CreateMD5(Byte[] md5);
    public virtual EvidenceBase Clone();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Byte[] get_SHA1();
    public Byte[] get_SHA256();
    public Byte[] get_MD5();
    public Byte[] GenerateHash(HashAlgorithm hashAlg);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.HashMembershipCondition : object {
    public HashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HashValue { get; public set; }
    public HashMembershipCondition(HashAlgorithm hashAlg, Byte[] value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public void set_HashAlgorithm(HashAlgorithm value);
    public HashAlgorithm get_HashAlgorithm();
    public void set_HashValue(Byte[] value);
    public Byte[] get_HashValue();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public interface System.Security.Policy.IApplicationTrustManager {
    public abstract virtual ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
}
internal interface System.Security.Policy.IConstantMembershipCondition {
}
internal interface System.Security.Policy.IDelayEvaluatedEvidence {
    public bool IsVerified { get; }
    public bool WasUsed { get; }
    [SecurityCriticalAttribute]
public abstract virtual bool get_IsVerified();
    public abstract virtual bool get_WasUsed();
    public abstract virtual void MarkUsed();
}
[ComVisibleAttribute("True")]
public interface System.Security.Policy.IIdentityPermissionFactory {
    public abstract virtual IPermission CreateIdentityPermission(Evidence evidence);
}
internal interface System.Security.Policy.ILegacyEvidenceAdapter {
    public object EvidenceObject { get; }
    public Type EvidenceType { get; }
    public abstract virtual object get_EvidenceObject();
    public abstract virtual Type get_EvidenceType();
}
[ComVisibleAttribute("True")]
public interface System.Security.Policy.IMembershipCondition {
    public abstract virtual bool Check(Evidence evidence);
    public abstract virtual IMembershipCondition Copy();
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object obj);
}
internal interface System.Security.Policy.IReportMatchMembershipCondition {
    public abstract virtual bool Check(Evidence evidence, Object& usedEvidence);
}
internal interface System.Security.Policy.IRuntimeEvidenceFactory {
    public IEvidenceFactory Target { get; }
    public abstract virtual IEvidenceFactory get_Target();
    public abstract virtual IEnumerable`1<EvidenceBase> GetFactorySuppliedEvidence();
    public abstract virtual EvidenceBase GenerateEvidence(Type evidenceType);
}
internal interface System.Security.Policy.IUnionSemanticCodeGroup {
    public abstract virtual PolicyStatement InternalResolve(Evidence evidence);
}
internal class System.Security.Policy.LegacyEvidenceList : EvidenceBase {
    public object EvidenceObject { get; }
    public Type EvidenceType { get; }
    public sealed virtual object get_EvidenceObject();
    public sealed virtual Type get_EvidenceType();
    public void Add(EvidenceBase evidence);
    public sealed virtual IEnumerator`1<EvidenceBase> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecuritySafeCriticalAttribute]
public virtual EvidenceBase Clone();
}
internal class System.Security.Policy.LegacyEvidenceWrapper : EvidenceBase {
    public object EvidenceObject { get; }
    public Type EvidenceType { get; }
    internal LegacyEvidenceWrapper(object legacyEvidence);
    public sealed virtual object get_EvidenceObject();
    public sealed virtual Type get_EvidenceType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual EvidenceBase Clone();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.NetCodeGroup : CodeGroup {
    public static string AnyOtherOriginScheme;
    public static string AbsentOriginScheme;
    public string MergeLogic { get; }
    public string PermissionSetName { get; }
    public string AttributeString { get; }
    public NetCodeGroup(IMembershipCondition membershipCondition);
    private static NetCodeGroup();
    public void ResetConnectAccess();
    public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess);
    public DictionaryEntry[] GetConnectAccessRules();
    [SecuritySafeCriticalAttribute]
public virtual PolicyStatement Resolve(Evidence evidence);
    private sealed virtual override PolicyStatement System.Security.Policy.IUnionSemanticCodeGroup.InternalResolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    internal SecurityElement CreateWebPermission(string host, string scheme, string port, string assemblyOverride);
    internal PolicyStatement CalculatePolicy(string host, string scheme, string port);
    public virtual CodeGroup Copy();
    public virtual string get_MergeLogic();
    public virtual string get_PermissionSetName();
    public virtual string get_AttributeString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    internal virtual string GetTypeName();
}
internal class System.Security.Policy.PEFileEvidenceFactory : object {
    internal SafePEFileHandle PEFile { get; }
    public IEvidenceFactory Target { get; }
    [SecurityCriticalAttribute]
internal SafePEFileHandle get_PEFile();
    public sealed virtual IEvidenceFactory get_Target();
    [SecuritySafeCriticalAttribute]
internal void FireEvidenceGeneratedEvent(EvidenceTypeGenerated type);
    [SecuritySafeCriticalAttribute]
public sealed virtual IEnumerable`1<EvidenceBase> GetFactorySuppliedEvidence();
    public sealed virtual EvidenceBase GenerateEvidence(Type evidenceType);
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public class System.Security.Policy.PermissionRequestEvidence : EvidenceBase {
    public PermissionSet RequestedPermissions { get; }
    public PermissionSet OptionalPermissions { get; }
    public PermissionSet DeniedPermissions { get; }
    public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied);
    public PermissionSet get_RequestedPermissions();
    public PermissionSet get_OptionalPermissions();
    public PermissionSet get_DeniedPermissions();
    public virtual EvidenceBase Clone();
    public PermissionRequestEvidence Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyException : SystemException {
    public PolicyException(string message);
    public PolicyException(string message, Exception exception);
    protected PolicyException(SerializationInfo info, StreamingContext context);
    internal PolicyException(string message, int hresult);
    internal PolicyException(string message, int hresult, Exception exception);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyLevel : object {
    public string Label { get; }
    [ComVisibleAttribute("False")]
public PolicyLevelType Type { get; }
    internal ConfigId ConfigId { get; }
    internal string Path { get; }
    public string StoreLocation { get; }
    public CodeGroup RootCodeGroup { get; public set; }
    public IList NamedPermissionSets { get; }
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public IList FullTrustAssemblies { get; }
    private static PolicyLevel();
    [SecurityCriticalAttribute]
internal PolicyLevel(PolicyLevelType type);
    internal PolicyLevel(PolicyLevelType type, string path);
    internal PolicyLevel(PolicyLevelType type, string path, ConfigId configId);
    [SecurityCriticalAttribute]
internal static string GetLocationFromType(PolicyLevelType type);
    [ObsoleteAttribute("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static PolicyLevel CreateAppDomainLevel();
    public string get_Label();
    public PolicyLevelType get_Type();
    internal ConfigId get_ConfigId();
    internal string get_Path();
    [SecuritySafeCriticalAttribute]
public string get_StoreLocation();
    [SecuritySafeCriticalAttribute]
public CodeGroup get_RootCodeGroup();
    [SecuritySafeCriticalAttribute]
public void set_RootCodeGroup(CodeGroup value);
    [SecuritySafeCriticalAttribute]
public IList get_NamedPermissionSets();
    public CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void AddFullTrustAssembly(StrongName sn);
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
[SecuritySafeCriticalAttribute]
public void AddFullTrustAssembly(StrongNameMembershipCondition snMC);
    [ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void RemoveFullTrustAssembly(StrongName sn);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Because all GAC assemblies always get full trust, the full trust list is no longer meaningful. You should install any assemblies that are used in security policy in the GAC to ensure they are trusted.")]
public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC);
    [SecuritySafeCriticalAttribute]
public IList get_FullTrustAssemblies();
    [SecuritySafeCriticalAttribute]
public void AddNamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet);
    [SecuritySafeCriticalAttribute]
public NamedPermissionSet RemoveNamedPermissionSet(string name);
    [SecuritySafeCriticalAttribute]
public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet);
    [SecuritySafeCriticalAttribute]
public NamedPermissionSet GetNamedPermissionSet(string name);
    [SecuritySafeCriticalAttribute]
public void Recover();
    [SecuritySafeCriticalAttribute]
public void Reset();
    [SecuritySafeCriticalAttribute]
public PolicyStatement Resolve(Evidence evidence);
    [SecuritySafeCriticalAttribute]
public SecurityElement ToXml();
    public void FromXml(SecurityElement e);
    [SecurityCriticalAttribute]
internal static PermissionSet GetBuiltInSet(string name);
    [SecurityCriticalAttribute]
internal NamedPermissionSet GetNamedPermissionSetInternal(string name);
    [SecurityCriticalAttribute]
internal PolicyStatement Resolve(Evidence evidence, int count, Byte[] serializedEvidence);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyStatement : object {
    internal PermissionSet m_permSet;
    internal PolicyStatementAttribute m_attributes;
    public PermissionSet PermissionSet { get; public set; }
    public PolicyStatementAttribute Attributes { get; public set; }
    public string AttributeString { get; }
    internal IEnumerable`1<IDelayEvaluatedEvidence> DependentEvidence { get; }
    internal bool HasDependentEvidence { get; }
    public PolicyStatement(PermissionSet permSet);
    public PolicyStatement(PermissionSet permSet, PolicyStatementAttribute attributes);
    public PermissionSet get_PermissionSet();
    public void set_PermissionSet(PermissionSet value);
    internal void SetPermissionSetNoCopy(PermissionSet permSet);
    internal PermissionSet GetPermissionSetNoCopy();
    public PolicyStatementAttribute get_Attributes();
    public void set_Attributes(PolicyStatementAttribute value);
    public PolicyStatement Copy();
    public string get_AttributeString();
    internal IEnumerable`1<IDelayEvaluatedEvidence> get_DependentEvidence();
    internal bool get_HasDependentEvidence();
    internal void AddDependentEvidence(IDelayEvaluatedEvidence dependentEvidence);
    internal void InplaceUnion(PolicyStatement childPolicy);
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement et);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    internal SecurityElement ToXml(PolicyLevel level, bool useInternal);
    [SecuritySafeCriticalAttribute]
public sealed virtual void FromXml(SecurityElement et, PolicyLevel level);
    [SecurityCriticalAttribute]
internal void FromXml(SecurityElement et, PolicyLevel level, bool allowInternalOnly);
    [SecurityCriticalAttribute]
internal void FromXml(SecurityDocument doc, int position, PolicyLevel level, bool allowInternalOnly);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Policy.PolicyStatementAttribute : Enum {
    public int value__;
    public static PolicyStatementAttribute Nothing;
    public static PolicyStatementAttribute Exclusive;
    public static PolicyStatementAttribute LevelFinal;
    public static PolicyStatementAttribute All;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Publisher : EvidenceBase {
    public X509Certificate Certificate { get; }
    public Publisher(X509Certificate cert);
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    internal static bool PublicKeyEquals(X509Certificate cert1, X509Certificate cert2);
    public virtual int GetHashCode();
    public X509Certificate get_Certificate();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
    internal object Normalize();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PublisherMembershipCondition : object {
    public X509Certificate Certificate { get; public set; }
    public PublisherMembershipCondition(X509Certificate certificate);
    public void set_Certificate(X509Certificate value);
    public X509Certificate get_Certificate();
    public virtual string ToString();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Site : EvidenceBase {
    public string Name { get; }
    public Site(string name);
    public static Site CreateFromUrl(string url);
    public string get_Name();
    internal SiteString GetSiteString();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
    internal object Normalize();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.SiteMembershipCondition : object {
    public string Site { get; public set; }
    public SiteMembershipCondition(string site);
    public void set_Site(string value);
    public string get_Site();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.StrongName : EvidenceBase {
    public StrongNamePublicKeyBlob PublicKey { get; }
    public string Name { get; }
    public Version Version { get; }
    private bool System.Security.Policy.IDelayEvaluatedEvidence.IsVerified { get; }
    private bool System.Security.Policy.IDelayEvaluatedEvidence.WasUsed { get; }
    public StrongName(StrongNamePublicKeyBlob blob, string name, Version version);
    internal StrongName(StrongNamePublicKeyBlob blob, string name, Version version, Assembly assembly);
    public StrongNamePublicKeyBlob get_PublicKey();
    public string get_Name();
    public Version get_Version();
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Security.Policy.IDelayEvaluatedEvidence.get_IsVerified();
    private sealed virtual override bool System.Security.Policy.IDelayEvaluatedEvidence.get_WasUsed();
    private sealed virtual override void System.Security.Policy.IDelayEvaluatedEvidence.MarkUsed();
    internal static bool CompareNames(string asmName, string mcName);
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    internal void FromXml(SecurityElement element);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal object Normalize();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.StrongNameMembershipCondition : object {
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public StrongNameMembershipCondition(StrongNamePublicKeyBlob blob, string name, Version version);
    public void set_PublicKey(StrongNamePublicKeyBlob value);
    public StrongNamePublicKeyBlob get_PublicKey();
    public void set_Name(string value);
    public string get_Name();
    public void set_Version(Version value);
    public Version get_Version();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.TrustManagerContext : object {
    public TrustManagerUIContext UIContext { get; public set; }
    public bool NoPrompt { get; public set; }
    public bool IgnorePersistedDecision { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool Persist { get; public set; }
    public ApplicationIdentity PreviousApplicationIdentity { get; public set; }
    public TrustManagerContext(TrustManagerUIContext uiContext);
    public virtual TrustManagerUIContext get_UIContext();
    public virtual void set_UIContext(TrustManagerUIContext value);
    public virtual bool get_NoPrompt();
    public virtual void set_NoPrompt(bool value);
    public virtual bool get_IgnorePersistedDecision();
    public virtual void set_IgnorePersistedDecision(bool value);
    public virtual bool get_KeepAlive();
    public virtual void set_KeepAlive(bool value);
    public virtual bool get_Persist();
    public virtual void set_Persist(bool value);
    public virtual ApplicationIdentity get_PreviousApplicationIdentity();
    public virtual void set_PreviousApplicationIdentity(ApplicationIdentity value);
}
[ComVisibleAttribute("True")]
public enum System.Security.Policy.TrustManagerUIContext : Enum {
    public int value__;
    public static TrustManagerUIContext Install;
    public static TrustManagerUIContext Upgrade;
    public static TrustManagerUIContext Run;
}
[ObsoleteAttribute("This type is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[ComVisibleAttribute("True")]
public class System.Security.Policy.UnionCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    internal UnionCodeGroup(IMembershipCondition membershipCondition, PermissionSet permSet);
    public UnionCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    [SecuritySafeCriticalAttribute]
public virtual PolicyStatement Resolve(Evidence evidence);
    private sealed virtual override PolicyStatement System.Security.Policy.IUnionSemanticCodeGroup.InternalResolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public virtual CodeGroup Copy();
    public virtual string get_MergeLogic();
    internal virtual string GetTypeName();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Url : EvidenceBase {
    public string Value { get; }
    internal Url(string name, bool parsed);
    public Url(string name);
    public string get_Value();
    internal URLString GetURLString();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
    internal object Normalize();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.UrlMembershipCondition : object {
    public string Url { get; public set; }
    public UrlMembershipCondition(string url);
    public void set_Url(string value);
    public string get_Url();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Zone : EvidenceBase {
    public SecurityZone SecurityZone { get; }
    public Zone(SecurityZone zone);
    private static Zone();
    public static Zone CreateFromUrl(string url);
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    [SecuritySafeCriticalAttribute]
public SecurityZone get_SecurityZone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual EvidenceBase Clone();
    public object Copy();
    internal SecurityElement ToXml();
    public virtual string ToString();
    internal object Normalize();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ZoneMembershipCondition : object {
    public SecurityZone SecurityZone { get; public set; }
    public ZoneMembershipCondition(SecurityZone zone);
    private static ZoneMembershipCondition();
    public void set_SecurityZone(SecurityZone value);
    public SecurityZone get_SecurityZone();
    public sealed virtual bool Check(Evidence evidence);
    private sealed virtual override bool System.Security.Policy.IReportMatchMembershipCondition.Check(Evidence evidence, Object& usedEvidence);
    public sealed virtual IMembershipCondition Copy();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public enum System.Security.PolicyLevelType : Enum {
    public int value__;
    public static PolicyLevelType User;
    public static PolicyLevelType Machine;
    public static PolicyLevelType Enterprise;
    public static PolicyLevelType AppDomain;
}
internal class System.Security.PolicyManager : object {
    [SecurityCriticalAttribute]
internal void AddLevel(PolicyLevel level);
    [SecurityCriticalAttribute]
internal IEnumerator PolicyHierarchy();
    [SecurityCriticalAttribute]
internal PermissionSet Resolve(Evidence evidence);
    [SecurityCriticalAttribute]
internal PermissionSet CodeGroupResolve(Evidence evidence, bool systemPolicy);
    internal static bool IsGacAssembly(Evidence evidence);
    [SecurityCriticalAttribute]
internal IEnumerator ResolveCodeGroups(Evidence evidence);
    internal static PolicyStatement ResolveCodeGroup(CodeGroup codeGroup, Evidence evidence);
    internal static bool CheckMembershipCondition(IMembershipCondition membershipCondition, Evidence evidence, Object& usedEvidence);
    [SecurityCriticalAttribute]
internal void Save();
    [SecurityCriticalAttribute]
internal static void EncodeLevel(PolicyLevel level);
    internal static bool CanUseQuickCache(CodeGroup group);
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.GenericIdentity : ClaimsIdentity {
    public IEnumerable`1<Claim> Claims { get; }
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    [SecuritySafeCriticalAttribute]
public GenericIdentity(string name);
    [SecuritySafeCriticalAttribute]
public GenericIdentity(string name, string type);
    protected GenericIdentity(GenericIdentity identity);
    public virtual ClaimsIdentity Clone();
    public virtual IEnumerable`1<Claim> get_Claims();
    public virtual string get_Name();
    public virtual string get_AuthenticationType();
    public virtual bool get_IsAuthenticated();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.GenericPrincipal : ClaimsPrincipal {
    public IIdentity Identity { get; }
    public GenericPrincipal(IIdentity identity, String[] roles);
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(string role);
}
internal enum System.Security.Principal.IdentifierAuthority : Enum {
    public long value__;
    public static IdentifierAuthority NullAuthority;
    public static IdentifierAuthority WorldAuthority;
    public static IdentifierAuthority LocalAuthority;
    public static IdentifierAuthority CreatorAuthority;
    public static IdentifierAuthority NonUniqueAuthority;
    public static IdentifierAuthority NTAuthority;
    public static IdentifierAuthority SiteServerAuthority;
    public static IdentifierAuthority InternetSiteAuthority;
    public static IdentifierAuthority ExchangeAuthority;
    public static IdentifierAuthority ResourceManagerAuthority;
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.IdentityNotMappedException : SystemException {
    public IdentityReferenceCollection UnmappedIdentities { get; }
    public IdentityNotMappedException(string message);
    public IdentityNotMappedException(string message, Exception inner);
    internal IdentityNotMappedException(string message, IdentityReferenceCollection unmappedIdentities);
    internal IdentityNotMappedException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public IdentityReferenceCollection get_UnmappedIdentities();
}
[ComVisibleAttribute("False")]
public abstract class System.Security.Principal.IdentityReference : object {
    public string Value { get; }
    public abstract virtual string get_Value();
    public abstract virtual bool IsValidTargetType(Type targetType);
    public abstract virtual IdentityReference Translate(Type targetType);
    public abstract virtual bool Equals(object o);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public static bool op_Equality(IdentityReference left, IdentityReference right);
    public static bool op_Inequality(IdentityReference left, IdentityReference right);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Security.Principal.IdentityReferenceCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IdentityReference Item { get; public set; }
    internal List`1<IdentityReference> Identities { get; }
    public IdentityReferenceCollection(int capacity);
    public sealed virtual void CopyTo(IdentityReference[] array, int offset);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(IdentityReference identity);
    public sealed virtual bool Remove(IdentityReference identity);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IdentityReference identity);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IdentityReference> GetEnumerator();
    public IdentityReference get_Item(int index);
    public void set_Item(int index, IdentityReference value);
    internal List`1<IdentityReference> get_Identities();
    public IdentityReferenceCollection Translate(Type targetType);
    [SecuritySafeCriticalAttribute]
public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess);
}
[ComVisibleAttribute("False")]
internal class System.Security.Principal.IdentityReferenceEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    public IdentityReference Current { get; }
    internal IdentityReferenceEnumerator(IdentityReferenceCollection collection);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual IdentityReference get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
public interface System.Security.Principal.IIdentity {
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
}
internal enum System.Security.Principal.ImpersonationQueryResult : Enum {
    public int value__;
    public static ImpersonationQueryResult Impersonated;
    public static ImpersonationQueryResult NotImpersonated;
    public static ImpersonationQueryResult Failed;
}
[ComVisibleAttribute("True")]
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    public abstract virtual bool IsInRole(string role);
}
internal enum System.Security.Principal.KerbLogonSubmitType : Enum {
    public int value__;
    public static KerbLogonSubmitType KerbInteractiveLogon;
    public static KerbLogonSubmitType KerbSmartCardLogon;
    public static KerbLogonSubmitType KerbWorkstationUnlockLogon;
    public static KerbLogonSubmitType KerbSmartCardUnlockLogon;
    public static KerbLogonSubmitType KerbProxyLogon;
    public static KerbLogonSubmitType KerbTicketLogon;
    public static KerbLogonSubmitType KerbTicketUnlockLogon;
    public static KerbLogonSubmitType KerbS4ULogon;
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.NTAccount : IdentityReference {
    internal static int MaximumAccountNameLength;
    internal static int MaximumDomainNameLength;
    public string Value { get; }
    public NTAccount(string domainName, string accountName);
    public NTAccount(string name);
    public virtual string get_Value();
    public virtual bool IsValidTargetType(Type targetType);
    [SecuritySafeCriticalAttribute]
public virtual IdentityReference Translate(Type targetType);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecurityCriticalAttribute]
internal static IdentityReferenceCollection Translate(IdentityReferenceCollection sourceAccounts, Type targetType, bool forceSuccess);
    [SecurityCriticalAttribute]
internal static IdentityReferenceCollection Translate(IdentityReferenceCollection sourceAccounts, Type targetType, Boolean& someFailed);
    public static bool op_Equality(NTAccount left, NTAccount right);
    public static bool op_Inequality(NTAccount left, NTAccount right);
}
[FlagsAttribute]
internal enum System.Security.Principal.PolicyRights : Enum {
    public int value__;
    public static PolicyRights POLICY_VIEW_LOCAL_INFORMATION;
    public static PolicyRights POLICY_VIEW_AUDIT_INFORMATION;
    public static PolicyRights POLICY_GET_PRIVATE_INFORMATION;
    public static PolicyRights POLICY_TRUST_ADMIN;
    public static PolicyRights POLICY_CREATE_ACCOUNT;
    public static PolicyRights POLICY_CREATE_SECRET;
    public static PolicyRights POLICY_CREATE_PRIVILEGE;
    public static PolicyRights POLICY_SET_DEFAULT_QUOTA_LIMITS;
    public static PolicyRights POLICY_SET_AUDIT_REQUIREMENTS;
    public static PolicyRights POLICY_AUDIT_LOG_ADMIN;
    public static PolicyRights POLICY_SERVER_ADMIN;
    public static PolicyRights POLICY_LOOKUP_NAMES;
    public static PolicyRights POLICY_NOTIFICATION;
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.SecurityIdentifier : IdentityReference {
    internal static long MaxIdentifierAuthority;
    internal static byte MaxSubAuthorities;
    public static int MinBinaryLength;
    public static int MaxBinaryLength;
    internal static byte Revision { get; }
    internal Byte[] BinaryForm { get; }
    internal IdentifierAuthority IdentifierAuthority { get; }
    internal int SubAuthorityCount { get; }
    public int BinaryLength { get; }
    public SecurityIdentifier AccountDomainSid { get; }
    public string Value { get; }
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier(string sddlForm);
    public SecurityIdentifier(Byte[] binaryForm, int offset);
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier(IntPtr binaryForm);
    [SecurityCriticalAttribute]
internal SecurityIdentifier(IntPtr binaryForm, bool noDemand);
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier(WellKnownSidType sidType, SecurityIdentifier domainSid);
    internal SecurityIdentifier(SecurityIdentifier domainSid, UInt32 rid);
    internal SecurityIdentifier(IdentifierAuthority identifierAuthority, Int32[] subAuthorities);
    private static SecurityIdentifier();
    internal static byte get_Revision();
    internal Byte[] get_BinaryForm();
    internal IdentifierAuthority get_IdentifierAuthority();
    internal int get_SubAuthorityCount();
    public int get_BinaryLength();
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier get_AccountDomainSid();
    public virtual bool Equals(object o);
    public bool Equals(SecurityIdentifier sid);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Value();
    internal static bool IsValidTargetTypeStatic(Type targetType);
    public virtual bool IsValidTargetType(Type targetType);
    [SecurityCriticalAttribute]
internal SecurityIdentifier GetAccountDomainSid();
    [SecuritySafeCriticalAttribute]
public bool IsAccountSid();
    [SecuritySafeCriticalAttribute]
public virtual IdentityReference Translate(Type targetType);
    public static bool op_Equality(SecurityIdentifier left, SecurityIdentifier right);
    public static bool op_Inequality(SecurityIdentifier left, SecurityIdentifier right);
    public sealed virtual int CompareTo(SecurityIdentifier sid);
    internal int GetSubAuthority(int index);
    [SecuritySafeCriticalAttribute]
public bool IsWellKnown(WellKnownSidType type);
    public void GetBinaryForm(Byte[] binaryForm, int offset);
    [SecuritySafeCriticalAttribute]
public bool IsEqualDomainSid(SecurityIdentifier sid);
    [SecurityCriticalAttribute]
internal static IdentityReferenceCollection Translate(IdentityReferenceCollection sourceSids, Type targetType, bool forceSuccess);
    [SecurityCriticalAttribute]
internal static IdentityReferenceCollection Translate(IdentityReferenceCollection sourceSids, Type targetType, Boolean& someFailed);
}
internal enum System.Security.Principal.SecurityLogonType : Enum {
    public int value__;
    public static SecurityLogonType Interactive;
    public static SecurityLogonType Network;
    public static SecurityLogonType Batch;
    public static SecurityLogonType Service;
    public static SecurityLogonType Proxy;
    public static SecurityLogonType Unlock;
}
internal enum System.Security.Principal.SidNameUse : Enum {
    public int value__;
    public static SidNameUse User;
    public static SidNameUse Group;
    public static SidNameUse Domain;
    public static SidNameUse Alias;
    public static SidNameUse WellKnownGroup;
    public static SidNameUse DeletedAccount;
    public static SidNameUse Invalid;
    public static SidNameUse Unknown;
    public static SidNameUse Computer;
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Principal.TokenAccessLevels : Enum {
    public int value__;
    public static TokenAccessLevels AssignPrimary;
    public static TokenAccessLevels Duplicate;
    public static TokenAccessLevels Impersonate;
    public static TokenAccessLevels Query;
    public static TokenAccessLevels QuerySource;
    public static TokenAccessLevels AdjustPrivileges;
    public static TokenAccessLevels AdjustGroups;
    public static TokenAccessLevels AdjustDefault;
    public static TokenAccessLevels AdjustSessionId;
    public static TokenAccessLevels Read;
    public static TokenAccessLevels Write;
    public static TokenAccessLevels AllAccess;
    public static TokenAccessLevels MaximumAllowed;
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.TokenImpersonationLevel : Enum {
    public int value__;
    public static TokenImpersonationLevel None;
    public static TokenImpersonationLevel Anonymous;
    public static TokenImpersonationLevel Identification;
    public static TokenImpersonationLevel Impersonation;
    public static TokenImpersonationLevel Delegation;
}
internal enum System.Security.Principal.TokenInformationClass : Enum {
    public int value__;
    public static TokenInformationClass TokenUser;
    public static TokenInformationClass TokenGroups;
    public static TokenInformationClass TokenPrivileges;
    public static TokenInformationClass TokenOwner;
    public static TokenInformationClass TokenPrimaryGroup;
    public static TokenInformationClass TokenDefaultDacl;
    public static TokenInformationClass TokenSource;
    public static TokenInformationClass TokenType;
    public static TokenInformationClass TokenImpersonationLevel;
    public static TokenInformationClass TokenStatistics;
    public static TokenInformationClass TokenRestrictedSids;
    public static TokenInformationClass TokenSessionId;
    public static TokenInformationClass TokenGroupsAndPrivileges;
    public static TokenInformationClass TokenSessionReference;
    public static TokenInformationClass TokenSandBoxInert;
    public static TokenInformationClass TokenAuditPolicy;
    public static TokenInformationClass TokenOrigin;
    public static TokenInformationClass TokenElevationType;
    public static TokenInformationClass TokenLinkedToken;
    public static TokenInformationClass TokenElevation;
    public static TokenInformationClass TokenHasRestrictions;
    public static TokenInformationClass TokenAccessInformation;
    public static TokenInformationClass TokenVirtualizationAllowed;
    public static TokenInformationClass TokenVirtualizationEnabled;
    public static TokenInformationClass TokenIntegrityLevel;
    public static TokenInformationClass TokenUIAccess;
    public static TokenInformationClass TokenMandatoryPolicy;
    public static TokenInformationClass TokenLogonSid;
    public static TokenInformationClass TokenIsAppContainer;
    public static TokenInformationClass TokenCapabilities;
    public static TokenInformationClass TokenAppContainerSid;
    public static TokenInformationClass TokenAppContainerNumber;
    public static TokenInformationClass TokenUserClaimAttributes;
    public static TokenInformationClass TokenDeviceClaimAttributes;
    public static TokenInformationClass TokenRestrictedUserClaimAttributes;
    public static TokenInformationClass TokenRestrictedDeviceClaimAttributes;
    public static TokenInformationClass TokenDeviceGroups;
    public static TokenInformationClass TokenRestrictedDeviceGroups;
    public static TokenInformationClass MaxTokenInfoClass;
}
internal enum System.Security.Principal.TokenType : Enum {
    public int value__;
    public static TokenType TokenPrimary;
    public static TokenType TokenImpersonation;
}
[ComVisibleAttribute("False")]
public enum System.Security.Principal.WellKnownSidType : Enum {
    public int value__;
    public static WellKnownSidType NullSid;
    public static WellKnownSidType WorldSid;
    public static WellKnownSidType LocalSid;
    public static WellKnownSidType CreatorOwnerSid;
    public static WellKnownSidType CreatorGroupSid;
    public static WellKnownSidType CreatorOwnerServerSid;
    public static WellKnownSidType CreatorGroupServerSid;
    public static WellKnownSidType NTAuthoritySid;
    public static WellKnownSidType DialupSid;
    public static WellKnownSidType NetworkSid;
    public static WellKnownSidType BatchSid;
    public static WellKnownSidType InteractiveSid;
    public static WellKnownSidType ServiceSid;
    public static WellKnownSidType AnonymousSid;
    public static WellKnownSidType ProxySid;
    public static WellKnownSidType EnterpriseControllersSid;
    public static WellKnownSidType SelfSid;
    public static WellKnownSidType AuthenticatedUserSid;
    public static WellKnownSidType RestrictedCodeSid;
    public static WellKnownSidType TerminalServerSid;
    public static WellKnownSidType RemoteLogonIdSid;
    public static WellKnownSidType LogonIdsSid;
    public static WellKnownSidType LocalSystemSid;
    public static WellKnownSidType LocalServiceSid;
    public static WellKnownSidType NetworkServiceSid;
    public static WellKnownSidType BuiltinDomainSid;
    public static WellKnownSidType BuiltinAdministratorsSid;
    public static WellKnownSidType BuiltinUsersSid;
    public static WellKnownSidType BuiltinGuestsSid;
    public static WellKnownSidType BuiltinPowerUsersSid;
    public static WellKnownSidType BuiltinAccountOperatorsSid;
    public static WellKnownSidType BuiltinSystemOperatorsSid;
    public static WellKnownSidType BuiltinPrintOperatorsSid;
    public static WellKnownSidType BuiltinBackupOperatorsSid;
    public static WellKnownSidType BuiltinReplicatorSid;
    public static WellKnownSidType BuiltinPreWindows2000CompatibleAccessSid;
    public static WellKnownSidType BuiltinRemoteDesktopUsersSid;
    public static WellKnownSidType BuiltinNetworkConfigurationOperatorsSid;
    public static WellKnownSidType AccountAdministratorSid;
    public static WellKnownSidType AccountGuestSid;
    public static WellKnownSidType AccountKrbtgtSid;
    public static WellKnownSidType AccountDomainAdminsSid;
    public static WellKnownSidType AccountDomainUsersSid;
    public static WellKnownSidType AccountDomainGuestsSid;
    public static WellKnownSidType AccountComputersSid;
    public static WellKnownSidType AccountControllersSid;
    public static WellKnownSidType AccountCertAdminsSid;
    public static WellKnownSidType AccountSchemaAdminsSid;
    public static WellKnownSidType AccountEnterpriseAdminsSid;
    public static WellKnownSidType AccountPolicyAdminsSid;
    public static WellKnownSidType AccountRasAndIasServersSid;
    public static WellKnownSidType NtlmAuthenticationSid;
    public static WellKnownSidType DigestAuthenticationSid;
    public static WellKnownSidType SChannelAuthenticationSid;
    public static WellKnownSidType ThisOrganizationSid;
    public static WellKnownSidType OtherOrganizationSid;
    public static WellKnownSidType BuiltinIncomingForestTrustBuildersSid;
    public static WellKnownSidType BuiltinPerformanceMonitoringUsersSid;
    public static WellKnownSidType BuiltinPerformanceLoggingUsersSid;
    public static WellKnownSidType BuiltinAuthorizationAccessSid;
    public static WellKnownSidType WinBuiltinTerminalServerLicenseServersSid;
    public static WellKnownSidType MaxDefined;
}
internal static class System.Security.Principal.Win32 : object {
    internal static int FALSE;
    internal static int TRUE;
    internal static bool LsaLookupNames2Supported { get; }
    internal static bool WellKnownSidApisSupported { get; }
    [SecuritySafeCriticalAttribute]
private static Win32();
    internal static bool get_LsaLookupNames2Supported();
    internal static bool get_WellKnownSidApisSupported();
    [SecurityCriticalAttribute]
internal static SafeLsaPolicyHandle LsaOpenPolicy(string systemName, PolicyRights rights);
    [SecurityCriticalAttribute]
internal static Byte[] ConvertIntPtrSidToByteArraySid(IntPtr binaryForm);
    [SecurityCriticalAttribute]
internal static int CreateSidFromString(string stringSid, Byte[]& resultSid);
    [SecurityCriticalAttribute]
internal static int CreateWellKnownSid(WellKnownSidType sidType, SecurityIdentifier domainSid, Byte[]& resultSid);
    [SecurityCriticalAttribute]
internal static bool IsEqualDomainSid(SecurityIdentifier sid1, SecurityIdentifier sid2);
    [SecurityCriticalAttribute]
internal static void InitializeReferencedDomainsPointer(SafeLsaMemoryHandle referencedDomains);
    [SecurityCriticalAttribute]
internal static int GetWindowsAccountDomainSid(SecurityIdentifier sid, SecurityIdentifier& resultSid);
    [SecurityCriticalAttribute]
internal static bool IsWellKnownSid(SecurityIdentifier sid, WellKnownSidType type);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int ImpersonateLoggedOnUser(SafeTokenHandle hToken);
    [SecurityCriticalAttribute]
internal static int OpenThreadToken(TokenAccessLevels dwDesiredAccess, WinSecurityContext OpenAs, SafeTokenHandle& phThreadToken);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int RevertToSelf();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int SetThreadToken(SafeTokenHandle hToken);
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.WindowsAccountType : Enum {
    public int value__;
    public static WindowsAccountType Normal;
    public static WindowsAccountType Guest;
    public static WindowsAccountType System;
    public static WindowsAccountType Anonymous;
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.WindowsBuiltInRole : Enum {
    public int value__;
    public static WindowsBuiltInRole Administrator;
    public static WindowsBuiltInRole User;
    public static WindowsBuiltInRole Guest;
    public static WindowsBuiltInRole PowerUser;
    public static WindowsBuiltInRole AccountOperator;
    public static WindowsBuiltInRole SystemOperator;
    public static WindowsBuiltInRole PrintOperator;
    public static WindowsBuiltInRole BackupOperator;
    public static WindowsBuiltInRole Replicator;
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsIdentity : ClaimsIdentity {
    public static string DefaultIssuer;
    public string AuthenticationType { get; }
    [ComVisibleAttribute("False")]
public TokenImpersonationLevel ImpersonationLevel { get; }
    public bool IsAuthenticated { get; }
    public bool IsGuest { get; }
    public bool IsSystem { get; }
    public bool IsAnonymous { get; }
    public string Name { get; }
    [ComVisibleAttribute("False")]
public SecurityIdentifier Owner { get; }
    [ComVisibleAttribute("False")]
public SecurityIdentifier User { get; }
    public IdentityReferenceCollection Groups { get; }
    public IntPtr Token { get; }
    internal SafeTokenHandle TokenHandle { get; }
    public IEnumerable`1<Claim> UserClaims { get; }
    public IEnumerable`1<Claim> DeviceClaims { get; }
    public IEnumerable`1<Claim> Claims { get; }
    [SecuritySafeCriticalAttribute]
private static WindowsIdentity();
    [SecurityCriticalAttribute]
internal WindowsIdentity(SafeTokenHandle safeTokenHandle);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(IntPtr userToken);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(IntPtr userToken, string type);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(string sUserPrincipalName);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(string sUserPrincipalName, string type);
    [SecuritySafeCriticalAttribute]
public WindowsIdentity(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
protected WindowsIdentity(WindowsIdentity identity);
    [SecurityCriticalAttribute]
internal WindowsIdentity(ClaimsIdentity claimsIdentity, IntPtr userToken);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecuritySafeCriticalAttribute]
public static WindowsIdentity GetCurrent();
    [SecuritySafeCriticalAttribute]
public static WindowsIdentity GetCurrent(bool ifImpersonating);
    [SecuritySafeCriticalAttribute]
public static WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess);
    [SecuritySafeCriticalAttribute]
public static WindowsIdentity GetAnonymous();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_AuthenticationType();
    [SecuritySafeCriticalAttribute]
public TokenImpersonationLevel get_ImpersonationLevel();
    public virtual bool get_IsAuthenticated();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsGuest();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSystem();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsAnonymous();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    [SecurityCriticalAttribute]
internal string GetName();
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier get_Owner();
    [SecuritySafeCriticalAttribute]
public SecurityIdentifier get_User();
    [SecuritySafeCriticalAttribute]
public IdentityReferenceCollection get_Groups();
    [SecuritySafeCriticalAttribute]
public virtual IntPtr get_Token();
    [SecuritySafeCriticalAttribute]
public virtual WindowsImpersonationContext Impersonate();
    [SecuritySafeCriticalAttribute]
public static WindowsImpersonationContext Impersonate(IntPtr userToken);
    [SecurityCriticalAttribute]
internal WindowsImpersonationContext Impersonate(StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
protected virtual void Dispose(bool disposing);
    [ComVisibleAttribute("False")]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
internal SafeTokenHandle get_TokenHandle();
    [SecurityCriticalAttribute]
internal static WindowsImpersonationContext SafeRevertToSelf(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static WindowsImpersonationContext SafeImpersonate(SafeTokenHandle userToken, WindowsIdentity wi, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static WindowsIdentity GetCurrentThreadWI();
    [SecurityCriticalAttribute]
internal static void UpdateThreadWI(WindowsIdentity wi);
    [SecurityCriticalAttribute]
internal static WindowsIdentity GetCurrentInternal(TokenAccessLevels desiredAccess, bool threadOnly);
    internal static RuntimeConstructorInfo GetSpecialSerializationCtor();
    [SecurityCriticalAttribute]
internal static SafeTokenHandle GetCurrentThreadToken(TokenAccessLevels desiredAccess, Int32& hr);
    [SecurityCriticalAttribute]
internal static ImpersonationQueryResult QueryImpersonation();
    [SecurityCriticalAttribute]
internal IntPtr GetTokenInternal();
    internal ClaimsIdentity CloneAsBase();
    public virtual ClaimsIdentity Clone();
    public virtual IEnumerable`1<Claim> get_UserClaims();
    public virtual IEnumerable`1<Claim> get_DeviceClaims();
    public virtual IEnumerable`1<Claim> get_Claims();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsImpersonationContext : object {
    [SecurityCriticalAttribute]
internal WindowsImpersonationContext(SafeTokenHandle safeTokenHandle, WindowsIdentity wi, bool isImpersonating, FrameSecurityDescriptor fsd);
    [SecuritySafeCriticalAttribute]
public void Undo();
    [ReliabilityContractAttribute("3", "1")]
[HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal bool UndoNoThrow();
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [ComVisibleAttribute("False")]
public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsPrincipal : ClaimsPrincipal {
    public IIdentity Identity { get; }
    public IEnumerable`1<Claim> UserClaims { get; }
    public IEnumerable`1<Claim> DeviceClaims { get; }
    public WindowsPrincipal(WindowsIdentity ntIdentity);
    public virtual IIdentity get_Identity();
    [SecuritySafeCriticalAttribute]
public virtual bool IsInRole(string role);
    public virtual IEnumerable`1<Claim> get_UserClaims();
    public virtual IEnumerable`1<Claim> get_DeviceClaims();
    public virtual bool IsInRole(WindowsBuiltInRole role);
    public virtual bool IsInRole(int rid);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual bool IsInRole(SecurityIdentifier sid);
}
internal enum System.Security.Principal.WinSecurityContext : Enum {
    public int value__;
    public static WinSecurityContext Thread;
    public static WinSecurityContext Process;
    public static WinSecurityContext Both;
}
public class System.Security.ReadOnlyPermissionSet : PermissionSet {
    public bool IsReadOnly { get; }
    public ReadOnlyPermissionSet(SecurityElement permissionSetXml);
    public virtual bool get_IsReadOnly();
    public virtual PermissionSet Copy();
    public virtual SecurityElement ToXml();
    protected virtual IEnumerator GetEnumeratorImpl();
    protected virtual IPermission GetPermissionImpl(Type permClass);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    public virtual void FromXml(SecurityElement et);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
}
internal class System.Security.ReadOnlyPermissionSetEnumerator : object {
    public object Current { get; }
    internal ReadOnlyPermissionSetEnumerator(IEnumerator permissionSetEnumerator);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Security.SafeBSTRHandle : SafeBuffer {
    internal int Length { get; }
    internal static SafeBSTRHandle Allocate(string src, UInt32 len);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "2")]
internal void ClearBuffer();
    internal int get_Length();
    internal static void Copy(SafeBSTRHandle source, SafeBSTRHandle target);
}
public class System.Security.SecureString : object {
    public int Length { get; }
    [SecuritySafeCriticalAttribute]
private static SecureString();
    [SecurityCriticalAttribute]
internal SecureString(SecureString str);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public SecureString(Char* value, int length);
    [SecuritySafeCriticalAttribute]
public int get_Length();
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecuritySafeCriticalAttribute]
public void AppendChar(char c);
    [SecuritySafeCriticalAttribute]
public void Clear();
    [SecuritySafeCriticalAttribute]
public SecureString Copy();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public void InsertAt(int index, char c);
    [SecuritySafeCriticalAttribute]
public bool IsReadOnly();
    [SecuritySafeCriticalAttribute]
public void MakeReadOnly();
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecuritySafeCriticalAttribute]
public void RemoveAt(int index);
    [SecuritySafeCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public void SetAt(int index, char c);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal IntPtr ToBSTR();
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal IntPtr ToUniStr(bool allocateFromHeap);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal IntPtr ToAnsiStr(bool allocateFromHeap);
}
public class System.Security.SecurityContext : object {
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isNewCapture;
    internal SecurityContextDisableFlow modreq(System.Runtime.CompilerServices.IsVolatile) _disableFlow;
    internal static TryCode modreq(System.Runtime.CompilerServices.IsVolatile) tryCode;
    internal static CleanupCode modreq(System.Runtime.CompilerServices.IsVolatile) cleanupCode;
    internal static SecurityContext FullTrustSecurityContext { get; }
    unknown ExecutionContext ExecutionContext {internal set; }
    internal WindowsIdentity WindowsIdentity { get; internal set; }
    internal CompressedStack CompressedStack { get; internal set; }
    internal static bool AlwaysFlowImpersonationPolicy { get; }
    private static SecurityContext();
    [SecurityCriticalAttribute]
internal static SecurityContext get_FullTrustSecurityContext();
    [ReliabilityContractAttribute("3", "2")]
internal void set_ExecutionContext(ExecutionContext value);
    internal WindowsIdentity get_WindowsIdentity();
    internal void set_WindowsIdentity(WindowsIdentity value);
    internal CompressedStack get_CompressedStack();
    [ReliabilityContractAttribute("3", "2")]
internal void set_CompressedStack(CompressedStack value);
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public static AsyncFlowControl SuppressFlow();
    [SecurityCriticalAttribute]
public static AsyncFlowControl SuppressFlowWindowsIdentity();
    [SecurityCriticalAttribute]
internal static AsyncFlowControl SuppressFlow(SecurityContextDisableFlow flags);
    [SecuritySafeCriticalAttribute]
public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    public static bool IsWindowsIdentityFlowSuppressed();
    [SecuritySafeCriticalAttribute]
internal static bool IsFlowSuppressed(SecurityContextDisableFlow flags);
    [SecurityCriticalAttribute]
public static void Run(SecurityContext securityContext, ContextCallback callback, object state);
    [SecurityCriticalAttribute]
internal static void RunInternal(SecurityContext securityContext, ContextCallback callBack, object state);
    [SecurityCriticalAttribute]
internal static void runTryCode(object userData);
    [SecurityCriticalAttribute]
[PrePrepareMethodAttribute]
internal static void runFinallyCode(object userData, bool exceptionThrown);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static SecurityContextSwitcher SetSecurityContext(SecurityContext sc, Reader prevSecurityContext, bool modifyCurrentExecutionContext);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static SecurityContextSwitcher SetSecurityContext(SecurityContext sc, Reader prevSecurityContext, bool modifyCurrentExecutionContext, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public SecurityContext CreateCopy();
    [SecuritySafeCriticalAttribute]
internal SecurityContext CreateMutableCopy();
    [SecuritySafeCriticalAttribute]
public static SecurityContext Capture();
    [SecurityCriticalAttribute]
internal static SecurityContext Capture(Reader currThreadEC, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static SecurityContext CreateFullTrustSecurityContext();
    internal static bool get_AlwaysFlowImpersonationPolicy();
    [SecurityCriticalAttribute]
internal static WindowsIdentity GetCurrentWI(Reader threadEC);
    [SecurityCriticalAttribute]
internal static WindowsIdentity GetCurrentWI(Reader threadEC, bool cachedAlwaysFlowImpersonationPolicy);
    [SecurityCriticalAttribute]
internal static void RestoreCurrentWI(Reader currentEC, Reader prevEC, WindowsIdentity targetWI, bool cachedAlwaysFlowImpersonationPolicy);
    [SecurityCriticalAttribute]
internal bool IsDefaultFTSecurityContext();
    [SecurityCriticalAttribute]
internal static bool CurrentlyInDefaultFTSecurityContext(Reader threadEC);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
internal static WindowsImpersonationFlowMode GetImpersonationFlowMode();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static bool IsDefaultThreadSecurityInfo();
}
internal enum System.Security.SecurityContextDisableFlow : Enum {
    public int value__;
    public static SecurityContextDisableFlow Nothing;
    public static SecurityContextDisableFlow WI;
    public static SecurityContextDisableFlow All;
}
public enum System.Security.SecurityContextSource : Enum {
    public int value__;
    public static SecurityContextSource CurrentAppDomain;
    public static SecurityContextSource CurrentAssembly;
}
internal class System.Security.SecurityContextSwitcher : ValueType {
    internal Reader prevSC;
    internal SecurityContext currSC;
    internal ExecutionContext currEC;
    internal CompressedStackSwitcher cssw;
    internal WindowsImpersonationContext wic;
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[ReliabilityContractAttribute("3", "1")]
internal bool UndoNoThrow();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
[HandleProcessCorruptedStateExceptionsAttribute]
public void Undo();
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
internal class System.Security.SecurityDocument : object {
    internal static byte c_element;
    internal static byte c_attribute;
    internal static byte c_text;
    internal static byte c_children;
    internal static int c_growthSize;
    internal Byte[] m_data;
    public SecurityDocument(int numData);
    public SecurityDocument(Byte[] data);
    public SecurityDocument(SecurityElement elRoot);
    public void GuaranteeSize(int size);
    public void AddString(string str, Int32& position);
    public void AppendString(string str, Int32& position);
    public static int EncodedStringSize(string str);
    public string GetString(Int32& position);
    public string GetString(Int32& position, bool bCreate);
    public void AddToken(byte b, Int32& position);
    public void ConvertElement(SecurityElement elCurrent, Int32& position);
    public SecurityElement GetRootElement();
    public SecurityElement GetElement(int position, bool bCreate);
    internal SecurityElement InternalGetElement(Int32& position, bool bCreate);
    public string GetTagForElement(int position);
    public ArrayList GetChildrenPositionForElement(int position);
    public string GetAttributeForElement(int position, string attributeName);
}
internal class System.Security.SecurityDocumentElement : object {
    internal SecurityDocumentElement(SecurityDocument document, int position);
    private sealed virtual override SecurityElement System.Security.ISecurityElementFactory.CreateSecurityElement();
    private sealed virtual override object System.Security.ISecurityElementFactory.Copy();
    private sealed virtual override string System.Security.ISecurityElementFactory.GetTag();
    private sealed virtual override string System.Security.ISecurityElementFactory.Attribute(string attributeName);
}
[ComVisibleAttribute("True")]
public class System.Security.SecurityElement : object {
    internal string m_strTag;
    internal string m_strText;
    internal ArrayList m_lAttributes;
    internal SecurityElementType m_type;
    public string Tag { get; public set; }
    public Hashtable Attributes { get; public set; }
    public string Text { get; public set; }
    public ArrayList Children { get; public set; }
    internal ArrayList InternalChildren { get; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    private static SecurityElement();
    private sealed virtual override SecurityElement System.Security.ISecurityElementFactory.CreateSecurityElement();
    private sealed virtual override string System.Security.ISecurityElementFactory.GetTag();
    private sealed virtual override object System.Security.ISecurityElementFactory.Copy();
    private sealed virtual override string System.Security.ISecurityElementFactory.Attribute(string attributeName);
    public static SecurityElement FromString(string xml);
    public string get_Tag();
    public void set_Tag(string value);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public string get_Text();
    public void set_Text(string value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    internal void ConvertSecurityElementFactories();
    internal ArrayList get_InternalChildren();
    internal void AddAttributeSafe(string name, string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    internal void AddChild(ISecurityElementFactory child);
    internal void AddChildNoDuplicates(ISecurityElementFactory child);
    public bool Equal(SecurityElement other);
    [ComVisibleAttribute("False")]
public SecurityElement Copy();
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    public static string Escape(string str);
    public virtual string ToString();
    internal void ToWriter(StreamWriter writer);
    public string Attribute(string name);
    public SecurityElement SearchForChildByTag(string tag);
    internal IPermission ToPermission(bool ignoreTypeLoadFailures);
    [SecurityCriticalAttribute]
internal object ToSecurityObject();
    internal string SearchForTextOfLocalName(string strLocalName);
    public string SearchForTextOfTag(string tag);
}
internal enum System.Security.SecurityElementType : Enum {
    public int value__;
    public static SecurityElementType Regular;
    public static SecurityElementType Format;
    public static SecurityElementType Comment;
}
[ComVisibleAttribute("True")]
public class System.Security.SecurityException : SystemException {
    [ComVisibleAttribute("False")]
public SecurityAction Action { get; public set; }
    public Type PermissionType { get; public set; }
    public IPermission FirstPermissionThatFailed { get; public set; }
    public string PermissionState { get; public set; }
    [ComVisibleAttribute("False")]
public object Demanded { get; public set; }
    public string GrantedSet { get; public set; }
    public string RefusedSet { get; public set; }
    [ComVisibleAttribute("False")]
public object DenySetInstance { get; public set; }
    [ComVisibleAttribute("False")]
public object PermitOnlySetInstance { get; public set; }
    [ComVisibleAttribute("False")]
public AssemblyName FailedAssemblyInfo { get; public set; }
    [ComVisibleAttribute("False")]
public MethodInfo Method { get; public set; }
    public SecurityZone Zone { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    [SecuritySafeCriticalAttribute]
public SecurityException(string message, Type type);
    [SecuritySafeCriticalAttribute]
public SecurityException(string message, Type type, string state);
    public SecurityException(string message, Exception inner);
    [SecurityCriticalAttribute]
internal SecurityException(PermissionSet grantedSetObj, PermissionSet refusedSetObj);
    [SecurityCriticalAttribute]
internal SecurityException(string message, PermissionSet grantedSetObj, PermissionSet refusedSetObj);
    [SecuritySafeCriticalAttribute]
protected SecurityException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public SecurityException(string message, AssemblyName assemblyName, PermissionSet grant, PermissionSet refused, MethodInfo method, SecurityAction action, object demanded, IPermission permThatFailed, Evidence evidence);
    [SecuritySafeCriticalAttribute]
public SecurityException(string message, object deny, object permitOnly, MethodInfo method, object demanded, IPermission permThatFailed);
    [SecuritySafeCriticalAttribute]
internal static string GetResString(string sResourceName);
    [SecurityCriticalAttribute]
internal static Exception MakeSecurityException(AssemblyName asmName, Evidence asmEvidence, PermissionSet granted, PermissionSet refused, RuntimeMethodHandleInternal rmh, SecurityAction action, object demand, IPermission permThatFailed);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    [SecuritySafeCriticalAttribute]
public Type get_PermissionType();
    public void set_PermissionType(Type value);
    [SecuritySafeCriticalAttribute]
public IPermission get_FirstPermissionThatFailed();
    public void set_FirstPermissionThatFailed(IPermission value);
    [SecuritySafeCriticalAttribute]
public string get_PermissionState();
    public void set_PermissionState(string value);
    [SecuritySafeCriticalAttribute]
public object get_Demanded();
    public void set_Demanded(object value);
    [SecuritySafeCriticalAttribute]
public string get_GrantedSet();
    public void set_GrantedSet(string value);
    [SecuritySafeCriticalAttribute]
public string get_RefusedSet();
    public void set_RefusedSet(string value);
    [SecuritySafeCriticalAttribute]
public object get_DenySetInstance();
    public void set_DenySetInstance(object value);
    [SecuritySafeCriticalAttribute]
public object get_PermitOnlySetInstance();
    public void set_PermitOnlySetInstance(object value);
    [SecuritySafeCriticalAttribute]
public AssemblyName get_FailedAssemblyInfo();
    public void set_FailedAssemblyInfo(AssemblyName value);
    [SecuritySafeCriticalAttribute]
public MethodInfo get_Method();
    public void set_Method(MethodInfo value);
    public SecurityZone get_Zone();
    public void set_Zone(SecurityZone value);
    [SecuritySafeCriticalAttribute]
public string get_Url();
    public void set_Url(string value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public static class System.Security.SecurityManager : object {
    internal static PolicyManager PolicyManager { get; }
    [ObsoleteAttribute("Because execution permission checks can no longer be turned off, the CheckExecutionRights property no longer has any effect.")]
public static bool CheckExecutionRights { get; public set; }
    [ObsoleteAttribute("Because security can no longer be turned off, the SecurityEnabled property no longer has any effect.")]
public static bool SecurityEnabled { get; public set; }
    private static SecurityManager();
    internal static PolicyManager get_PolicyManager();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("IsGranted is obsolete and will be removed in a future release of the .NET Framework.  Please use the PermissionSet property of either AppDomain or Assembly instead.")]
public static bool IsGranted(IPermission perm);
    public static PermissionSet GetStandardSandbox(Evidence evidence);
    [SecurityCriticalAttribute]
public static void GetZoneAndOrigin(ArrayList& zone, ArrayList& origin);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static void SavePolicyLevel(PolicyLevel level);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, PermissionSet& denied);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static PermissionSet ResolvePolicy(Evidence[] evidences);
    [SecurityCriticalAttribute]
public static bool CurrentThreadRequiresSecurityContextCapture();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static PermissionSet ResolveSystemPolicy(Evidence evidence);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static IEnumerator ResolvePolicyGroups(Evidence evidence);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static IEnumerator PolicyHierarchy();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static void SavePolicy();
    public static bool get_CheckExecutionRights();
    public static void set_CheckExecutionRights(bool value);
    public static bool get_SecurityEnabled();
    public static void set_SecurityEnabled(bool value);
    internal static int GetSpecialFlags(PermissionSet grantSet, PermissionSet deniedSet);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool IsSameType(string strLeft, string strRight);
    [SecurityCriticalAttribute]
internal static bool _SetThreadSecurity(bool bThreadSecurity);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void GetGrantedPermissions(ObjectHandleOnStack retGranted, ObjectHandleOnStack retDenied, StackCrawlMarkHandle stackMark);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    public bool get_SkipVerificationInFullTrust();
    public void set_SkipVerificationInFullTrust(bool value);
    public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
internal class System.Security.SecurityRuntime : object {
    internal static bool StackContinue;
    internal static bool StackHalt;
    [SecurityCriticalAttribute]
internal static FrameSecurityDescriptor GetSecurityObjectForFrame(StackCrawlMark& stackMark, bool create);
    [SecurityCriticalAttribute]
internal static MethodInfo GetMethodInfo(RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal static void Assert(PermissionSet permSet, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void AssertAllPossible(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void Deny(PermissionSet permSet, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void PermitOnly(PermissionSet permSet, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void RevertAssert(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void RevertDeny(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void RevertPermitOnly(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void RevertAll(StackCrawlMark& stackMark);
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[SecurityCriticalAttribute]
public abstract class System.Security.SecurityState : object {
    [SecurityCriticalAttribute]
public bool IsStateAvailable();
    public abstract virtual void EnsureState();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public enum System.Security.SecurityZone : Enum {
    public int value__;
    public static SecurityZone MyComputer;
    public static SecurityZone Intranet;
    public static SecurityZone Trusted;
    public static SecurityZone Internet;
    public static SecurityZone Untrusted;
    public static SecurityZone NoZone;
}
internal enum System.Security.SpecialPermissionSetFlag : Enum {
    public int value__;
    public static SpecialPermissionSetFlag Regular;
    public static SpecialPermissionSetFlag NoSet;
    public static SpecialPermissionSetFlag EmptySet;
    public static SpecialPermissionSetFlag SkipVerification;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
[ComVisibleAttribute("True")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
internal static class System.Security.Util.Config : object {
    internal static string MachineDirectory { get; }
    internal static string UserDirectory { get; }
    [SecurityCriticalAttribute]
internal static string get_MachineDirectory();
    [SecurityCriticalAttribute]
internal static string get_UserDirectory();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int SaveDataByte(string path, Byte[] data, int length);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool RecoverData(ConfigId id);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetQuickCache(ConfigId id, QuickCacheEntryType quickCacheFlags);
    [SecurityCriticalAttribute]
internal static bool GetCacheEntry(ConfigId id, int numKey, Byte[] key, Byte[]& data);
    [SecurityCriticalAttribute]
internal static void AddCacheEntry(ConfigId id, int numKey, Byte[] key, Byte[] data);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void ResetCacheData(ConfigId id);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool WriteToEventLog(string message);
}
internal class System.Security.Util.DirectoryString : SiteString {
    protected static Char[] m_illegalDirectoryCharacters;
    public DirectoryString(string directory, bool checkForIllegalChars);
    private static DirectoryString();
    public virtual bool IsSubsetOf(DirectoryString operand);
    public virtual bool IsSubsetOf(DirectoryString operand, bool ignoreCase);
}
internal static class System.Security.Util.Hex : object {
    public static string EncodeHexString(Byte[] sArray);
    internal static string EncodeHexStringFromInt(Byte[] sArray);
    public static int ConvertHexDigit(char val);
    public static Byte[] DecodeHexString(string hexString);
}
internal class System.Security.Util.LocalSiteString : SiteString {
    public LocalSiteString(string site);
    private static LocalSiteString();
    public virtual bool IsSubsetOf(LocalSiteString operand);
    public virtual bool IsSubsetOf(LocalSiteString operand, bool ignoreCase);
}
internal class System.Security.Util.Parser : object {
    internal Parser(string input);
    internal Parser(string input, String[] searchStrings, String[] replaceStrings);
    internal Parser(Byte[] array, ByteTokenEncoding encoding);
    internal Parser(Byte[] array, ByteTokenEncoding encoding, int startIndex);
    internal Parser(StreamReader input);
    internal Parser(Char[] array);
    internal SecurityElement GetTopElement();
}
[FlagsAttribute]
internal enum System.Security.Util.QuickCacheEntryType : Enum {
    public int value__;
    public static QuickCacheEntryType FullTrustZoneMyComputer;
    public static QuickCacheEntryType FullTrustZoneIntranet;
    public static QuickCacheEntryType FullTrustZoneInternet;
    public static QuickCacheEntryType FullTrustZoneTrusted;
    public static QuickCacheEntryType FullTrustZoneUntrusted;
    public static QuickCacheEntryType FullTrustAll;
}
internal class System.Security.Util.SiteString : object {
    protected string m_site;
    protected ArrayList m_separatedSite;
    protected static Char[] m_separators;
    public SiteString(string site);
    private static SiteString();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal bool Equals(SiteString ss, bool ignoreCase);
    public virtual SiteString Copy();
    public virtual bool IsSubsetOf(SiteString operand);
    public virtual bool IsSubsetOf(SiteString operand, bool ignoreCase);
    public virtual SiteString Intersect(SiteString operand);
    public virtual SiteString Union(SiteString operand);
}
internal class System.Security.Util.StringExpressionSet : object {
    [SecurityCriticalAttribute]
protected ArrayList m_list;
    protected bool m_ignoreCase;
    [SecurityCriticalAttribute]
protected string m_expressions;
    [SecurityCriticalAttribute]
protected String[] m_expressionsArray;
    protected bool m_throwOnRelative;
    protected static Char[] m_separators;
    protected static Char[] m_trimChars;
    protected static char m_directorySeparator;
    protected static char m_alternateDirectorySeparator;
    public StringExpressionSet(string str);
    public StringExpressionSet(bool ignoreCase, bool throwOnRelative);
    [SecuritySafeCriticalAttribute]
public StringExpressionSet(bool ignoreCase, string str, bool throwOnRelative);
    private static StringExpressionSet();
    protected virtual StringExpressionSet CreateNewEmpty();
    [SecuritySafeCriticalAttribute]
public virtual StringExpressionSet Copy();
    public void SetThrowOnRelative(bool throwOnRelative);
    protected virtual string ProcessWholeString(string str);
    protected virtual string ProcessSingleString(string str);
    [SecurityCriticalAttribute]
public void AddExpressions(string str);
    [SecurityCriticalAttribute]
public void AddExpressions(String[] str, bool checkForDuplicates, bool needFullPath);
    [SecurityCriticalAttribute]
public void AddExpressions(ArrayList exprArrayList, bool checkForDuplicates);
    [SecurityCriticalAttribute]
internal static ArrayList CreateListFromExpressions(String[] str, bool needFullPath);
    [SecurityCriticalAttribute]
protected void CheckList();
    protected String[] Split(string expressions);
    [SecurityCriticalAttribute]
protected void CreateList();
    [SecuritySafeCriticalAttribute]
public bool IsEmpty();
    [SecurityCriticalAttribute]
public bool IsSubsetOf(StringExpressionSet ses);
    [SecurityCriticalAttribute]
public bool IsSubsetOfPathDiscovery(StringExpressionSet ses);
    [SecurityCriticalAttribute]
public StringExpressionSet Union(StringExpressionSet ses);
    [SecurityCriticalAttribute]
public StringExpressionSet Intersect(StringExpressionSet ses);
    [SecuritySafeCriticalAttribute]
protected void GenerateString();
    [SecurityCriticalAttribute]
public string UnsafeToString();
    [SecurityCriticalAttribute]
public String[] UnsafeToStringArray();
    protected virtual bool StringSubsetString(string left, string right, bool ignoreCase);
    protected static bool StringSubsetStringPathDiscovery(string left, string right, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
protected void AddSingleExpressionNoDuplicates(string expression);
    [SecurityCriticalAttribute]
protected void Reduce();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void GetLongPathName(string path, StringHandleOnStack retLongPath);
    [SecurityCriticalAttribute]
internal static string CanonicalizePath(string path);
    [SecurityCriticalAttribute]
internal static string CanonicalizePath(string path, bool needFullPath);
}
internal class System.Security.Util.TokenBasedSet : object {
    internal TokenBasedSet(TokenBasedSet tbSet);
    internal bool MoveNext(TokenBasedSetEnumerator& e);
    internal void Reset();
    internal void SetItem(int index, object item);
    internal object GetItem(int index);
    internal object RemoveItem(int index);
    internal int GetStartingIndex();
    internal int GetCount();
    internal int GetMaxUsedIndex();
    internal bool FastIsEmpty();
    internal TokenBasedSet SpecialUnion(TokenBasedSet other);
    internal void SpecialSplit(TokenBasedSet& unrestrictedPermSet, TokenBasedSet& normalPermSet, bool ignoreTypeLoadFailures);
}
internal class System.Security.Util.TokenBasedSetEnumerator : ValueType {
    public object Current;
    public int Index;
    private TokenBasedSet _tb;
    public TokenBasedSetEnumerator(TokenBasedSet tb);
    public bool MoveNext();
    public void Reset();
}
internal class System.Security.Util.Tokenizer : object {
    internal static byte bra;
    internal static byte ket;
    internal static byte slash;
    internal static byte cstr;
    internal static byte equals;
    internal static byte quest;
    internal static byte bang;
    internal static byte dash;
    internal static int intOpenBracket;
    internal static int intCloseBracket;
    internal static int intSlash;
    internal static int intEquals;
    internal static int intQuote;
    internal static int intQuest;
    internal static int intBang;
    internal static int intDash;
    internal static int intTab;
    internal static int intCR;
    internal static int intLF;
    internal static int intSpace;
    public int LineNo;
    internal Tokenizer(string input);
    internal Tokenizer(string input, String[] searchStrings, String[] replaceStrings);
    internal Tokenizer(Byte[] array, ByteTokenEncoding encoding, int startIndex);
    internal Tokenizer(Char[] array);
    internal Tokenizer(StreamReader input);
    internal void BasicInitialization();
    public void Recycle();
    internal void ChangeFormat(Encoding encoding);
    internal void GetTokens(TokenizerStream stream, int maxNum, bool endAfterKet);
}
internal class System.Security.Util.TokenizerShortBlock : object {
    internal Int16[] m_block;
    internal TokenizerShortBlock m_next;
}
internal class System.Security.Util.TokenizerStream : object {
    internal void AddToken(short token);
    internal void AddString(string str);
    internal void Reset();
    internal short GetNextFullToken();
    internal short GetNextToken();
    internal string GetNextString();
    internal void ThrowAwayNextString();
    internal void TagLastToken(short tag);
    internal int GetTokenCount();
    internal void GoToPosition(int position);
}
internal class System.Security.Util.TokenizerStringBlock : object {
    internal String[] m_block;
    internal TokenizerStringBlock m_next;
}
internal class System.Security.Util.URLString : SiteString {
    public string Scheme { get; }
    public string Host { get; }
    public string Port { get; }
    public string Directory { get; }
    public bool IsRelativeFileUrl { get; }
    public URLString(string url);
    public URLString(string url, bool parsed);
    internal URLString(string url, bool parsed, bool doDeferredParsing);
    [OnDeserializedAttribute]
public void OnDeserialized(StreamingContext ctx);
    internal static string PreProcessForExtendedPathRemoval(string url, bool isFileUrl);
    public string get_Scheme();
    public string get_Host();
    public string get_Port();
    public string get_Directory();
    public bool get_IsRelativeFileUrl();
    public string GetFileName();
    public string GetDirectoryName();
    public virtual SiteString Copy();
    public virtual bool IsSubsetOf(SiteString site);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public bool Equals(URLString url);
    public static bool CompareUrls(URLString url1, URLString url2);
    internal string NormalizeUrl();
    [SecuritySafeCriticalAttribute]
internal URLString SpecialNormalizeUrl();
}
internal static class System.Security.Util.XMLUtil : object {
    private static XMLUtil();
    public static SecurityElement NewPermissionElement(IPermission ip);
    public static SecurityElement NewPermissionElement(string name);
    public static void AddClassAttribute(SecurityElement element, Type type, string typename);
    internal static bool ParseElementForAssemblyIdentification(SecurityElement el, String& className, String& assemblyName, String& assemblyVersion);
    public static string SecurityObjectToXmlString(object ob);
    [SecurityCriticalAttribute]
public static object XmlStringToSecurityObject(string s);
    [SecuritySafeCriticalAttribute]
public static IPermission CreatePermission(SecurityElement el, PermissionState permState, bool ignoreTypeLoadFailures);
    [SecuritySafeCriticalAttribute]
public static CodeGroup CreateCodeGroup(SecurityElement el);
    [SecurityCriticalAttribute]
internal static IMembershipCondition CreateMembershipCondition(SecurityElement el);
    internal static Type GetClassFromElement(SecurityElement el, bool ignoreTypeLoadFailures);
    public static bool IsPermissionElement(IPermission ip, SecurityElement el);
    public static bool IsUnrestricted(SecurityElement el);
    public static string BitFieldEnumToString(Type type, object value);
}
[ComVisibleAttribute("True")]
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    protected VerificationException(SerializationInfo info, StreamingContext context);
}
internal enum System.Security.WindowsImpersonationFlowMode : Enum {
    public int value__;
    public static WindowsImpersonationFlowMode IMP_FASTFLOW;
    public static WindowsImpersonationFlowMode IMP_NOFLOW;
    public static WindowsImpersonationFlowMode IMP_ALWAYSFLOW;
    public static WindowsImpersonationFlowMode IMP_DEFAULT;
}
[ComVisibleAttribute("True")]
public class System.Security.XmlSyntaxException : SystemException {
    public XmlSyntaxException(string message);
    public XmlSyntaxException(string message, Exception inner);
    public XmlSyntaxException(int lineNumber);
    public XmlSyntaxException(int lineNumber, string message);
    internal XmlSyntaxException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
[ComVisibleAttribute("True")]
public class System.SerializableAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
}
internal class System.SharedStatics : object {
    public static string Remoting_Identity_IDGuid { get; }
    internal static ulong MemoryFailPointReservedMemory { get; }
    [SecuritySafeCriticalAttribute]
public static string get_Remoting_Identity_IDGuid();
    [SecuritySafeCriticalAttribute]
public static StringMaker GetSharedStringMaker();
    [SecuritySafeCriticalAttribute]
public static void ReleaseSharedStringMaker(StringMaker& maker);
    internal static int Remoting_Identity_GetNextSeqNum();
    [ReliabilityContractAttribute("3", "2")]
internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
}
internal class System.Signature : object {
    internal RuntimeType[] m_arguments;
    internal RuntimeType m_declaringType;
    internal RuntimeType m_returnTypeORfieldType;
    internal object m_keepalive;
    [SecurityCriticalAttribute]
internal Void* m_sig;
    internal int m_managedCallingConventionAndArgIteratorFlags;
    internal int m_nSizeOfArgStack;
    internal int m_csig;
    internal RuntimeMethodHandleInternal m_pMethod;
    internal CallingConventions CallingConvention { get; }
    internal RuntimeType[] Arguments { get; }
    internal RuntimeType ReturnType { get; }
    internal RuntimeType FieldType { get; }
    [SecuritySafeCriticalAttribute]
public Signature(IRuntimeMethodInfo method, RuntimeType[] arguments, RuntimeType returnType, CallingConventions callingConvention);
    [SecuritySafeCriticalAttribute]
public Signature(IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    [SecurityCriticalAttribute]
public Signature(IRuntimeFieldInfo fieldHandle, RuntimeType declaringType);
    [SecurityCriticalAttribute]
public Signature(Void* pCorSig, int cCorSig, RuntimeType declaringType);
    internal CallingConventions get_CallingConvention();
    internal RuntimeType[] get_Arguments();
    internal RuntimeType get_ReturnType();
    internal RuntimeType get_FieldType();
    [SecuritySafeCriticalAttribute]
internal static bool CompareSig(Signature sig1, Signature sig2);
    [SecuritySafeCriticalAttribute]
internal Type[] GetCustomModifiers(int position, bool required);
}
[ComVisibleAttribute("True")]
public class System.Single : ValueType {
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    internal float m_value;
    [SecuritySafeCriticalAttribute]
public static bool IsInfinity(float f);
    [SecuritySafeCriticalAttribute]
public static bool IsPositiveInfinity(float f);
    [SecuritySafeCriticalAttribute]
public static bool IsNegativeInfinity(float f);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static bool IsNaN(float f);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    public static bool op_Equality(float left, float right);
    public static bool op_Inequality(float left, float right);
    public static bool op_LessThan(float left, float right);
    public static bool op_GreaterThan(float left, float right);
    public static bool op_LessThanOrEqual(float left, float right);
    public static bool op_GreaterThanOrEqual(float left, float right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.SizedReference : object {
    internal IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) _handle;
    public object Target { get; }
    public long ApproximateSize { get; }
    [SecuritySafeCriticalAttribute]
public SizedReference(object target);
    protected virtual void Finalize();
    [SecuritySafeCriticalAttribute]
public object get_Target();
    [SecuritySafeCriticalAttribute]
public long get_ApproximateSize();
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    public static string Empty;
    internal char FirstChar { get; }
    public char Chars { get; }
    public int Length { get; }
    internal static bool LegacyMode { get; }
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public String(Char* value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public String(SByte* value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    [SecuritySafeCriticalAttribute]
public String(Char[] value, int startIndex, int length);
    [SecuritySafeCriticalAttribute]
public String(Char[] value);
    [SecuritySafeCriticalAttribute]
public String(char c, int count);
    public static string Join(string separator, String[] value);
    [ComVisibleAttribute("False")]
public static string Join(string separator, Object[] values);
    [ComVisibleAttribute("False")]
public static string Join(string separator, IEnumerable`1<T> values);
    [ComVisibleAttribute("False")]
public static string Join(string separator, IEnumerable`1<string> values);
    internal char get_FirstChar();
    [SecuritySafeCriticalAttribute]
public static string Join(string separator, String[] value, int startIndex, int count);
    [SecurityCriticalAttribute]
internal static int nativeCompareOrdinalEx(string strA, int indexA, string strB, int indexB, int count);
    [SecurityCriticalAttribute]
internal static int nativeCompareOrdinalIgnoreCaseWC(string strA, SByte* strBBytes);
    [SecuritySafeCriticalAttribute]
internal static string SmallCharToUpper(string strIn);
    [ReliabilityContractAttribute("3", "1")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "1")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool Equals(string value);
    [SecuritySafeCriticalAttribute]
public bool Equals(string value, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool Equals(string a, string b);
    [SecuritySafeCriticalAttribute]
public static bool Equals(string a, string b, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Equality(string a, string b);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(string a, string b);
    [SecuritySafeCriticalAttribute]
public char get_Chars(int index);
    [SecuritySafeCriticalAttribute]
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [SecuritySafeCriticalAttribute]
public Char[] ToCharArray();
    [SecuritySafeCriticalAttribute]
public Char[] ToCharArray(int startIndex, int length);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int InternalMarvin32HashString(string s, int sLen, long additionalEntropy);
    [SecuritySafeCriticalAttribute]
internal static bool UseRandomizedHashing();
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
internal int GetLegacyNonRandomizedHashCode();
    [SecuritySafeCriticalAttribute]
public int get_Length();
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    [ComVisibleAttribute("False")]
public String[] Split(Char[] separator, StringSplitOptions options);
    [ComVisibleAttribute("False")]
public String[] Split(Char[] separator, int count, StringSplitOptions options);
    [ComVisibleAttribute("False")]
internal String[] SplitInternal(Char[] separator, int count, StringSplitOptions options);
    [ComVisibleAttribute("False")]
public String[] Split(String[] separator, StringSplitOptions options);
    [ComVisibleAttribute("False")]
public String[] Split(String[] separator, int count, StringSplitOptions options);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string Substring(int startIndex);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public string Substring(int startIndex, int length);
    [SecurityCriticalAttribute]
internal string InternalSubStringWithChecks(int startIndex, int length, bool fAlwaysCopy);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string Trim(Char[] trimChars);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string TrimStart(Char[] trimChars);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string TrimEnd(Char[] trimChars);
    [SecurityCriticalAttribute]
internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    [SecuritySafeCriticalAttribute]
internal int ConvertToAnsi(Byte* pbNativeBuffer, int cbNativeBuffer, bool fBestFit, bool fThrowOnUnmappableChar);
    public bool IsNormalized();
    [SecuritySafeCriticalAttribute]
public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    [SecuritySafeCriticalAttribute]
public string Normalize(NormalizationForm normalizationForm);
    [SecurityCriticalAttribute]
internal static string FastAllocateString(int length);
    [SecurityCriticalAttribute]
internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Compare(string strA, string strB);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Compare(string strA, string strB, bool ignoreCase);
    [SecuritySafeCriticalAttribute]
public static int Compare(string strA, string strB, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    [SecuritySafeCriticalAttribute]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int CompareTo(object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual int CompareTo(string strB);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int CompareOrdinal(string strA, string strB);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool Contains(string value);
    public bool EndsWith(string value);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal bool EndsWith(char value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOf(char value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOf(char value, int startIndex);
    [SecuritySafeCriticalAttribute]
public int IndexOf(char value, int startIndex, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOfAny(Char[] anyOf);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOfAny(Char[] anyOf, int startIndex);
    [SecuritySafeCriticalAttribute]
public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOf(string value, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    [SecuritySafeCriticalAttribute]
public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    [SecuritySafeCriticalAttribute]
public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    [SecuritySafeCriticalAttribute]
public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    [SecuritySafeCriticalAttribute]
public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool StartsWith(string value);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public string ToLower();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string ToLower(CultureInfo culture);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string ToLowerInvariant();
    public string ToUpper();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string ToUpper(CultureInfo culture);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string ToUpperInvariant();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string ToString();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual object Clone();
    public string Trim();
    [SecuritySafeCriticalAttribute]
public string Insert(int startIndex, string value);
    public string Replace(char oldChar, char newChar);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public string Replace(string oldValue, string newValue);
    [SecuritySafeCriticalAttribute]
public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    [SecuritySafeCriticalAttribute]
public static string Copy(string str);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static string Concat(object arg0, object arg1, object arg2, object arg3);
    public static string Concat(Object[] args);
    [ComVisibleAttribute("False")]
public static string Concat(IEnumerable`1<T> values);
    [ComVisibleAttribute("False")]
public static string Concat(IEnumerable`1<string> values);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1, string str2);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static string Intern(string str);
    [SecuritySafeCriticalAttribute]
public static string IsInterned(string str);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool get_LegacyMode();
    [SecurityCriticalAttribute]
internal bool IsFastSort();
    [SecurityCriticalAttribute]
internal bool IsAscii();
    [SecurityCriticalAttribute]
internal void SetTrailByte(byte data);
    [SecurityCriticalAttribute]
internal bool TryGetTrailByte(Byte& data);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void InternalCopy(string src, IntPtr dest, int len);
}
[ComVisibleAttribute("True")]
public abstract class System.StringComparer : object {
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
[ComVisibleAttribute("True")]
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[ComVisibleAttribute("False")]
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.AnsiBSTRMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(int flags, string strManaged);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static string ConvertToManaged(IntPtr bstr);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(IntPtr pNative);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.AnsiCharMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static Byte[] DoAnsiConversion(string str, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cbLength);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static byte ConvertToNative(char managedChar, bool fBestFit, bool fThrowOnUnmappableChar);
    [ForceTokenStabilizationAttribute]
internal static char ConvertToManaged(byte nativeChar);
}
[ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal class System.StubHelpers.AsAnyMarshaler : ValueType {
    private static ushort VTHACK_ANSICHAR;
    private static ushort VTHACK_WINBOOL;
    private IntPtr pvArrayMarshaler;
    private BackPropAction backPropAction;
    private Type layoutType;
    private CleanupWorkList cleanupWorkList;
    [ForceTokenStabilizationAttribute]
internal AsAnyMarshaler(IntPtr pvArrayMarshaler);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal IntPtr ConvertToNative(object pManagedHome, int dwFlags);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void ConvertToManaged(object pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void ClearNative(IntPtr pNativeHome);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.BSTRMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(string strManaged, IntPtr pNativeBuffer);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static string ConvertToManaged(IntPtr bstr);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(IntPtr pNative);
}
[SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
[ReliabilityContractAttribute("3", "1")]
internal class System.StubHelpers.CleanupWorkList : object {
    public void Add(CleanupWorkListElement elem);
    [ReliabilityContractAttribute("3", "2")]
public void Destroy();
}
[SecurityCriticalAttribute]
internal class System.StubHelpers.CleanupWorkListElement : object {
    public SafeHandle m_handle;
    public bool m_owned;
    public CleanupWorkListElement(SafeHandle handle);
}
[ForceTokenStabilizationAttribute]
internal class System.StubHelpers.CopyCtorStubCookie : ValueType {
    public IntPtr m_srcInstancePtr;
    public UInt32 m_dstStackOffset;
    public IntPtr m_ctorPtr;
    public IntPtr m_dtorPtr;
    public IntPtr m_pNext;
    [ForceTokenStabilizationAttribute]
public void SetData(IntPtr srcInstancePtr, UInt32 dstStackOffset, IntPtr ctorPtr, IntPtr dtorPtr);
    [ForceTokenStabilizationAttribute]
public void SetNext(IntPtr pNext);
}
internal class System.StubHelpers.CopyCtorStubDesc : ValueType {
    public IntPtr m_pCookie;
    public IntPtr m_pTarget;
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.CSTRMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static string ConvertToManaged(IntPtr cstr);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(IntPtr pNative);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.DateMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static double ConvertToNative(DateTime managedDate);
    [ForceTokenStabilizationAttribute]
internal static long ConvertToManaged(double nativeDate);
}
[ForceTokenStabilizationAttribute]
internal class System.StubHelpers.DateTimeNative : ValueType {
    public long UniversalTime;
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.DateTimeOffsetMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertToNative(DateTimeOffset& managedDTO, DateTimeNative& dateTime);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertToManaged(DateTimeOffset& managedLocalDTO, DateTimeNative& nativeTicks);
}
[FriendAccessAllowedAttribute]
internal static class System.StubHelpers.EventArgsMarshaler : object {
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static IntPtr CreateNativeNCCEventArgsInstance(int action, object newItems, object oldItems, int newIndex, int oldIndex);
    [SuppressUnmanagedCodeSecurityAttribute]
[FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static IntPtr CreateNativePCEventArgsInstance(string name);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr CreateNativeNCCEventArgsInstanceHelper(int action, IntPtr newItem, IntPtr oldItem, int newIndex, int oldIndex);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.HResultExceptionMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static int ConvertToNative(Exception ex);
    [SecuritySafeCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static Exception ConvertToManaged(int hr);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.HStringMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static IntPtr ConvertToNative(string managed);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr ConvertToNativeReference(string managed, HSTRING_HEADER* hstringHeader);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static string ConvertToManaged(IntPtr hstring);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(IntPtr hstring);
}
[FriendAccessAllowedAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.InterfaceMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static IntPtr ConvertToNative(object objSrc, IntPtr itfMT, IntPtr classMT, int flags);
    [ForceTokenStabilizationAttribute]
internal static object ConvertToManaged(IntPtr pUnk, IntPtr itfMT, IntPtr classMT, int flags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
[ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr pUnk);
    [FriendAccessAllowedAttribute]
[ForceTokenStabilizationAttribute]
internal static object ConvertToManagedWithoutUnboxing(IntPtr pNative);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.KeyValuePairMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(KeyValuePair`2& pair);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static KeyValuePair`2<K, V> ConvertToManaged(IntPtr pInsp);
    [SecurityCriticalAttribute]
internal static object ConvertToManagedBox(IntPtr pInsp);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.MngdHiddenLengthArrayMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, IntPtr cbElementSize, ushort vt);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertContentsToNative_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative_Type(Type[]& managedArray, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertContentsToNative_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int elementCount);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertContentsToManaged_Type(Type[]& managedArray, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertContentsToManaged_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertContentsToManaged_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNativeContents_Type(IntPtr pNativeHome, int cElements);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.MngdNativeArrayMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int dwFlags);
    [ForceTokenStabilizationAttribute]
internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int cElements);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    [ForceTokenStabilizationAttribute]
internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.MngdRefCustomMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pCMHelper);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ClearManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.MngdSafeArrayMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int iRank, int dwFlags);
    [ForceTokenStabilizationAttribute]
internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, object pOriginalManaged);
    [ForceTokenStabilizationAttribute]
internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    [ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
[ForceTokenStabilizationAttribute]
internal class System.StubHelpers.NativeVariant : ValueType {
    private ushort vt;
    private ushort wReserved1;
    private ushort wReserved2;
    private ushort wReserved3;
    private long data1;
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.NullableMarshaler : object {
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static IntPtr ConvertToNative(Nullable`1& pManaged);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static Nullable`1<T> ConvertToManaged(IntPtr pNative);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.ObjectMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static void ConvertToNative(object objSrc, IntPtr pDstVariant);
    [ForceTokenStabilizationAttribute]
internal static object ConvertToManaged(IntPtr pSrcVariant);
    [ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr pVariant);
}
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.StubHelpers.StubHelpers : object {
    [ForceTokenStabilizationAttribute]
internal static bool IsQCall(IntPtr pMD);
    [ForceTokenStabilizationAttribute]
internal static void InitDeclaringType(IntPtr pMD);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetNDirectTarget(IntPtr pMD);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetDelegateTarget(Delegate pThis, IntPtr& pStubArg);
    [ForceTokenStabilizationAttribute]
internal static void SetCopyCtorCookieChain(IntPtr pStubArg, IntPtr pUnmngThis, int dwStubFlags, IntPtr pCookie);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetFinalStubTarget(IntPtr pStubArg, IntPtr pUnmngThis, int dwStubFlags);
    [ForceTokenStabilizationAttribute]
internal static void DemandPermission(IntPtr pNMD);
    [ForceTokenStabilizationAttribute]
internal static void SetLastError();
    [ForceTokenStabilizationAttribute]
internal static void ThrowInteropParamException(int resID, int paramIdx);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static IntPtr AddToCleanupList(CleanupWorkList& pCleanupWorkList, SafeHandle handle);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void DestroyCleanupList(CleanupWorkList& pCleanupWorkList);
    [ForceTokenStabilizationAttribute]
internal static Exception GetHRExceptionObject(int hr);
    [ForceTokenStabilizationAttribute]
internal static Exception InternalGetHRExceptionObject(int hr);
    [ForceTokenStabilizationAttribute]
internal static Exception GetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis);
    [ForceTokenStabilizationAttribute]
internal static Exception GetCOMHRExceptionObject_WinRT(int hr, IntPtr pCPCMD, object pThis);
    [ForceTokenStabilizationAttribute]
internal static Exception InternalGetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis, bool fForWinRT);
    [ForceTokenStabilizationAttribute]
internal static IntPtr CreateCustomMarshalerHelper(IntPtr pMD, int paramToken, IntPtr hndManagedType);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static IntPtr SafeHandleAddRef(SafeHandle pHandle, Boolean& success);
    [ForceTokenStabilizationAttribute]
[ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal static void SafeHandleRelease(SafeHandle pHandle);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetCOMIPFromRCW(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget, Boolean& pfNeedsRelease);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetCOMIPFromRCW_WinRT(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetCOMIPFromRCW_WinRTSharedGeneric(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetCOMIPFromRCW_WinRTDelegate(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    [ForceTokenStabilizationAttribute]
internal static bool ShouldCallWinRTInterface(object objSrc, IntPtr pCPCMD);
    internal static Delegate GetTargetForAmbiguousVariantCall(object objSrc, IntPtr pMT, Boolean& fUseString);
    [ForceTokenStabilizationAttribute]
internal static void StubRegisterRCW(object pThis);
    [ForceTokenStabilizationAttribute]
internal static void StubUnregisterRCW(object pThis);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetDelegateInvokeMethod(Delegate pThis);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static object GetWinRTFactoryObject(IntPtr pCPCMD);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr GetWinRTFactoryReturnValue(object pThis, IntPtr pCtorEntry);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr GetOuterInspectable(object pThis, IntPtr pCtorMD);
    [ForceTokenStabilizationAttribute]
internal static Exception TriggerExceptionSwallowedMDA(Exception ex, IntPtr pManagedTarget);
    [ForceTokenStabilizationAttribute]
internal static void CheckCollectedDelegateMDA(IntPtr pEntryThunk);
    [ForceTokenStabilizationAttribute]
internal static IntPtr ProfilerBeginTransitionCallback(IntPtr pSecretParam, IntPtr pThread, object pThis);
    [ForceTokenStabilizationAttribute]
internal static void ProfilerEndTransitionCallback(IntPtr pMD, IntPtr pThread);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ForceTokenStabilizationAttribute]
internal static void CheckStringLength(int length);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ForceTokenStabilizationAttribute]
internal static void CheckStringLength(UInt32 length);
    [ForceTokenStabilizationAttribute]
internal static int strlen(SByte* ptr);
    [ForceTokenStabilizationAttribute]
internal static void DecimalCanonicalizeInternal(Decimal& dec);
    [ForceTokenStabilizationAttribute]
internal static void FmtClassUpdateNativeInternal(object obj, Byte* pNative, CleanupWorkList& pCleanupWorkList);
    [ForceTokenStabilizationAttribute]
internal static void FmtClassUpdateCLRInternal(object obj, Byte* pNative);
    [ForceTokenStabilizationAttribute]
internal static void LayoutDestroyNativeInternal(Byte* pNative, IntPtr pMT);
    [ForceTokenStabilizationAttribute]
internal static object AllocateInternal(IntPtr typeHandle);
    [ForceTokenStabilizationAttribute]
internal static void MarshalToUnmanagedVaListInternal(IntPtr va_list, UInt32 vaListSize, IntPtr pArgIterator);
    [ForceTokenStabilizationAttribute]
internal static void MarshalToManagedVaListInternal(IntPtr va_list, IntPtr pArgIterator);
    [ForceTokenStabilizationAttribute]
internal static UInt32 CalcVaListSize(IntPtr va_list);
    [ForceTokenStabilizationAttribute]
internal static void ValidateObject(object obj, IntPtr pMD, object pThis);
    [ForceTokenStabilizationAttribute]
internal static void ValidateByref(IntPtr byref, IntPtr pMD, object pThis);
    [ForceTokenStabilizationAttribute]
internal static IntPtr GetStubContext();
    [ForceTokenStabilizationAttribute]
internal static void TriggerGCForMDA();
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.SystemTypeMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertToNative(Type managedType, TypeNameNative* pNativeType);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertToManaged(TypeNameNative* pNativeType, Type& managedType);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(TypeNameNative* pNativeType);
}
internal enum System.StubHelpers.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Projection;
}
[ForceTokenStabilizationAttribute]
internal class System.StubHelpers.TypeNameNative : ValueType {
    internal IntPtr typeName;
    internal TypeKind typeKind;
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.UriMarshaler : object {
    [ForceTokenStabilizationAttribute]
internal static string GetRawUriFromNative(IntPtr pUri);
    [ForceTokenStabilizationAttribute]
internal static IntPtr CreateNativeUriInstance(string rawUri);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.ValueClassMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ConvertToNative(IntPtr dst, IntPtr src, IntPtr pMT, CleanupWorkList& pCleanupWorkList);
    [ForceTokenStabilizationAttribute]
internal static void ConvertToManaged(IntPtr dst, IntPtr src, IntPtr pMT);
    [ForceTokenStabilizationAttribute]
internal static void ClearNative(IntPtr dst, IntPtr pMT);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.VBByValStrMarshaler : object {
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(string strManaged, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cch);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal static string ConvertToManaged(IntPtr pNative, int cch);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.WinRTTypeNameConverter : object {
    internal static string ConvertToWinRTTypeName(Type managedType, Boolean& isPrimitive);
    internal static Type GetTypeFromWinRTTypeName(string typeName, Boolean& isPrimitive);
}
[ReliabilityContractAttribute("3", "1")]
internal static class System.StubHelpers.WSTRBufferMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal class System.SwitchStructure : ValueType {
    internal string name;
    internal int value;
    internal SwitchStructure(string n, int v);
}
internal class System.System_LazyDebugView`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public LazyThreadSafetyMode Mode { get; }
    public bool IsValueFaulted { get; }
    public System_LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public LazyThreadSafetyMode get_Mode();
    public bool get_IsValueFaulted();
}
[ComVisibleAttribute("True")]
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
internal class System.SZArrayHelper : object {
    [SecuritySafeCriticalAttribute]
internal IEnumerator`1<T> GetEnumerator();
    [SecuritySafeCriticalAttribute]
internal int get_Count();
    [SecuritySafeCriticalAttribute]
internal T get_Item(int index);
    [SecuritySafeCriticalAttribute]
internal void set_Item(int index, T value);
}
[ComVisibleAttribute("True")]
public class System.Text.ASCIIEncoding : Encoding {
    [ComVisibleAttribute("False")]
public bool IsSingleByte { get; }
    internal virtual void SetDefaultFallbacks();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    [ComVisibleAttribute("False")]
public virtual Decoder GetDecoder();
    [ComVisibleAttribute("False")]
public virtual Encoder GetEncoder();
}
internal abstract class System.Text.BaseCodePageEncoding : EncodingNLS {
    internal static string CODE_PAGE_DATA_FILE_NAME;
    protected int dataTableCodePage;
    protected bool bFlagDataTable;
    protected int iExtraBytes;
    protected Char[] arrayUnicodeBestFit;
    protected Char[] arrayBytesBestFit;
    protected bool m_bUseMlangTypeForSerialization;
    [SecurityCriticalAttribute]
protected CodePageHeader* pCodePage;
    [SecurityCriticalAttribute]
protected SafeViewOfFileHandle safeMemorySectionHandle;
    [SecurityCriticalAttribute]
protected SafeFileMappingHandle safeFileMappingHandle;
    [SecuritySafeCriticalAttribute]
private static BaseCodePageEncoding();
    [SecurityCriticalAttribute]
internal BaseCodePageEncoding(int codepage);
    [SecurityCriticalAttribute]
internal BaseCodePageEncoding(int codepage, int dataCodePage);
    [SecurityCriticalAttribute]
internal BaseCodePageEncoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal static int GetCodePageByteSize(int codePage);
    [SecurityCriticalAttribute]
protected abstract virtual void LoadManagedCodePage();
    [SecurityCriticalAttribute]
protected Byte* GetSharedMemory(int iSize);
    [SecurityCriticalAttribute]
protected virtual string GetMemorySectionName();
    [SecurityCriticalAttribute]
protected abstract virtual void ReadBestFitTable();
    [SecuritySafeCriticalAttribute]
internal virtual Char[] GetBestFitUnicodeToBytesData();
    [SecuritySafeCriticalAttribute]
internal virtual Char[] GetBestFitBytesToUnicodeData();
    [SecurityCriticalAttribute]
internal void CheckMemorySection();
}
internal class System.Text.CodePageEncoding : object {
    internal CodePageEncoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Text.DBCSCodePageEncoding : BaseCodePageEncoding {
    protected static char UNKNOWN_CHAR_FLAG;
    protected static char UNICODE_REPLACEMENT_CHAR;
    protected static char LEAD_BYTE_CHAR;
    [SecurityCriticalAttribute]
protected Char* mapBytesToUnicode;
    [SecurityCriticalAttribute]
protected UInt16* mapUnicodeToBytes;
    [SecurityCriticalAttribute]
protected Int32* mapCodePageCached;
    protected char charUnknown;
    [SecurityCriticalAttribute]
public DBCSCodePageEncoding(int codePage);
    [SecurityCriticalAttribute]
internal DBCSCodePageEncoding(int codePage, int dataCodePage);
    [SecurityCriticalAttribute]
internal DBCSCodePageEncoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void LoadManagedCodePage();
    protected virtual bool CleanUpBytes(Int32& bytes);
    [SecurityCriticalAttribute]
protected virtual void CleanUpEndBytes(Char* chars);
    [SecurityCriticalAttribute]
protected virtual void ReadBestFitTable();
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Decoder GetDecoder();
}
[ComVisibleAttribute("True")]
public abstract class System.Text.Decoder : object {
    internal DecoderFallback m_fallback;
    internal DecoderFallbackBuffer m_fallbackBuffer;
    [ComVisibleAttribute("False")]
public DecoderFallback Fallback { get; public set; }
    [ComVisibleAttribute("False")]
public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    internal void SerializeDecoder(SerializationInfo info);
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    [ComVisibleAttribute("False")]
public virtual void Reset();
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [ComVisibleAttribute("False")]
public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    [ComVisibleAttribute("False")]
public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.DecoderFallback : object {
    internal bool bIsMicrosoftBestFitFallback;
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    internal bool IsMicrosoftBestFitFallback { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
    internal bool get_IsMicrosoftBestFitFallback();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    [SecurityCriticalAttribute]
internal Byte* byteStart;
    [SecurityCriticalAttribute]
internal Char* charEnd;
    public int Remaining { get; }
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    [SecurityCriticalAttribute]
internal void InternalReset();
    [SecurityCriticalAttribute]
internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    [SecurityCriticalAttribute]
internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    [SecurityCriticalAttribute]
internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
public class System.Text.DecoderFallbackException : ArgumentException {
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    internal DecoderFallbackException(SerializationInfo info, StreamingContext context);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    protected Encoding m_encoding;
    protected bool m_mustFlush;
    internal bool m_throwOnOverflow;
    internal int m_bytesUsed;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal DecoderNLS(SerializationInfo info, StreamingContext context);
    internal DecoderNLS(Encoding encoding);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [SecurityCriticalAttribute]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [SecurityCriticalAttribute]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    [SecuritySafeCriticalAttribute]
public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [SecurityCriticalAttribute]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
    [SecurityCriticalAttribute]
internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
[ComVisibleAttribute("True")]
public abstract class System.Text.Encoder : object {
    internal EncoderFallback m_fallback;
    internal EncoderFallbackBuffer m_fallbackBuffer;
    [ComVisibleAttribute("False")]
public EncoderFallback Fallback { get; public set; }
    [ComVisibleAttribute("False")]
public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    internal void SerializeEncoder(SerializationInfo info);
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    [ComVisibleAttribute("False")]
public virtual void Reset();
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    [ComVisibleAttribute("False")]
public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.EncoderFallback : object {
    internal bool bIsMicrosoftBestFitFallback;
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    [SecurityCriticalAttribute]
internal Char* charStart;
    [SecurityCriticalAttribute]
internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    [SecurityCriticalAttribute]
internal void InternalReset();
    [SecurityCriticalAttribute]
internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal char InternalGetNextChar();
    [SecurityCriticalAttribute]
internal virtual bool InternalFallback(char ch, Char*& chars);
    internal void ThrowLastCharRecursive(int charRecursive);
}
public class System.Text.EncoderFallbackException : ArgumentException {
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(SerializationInfo info, StreamingContext context);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char charLeftOver;
    protected Encoding m_encoding;
    protected bool m_mustFlush;
    internal bool m_throwOnOverflow;
    internal int m_charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal EncoderNLS(SerializationInfo info, StreamingContext context);
    internal EncoderNLS(Encoding encoding);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [SecurityCriticalAttribute]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [SecurityCriticalAttribute]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    [SecuritySafeCriticalAttribute]
public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [SecurityCriticalAttribute]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int get_MaxCharCount();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
}
[ComVisibleAttribute("True")]
public abstract class System.Text.Encoding : object {
    internal static int CodePageASCII;
    internal static int ISO_8859_1;
    internal int m_codePage;
    internal CodePageDataItem dataItem;
    internal bool m_deserializedFromEverett;
    [OptionalFieldAttribute]
internal EncoderFallback encoderFallback;
    [OptionalFieldAttribute]
internal DecoderFallback decoderFallback;
    internal static Byte[] emptyByteArray;
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    [ComVisibleAttribute("False")]
public bool IsSingleByte { get; }
    [ComVisibleAttribute("False")]
public EncoderFallback EncoderFallback { get; public set; }
    [ComVisibleAttribute("False")]
public DecoderFallback DecoderFallback { get; public set; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    public static Encoding ASCII { get; }
    public int CodePage { get; }
    public static Encoding Default { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    protected Encoding(int codePage);
    private static Encoding();
    internal virtual void SetDefaultFallbacks();
    internal void OnDeserializing();
    internal void OnDeserialized();
    internal void DeserializeEncoding(SerializationInfo info, StreamingContext context);
    internal void SerializeEncoding(SerializationInfo info, StreamingContext context);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    [ComVisibleAttribute("False")]
public virtual object Clone();
    public bool get_IsReadOnly();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Encoding get_ASCII();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    public virtual Byte[] GetBytes(Char[] chars);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int get_CodePage();
    [ComVisibleAttribute("False")]
public bool IsAlwaysNormalized();
    [ComVisibleAttribute("False")]
public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public static Encoding get_Default();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    internal void ThrowBytesOverflow();
    [SecurityCriticalAttribute]
internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    internal void ThrowCharsOverflow();
    [SecurityCriticalAttribute]
internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
}
public class System.Text.EncodingInfo : object {
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_Name();
    public string get_DisplayName();
    public Encoding GetEncoding();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string s);
    [SecurityCriticalAttribute]
public virtual int GetByteCount(Char* chars, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecurityCriticalAttribute]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecurityCriticalAttribute]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
internal class System.Text.EUCJPEncoding : DBCSCodePageEncoding {
    [SecurityCriticalAttribute]
protected virtual string GetMemorySectionName();
    protected virtual bool CleanUpBytes(Int32& bytes);
    [SecurityCriticalAttribute]
protected virtual void CleanUpEndBytes(Char* chars);
}
internal enum System.Text.ExtendedNormalizationForms : Enum {
    public int value__;
    public static ExtendedNormalizationForms FormC;
    public static ExtendedNormalizationForms FormD;
    public static ExtendedNormalizationForms FormKC;
    public static ExtendedNormalizationForms FormKD;
    public static ExtendedNormalizationForms FormIdna;
    public static ExtendedNormalizationForms FormCDisallowUnassigned;
    public static ExtendedNormalizationForms FormDDisallowUnassigned;
    public static ExtendedNormalizationForms FormKCDisallowUnassigned;
    public static ExtendedNormalizationForms FormKDDisallowUnassigned;
    public static ExtendedNormalizationForms FormIdnaDisallowUnassigned;
}
internal class System.Text.GB18030Encoding : DBCSCodePageEncoding {
    [SecurityCriticalAttribute]
internal Char* map4BytesToUnicode;
    [SecurityCriticalAttribute]
internal Byte* mapUnicodeTo4BytesFlags;
    [SecurityCriticalAttribute]
internal GB18030Encoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void LoadManagedCodePage();
    internal virtual void SetDefaultFallbacks();
    [SecurityCriticalAttribute]
internal bool Is4Byte(char charTest);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal bool IsGBLeadByte(short ch);
    internal bool IsGBTwoByteTrailing(short ch);
    internal bool IsGBFourByteTrailing(short ch);
    internal int GetFourBytesOffset(short offset1, short offset2, short offset3, short offset4);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Decoder GetDecoder();
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding encoding;
    internal Char[] arrayBestFit;
    internal char cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    internal char cBestFit;
    internal int iCount;
    internal int iSize;
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
    [SecurityCriticalAttribute]
internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding encoding;
    internal Char[] arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
}
internal class System.Text.ISCIIEncoding : EncodingNLS {
    public ISCIIEncoding(int codePage);
    internal ISCIIEncoding(SerializationInfo info, StreamingContext context);
    private static ISCIIEncoding();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetHashCode();
}
internal class System.Text.ISO2022Encoding : DBCSCodePageEncoding {
    [SecurityCriticalAttribute]
internal ISO2022Encoding(int codePage);
    [SecurityCriticalAttribute]
internal ISO2022Encoding(SerializationInfo info, StreamingContext context);
    private static ISO2022Encoding();
    [SecurityCriticalAttribute]
protected virtual string GetMemorySectionName();
    protected virtual bool CleanUpBytes(Int32& bytes);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    public bool IsSingleByte { get; }
    internal Latin1Encoding(SerializationInfo info, StreamingContext context);
    private static Latin1Encoding();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
internal class System.Text.MLangCodePageEncoding : object {
    internal MLangCodePageEncoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Text.Normalization : object {
    [SecurityCriticalAttribute]
internal static bool IsNormalized(string strInput, NormalizationForm normForm);
    [SecurityCriticalAttribute]
internal static string Normalize(string strInput, NormalizationForm normForm);
}
[ComVisibleAttribute("True")]
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
internal class System.Text.SBCSCodePageEncoding : BaseCodePageEncoding {
    public bool IsSingleByte { get; }
    [SecurityCriticalAttribute]
public SBCSCodePageEncoding(int codePage);
    [SecurityCriticalAttribute]
internal SBCSCodePageEncoding(int codePage, int dataCodePage);
    [SecurityCriticalAttribute]
internal SBCSCodePageEncoding(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void LoadManagedCodePage();
    [SecurityCriticalAttribute]
protected virtual void ReadBestFitTable();
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    [ComVisibleAttribute("False")]
public virtual bool IsAlwaysNormalized(NormalizationForm form);
}
[DefaultMemberAttribute("Chars")]
[ComVisibleAttribute("True")]
public class System.Text.StringBuilder : object {
    internal static int DefaultCapacity;
    internal static int MaxChunkSize;
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringBuilder(int capacity);
    public StringBuilder(string value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringBuilder(string value, int capacity);
    [SecuritySafeCriticalAttribute]
public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public StringBuilder Append(char value, int repeatCount);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(Char[] value, int startIndex, int charCount);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(string value);
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal void ReplaceBufferInternal(Char* newBuffer, int newLength);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal void ReplaceBufferAnsiInternal(SByte* newBuffer, int newLength);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(string value, int startIndex, int count);
    [ComVisibleAttribute("False")]
public StringBuilder AppendLine();
    [ComVisibleAttribute("False")]
public StringBuilder AppendLine(string value);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    public StringBuilder Append(short value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringBuilder Append(object value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(Char[] value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuilder Replace(string oldValue, string newValue);
    public bool Equals(StringBuilder sb);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [SecurityCriticalAttribute]
internal StringBuilder Append(Char* value, int valueCount);
    [SecurityCriticalAttribute]
[ForceTokenStabilizationAttribute]
internal void InternalCopy(IntPtr dest, int len);
}
internal static class System.Text.StringBuilderCache : object {
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal class System.Text.SurrogateEncoder : object {
    internal SurrogateEncoder(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Text.UnicodeEncoding : Encoding {
    public static int CharSize;
    [OptionalFieldAttribute]
internal bool isThrowException;
    internal bool bigEndian;
    internal bool byteOrderMark;
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    internal virtual void SetDefaultFallbacks();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string s);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual string GetString(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    [ComVisibleAttribute("False")]
public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF32Encoding : Encoding {
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    internal virtual void SetDefaultFallbacks();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetByteCount(Char* chars, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
public virtual string GetString(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Text.UTF7Encoding : Encoding {
    public UTF7Encoding(bool allowOptionals);
    internal virtual void SetDefaultFallbacks();
    [ComVisibleAttribute("False")]
public virtual bool Equals(object value);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string s);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual string GetString(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[ComVisibleAttribute("True")]
public class System.Text.UTF8Encoding : Encoding {
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    internal virtual void SetDefaultFallbacks();
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(string chars);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public virtual string GetString(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Threading._IOCompletionCallback : object {
    internal static ContextCallback _ccb;
    [SecuritySafeCriticalAttribute]
private static _IOCompletionCallback();
    [SecurityCriticalAttribute]
internal _IOCompletionCallback(IOCompletionCallback ioCompletionCallback, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void IOCompletionCallback_Context(object state);
    [SecurityCriticalAttribute]
internal static void PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
}
internal static class System.Threading._ThreadPoolWaitCallback : object {
    [SecurityCriticalAttribute]
internal static bool PerformWaitCallback();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    [SecuritySafeCriticalAttribute]
private static _ThreadPoolWaitOrTimerCallback();
    [SecurityCriticalAttribute]
internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static void PerformWaitOrTimerCallback(object state, bool timedOut);
}
[ComVisibleAttribute("False")]
public class System.Threading.AbandonedMutexException : SystemException {
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
[ComVisibleAttribute("True")]
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private bool useEC;
    private ExecutionContext _ec;
    private SecurityContext _sc;
    private Thread _thread;
    [SecurityCriticalAttribute]
internal void Setup(SecurityContextDisableFlow flags);
    [SecurityCriticalAttribute]
internal void Setup();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public void Undo();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
[ComVisibleAttribute("True")]
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
internal class System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
    internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> m_currArrayFragment;
    internal int m_currArrayIndex;
    public CancellationCallbackCoreWorkArguments(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
}
internal class System.Threading.CancellationCallbackInfo : object {
    internal Action`1<object> Callback;
    internal object StateForCallback;
    internal SynchronizationContext TargetSyncContext;
    internal ExecutionContext TargetExecutionContext;
    internal CancellationTokenSource CancellationTokenSource;
    internal CancellationCallbackInfo(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
    [SecuritySafeCriticalAttribute]
internal void ExecuteCallback();
}
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
[ComVisibleAttribute("False")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource m_source;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static CancellationToken get_None();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsCancellationRequested();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void ThrowIfCancellationRequested();
    internal void ThrowIfSourceDisposed();
}
public class System.Threading.CancellationTokenRegistration : ValueType {
    private CancellationCallbackInfo m_callbackInfo;
    private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;
    internal CancellationTokenRegistration(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
    [FriendAccessAllowedAttribute]
internal bool TryDeregister();
    public sealed virtual void Dispose();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("False")]
public class System.Threading.CancellationTokenSource : object {
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal bool IsDisposed { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal bool CanBeCanceled { get; }
    internal WaitHandle WaitHandle { get; }
    internal CancellationCallbackInfo ExecutingCallback { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal bool get_IsDisposed();
    internal void set_ThreadIDExecutingCallbacks(int value);
    internal int get_ThreadIDExecutingCallbacks();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public CancellationToken get_Token();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal bool get_CanBeCanceled();
    internal WaitHandle get_WaitHandle();
    internal CancellationCallbackInfo get_ExecutingCallback();
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal void ThrowIfDisposed();
    internal static CancellationTokenSource InternalGetStaticSource(bool set);
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
}
[FriendAccessAllowedAttribute]
[EventSourceAttribute]
internal class System.Threading.CdsSyncEtwBCLProvider : EventSource {
    public static CdsSyncEtwBCLProvider Log;
    private static CdsSyncEtwBCLProvider();
    [EventAttribute("1")]
public void SpinLock_FastPathFailed(int ownerID);
    [EventAttribute("2")]
public void SpinWait_NextSpinWillYield();
    [SecuritySafeCriticalAttribute]
[EventAttribute("3")]
public void Barrier_PhaseFinished(bool currentSense, long phaseNum);
}
public class System.Threading.CompressedStack : object {
    internal static TryCode modreq(System.Runtime.CompilerServices.IsVolatile) tryCode;
    internal static CleanupCode modreq(System.Runtime.CompilerServices.IsVolatile) cleanupCode;
    internal PermissionListSet PLS { get; }
    internal SafeCompressedStackHandle CompressedStackHandle { get; private set; }
    [SecurityCriticalAttribute]
internal CompressedStack(SafeCompressedStackHandle csHandle);
    internal PermissionListSet get_PLS();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal SafeCompressedStackHandle get_CompressedStackHandle();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
private void set_CompressedStackHandle(SafeCompressedStackHandle value);
    [SecurityCriticalAttribute]
public static CompressedStack GetCompressedStack();
    [SecurityCriticalAttribute]
internal static CompressedStack GetCompressedStack(StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public static CompressedStack Capture();
    [SecurityCriticalAttribute]
public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
    [SecurityCriticalAttribute]
internal static void runTryCode(object userData);
    [SecurityCriticalAttribute]
[PrePrepareMethodAttribute]
internal static void runFinallyCode(object userData, bool exceptionThrown);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal static CompressedStackSwitcher SetCompressedStack(CompressedStack cs, CompressedStack prevCS);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public CompressedStack CreateCopy();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static IntPtr SetAppDomainStack(CompressedStack cs);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void RestoreAppDomainStack(IntPtr appDomainStack);
    [SecurityCriticalAttribute]
internal static CompressedStack GetCompressedStackThread();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static void SetCompressedStackThread(CompressedStack cs);
    [SecurityCriticalAttribute]
internal bool CheckDemand(CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal bool CheckSetDemand(PermissionSet pset, RuntimeMethodHandleInternal rmh);
    [SecurityCriticalAttribute]
internal void DemandFlagsOrGrantSet(int flags, PermissionSet grantSet);
    [SecurityCriticalAttribute]
internal void GetZoneAndOrigin(ArrayList zoneList, ArrayList originList, PermissionToken zoneToken, PermissionToken originToken);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal void CompleteConstruction(CompressedStack innerCS);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static SafeCompressedStackHandle GetDelayedCompressedStack(StackCrawlMark& stackMark, bool walkStack);
    [SecurityCriticalAttribute]
internal static void DestroyDelayedCompressedStack(IntPtr unmanagedCompressedStack);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal static void DestroyDCSList(SafeCompressedStackHandle compressedStack);
    [SecurityCriticalAttribute]
internal static int GetDCSCount(SafeCompressedStackHandle compressedStack);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal static bool IsImmediateCompletionCandidate(SafeCompressedStackHandle compressedStack, CompressedStack& innerCS);
    [SecurityCriticalAttribute]
internal static DomainCompressedStack GetDomainCompressedStack(SafeCompressedStackHandle compressedStack, int index);
    [SecurityCriticalAttribute]
internal static void GetHomogeneousPLS(PermissionListSet hgPLS);
}
internal class System.Threading.CompressedStackSwitcher : ValueType {
    internal CompressedStack curr_CS;
    internal CompressedStack prev_CS;
    internal IntPtr prev_ADStack;
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CompressedStackSwitcher c1, CompressedStackSwitcher c2);
    public static bool op_Inequality(CompressedStackSwitcher c1, CompressedStackSwitcher c2);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal bool UndoNoThrow();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public void Undo();
}
[ComVisibleAttribute("True")]
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("Initial Count={InitialCount}, Current Count={CurrentCount}")]
[ComVisibleAttribute("False")]
public class System.Threading.CountdownEvent : object {
    public int CurrentCount { get; }
    public int InitialCount { get; }
    public bool IsSet { get; }
    public WaitHandle WaitHandle { get; }
    public CountdownEvent(int initialCount);
    public int get_CurrentCount();
    public int get_InitialCount();
    public bool get_IsSet();
    public WaitHandle get_WaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool Signal();
    public bool Signal(int signalCount);
    public void AddCount();
    public bool TryAddCount();
    public void AddCount(int signalCount);
    public bool TryAddCount(int signalCount);
    public void Reset();
    public void Reset(int count);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
}
internal class System.Threading.DomainCompressedStack : object {
    internal PermissionListSet PLS { get; }
    internal bool ConstructionHalted { get; }
    internal PermissionListSet get_PLS();
    internal bool get_ConstructionHalted();
    [SecurityCriticalAttribute]
internal static int GetDescCount(IntPtr dcs);
    [SecurityCriticalAttribute]
internal static void GetDomainPermissionSets(IntPtr dcs, PermissionSet& granted, PermissionSet& refused);
    [SecurityCriticalAttribute]
internal static bool GetDescriptorInfo(IntPtr dcs, int index, PermissionSet& granted, PermissionSet& refused, Assembly& assembly, FrameSecurityDescriptor& fsd);
    [SecurityCriticalAttribute]
internal static bool IgnoreDomain(IntPtr dcs);
}
[ComVisibleAttribute("False")]
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[ComVisibleAttribute("True")]
public class System.Threading.EventWaitHandle : WaitHandle {
    [SecuritySafeCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity);
    [SecurityCriticalAttribute]
public static EventWaitHandle OpenExisting(string name);
    [SecurityCriticalAttribute]
public static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, EventWaitHandle& result);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, EventWaitHandleRights rights, EventWaitHandle& result);
    [SecuritySafeCriticalAttribute]
public bool Reset();
    [SecuritySafeCriticalAttribute]
public bool Set();
    [SecuritySafeCriticalAttribute]
public EventWaitHandleSecurity GetAccessControl();
    [SecuritySafeCriticalAttribute]
public void SetAccessControl(EventWaitHandleSecurity eventSecurity);
}
public class System.Threading.ExecutionContext : object {
    internal bool isNewCapture { get; internal set; }
    internal bool isFlowSuppressed { get; internal set; }
    internal static ExecutionContext PreAllocatedDefault { get; }
    internal bool IsPreAllocatedDefault { get; }
    internal LogicalCallContext LogicalCallContext { get; internal set; }
    internal IllogicalCallContext IllogicalCallContext { get; internal set; }
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    internal SynchronizationContext SynchronizationContextNoFlow { get; internal set; }
    internal HostExecutionContext HostExecutionContext { get; internal set; }
    internal SecurityContext SecurityContext { get; internal set; }
    [ReliabilityContractAttribute("3", "2")]
internal ExecutionContext(bool isPreAllocatedDefault);
    private static ExecutionContext();
    internal bool get_isNewCapture();
    internal void set_isNewCapture(bool value);
    internal bool get_isFlowSuppressed();
    internal void set_isFlowSuppressed(bool value);
    [SecuritySafeCriticalAttribute]
internal static ExecutionContext get_PreAllocatedDefault();
    internal bool get_IsPreAllocatedDefault();
    [SecurityCriticalAttribute]
internal LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal void set_LogicalCallContext(LogicalCallContext value);
    internal IllogicalCallContext get_IllogicalCallContext();
    internal void set_IllogicalCallContext(IllogicalCallContext value);
    [ReliabilityContractAttribute("3", "2")]
internal SynchronizationContext get_SynchronizationContext();
    [ReliabilityContractAttribute("3", "2")]
internal void set_SynchronizationContext(SynchronizationContext value);
    [ReliabilityContractAttribute("3", "2")]
internal SynchronizationContext get_SynchronizationContextNoFlow();
    [ReliabilityContractAttribute("3", "2")]
internal void set_SynchronizationContextNoFlow(SynchronizationContext value);
    internal HostExecutionContext get_HostExecutionContext();
    internal void set_HostExecutionContext(HostExecutionContext value);
    [ReliabilityContractAttribute("3", "2")]
internal SecurityContext get_SecurityContext();
    [ReliabilityContractAttribute("3", "2")]
internal void set_SecurityContext(SecurityContext value);
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static void Run(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
    [SecurityCriticalAttribute]
internal static void EstablishCopyOnWriteScope(Thread currentThread, bool knownNullWindowsIdentity, ExecutionContextSwitcher& ecsw);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal static ExecutionContextSwitcher SetExecutionContext(ExecutionContext executionContext, bool preserveSyncCtx);
    [SecuritySafeCriticalAttribute]
public ExecutionContext CreateCopy();
    [SecuritySafeCriticalAttribute]
internal ExecutionContext CreateMutableCopy();
    [SecurityCriticalAttribute]
public static AsyncFlowControl SuppressFlow();
    [SecuritySafeCriticalAttribute]
public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    [SecuritySafeCriticalAttribute]
public static ExecutionContext Capture();
    [FriendAccessAllowedAttribute]
[SecuritySafeCriticalAttribute]
internal static ExecutionContext FastCapture();
    [SecurityCriticalAttribute]
internal static ExecutionContext Capture(StackCrawlMark& stackMark, CaptureOptions options);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal bool IsDefaultFTContext(bool ignoreSyncCtx);
}
internal class System.Threading.ExecutionContextSwitcher : ValueType {
    internal Reader outerEC;
    internal bool outerECBelongsToScope;
    internal SecurityContextSwitcher scsw;
    internal object hecsw;
    internal WindowsIdentity wi;
    internal bool cachedAlwaysFlowImpersonationPolicy;
    internal bool wiIsValid;
    internal Thread thread;
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[ReliabilityContractAttribute("3", "1")]
internal bool UndoNoThrow();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal void Undo(Thread currentThread);
}
public class System.Threading.HostExecutionContext : object {
    protected internal object State { get; protected internal set; }
    public HostExecutionContext(object state);
    protected internal object get_State();
    protected internal void set_State(object value);
    [SecuritySafeCriticalAttribute]
public virtual HostExecutionContext CreateCopy();
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
}
public class System.Threading.HostExecutionContextManager : object {
    [SecurityCriticalAttribute]
internal static int ReleaseHostSecurityContext(IntPtr context);
    [SecurityCriticalAttribute]
internal static int CloneHostSecurityContext(SafeHandle context, SafeHandle clonedContext);
    [SecurityCriticalAttribute]
internal static bool CheckIfHosted();
    [SecuritySafeCriticalAttribute]
public virtual HostExecutionContext Capture();
    [SecurityCriticalAttribute]
public virtual object SetHostExecutionContext(HostExecutionContext hostExecutionContext);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public virtual void Revert(object previousState);
    [SecurityCriticalAttribute]
internal static HostExecutionContext CaptureHostExecutionContext();
    [SecurityCriticalAttribute]
internal static object SetHostExecutionContextInternal(HostExecutionContext hostContext);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal static HostExecutionContextManager GetCurrentHostExecutionContextManager();
    internal static HostExecutionContextManager GetInternalHostExecutionContextManager();
}
internal class System.Threading.HostExecutionContextSwitcher : object {
    internal ExecutionContext executionContext;
    internal HostExecutionContext previousHostContext;
    internal HostExecutionContext currentHostContext;
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void Undo(object switcherObject);
}
public static class System.Threading.Interlocked : object {
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Increment(Int32& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long Increment(Int64& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static int Decrement(Int32& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static long Decrement(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static int Exchange(Int32& location1, int value);
    [SecuritySafeCriticalAttribute]
public static long Exchange(Int64& location1, long value);
    [SecuritySafeCriticalAttribute]
public static float Exchange(Single& location1, float value);
    [SecuritySafeCriticalAttribute]
public static double Exchange(Double& location1, double value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static object Exchange(Object& location1, object value);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
[ComVisibleAttribute("False")]
public static T Exchange(T& location1, T value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static int CompareExchange(Int32& location1, int value, int comparand);
    [SecuritySafeCriticalAttribute]
public static long CompareExchange(Int64& location1, long value, long comparand);
    [SecuritySafeCriticalAttribute]
public static float CompareExchange(Single& location1, float value, float comparand);
    [SecuritySafeCriticalAttribute]
public static double CompareExchange(Double& location1, double value, double comparand);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static object CompareExchange(Object& location1, object value, object comparand);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    [ReliabilityContractAttribute("3", "2")]
[ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public static T CompareExchange(T& location1, T value, T comparand);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded);
    [ReliabilityContractAttribute("3", "2")]
internal static int ExchangeAdd(Int32& location1, int value);
    internal static long ExchangeAdd(Int64& location1, long value);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Add(Int32& location1, int value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static long Add(Int64& location1, long value);
    public static long Read(Int64& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void MemoryBarrier();
}
internal class System.Threading.InternalCrossContextDelegate : MulticastDelegate {
    public InternalCrossContextDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Threading.IThreadPoolWorkItem {
    [SecurityCriticalAttribute]
public abstract virtual void ExecuteWorkItem();
    [SecurityCriticalAttribute]
public abstract virtual void MarkAborted(ThreadAbortException tae);
}
[SecurityCriticalAttribute]
internal class System.Threading.IUnknownSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    internal object Clone();
}
internal static class System.Threading.LazyHelpers`1 : object {
    internal static Func`1<T> s_activatorFactorySelector;
    private static LazyHelpers`1();
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[ComVisibleAttribute("True")]
public class System.Threading.LockCookie : ValueType {
    private int _dwFlags;
    private int _dwWriterSeqNum;
    private int _wReaderAndWriterLevel;
    private int _dwThreadID;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(LockCookie obj);
    public static bool op_Equality(LockCookie a, LockCookie b);
    public static bool op_Inequality(LockCookie a, LockCookie b);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
    public LockRecursionException(string message, Exception innerException);
}
[ComVisibleAttribute("True")]
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    public void Set();
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public static class System.Threading.Monitor : object {
    [SecuritySafeCriticalAttribute]
public static void Enter(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Enter(object obj, Boolean& lockTaken);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void Exit(object obj);
    public static bool TryEnter(object obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void TryEnter(object obj, Boolean& lockTaken);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool TryEnter(object obj, int millisecondsTimeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    [SecuritySafeCriticalAttribute]
public static bool IsEntered(object obj);
    [SecuritySafeCriticalAttribute]
public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    [SecuritySafeCriticalAttribute]
public static void Pulse(object obj);
    [SecuritySafeCriticalAttribute]
public static void PulseAll(object obj);
}
[ComVisibleAttribute("True")]
public class System.Threading.Mutex : WaitHandle {
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew, MutexSecurity mutexSecurity);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
internal Mutex(bool initiallyOwned, string name, Boolean& createdNew, SECURITY_ATTRIBUTES secAttrs);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public Mutex(bool initiallyOwned, string name);
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public Mutex(bool initiallyOwned);
    private static Mutex();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
internal void CreateMutexWithGuaranteedCleanup(bool initiallyOwned, string name, Boolean& createdNew, SECURITY_ATTRIBUTES secAttrs);
    [SecurityCriticalAttribute]
public static Mutex OpenExisting(string name);
    [SecurityCriticalAttribute]
public static Mutex OpenExisting(string name, MutexRights rights);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, Mutex& result);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, MutexRights rights, Mutex& result);
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public void ReleaseMutex();
    [SecuritySafeCriticalAttribute]
public MutexSecurity GetAccessControl();
    [SecuritySafeCriticalAttribute]
public void SetAccessControl(MutexSecurity mutexSecurity);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal static void AcquireReservedMutex(Boolean& bHandleObtained);
    [ReliabilityContractAttribute("3", "1")]
internal static void ReleaseReservedMutex();
}
[ComVisibleAttribute("True")]
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
[ComVisibleAttribute("True")]
public class System.Threading.Overlapped : object {
    public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    [ComVisibleAttribute("False")]
public IntPtr EventHandleIntPtr { get; public set; }
    internal _IOCompletionCallback iocbHelper { get; }
    internal IOCompletionCallback UserCallback { get; }
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  http://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    internal _IOCompletionCallback get_iocbHelper();
    [SecurityCriticalAttribute]
internal IOCompletionCallback get_UserCallback();
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
}
internal class System.Threading.OverlappedData : object {
    internal IAsyncResult m_asyncResult;
    [SecurityCriticalAttribute]
internal IOCompletionCallback m_iocb;
    internal _IOCompletionCallback m_iocbHelper;
    internal Overlapped m_overlapped;
    internal NativeOverlapped m_nativeOverlapped;
    [ComVisibleAttribute("False")]
internal IntPtr UserHandle { get; internal set; }
    [SecurityCriticalAttribute]
internal void ReInitialize();
    [SecurityCriticalAttribute]
internal NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [SecurityCriticalAttribute]
internal NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    internal IntPtr get_UserHandle();
    internal void set_UserHandle(IntPtr value);
    [SecurityCriticalAttribute]
internal static void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);
    [SecurityCriticalAttribute]
internal static OverlappedData GetOverlappedFromNative(NativeOverlapped* nativeOverlappedPtr);
    [SecurityCriticalAttribute]
internal static void CheckVMForIOPacket(NativeOverlapped*& pOVERLAP, UInt32& errorCode, UInt32& numBytes);
}
internal class System.Threading.OverlappedDataCache : CriticalFinalizerObject {
    private static OverlappedDataCache();
    protected virtual void Finalize();
    internal static OverlappedData GetOverlappedData(Overlapped overlapped);
    [SecurityCriticalAttribute]
internal static void CacheOverlappedData(OverlappedData data);
}
[ComVisibleAttribute("False")]
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    internal static int ProcessorCount { get; }
    internal static bool IsSingleProcessor { get; }
    internal static int get_ProcessorCount();
    internal static bool get_IsSingleProcessor();
}
internal class System.Threading.QueueUserWorkItemCallback : object {
    [SecurityCriticalAttribute]
internal static ContextCallback ccb;
    [SecuritySafeCriticalAttribute]
private static QueueUserWorkItemCallback();
    [SecurityCriticalAttribute]
internal QueueUserWorkItemCallback(WaitCallback waitCallback, object stateObj, bool compressStack, StackCrawlMark& stackMark);
    internal QueueUserWorkItemCallback(WaitCallback waitCallback, object stateObj, ExecutionContext ec);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
}
[ComVisibleAttribute("True")]
public class System.Threading.ReaderWriterLock : CriticalFinalizerObject {
    public bool IsReaderLockHeld { get; }
    public bool IsWriterLockHeld { get; }
    public int WriterSeqNum { get; }
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public bool get_IsReaderLockHeld();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public bool get_IsWriterLockHeld();
    [SecuritySafeCriticalAttribute]
public int get_WriterSeqNum();
    [SecuritySafeCriticalAttribute]
public void AcquireReaderLock(int millisecondsTimeout);
    [SecuritySafeCriticalAttribute]
public void AcquireReaderLock(TimeSpan timeout);
    [SecuritySafeCriticalAttribute]
public void AcquireWriterLock(int millisecondsTimeout);
    [SecuritySafeCriticalAttribute]
public void AcquireWriterLock(TimeSpan timeout);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public void ReleaseReaderLock();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void ReleaseWriterLock();
    [SecuritySafeCriticalAttribute]
public LockCookie UpgradeToWriterLock(int millisecondsTimeout);
    public LockCookie UpgradeToWriterLock(TimeSpan timeout);
    [SecuritySafeCriticalAttribute]
public void DowngradeFromWriterLock(LockCookie& lockCookie);
    [SecuritySafeCriticalAttribute]
public LockCookie ReleaseLock();
    [SecuritySafeCriticalAttribute]
public void RestoreLock(LockCookie& lockCookie);
    [SecuritySafeCriticalAttribute]
public bool AnyWritersSince(int seqNum);
}
[ComVisibleAttribute("True")]
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    internal void SetHandle(IntPtr handle);
    [SecurityCriticalAttribute]
internal void SetWaitObject(WaitHandle waitObject);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
public bool Unregister(WaitHandle waitObject);
}
internal class System.Threading.RegisteredWaitHandleSafe : CriticalFinalizerObject {
    internal IntPtr GetHandle();
    internal void SetHandle(IntPtr handle);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
internal void SetWaitObject(WaitHandle waitObject);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal bool Unregister(WaitHandle waitObject);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
}
[SecurityCriticalAttribute]
internal class System.Threading.SafeCompressedStackHandle : SafeHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[ComVisibleAttribute("False")]
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.SparselyPopulatedArray`1 : object {
    internal SparselyPopulatedArrayFragment`1<T> Tail { get; }
    internal SparselyPopulatedArray`1(int initialSize);
    internal SparselyPopulatedArrayFragment`1<T> get_Tail();
    internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);
}
internal class System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
    private SparselyPopulatedArrayFragment`1<T> m_source;
    private int m_index;
    internal SparselyPopulatedArrayFragment`1<T> Source { get; }
    internal int Index { get; }
    internal SparselyPopulatedArrayAddInfo`1(SparselyPopulatedArrayFragment`1<T> source, int index);
    internal SparselyPopulatedArrayFragment`1<T> get_Source();
    internal int get_Index();
}
[DefaultMemberAttribute("Item")]
internal class System.Threading.SparselyPopulatedArrayFragment`1 : object {
    internal T[] m_elements;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_freeCount;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_next;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_prev;
    internal T Item { get; }
    internal int Length { get; }
    internal SparselyPopulatedArrayFragment`1<T> Prev { get; }
    internal SparselyPopulatedArrayFragment`1(int size);
    internal SparselyPopulatedArrayFragment`1(int size, SparselyPopulatedArrayFragment`1<T> prev);
    internal T get_Item(int index);
    internal int get_Length();
    internal SparselyPopulatedArrayFragment`1<T> get_Prev();
    internal T SafeAtomicRemove(int index, T expectedElement);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
public class System.Threading.SpinLock : ValueType {
    private static int SPINNING_FACTOR;
    private static int SLEEP_ONE_FREQUENCY;
    private static int SLEEP_ZERO_FREQUENCY;
    private static int TIMEOUT_CHECK_FREQUENCY;
    private static int LOCK_ID_DISABLE_MASK;
    private static int LOCK_ANONYMOUS_OWNED;
    private static int WAITERS_MASK;
    private static int ID_DISABLED_AND_ANONYMOUS_OWNED;
    private static int LOCK_UNOWNED;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    [ReliabilityContractAttribute("3", "2")]
public void Exit();
    [ReliabilityContractAttribute("3", "2")]
public void Exit(bool useMemoryBarrier);
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeld();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeldByCurrentThread();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int YIELD_THRESHOLD;
    internal static int SLEEP_0_EVERY_HOW_MANY_TIMES;
    internal static int SLEEP_1_EVERY_HOW_MANY_TIMES;
    private int m_count;
    public int Count { get; }
    public bool NextSpinWillYield { get; }
    public int get_Count();
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
public class System.Threading.SynchronizationContext : object {
    public static SynchronizationContext Current { get; }
    internal static SynchronizationContext CurrentNoFlow { get; }
    [SecuritySafeCriticalAttribute]
protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [PrePrepareMethodAttribute]
[CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [ReliabilityContractAttribute("3", "1")]
[CLSCompliantAttribute("False")]
[PrePrepareMethodAttribute]
[SecurityCriticalAttribute]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [SecurityCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void SetSynchronizationContext(SynchronizationContext syncContext);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static SynchronizationContext get_Current();
    [FriendAccessAllowedAttribute]
internal static SynchronizationContext get_CurrentNoFlow();
    public virtual SynchronizationContext CreateCopy();
}
[FlagsAttribute]
internal enum System.Threading.SynchronizationContextProperties : Enum {
    public int value__;
    public static SynchronizationContextProperties None;
    public static SynchronizationContextProperties RequireWaitNotification;
}
[ComVisibleAttribute("True")]
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    protected Action m_action;
    internal static bool IsValidLocationForInlining { get; }
    [SecurityCriticalAttribute]
internal AwaitTaskContinuation(Action action, bool flowExecutionContext, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    [SecuritySafeCriticalAttribute]
internal virtual void Run(Task ignored, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    [SecurityCriticalAttribute]
protected static ContextCallback GetInvokeActionCallback();
    [SecurityCriticalAttribute]
protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    [SecurityCriticalAttribute]
internal static void RunOrScheduleAction(Action action, bool allowInlining, Task& currentTask);
    [SecurityCriticalAttribute]
internal static void UnsafeScheduleAction(Action action);
    protected static void ThrowAsyncIfNecessary(Exception exc);
}
internal class System.Threading.Tasks.BeginEndAwaitableAdapter : object {
    public static AsyncCallback Callback;
    public bool IsCompleted { get; }
    private static BeginEndAwaitableAdapter();
    public BeginEndAwaitableAdapter GetAwaiter();
    public bool get_IsCompleted();
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    public sealed virtual void OnCompleted(Action continuation);
    public IAsyncResult GetResult();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    public Task Completion { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    public void Complete();
    public Task get_Completion();
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    [ConditionalAttribute("DEBUG")]
internal static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark& stackMark);
    internal virtual void InnerInvoke();
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
internal class System.Threading.Tasks.IndexRange : ValueType {
    internal long m_nFromInclusive;
    internal long m_nToExclusive;
    internal Shared`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_nSharedCurrentIndexOffset;
    internal int m_bRangeFinished;
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ChildReplica;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions SelfReplicating;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public abstract virtual void Invoke(Task completingTask);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
internal class System.Threading.Tasks.PaddingFor32 : ValueType {
}
internal static class System.Threading.Tasks.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
public static class System.Threading.Tasks.Parallel : object {
    internal static int DEFAULT_LOOP_STRIDE;
    internal static int s_forkJoinContextID;
    internal static ParallelOptions s_defaultParallelOptions;
    private static Parallel();
    public static void Invoke(Action[] actions);
    public static void Invoke(ParallelOptions parallelOptions, Action[] actions);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    internal static void ThrowIfReducableToSingleOCE(IEnumerable`1<Exception> excCollection, CancellationToken ct);
}
internal class System.Threading.Tasks.ParallelForReplicaTask : Task {
    internal object m_stateForNextReplica;
    internal object m_stateFromPreviousReplica;
    internal Task m_handedOverChildReplica;
    internal object SavedStateForNextReplica { get; internal set; }
    internal object SavedStateFromPreviousReplica { get; internal set; }
    internal Task HandedOverChildReplica { get; internal set; }
    internal ParallelForReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
    internal virtual object get_SavedStateForNextReplica();
    internal virtual void set_SavedStateForNextReplica(object value);
    internal virtual object get_SavedStateFromPreviousReplica();
    internal virtual void set_SavedStateFromPreviousReplica(object value);
    internal virtual Task get_HandedOverChildReplica();
    internal virtual void set_HandedOverChildReplica(Task value);
}
internal class System.Threading.Tasks.ParallelForReplicatingTask : Task {
    internal ParallelForReplicatingTask(ParallelOptions parallelOptions, Action action, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual bool ShouldReplicate();
    internal virtual Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
}
public class System.Threading.Tasks.ParallelLoopResult : ValueType {
    internal bool m_completed;
    internal Nullable`1<long> m_lowestBreakIteration;
    public bool IsCompleted { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    public bool get_IsCompleted();
    public Nullable`1<long> get_LowestBreakIteration();
}
[DebuggerDisplayAttribute("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")]
public class System.Threading.Tasks.ParallelLoopState : object {
    internal bool InternalShouldExitCurrentIteration { get; }
    public bool ShouldExitCurrentIteration { get; }
    public bool IsStopped { get; }
    public bool IsExceptional { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    internal ParallelLoopState(ParallelLoopStateFlags fbase);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    public bool get_ShouldExitCurrentIteration();
    public bool get_IsStopped();
    public bool get_IsExceptional();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    public Nullable`1<long> get_LowestBreakIteration();
    public void Stop();
    internal virtual void InternalBreak();
    public void Break();
    internal static void Break(int iteration, ParallelLoopStateFlags32 pflags);
    internal static void Break(long iteration, ParallelLoopStateFlags64 pflags);
}
internal class System.Threading.Tasks.ParallelLoopState32 : ParallelLoopState {
    internal int CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState32(ParallelLoopStateFlags32 sharedParallelStateFlags);
    internal int get_CurrentIteration();
    internal void set_CurrentIteration(int value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopState64 : ParallelLoopState {
    internal long CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState64(ParallelLoopStateFlags64 sharedParallelStateFlags);
    internal long get_CurrentIteration();
    internal void set_CurrentIteration(long value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags : object {
    internal static int PLS_NONE;
    internal static int PLS_EXCEPTIONAL;
    internal static int PLS_BROKEN;
    internal static int PLS_STOPPED;
    internal static int PLS_CANCELED;
    internal int LoopStateFlags { get; }
    private static ParallelLoopStateFlags();
    internal int get_LoopStateFlags();
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates);
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates, Int32& oldState);
    internal void SetExceptional();
    internal void Stop();
    internal bool Cancel();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags32 : ParallelLoopStateFlags {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lowestBreakIteration;
    internal int LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal int get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(int CallerIteration);
    internal bool ShouldExitLoop();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags64 : ParallelLoopStateFlags {
    internal long m_lowestBreakIteration;
    internal long LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal long get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(long CallerIteration);
    internal bool ShouldExitLoop();
}
public class System.Threading.Tasks.ParallelOptions : object {
    public TaskScheduler TaskScheduler { get; public set; }
    internal TaskScheduler EffectiveTaskScheduler { get; }
    public int MaxDegreeOfParallelism { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    internal int EffectiveMaxConcurrencyLevel { get; }
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
    internal TaskScheduler get_EffectiveTaskScheduler();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    internal int get_EffectiveMaxConcurrencyLevel();
}
internal class System.Threading.Tasks.RangeManager : object {
    internal IndexRange[] m_indexRanges;
    internal int m_nCurrentIndexRangeToAssign;
    internal long m_nStep;
    internal RangeManager(long nFromInclusive, long nToExclusive, long nStep, int nNumExpectedWorkers);
    internal RangeWorker RegisterNewWorker();
}
internal class System.Threading.Tasks.RangeWorker : ValueType {
    internal IndexRange[] m_indexRanges;
    internal int m_nCurrentIndexRange;
    internal long m_nStep;
    internal long m_nIncrementValue;
    internal long m_nMaxIncrementValue;
    internal RangeWorker(IndexRange[] ranges, int nInitialRange, long nStep);
    internal bool FindNewWork(Int64& nFromInclusiveLocal, Int64& nToExclusiveLocal);
    internal bool FindNewWork32(Int32& nFromInclusiveLocal32, Int32& nToExclusiveLocal32);
}
internal class System.Threading.Tasks.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    public sealed virtual bool TryDequeue(T& result);
    public bool TryPeek(T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
internal class System.Threading.Tasks.StackGuard : object {
    [SecuritySafeCriticalAttribute]
internal bool TryBeginInliningScope();
    internal void EndInliningScope();
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    [SecurityCriticalAttribute]
internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext, StackCrawlMark& stackMark);
    private static SynchronizationContextAwaitTaskContinuation();
    [SecuritySafeCriticalAttribute]
internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    [SecurityCriticalAttribute]
protected internal virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
public class System.Threading.Tasks.Task : object {
    internal static int TASK_STATE_STARTED;
    internal static int TASK_STATE_DELEGATE_INVOKED;
    internal static int TASK_STATE_DISPOSED;
    internal static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT;
    internal static int TASK_STATE_CANCELLATIONACKNOWLEDGED;
    internal static int TASK_STATE_FAULTED;
    internal static int TASK_STATE_CANCELED;
    internal static int TASK_STATE_WAITING_ON_CHILDREN;
    internal static int TASK_STATE_RAN_TO_COMPLETION;
    internal static int TASK_STATE_WAITINGFORACTIVATION;
    internal static int TASK_STATE_COMPLETION_RESERVED;
    internal static int TASK_STATE_THREAD_WAS_ABORTED;
    internal static int TASK_STATE_WAIT_COMPLETION_NOTIFICATION;
    internal static int TASK_STATE_EXECUTIONCONTEXT_IS_NULL;
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    internal static int s_taskIdCounter;
    internal object m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Task m_parent;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    internal ContingentProperties modreq(System.Runtime.CompilerServices.IsVolatile) m_contingentProperties;
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    internal static StackGuard CurrentStackGuard { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    internal bool IsRanToCompletion { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    internal static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool IsSelfReplicatingRoot { get; }
    internal bool IsChildReplica { get; }
    internal int ActiveChildCount { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal object SavedStateForNextReplica { get; internal set; }
    internal object SavedStateFromPreviousReplica { get; internal set; }
    internal Task HandedOverChildReplica { get; internal set; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Action`1<object> action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    internal void TaskConstructorCore(object action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    [SecuritySafeCriticalAttribute]
internal void PossiblyCaptureContext(StackCrawlMark& stackMark);
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    internal bool MarkStarted();
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    [SecuritySafeCriticalAttribute]
internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, StackCrawlMark& stackMark);
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    internal static StackGuard get_CurrentStackGuard();
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool get_IsCompleted();
    internal bool get_IsRanToCompletion();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    public static TaskFactory get_Factory();
    [FriendAccessAllowedAttribute]
internal static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_IsSelfReplicatingRoot();
    internal bool get_IsChildReplica();
    internal int get_ActiveChildCount();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool bUserDelegateExecuted);
    internal void FinishStageTwo();
    internal void FinishStageThree();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren();
    internal void FinishThreadAbortedTask(bool bTAEAddedToExceptionHolder, bool delegateRan);
    internal virtual bool ShouldReplicate();
    internal virtual Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
    internal virtual object get_SavedStateForNextReplica();
    internal virtual void set_SavedStateForNextReplica(object value);
    internal virtual object get_SavedStateFromPreviousReplica();
    internal virtual void set_SavedStateFromPreviousReplica(object value);
    internal virtual Task get_HandedOverChildReplica();
    internal virtual void set_HandedOverChildReplica(Task value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    [SecuritySafeCriticalAttribute]
internal bool ExecuteEntry(bool bPreventDoubleExecution);
    internal virtual void InnerInvoke();
    internal void InnerInvokeWithArg(Task childTask);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TaskAwaiter GetAwaiter();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    [SecurityCriticalAttribute]
internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext, StackCrawlMark& stackMark);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    [SecuritySafeCriticalAttribute]
internal void FinishContinuations();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void FastWaitAll(Task[] tasks);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    [FriendAccessAllowedAttribute]
internal static Task FromException(Exception exception);
    [FriendAccessAllowedAttribute]
internal static Task`1<TResult> FromException(Exception exception);
    [FriendAccessAllowedAttribute]
internal static Task FromCancellation(CancellationToken cancellationToken);
    [FriendAccessAllowedAttribute]
internal static Task`1<TResult> FromCancellation(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    [FriendAccessAllowedAttribute]
internal static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
}
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
public class System.Threading.Tasks.Task`1 : Task {
    internal TResult m_result;
    internal static Func`2<Task`1<Task>, Task`1<TResult>> TaskWhenAnyCast;
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Func`2<object, TResult> valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TResult get_Result();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    internal bool TrySetException(object exceptionObject);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TaskAwaiter`1<TResult> GetAwaiter();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark);
}
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    internal bool TrySetException(IEnumerable`1<ExceptionDispatchInfo> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    [SecuritySafeCriticalAttribute]
protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    private static TaskExceptionHolder();
    protected virtual void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject);
    internal void Add(object exceptionObject, bool representsCancellation);
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
public class System.Threading.Tasks.TaskFactory : object {
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark& stackMark);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark);
}
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    internal static int s_taskSchedulerIdCounter;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    [SecurityCriticalAttribute]
protected internal abstract virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    [SecuritySafeCriticalAttribute]
internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    [SecurityCriticalAttribute]
protected bool TryExecuteTask(Task task);
    [SecurityCriticalAttribute]
public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    [SecurityCriticalAttribute]
internal Task[] GetScheduledTasksForDebugger();
    [SecurityCriticalAttribute]
internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    [SecurityCriticalAttribute]
internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext, StackCrawlMark& stackMark);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    [SecurityCriticalAttribute]
protected internal virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected internal virtual bool TryDequeue(Task task);
    [SecurityCriticalAttribute]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
[EventSourceAttribute]
internal class System.Threading.Tasks.TplEtwProvider : EventSource {
    public static TplEtwProvider Log;
    private static TplEtwProvider();
    [SecuritySafeCriticalAttribute]
[EventAttribute("1")]
public void ParallelLoopBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, ForkJoinOperationType OperationType, long InclusiveFrom, long ExclusiveTo);
    [SecuritySafeCriticalAttribute]
[EventAttribute("2")]
public void ParallelLoopEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, long TotalIterations);
    [SecuritySafeCriticalAttribute]
[EventAttribute("3")]
public void ParallelInvokeBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, ForkJoinOperationType OperationType, int ActionCount);
    [EventAttribute("4")]
public void ParallelInvokeEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
    [EventAttribute("5")]
public void ParallelFork(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
    [EventAttribute("6")]
public void ParallelJoin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
    [SecuritySafeCriticalAttribute]
[EventAttribute("7")]
public void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
    [EventAttribute("8")]
public void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [SecuritySafeCriticalAttribute]
[EventAttribute("9")]
public void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
    [SecuritySafeCriticalAttribute]
[EventAttribute("10")]
public void TaskWaitBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, TaskWaitBehavior Behavior);
    [EventAttribute("11")]
public void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Thread")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Threading.Thread : CriticalFinalizerObject {
    public int ManagedThreadId { get; }
    internal bool ExecutionContextBelongsToCurrentScope { get; internal set; }
    public ExecutionContext ExecutionContext { get; }
    public ThreadPriority Priority { get; public set; }
    public bool IsAlive { get; }
    public bool IsThreadPoolThread { get; }
    public static Thread CurrentThread { get; }
    public bool IsBackground { get; public set; }
    public ThreadState ThreadState { get; }
    [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", "False")]
public ApartmentState ApartmentState { get; public set; }
    public CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public static Context CurrentContext { get; }
    public static IPrincipal CurrentPrincipal { get; public set; }
    public string Name { get; public set; }
    internal object AbortReason { get; internal set; }
    [SecuritySafeCriticalAttribute]
public Thread(ThreadStart start);
    [SecuritySafeCriticalAttribute]
public Thread(ThreadStart start, int maxStackSize);
    [SecuritySafeCriticalAttribute]
public Thread(ParameterizedThreadStart start);
    [SecuritySafeCriticalAttribute]
public Thread(ParameterizedThreadStart start, int maxStackSize);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public int get_ManagedThreadId();
    internal ThreadHandle GetNativeHandle();
    public void Start();
    public void Start(object parameter);
    [ReliabilityContractAttribute("3", "2")]
internal Reader GetExecutionContextReader();
    internal bool get_ExecutionContextBelongsToCurrentScope();
    internal void set_ExecutionContextBelongsToCurrentScope(bool value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public ExecutionContext get_ExecutionContext();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
internal ExecutionContext GetMutableExecutionContext();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal void SetExecutionContext(ExecutionContext value, bool belongsToCurrentScope);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal void SetExecutionContext(Reader value, bool belongsToCurrentScope);
    [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
[SecurityCriticalAttribute]
public void SetCompressedStack(CompressedStack stack);
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
internal IntPtr SetAppDomainStack(SafeCompressedStackHandle csHandle);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal void RestoreAppDomainStack(IntPtr appDomainStack);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public CompressedStack GetCompressedStack();
    [ForceTokenStabilizationAttribute]
[SecurityCriticalAttribute]
internal static IntPtr InternalGetCurrentThread();
    [SecuritySafeCriticalAttribute]
public void Abort(object stateInfo);
    [SecuritySafeCriticalAttribute]
public void Abort();
    [SecuritySafeCriticalAttribute]
public static void ResetAbort();
    [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[SecuritySafeCriticalAttribute]
public void Suspend();
    [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[SecuritySafeCriticalAttribute]
public void Resume();
    [SecuritySafeCriticalAttribute]
public void Interrupt();
    [SecuritySafeCriticalAttribute]
public ThreadPriority get_Priority();
    [SecuritySafeCriticalAttribute]
public void set_Priority(ThreadPriority value);
    [SecuritySafeCriticalAttribute]
public bool get_IsAlive();
    [SecuritySafeCriticalAttribute]
public bool get_IsThreadPoolThread();
    [SecuritySafeCriticalAttribute]
public void Join();
    [SecuritySafeCriticalAttribute]
public bool Join(int millisecondsTimeout);
    public bool Join(TimeSpan timeout);
    [SecuritySafeCriticalAttribute]
public static void Sleep(int millisecondsTimeout);
    public static void Sleep(TimeSpan timeout);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static void SpinWait(int iterations);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static bool Yield();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "1")]
public static Thread get_CurrentThread();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public void DisableComObjectEagerCleanup();
    [SecuritySafeCriticalAttribute]
public bool get_IsBackground();
    [SecuritySafeCriticalAttribute]
public void set_IsBackground(bool value);
    [SecuritySafeCriticalAttribute]
public ThreadState get_ThreadState();
    [SecuritySafeCriticalAttribute]
public ApartmentState get_ApartmentState();
    [SecuritySafeCriticalAttribute]
public void set_ApartmentState(ApartmentState value);
    [SecuritySafeCriticalAttribute]
public ApartmentState GetApartmentState();
    [SecuritySafeCriticalAttribute]
public bool TrySetApartmentState(ApartmentState state);
    [SecuritySafeCriticalAttribute]
public void SetApartmentState(ApartmentState state);
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public static void FreeNamedDataSlot(string name);
    public static object GetData(LocalDataStoreSlot slot);
    public static void SetData(LocalDataStoreSlot slot, object data);
    public CultureInfo get_CurrentUICulture();
    [SecuritySafeCriticalAttribute]
public void set_CurrentUICulture(CultureInfo value);
    [SecuritySafeCriticalAttribute]
internal CultureInfo GetCurrentUICultureNoAppX();
    public CultureInfo get_CurrentCulture();
    [SecuritySafeCriticalAttribute]
public void set_CurrentCulture(CultureInfo value);
    [SecurityCriticalAttribute]
public static Context get_CurrentContext();
    [SecurityCriticalAttribute]
internal Context GetCurrentContextInternal();
    [SecuritySafeCriticalAttribute]
public static IPrincipal get_CurrentPrincipal();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void set_CurrentPrincipal(IPrincipal value);
    [SecurityCriticalAttribute]
internal static Context GetContextInternal(IntPtr id);
    [SecurityCriticalAttribute]
internal object InternalCrossContextCallback(Context ctx, IntPtr ctxID, int appDomainID, InternalCrossContextDelegate ftnToCall, Object[] args);
    [SecurityCriticalAttribute]
internal object InternalCrossContextCallback(Context ctx, InternalCrossContextDelegate ftnToCall, Object[] args);
    [SecuritySafeCriticalAttribute]
public static AppDomain GetDomain();
    public static int GetDomainID();
    public string get_Name();
    [SecuritySafeCriticalAttribute]
public void set_Name(string value);
    [SecurityCriticalAttribute]
internal object get_AbortReason();
    [SecurityCriticalAttribute]
internal void set_AbortReason(object value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void BeginCriticalRegion();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void EndCriticalRegion();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void BeginThreadAffinity();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public static void EndThreadAffinity();
    public static byte VolatileRead(Byte& address);
    public static short VolatileRead(Int16& address);
    public static int VolatileRead(Int32& address);
    public static long VolatileRead(Int64& address);
    [CLSCompliantAttribute("False")]
public static sbyte VolatileRead(SByte& address);
    [CLSCompliantAttribute("False")]
public static ushort VolatileRead(UInt16& address);
    [CLSCompliantAttribute("False")]
public static UInt32 VolatileRead(UInt32& address);
    public static IntPtr VolatileRead(IntPtr& address);
    [CLSCompliantAttribute("False")]
public static UIntPtr VolatileRead(UIntPtr& address);
    [CLSCompliantAttribute("False")]
public static ulong VolatileRead(UInt64& address);
    public static float VolatileRead(Single& address);
    public static double VolatileRead(Double& address);
    public static object VolatileRead(Object& address);
    public static void VolatileWrite(Byte& address, byte value);
    public static void VolatileWrite(Int16& address, short value);
    public static void VolatileWrite(Int32& address, int value);
    public static void VolatileWrite(Int64& address, long value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(SByte& address, sbyte value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt16& address, ushort value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt32& address, UInt32 value);
    public static void VolatileWrite(IntPtr& address, IntPtr value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UIntPtr& address, UIntPtr value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt64& address, ulong value);
    public static void VolatileWrite(Single& address, float value);
    public static void VolatileWrite(Double& address, double value);
    public static void VolatileWrite(Object& address, object value);
    [SecuritySafeCriticalAttribute]
public static void MemoryBarrier();
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Thread.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    [SecurityCriticalAttribute]
internal void SetAbortReason(object o);
    [SecurityCriticalAttribute]
internal object GetAbortReason();
    [SecurityCriticalAttribute]
internal void ClearAbortReason();
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public object get_ExceptionState();
}
internal class System.Threading.ThreadHandle : ValueType {
    private IntPtr m_ptr;
    internal ThreadHandle(IntPtr pThread);
}
internal class System.Threading.ThreadHelper : object {
    [SecurityCriticalAttribute]
internal static ContextCallback _ccb;
    [SecuritySafeCriticalAttribute]
private static ThreadHelper();
    internal ThreadHelper(Delegate start);
    internal void SetExecutionContextHelper(ExecutionContext ec);
    [SecurityCriticalAttribute]
internal void ThreadStart(object obj);
    [SecurityCriticalAttribute]
internal void ThreadStart();
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    public IList`1<T> get_Values();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
}
public static class System.Threading.ThreadPool : object {
    [SecuritySafeCriticalAttribute]
public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    [SecuritySafeCriticalAttribute]
public static bool QueueUserWorkItem(WaitCallback callBack);
    [SecurityCriticalAttribute]
public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    [SecurityCriticalAttribute]
internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
    [SecurityCriticalAttribute]
internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems();
    internal static IEnumerable`1<IThreadPoolWorkItem> EnumerateQueuedWorkItems(WorkStealingQueue[] wsQueues, QueueSegment globalQueueTail);
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
    [SecurityCriticalAttribute]
internal static Object[] GetQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool RequestWorkerThread();
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    [SecurityCriticalAttribute]
internal static bool NotifyWorkItemComplete();
    [SecurityCriticalAttribute]
internal static void ReportThreadStatus(bool isWorking);
    [SecuritySafeCriticalAttribute]
internal static void NotifyWorkItemProgress();
    [SecurityCriticalAttribute]
internal static void NotifyWorkItemProgressNative();
    [SecurityCriticalAttribute]
internal static bool IsThreadPoolHosted();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    [SecuritySafeCriticalAttribute]
public static bool BindHandle(SafeHandle osHandle);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static UInt32 tpQuantum;
    public static int processorCount;
    public static bool tpHosted;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) vmTpInitialized;
    public static bool enableWorkerTracking;
    [SecurityCriticalAttribute]
public static ThreadPoolWorkQueue workQueue;
    [SecuritySafeCriticalAttribute]
private static ThreadPoolGlobals();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueHead;
    internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueTail;
    internal bool loggingEnabled;
    internal static SparseArray`1<WorkStealingQueue> allThreadQueues;
    private static ThreadPoolWorkQueue();
    [SecurityCriticalAttribute]
public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
    [SecurityCriticalAttribute]
internal void EnsureThreadRequested();
    [SecurityCriticalAttribute]
internal void MarkThreadRequestSatisfied();
    [SecurityCriticalAttribute]
public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
    [SecurityCriticalAttribute]
internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
    [SecurityCriticalAttribute]
public void Dequeue(ThreadPoolWorkQueueThreadLocals tl, IThreadPoolWorkItem& callback, Boolean& missedSteal);
    [SecurityCriticalAttribute]
internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [SecurityCriticalAttribute]
[ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public Random random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
}
[ComVisibleAttribute("True")]
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public static class System.Threading.Timeout : object {
    public static int Infinite;
    internal static UInt32 UnsignedInfinite;
    [ComVisibleAttribute("False")]
public static TimeSpan InfiniteTimeSpan;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
[ComVisibleAttribute("True")]
public class System.Threading.Timer : MarshalByRefObject {
    [SecuritySafeCriticalAttribute]
public Timer(TimerCallback callback, object state, int dueTime, int period);
    [SecuritySafeCriticalAttribute]
public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    [SecuritySafeCriticalAttribute]
public Timer(TimerCallback callback, object state, long dueTime, long period);
    [SecuritySafeCriticalAttribute]
public Timer(TimerCallback callback);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
    internal void KeepRootedWhileScheduled();
}
[ComVisibleAttribute("True")]
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer m_timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual void Finalize();
    public void Close();
    public bool Close(WaitHandle notifyObject);
}
internal class System.Threading.TimerQueue : object {
    public static TimerQueue Instance { get; }
    private static TimerQueue();
    public static TimerQueue get_Instance();
    [SecuritySafeCriticalAttribute]
internal static void AppDomainTimerCallback();
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void DeleteTimer(TimerQueueTimer timer);
}
internal class System.Threading.TimerQueueTimer : object {
    internal TimerQueueTimer m_next;
    internal TimerQueueTimer m_prev;
    internal int m_startTicks;
    internal UInt32 m_dueTime;
    internal UInt32 m_period;
    [SecurityCriticalAttribute]
internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period, StackCrawlMark& stackMark);
    internal bool Change(UInt32 dueTime, UInt32 period);
    public void Close();
    public bool Close(WaitHandle toSignal);
    internal void Fire();
    [SecuritySafeCriticalAttribute]
internal void SignalNoCallbacksRunning();
    [SecuritySafeCriticalAttribute]
internal void CallCallback();
}
public static class System.Threading.Volatile : object {
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static bool Read(Boolean& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
public static sbyte Read(SByte& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static byte Read(Byte& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static short Read(Int16& location);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static ushort Read(UInt16& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int Read(Int32& location);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static UInt32 Read(UInt32& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static long Read(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static ulong Read(UInt64& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static IntPtr Read(IntPtr& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
public static UIntPtr Read(UIntPtr& location);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static float Read(Single& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static double Read(Double& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[SecuritySafeCriticalAttribute]
public static T Read(T& location);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(Boolean& location, bool value);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(SByte& location, sbyte value);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(Byte& location, byte value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static void Write(Int16& location, short value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
public static void Write(UInt16& location, ushort value);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(Int32& location, int value);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(UInt32& location, UInt32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static void Write(Int64& location, long value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void Write(UInt64& location, ulong value);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(IntPtr& location, IntPtr value);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(UIntPtr& location, UIntPtr value);
    [ReliabilityContractAttribute("3", "2")]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(Single& location, float value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
[ReliabilityContractAttribute("3", "2")]
public static void Write(Double& location, double value);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static void Write(T& location, T value);
}
[ComVisibleAttribute("True")]
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.WaitDelegate : MulticastDelegate {
    public WaitDelegate(object object, IntPtr method);
    public virtual int Invoke(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public virtual IAsyncResult BeginInvoke(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    public static int WaitTimeout;
    [SecurityCriticalAttribute]
internal SafeWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) safeWaitHandle;
    internal bool hasThreadAffinity;
    protected static IntPtr InvalidHandle;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    [SecuritySafeCriticalAttribute]
public virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
public virtual void set_Handle(IntPtr value);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public SafeWaitHandle get_SafeWaitHandle();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void set_SafeWaitHandle(SafeWaitHandle value);
    [SecurityCriticalAttribute]
internal void SetHandleInternal(SafeWaitHandle handle);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
    [SecurityCriticalAttribute]
internal static bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    [SecuritySafeCriticalAttribute]
public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    [SecuritySafeCriticalAttribute]
public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    public virtual void Close();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("False")]
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal class System.Threading.WinRTSynchronizationContextFactoryBase : object {
    [SecurityCriticalAttribute]
public virtual SynchronizationContext Create(object coreDispatcher);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
internal static class System.ThrowHelper : object {
    internal static void ThrowArgumentOutOfRangeException();
    internal static void ThrowWrongKeyTypeArgumentException(object key, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
    internal static void ThrowKeyNotFoundException();
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowSecurityException(ExceptionResource resource);
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    internal static void ThrowUnauthorizedAccessException(ExceptionResource resource);
    internal static void ThrowObjectDisposedException(string objectName, ExceptionResource resource);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    internal static string GetArgumentName(ExceptionArgument argument);
    internal static string GetResourceName(ExceptionResource resource);
}
[ComVisibleAttribute("True")]
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    private static double MillisecondsPerTick;
    public static long TicksPerSecond;
    private static double SecondsPerTick;
    public static long TicksPerMinute;
    private static double MinutesPerTick;
    public static long TicksPerHour;
    private static double HoursPerTick;
    public static long TicksPerDay;
    private static double DaysPerTick;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static long TicksPerTenthSecond;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[ComVisibleAttribute("True")]
public abstract class System.TimeZone : object {
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static TimeZone();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneInfo : object {
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private static TimeZoneInfo();
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public AdjustmentRule[] GetAdjustmentRules();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public class System.Tuple`1 : object {
    public T1 Item1 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`2 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`3 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`4 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`5 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`6 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`7 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`8 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.ITuple.Size { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Type")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public abstract class System.Type : MemberInfo {
    internal static BindingFlags DeclaredOnlyLookup;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public static object Missing;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public Guid GUID { get; }
    public static Binder DefaultBinder { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    [ComVisibleAttribute("True")]
public ConstructorInfo TypeInitializer { get; }
    public bool IsNested { get; }
    public TypeAttributes Attributes { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsVisible { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsAutoLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsExplicitLayout { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsEnum { get; }
    public bool IsSpecialName { get; }
    public bool IsImport { get; }
    public bool IsSerializable { get; }
    public bool IsAnsiClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsAutoClass { get; }
    public bool IsArray { get; }
    internal bool IsSzArray { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsCOMObject { get; }
    internal bool IsWindowsRuntimeObject { get; }
    internal bool IsExportedToWindowsRuntime { get; }
    public bool HasElementType { get; }
    public bool IsContextful { get; }
    public bool IsMarshalByRef { get; }
    internal bool HasProxyAttribute { get; }
    public Type[] GenericTypeArguments { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    internal bool NeedsReflectionSecurityCheck { get; }
    public Type UnderlyingSystemType { get; }
    private static Type();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_ReflectedType();
    public sealed virtual Type GetType();
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public virtual Type MakePointerType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, bool throwOnError);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, string server);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, string server);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Binder get_DefaultBinder();
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    public abstract virtual Module get_Module();
    public abstract virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    internal virtual RuntimeTypeHandle GetTypeHandleInternal();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    [SecurityCriticalAttribute]
internal static RuntimeType GetTypeFromHandleUnsafe(IntPtr handle);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    public abstract virtual string get_FullName();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public virtual int GetArrayRank();
    public abstract virtual Type get_BaseType();
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(Type[] types);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo[] GetConstructors();
    [ComVisibleAttribute("True")]
public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual ConstructorInfo get_TypeInitializer();
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, Type[] types);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public sealed virtual MethodInfo GetMethod(string name);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name);
    public sealed virtual FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public sealed virtual PropertyInfo GetProperty(string name, Type[] types);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType);
    internal PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Type returnType);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual PropertyInfo GetProperty(string name);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties();
    public sealed virtual Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsNested();
    public sealed virtual TypeAttributes get_Attributes();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public bool get_IsVisible();
    public sealed virtual bool get_IsNotPublic();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool get_IsPublic();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamANDAssem();
    public sealed virtual bool get_IsNestedFamORAssem();
    public sealed virtual bool get_IsAutoLayout();
    public sealed virtual bool get_IsLayoutSequential();
    public sealed virtual bool get_IsExplicitLayout();
    public sealed virtual bool get_IsClass();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsValueType();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool get_IsEnum();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsImport();
    public virtual bool get_IsSerializable();
    public sealed virtual bool get_IsAnsiClass();
    public sealed virtual bool get_IsUnicodeClass();
    public sealed virtual bool get_IsAutoClass();
    public sealed virtual bool get_IsArray();
    internal virtual bool get_IsSzArray();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    public sealed virtual bool get_IsByRef();
    public sealed virtual bool get_IsPointer();
    public sealed virtual bool get_IsPrimitive();
    public sealed virtual bool get_IsCOMObject();
    internal bool get_IsWindowsRuntimeObject();
    internal bool get_IsExportedToWindowsRuntime();
    public sealed virtual bool get_HasElementType();
    public sealed virtual bool get_IsContextful();
    public sealed virtual bool get_IsMarshalByRef();
    internal bool get_HasProxyAttribute();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
protected virtual bool IsValueTypeImpl();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    protected abstract virtual bool IsPrimitiveImpl();
    protected abstract virtual bool IsCOMObjectImpl();
    internal virtual bool IsWindowsRuntimeObjectImpl();
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    public virtual Type MakeGenericType(Type[] typeArguments);
    protected virtual bool IsContextfulImpl();
    protected virtual bool IsMarshalByRefImpl();
    internal virtual bool HasProxyAttributeImpl();
    public abstract virtual Type GetElementType();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type GetGenericTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
internal Type GetRootElementType();
    public virtual String[] GetEnumNames();
    public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    internal bool get_NeedsReflectionSecurityCheck();
    public abstract virtual Type get_UnderlyingSystemType();
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsEquivalentTo(Type other);
    internal bool ImplementInterface(Type ifaceType);
    internal string FormatTypeName();
    internal virtual string FormatTypeName(bool serialization);
    public virtual string ToString();
    public static Type[] GetTypeArray(Object[] args);
    public virtual bool Equals(object o);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(Type o);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(Type left, Type right);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(Type left, Type right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    private sealed virtual override void System.Runtime.InteropServices._Type.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Type.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Type.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private IntPtr Value;
    private IntPtr Type;
    internal bool IsNull { get; }
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    [SecuritySafeCriticalAttribute]
public static object ToObject(TypedReference value);
    [SecurityCriticalAttribute]
internal static object InternalToObject(Void* value);
    internal bool get_IsNull();
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
    [SecurityCriticalAttribute]
internal static void InternalSetTypedReference(Void* target, object value);
}
[ComVisibleAttribute("True")]
public class System.TypeInitializationException : SystemException {
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.TypeLoadException : SystemException {
    internal int ResourceId;
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
    public string get_TypeName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum System.TypeNameFormatFlags : Enum {
    public int value__;
    public static TypeNameFormatFlags FormatBasic;
    public static TypeNameFormatFlags FormatNamespace;
    public static TypeNameFormatFlags FormatFullInst;
    public static TypeNameFormatFlags FormatAssembly;
    public static TypeNameFormatFlags FormatSignature;
    public static TypeNameFormatFlags FormatNoVersion;
    public static TypeNameFormatFlags FormatAngleBrackets;
    public static TypeNameFormatFlags FormatStubInfo;
    public static TypeNameFormatFlags FormatGenericParam;
    public static TypeNameFormatFlags FormatSerialization;
}
internal enum System.TypeNameKind : Enum {
    public int value__;
    public static TypeNameKind Name;
    public static TypeNameKind ToString;
    public static TypeNameKind SerializationName;
    public static TypeNameKind FullName;
}
internal class System.TypeNameParser : object {
    private static TypeNameParser();
    [SecuritySafeCriticalAttribute]
internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    public static ushort MaxValue;
    public static ushort MinValue;
    private ushort m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.UInt32 : ValueType {
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    private UInt32 m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt32 obj);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
[TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.UInt64 : ValueType {
    public static ulong MaxValue;
    public static ulong MinValue;
    private ulong m_value;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.UIntPtr : ValueType {
    [SecurityCriticalAttribute]
private Void* m_value;
    public static UIntPtr Zero;
    public static int Size { get; }
    [SecuritySafeCriticalAttribute]
public UIntPtr(UInt32 value);
    [SecuritySafeCriticalAttribute]
public UIntPtr(ulong value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public UIntPtr(Void* value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public UInt32 ToUInt32();
    [SecuritySafeCriticalAttribute]
public ulong ToUInt64();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public static UIntPtr op_Explicit(UInt32 value);
    public static UIntPtr op_Explicit(ulong value);
    [SecuritySafeCriticalAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [SecuritySafeCriticalAttribute]
public static ulong op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static UIntPtr op_Explicit(Void* value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static Void* op_Explicit(UIntPtr value);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    public static int get_Size();
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public Void* ToPointer();
}
[ComVisibleAttribute("True")]
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.UnhandledExceptionEventArgs : EventArgs {
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    [ReliabilityContractAttribute("3", "2")]
public object get_ExceptionObject();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsTerminating();
}
[ComVisibleAttribute("True")]
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.UnitySerializationHolder : object {
    internal static int EmptyUnity;
    internal static int NullUnity;
    internal static int MissingUnity;
    internal static int RuntimeTypeUnity;
    internal static int ModuleUnity;
    internal static int AssemblyUnity;
    internal static int GenericParameterTypeUnity;
    internal static int PartialInstantiationTypeUnity;
    internal static int Pointer;
    internal static int Array;
    internal static int SzArray;
    internal static int ByRef;
    internal UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, Missing missing);
    internal static RuntimeType AddElementTypes(SerializationInfo info, RuntimeType type);
    internal Type MakeElementTypes(Type type);
    internal static void GetUnitySerializationInfo(SerializationInfo info, RuntimeType type);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType, string data, RuntimeAssembly assembly);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
}
internal class System.UnSafeCharBuffer : ValueType {
    [SecurityCriticalAttribute]
private Char* m_buffer;
    private int m_totalSize;
    private int m_length;
    public int Length { get; }
    [SecurityCriticalAttribute]
public UnSafeCharBuffer(Char* buffer, int bufferSize);
    [SecuritySafeCriticalAttribute]
public void AppendString(string stringToAppend);
    public int get_Length();
}
internal class System.Utf8String : ValueType {
    [SecurityCriticalAttribute]
private Void* m_pStringHeap;
    private int m_StringHeapByteLength;
    [SecurityCriticalAttribute]
internal Utf8String(Void* pStringHeap);
    [SecurityCriticalAttribute]
internal Utf8String(Void* pUtf8String, int cUtf8String);
    [SecuritySafeCriticalAttribute]
internal bool Equals(Utf8String s);
    [SecuritySafeCriticalAttribute]
internal bool EqualsCaseInsensitive(Utf8String s);
    [SecuritySafeCriticalAttribute]
internal UInt32 HashCaseInsensitive();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public abstract class System.ValueType : object {
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    internal static int GetHashCodeOfPtr(IntPtr ptr);
    public virtual string ToString();
}
internal class System.Variant : ValueType {
    internal static int CV_EMPTY;
    internal static int CV_VOID;
    internal static int CV_BOOLEAN;
    internal static int CV_CHAR;
    internal static int CV_I1;
    internal static int CV_U1;
    internal static int CV_I2;
    internal static int CV_U2;
    internal static int CV_I4;
    internal static int CV_U4;
    internal static int CV_I8;
    internal static int CV_U8;
    internal static int CV_R4;
    internal static int CV_R8;
    internal static int CV_STRING;
    internal static int CV_PTR;
    internal static int CV_DATETIME;
    internal static int CV_TIMESPAN;
    internal static int CV_OBJECT;
    internal static int CV_DECIMAL;
    internal static int CV_ENUM;
    internal static int CV_MISSING;
    internal static int CV_NULL;
    internal static int CV_LAST;
    internal static int TypeCodeBitMask;
    internal static int VTBitMask;
    internal static int VTBitShift;
    internal static int ArrayBitMask;
    internal static int EnumI1;
    internal static int EnumU1;
    internal static int EnumI2;
    internal static int EnumU2;
    internal static int EnumI4;
    internal static int EnumU4;
    internal static int EnumI8;
    internal static int EnumU8;
    internal static int EnumMask;
    private object m_objref;
    private int m_data1;
    private int m_data2;
    private int m_flags;
    internal static Type[] ClassTypes;
    internal static Variant Empty;
    internal static Variant Missing;
    internal static Variant DBNull;
    internal int CVType { get; }
    internal Variant(int flags, object or, int data1, int data2);
    public Variant(bool val);
    public Variant(sbyte val);
    public Variant(byte val);
    public Variant(short val);
    public Variant(ushort val);
    public Variant(char val);
    public Variant(int val);
    public Variant(UInt32 val);
    public Variant(long val);
    public Variant(ulong val);
    [SecuritySafeCriticalAttribute]
public Variant(float val);
    [SecurityCriticalAttribute]
public Variant(double val);
    public Variant(DateTime val);
    public Variant(decimal val);
    [SecuritySafeCriticalAttribute]
public Variant(object obj);
    [SecurityCriticalAttribute]
public Variant(Void* voidPointer, Type pointerType);
    private static Variant();
    [SecurityCriticalAttribute]
internal double GetR8FromVar();
    [SecurityCriticalAttribute]
internal float GetR4FromVar();
    [SecurityCriticalAttribute]
internal void SetFieldsR4(float val);
    [SecurityCriticalAttribute]
internal void SetFieldsR8(double val);
    [SecurityCriticalAttribute]
internal void SetFieldsObject(object val);
    internal long GetI8FromVar();
    internal int get_CVType();
    [SecuritySafeCriticalAttribute]
public object ToObject();
    [SecuritySafeCriticalAttribute]
internal static void MarshalHelperConvertObjectToVariant(object o, Variant& v);
    internal static object MarshalHelperConvertVariantToObject(Variant& v);
    [SecurityCriticalAttribute]
internal static void MarshalHelperCastVariant(object pValue, int vt, Variant& v);
}
[ComVisibleAttribute("True")]
public class System.Version : object {
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    public Version(string version);
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int fieldCount);
    public static Version Parse(string input);
    public static bool TryParse(string input, Version& result);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
[ComVisibleAttribute("True")]
public class System.Void : ValueType {
}
[ComVisibleAttribute("True")]
public class System.WeakReference : object {
    internal IntPtr m_handle;
    public bool IsAlive { get; }
    public bool TrackResurrection { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsAlive();
    public virtual bool get_TrackResurrection();
    [SecuritySafeCriticalAttribute]
public virtual object get_Target();
    [SecuritySafeCriticalAttribute]
public virtual void set_Target(object value);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.WeakReference`1 : object {
    internal IntPtr m_handle;
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    internal WeakReference`1(SerializationInfo info, StreamingContext context);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool TryGetTarget(T& target);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void SetTarget(T target);
    [SecuritySafeCriticalAttribute]
protected virtual void Finalize();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("384")]
internal class System.XmlIgnoreMemberAttribute : Attribute {
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
