internal static class FXAssembly : object {
    internal static string Version;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    internal IEqualityComparer`1<K> get_Comparer();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : EqualityComparer`1<string> {
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    internal static MSBuildNameIgnoreCaseComparer Mutable { get; }
    private static MSBuildNameIgnoreCaseComparer();
    internal static MSBuildNameIgnoreCaseComparer get_Default();
    internal static MSBuildNameIgnoreCaseComparer get_Mutable();
    public static bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public T GetValueWithConstraints(IDictionary`2<string, T> dictionary, string key, int startIndex, int endIndex);
    public sealed virtual bool Equals(IKeyed x, IKeyed y);
    public virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(IKeyed keyed);
    public virtual int GetHashCode(string obj);
    internal void SetConstraintsForUnitTestingOnly(string constraintString, int startIndex, int endIndex);
    internal void RemoveConstraintsForUnitTestingOnly();
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__1")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = 0")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyList`1 : object {
    public static ReadOnlyEmptyList`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    public static ReadOnlyEmptyList`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyList`1/<GetEnumerator>d__1")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal class Microsoft.Build.Shared.AssemblyFoldersEx : object {
    internal AssemblyFoldersEx(string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, ProcessorArchitecture targetProcessorArchitecture, OpenBaseKey openBaseKey);
    internal static List`1<ExtensionFoldersRegistryKey> GatherVersionStrings(string targetRuntimeVersion, IEnumerable versions);
    private sealed virtual override IEnumerator`1<AssemblyFoldersExInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersExInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    internal static ResourceManager get_PrimaryResources();
    internal static ResourceManager get_SharedResources();
    internal static string FormatString(string unformatted, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static CanonicalError();
    internal static Parts Parse(string message);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    internal static Encoding CurrentSystemOemEncoding { get; }
    internal static Encoding get_CurrentSystemOemEncoding();
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string Escape(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static EventArgsFormatting();
    internal static string EscapeCarriageReturn(string stringWithCarriageReturn);
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool removeCarriageReturn);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool removeCarriageReturn, bool showProjectFile);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    internal string RegistryKey { get; private set; }
    internal Version ComponentVersion { get; private set; }
    internal Version TargetFrameworkVersion { get; private set; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    internal ExtensionFoldersRegistryKey(string registryKey, Version componentVersion, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
private void set_RegistryKey(string value);
    [CompilerGeneratedAttribute]
internal Version get_ComponentVersion();
    [CompilerGeneratedAttribute]
private void set_ComponentVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworkVersion(Version value);
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.FileMatcher : object {
    internal static Char[] directorySeparatorCharacters;
    private static FileMatcher();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal static void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, GetFileSystemEntries getFileSystemEntries);
    internal static bool IsDirectorySeparator(char c);
    internal static void RemoveProjectDirectory(String[] paths, string projectDirectory);
    internal static void GetFileSpecInfo(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    internal static Result FileMatch(string filespec, string fileToMatch);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, GetFileSystemEntries getFileSystemEntries, DirectoryExists directoryExists);
}
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static int MaxPath;
    internal static string cacheDirectory;
    internal static string FileTimeFormat;
    internal static string ExecutingAssemblyPath { get; }
    internal static string CurrentExecutableName { get; }
    internal static string CurrentExecutablePath { get; }
    internal static string CurrentExecutableDirectory { get; }
    internal static string CurrentExecutableConfigurationFilePath { get; }
    private static FileUtilities();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string get_CurrentExecutableName();
    internal static string get_CurrentExecutablePath();
    internal static string get_CurrentExecutableDirectory();
    internal static string get_CurrentExecutableConfigurationFilePath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive);
    internal static bool IsRootedNoThrow(string path);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath);
    internal static bool FileExistsNoThrow(string fullPath);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string fullDotNetFrameworkRegistryKey;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string fullDotNetFrameworkSdkRegistryKeyV40OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV40OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV40OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV40OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    internal static string fullDotNetFrameworkSdkRegistryKeyV45OnVS10;
    internal static string dotNetFrameworkSdkInstallKeyValueV45OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV45OnVS11;
    internal static string dotNetFrameworkSdkInstallKeyValueV45OnVS11;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    internal static string PathToDotNetFrameworkSdkV35ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV35ToolsOnVS11 { get; }
    internal static string PathToDotNetFrameworkSdkV40ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV40ToolsOnVS11 { get; }
    internal static string PathToDotNetFrameworkSdkV45ToolsOnVS10 { get; }
    internal static string PathToDotNetFrameworkSdkV45ToolsOnVS11 { get; }
    internal static string PathToWindowsSdkV45OnVS10 { get; }
    internal static string PathToWindowsSdkV45OnVS11 { get; }
    internal static string PathToDotNetFrameworkReferenceAssembliesV30 { get; }
    internal static string PathToDotNetFrameworkReferenceAssembliesV35 { get; }
    private static FrameworkLocationHelper();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    internal static string get_PathToDotNetFrameworkSdkV35ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV35ToolsOnVS11();
    internal static string get_PathToDotNetFrameworkSdkV40ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV40ToolsOnVS11();
    internal static string get_PathToDotNetFrameworkSdkV45ToolsOnVS10();
    internal static string get_PathToDotNetFrameworkSdkV45ToolsOnVS11();
    internal static string get_PathToWindowsSdkV45OnVS10();
    internal static string get_PathToWindowsSdkV45OnVS11();
    internal static string get_PathToDotNetFrameworkReferenceAssembliesV30();
    internal static string get_PathToDotNetFrameworkReferenceAssembliesV35();
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue : MulticastDelegate {
    public GetRegistrySubKeyDefaultValue(object object, IntPtr method);
    public virtual string Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyNames : MulticastDelegate {
    public GetRegistrySubKeyNames(object object, IntPtr method);
    public virtual IEnumerable`1<string> Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.InprocTrackingNativeMethods : object {
    internal static void StartTrackingContext(string intermediateDirectory, string taskName);
    internal static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarker);
    internal static void EndTrackingContext();
    internal static void StopTrackingAndCleanup();
    internal static void SuspendTracking();
    internal static void ResumeTracking();
    internal static void WriteAllTLogs(string intermediateDirectory, string tlogRootName);
    internal static void WriteContextTLogs(string intermediateDirectory, string tlogRootName);
    internal static void SetThreadCount(int threadCount);
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static HandleRef NullHandleRef;
    internal static IntPtr NullIntPtr;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static int MAX_PATH;
    private static NativeMethodsShared();
    internal static int SetErrorMode(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static string FindOnPath(string filename);
    internal static void KillTree(int processIdTokill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, StringBuilder lpBuffer);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, StringBuilder buffer, IntPtr mustBeZero);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
}
internal class Microsoft.Build.Shared.OpenBaseKey : MulticastDelegate {
    public OpenBaseKey(object object, IntPtr method);
    public virtual RegistryKey Invoke(RegistryHive hive, RegistryView view);
    public virtual IAsyncResult BeginInvoke(RegistryHive hive, RegistryView view, AsyncCallback callback, object object);
    public virtual RegistryKey EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.RegistryHelper : object {
    internal static IEnumerable`1<string> GetSubKeyNames(RegistryKey baseKey, string subkey);
    internal static string GetDefaultValue(RegistryKey baseKey, string subkey);
    internal static RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
[LoadInSeparateAppDomainAttribute]
public abstract class Microsoft.Build.Utilities.AppDomainIsolatedTask : MarshalByRefObject {
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    protected ResourceManager TaskResources { get; protected set; }
    protected string HelpKeywordPrefix { get; protected set; }
    protected AppDomainIsolatedTask(ResourceManager taskResources);
    protected AppDomainIsolatedTask(ResourceManager taskResources, string helpKeywordPrefix);
    public sealed virtual IBuildEngine get_BuildEngine();
    public sealed virtual void set_BuildEngine(IBuildEngine value);
    public sealed virtual ITaskHost get_HostObject();
    public sealed virtual void set_HostObject(ITaskHost value);
    public TaskLoggingHelper get_Log();
    protected ResourceManager get_TaskResources();
    protected void set_TaskResources(ResourceManager value);
    protected string get_HelpKeywordPrefix();
    protected void set_HelpKeywordPrefix(string value);
    public abstract virtual bool Execute();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
}
public class Microsoft.Build.Utilities.AssemblyFoldersExInfo : object {
    public RegistryHive Hive { get; private set; }
    public RegistryView View { get; private set; }
    public string Key { get; private set; }
    public string DirectoryPath { get; private set; }
    public Version TargetFrameworkVersion { get; private set; }
    public AssemblyFoldersExInfo(RegistryHive hive, RegistryView view, string registryKey, string directoryPath, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
public RegistryHive get_Hive();
    [CompilerGeneratedAttribute]
private void set_Hive(RegistryHive value);
    [CompilerGeneratedAttribute]
public RegistryView get_View();
    [CompilerGeneratedAttribute]
private void set_View(RegistryView value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
private void set_DirectoryPath(string value);
    [CompilerGeneratedAttribute]
public Version get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworkVersion(Version value);
}
internal static class Microsoft.Build.Utilities.CanonicalTrackedFilesHelper : object {
    internal static int MaxLogCount;
    internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot);
    internal static bool FilesExistAndRecordNewestWriteTime(ITaskItem[] files, TaskLoggingHelper log, DateTime& outputNewestTime, String& outputNewestFilename);
    internal static bool FilesExistAndRecordOldestWriteTime(ITaskItem[] files, TaskLoggingHelper log, DateTime& outputOldestTime, String& outputOldestFilename);
}
public class Microsoft.Build.Utilities.CanonicalTrackedInputFiles : object {
    internal ITaskItem[] SourcesNeedingCompilation { get; internal set; }
    public Dictionary`2<string, Dictionary`2<string, string>> DependencyTable { get; }
    public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers);
    public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers);
    public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers);
    public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers);
    public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers);
    internal ITaskItem[] get_SourcesNeedingCompilation();
    internal void set_SourcesNeedingCompilation(ITaskItem[] value);
    public Dictionary`2<string, Dictionary`2<string, string>> get_DependencyTable();
    public ITaskItem[] ComputeSourcesNeedingCompilation();
    public ITaskItem[] ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers);
    internal ITaskItem[] ComputeSourcesNeedingCompilationFromPrimaryFiles();
    internal ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(bool searchForSubRootsInCompositeRootingMarkers);
    public bool FileIsExcludedFromDependencyCheck(string fileName);
    public void SaveTlog();
    public void SaveTlog(DependencyFilter includeInTLog);
    public void RemoveEntriesForSource(ITaskItem source);
    public void RemoveEntriesForSource(ITaskItem[] source);
    public void RemoveEntryForSourceRoot(string rootingMarker);
    public void RemoveDependencyFromEntry(ITaskItem[] sources, ITaskItem dependencyToRemove);
    public void RemoveDependencyFromEntry(ITaskItem source, ITaskItem dependencyToRemove);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem source);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs);
}
public class Microsoft.Build.Utilities.CanonicalTrackedOutputFiles : object {
    public Dictionary`2<string, Dictionary`2<string, DateTime>> DependencyTable { get; }
    public CanonicalTrackedOutputFiles(ITaskItem[] tlogFiles);
    public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles);
    public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles, bool constructOutputsFromTLogs);
    public Dictionary`2<string, Dictionary`2<string, DateTime>> get_DependencyTable();
    public String[] RemoveRootsWithSharedOutputs(ITaskItem[] sources);
    public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove);
    public ITaskItem[] OutputsForNonCompositeSource(ITaskItem[] sources);
    public ITaskItem[] OutputsForSource(ITaskItem[] sources);
    public ITaskItem[] OutputsForSource(ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers);
    internal bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot);
    public void AddComputedOutputForSourceRoot(string sourceKey, string computedOutput);
    public void AddComputedOutputsForSourceRoot(string sourceKey, String[] computedOutputs);
    public void AddComputedOutputsForSourceRoot(string sourceKey, ITaskItem[] computedOutputs);
    public void SaveTlog();
    public void SaveTlog(DependencyFilter includeInTLog);
    public void RemoveEntriesForSource(ITaskItem source);
    public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput);
    public void RemoveEntriesForSource(ITaskItem[] source);
    public void RemoveEntriesForSource(ITaskItem[] source, ITaskItem[] correspondingOutputs);
    public void RemoveDependencyFromEntry(ITaskItem[] sources, ITaskItem dependencyToRemove);
    public void RemoveDependencyFromEntry(ITaskItem source, ITaskItem dependencyToRemove);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem source);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source);
    public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs);
}
public class Microsoft.Build.Utilities.CommandLineBuilder : object {
    public int Length { get; }
    protected StringBuilder CommandLine { get; }
    public CommandLineBuilder(bool quoteHyphensOnCommandLine);
    private static CommandLineBuilder();
    public int get_Length();
    protected StringBuilder get_CommandLine();
    public virtual string ToString();
    protected virtual bool IsQuotingRequired(string parameter);
    protected void AppendSpaceIfNotEmpty();
    protected void AppendTextWithQuoting(string textToAppend);
    protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTextToAppend);
    public void AppendTextUnquoted(string textToAppend);
    protected void AppendFileNameWithQuoting(string fileName);
    public void AppendFileNameIfNotNull(string fileName);
    public void AppendFileNameIfNotNull(ITaskItem fileItem);
    public void AppendFileNamesIfNotNull(String[] fileNames, string delimiter);
    public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter);
    public void AppendSwitch(string switchName);
    public void AppendSwitchIfNotNull(string switchName, string parameter);
    protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, string parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
}
public class Microsoft.Build.Utilities.DependencyFilter : MulticastDelegate {
    public DependencyFilter(object object, IntPtr method);
    public virtual bool Invoke(string fullPath);
    public virtual IAsyncResult BeginInvoke(string fullPath, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Utilities.DependencyTableCache : object {
    internal static Dictionary`2<string, DependencyTableCacheEntry> DependencyTable { get; }
    private static DependencyTableCache();
    internal static Dictionary`2<string, DependencyTableCacheEntry> get_DependencyTable();
    internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarker);
    internal static string FormatNormalizedTlogRootingMarker(ITaskItem[] tlogFiles);
    internal static string NormalizeTlogPath(string tlogPath);
}
internal class Microsoft.Build.Utilities.DependencyTableCacheEntry : object {
    public ITaskItem[] TlogFiles { get; }
    public DateTime TableTime { get; }
    public IDictionary DependencyTable { get; }
    internal DependencyTableCacheEntry(ITaskItem[] tlogFiles, IDictionary dependencyTable);
    public ITaskItem[] get_TlogFiles();
    public DateTime get_TableTime();
    public IDictionary get_DependencyTable();
}
public enum Microsoft.Build.Utilities.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
public enum Microsoft.Build.Utilities.ExecutableType : Enum {
    public int value__;
    public static ExecutableType Native32Bit;
    public static ExecutableType Native64Bit;
    public static ExecutableType ManagedIL;
    public static ExecutableType Managed32Bit;
    public static ExecutableType Managed64Bit;
    public static ExecutableType SameAsCurrentProcess;
}
public static class Microsoft.Build.Utilities.FileTracker : object {
    private static FileTracker();
    public static void EndTrackingContext();
    public static void ResumeTracking();
    public static void SetThreadCount(int threadCount);
    public static void StartTrackingContext(string intermediateDirectory, string taskName);
    public static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile);
    public static void StopTrackingAndCleanup();
    public static void SuspendTracking();
    public static void WriteAllTLogs(string intermediateDirectory, string taskName);
    public static void WriteContextTLogs(string intermediateDirectory, string taskName);
    public static bool FileIsExcludedFromDependencies(string fileName);
    public static bool FileIsUnderPath(string fileName, string path);
    public static string FormatRootingMarker(ITaskItem source);
    public static string FormatRootingMarker(ITaskItem source, ITaskItem output);
    public static string FormatRootingMarker(ITaskItem[] sources);
    public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs);
    public static string CreateRootingMarkerResponseFile(ITaskItem[] sources);
    public static string CreateRootingMarkerResponseFile(string rootMarker);
    public static string EnsureFileTrackerOnPath();
    public static string EnsureFileTrackerOnPath(string rootPath);
    public static string FindTrackerOnPath();
    public static bool ForceOutOfProcTracking(ExecutableType toolType);
    public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllName, string cancelEventName);
    public static string GetTrackerPath(ExecutableType toolType);
    public static string GetTrackerPath(ExecutableType toolType, string rootPath);
    public static string GetFileTrackerPath(ExecutableType toolType);
    public static string GetFileTrackerPath(ExecutableType toolType, string rootPath);
    public static string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles);
    public static string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);
    public static string TrackerCommandArguments(string command, string arguments);
    public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles);
    public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);
    public static Process StartProcess(string command, string arguments, ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName);
    public static Process StartProcess(string command, string arguments, ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles);
    public static Process StartProcess(string command, string arguments, ExecutableType toolType, string intermediateDirectory, string rootFiles);
    public static Process StartProcess(string command, string arguments, ExecutableType toolType, string rootFiles);
    public static Process StartProcess(string command, string arguments, ExecutableType toolType);
    internal static void LogMessageFromResources(TaskLoggingHelper Log, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importance, string message, Object[] messageArgs);
    internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, string messageResourceName, Object[] messageArgs);
}
public class Microsoft.Build.Utilities.FlatTrackingData : object {
    public IDictionary`2<string, DateTime> DependencyTable { get; }
    public List`1<string> MissingFiles { get; public set; }
    public string OldestFileName { get; public set; }
    public DateTime OldestFileTime { get; public set; }
    public DateTime OldestFileTimeUtc { get; public set; }
    public string NewestFileName { get; public set; }
    public DateTime NewestFileTime { get; public set; }
    public DateTime NewestFileTimeUtc { get; public set; }
    public bool TreatRootMarkersAsEntries { get; public set; }
    public bool SkipMissingFiles { get; public set; }
    public ITaskItem[] TlogFiles { get; public set; }
    public DateTime NewestTLogTime { get; public set; }
    public DateTime NewestTLogTimeUtc { get; public set; }
    public string NewestTLogFileName { get; public set; }
    public bool TlogsAvailable { get; public set; }
    public FlatTrackingData(ITaskItem[] tlogFiles, DateTime missingFileTimeUtc);
    public FlatTrackingData(ITaskItem[] tlogFiles, ITaskItem[] tlogFilesToIgnore, DateTime missingFileTimeUtc);
    public FlatTrackingData(ITaskItem[] tlogFiles, ITaskItem[] tlogFilesToIgnore, DateTime missingFileTimeUtc, String[] excludedInputPaths, IDictionary`2<string, DateTime> sharedLastWriteTimeUtcCache);
    public FlatTrackingData(ITask ownerTask, ITaskItem[] tlogFiles, DateTime missingFileTimeUtc);
    public FlatTrackingData(ITaskItem[] tlogFiles, bool skipMissingFiles);
    public FlatTrackingData(ITask ownerTask, ITaskItem[] tlogFiles, bool skipMissingFiles);
    public IDictionary`2<string, DateTime> get_DependencyTable();
    public List`1<string> get_MissingFiles();
    public void set_MissingFiles(List`1<string> value);
    public string get_OldestFileName();
    public void set_OldestFileName(string value);
    public DateTime get_OldestFileTime();
    public void set_OldestFileTime(DateTime value);
    public DateTime get_OldestFileTimeUtc();
    public void set_OldestFileTimeUtc(DateTime value);
    public string get_NewestFileName();
    public void set_NewestFileName(string value);
    public DateTime get_NewestFileTime();
    public void set_NewestFileTime(DateTime value);
    public DateTime get_NewestFileTimeUtc();
    public void set_NewestFileTimeUtc(DateTime value);
    public bool get_TreatRootMarkersAsEntries();
    public void set_TreatRootMarkersAsEntries(bool value);
    public bool get_SkipMissingFiles();
    public void set_SkipMissingFiles(bool value);
    public ITaskItem[] get_TlogFiles();
    public void set_TlogFiles(ITaskItem[] value);
    public DateTime get_NewestTLogTime();
    public void set_NewestTLogTime(DateTime value);
    public DateTime get_NewestTLogTimeUtc();
    public void set_NewestTLogTimeUtc(DateTime value);
    public string get_NewestTLogFileName();
    public void set_NewestTLogFileName(string value);
    public bool get_TlogsAvailable();
    public void set_TlogsAvailable(bool value);
    public void UpdateFileEntryDetails();
    public bool FileIsExcludedFromDependencyCheck(string fileName);
    public void SaveTlog();
    public void SaveTlog(DependencyFilter includeInTLog);
    public DateTime GetLastWriteTimeUtc(string file);
    public static bool IsUpToDate(Task hostTask, UpToDateCheckType upToDateCheckType, ITaskItem[] readTLogNames, ITaskItem[] writeTLogNames);
    public static bool IsUpToDate(TaskLoggingHelper Log, UpToDateCheckType upToDateCheckType, FlatTrackingData inputs, FlatTrackingData outputs);
    public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] readTLogNames, ITaskItem[] writeTLogNames, ITaskItem[] trackedFilesToRemoveFromTLogs);
}
public enum Microsoft.Build.Utilities.HostObjectInitializationStatus : Enum {
    public int value__;
    public static HostObjectInitializationStatus UseHostObjectToExecute;
    public static HostObjectInitializationStatus UseAlternateToolToExecute;
    public static HostObjectInitializationStatus NoActionReturnSuccess;
    public static HostObjectInitializationStatus NoActionReturnFailure;
}
public abstract class Microsoft.Build.Utilities.Logger : object {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public virtual LoggerVerbosity get_Verbosity();
    public virtual void set_Verbosity(LoggerVerbosity value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public abstract virtual void Initialize(IEventSource eventSource);
    public virtual void Shutdown();
    public virtual string FormatErrorEvent(BuildErrorEventArgs args);
    public virtual string FormatWarningEvent(BuildWarningEventArgs args);
    public bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
}
public class Microsoft.Build.Utilities.MuxLogger : object {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int maxNodeCount);
    public sealed virtual void Shutdown();
    public void RegisterLogger(int submissionId, ILogger logger);
    public bool UnregisterLoggers(int submissionId);
    internal void InitializeLogger(List`1<ILogger> loggerList, ILogger logger, IEventSource sourceForLogger);
}
internal static class Microsoft.Build.Utilities.NativeMethods : object {
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static DateTime GetLastWriteTimeUtc(string fullPath);
}
public static class Microsoft.Build.Utilities.ProcessorArchitecture : object {
    public static string X86;
    public static string IA64;
    public static string AMD64;
    public static string MSIL;
    public static string ARM;
    public static string CurrentProcessArchitecture { get; }
    private static ProcessorArchitecture();
    public static string get_CurrentProcessArchitecture();
}
public enum Microsoft.Build.Utilities.TargetDotNetFrameworkVersion : Enum {
    public int value__;
    public static TargetDotNetFrameworkVersion Version11;
    public static TargetDotNetFrameworkVersion Version20;
    public static TargetDotNetFrameworkVersion Version30;
    public static TargetDotNetFrameworkVersion Version35;
    public static TargetDotNetFrameworkVersion Version40;
    public static TargetDotNetFrameworkVersion Version45;
    public static TargetDotNetFrameworkVersion VersionLatest;
}
public class Microsoft.Build.Utilities.TargetPlatformSDK : object {
    public string TargetPlatformIdentifier { get; private set; }
    public Version TargetPlatformVersion { get; private set; }
    public string Path { get; public set; }
    internal Dictionary`2<string, string> ExtensionSDKs { get; private set; }
    public TargetPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string path);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public Version get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformVersion(Version value);
    public string get_Path();
    public void set_Path(string value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_ExtensionSDKs();
    [CompilerGeneratedAttribute]
private void set_ExtensionSDKs(Dictionary`2<string, string> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetPlatformSDK other);
}
public abstract class Microsoft.Build.Utilities.Task : object {
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public IBuildEngine4 BuildEngine4 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    protected ResourceManager TaskResources { get; protected set; }
    protected string HelpKeywordPrefix { get; protected set; }
    protected Task(ResourceManager taskResources);
    protected Task(ResourceManager taskResources, string helpKeywordPrefix);
    public sealed virtual IBuildEngine get_BuildEngine();
    public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public IBuildEngine4 get_BuildEngine4();
    public sealed virtual ITaskHost get_HostObject();
    public sealed virtual void set_HostObject(ITaskHost value);
    public TaskLoggingHelper get_Log();
    protected ResourceManager get_TaskResources();
    protected void set_TaskResources(ResourceManager value);
    protected string get_HelpKeywordPrefix();
    protected void set_HelpKeywordPrefix(string value);
    public abstract virtual bool Execute();
}
public class Microsoft.Build.Utilities.TaskItem : MarshalByRefObject {
    public string ItemSpec { get; public set; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public ICollection MetadataNames { get; }
    public int MetadataCount { get; }
    public TaskItem(string itemSpec);
    public TaskItem(string itemSpec, IDictionary itemMetadata);
    public TaskItem(ITaskItem sourceItem);
    public sealed virtual string get_ItemSpec();
    public sealed virtual void set_ItemSpec(string value);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual IDictionary CloneCustomMetadata();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    public static string op_Explicit(TaskItem taskItemToCast);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
}
public class Microsoft.Build.Utilities.TaskLoggingHelper : MarshalByRefObject {
    protected string TaskName { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    protected string get_TaskName();
    protected IBuildEngine get_BuildEngine();
    public ResourceManager get_TaskResources();
    public void set_TaskResources(ResourceManager value);
    public string get_HelpKeywordPrefix();
    public void set_HelpKeywordPrefix(string value);
    public bool get_HasLoggedErrors();
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public virtual object InitializeLifetimeService();
    public void MarkAsInactive();
}
public static class Microsoft.Build.Utilities.ToolLocationHelper : object {
    public static string PathToSystem { get; }
    private static ToolLocationHelper();
    public static IList`1<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, ProcessorArchitecture targetProcessorArchitecture);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(String[] diskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks();
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks(String[] diskRoots, string registryRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static string get_PathToSystem();
    public static string GetDotNetFrameworkVersionFolderPrefix(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion version);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static IList`1<string> GetPathToReferenceAssemblies(FrameworkName frameworkName);
    internal static string VersionToDotNetFrameworkPath(VersionToPath PathToDotNetFramework, TargetDotNetFrameworkVersion version);
    internal static string VersionToDotNetReferenceAssemblies(VersionToPath PathToDotReferenceAssemblies, TargetDotNetFrameworkVersion version);
    internal static IList`1<string> HandleLegacyDotNetFrameworkReferenceAssemblyPaths(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies, FrameworkName frameworkName);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, FrameworkName frameworkName);
    public static string GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, FrameworkName frameworkName);
    internal static IList`1<string> GetPathAndChainReferenceAssemblyLocations(string targetFrameworkRootPath, FrameworkName frameworkName, bool chain);
    public static void ClearSDKStaticCache();
    internal static void ClearStaticCaches();
    internal static ReadOnlyCollection`1<TargetPlatformSDK> RetrieveTargetPlatformList(String[] diskRoots, string registrySearchLocation);
    internal static void GatherSDKListFromDirectory(List`1<string> diskroots, Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformSDKs);
    internal static void GatherSDKsFromRegistryImpl(Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformMonikers, string registryKeyRoot, RegistryView registryView, RegistryHive registryHive, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, FileExists fileExists);
    internal static string ChainReferenceAssemblyPath(string targetFrameworkDirectory);
    internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootPath, FrameworkName frameworkName);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary);
    internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture(DotNetFrameworkArchitecture architecture);
    public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    internal static string GetPathToWindowsSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToSystemFile(string fileName);
    public static IList`1<string> GetSupportedTargetFrameworks();
    public static FrameworkName HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier);
    public static string GetProgramFilesReferenceAssemblyRoot();
    internal static IList`1<string> GetFrameworkIdentifiers(string frameworkReferenceRoot);
    internal static string RemoveDirectories(string path, int numberOfLevelsToRemove);
}
public abstract class Microsoft.Build.Utilities.ToolTask : Task {
    [OutputAttribute]
public int ExitCode { get; }
    public bool YieldDuringToolExecution { get; public set; }
    public bool UseCommandProcessor { get; public set; }
    public bool EchoOff { get; public set; }
    protected int TaskProcessTerminationTimeout { get; protected set; }
    protected ManualResetEvent ToolCanceled { get; private set; }
    protected string ToolName { get; }
    public string ToolExe { get; public set; }
    public string ToolPath { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public int Timeout { get; public set; }
    protected Encoding ResponseFileEncoding { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    [ObsoleteAttribute("Use EnvironmentVariables property")]
protected StringDictionary EnvironmentOverride { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected bool HasLoggedErrors { get; }
    public string StandardOutputImportance { get; public set; }
    public string StandardErrorImportance { get; public set; }
    public bool LogStandardErrorAsError { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardOutputImportanceToUse { get; }
    protected MessageImportance StandardErrorImportanceToUse { get; }
    protected ToolTask(ResourceManager taskResources);
    protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix);
    private static ToolTask();
    public int get_ExitCode();
    [CompilerGeneratedAttribute]
public bool get_YieldDuringToolExecution();
    [CompilerGeneratedAttribute]
public void set_YieldDuringToolExecution(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseCommandProcessor();
    [CompilerGeneratedAttribute]
public void set_UseCommandProcessor(bool value);
    [CompilerGeneratedAttribute]
public bool get_EchoOff();
    [CompilerGeneratedAttribute]
public void set_EchoOff(bool value);
    [CompilerGeneratedAttribute]
protected int get_TaskProcessTerminationTimeout();
    [CompilerGeneratedAttribute]
protected void set_TaskProcessTerminationTimeout(int value);
    [CompilerGeneratedAttribute]
protected ManualResetEvent get_ToolCanceled();
    [CompilerGeneratedAttribute]
private void set_ToolCanceled(ManualResetEvent value);
    protected abstract virtual string get_ToolName();
    public virtual string get_ToolExe();
    public virtual void set_ToolExe(string value);
    public void set_ToolPath(string value);
    public string get_ToolPath();
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    public virtual void set_Timeout(int value);
    public virtual int get_Timeout();
    protected virtual Encoding get_ResponseFileEncoding();
    protected virtual string ResponseFileEscape(string responseString);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    protected virtual StringDictionary get_EnvironmentOverride();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual bool get_HasLoggedErrors();
    public string get_StandardOutputImportance();
    public void set_StandardOutputImportance(string value);
    public string get_StandardErrorImportance();
    public void set_StandardErrorImportance(string value);
    public bool get_LogStandardErrorAsError();
    public void set_LogStandardErrorAsError(bool value);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected MessageImportance get_StandardOutputImportanceToUse();
    protected MessageImportance get_StandardErrorImportanceToUse();
    protected abstract virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    protected internal virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GetResponseFileSwitch(string responseFilePath);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual bool CallHostObjectToExecute();
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual void LogToolCommand(string message);
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    protected ProcessStartInfo GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch);
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    public virtual void Cancel();
    protected void DeleteTempFile(string fileName);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    public virtual bool Execute();
}
public static class Microsoft.Build.Utilities.TrackedDependencies : object {
    public static ITaskItem[] ExpandWildcards(ITaskItem[] expand);
    internal static bool ItemsExist(ITaskItem[] files);
}
public enum Microsoft.Build.Utilities.UpToDateCheckType : Enum {
    public int value__;
    public static UpToDateCheckType InputNewerThanOutput;
    public static UpToDateCheckType InputOrOutputNewerThanTracking;
    public static UpToDateCheckType InputNewerThanTracking;
}
public enum Microsoft.Build.Utilities.VisualStudioVersion : Enum {
    public int value__;
    public static VisualStudioVersion Version100;
    public static VisualStudioVersion Version110;
    public static VisualStudioVersion VersionLatest;
}
internal class Microsoft.Build.Utilities.WIN32_FILE_ATTRIBUTE_DATA : ValueType {
    internal int fileAttributes;
    internal UInt32 ftCreationTimeLow;
    internal UInt32 ftCreationTimeHigh;
    internal UInt32 ftLastAccessTimeLow;
    internal UInt32 ftLastAccessTimeHigh;
    internal UInt32 ftLastWriteTimeLow;
    internal UInt32 ftLastWriteTimeHigh;
    internal UInt32 fileSizeHigh;
    internal UInt32 fileSizeLow;
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
