internal class System.Xml.Utils.Res : object {
    internal static string Xml_UserException;
    internal static string Xml_ErrorFilePosition;
    internal static string Xml_InvalidOperation;
    internal static string Xml_EndOfInnerExceptionStack;
    internal static string XPath_UnclosedString;
    internal static string XPath_ScientificNotation;
    internal static string XPath_UnexpectedToken;
    internal static string XPath_NodeTestExpected;
    internal static string XPath_EofExpected;
    internal static string XPath_TokenExpected;
    internal static string XPath_InvalidAxisInPattern;
    internal static string XPath_PredicateAfterDot;
    internal static string XPath_PredicateAfterDotDot;
    internal static string XPath_NArgsExpected;
    internal static string XPath_NOrMArgsExpected;
    internal static string XPath_AtLeastNArgsExpected;
    internal static string XPath_AtMostMArgsExpected;
    internal static string XPath_NodeSetArgumentExpected;
    internal static string XPath_NodeSetExpected;
    internal static string XPath_RtfInPathExpr;
    internal static string Xslt_WarningAsError;
    internal static string Xslt_InputTooComplex;
    internal static string Xslt_CannotLoadStylesheet;
    internal static string Xslt_WrongStylesheetElement;
    internal static string Xslt_WdXslNamespace;
    internal static string Xslt_NotAtTop;
    internal static string Xslt_UnexpectedElement;
    internal static string Xslt_NullNsAtTopLevel;
    internal static string Xslt_TextNodesNotAllowed;
    internal static string Xslt_NotEmptyContents;
    internal static string Xslt_InvalidAttribute;
    internal static string Xslt_MissingAttribute;
    internal static string Xslt_InvalidAttrValue;
    internal static string Xslt_BistateAttribute;
    internal static string Xslt_CharAttribute;
    internal static string Xslt_CircularInclude;
    internal static string Xslt_SingleRightBraceInAvt;
    internal static string Xslt_VariableCntSel2;
    internal static string Xslt_KeyCntUse;
    internal static string Xslt_DupTemplateName;
    internal static string Xslt_BothMatchNameAbsent;
    internal static string Xslt_InvalidVariable;
    internal static string Xslt_DupGlobalVariable;
    internal static string Xslt_DupLocalVariable;
    internal static string Xslt_DupNsAlias;
    internal static string Xslt_EmptyAttrValue;
    internal static string Xslt_EmptyNsAlias;
    internal static string Xslt_UnknownXsltFunction;
    internal static string Xslt_UnsupportedXsltFunction;
    internal static string Xslt_NoAttributeSet;
    internal static string Xslt_UndefinedKey;
    internal static string Xslt_CircularAttributeSet;
    internal static string Xslt_InvalidCallTemplate;
    internal static string Xslt_InvalidPrefix;
    internal static string Xslt_ScriptXsltNamespace;
    internal static string Xslt_ScriptInvalidLanguage;
    internal static string Xslt_ScriptMixedLanguages;
    internal static string Xslt_ScriptCompileException;
    internal static string Xslt_ScriptNotAtTop;
    internal static string Xslt_AssemblyNameHref;
    internal static string Xslt_ScriptAndExtensionClash;
    internal static string Xslt_NoDecimalFormat;
    internal static string Xslt_DecimalFormatSignsNotDistinct;
    internal static string Xslt_DecimalFormatRedefined;
    internal static string Xslt_UnknownExtensionElement;
    internal static string Xslt_ModeWithoutMatch;
    internal static string Xslt_ModeListEmpty;
    internal static string Xslt_ModeListDup;
    internal static string Xslt_ModeListAll;
    internal static string Xslt_PriorityWithoutMatch;
    internal static string Xslt_InvalidApplyImports;
    internal static string Xslt_DuplicateWithParam;
    internal static string Xslt_ReservedNS;
    internal static string Xslt_XmlnsAttr;
    internal static string Xslt_NoWhen;
    internal static string Xslt_WhenAfterOtherwise;
    internal static string Xslt_DupOtherwise;
    internal static string Xslt_AttributeRedefinition;
    internal static string Xslt_InvalidMethod;
    internal static string Xslt_InvalidEncoding;
    internal static string Xslt_InvalidLanguage;
    internal static string Xslt_InvalidCompareOption;
    internal static string Xslt_KeyNotAllowed;
    internal static string Xslt_VariablesNotAllowed;
    internal static string Xslt_CurrentNotAllowed;
    internal static string Xslt_DocumentFuncProhibited;
    internal static string Xslt_ScriptsProhibited;
    internal static string Xslt_ItemNull;
    internal static string Xslt_NodeSetNotNode;
    internal static string Xslt_UnsupportedClrType;
    internal static string Xslt_NotYetImplemented;
    internal static string Xslt_SchemaDeclaration;
    internal static string Xslt_SchemaAttribute;
    internal static string Xslt_SchemaAttributeValue;
    internal static string Xslt_ElementCntSel;
    internal static string Xslt_PerformSortCntSel;
    internal static string Xslt_RequiredAndSelect;
    internal static string Xslt_NoSelectNoContent;
    internal static string Xslt_NonTemplateTunnel;
    internal static string Xslt_RequiredOnFunction;
    internal static string Xslt_ExcludeDefault;
    internal static string Xslt_CollationSyntax;
    internal static string Xslt_AnalyzeStringDupChild;
    internal static string Xslt_AnalyzeStringChildOrder;
    internal static string Xslt_AnalyzeStringEmpty;
    internal static string Xslt_SortStable;
    internal static string Xslt_InputTypeAnnotations;
    internal static string Coll_BadOptFormat;
    internal static string Coll_Unsupported;
    internal static string Coll_UnsupportedLanguage;
    internal static string Coll_UnsupportedOpt;
    internal static string Coll_UnsupportedOptVal;
    internal static string Coll_UnsupportedSortOpt;
    internal static string Qil_Validation;
    internal static string XmlIl_TooManyParameters;
    internal static string XmlIl_BadXmlState;
    internal static string XmlIl_BadXmlStateAttr;
    internal static string XmlIl_NmspAfterAttr;
    internal static string XmlIl_NmspConflict;
    internal static string XmlIl_CantResolveEntity;
    internal static string XmlIl_NoDefaultDocument;
    internal static string XmlIl_UnknownDocument;
    internal static string XmlIl_UnknownParam;
    internal static string XmlIl_UnknownExtObj;
    internal static string XmlIl_CantStripNav;
    internal static string XmlIl_ExtensionError;
    internal static string XmlIl_TopLevelAttrNmsp;
    internal static string XmlIl_NoExtensionMethod;
    internal static string XmlIl_AmbiguousExtensionMethod;
    internal static string XmlIl_NonPublicExtensionMethod;
    internal static string XmlIl_GenericExtensionMethod;
    internal static string XmlIl_ByRefType;
    internal static string XmlIl_DocumentLoadError;
    internal static string Xslt_CompileError;
    internal static string Xslt_CompileError2;
    internal static string Xslt_UnsuppFunction;
    internal static string Xslt_NotFirstImport;
    internal static string Xslt_UnexpectedKeyword;
    internal static string Xslt_InvalidContents;
    internal static string Xslt_CantResolve;
    internal static string Xslt_SingleRightAvt;
    internal static string Xslt_OpenBracesAvt;
    internal static string Xslt_OpenLiteralAvt;
    internal static string Xslt_NestedAvt;
    internal static string Xslt_EmptyAvtExpr;
    internal static string Xslt_InvalidXPath;
    internal static string Xslt_InvalidQName;
    internal static string Xslt_NoStylesheetLoaded;
    internal static string Xslt_TemplateNoAttrib;
    internal static string Xslt_DupVarName;
    internal static string Xslt_WrongNumberArgs;
    internal static string Xslt_NoNodeSetConversion;
    internal static string Xslt_NoNavigatorConversion;
    internal static string Xslt_FunctionFailed;
    internal static string Xslt_InvalidFormat;
    internal static string Xslt_InvalidFormat1;
    internal static string Xslt_InvalidFormat2;
    internal static string Xslt_InvalidFormat3;
    internal static string Xslt_InvalidFormat4;
    internal static string Xslt_InvalidFormat5;
    internal static string Xslt_InvalidFormat8;
    internal static string Xslt_ScriptCompileErrors;
    internal static string Xslt_ScriptInvalidPrefix;
    internal static string Xslt_ScriptDub;
    internal static string Xslt_ScriptEmpty;
    internal static string Xslt_DupDecimalFormat;
    internal static string Xslt_CircularReference;
    internal static string Xslt_InvalidExtensionNamespace;
    internal static string Xslt_InvalidModeAttribute;
    internal static string Xslt_MultipleRoots;
    internal static string Xslt_ApplyImports;
    internal static string Xslt_Terminate;
    internal static string Xslt_InvalidPattern;
    internal static string Xslt_EmptyTagRequired;
    internal static string Xslt_WrongNamespace;
    internal static string Xslt_InvalidFormat6;
    internal static string Xslt_InvalidFormat7;
    internal static string Xslt_ScriptMixLang;
    internal static string Xslt_ScriptInvalidLang;
    internal static string Xslt_InvalidExtensionPermitions;
    internal static string Xslt_InvalidParamNamespace;
    internal static string Xslt_DuplicateParametr;
    internal static string Xslt_VariableCntSel;
    public static ResourceManager Resources { get; }
    private static Res();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class System.Xml.Utils.ResCategoryAttribute : CategoryAttribute {
    public ResCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.Xml.Utils.ResDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public ResDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.Xml.Xsl.ExecuteDelegate : MulticastDelegate {
    public ExecuteDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlQueryRuntime runtime);
    public virtual IAsyncResult BeginInvoke(XmlQueryRuntime runtime, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Xml.Xsl.IErrorHelper {
    public abstract virtual void ReportError(string res, String[] args);
    public abstract virtual void ReportWarning(string res, String[] args);
}
internal enum System.Xml.Xsl.IlGen.BranchingContext : Enum {
    public int value__;
    public static BranchingContext None;
    public static BranchingContext OnTrue;
    public static BranchingContext OnFalse;
}
internal class System.Xml.Xsl.IlGen.GenerateHelper : object {
    public StaticDataManager StaticData { get; }
    public GenerateHelper(XmlILModule module, bool isDebug);
    public void MethodBegin(MethodBase methInfo, ISourceLineInfo sourceInfo, bool initWriters);
    public void MethodEnd();
    public void CallSyncToNavigator();
    public StaticDataManager get_StaticData();
    public void LoadInteger(int intVal);
    public void LoadBoolean(bool boolVal);
    public void LoadType(Type clrTyp);
    public LocalBuilder DeclareLocal(string name, Type type);
    public void LoadQueryRuntime();
    public void LoadQueryContext();
    public void LoadXsltLibrary();
    public void LoadQueryOutput();
    public void LoadParameter(int paramPos);
    public void SetParameter(object paramId);
    public void BranchAndMark(Label lblBranch, Label lblMark);
    public void TestAndBranch(int i4, Label lblBranch, OpCode opcodeBranch);
    public void ConvBranchToBool(Label lblBranch, bool isTrueBranch);
    public void TailCall(MethodInfo meth);
    public void Call(MethodInfo meth);
    public void CallToken(MethodInfo meth);
    public void Construct(ConstructorInfo constr);
    public void CallConcatStrings(int cStrings);
    public void TreatAs(Type clrTypeSrc, Type clrTypeDst);
    public void ConstructLiteralDecimal(decimal dec);
    public void ConstructLiteralQName(string localName, string namespaceName);
    public void CallArithmeticOp(QilNodeType opType, XmlTypeCode code);
    public void CallCompareEquals(XmlTypeCode code);
    public void CallCompare(XmlTypeCode code);
    public void CallStartRtfConstruction(string baseUri);
    public void CallEndRtfConstruction();
    public void CallStartSequenceConstruction();
    public void CallEndSequenceConstruction();
    public void CallGetEarlyBoundObject(int idxObj, Type clrType);
    public void CallGetAtomizedName(int idxName);
    public void CallGetNameFilter(int idxFilter);
    public void CallGetTypeFilter(XPathNodeType nodeType);
    public void CallParseTagName(GenerateNameType nameType);
    public void CallGetGlobalValue(int idxValue, Type clrType);
    public void CallSetGlobalValue(Type clrType);
    public void CallGetCollation(int idxName);
    public void CallGetParameter(string localName, string namespaceUri);
    public void CallStartTree(XPathNodeType rootType);
    public void CallEndTree();
    public void CallWriteStartRoot();
    public void CallWriteEndRoot();
    public void CallWriteStartElement(GenerateNameType nameType, bool callChk);
    public void CallWriteEndElement(GenerateNameType nameType, bool callChk);
    public void CallStartElementContent();
    public void CallWriteStartAttribute(GenerateNameType nameType, bool callChk);
    public void CallWriteEndAttribute(bool callChk);
    public void CallWriteNamespaceDecl(bool callChk);
    public void CallWriteString(bool disableOutputEscaping, bool callChk);
    public void CallWriteStartPI();
    public void CallWriteEndPI();
    public void CallWriteStartComment();
    public void CallWriteEndComment();
    public void CallCacheCount(Type itemStorageType);
    public void CallCacheItem(Type itemStorageType);
    public void CallValueAs(Type clrType);
    public void AddSortKey(XmlQueryType keyType);
    public void DebugStartScope();
    public void DebugEndScope();
    public void DebugSequencePoint(ISourceLineInfo sourceInfo);
    public Label DefineLabel();
    public void MarkLabel(Label lbl);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, byte byteVal);
    public void Emit(OpCode opcode, ConstructorInfo constrInfo);
    public void Emit(OpCode opcode, double dblVal);
    public void Emit(OpCode opcode, float fltVal);
    public void Emit(OpCode opcode, FieldInfo fldInfo);
    public void Emit(OpCode opcode, short shrtVal);
    public void Emit(OpCode opcode, int intVal);
    public void Emit(OpCode opcode, long longVal);
    public void Emit(OpCode opcode, Label lblVal);
    public void Emit(OpCode opcode, Label[] arrLabels);
    public void Emit(OpCode opcode, LocalBuilder locBldr);
    public void Emit(OpCode opcode, MethodInfo methInfo);
    public void Emit(OpCode opcode, sbyte sbyteVal);
    public void Emit(OpCode opcode, string strVal);
    public void Emit(OpCode opcode, Type typVal);
    public void EmitUnconditionalBranch(OpCode opcode, Label lblTarget);
}
internal enum System.Xml.Xsl.IlGen.GenerateNameType : Enum {
    public int value__;
    public static GenerateNameType LiteralLocalName;
    public static GenerateNameType LiteralName;
    public static GenerateNameType CopiedName;
    public static GenerateNameType TagNameAndMappings;
    public static GenerateNameType TagNameAndNamespace;
    public static GenerateNameType QName;
    public static GenerateNameType StackName;
}
internal enum System.Xml.Xsl.IlGen.ItemLocation : Enum {
    public int value__;
    public static ItemLocation None;
    public static ItemLocation Stack;
    public static ItemLocation Parameter;
    public static ItemLocation Local;
    public static ItemLocation Current;
    public static ItemLocation Global;
}
internal class System.Xml.Xsl.IlGen.IteratorDescriptor : object {
    public IteratorDescriptor ParentIterator { get; }
    public bool HasLabelNext { get; }
    public LocalBuilder LocalPosition { get; public set; }
    public bool IsBranching { get; }
    public Label LabelBranch { get; }
    public BranchingContext CurrentBranchingContext { get; }
    public StorageDescriptor Storage { get; public set; }
    public IteratorDescriptor(GenerateHelper helper);
    public IteratorDescriptor(IteratorDescriptor iterParent);
    public IteratorDescriptor get_ParentIterator();
    public bool get_HasLabelNext();
    public Label GetLabelNext();
    public void SetIterator(Label lblNext, StorageDescriptor storage);
    public void SetIterator(IteratorDescriptor iterInfo);
    public void LoopToEnd(Label lblOnEnd);
    public LocalBuilder get_LocalPosition();
    public void set_LocalPosition(LocalBuilder value);
    public void CacheCount();
    public void EnsureNoCache();
    public void SetBranching(BranchingContext brctxt, Label lblBranch);
    public bool get_IsBranching();
    public Label get_LabelBranch();
    public BranchingContext get_CurrentBranchingContext();
    public StorageDescriptor get_Storage();
    public void set_Storage(StorageDescriptor value);
    public void PushValue();
    public void EnsureStack();
    public void EnsureNoStack(string locName);
    public void EnsureLocal(string locName);
    public void EnsureLocal(LocalBuilder bldr);
    public void DiscardStack();
    public void EnsureStackNoCache();
    public void EnsureNoStackNoCache(string locName);
    public void EnsureLocalNoCache(string locName);
    public void EnsureLocalNoCache(LocalBuilder bldr);
    public void EnsureItemStorageType(XmlQueryType xmlType, Type storageTypeDest);
}
internal enum System.Xml.Xsl.IlGen.OptimizerPatternArgument : Enum {
    public int value__;
    public static OptimizerPatternArgument StepNode;
    public static OptimizerPatternArgument StepInput;
    public static OptimizerPatternArgument ElementQName;
    public static OptimizerPatternArgument KindTestType;
    public static OptimizerPatternArgument IndexedNodes;
    public static OptimizerPatternArgument KeyExpression;
    public static OptimizerPatternArgument DodStep;
    public static OptimizerPatternArgument MaxPosition;
    public static OptimizerPatternArgument RtfText;
}
internal enum System.Xml.Xsl.IlGen.OptimizerPatternName : Enum {
    public int value__;
    public static OptimizerPatternName None;
    public static OptimizerPatternName DodReverse;
    public static OptimizerPatternName EqualityIndex;
    public static OptimizerPatternName FilterAttributeKind;
    public static OptimizerPatternName FilterContentKind;
    public static OptimizerPatternName FilterElements;
    public static OptimizerPatternName IsDocOrderDistinct;
    public static OptimizerPatternName IsPositional;
    public static OptimizerPatternName JoinAndDod;
    public static OptimizerPatternName MaxPosition;
    public static OptimizerPatternName SameDepth;
    public static OptimizerPatternName Step;
    public static OptimizerPatternName SingleTextRtf;
    public static OptimizerPatternName Axis;
    public static OptimizerPatternName MaybeSideEffects;
    public static OptimizerPatternName TailCall;
    public static OptimizerPatternName DodMerge;
    public static OptimizerPatternName IsReferenced;
}
internal class System.Xml.Xsl.IlGen.OptimizerPatterns : object {
    public string Name { get; }
    private static OptimizerPatterns();
    public static OptimizerPatterns Read(QilNode nd);
    public static OptimizerPatterns Write(QilNode nd);
    public static void Inherit(QilNode ndSrc, QilNode ndDst, OptimizerPatternName pattern);
    public void AddArgument(OptimizerPatternArgument argId, object arg);
    public object GetArgument(OptimizerPatternArgument argNum);
    public void AddPattern(OptimizerPatternName pattern);
    public bool MatchesPattern(OptimizerPatternName pattern);
    public virtual string get_Name();
    public virtual string ToString();
}
internal enum System.Xml.Xsl.IlGen.PossibleXmlStates : Enum {
    public int value__;
    public static PossibleXmlStates None;
    public static PossibleXmlStates WithinSequence;
    public static PossibleXmlStates EnumAttrs;
    public static PossibleXmlStates WithinContent;
    public static PossibleXmlStates WithinAttr;
    public static PossibleXmlStates WithinComment;
    public static PossibleXmlStates WithinPI;
    public static PossibleXmlStates Any;
}
internal class System.Xml.Xsl.IlGen.StaticDataManager : object {
    public String[] Names { get; }
    public Int32Pair[] NameFilters { get; }
    public StringPair[][] PrefixMappingsList { get; }
    public String[] GlobalNames { get; }
    public EarlyBoundInfo[] EarlyBound { get; }
    public XmlQueryType[] XmlTypes { get; }
    public XmlCollation[] Collations { get; }
    public int DeclareName(string name);
    public String[] get_Names();
    public int DeclareNameFilter(string locName, string nsUri);
    public Int32Pair[] get_NameFilters();
    public int DeclarePrefixMappings(IList`1<QilNode> list);
    public StringPair[][] get_PrefixMappingsList();
    public int DeclareGlobalValue(string name);
    public String[] get_GlobalNames();
    public int DeclareEarlyBound(string namespaceUri, Type ebType);
    public EarlyBoundInfo[] get_EarlyBound();
    public int DeclareXmlType(XmlQueryType type);
    public XmlQueryType[] get_XmlTypes();
    public int DeclareCollation(string collation);
    public XmlCollation[] get_Collations();
}
internal class System.Xml.Xsl.IlGen.StorageDescriptor : ValueType {
    private ItemLocation location;
    private object locationObject;
    private Type itemStorageType;
    private bool isCached;
    public ItemLocation Location { get; }
    public int ParameterLocation { get; }
    public LocalBuilder LocalLocation { get; }
    public LocalBuilder CurrentLocation { get; }
    public MethodInfo GlobalLocation { get; }
    public bool IsCached { get; }
    public Type ItemStorageType { get; }
    public static StorageDescriptor None();
    public static StorageDescriptor Stack(Type itemStorageType, bool isCached);
    public static StorageDescriptor Parameter(int paramIndex, Type itemStorageType, bool isCached);
    public static StorageDescriptor Local(LocalBuilder loc, Type itemStorageType, bool isCached);
    public static StorageDescriptor Current(LocalBuilder locIter, Type itemStorageType);
    public static StorageDescriptor Global(MethodInfo methGlobal, Type itemStorageType, bool isCached);
    public StorageDescriptor ToStack();
    public StorageDescriptor ToLocal(LocalBuilder loc);
    public StorageDescriptor ToStorageType(Type itemStorageType);
    public ItemLocation get_Location();
    public int get_ParameterLocation();
    public LocalBuilder get_LocalLocation();
    public LocalBuilder get_CurrentLocation();
    public MethodInfo get_GlobalLocation();
    public bool get_IsCached();
    public Type get_ItemStorageType();
}
internal static class System.Xml.Xsl.IlGen.TailCallAnalyzer : object {
    public static void Analyze(QilExpression qil);
}
internal class System.Xml.Xsl.IlGen.UniqueList`1 : object {
    public int Add(T value);
    public T[] ToArray();
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.IlGen.XmlILAnnotation : ListBase`1<object> {
    public MethodInfo FunctionBinding { get; public set; }
    public int ArgumentPosition { get; public set; }
    public IteratorDescriptor CachedIteratorDescriptor { get; public set; }
    public XmlILConstructInfo ConstructInfo { get; public set; }
    public OptimizerPatterns Patterns { get; public set; }
    public int Count { get; }
    public object Item { get; public set; }
    public static XmlILAnnotation Write(QilNode nd);
    public MethodInfo get_FunctionBinding();
    public void set_FunctionBinding(MethodInfo value);
    public int get_ArgumentPosition();
    public void set_ArgumentPosition(int value);
    public IteratorDescriptor get_CachedIteratorDescriptor();
    public void set_CachedIteratorDescriptor(IteratorDescriptor value);
    public XmlILConstructInfo get_ConstructInfo();
    public void set_ConstructInfo(XmlILConstructInfo value);
    public OptimizerPatterns get_Patterns();
    public void set_Patterns(OptimizerPatterns value);
    public virtual int get_Count();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
}
internal class System.Xml.Xsl.IlGen.XmlILConstructInfo : object {
    public PossibleXmlStates InitialStates { get; public set; }
    public PossibleXmlStates FinalStates { get; public set; }
    unknown PossibleXmlStates BeginLoopStates {public set; }
    unknown PossibleXmlStates EndLoopStates {public set; }
    public XmlILConstructMethod ConstructMethod { get; public set; }
    public bool PushToWriterFirst { get; public set; }
    public bool PushToWriterLast { get; public set; }
    public bool PullFromIteratorFirst { get; public set; }
    unknown XmlILConstructInfo ParentInfo {public set; }
    public XmlILConstructInfo ParentElementInfo { get; }
    public bool IsNamespaceInScope { get; public set; }
    public bool MightHaveNamespaces { get; public set; }
    public bool MightHaveNamespacesAfterAttributes { get; public set; }
    public bool MightHaveAttributes { get; public set; }
    public bool MightHaveDuplicateAttributes { get; public set; }
    public ArrayList CallersInfo { get; }
    public string Name { get; }
    public static XmlILConstructInfo Read(QilNode nd);
    public static XmlILConstructInfo Write(QilNode nd);
    public PossibleXmlStates get_InitialStates();
    public void set_InitialStates(PossibleXmlStates value);
    public PossibleXmlStates get_FinalStates();
    public void set_FinalStates(PossibleXmlStates value);
    public void set_BeginLoopStates(PossibleXmlStates value);
    public void set_EndLoopStates(PossibleXmlStates value);
    public XmlILConstructMethod get_ConstructMethod();
    public void set_ConstructMethod(XmlILConstructMethod value);
    public bool get_PushToWriterFirst();
    public void set_PushToWriterFirst(bool value);
    public bool get_PushToWriterLast();
    public void set_PushToWriterLast(bool value);
    public bool get_PullFromIteratorFirst();
    public void set_PullFromIteratorFirst(bool value);
    public void set_ParentInfo(XmlILConstructInfo value);
    public XmlILConstructInfo get_ParentElementInfo();
    public bool get_IsNamespaceInScope();
    public void set_IsNamespaceInScope(bool value);
    public bool get_MightHaveNamespaces();
    public void set_MightHaveNamespaces(bool value);
    public bool get_MightHaveNamespacesAfterAttributes();
    public void set_MightHaveNamespacesAfterAttributes(bool value);
    public bool get_MightHaveAttributes();
    public void set_MightHaveAttributes(bool value);
    public bool get_MightHaveDuplicateAttributes();
    public void set_MightHaveDuplicateAttributes(bool value);
    public ArrayList get_CallersInfo();
    public virtual string get_Name();
    public virtual string ToString();
}
internal enum System.Xml.Xsl.IlGen.XmlILConstructMethod : Enum {
    public int value__;
    public static XmlILConstructMethod Iterator;
    public static XmlILConstructMethod Writer;
    public static XmlILConstructMethod WriterThenIterator;
    public static XmlILConstructMethod IteratorThenWriter;
}
internal static class System.Xml.Xsl.IlGen.XmlILConstructors : object {
    public static ConstructorInfo DecFromParts;
    public static ConstructorInfo DecFromInt32;
    public static ConstructorInfo DecFromInt64;
    public static ConstructorInfo Debuggable;
    public static ConstructorInfo NonUserCode;
    public static ConstructorInfo QName;
    public static ConstructorInfo StepThrough;
    public static ConstructorInfo Transparent;
    private static XmlILConstructors();
}
internal class System.Xml.Xsl.IlGen.XmlILElementAnalyzer : XmlILStateAnalyzer {
    public XmlILElementAnalyzer(QilFactory fac);
    public virtual QilNode Analyze(QilNode ndElem, QilNode ndContent);
    protected virtual void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info);
    protected virtual void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info);
}
internal enum System.Xml.Xsl.IlGen.XmlILMethodAttributes : Enum {
    public int value__;
    public static XmlILMethodAttributes None;
    public static XmlILMethodAttributes NonUser;
    public static XmlILMethodAttributes Raw;
}
internal static class System.Xml.Xsl.IlGen.XmlILMethods : object {
    public static MethodInfo AncCreate;
    public static MethodInfo AncNext;
    public static MethodInfo AncDOCreate;
    public static MethodInfo AncDONext;
    public static MethodInfo AttrContentCreate;
    public static MethodInfo AttrContentNext;
    public static MethodInfo AttrCreate;
    public static MethodInfo AttrNext;
    public static MethodInfo ContentCreate;
    public static MethodInfo ContentNext;
    public static MethodInfo ContentMergeCreate;
    public static MethodInfo ContentMergeNext;
    public static MethodInfo DescCreate;
    public static MethodInfo DescNext;
    public static MethodInfo DescMergeCreate;
    public static MethodInfo DescMergeNext;
    public static MethodInfo DiffCreate;
    public static MethodInfo DiffNext;
    public static MethodInfo DodMergeCreate;
    public static MethodInfo DodMergeAdd;
    public static MethodInfo DodMergeSeq;
    public static MethodInfo ElemContentCreate;
    public static MethodInfo ElemContentNext;
    public static MethodInfo FollSibCreate;
    public static MethodInfo FollSibNext;
    public static MethodInfo FollSibMergeCreate;
    public static MethodInfo FollSibMergeNext;
    public static MethodInfo IdCreate;
    public static MethodInfo IdNext;
    public static MethodInfo InterCreate;
    public static MethodInfo InterNext;
    public static MethodInfo KindContentCreate;
    public static MethodInfo KindContentNext;
    public static MethodInfo NmspCreate;
    public static MethodInfo NmspNext;
    public static MethodInfo NodeRangeCreate;
    public static MethodInfo NodeRangeNext;
    public static MethodInfo ParentCreate;
    public static MethodInfo ParentNext;
    public static MethodInfo PrecCreate;
    public static MethodInfo PrecNext;
    public static MethodInfo PreSibCreate;
    public static MethodInfo PreSibNext;
    public static MethodInfo PreSibDOCreate;
    public static MethodInfo PreSibDONext;
    public static MethodInfo SortKeyCreate;
    public static MethodInfo SortKeyDateTime;
    public static MethodInfo SortKeyDecimal;
    public static MethodInfo SortKeyDouble;
    public static MethodInfo SortKeyEmpty;
    public static MethodInfo SortKeyFinish;
    public static MethodInfo SortKeyInt;
    public static MethodInfo SortKeyInteger;
    public static MethodInfo SortKeyKeys;
    public static MethodInfo SortKeyString;
    public static MethodInfo UnionCreate;
    public static MethodInfo UnionNext;
    public static MethodInfo XPFollCreate;
    public static MethodInfo XPFollNext;
    public static MethodInfo XPFollMergeCreate;
    public static MethodInfo XPFollMergeNext;
    public static MethodInfo XPPrecCreate;
    public static MethodInfo XPPrecNext;
    public static MethodInfo XPPrecDOCreate;
    public static MethodInfo XPPrecDONext;
    public static MethodInfo XPPrecMergeCreate;
    public static MethodInfo XPPrecMergeNext;
    public static MethodInfo AddNewIndex;
    public static MethodInfo ChangeTypeXsltArg;
    public static MethodInfo ChangeTypeXsltResult;
    public static MethodInfo CompPos;
    public static MethodInfo Context;
    public static MethodInfo CreateCollation;
    public static MethodInfo DocOrder;
    public static MethodInfo EndRtfConstr;
    public static MethodInfo EndSeqConstr;
    public static MethodInfo FindIndex;
    public static MethodInfo GenId;
    public static MethodInfo GetAtomizedName;
    public static MethodInfo GetCollation;
    public static MethodInfo GetEarly;
    public static MethodInfo GetNameFilter;
    public static MethodInfo GetOutput;
    public static MethodInfo GetGlobalValue;
    public static MethodInfo GetTypeFilter;
    public static MethodInfo GlobalComputed;
    public static MethodInfo ItemMatchesCode;
    public static MethodInfo ItemMatchesType;
    public static MethodInfo QNameEqualLit;
    public static MethodInfo QNameEqualNav;
    public static MethodInfo RtfConstr;
    public static MethodInfo SendMessage;
    public static MethodInfo SeqMatchesCode;
    public static MethodInfo SeqMatchesType;
    public static MethodInfo SetGlobalValue;
    public static MethodInfo StartRtfConstr;
    public static MethodInfo StartSeqConstr;
    public static MethodInfo TagAndMappings;
    public static MethodInfo TagAndNamespace;
    public static MethodInfo ThrowException;
    public static MethodInfo XsltLib;
    public static MethodInfo GetDataSource;
    public static MethodInfo GetDefaultDataSource;
    public static MethodInfo GetParam;
    public static MethodInfo InvokeXsltLate;
    public static MethodInfo IndexAdd;
    public static MethodInfo IndexLookup;
    public static MethodInfo ItemIsNode;
    public static MethodInfo Value;
    public static MethodInfo ValueAsAny;
    public static MethodInfo NavClone;
    public static MethodInfo NavLocalName;
    public static MethodInfo NavMoveAttr;
    public static MethodInfo NavMoveId;
    public static MethodInfo NavMoveParent;
    public static MethodInfo NavMoveRoot;
    public static MethodInfo NavMoveTo;
    public static MethodInfo NavNmsp;
    public static MethodInfo NavPrefix;
    public static MethodInfo NavSamePos;
    public static MethodInfo NavType;
    public static MethodInfo StartElemLitName;
    public static MethodInfo StartElemLocName;
    public static MethodInfo EndElemStackName;
    public static MethodInfo StartAttrLitName;
    public static MethodInfo StartAttrLocName;
    public static MethodInfo EndAttr;
    public static MethodInfo Text;
    public static MethodInfo NoEntText;
    public static MethodInfo StartTree;
    public static MethodInfo EndTree;
    public static MethodInfo StartElemLitNameUn;
    public static MethodInfo StartElemLocNameUn;
    public static MethodInfo StartContentUn;
    public static MethodInfo EndElemLitNameUn;
    public static MethodInfo EndElemLocNameUn;
    public static MethodInfo StartAttrLitNameUn;
    public static MethodInfo StartAttrLocNameUn;
    public static MethodInfo EndAttrUn;
    public static MethodInfo NamespaceDeclUn;
    public static MethodInfo TextUn;
    public static MethodInfo NoEntTextUn;
    public static MethodInfo StartRoot;
    public static MethodInfo EndRoot;
    public static MethodInfo StartElemCopyName;
    public static MethodInfo StartElemMapName;
    public static MethodInfo StartElemNmspName;
    public static MethodInfo StartElemQName;
    public static MethodInfo StartAttrCopyName;
    public static MethodInfo StartAttrMapName;
    public static MethodInfo StartAttrNmspName;
    public static MethodInfo StartAttrQName;
    public static MethodInfo NamespaceDecl;
    public static MethodInfo StartComment;
    public static MethodInfo CommentText;
    public static MethodInfo EndComment;
    public static MethodInfo StartPI;
    public static MethodInfo PIText;
    public static MethodInfo EndPI;
    public static MethodInfo WriteItem;
    public static MethodInfo CopyOf;
    public static MethodInfo StartCopy;
    public static MethodInfo EndCopy;
    public static MethodInfo DecAdd;
    public static MethodInfo DecCmp;
    public static MethodInfo DecEq;
    public static MethodInfo DecSub;
    public static MethodInfo DecMul;
    public static MethodInfo DecDiv;
    public static MethodInfo DecRem;
    public static MethodInfo DecNeg;
    public static MethodInfo QNameEq;
    public static MethodInfo StrEq;
    public static MethodInfo StrCat2;
    public static MethodInfo StrCat3;
    public static MethodInfo StrCat4;
    public static MethodInfo StrCmp;
    public static MethodInfo StrLen;
    public static MethodInfo DblToDec;
    public static MethodInfo DblToInt;
    public static MethodInfo DblToLng;
    public static MethodInfo DblToStr;
    public static MethodInfo DecToDbl;
    public static MethodInfo DTToStr;
    public static MethodInfo IntToDbl;
    public static MethodInfo LngToDbl;
    public static MethodInfo StrToDbl;
    public static MethodInfo StrToDT;
    public static MethodInfo ItemToBool;
    public static MethodInfo ItemToDbl;
    public static MethodInfo ItemToStr;
    public static MethodInfo ItemToNode;
    public static MethodInfo ItemToNodes;
    public static MethodInfo ItemsToBool;
    public static MethodInfo ItemsToDbl;
    public static MethodInfo ItemsToNode;
    public static MethodInfo ItemsToNodes;
    public static MethodInfo ItemsToStr;
    public static MethodInfo StrCatCat;
    public static MethodInfo StrCatClear;
    public static MethodInfo StrCatResult;
    public static MethodInfo StrCatDelim;
    public static MethodInfo NavsToItems;
    public static MethodInfo ItemsToNavs;
    public static MethodInfo SetDod;
    public static MethodInfo GetTypeFromHandle;
    public static MethodInfo InitializeArray;
    public static Dictionary`2<Type, XmlILStorageMethods> StorageMethods;
    private static XmlILMethods();
    public static MethodInfo GetMethod(Type className, string methName);
    public static MethodInfo GetMethod(Type className, string methName, Type[] args);
}
internal class System.Xml.Xsl.IlGen.XmlILModule : object {
    public static PermissionSet CreateModulePermissionSet;
    public bool EmitSymbols { get; }
    private static XmlILModule();
    public XmlILModule(TypeBuilder typeBldr);
    public XmlILModule(bool useLRE, bool emitSymbols);
    public bool get_EmitSymbols();
    public MethodInfo DefineMethod(string name, Type returnType, Type[] paramTypes, String[] paramNames, XmlILMethodAttributes xmlAttrs);
    public static ILGenerator DefineMethodBody(MethodBase methInfo);
    public MethodInfo FindMethod(string name);
    public FieldInfo DefineInitializedData(string name, Byte[] data);
    public FieldInfo DefineField(string fieldName, Type type);
    public ConstructorInfo DefineTypeInitializer();
    public ISymbolDocumentWriter AddSourceDocument(string fileName);
    public void BakeMethods();
    public Delegate CreateDelegate(string name, Type typDelegate);
}
internal class System.Xml.Xsl.IlGen.XmlILNamespaceAnalyzer : object {
    public void Analyze(QilNode nd, bool defaultNmspInScope);
}
internal enum System.Xml.Xsl.IlGen.XmlILOptimization : Enum {
    public int value__;
    public static XmlILOptimization None;
    public static XmlILOptimization EliminateLiteralVariables;
    public static XmlILOptimization TailCall;
    public static XmlILOptimization AnnotateAncestor;
    public static XmlILOptimization AnnotateAncestorSelf;
    public static XmlILOptimization AnnotateAttribute;
    public static XmlILOptimization AnnotateAttrNmspLoop;
    public static XmlILOptimization AnnotateBarrier;
    public static XmlILOptimization AnnotateConstruction;
    public static XmlILOptimization AnnotateContent;
    public static XmlILOptimization AnnotateContentLoop;
    public static XmlILOptimization AnnotateDescendant;
    public static XmlILOptimization AnnotateDescendantLoop;
    public static XmlILOptimization AnnotateDescendantSelf;
    public static XmlILOptimization AnnotateDifference;
    public static XmlILOptimization AnnotateDod;
    public static XmlILOptimization AnnotateDodMerge;
    public static XmlILOptimization AnnotateDodReverse;
    public static XmlILOptimization AnnotateFilter;
    public static XmlILOptimization AnnotateFilterAttributeKind;
    public static XmlILOptimization AnnotateFilterContentKind;
    public static XmlILOptimization AnnotateFilterElements;
    public static XmlILOptimization AnnotateFollowingSibling;
    public static XmlILOptimization AnnotateIndex1;
    public static XmlILOptimization AnnotateIndex2;
    public static XmlILOptimization AnnotateIntersect;
    public static XmlILOptimization AnnotateInvoke;
    public static XmlILOptimization AnnotateJoinAndDod;
    public static XmlILOptimization AnnotateLet;
    public static XmlILOptimization AnnotateMaxLengthEq;
    public static XmlILOptimization AnnotateMaxLengthGe;
    public static XmlILOptimization AnnotateMaxLengthGt;
    public static XmlILOptimization AnnotateMaxLengthLe;
    public static XmlILOptimization AnnotateMaxLengthLt;
    public static XmlILOptimization AnnotateMaxLengthNe;
    public static XmlILOptimization AnnotateMaxPositionEq;
    public static XmlILOptimization AnnotateMaxPositionLe;
    public static XmlILOptimization AnnotateMaxPositionLt;
    public static XmlILOptimization AnnotateNamespace;
    public static XmlILOptimization AnnotateNodeRange;
    public static XmlILOptimization AnnotateParent;
    public static XmlILOptimization AnnotatePositionalIterator;
    public static XmlILOptimization AnnotatePreceding;
    public static XmlILOptimization AnnotatePrecedingSibling;
    public static XmlILOptimization AnnotateRoot;
    public static XmlILOptimization AnnotateRootLoop;
    public static XmlILOptimization AnnotateSingleTextRtf;
    public static XmlILOptimization AnnotateSingletonLoop;
    public static XmlILOptimization AnnotateTrackCallers;
    public static XmlILOptimization AnnotateUnion;
    public static XmlILOptimization AnnotateUnionContent;
    public static XmlILOptimization AnnotateXPathFollowing;
    public static XmlILOptimization AnnotateXPathPreceding;
    public static XmlILOptimization CommuteDodFilter;
    public static XmlILOptimization CommuteFilterLoop;
    public static XmlILOptimization EliminateAdd;
    public static XmlILOptimization EliminateAfter;
    public static XmlILOptimization EliminateAnd;
    public static XmlILOptimization EliminateAverage;
    public static XmlILOptimization EliminateBefore;
    public static XmlILOptimization EliminateConditional;
    public static XmlILOptimization EliminateDifference;
    public static XmlILOptimization EliminateDivide;
    public static XmlILOptimization EliminateDod;
    public static XmlILOptimization EliminateEq;
    public static XmlILOptimization EliminateFilter;
    public static XmlILOptimization EliminateGe;
    public static XmlILOptimization EliminateGt;
    public static XmlILOptimization EliminateIntersection;
    public static XmlILOptimization EliminateIs;
    public static XmlILOptimization EliminateIsEmpty;
    public static XmlILOptimization EliminateIsType;
    public static XmlILOptimization EliminateIterator;
    public static XmlILOptimization EliminateIteratorUsedAtMostOnce;
    public static XmlILOptimization EliminateLe;
    public static XmlILOptimization EliminateLength;
    public static XmlILOptimization EliminateLoop;
    public static XmlILOptimization EliminateLt;
    public static XmlILOptimization EliminateMaximum;
    public static XmlILOptimization EliminateMinimum;
    public static XmlILOptimization EliminateModulo;
    public static XmlILOptimization EliminateMultiply;
    public static XmlILOptimization EliminateNamespaceDecl;
    public static XmlILOptimization EliminateNe;
    public static XmlILOptimization EliminateNegate;
    public static XmlILOptimization EliminateNop;
    public static XmlILOptimization EliminateNot;
    public static XmlILOptimization EliminateOr;
    public static XmlILOptimization EliminatePositionOf;
    public static XmlILOptimization EliminateReturnDod;
    public static XmlILOptimization EliminateSequence;
    public static XmlILOptimization EliminateSort;
    public static XmlILOptimization EliminateStrConcat;
    public static XmlILOptimization EliminateStrConcatSingle;
    public static XmlILOptimization EliminateStrLength;
    public static XmlILOptimization EliminateSubtract;
    public static XmlILOptimization EliminateSum;
    public static XmlILOptimization EliminateTypeAssert;
    public static XmlILOptimization EliminateTypeAssertOptional;
    public static XmlILOptimization EliminateUnion;
    public static XmlILOptimization EliminateUnusedGlobals;
    public static XmlILOptimization EliminateXsltConvert;
    public static XmlILOptimization FoldConditionalNot;
    public static XmlILOptimization FoldNamedDescendants;
    public static XmlILOptimization FoldNone;
    public static XmlILOptimization FoldXsltConvertLiteral;
    public static XmlILOptimization IntroduceDod;
    public static XmlILOptimization IntroducePrecedingDod;
    public static XmlILOptimization NormalizeAddEq;
    public static XmlILOptimization NormalizeAddLiteral;
    public static XmlILOptimization NormalizeAttribute;
    public static XmlILOptimization NormalizeConditionalText;
    public static XmlILOptimization NormalizeDifference;
    public static XmlILOptimization NormalizeEqLiteral;
    public static XmlILOptimization NormalizeGeLiteral;
    public static XmlILOptimization NormalizeGtLiteral;
    public static XmlILOptimization NormalizeIdEq;
    public static XmlILOptimization NormalizeIdNe;
    public static XmlILOptimization NormalizeIntersect;
    public static XmlILOptimization NormalizeInvokeEmpty;
    public static XmlILOptimization NormalizeLeLiteral;
    public static XmlILOptimization NormalizeLengthGt;
    public static XmlILOptimization NormalizeLengthNe;
    public static XmlILOptimization NormalizeLoopConditional;
    public static XmlILOptimization NormalizeLoopInvariant;
    public static XmlILOptimization NormalizeLoopLoop;
    public static XmlILOptimization NormalizeLoopText;
    public static XmlILOptimization NormalizeLtLiteral;
    public static XmlILOptimization NormalizeMuenchian;
    public static XmlILOptimization NormalizeMultiplyLiteral;
    public static XmlILOptimization NormalizeNeLiteral;
    public static XmlILOptimization NormalizeNestedSequences;
    public static XmlILOptimization NormalizeSingletonLet;
    public static XmlILOptimization NormalizeSortXsltConvert;
    public static XmlILOptimization NormalizeUnion;
    public static XmlILOptimization NormalizeXsltConvertEq;
    public static XmlILOptimization NormalizeXsltConvertGe;
    public static XmlILOptimization NormalizeXsltConvertGt;
    public static XmlILOptimization NormalizeXsltConvertLe;
    public static XmlILOptimization NormalizeXsltConvertLt;
    public static XmlILOptimization NormalizeXsltConvertNe;
    public static XmlILOptimization Last_;
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.IlGen.XmlILOptimizerVisitor : QilPatternVisitor {
    private static XmlILOptimizerVisitor();
    public XmlILOptimizerVisitor(QilExpression qil, bool optimize);
    public QilExpression Optimize();
    protected virtual QilNode Visit(QilNode nd);
    protected virtual QilNode VisitReference(QilNode oldNode);
    protected bool AllowReplace(XmlILOptimization pattern, QilNode original);
    protected QilNode Replace(XmlILOptimization pattern, QilNode original, QilNode replacement);
    protected virtual QilNode NoReplace(QilNode node);
    protected virtual void RecalculateType(QilNode node, XmlQueryType oldType);
    protected virtual QilNode VisitQilExpression(QilExpression local0);
    protected virtual QilNode VisitOptimizeBarrier(QilUnary local0);
    protected virtual QilNode VisitDataSource(QilDataSource local0);
    protected virtual QilNode VisitNop(QilUnary local0);
    protected virtual QilNode VisitError(QilUnary local0);
    protected virtual QilNode VisitWarning(QilUnary local0);
    protected virtual QilNode VisitLet(QilIterator local0);
    protected virtual QilNode VisitPositionOf(QilUnary local0);
    protected virtual QilNode VisitAnd(QilBinary local0);
    protected virtual QilNode VisitOr(QilBinary local0);
    protected virtual QilNode VisitNot(QilUnary local0);
    protected virtual QilNode VisitConditional(QilTernary local0);
    protected virtual QilNode VisitChoice(QilChoice local0);
    protected virtual QilNode VisitLength(QilUnary local0);
    protected virtual QilNode VisitSequence(QilList local0);
    protected virtual QilNode VisitUnion(QilBinary local0);
    protected virtual QilNode VisitIntersection(QilBinary local0);
    protected virtual QilNode VisitDifference(QilBinary local0);
    protected virtual QilNode VisitAverage(QilUnary local0);
    protected virtual QilNode VisitSum(QilUnary local0);
    protected virtual QilNode VisitMinimum(QilUnary local0);
    protected virtual QilNode VisitMaximum(QilUnary local0);
    protected virtual QilNode VisitNegate(QilUnary local0);
    protected virtual QilNode VisitAdd(QilBinary local0);
    protected virtual QilNode VisitSubtract(QilBinary local0);
    protected virtual QilNode VisitMultiply(QilBinary local0);
    protected virtual QilNode VisitDivide(QilBinary local0);
    protected virtual QilNode VisitModulo(QilBinary local0);
    protected virtual QilNode VisitStrLength(QilUnary local0);
    protected virtual QilNode VisitStrConcat(QilStrConcat local0);
    protected virtual QilNode VisitStrParseQName(QilBinary local0);
    protected virtual QilNode VisitNe(QilBinary local0);
    protected virtual QilNode VisitEq(QilBinary local0);
    protected virtual QilNode VisitGt(QilBinary local0);
    protected virtual QilNode VisitGe(QilBinary local0);
    protected virtual QilNode VisitLt(QilBinary local0);
    protected virtual QilNode VisitLe(QilBinary local0);
    protected virtual QilNode VisitIs(QilBinary local0);
    protected virtual QilNode VisitAfter(QilBinary local0);
    protected virtual QilNode VisitBefore(QilBinary local0);
    protected virtual QilNode VisitLoop(QilLoop local0);
    protected virtual QilNode VisitFilter(QilLoop local0);
    protected virtual QilNode VisitSort(QilLoop local0);
    protected virtual QilNode VisitSortKey(QilSortKey local0);
    protected virtual QilNode VisitDocOrderDistinct(QilUnary local0);
    protected virtual QilNode VisitFunction(QilFunction local0);
    protected virtual QilNode VisitInvoke(QilInvoke local0);
    protected virtual QilNode VisitContent(QilUnary local0);
    protected virtual QilNode VisitAttribute(QilBinary local0);
    protected virtual QilNode VisitParent(QilUnary local0);
    protected virtual QilNode VisitRoot(QilUnary local0);
    protected virtual QilNode VisitDescendant(QilUnary local0);
    protected virtual QilNode VisitDescendantOrSelf(QilUnary local0);
    protected virtual QilNode VisitAncestor(QilUnary local0);
    protected virtual QilNode VisitAncestorOrSelf(QilUnary local0);
    protected virtual QilNode VisitPreceding(QilUnary local0);
    protected virtual QilNode VisitFollowingSibling(QilUnary local0);
    protected virtual QilNode VisitPrecedingSibling(QilUnary local0);
    protected virtual QilNode VisitNodeRange(QilBinary local0);
    protected virtual QilNode VisitDeref(QilBinary local0);
    protected virtual QilNode VisitElementCtor(QilBinary local0);
    protected virtual QilNode VisitAttributeCtor(QilBinary local0);
    protected virtual QilNode VisitCommentCtor(QilUnary local0);
    protected virtual QilNode VisitPICtor(QilBinary local0);
    protected virtual QilNode VisitTextCtor(QilUnary local0);
    protected virtual QilNode VisitRawTextCtor(QilUnary local0);
    protected virtual QilNode VisitDocumentCtor(QilUnary local0);
    protected virtual QilNode VisitNamespaceDecl(QilBinary local0);
    protected virtual QilNode VisitRtfCtor(QilBinary local0);
    protected virtual QilNode VisitNameOf(QilUnary local0);
    protected virtual QilNode VisitLocalNameOf(QilUnary local0);
    protected virtual QilNode VisitNamespaceUriOf(QilUnary local0);
    protected virtual QilNode VisitPrefixOf(QilUnary local0);
    protected virtual QilNode VisitTypeAssert(QilTargetType local0);
    protected virtual QilNode VisitIsType(QilTargetType local0);
    protected virtual QilNode VisitIsEmpty(QilUnary local0);
    protected virtual QilNode VisitXPathNodeValue(QilUnary local0);
    protected virtual QilNode VisitXPathFollowing(QilUnary local0);
    protected virtual QilNode VisitXPathPreceding(QilUnary local0);
    protected virtual QilNode VisitXPathNamespace(QilUnary local0);
    protected virtual QilNode VisitXsltGenerateId(QilUnary local0);
    protected virtual QilNode VisitXsltCopy(QilBinary local0);
    protected virtual QilNode VisitXsltCopyOf(QilUnary local0);
    protected virtual QilNode VisitXsltConvert(QilTargetType local0);
    protected bool NonPositional(QilNode expr, QilNode iter);
}
internal class System.Xml.Xsl.IlGen.XmlILStateAnalyzer : object {
    protected XmlILConstructInfo parentInfo;
    protected QilFactory fac;
    protected PossibleXmlStates xstates;
    protected bool withinElem;
    public XmlILStateAnalyzer(QilFactory fac);
    public virtual QilNode Analyze(QilNode ndConstr, QilNode ndContent);
    protected virtual QilNode AnalyzeContent(QilNode nd);
    protected virtual void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info);
    protected virtual void AnalyzeSequence(QilList ndSeq, XmlILConstructInfo info);
    protected virtual void AnalyzeConditional(QilTernary ndCond, XmlILConstructInfo info);
    protected virtual void AnalyzeChoice(QilChoice ndChoice, XmlILConstructInfo info);
    protected virtual void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info);
}
internal class System.Xml.Xsl.IlGen.XmlILStorageMethods : object {
    public MethodInfo AggAvg;
    public MethodInfo AggAvgResult;
    public MethodInfo AggCreate;
    public MethodInfo AggIsEmpty;
    public MethodInfo AggMax;
    public MethodInfo AggMaxResult;
    public MethodInfo AggMin;
    public MethodInfo AggMinResult;
    public MethodInfo AggSum;
    public MethodInfo AggSumResult;
    public Type SeqType;
    public FieldInfo SeqEmpty;
    public MethodInfo SeqReuse;
    public MethodInfo SeqReuseSgl;
    public MethodInfo SeqAdd;
    public MethodInfo SeqSortByKeys;
    public Type IListType;
    public MethodInfo IListCount;
    public MethodInfo IListItem;
    public MethodInfo ValueAs;
    public MethodInfo ToAtomicValue;
    public XmlILStorageMethods(Type storageType);
}
internal class System.Xml.Xsl.IlGen.XmlILTypeHelper : object {
    private static XmlILTypeHelper();
    public static Type GetStorageType(XmlQueryType qyTyp);
}
internal class System.Xml.Xsl.IlGen.XmlILVisitor : QilVisitor {
    public void Visit(QilExpression qil, GenerateHelper helper, MethodInfo methRoot);
    protected virtual QilNode Visit(QilNode nd);
    protected virtual QilNode VisitChildren(QilNode parent);
    protected virtual QilNode VisitDataSource(QilDataSource ndSrc);
    protected virtual QilNode VisitNop(QilUnary ndNop);
    protected virtual QilNode VisitOptimizeBarrier(QilUnary ndBarrier);
    protected virtual QilNode VisitError(QilUnary ndErr);
    protected virtual QilNode VisitWarning(QilUnary ndWarning);
    protected virtual QilNode VisitTrue(QilNode ndTrue);
    protected virtual QilNode VisitFalse(QilNode ndFalse);
    protected virtual QilNode VisitLiteralString(QilLiteral ndStr);
    protected virtual QilNode VisitLiteralInt32(QilLiteral ndInt);
    protected virtual QilNode VisitLiteralInt64(QilLiteral ndLong);
    protected virtual QilNode VisitLiteralDouble(QilLiteral ndDbl);
    protected virtual QilNode VisitLiteralDecimal(QilLiteral ndDec);
    protected virtual QilNode VisitLiteralQName(QilName ndQName);
    protected virtual QilNode VisitAnd(QilBinary ndAnd);
    protected virtual QilNode VisitOr(QilBinary ndOr);
    protected virtual QilNode VisitNot(QilUnary ndNot);
    protected virtual QilNode VisitConditional(QilTernary ndCond);
    protected virtual QilNode VisitChoice(QilChoice ndChoice);
    protected virtual QilNode VisitLength(QilUnary ndSetLen);
    protected virtual QilNode VisitSequence(QilList ndSeq);
    protected virtual QilNode VisitUnion(QilBinary ndUnion);
    protected virtual QilNode VisitIntersection(QilBinary ndInter);
    protected virtual QilNode VisitDifference(QilBinary ndDiff);
    protected virtual QilNode VisitAverage(QilUnary ndAvg);
    protected virtual QilNode VisitSum(QilUnary ndSum);
    protected virtual QilNode VisitMinimum(QilUnary ndMin);
    protected virtual QilNode VisitMaximum(QilUnary ndMax);
    protected virtual QilNode VisitNegate(QilUnary ndNeg);
    protected virtual QilNode VisitAdd(QilBinary ndPlus);
    protected virtual QilNode VisitSubtract(QilBinary ndMinus);
    protected virtual QilNode VisitMultiply(QilBinary ndMul);
    protected virtual QilNode VisitDivide(QilBinary ndDiv);
    protected virtual QilNode VisitModulo(QilBinary ndMod);
    protected virtual QilNode VisitStrLength(QilUnary ndLen);
    protected virtual QilNode VisitStrConcat(QilStrConcat ndStrConcat);
    protected virtual QilNode VisitStrParseQName(QilBinary ndParsedTagName);
    protected virtual QilNode VisitNe(QilBinary ndNe);
    protected virtual QilNode VisitEq(QilBinary ndEq);
    protected virtual QilNode VisitGt(QilBinary ndGt);
    protected virtual QilNode VisitGe(QilBinary ndGe);
    protected virtual QilNode VisitLt(QilBinary ndLt);
    protected virtual QilNode VisitLe(QilBinary ndLe);
    protected virtual QilNode VisitIs(QilBinary ndIs);
    protected virtual QilNode VisitBefore(QilBinary ndBefore);
    protected virtual QilNode VisitAfter(QilBinary ndAfter);
    protected virtual QilNode VisitFor(QilIterator ndFor);
    protected virtual QilNode VisitLet(QilIterator ndLet);
    protected virtual QilNode VisitParameter(QilParameter ndParameter);
    protected virtual QilNode VisitLoop(QilLoop ndLoop);
    protected virtual QilNode VisitFilter(QilLoop ndFilter);
    public void StartLetBinding(QilIterator ndLet);
    protected virtual QilNode VisitPositionOf(QilUnary ndPos);
    protected virtual QilNode VisitSort(QilLoop ndSort);
    protected virtual QilNode VisitDocOrderDistinct(QilUnary ndDod);
    protected virtual QilNode VisitInvoke(QilInvoke ndInvoke);
    protected virtual QilNode VisitContent(QilUnary ndContent);
    protected virtual QilNode VisitAttribute(QilBinary ndAttr);
    protected virtual QilNode VisitParent(QilUnary ndParent);
    protected virtual QilNode VisitRoot(QilUnary ndRoot);
    protected virtual QilNode VisitXmlContext(QilNode ndCtxt);
    protected virtual QilNode VisitDescendant(QilUnary ndDesc);
    protected virtual QilNode VisitDescendantOrSelf(QilUnary ndDesc);
    protected virtual QilNode VisitAncestor(QilUnary ndAnc);
    protected virtual QilNode VisitAncestorOrSelf(QilUnary ndAnc);
    protected virtual QilNode VisitPreceding(QilUnary ndPrec);
    protected virtual QilNode VisitFollowingSibling(QilUnary ndFollSib);
    protected virtual QilNode VisitPrecedingSibling(QilUnary ndPreSib);
    protected virtual QilNode VisitNodeRange(QilBinary ndRange);
    protected virtual QilNode VisitDeref(QilBinary ndDeref);
    protected virtual QilNode VisitElementCtor(QilBinary ndElem);
    protected virtual QilNode VisitAttributeCtor(QilBinary ndAttr);
    protected virtual QilNode VisitCommentCtor(QilUnary ndComment);
    protected virtual QilNode VisitPICtor(QilBinary ndPI);
    protected virtual QilNode VisitTextCtor(QilUnary ndText);
    protected virtual QilNode VisitRawTextCtor(QilUnary ndText);
    protected virtual QilNode VisitDocumentCtor(QilUnary ndDoc);
    protected virtual QilNode VisitNamespaceDecl(QilBinary ndNmsp);
    protected virtual QilNode VisitRtfCtor(QilBinary ndRtf);
    protected virtual QilNode VisitNameOf(QilUnary ndName);
    protected virtual QilNode VisitLocalNameOf(QilUnary ndName);
    protected virtual QilNode VisitNamespaceUriOf(QilUnary ndName);
    protected virtual QilNode VisitPrefixOf(QilUnary ndName);
    protected virtual QilNode VisitTypeAssert(QilTargetType ndTypeAssert);
    protected virtual QilNode VisitIsType(QilTargetType ndIsType);
    protected virtual QilNode VisitIsEmpty(QilUnary ndIsEmpty);
    protected virtual QilNode VisitXPathNodeValue(QilUnary ndVal);
    protected virtual QilNode VisitXPathFollowing(QilUnary ndFoll);
    protected virtual QilNode VisitXPathPreceding(QilUnary ndPrec);
    protected virtual QilNode VisitXPathNamespace(QilUnary ndNmsp);
    protected virtual QilNode VisitXsltGenerateId(QilUnary ndGenId);
    protected virtual QilNode VisitXsltInvokeLateBound(QilInvokeLateBound ndInvoke);
    protected virtual QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound ndInvoke);
    protected virtual QilNode VisitXsltCopy(QilBinary ndCopy);
    protected virtual QilNode VisitXsltCopyOf(QilUnary ndCopyOf);
    protected virtual QilNode VisitXsltConvert(QilTargetType ndConv);
}
internal class System.Xml.Xsl.IListEnumerator`1 : ValueType {
    private IList`1<T> sequence;
    private int index;
    private T current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public IListEnumerator`1(IList`1<T> sequence);
    public sealed virtual void Dispose();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class System.Xml.Xsl.Int32Pair : ValueType {
    private int left;
    private int right;
    public int Left { get; }
    public int Right { get; }
    public Int32Pair(int left, int right);
    public int get_Left();
    public int get_Right();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal interface System.Xml.Xsl.ISourceLineInfo {
    public string Uri { get; }
    public bool IsNoSource { get; }
    public Location Start { get; }
    public Location End { get; }
    public abstract virtual string get_Uri();
    public abstract virtual bool get_IsNoSource();
    public abstract virtual Location get_Start();
    public abstract virtual Location get_End();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Xml.Xsl.ListBase`1 : object {
    public int Count { get; }
    public T Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void CopyTo(T[] array, int index);
    public virtual IListEnumerator`1<T> GetEnumerator();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual void Add(T value);
    public virtual void Insert(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DebuggerDisplayAttribute("({Line},{Pos})")]
internal class System.Xml.Xsl.Location : ValueType {
    private ulong value;
    public int Line { get; }
    public int Pos { get; }
    public Location(int line, int pos);
    public Location(Location that);
    public int get_Line();
    public int get_Pos();
    public bool LessOrEqual(Location that);
}
internal interface System.Xml.Xsl.Qil.IQilAnnotation {
    public string Name { get; }
    public abstract virtual string get_Name();
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilBinary : QilNode {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilNode Left { get; public set; }
    public QilNode Right { get; public set; }
    public QilBinary(QilNodeType nodeType, QilNode left, QilNode right);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilNode get_Left();
    public void set_Left(QilNode value);
    public QilNode get_Right();
    public void set_Right(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilChoice : QilBinary {
    public QilNode Expression { get; public set; }
    public QilList Branches { get; public set; }
    public QilChoice(QilNodeType nodeType, QilNode expression, QilNode branches);
    public QilNode get_Expression();
    public void set_Expression(QilNode value);
    public QilList get_Branches();
    public void set_Branches(QilList value);
}
internal class System.Xml.Xsl.Qil.QilCloneVisitor : QilScopedVisitor {
    public QilCloneVisitor(QilFactory fac);
    public QilCloneVisitor(QilFactory fac, SubstitutionList subs);
    public QilNode Clone(QilNode node);
    protected virtual QilNode Visit(QilNode oldNode);
    protected virtual QilNode VisitChildren(QilNode parent);
    protected virtual QilNode VisitReference(QilNode oldNode);
    protected virtual void BeginScope(QilNode node);
    protected virtual void EndScope(QilNode node);
    protected QilNode FindClonedReference(QilNode node);
}
internal class System.Xml.Xsl.Qil.QilDataSource : QilBinary {
    public QilNode Name { get; public set; }
    public QilNode BaseUri { get; public set; }
    public QilDataSource(QilNodeType nodeType, QilNode name, QilNode baseUri);
    public QilNode get_Name();
    public void set_Name(QilNode value);
    public QilNode get_BaseUri();
    public void set_BaseUri(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilDepthChecker : object {
    public static void Check(QilNode input);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilExpression : QilNode {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilFactory Factory { get; public set; }
    public bool IsDebug { get; public set; }
    public XmlWriterSettings DefaultWriterSettings { get; public set; }
    public IList`1<WhitespaceRule> WhitespaceRules { get; public set; }
    public QilList GlobalParameterList { get; public set; }
    public QilList GlobalVariableList { get; public set; }
    public IList`1<EarlyBoundInfo> EarlyBoundTypes { get; public set; }
    public QilList FunctionList { get; public set; }
    public QilNode Root { get; public set; }
    public QilExpression(QilNodeType nodeType, QilNode root);
    public QilExpression(QilNodeType nodeType, QilNode root, QilFactory factory);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilFactory get_Factory();
    public void set_Factory(QilFactory value);
    public bool get_IsDebug();
    public void set_IsDebug(bool value);
    public XmlWriterSettings get_DefaultWriterSettings();
    public void set_DefaultWriterSettings(XmlWriterSettings value);
    public IList`1<WhitespaceRule> get_WhitespaceRules();
    public void set_WhitespaceRules(IList`1<WhitespaceRule> value);
    public QilList get_GlobalParameterList();
    public void set_GlobalParameterList(QilList value);
    public QilList get_GlobalVariableList();
    public void set_GlobalVariableList(QilList value);
    public IList`1<EarlyBoundInfo> get_EarlyBoundTypes();
    public void set_EarlyBoundTypes(IList`1<EarlyBoundInfo> value);
    public QilList get_FunctionList();
    public void set_FunctionList(QilList value);
    public QilNode get_Root();
    public void set_Root(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilFactory : object {
    public QilTypeChecker TypeChecker { get; }
    public QilTypeChecker get_TypeChecker();
    public QilExpression QilExpression(QilNode root, QilFactory factory);
    public QilList FunctionList(IList`1<QilNode> values);
    public QilList GlobalVariableList(IList`1<QilNode> values);
    public QilList GlobalParameterList(IList`1<QilNode> values);
    public QilList ActualParameterList(IList`1<QilNode> values);
    public QilList FormalParameterList(IList`1<QilNode> values);
    public QilList SortKeyList(IList`1<QilNode> values);
    public QilList BranchList(IList`1<QilNode> values);
    public QilList Sequence(IList`1<QilNode> values);
    public QilParameter Parameter(XmlQueryType xmlType);
    public QilStrConcat StrConcat(QilNode values);
    public QilName LiteralQName(string local);
    public QilTargetType TypeAssert(QilNode expr, XmlQueryType xmlType);
    public QilTargetType IsType(QilNode expr, XmlQueryType xmlType);
    public QilTargetType XsltConvert(QilNode expr, XmlQueryType xmlType);
    public QilFunction Function(QilNode arguments, QilNode sideEffects, XmlQueryType xmlType);
    public QilExpression QilExpression(QilNode root);
    public QilList FunctionList();
    public QilList GlobalVariableList();
    public QilList GlobalParameterList();
    public QilList ActualParameterList();
    public QilList FormalParameterList();
    public QilList SortKeyList();
    public QilList BranchList();
    public QilUnary OptimizeBarrier(QilNode child);
    public QilNode Unknown(XmlQueryType xmlType);
    public QilDataSource DataSource(QilNode name, QilNode baseUri);
    public QilUnary Nop(QilNode child);
    public QilUnary Error(QilNode child);
    public QilUnary Warning(QilNode child);
    public QilIterator For(QilNode binding);
    public QilIterator Let(QilNode binding);
    public QilParameter Parameter(QilNode defaultValue, QilNode name, XmlQueryType xmlType);
    public QilUnary PositionOf(QilNode child);
    public QilNode True();
    public QilNode False();
    public QilLiteral LiteralString(string value);
    public QilLiteral LiteralInt32(int value);
    public QilLiteral LiteralInt64(long value);
    public QilLiteral LiteralDouble(double value);
    public QilLiteral LiteralDecimal(decimal value);
    public QilName LiteralQName(string localName, string namespaceUri, string prefix);
    public QilLiteral LiteralType(XmlQueryType value);
    public QilLiteral LiteralObject(object value);
    public QilBinary And(QilNode left, QilNode right);
    public QilBinary Or(QilNode left, QilNode right);
    public QilUnary Not(QilNode child);
    public QilTernary Conditional(QilNode left, QilNode center, QilNode right);
    public QilChoice Choice(QilNode expression, QilNode branches);
    public QilUnary Length(QilNode child);
    public QilList Sequence();
    public QilBinary Union(QilNode left, QilNode right);
    public QilBinary Intersection(QilNode left, QilNode right);
    public QilBinary Difference(QilNode left, QilNode right);
    public QilUnary Average(QilNode child);
    public QilUnary Sum(QilNode child);
    public QilUnary Minimum(QilNode child);
    public QilUnary Maximum(QilNode child);
    public QilUnary Negate(QilNode child);
    public QilBinary Add(QilNode left, QilNode right);
    public QilBinary Subtract(QilNode left, QilNode right);
    public QilBinary Multiply(QilNode left, QilNode right);
    public QilBinary Divide(QilNode left, QilNode right);
    public QilBinary Modulo(QilNode left, QilNode right);
    public QilUnary StrLength(QilNode child);
    public QilStrConcat StrConcat(QilNode delimiter, QilNode values);
    public QilBinary StrParseQName(QilNode left, QilNode right);
    public QilBinary Ne(QilNode left, QilNode right);
    public QilBinary Eq(QilNode left, QilNode right);
    public QilBinary Gt(QilNode left, QilNode right);
    public QilBinary Ge(QilNode left, QilNode right);
    public QilBinary Lt(QilNode left, QilNode right);
    public QilBinary Le(QilNode left, QilNode right);
    public QilBinary Is(QilNode left, QilNode right);
    public QilBinary After(QilNode left, QilNode right);
    public QilBinary Before(QilNode left, QilNode right);
    public QilLoop Loop(QilNode variable, QilNode body);
    public QilLoop Filter(QilNode variable, QilNode body);
    public QilLoop Sort(QilNode variable, QilNode body);
    public QilSortKey SortKey(QilNode key, QilNode collation);
    public QilUnary DocOrderDistinct(QilNode child);
    public QilFunction Function(QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType xmlType);
    public QilInvoke Invoke(QilNode function, QilNode arguments);
    public QilUnary Content(QilNode child);
    public QilBinary Attribute(QilNode left, QilNode right);
    public QilUnary Parent(QilNode child);
    public QilUnary Root(QilNode child);
    public QilNode XmlContext();
    public QilUnary Descendant(QilNode child);
    public QilUnary DescendantOrSelf(QilNode child);
    public QilUnary Ancestor(QilNode child);
    public QilUnary AncestorOrSelf(QilNode child);
    public QilUnary Preceding(QilNode child);
    public QilUnary FollowingSibling(QilNode child);
    public QilUnary PrecedingSibling(QilNode child);
    public QilBinary NodeRange(QilNode left, QilNode right);
    public QilBinary Deref(QilNode left, QilNode right);
    public QilBinary ElementCtor(QilNode left, QilNode right);
    public QilBinary AttributeCtor(QilNode left, QilNode right);
    public QilUnary CommentCtor(QilNode child);
    public QilBinary PICtor(QilNode left, QilNode right);
    public QilUnary TextCtor(QilNode child);
    public QilUnary RawTextCtor(QilNode child);
    public QilUnary DocumentCtor(QilNode child);
    public QilBinary NamespaceDecl(QilNode left, QilNode right);
    public QilBinary RtfCtor(QilNode left, QilNode right);
    public QilUnary NameOf(QilNode child);
    public QilUnary LocalNameOf(QilNode child);
    public QilUnary NamespaceUriOf(QilNode child);
    public QilUnary PrefixOf(QilNode child);
    public QilTargetType TypeAssert(QilNode source, QilNode targetType);
    public QilTargetType IsType(QilNode source, QilNode targetType);
    public QilUnary IsEmpty(QilNode child);
    public QilUnary XPathNodeValue(QilNode child);
    public QilUnary XPathFollowing(QilNode child);
    public QilUnary XPathPreceding(QilNode child);
    public QilUnary XPathNamespace(QilNode child);
    public QilUnary XsltGenerateId(QilNode child);
    public QilInvokeLateBound XsltInvokeLateBound(QilNode name, QilNode arguments);
    public QilInvokeEarlyBound XsltInvokeEarlyBound(QilNode name, QilNode clrMethod, QilNode arguments, XmlQueryType xmlType);
    public QilBinary XsltCopy(QilNode left, QilNode right);
    public QilUnary XsltCopyOf(QilNode child);
    public QilTargetType XsltConvert(QilNode source, QilNode targetType);
    [ConditionalAttribute("QIL_TRACE_NODE_CREATION")]
public void TraceNode(QilNode n);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilFunction : QilReference {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilList Arguments { get; public set; }
    public QilNode Definition { get; public set; }
    public bool MaybeSideEffects { get; public set; }
    public QilFunction(QilNodeType nodeType, QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType resultType);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilList get_Arguments();
    public void set_Arguments(QilList value);
    public QilNode get_Definition();
    public void set_Definition(QilNode value);
    public bool get_MaybeSideEffects();
    public void set_MaybeSideEffects(bool value);
}
internal class System.Xml.Xsl.Qil.QilInvoke : QilBinary {
    public QilFunction Function { get; public set; }
    public QilList Arguments { get; public set; }
    public QilInvoke(QilNodeType nodeType, QilNode function, QilNode arguments);
    public QilFunction get_Function();
    public void set_Function(QilFunction value);
    public QilList get_Arguments();
    public void set_Arguments(QilList value);
}
internal class System.Xml.Xsl.Qil.QilInvokeEarlyBound : QilTernary {
    public QilName Name { get; public set; }
    public MethodInfo ClrMethod { get; public set; }
    public QilList Arguments { get; public set; }
    public QilInvokeEarlyBound(QilNodeType nodeType, QilNode name, QilNode method, QilNode arguments, XmlQueryType resultType);
    public QilName get_Name();
    public void set_Name(QilName value);
    public MethodInfo get_ClrMethod();
    public void set_ClrMethod(MethodInfo value);
    public QilList get_Arguments();
    public void set_Arguments(QilList value);
}
internal class System.Xml.Xsl.Qil.QilInvokeLateBound : QilBinary {
    public QilName Name { get; public set; }
    public QilList Arguments { get; public set; }
    public QilInvokeLateBound(QilNodeType nodeType, QilNode name, QilNode arguments);
    public QilName get_Name();
    public void set_Name(QilName value);
    public QilList get_Arguments();
    public void set_Arguments(QilList value);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilIterator : QilReference {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilNode Binding { get; public set; }
    public QilIterator(QilNodeType nodeType, QilNode binding);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilNode get_Binding();
    public void set_Binding(QilNode value);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilList : QilNode {
    public XmlQueryType XmlType { get; }
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilList(QilNodeType nodeType);
    public virtual XmlQueryType get_XmlType();
    public virtual QilNode ShallowClone(QilFactory f);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public virtual void Insert(int index, QilNode node);
    public virtual void RemoveAt(int index);
}
internal class System.Xml.Xsl.Qil.QilLiteral : QilNode {
    public object Value { get; public set; }
    public QilLiteral(QilNodeType nodeType, object value);
    public object get_Value();
    public void set_Value(object value);
    public static string op_Implicit(QilLiteral literal);
    public static int op_Implicit(QilLiteral literal);
    public static long op_Implicit(QilLiteral literal);
    public static double op_Implicit(QilLiteral literal);
    public static decimal op_Implicit(QilLiteral literal);
    public static XmlQueryType op_Implicit(QilLiteral literal);
}
internal class System.Xml.Xsl.Qil.QilLoop : QilBinary {
    public QilIterator Variable { get; public set; }
    public QilNode Body { get; public set; }
    public QilLoop(QilNodeType nodeType, QilNode variable, QilNode body);
    public QilIterator get_Variable();
    public void set_Variable(QilIterator value);
    public QilNode get_Body();
    public void set_Body(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilName : QilLiteral {
    public string LocalName { get; public set; }
    public string NamespaceUri { get; public set; }
    public string Prefix { get; public set; }
    public string QualifiedName { get; }
    public QilName(QilNodeType nodeType, string local, string uri, string prefix);
    public string get_LocalName();
    public void set_LocalName(string value);
    public string get_NamespaceUri();
    public void set_NamespaceUri(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_QualifiedName();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public static bool op_Equality(QilName a, QilName b);
    public static bool op_Inequality(QilName a, QilName b);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilNode : object {
    protected QilNodeType nodeType;
    protected XmlQueryType xmlType;
    protected ISourceLineInfo sourceLine;
    protected object annotation;
    public QilNodeType NodeType { get; public set; }
    public XmlQueryType XmlType { get; public set; }
    public ISourceLineInfo SourceLine { get; public set; }
    public object Annotation { get; public set; }
    public int Count { get; }
    public QilNode Item { get; public set; }
    public bool IsReadOnly { get; }
    public QilNode(QilNodeType nodeType);
    public QilNode(QilNodeType nodeType, XmlQueryType xmlType);
    public QilNodeType get_NodeType();
    public void set_NodeType(QilNodeType value);
    public virtual XmlQueryType get_XmlType();
    public virtual void set_XmlType(XmlQueryType value);
    public ISourceLineInfo get_SourceLine();
    public void set_SourceLine(ISourceLineInfo value);
    public object get_Annotation();
    public void set_Annotation(object value);
    public virtual QilNode DeepClone(QilFactory f);
    public virtual QilNode ShallowClone(QilFactory f);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public virtual void Insert(int index, QilNode node);
    public virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<QilNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool get_IsReadOnly();
    public virtual void Add(QilNode node);
    public virtual void Add(IList`1<QilNode> list);
    public virtual void Clear();
    public virtual bool Contains(QilNode node);
    public virtual void CopyTo(QilNode[] array, int index);
    public virtual bool Remove(QilNode node);
    public virtual int IndexOf(QilNode node);
}
internal enum System.Xml.Xsl.Qil.QilNodeType : Enum {
    public int value__;
    public static QilNodeType QilExpression;
    public static QilNodeType FunctionList;
    public static QilNodeType GlobalVariableList;
    public static QilNodeType GlobalParameterList;
    public static QilNodeType ActualParameterList;
    public static QilNodeType FormalParameterList;
    public static QilNodeType SortKeyList;
    public static QilNodeType BranchList;
    public static QilNodeType OptimizeBarrier;
    public static QilNodeType Unknown;
    public static QilNodeType DataSource;
    public static QilNodeType Nop;
    public static QilNodeType Error;
    public static QilNodeType Warning;
    public static QilNodeType For;
    public static QilNodeType Let;
    public static QilNodeType Parameter;
    public static QilNodeType PositionOf;
    public static QilNodeType True;
    public static QilNodeType False;
    public static QilNodeType LiteralString;
    public static QilNodeType LiteralInt32;
    public static QilNodeType LiteralInt64;
    public static QilNodeType LiteralDouble;
    public static QilNodeType LiteralDecimal;
    public static QilNodeType LiteralQName;
    public static QilNodeType LiteralType;
    public static QilNodeType LiteralObject;
    public static QilNodeType And;
    public static QilNodeType Or;
    public static QilNodeType Not;
    public static QilNodeType Conditional;
    public static QilNodeType Choice;
    public static QilNodeType Length;
    public static QilNodeType Sequence;
    public static QilNodeType Union;
    public static QilNodeType Intersection;
    public static QilNodeType Difference;
    public static QilNodeType Average;
    public static QilNodeType Sum;
    public static QilNodeType Minimum;
    public static QilNodeType Maximum;
    public static QilNodeType Negate;
    public static QilNodeType Add;
    public static QilNodeType Subtract;
    public static QilNodeType Multiply;
    public static QilNodeType Divide;
    public static QilNodeType Modulo;
    public static QilNodeType StrLength;
    public static QilNodeType StrConcat;
    public static QilNodeType StrParseQName;
    public static QilNodeType Ne;
    public static QilNodeType Eq;
    public static QilNodeType Gt;
    public static QilNodeType Ge;
    public static QilNodeType Lt;
    public static QilNodeType Le;
    public static QilNodeType Is;
    public static QilNodeType After;
    public static QilNodeType Before;
    public static QilNodeType Loop;
    public static QilNodeType Filter;
    public static QilNodeType Sort;
    public static QilNodeType SortKey;
    public static QilNodeType DocOrderDistinct;
    public static QilNodeType Function;
    public static QilNodeType Invoke;
    public static QilNodeType Content;
    public static QilNodeType Attribute;
    public static QilNodeType Parent;
    public static QilNodeType Root;
    public static QilNodeType XmlContext;
    public static QilNodeType Descendant;
    public static QilNodeType DescendantOrSelf;
    public static QilNodeType Ancestor;
    public static QilNodeType AncestorOrSelf;
    public static QilNodeType Preceding;
    public static QilNodeType FollowingSibling;
    public static QilNodeType PrecedingSibling;
    public static QilNodeType NodeRange;
    public static QilNodeType Deref;
    public static QilNodeType ElementCtor;
    public static QilNodeType AttributeCtor;
    public static QilNodeType CommentCtor;
    public static QilNodeType PICtor;
    public static QilNodeType TextCtor;
    public static QilNodeType RawTextCtor;
    public static QilNodeType DocumentCtor;
    public static QilNodeType NamespaceDecl;
    public static QilNodeType RtfCtor;
    public static QilNodeType NameOf;
    public static QilNodeType LocalNameOf;
    public static QilNodeType NamespaceUriOf;
    public static QilNodeType PrefixOf;
    public static QilNodeType TypeAssert;
    public static QilNodeType IsType;
    public static QilNodeType IsEmpty;
    public static QilNodeType XPathNodeValue;
    public static QilNodeType XPathFollowing;
    public static QilNodeType XPathPreceding;
    public static QilNodeType XPathNamespace;
    public static QilNodeType XsltGenerateId;
    public static QilNodeType XsltInvokeLateBound;
    public static QilNodeType XsltInvokeEarlyBound;
    public static QilNodeType XsltCopy;
    public static QilNodeType XsltCopyOf;
    public static QilNodeType XsltConvert;
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilParameter : QilIterator {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilNode DefaultValue { get; public set; }
    public QilName Name { get; public set; }
    public QilParameter(QilNodeType nodeType, QilNode defaultValue, QilNode name, XmlQueryType xmlType);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilNode get_DefaultValue();
    public void set_DefaultValue(QilNode value);
    public QilName get_Name();
    public void set_Name(QilName value);
}
internal class System.Xml.Xsl.Qil.QilPatternFactory : object {
    public QilFactory BaseFactory { get; }
    public bool IsDebug { get; }
    public QilPatternFactory(QilFactory f, bool debug);
    public QilFactory get_BaseFactory();
    public bool get_IsDebug();
    public QilLiteral String(string val);
    public QilLiteral Int32(int val);
    public QilLiteral Double(double val);
    public QilName QName(string local, string uri, string prefix);
    public QilName QName(string local, string uri);
    public QilName QName(string local);
    public QilNode Unknown(XmlQueryType t);
    public QilExpression QilExpression(QilNode root, QilFactory factory);
    public QilList FunctionList();
    public QilList GlobalVariableList();
    public QilList GlobalParameterList();
    public QilList ActualParameterList();
    public QilList ActualParameterList(QilNode arg1);
    public QilList ActualParameterList(QilNode arg1, QilNode arg2);
    public QilList ActualParameterList(QilNode[] args);
    public QilList FormalParameterList();
    public QilList FormalParameterList(QilNode arg1);
    public QilList FormalParameterList(QilNode arg1, QilNode arg2);
    public QilList FormalParameterList(QilNode[] args);
    public QilList SortKeyList();
    public QilList SortKeyList(QilSortKey key);
    public QilList BranchList(QilNode[] args);
    public QilNode OptimizeBarrier(QilNode child);
    public QilNode DataSource(QilNode name, QilNode baseUri);
    public QilNode Nop(QilNode child);
    public QilNode Error(QilNode text);
    public QilNode Warning(QilNode text);
    public QilIterator For(QilNode binding);
    public QilIterator Let(QilNode binding);
    public QilParameter Parameter(XmlQueryType t);
    public QilParameter Parameter(QilNode defaultValue, QilName name, XmlQueryType t);
    public QilNode PositionOf(QilIterator expr);
    public QilNode True();
    public QilNode False();
    public QilNode Boolean(bool b);
    public QilNode And(QilNode left, QilNode right);
    public QilNode Or(QilNode left, QilNode right);
    public QilNode Not(QilNode child);
    public QilNode Conditional(QilNode condition, QilNode trueBranch, QilNode falseBranch);
    public QilNode Choice(QilNode expr, QilList branches);
    public QilNode Length(QilNode child);
    public QilNode Sequence();
    public QilNode Sequence(QilNode child);
    public QilNode Sequence(QilNode child1, QilNode child2);
    public QilNode Sequence(QilNode[] args);
    public QilNode Union(QilNode left, QilNode right);
    public QilNode Sum(QilNode collection);
    public QilNode Negate(QilNode child);
    public QilNode Add(QilNode left, QilNode right);
    public QilNode Subtract(QilNode left, QilNode right);
    public QilNode Multiply(QilNode left, QilNode right);
    public QilNode Divide(QilNode left, QilNode right);
    public QilNode Modulo(QilNode left, QilNode right);
    public QilNode StrLength(QilNode str);
    public QilNode StrConcat(QilNode values);
    public QilNode StrConcat(QilNode[] args);
    public QilNode StrConcat(IList`1<QilNode> args);
    public QilNode StrParseQName(QilNode str, QilNode ns);
    public QilNode Ne(QilNode left, QilNode right);
    public QilNode Eq(QilNode left, QilNode right);
    public QilNode Gt(QilNode left, QilNode right);
    public QilNode Ge(QilNode left, QilNode right);
    public QilNode Lt(QilNode left, QilNode right);
    public QilNode Le(QilNode left, QilNode right);
    public QilNode Is(QilNode left, QilNode right);
    public QilNode After(QilNode left, QilNode right);
    public QilNode Before(QilNode left, QilNode right);
    public QilNode Loop(QilIterator variable, QilNode body);
    public QilNode Filter(QilIterator variable, QilNode expr);
    public QilNode Sort(QilIterator iter, QilNode keys);
    public QilSortKey SortKey(QilNode key, QilNode collation);
    public QilNode DocOrderDistinct(QilNode collection);
    public QilFunction Function(QilList args, QilNode sideEffects, XmlQueryType resultType);
    public QilFunction Function(QilList args, QilNode defn, QilNode sideEffects);
    public QilNode Invoke(QilFunction func, QilList args);
    public QilNode Content(QilNode context);
    public QilNode Parent(QilNode context);
    public QilNode Root(QilNode context);
    public QilNode XmlContext();
    public QilNode Descendant(QilNode expr);
    public QilNode DescendantOrSelf(QilNode context);
    public QilNode Ancestor(QilNode expr);
    public QilNode AncestorOrSelf(QilNode expr);
    public QilNode Preceding(QilNode expr);
    public QilNode FollowingSibling(QilNode expr);
    public QilNode PrecedingSibling(QilNode expr);
    public QilNode NodeRange(QilNode left, QilNode right);
    public QilBinary Deref(QilNode context, QilNode id);
    public QilNode ElementCtor(QilNode name, QilNode content);
    public QilNode AttributeCtor(QilNode name, QilNode val);
    public QilNode CommentCtor(QilNode content);
    public QilNode PICtor(QilNode name, QilNode content);
    public QilNode TextCtor(QilNode content);
    public QilNode RawTextCtor(QilNode content);
    public QilNode DocumentCtor(QilNode child);
    public QilNode NamespaceDecl(QilNode prefix, QilNode uri);
    public QilNode RtfCtor(QilNode content, QilNode baseUri);
    public QilNode NameOf(QilNode expr);
    public QilNode LocalNameOf(QilNode expr);
    public QilNode NamespaceUriOf(QilNode expr);
    public QilNode PrefixOf(QilNode expr);
    public QilNode TypeAssert(QilNode expr, XmlQueryType t);
    public QilNode IsType(QilNode expr, XmlQueryType t);
    public QilNode IsEmpty(QilNode set);
    public QilNode XPathNodeValue(QilNode expr);
    public QilNode XPathFollowing(QilNode expr);
    public QilNode XPathNamespace(QilNode expr);
    public QilNode XPathPreceding(QilNode expr);
    public QilNode XsltGenerateId(QilNode expr);
    public QilNode XsltInvokeEarlyBound(QilNode name, MethodInfo d, XmlQueryType t, IList`1<QilNode> args);
    public QilNode XsltInvokeLateBound(QilNode name, IList`1<QilNode> args);
    public QilNode XsltCopy(QilNode expr, QilNode content);
    public QilNode XsltCopyOf(QilNode expr);
    public QilNode XsltConvert(QilNode expr, XmlQueryType t);
}
internal abstract class System.Xml.Xsl.Qil.QilPatternVisitor : QilReplaceVisitor {
    public QilPatterns Patterns { get; public set; }
    public int Threshold { get; public set; }
    public int ReplacementCount { get; }
    public int LastReplacement { get; }
    public bool Matching { get; }
    public QilPatternVisitor(QilPatterns patterns, QilFactory f);
    public QilPatterns get_Patterns();
    public void set_Patterns(QilPatterns value);
    public int get_Threshold();
    public void set_Threshold(int value);
    public int get_ReplacementCount();
    public int get_LastReplacement();
    public bool get_Matching();
    protected virtual bool AllowReplace(int pattern, QilNode original);
    protected virtual QilNode Replace(int pattern, QilNode original, QilNode replacement);
    protected virtual QilNode NoReplace(QilNode node);
    protected virtual QilNode Visit(QilNode node);
    protected virtual QilNode VisitQilExpression(QilExpression n);
    protected virtual QilNode VisitFunctionList(QilList n);
    protected virtual QilNode VisitGlobalVariableList(QilList n);
    protected virtual QilNode VisitGlobalParameterList(QilList n);
    protected virtual QilNode VisitActualParameterList(QilList n);
    protected virtual QilNode VisitFormalParameterList(QilList n);
    protected virtual QilNode VisitSortKeyList(QilList n);
    protected virtual QilNode VisitBranchList(QilList n);
    protected virtual QilNode VisitOptimizeBarrier(QilUnary n);
    protected virtual QilNode VisitUnknown(QilNode n);
    protected virtual QilNode VisitDataSource(QilDataSource n);
    protected virtual QilNode VisitNop(QilUnary n);
    protected virtual QilNode VisitError(QilUnary n);
    protected virtual QilNode VisitWarning(QilUnary n);
    protected virtual QilNode VisitFor(QilIterator n);
    protected virtual QilNode VisitForReference(QilIterator n);
    protected virtual QilNode VisitLet(QilIterator n);
    protected virtual QilNode VisitLetReference(QilIterator n);
    protected virtual QilNode VisitParameter(QilParameter n);
    protected virtual QilNode VisitParameterReference(QilParameter n);
    protected virtual QilNode VisitPositionOf(QilUnary n);
    protected virtual QilNode VisitTrue(QilNode n);
    protected virtual QilNode VisitFalse(QilNode n);
    protected virtual QilNode VisitLiteralString(QilLiteral n);
    protected virtual QilNode VisitLiteralInt32(QilLiteral n);
    protected virtual QilNode VisitLiteralInt64(QilLiteral n);
    protected virtual QilNode VisitLiteralDouble(QilLiteral n);
    protected virtual QilNode VisitLiteralDecimal(QilLiteral n);
    protected virtual QilNode VisitLiteralQName(QilName n);
    protected virtual QilNode VisitLiteralType(QilLiteral n);
    protected virtual QilNode VisitLiteralObject(QilLiteral n);
    protected virtual QilNode VisitAnd(QilBinary n);
    protected virtual QilNode VisitOr(QilBinary n);
    protected virtual QilNode VisitNot(QilUnary n);
    protected virtual QilNode VisitConditional(QilTernary n);
    protected virtual QilNode VisitChoice(QilChoice n);
    protected virtual QilNode VisitLength(QilUnary n);
    protected virtual QilNode VisitSequence(QilList n);
    protected virtual QilNode VisitUnion(QilBinary n);
    protected virtual QilNode VisitIntersection(QilBinary n);
    protected virtual QilNode VisitDifference(QilBinary n);
    protected virtual QilNode VisitAverage(QilUnary n);
    protected virtual QilNode VisitSum(QilUnary n);
    protected virtual QilNode VisitMinimum(QilUnary n);
    protected virtual QilNode VisitMaximum(QilUnary n);
    protected virtual QilNode VisitNegate(QilUnary n);
    protected virtual QilNode VisitAdd(QilBinary n);
    protected virtual QilNode VisitSubtract(QilBinary n);
    protected virtual QilNode VisitMultiply(QilBinary n);
    protected virtual QilNode VisitDivide(QilBinary n);
    protected virtual QilNode VisitModulo(QilBinary n);
    protected virtual QilNode VisitStrLength(QilUnary n);
    protected virtual QilNode VisitStrConcat(QilStrConcat n);
    protected virtual QilNode VisitStrParseQName(QilBinary n);
    protected virtual QilNode VisitNe(QilBinary n);
    protected virtual QilNode VisitEq(QilBinary n);
    protected virtual QilNode VisitGt(QilBinary n);
    protected virtual QilNode VisitGe(QilBinary n);
    protected virtual QilNode VisitLt(QilBinary n);
    protected virtual QilNode VisitLe(QilBinary n);
    protected virtual QilNode VisitIs(QilBinary n);
    protected virtual QilNode VisitAfter(QilBinary n);
    protected virtual QilNode VisitBefore(QilBinary n);
    protected virtual QilNode VisitLoop(QilLoop n);
    protected virtual QilNode VisitFilter(QilLoop n);
    protected virtual QilNode VisitSort(QilLoop n);
    protected virtual QilNode VisitSortKey(QilSortKey n);
    protected virtual QilNode VisitDocOrderDistinct(QilUnary n);
    protected virtual QilNode VisitFunction(QilFunction n);
    protected virtual QilNode VisitFunctionReference(QilFunction n);
    protected virtual QilNode VisitInvoke(QilInvoke n);
    protected virtual QilNode VisitContent(QilUnary n);
    protected virtual QilNode VisitAttribute(QilBinary n);
    protected virtual QilNode VisitParent(QilUnary n);
    protected virtual QilNode VisitRoot(QilUnary n);
    protected virtual QilNode VisitXmlContext(QilNode n);
    protected virtual QilNode VisitDescendant(QilUnary n);
    protected virtual QilNode VisitDescendantOrSelf(QilUnary n);
    protected virtual QilNode VisitAncestor(QilUnary n);
    protected virtual QilNode VisitAncestorOrSelf(QilUnary n);
    protected virtual QilNode VisitPreceding(QilUnary n);
    protected virtual QilNode VisitFollowingSibling(QilUnary n);
    protected virtual QilNode VisitPrecedingSibling(QilUnary n);
    protected virtual QilNode VisitNodeRange(QilBinary n);
    protected virtual QilNode VisitDeref(QilBinary n);
    protected virtual QilNode VisitElementCtor(QilBinary n);
    protected virtual QilNode VisitAttributeCtor(QilBinary n);
    protected virtual QilNode VisitCommentCtor(QilUnary n);
    protected virtual QilNode VisitPICtor(QilBinary n);
    protected virtual QilNode VisitTextCtor(QilUnary n);
    protected virtual QilNode VisitRawTextCtor(QilUnary n);
    protected virtual QilNode VisitDocumentCtor(QilUnary n);
    protected virtual QilNode VisitNamespaceDecl(QilBinary n);
    protected virtual QilNode VisitRtfCtor(QilBinary n);
    protected virtual QilNode VisitNameOf(QilUnary n);
    protected virtual QilNode VisitLocalNameOf(QilUnary n);
    protected virtual QilNode VisitNamespaceUriOf(QilUnary n);
    protected virtual QilNode VisitPrefixOf(QilUnary n);
    protected virtual QilNode VisitTypeAssert(QilTargetType n);
    protected virtual QilNode VisitIsType(QilTargetType n);
    protected virtual QilNode VisitIsEmpty(QilUnary n);
    protected virtual QilNode VisitXPathNodeValue(QilUnary n);
    protected virtual QilNode VisitXPathFollowing(QilUnary n);
    protected virtual QilNode VisitXPathPreceding(QilUnary n);
    protected virtual QilNode VisitXPathNamespace(QilUnary n);
    protected virtual QilNode VisitXsltGenerateId(QilUnary n);
    protected virtual QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n);
    protected virtual QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n);
    protected virtual QilNode VisitXsltCopy(QilBinary n);
    protected virtual QilNode VisitXsltCopyOf(QilUnary n);
    protected virtual QilNode VisitXsltConvert(QilTargetType n);
}
internal class System.Xml.Xsl.Qil.QilReference : QilNode {
    public string DebugName { get; public set; }
    public QilReference(QilNodeType nodeType);
    public string get_DebugName();
    public void set_DebugName(string value);
}
internal abstract class System.Xml.Xsl.Qil.QilReplaceVisitor : QilVisitor {
    protected QilFactory f;
    public QilReplaceVisitor(QilFactory f);
    protected virtual QilNode VisitChildren(QilNode parent);
    protected virtual void RecalculateType(QilNode node, XmlQueryType oldType);
}
internal class System.Xml.Xsl.Qil.QilScopedVisitor : QilVisitor {
    protected virtual void BeginScope(QilNode node);
    protected virtual void EndScope(QilNode node);
    protected virtual void BeforeVisit(QilNode node);
    protected virtual void AfterVisit(QilNode node);
    protected virtual QilNode Visit(QilNode n);
}
internal class System.Xml.Xsl.Qil.QilSortKey : QilBinary {
    public QilNode Key { get; public set; }
    public QilNode Collation { get; public set; }
    public QilSortKey(QilNodeType nodeType, QilNode key, QilNode collation);
    public QilNode get_Key();
    public void set_Key(QilNode value);
    public QilNode get_Collation();
    public void set_Collation(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilStrConcat : QilBinary {
    public QilNode Delimiter { get; public set; }
    public QilNode Values { get; public set; }
    public QilStrConcat(QilNodeType nodeType, QilNode delimiter, QilNode values);
    public QilNode get_Delimiter();
    public void set_Delimiter(QilNode value);
    public QilNode get_Values();
    public void set_Values(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilTargetType : QilBinary {
    public QilNode Source { get; public set; }
    public XmlQueryType TargetType { get; public set; }
    public QilTargetType(QilNodeType nodeType, QilNode expr, QilNode targetType);
    public QilNode get_Source();
    public void set_Source(QilNode value);
    public XmlQueryType get_TargetType();
    public void set_TargetType(XmlQueryType value);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilTernary : QilNode {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilNode Left { get; public set; }
    public QilNode Center { get; public set; }
    public QilNode Right { get; public set; }
    public QilTernary(QilNodeType nodeType, QilNode left, QilNode center, QilNode right);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilNode get_Left();
    public void set_Left(QilNode value);
    public QilNode get_Center();
    public void set_Center(QilNode value);
    public QilNode get_Right();
    public void set_Right(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilTypeChecker : object {
    public XmlQueryType Check(QilNode n);
    public XmlQueryType CheckQilExpression(QilExpression node);
    public XmlQueryType CheckFunctionList(QilList node);
    public XmlQueryType CheckGlobalVariableList(QilList node);
    public XmlQueryType CheckGlobalParameterList(QilList node);
    public XmlQueryType CheckActualParameterList(QilList node);
    public XmlQueryType CheckFormalParameterList(QilList node);
    public XmlQueryType CheckSortKeyList(QilList node);
    public XmlQueryType CheckBranchList(QilList node);
    public XmlQueryType CheckOptimizeBarrier(QilUnary node);
    public XmlQueryType CheckUnknown(QilNode node);
    public XmlQueryType CheckDataSource(QilDataSource node);
    public XmlQueryType CheckNop(QilUnary node);
    public XmlQueryType CheckError(QilUnary node);
    public XmlQueryType CheckWarning(QilUnary node);
    public XmlQueryType CheckFor(QilIterator node);
    public XmlQueryType CheckLet(QilIterator node);
    public XmlQueryType CheckParameter(QilParameter node);
    public XmlQueryType CheckPositionOf(QilUnary node);
    public XmlQueryType CheckTrue(QilNode node);
    public XmlQueryType CheckFalse(QilNode node);
    public XmlQueryType CheckLiteralString(QilLiteral node);
    public XmlQueryType CheckLiteralInt32(QilLiteral node);
    public XmlQueryType CheckLiteralInt64(QilLiteral node);
    public XmlQueryType CheckLiteralDouble(QilLiteral node);
    public XmlQueryType CheckLiteralDecimal(QilLiteral node);
    public XmlQueryType CheckLiteralQName(QilName node);
    public XmlQueryType CheckLiteralType(QilLiteral node);
    public XmlQueryType CheckLiteralObject(QilLiteral node);
    public XmlQueryType CheckAnd(QilBinary node);
    public XmlQueryType CheckOr(QilBinary node);
    public XmlQueryType CheckNot(QilUnary node);
    public XmlQueryType CheckConditional(QilTernary node);
    public XmlQueryType CheckChoice(QilChoice node);
    public XmlQueryType CheckLength(QilUnary node);
    public XmlQueryType CheckSequence(QilList node);
    public XmlQueryType CheckUnion(QilBinary node);
    public XmlQueryType CheckIntersection(QilBinary node);
    public XmlQueryType CheckDifference(QilBinary node);
    public XmlQueryType CheckAverage(QilUnary node);
    public XmlQueryType CheckSum(QilUnary node);
    public XmlQueryType CheckMinimum(QilUnary node);
    public XmlQueryType CheckMaximum(QilUnary node);
    public XmlQueryType CheckNegate(QilUnary node);
    public XmlQueryType CheckAdd(QilBinary node);
    public XmlQueryType CheckSubtract(QilBinary node);
    public XmlQueryType CheckMultiply(QilBinary node);
    public XmlQueryType CheckDivide(QilBinary node);
    public XmlQueryType CheckModulo(QilBinary node);
    public XmlQueryType CheckStrLength(QilUnary node);
    public XmlQueryType CheckStrConcat(QilStrConcat node);
    public XmlQueryType CheckStrParseQName(QilBinary node);
    public XmlQueryType CheckNe(QilBinary node);
    public XmlQueryType CheckEq(QilBinary node);
    public XmlQueryType CheckGt(QilBinary node);
    public XmlQueryType CheckGe(QilBinary node);
    public XmlQueryType CheckLt(QilBinary node);
    public XmlQueryType CheckLe(QilBinary node);
    public XmlQueryType CheckIs(QilBinary node);
    public XmlQueryType CheckAfter(QilBinary node);
    public XmlQueryType CheckBefore(QilBinary node);
    public XmlQueryType CheckLoop(QilLoop node);
    public XmlQueryType CheckFilter(QilLoop node);
    public XmlQueryType CheckSort(QilLoop node);
    public XmlQueryType CheckSortKey(QilSortKey node);
    public XmlQueryType CheckDocOrderDistinct(QilUnary node);
    public XmlQueryType CheckFunction(QilFunction node);
    public XmlQueryType CheckInvoke(QilInvoke node);
    public XmlQueryType CheckContent(QilUnary node);
    public XmlQueryType CheckAttribute(QilBinary node);
    public XmlQueryType CheckParent(QilUnary node);
    public XmlQueryType CheckRoot(QilUnary node);
    public XmlQueryType CheckXmlContext(QilNode node);
    public XmlQueryType CheckDescendant(QilUnary node);
    public XmlQueryType CheckDescendantOrSelf(QilUnary node);
    public XmlQueryType CheckAncestor(QilUnary node);
    public XmlQueryType CheckAncestorOrSelf(QilUnary node);
    public XmlQueryType CheckPreceding(QilUnary node);
    public XmlQueryType CheckFollowingSibling(QilUnary node);
    public XmlQueryType CheckPrecedingSibling(QilUnary node);
    public XmlQueryType CheckNodeRange(QilBinary node);
    public XmlQueryType CheckDeref(QilBinary node);
    public XmlQueryType CheckElementCtor(QilBinary node);
    public XmlQueryType CheckAttributeCtor(QilBinary node);
    public XmlQueryType CheckCommentCtor(QilUnary node);
    public XmlQueryType CheckPICtor(QilBinary node);
    public XmlQueryType CheckTextCtor(QilUnary node);
    public XmlQueryType CheckRawTextCtor(QilUnary node);
    public XmlQueryType CheckDocumentCtor(QilUnary node);
    public XmlQueryType CheckNamespaceDecl(QilBinary node);
    public XmlQueryType CheckRtfCtor(QilBinary node);
    public XmlQueryType CheckNameOf(QilUnary node);
    public XmlQueryType CheckLocalNameOf(QilUnary node);
    public XmlQueryType CheckNamespaceUriOf(QilUnary node);
    public XmlQueryType CheckPrefixOf(QilUnary node);
    public XmlQueryType CheckDeepCopy(QilUnary node);
    public XmlQueryType CheckTypeAssert(QilTargetType node);
    public XmlQueryType CheckIsType(QilTargetType node);
    public XmlQueryType CheckIsEmpty(QilUnary node);
    public XmlQueryType CheckXPathNodeValue(QilUnary node);
    public XmlQueryType CheckXPathFollowing(QilUnary node);
    public XmlQueryType CheckXPathPreceding(QilUnary node);
    public XmlQueryType CheckXPathNamespace(QilUnary node);
    public XmlQueryType CheckXsltGenerateId(QilUnary node);
    public XmlQueryType CheckXsltInvokeLateBound(QilInvokeLateBound node);
    public XmlQueryType CheckXsltInvokeEarlyBound(QilInvokeEarlyBound node);
    public XmlQueryType CheckXsltCopy(QilBinary node);
    public XmlQueryType CheckXsltCopyOf(QilUnary node);
    public XmlQueryType CheckXsltConvert(QilTargetType node);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.Qil.QilUnary : QilNode {
    public int Count { get; }
    public QilNode Item { get; public set; }
    public QilNode Child { get; public set; }
    public QilUnary(QilNodeType nodeType, QilNode child);
    public virtual int get_Count();
    public virtual QilNode get_Item(int index);
    public virtual void set_Item(int index, QilNode value);
    public QilNode get_Child();
    public void set_Child(QilNode value);
}
internal class System.Xml.Xsl.Qil.QilValidationVisitor : QilScopedVisitor {
    [ConditionalAttribute("DEBUG")]
public static void Validate(QilNode node);
    [ConditionalAttribute("DEBUG")]
internal static void SetError(QilNode n, string message);
}
internal abstract class System.Xml.Xsl.Qil.QilVisitor : object {
    protected virtual QilNode VisitAssumeReference(QilNode expr);
    protected virtual QilNode VisitChildren(QilNode parent);
    protected virtual bool IsReference(QilNode parent, int childNum);
    protected virtual QilNode Visit(QilNode n);
    protected virtual QilNode VisitReference(QilNode n);
    protected virtual QilNode VisitNull();
    protected virtual QilNode VisitQilExpression(QilExpression n);
    protected virtual QilNode VisitFunctionList(QilList n);
    protected virtual QilNode VisitGlobalVariableList(QilList n);
    protected virtual QilNode VisitGlobalParameterList(QilList n);
    protected virtual QilNode VisitActualParameterList(QilList n);
    protected virtual QilNode VisitFormalParameterList(QilList n);
    protected virtual QilNode VisitSortKeyList(QilList n);
    protected virtual QilNode VisitBranchList(QilList n);
    protected virtual QilNode VisitOptimizeBarrier(QilUnary n);
    protected virtual QilNode VisitUnknown(QilNode n);
    protected virtual QilNode VisitDataSource(QilDataSource n);
    protected virtual QilNode VisitNop(QilUnary n);
    protected virtual QilNode VisitError(QilUnary n);
    protected virtual QilNode VisitWarning(QilUnary n);
    protected virtual QilNode VisitFor(QilIterator n);
    protected virtual QilNode VisitForReference(QilIterator n);
    protected virtual QilNode VisitLet(QilIterator n);
    protected virtual QilNode VisitLetReference(QilIterator n);
    protected virtual QilNode VisitParameter(QilParameter n);
    protected virtual QilNode VisitParameterReference(QilParameter n);
    protected virtual QilNode VisitPositionOf(QilUnary n);
    protected virtual QilNode VisitTrue(QilNode n);
    protected virtual QilNode VisitFalse(QilNode n);
    protected virtual QilNode VisitLiteralString(QilLiteral n);
    protected virtual QilNode VisitLiteralInt32(QilLiteral n);
    protected virtual QilNode VisitLiteralInt64(QilLiteral n);
    protected virtual QilNode VisitLiteralDouble(QilLiteral n);
    protected virtual QilNode VisitLiteralDecimal(QilLiteral n);
    protected virtual QilNode VisitLiteralQName(QilName n);
    protected virtual QilNode VisitLiteralType(QilLiteral n);
    protected virtual QilNode VisitLiteralObject(QilLiteral n);
    protected virtual QilNode VisitAnd(QilBinary n);
    protected virtual QilNode VisitOr(QilBinary n);
    protected virtual QilNode VisitNot(QilUnary n);
    protected virtual QilNode VisitConditional(QilTernary n);
    protected virtual QilNode VisitChoice(QilChoice n);
    protected virtual QilNode VisitLength(QilUnary n);
    protected virtual QilNode VisitSequence(QilList n);
    protected virtual QilNode VisitUnion(QilBinary n);
    protected virtual QilNode VisitIntersection(QilBinary n);
    protected virtual QilNode VisitDifference(QilBinary n);
    protected virtual QilNode VisitAverage(QilUnary n);
    protected virtual QilNode VisitSum(QilUnary n);
    protected virtual QilNode VisitMinimum(QilUnary n);
    protected virtual QilNode VisitMaximum(QilUnary n);
    protected virtual QilNode VisitNegate(QilUnary n);
    protected virtual QilNode VisitAdd(QilBinary n);
    protected virtual QilNode VisitSubtract(QilBinary n);
    protected virtual QilNode VisitMultiply(QilBinary n);
    protected virtual QilNode VisitDivide(QilBinary n);
    protected virtual QilNode VisitModulo(QilBinary n);
    protected virtual QilNode VisitStrLength(QilUnary n);
    protected virtual QilNode VisitStrConcat(QilStrConcat n);
    protected virtual QilNode VisitStrParseQName(QilBinary n);
    protected virtual QilNode VisitNe(QilBinary n);
    protected virtual QilNode VisitEq(QilBinary n);
    protected virtual QilNode VisitGt(QilBinary n);
    protected virtual QilNode VisitGe(QilBinary n);
    protected virtual QilNode VisitLt(QilBinary n);
    protected virtual QilNode VisitLe(QilBinary n);
    protected virtual QilNode VisitIs(QilBinary n);
    protected virtual QilNode VisitAfter(QilBinary n);
    protected virtual QilNode VisitBefore(QilBinary n);
    protected virtual QilNode VisitLoop(QilLoop n);
    protected virtual QilNode VisitFilter(QilLoop n);
    protected virtual QilNode VisitSort(QilLoop n);
    protected virtual QilNode VisitSortKey(QilSortKey n);
    protected virtual QilNode VisitDocOrderDistinct(QilUnary n);
    protected virtual QilNode VisitFunction(QilFunction n);
    protected virtual QilNode VisitFunctionReference(QilFunction n);
    protected virtual QilNode VisitInvoke(QilInvoke n);
    protected virtual QilNode VisitContent(QilUnary n);
    protected virtual QilNode VisitAttribute(QilBinary n);
    protected virtual QilNode VisitParent(QilUnary n);
    protected virtual QilNode VisitRoot(QilUnary n);
    protected virtual QilNode VisitXmlContext(QilNode n);
    protected virtual QilNode VisitDescendant(QilUnary n);
    protected virtual QilNode VisitDescendantOrSelf(QilUnary n);
    protected virtual QilNode VisitAncestor(QilUnary n);
    protected virtual QilNode VisitAncestorOrSelf(QilUnary n);
    protected virtual QilNode VisitPreceding(QilUnary n);
    protected virtual QilNode VisitFollowingSibling(QilUnary n);
    protected virtual QilNode VisitPrecedingSibling(QilUnary n);
    protected virtual QilNode VisitNodeRange(QilBinary n);
    protected virtual QilNode VisitDeref(QilBinary n);
    protected virtual QilNode VisitElementCtor(QilBinary n);
    protected virtual QilNode VisitAttributeCtor(QilBinary n);
    protected virtual QilNode VisitCommentCtor(QilUnary n);
    protected virtual QilNode VisitPICtor(QilBinary n);
    protected virtual QilNode VisitTextCtor(QilUnary n);
    protected virtual QilNode VisitRawTextCtor(QilUnary n);
    protected virtual QilNode VisitDocumentCtor(QilUnary n);
    protected virtual QilNode VisitNamespaceDecl(QilBinary n);
    protected virtual QilNode VisitRtfCtor(QilBinary n);
    protected virtual QilNode VisitNameOf(QilUnary n);
    protected virtual QilNode VisitLocalNameOf(QilUnary n);
    protected virtual QilNode VisitNamespaceUriOf(QilUnary n);
    protected virtual QilNode VisitPrefixOf(QilUnary n);
    protected virtual QilNode VisitTypeAssert(QilTargetType n);
    protected virtual QilNode VisitIsType(QilTargetType n);
    protected virtual QilNode VisitIsEmpty(QilUnary n);
    protected virtual QilNode VisitXPathNodeValue(QilUnary n);
    protected virtual QilNode VisitXPathFollowing(QilUnary n);
    protected virtual QilNode VisitXPathPreceding(QilUnary n);
    protected virtual QilNode VisitXPathNamespace(QilUnary n);
    protected virtual QilNode VisitXsltGenerateId(QilUnary n);
    protected virtual QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n);
    protected virtual QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n);
    protected virtual QilNode VisitXsltCopy(QilBinary n);
    protected virtual QilNode VisitXsltCopyOf(QilUnary n);
    protected virtual QilNode VisitXsltConvert(QilTargetType n);
}
internal class System.Xml.Xsl.Qil.QilXmlReader : object {
    private static QilXmlReader();
    public QilXmlReader(XmlReader r);
    public QilExpression Read();
}
internal class System.Xml.Xsl.Qil.QilXmlWriter : QilScopedVisitor {
    protected XmlWriter writer;
    protected Options options;
    public QilXmlWriter(XmlWriter writer);
    public QilXmlWriter(XmlWriter writer, Options options);
    public void ToXml(QilNode node);
    protected virtual void WriteAnnotations(object ann);
    protected virtual void WriteLineInfo(QilNode node);
    protected virtual void WriteXmlType(QilNode node);
    protected virtual QilNode VisitChildren(QilNode node);
    protected virtual QilNode VisitReference(QilNode node);
    protected virtual QilNode VisitQilExpression(QilExpression qil);
    protected virtual QilNode VisitLiteralType(QilLiteral value);
    protected virtual QilNode VisitLiteralQName(QilName value);
    protected virtual void BeginScope(QilNode node);
    protected virtual void EndScope(QilNode node);
    protected virtual void BeforeVisit(QilNode node);
    protected virtual void AfterVisit(QilNode node);
}
internal enum System.Xml.Xsl.Qil.SerializationHints : Enum {
    public int value__;
    public static SerializationHints None;
    public static SerializationHints CData;
    public static SerializationHints DisableOutputEscaping;
}
internal class System.Xml.Xsl.Qil.SubstitutionList : object {
    public void AddSubstitutionPair(QilNode find, QilNode replace);
    public void RemoveLastSubstitutionPair();
    public void RemoveLastNSubstitutionPairs(int n);
    public QilNode FindReplacement(QilNode n);
}
internal class System.Xml.Xsl.Qil.WhitespaceRule : object {
    public string LocalName { get; public set; }
    public string NamespaceName { get; public set; }
    public bool PreserveSpace { get; }
    public WhitespaceRule(string localName, string namespaceName, bool preserveSpace);
    public WhitespaceRule(XmlQueryDataReader reader);
    protected void Init(string localName, string namespaceName, bool preserveSpace);
    public string get_LocalName();
    public void set_LocalName(string value);
    public string get_NamespaceName();
    public void set_NamespaceName(string value);
    public bool get_PreserveSpace();
    public void GetObjectData(XmlQueryDataWriter writer);
}
internal class System.Xml.Xsl.QueryReaderSettings : object {
    public XmlNameTable NameTable { get; }
    public QueryReaderSettings(XmlNameTable xmlNameTable);
    public QueryReaderSettings(XmlReader reader);
    public XmlReader CreateReader(Stream stream, string baseUri);
    public XmlNameTable get_NameTable();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.AncestorDocOrderIterator : ValueType {
    private XmlNavigatorStack stack;
    private XPathNavigator navCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.AncestorIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private bool haveCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.AttributeContentIterator : ValueType {
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.AttributeIterator : ValueType {
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
internal static class System.Xml.Xsl.Runtime.CharUtil : object {
    public static bool IsAlphaNumeric(char ch);
    public static bool IsDecimalDigitOne(char ch);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.ContentIterator : ValueType {
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.ContentMergeIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XPathNavigator navNext;
    private XmlNavigatorStack navStack;
    private IteratorState state;
    public XPathNavigator Current { get; }
    public void Create(XmlNavigatorFilter filter);
    public IteratorResult MoveNext(XPathNavigator input);
    internal IteratorResult MoveNext(XPathNavigator input, bool isContent);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DecimalAggregator : ValueType {
    private decimal result;
    private int cnt;
    public decimal SumResult { get; }
    public decimal AverageResult { get; }
    public decimal MinimumResult { get; }
    public decimal MaximumResult { get; }
    public bool IsEmpty { get; }
    public void Create();
    public void Sum(decimal value);
    public void Average(decimal value);
    public void Minimum(decimal value);
    public void Maximum(decimal value);
    public decimal get_SumResult();
    public decimal get_AverageResult();
    public decimal get_MinimumResult();
    public decimal get_MaximumResult();
    public bool get_IsEmpty();
}
internal class System.Xml.Xsl.Runtime.DecimalFormat : object {
    public NumberFormatInfo info;
    public char digit;
    public char zeroDigit;
    public char patternSeparator;
    internal DecimalFormat(NumberFormatInfo info, char digit, char zeroDigit, char patternSeparator);
}
internal class System.Xml.Xsl.Runtime.DecimalFormatter : object {
    public DecimalFormatter(string formatPicture, DecimalFormat decimalFormat);
    public string Format(double value);
    public static string Format(double value, string formatPicture, DecimalFormat decimalFormat);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DescendantIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XPathNavigator navEnd;
    private bool hasFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator input, XmlNavigatorFilter filter, bool orSelf);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DescendantMergeIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XPathNavigator navRoot;
    private XPathNavigator navEnd;
    private IteratorState state;
    private bool orSelf;
    public XPathNavigator Current { get; }
    public void Create(XmlNavigatorFilter filter, bool orSelf);
    public IteratorResult MoveNext(XPathNavigator input);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DifferenceIterator : ValueType {
    private XmlQueryRuntime runtime;
    private XPathNavigator navLeft;
    private XPathNavigator navRight;
    private IteratorState state;
    public XPathNavigator Current { get; }
    public void Create(XmlQueryRuntime runtime);
    public SetIteratorResult MoveNext(XPathNavigator nestedNavigator);
    public XPathNavigator get_Current();
}
internal class System.Xml.Xsl.Runtime.DocumentOrderComparer : object {
    public sealed virtual int Compare(XPathNavigator navThis, XPathNavigator navThat);
    public int GetDocumentIndex(XPathNavigator nav);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DodSequenceMerge : ValueType {
    private IList`1<XPathNavigator> firstSequence;
    private List`1<IEnumerator`1<XPathNavigator>> sequencesToMerge;
    private int nodeCount;
    private XmlQueryRuntime runtime;
    public void Create(XmlQueryRuntime runtime);
    public void AddSequence(IList`1<XPathNavigator> sequence);
    public IList`1<XPathNavigator> MergeSequences();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.DoubleAggregator : ValueType {
    private double result;
    private int cnt;
    public double SumResult { get; }
    public double AverageResult { get; }
    public double MinimumResult { get; }
    public double MaximumResult { get; }
    public bool IsEmpty { get; }
    public void Create();
    public void Sum(double value);
    public void Average(double value);
    public void Minimum(double value);
    public void Maximum(double value);
    public double get_SumResult();
    public double get_AverageResult();
    public double get_MinimumResult();
    public double get_MaximumResult();
    public bool get_IsEmpty();
}
internal class System.Xml.Xsl.Runtime.EarlyBoundInfo : object {
    public string NamespaceUri { get; }
    public Type EarlyBoundType { get; }
    public EarlyBoundInfo(string namespaceUri, Type ebType);
    public string get_NamespaceUri();
    public Type get_EarlyBoundType();
    public object CreateObject();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.ElementContentIterator : ValueType {
    private string localName;
    private string ns;
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, string localName, string ns);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.FollowingSiblingIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator : ValueType {
    private ContentMergeIterator wrapped;
    public XPathNavigator Current { get; }
    public void Create(XmlNavigatorFilter filter);
    public IteratorResult MoveNext(XPathNavigator navigator);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.IdIterator : ValueType {
    private XPathNavigator navCurrent;
    private String[] idrefs;
    private int idx;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, string value);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.Int32Aggregator : ValueType {
    private int result;
    private int cnt;
    public int SumResult { get; }
    public int AverageResult { get; }
    public int MinimumResult { get; }
    public int MaximumResult { get; }
    public bool IsEmpty { get; }
    public void Create();
    public void Sum(int value);
    public void Average(int value);
    public void Minimum(int value);
    public void Maximum(int value);
    public int get_SumResult();
    public int get_AverageResult();
    public int get_MinimumResult();
    public int get_MaximumResult();
    public bool get_IsEmpty();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.Int64Aggregator : ValueType {
    private long result;
    private int cnt;
    public long SumResult { get; }
    public long AverageResult { get; }
    public long MinimumResult { get; }
    public long MaximumResult { get; }
    public bool IsEmpty { get; }
    public void Create();
    public void Sum(long value);
    public void Average(long value);
    public void Minimum(long value);
    public void Maximum(long value);
    public long get_SumResult();
    public long get_AverageResult();
    public long get_MinimumResult();
    public long get_MaximumResult();
    public bool get_IsEmpty();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.IntersectIterator : ValueType {
    private XmlQueryRuntime runtime;
    private XPathNavigator navLeft;
    private XPathNavigator navRight;
    private IteratorState state;
    public XPathNavigator Current { get; }
    public void Create(XmlQueryRuntime runtime);
    public SetIteratorResult MoveNext(XPathNavigator nestedNavigator);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public enum System.Xml.Xsl.Runtime.IteratorResult : Enum {
    public int value__;
    public static IteratorResult NoMoreNodes;
    public static IteratorResult NeedInputNode;
    public static IteratorResult HaveCurrentNode;
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.NamespaceIterator : ValueType {
    private XPathNavigator navCurrent;
    private XmlNavigatorStack navStack;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
internal class System.Xml.Xsl.Runtime.NavigatorConstructor : object {
    public XPathNavigator GetNavigator(XmlEventCache events, XmlNameTable nameTable);
    public XPathNavigator GetNavigator(string text, string baseUri, XmlNameTable nameTable);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.NodeKindContentIterator : ValueType {
    private XPathNodeType nodeType;
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XPathNodeType nodeType);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.NodeRangeIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XPathNavigator navEnd;
    private IteratorState state;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator start, XmlNavigatorFilter filter, XPathNavigator end);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
internal class System.Xml.Xsl.Runtime.NumberFormatter : NumberFormatterBase {
    public static char DefaultStartChar;
    public NumberFormatter(string formatString, int lang, string letterValue, string groupingSeparator, int groupingSize);
    private static NumberFormatter();
    public string FormatSequence(IList`1<XPathItem> val);
}
internal class System.Xml.Xsl.Runtime.NumberFormatterBase : object {
    protected static int MaxAlphabeticValue;
    protected static int MaxRomanValue;
    private static NumberFormatterBase();
    public static void ConvertToAlphabetic(StringBuilder sb, double val, char firstChar, int totalChars);
    public static void ConvertToRoman(StringBuilder sb, double val, bool upperCase);
}
internal enum System.Xml.Xsl.Runtime.NumberingSequence : Enum {
    public int value__;
    public static NumberingSequence Nil;
    public static NumberingSequence FirstDecimal;
    public static NumberingSequence Arabic;
    public static NumberingSequence DArabic;
    public static NumberingSequence Hindi3;
    public static NumberingSequence Thai2;
    public static NumberingSequence FEDecimal;
    public static NumberingSequence KorDbNum1;
    public static NumberingSequence LastNum;
    public static NumberingSequence FirstAlpha;
    public static NumberingSequence UCLetter;
    public static NumberingSequence LCLetter;
    public static NumberingSequence UCRus;
    public static NumberingSequence LCRus;
    public static NumberingSequence Thai1;
    public static NumberingSequence Hindi1;
    public static NumberingSequence Hindi2;
    public static NumberingSequence Aiueo;
    public static NumberingSequence DAiueo;
    public static NumberingSequence Iroha;
    public static NumberingSequence DIroha;
    public static NumberingSequence DChosung;
    public static NumberingSequence Ganada;
    public static NumberingSequence ArabicScript;
    public static NumberingSequence LastAlpha;
    public static NumberingSequence FirstSpecial;
    public static NumberingSequence UCRoman;
    public static NumberingSequence LCRoman;
    public static NumberingSequence Hebrew;
    public static NumberingSequence DbNum3;
    public static NumberingSequence ChnCmplx;
    public static NumberingSequence KorDbNum3;
    public static NumberingSequence Zodiac1;
    public static NumberingSequence Zodiac2;
    public static NumberingSequence Zodiac3;
    public static NumberingSequence LastSpecial;
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.ParentIterator : ValueType {
    private XPathNavigator navCurrent;
    private bool haveCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.PrecedingIterator : ValueType {
    private XmlNavigatorStack stack;
    private XPathNavigator navCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XPathNavigator navEnd;
    private bool needFirst;
    private bool useCompPos;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.PrecedingSiblingIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
internal abstract class System.Xml.Xsl.Runtime.RtfNavigator : XPathNavigator {
    public XPathNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Name { get; }
    public string Prefix { get; }
    public bool IsEmptyElement { get; }
    public XmlNameTable NameTable { get; }
    public abstract virtual void CopyToWriter(XmlWriter writer);
    public abstract virtual XPathNavigator ToNavigator();
    public virtual XPathNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Name();
    public virtual string get_Prefix();
    public virtual bool get_IsEmptyElement();
    public virtual XmlNameTable get_NameTable();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNext();
    public virtual bool MoveToPrevious();
    public virtual bool MoveToFirstChild();
    public virtual bool MoveToParent();
    public virtual bool MoveToId(string id);
    public virtual bool IsSamePosition(XPathNavigator other);
}
internal class System.Xml.Xsl.Runtime.RtfTextNavigator : RtfNavigator {
    public string Value { get; }
    public string BaseURI { get; }
    public RtfTextNavigator(string text, string baseUri);
    public RtfTextNavigator(RtfTextNavigator that);
    public virtual void CopyToWriter(XmlWriter writer);
    public virtual XPathNavigator ToNavigator();
    public virtual string get_Value();
    public virtual string get_BaseURI();
    public virtual XPathNavigator Clone();
    public virtual bool MoveTo(XPathNavigator other);
}
internal class System.Xml.Xsl.Runtime.RtfTreeNavigator : RtfNavigator {
    public string Value { get; }
    public string BaseURI { get; }
    public RtfTreeNavigator(XmlEventCache events, XmlNameTable nameTable);
    public RtfTreeNavigator(RtfTreeNavigator that);
    public virtual void CopyToWriter(XmlWriter writer);
    public virtual XPathNavigator ToNavigator();
    public virtual string get_Value();
    public virtual string get_BaseURI();
    public virtual XPathNavigator Clone();
    public virtual bool MoveTo(XPathNavigator other);
}
[EditorBrowsableAttribute("1")]
public enum System.Xml.Xsl.Runtime.SetIteratorResult : Enum {
    public int value__;
    public static SetIteratorResult NoMoreNodes;
    public static SetIteratorResult InitRightIterator;
    public static SetIteratorResult NeedLeftNode;
    public static SetIteratorResult NeedRightNode;
    public static SetIteratorResult HaveCurrentNode;
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.StringConcat : ValueType {
    private string s1;
    private string s2;
    private string s3;
    private string s4;
    private string delimiter;
    private List`1<string> strList;
    private int idxStr;
    public string Delimiter { get; public set; }
    internal int Count { get; }
    public void Clear();
    public string get_Delimiter();
    public void set_Delimiter(string value);
    internal int get_Count();
    public void Concat(string value);
    public string GetResult();
    internal void ConcatNoDelimiter(string s);
}
internal class System.Xml.Xsl.Runtime.TokenInfo : object {
    public char startChar;
    public int startIdx;
    public string formatString;
    public int length;
    [ConditionalAttribute("DEBUG")]
public void AssertSeparator(bool isSeparator);
    public static TokenInfo CreateSeparator(string formatString, int startIdx, int tokLen);
    public static TokenInfo CreateFormat(string formatString, int startIdx, int tokLen);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.UnionIterator : ValueType {
    private XmlQueryRuntime runtime;
    private XPathNavigator navCurr;
    private XPathNavigator navOther;
    private IteratorState state;
    public XPathNavigator Current { get; }
    public void Create(XmlQueryRuntime runtime);
    public SetIteratorResult MoveNext(XPathNavigator nestedNavigator);
    public XPathNavigator get_Current();
}
internal class System.Xml.Xsl.Runtime.WhitespaceRuleLookup : object {
    public WhitespaceRuleLookup(IList`1<WhitespaceRule> rules);
    public void Atomize(XmlNameTable nameTable);
    public bool ShouldStripSpace(string localName, string namespaceName);
}
internal class System.Xml.Xsl.Runtime.WhitespaceRuleReader : XmlWrappingReader {
    public string Value { get; }
    public static XmlReader CreateReader(XmlReader baseReader, WhitespaceRuleLookup wsRules);
    public virtual string get_Value();
    public virtual bool Read();
}
internal class System.Xml.Xsl.Runtime.XmlAttributeCache : XmlRawWriter {
    public int Count { get; }
    public OnRemoveWriter OnRemoveWriterEvent { get; public set; }
    public void Init(XmlRawWriter wrapped);
    public int get_Count();
    public sealed virtual OnRemoveWriter get_OnRemoveWriterEvent();
    public sealed virtual void set_OnRemoveWriterEvent(OnRemoveWriter value);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    internal virtual void WriteNamespaceDeclaration(string prefix, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    internal virtual void StartElementContent();
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    internal virtual void WriteEndElement(string prefix, string localName, string ns);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void Close();
    public virtual void Flush();
}
internal class System.Xml.Xsl.Runtime.XmlCachedSequenceWriter : XmlSequenceWriter {
    public XmlQueryItemSequence ResultSequence { get; }
    public XmlQueryItemSequence get_ResultSequence();
    public virtual XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable);
    public virtual void EndTree();
    public virtual void WriteItem(XPathItem item);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlCollation : object {
    internal static XmlCollation CodePointCollation { get; }
    internal bool UpperFirst { get; }
    internal bool EmptyGreatest { get; }
    internal bool DescendingOrder { get; }
    internal CultureInfo Culture { get; }
    internal XmlCollation(BinaryReader reader);
    private static XmlCollation();
    internal static XmlCollation get_CodePointCollation();
    internal static XmlCollation Create(string collationLiteral);
    internal static XmlCollation Create(string collationLiteral, bool throwOnError);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void GetObjectData(BinaryWriter writer);
    internal bool get_UpperFirst();
    internal bool get_EmptyGreatest();
    internal bool get_DescendingOrder();
    internal CultureInfo get_Culture();
    internal XmlSortKey CreateSortKey(string s);
}
internal class System.Xml.Xsl.Runtime.XmlDateTimeSortKey : XmlIntegerSortKey {
    public XmlDateTimeSortKey(DateTime value, XmlCollation collation);
}
internal class System.Xml.Xsl.Runtime.XmlDecimalSortKey : XmlSortKey {
    public XmlDecimalSortKey(decimal value, XmlCollation collation);
    public virtual int CompareTo(object obj);
}
internal class System.Xml.Xsl.Runtime.XmlDoubleSortKey : XmlSortKey {
    public XmlDoubleSortKey(double value, XmlCollation collation);
    public virtual int CompareTo(object obj);
}
internal class System.Xml.Xsl.Runtime.XmlEmptySortKey : XmlSortKey {
    public bool IsEmptyGreatest { get; }
    public XmlEmptySortKey(XmlCollation collation);
    public bool get_IsEmptyGreatest();
    public virtual int CompareTo(object obj);
}
internal class System.Xml.Xsl.Runtime.XmlExtensionFunction : object {
    public MethodInfo Method { get; }
    public Type ClrReturnType { get; }
    public XmlQueryType XmlReturnType { get; }
    public XmlExtensionFunction(string name, string namespaceUri, MethodInfo meth);
    public XmlExtensionFunction(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags);
    public void Init(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags);
    public MethodInfo get_Method();
    public Type GetClrArgumentType(int index);
    public Type get_ClrReturnType();
    public XmlQueryType GetXmlArgumentType(int index);
    public XmlQueryType get_XmlReturnType();
    public bool CanBind();
    public void Bind();
    public object Invoke(object extObj, Object[] args);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class System.Xml.Xsl.Runtime.XmlExtensionFunctionTable : object {
    public XmlExtensionFunction Bind(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlILIndex : object {
    public void Add(string key, XPathNavigator navigator);
    public XmlQueryNodeSequence Lookup(string key);
}
internal class System.Xml.Xsl.Runtime.XmlILQueryEventArgs : XsltMessageEncounteredEventArgs {
    public string Message { get; }
    public XmlILQueryEventArgs(string message);
    public virtual string get_Message();
}
[EditorBrowsableAttribute("1")]
public static class System.Xml.Xsl.Runtime.XmlILStorageConverter : object {
    public static XmlAtomicValue StringToAtomicValue(string value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue DecimalToAtomicValue(decimal value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue Int64ToAtomicValue(long value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue Int32ToAtomicValue(int value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue BooleanToAtomicValue(bool value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue DoubleToAtomicValue(double value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue SingleToAtomicValue(float value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue DateTimeToAtomicValue(DateTime value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue XmlQualifiedNameToAtomicValue(XmlQualifiedName value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue TimeSpanToAtomicValue(TimeSpan value, int index, XmlQueryRuntime runtime);
    public static XmlAtomicValue BytesToAtomicValue(Byte[] value, int index, XmlQueryRuntime runtime);
    public static IList`1<XPathItem> NavigatorsToItems(IList`1<XPathNavigator> listNavigators);
    public static IList`1<XPathNavigator> ItemsToNavigators(IList`1<XPathItem> listItems);
}
internal class System.Xml.Xsl.Runtime.XmlIntegerSortKey : XmlSortKey {
    public XmlIntegerSortKey(long value, XmlCollation collation);
    public virtual int CompareTo(object obj);
}
internal class System.Xml.Xsl.Runtime.XmlIntSortKey : XmlSortKey {
    public XmlIntSortKey(int value, XmlCollation collation);
    public virtual int CompareTo(object obj);
}
internal class System.Xml.Xsl.Runtime.XmlMergeSequenceWriter : XmlSequenceWriter {
    public XmlMergeSequenceWriter(XmlRawWriter xwrt);
    public virtual XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable);
    public virtual void EndTree();
    public virtual void WriteItem(XPathItem item);
}
internal class System.Xml.Xsl.Runtime.XmlNavAttrFilter : XmlNavigatorFilter {
    private static XmlNavAttrFilter();
    public static XmlNavigatorFilter Create();
    public virtual bool MoveToContent(XPathNavigator navigator);
    public virtual bool MoveToNextContent(XPathNavigator navigator);
    public virtual bool MoveToFollowingSibling(XPathNavigator navigator);
    public virtual bool MoveToPreviousSibling(XPathNavigator navigator);
    public virtual bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd);
    public virtual bool IsFiltered(XPathNavigator navigator);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Xml.Xsl.Runtime.XmlNavigatorFilter : object {
    public abstract virtual bool MoveToContent(XPathNavigator navigator);
    public abstract virtual bool MoveToNextContent(XPathNavigator navigator);
    public abstract virtual bool MoveToFollowingSibling(XPathNavigator navigator);
    public abstract virtual bool MoveToPreviousSibling(XPathNavigator navigator);
    public abstract virtual bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navigatorEnd);
    public abstract virtual bool IsFiltered(XPathNavigator navigator);
}
internal class System.Xml.Xsl.Runtime.XmlNavigatorStack : ValueType {
    private XPathNavigator[] stkNav;
    private int sp;
    private static int InitialStackSize;
    public bool IsEmpty { get; }
    public void Push(XPathNavigator nav);
    public XPathNavigator Pop();
    public XPathNavigator Peek();
    public void Reset();
    public bool get_IsEmpty();
}
internal class System.Xml.Xsl.Runtime.XmlNavNameFilter : XmlNavigatorFilter {
    public static XmlNavigatorFilter Create(string localName, string namespaceUri);
    public virtual bool MoveToContent(XPathNavigator navigator);
    public virtual bool MoveToNextContent(XPathNavigator navigator);
    public virtual bool MoveToFollowingSibling(XPathNavigator navigator);
    public virtual bool MoveToPreviousSibling(XPathNavigator navigator);
    public virtual bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd);
    public virtual bool IsFiltered(XPathNavigator navigator);
}
internal class System.Xml.Xsl.Runtime.XmlNavNeverFilter : XmlNavigatorFilter {
    private static XmlNavNeverFilter();
    public static XmlNavigatorFilter Create();
    public virtual bool MoveToContent(XPathNavigator navigator);
    public virtual bool MoveToNextContent(XPathNavigator navigator);
    public virtual bool MoveToFollowingSibling(XPathNavigator navigator);
    public virtual bool MoveToPreviousSibling(XPathNavigator navigator);
    public virtual bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd);
    public virtual bool IsFiltered(XPathNavigator navigator);
    public static bool MoveToFirstAttributeContent(XPathNavigator navigator);
    public static bool MoveToNextAttributeContent(XPathNavigator navigator);
}
internal class System.Xml.Xsl.Runtime.XmlNavTypeFilter : XmlNavigatorFilter {
    private static XmlNavTypeFilter();
    public static XmlNavigatorFilter Create(XPathNodeType nodeType);
    public virtual bool MoveToContent(XPathNavigator navigator);
    public virtual bool MoveToNextContent(XPathNavigator navigator);
    public virtual bool MoveToFollowingSibling(XPathNavigator navigator);
    public virtual bool MoveToPreviousSibling(XPathNavigator navigator);
    public virtual bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd);
    public virtual bool IsFiltered(XPathNavigator navigator);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQueryContext : object {
    public XmlNameTable QueryNameTable { get; }
    public XmlNameTable DefaultNameTable { get; }
    public XPathNavigator DefaultDataSource { get; }
    internal XmlQueryContext(XmlQueryRuntime runtime, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, WhitespaceRuleLookup wsRules);
    public XmlNameTable get_QueryNameTable();
    public XmlNameTable get_DefaultNameTable();
    public XPathNavigator get_DefaultDataSource();
    public XPathNavigator GetDataSource(string uriRelative, string uriBase);
    public object GetParameter(string localName, string namespaceUri);
    public object GetLateBoundObject(string namespaceUri);
    public bool LateBoundFunctionExists(string name, string namespaceUri);
    public IList`1<XPathItem> InvokeXsltLateBoundFunction(string name, string namespaceUri, IList`1[] args);
    public void OnXsltMessageEncountered(string message);
}
internal class System.Xml.Xsl.Runtime.XmlQueryDataReader : BinaryReader {
    public XmlQueryDataReader(Stream input);
    public int ReadInt32Encoded();
    public string ReadStringQ();
    public sbyte ReadSByte(sbyte minValue, sbyte maxValue);
}
internal class System.Xml.Xsl.Runtime.XmlQueryDataWriter : BinaryWriter {
    public XmlQueryDataWriter(Stream output);
    public void WriteInt32Encoded(int value);
    public void WriteStringQ(string value);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQueryItemSequence : XmlQuerySequence`1<XPathItem> {
    public static XmlQueryItemSequence Empty;
    public XmlQueryItemSequence(int capacity);
    public XmlQueryItemSequence(XPathItem item);
    private static XmlQueryItemSequence();
    public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq);
    public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq, XPathItem item);
    public void AddClone(XPathItem item);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQueryNodeSequence : XmlQuerySequence`1<XPathNavigator> {
    public static XmlQueryNodeSequence Empty;
    public bool IsDocOrderDistinct { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.IsReadOnly { get; }
    private XPathItem System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.Item { get; private set; }
    public XmlQueryNodeSequence(int capacity);
    public XmlQueryNodeSequence(IList`1<XPathNavigator> list);
    public XmlQueryNodeSequence(XPathNavigator[] array, int size);
    public XmlQueryNodeSequence(XPathNavigator navigator);
    private static XmlQueryNodeSequence();
    public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq);
    public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq, XPathNavigator navigator);
    public bool get_IsDocOrderDistinct();
    public void set_IsDocOrderDistinct(bool value);
    public XmlQueryNodeSequence DocOrderDistinct(IComparer`1<XPathNavigator> comparer);
    public void AddClone(XPathNavigator navigator);
    protected virtual void OnItemsChanged();
    private sealed virtual override IEnumerator`1<XPathItem> System.Collections.Generic.IEnumerable<System.Xml.XPath.XPathItem>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.Add(XPathItem value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.Contains(XPathItem value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.CopyTo(XPathItem[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Xml.XPath.XPathItem>.Remove(XPathItem value);
    private sealed virtual override XPathItem System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.set_Item(int index, XPathItem value);
    private sealed virtual override int System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.IndexOf(XPathItem value);
    private sealed virtual override void System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.Insert(int index, XPathItem value);
    private sealed virtual override void System.Collections.Generic.IList<System.Xml.XPath.XPathItem>.RemoveAt(int index);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQueryOutput : XmlWriter {
    internal XmlSequenceWriter SequenceWriter { get; }
    internal XmlRawWriter Writer { get; internal set; }
    public WriteState WriteState { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    internal XmlQueryOutput(XmlQueryRuntime runtime, XmlSequenceWriter seqwrt);
    internal XmlQueryOutput(XmlQueryRuntime runtime, XmlEventCache xwrt);
    internal XmlSequenceWriter get_SequenceWriter();
    internal XmlRawWriter get_Writer();
    internal void set_Writer(XmlRawWriter value);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteEndDocument();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string target, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteCData(string text);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual WriteState get_WriteState();
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public void StartTree(XPathNodeType rootType);
    public void EndTree();
    public void WriteStartElementUnchecked(string prefix, string localName, string ns);
    public void WriteStartElementUnchecked(string localName);
    public void StartElementContentUnchecked();
    public void WriteEndElementUnchecked(string prefix, string localName, string ns);
    public void WriteEndElementUnchecked(string localName);
    public void WriteStartAttributeUnchecked(string prefix, string localName, string ns);
    public void WriteStartAttributeUnchecked(string localName);
    public void WriteEndAttributeUnchecked();
    public void WriteNamespaceDeclarationUnchecked(string prefix, string ns);
    public void WriteStringUnchecked(string text);
    public void WriteRawUnchecked(string text);
    public void WriteStartRoot();
    public void WriteEndRoot();
    public void WriteStartElementLocalName(string localName);
    public void WriteStartAttributeLocalName(string localName);
    public void WriteStartElementComputed(string tagName, int prefixMappingsIndex);
    public void WriteStartElementComputed(string tagName, string ns);
    public void WriteStartElementComputed(XPathNavigator navigator);
    public void WriteStartElementComputed(XmlQualifiedName name);
    public void WriteStartAttributeComputed(string tagName, int prefixMappingsIndex);
    public void WriteStartAttributeComputed(string tagName, string ns);
    public void WriteStartAttributeComputed(XPathNavigator navigator);
    public void WriteStartAttributeComputed(XmlQualifiedName name);
    public void WriteNamespaceDeclaration(string prefix, string ns);
    public void WriteStartNamespace(string prefix);
    public void WriteNamespaceString(string text);
    public void WriteEndNamespace();
    public void WriteStartComment();
    public void WriteCommentString(string text);
    public void WriteEndComment();
    public void WriteStartProcessingInstruction(string target);
    public void WriteProcessingInstructionString(string text);
    public void WriteEndProcessingInstruction();
    public void WriteItem(XPathItem item);
    public void XsltCopyOf(XPathNavigator navigator);
    public bool StartCopy(XPathNavigator navigator);
    public void EndCopy(XPathNavigator navigator);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQueryRuntime : object {
    internal static BindingFlags EarlyBoundFlags;
    internal static BindingFlags LateBoundFlags;
    public XmlQueryContext ExternalContext { get; }
    public XsltLibrary XsltFunctions { get; }
    public XmlNameTable NameTable { get; }
    internal XmlQueryType[] XmlTypes { get; }
    public XmlQueryOutput Output { get; }
    internal XmlQueryRuntime(XmlQueryStaticData data, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, XmlSequenceWriter seqWrt);
    public String[] DebugGetGlobalNames();
    public IList DebugGetGlobalValue(string name);
    public void DebugSetGlobalValue(string name, object value);
    public object DebugGetXsltValue(IList seq);
    public XmlQueryContext get_ExternalContext();
    public XsltLibrary get_XsltFunctions();
    public object GetEarlyBoundObject(int index);
    public bool EarlyBoundFunctionExists(string name, string namespaceUri);
    public bool IsGlobalComputed(int index);
    public object GetGlobalValue(int index);
    public void SetGlobalValue(int index, object value);
    public XmlNameTable get_NameTable();
    public string GetAtomizedName(int index);
    public XmlNavigatorFilter GetNameFilter(int index);
    public XmlNavigatorFilter GetTypeFilter(XPathNodeType nodeType);
    public XmlQualifiedName ParseTagName(string tagName, int indexPrefixMappings);
    public XmlQualifiedName ParseTagName(string tagName, string ns);
    internal void ParseTagName(string tagName, int idxPrefixMappings, String& prefix, String& localName, String& ns);
    public bool IsQNameEqual(XPathNavigator n1, XPathNavigator n2);
    public bool IsQNameEqual(XPathNavigator navigator, int indexLocalName, int indexNamespaceUri);
    internal XmlQueryType[] get_XmlTypes();
    internal XmlQueryType GetXmlType(int idxType);
    public object ChangeTypeXsltArgument(int indexType, object value, Type destinationType);
    internal object ChangeTypeXsltArgument(XmlQueryType xmlType, object value, Type destinationType);
    public object ChangeTypeXsltResult(int indexType, object value);
    internal object ChangeTypeXsltResult(XmlQueryType xmlType, object value);
    public bool MatchesXmlType(IList`1<XPathItem> seq, int indexType);
    public bool MatchesXmlType(XPathItem item, int indexType);
    public bool MatchesXmlType(IList`1<XPathItem> seq, XmlTypeCode code);
    public bool MatchesXmlType(XPathItem item, XmlTypeCode code);
    public XmlCollation GetCollation(int index);
    public XmlCollation CreateCollation(string collation);
    public int ComparePosition(XPathNavigator navigatorThis, XPathNavigator navigatorThat);
    public IList`1<XPathNavigator> DocOrderDistinct(IList`1<XPathNavigator> seq);
    public string GenerateId(XPathNavigator navigator);
    public bool FindIndex(XPathNavigator context, int indexId, XmlILIndex& index);
    public void AddNewIndex(XPathNavigator context, int indexId, XmlILIndex index);
    public XmlQueryOutput get_Output();
    public void StartSequenceConstruction(XmlQueryOutput& output);
    public IList`1<XPathItem> EndSequenceConstruction(XmlQueryOutput& output);
    public void StartRtfConstruction(string baseUri, XmlQueryOutput& output);
    public XPathNavigator EndRtfConstruction(XmlQueryOutput& output);
    public XPathNavigator TextRtfConstruction(string text, string baseUri);
    public void SendMessage(string message);
    public void ThrowException(string text);
    internal static XPathNavigator SyncToNavigator(XPathNavigator navigatorThis, XPathNavigator navigatorThat);
    public static int OnCurrentNodeChanged(XPathNavigator currentNode);
}
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlQuerySequence`1 : object {
    public static XmlQuerySequence`1<T> Empty;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public T Item { get; public set; }
    public XmlQuerySequence`1(int capacity);
    public XmlQuerySequence`1(T[] array, int size);
    public XmlQuerySequence`1(T value);
    private static XmlQuerySequence`1();
    public static XmlQuerySequence`1<T> CreateOrReuse(XmlQuerySequence`1<T> seq);
    public static XmlQuerySequence`1<T> CreateOrReuse(XmlQuerySequence`1<T> seq, T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public void Clear();
    public void Add(T value);
    public void SortByKeys(Array keys);
    protected virtual void OnItemsChanged();
}
internal class System.Xml.Xsl.Runtime.XmlQueryStaticData : object {
    public static string DataFieldName;
    public static string TypesFieldName;
    public XmlWriterSettings DefaultWriterSettings { get; }
    public IList`1<WhitespaceRule> WhitespaceRules { get; }
    public String[] Names { get; }
    public StringPair[][] PrefixMappingsList { get; }
    public Int32Pair[] Filters { get; }
    public XmlQueryType[] Types { get; }
    public XmlCollation[] Collations { get; }
    public String[] GlobalNames { get; }
    public EarlyBoundInfo[] EarlyBound { get; }
    public XmlQueryStaticData(XmlWriterSettings defaultWriterSettings, IList`1<WhitespaceRule> whitespaceRules, StaticDataManager staticData);
    public XmlQueryStaticData(Byte[] data, Type[] ebTypes);
    public void GetObjectData(Byte[]& data, Type[]& ebTypes);
    public XmlWriterSettings get_DefaultWriterSettings();
    public IList`1<WhitespaceRule> get_WhitespaceRules();
    public String[] get_Names();
    public StringPair[][] get_PrefixMappingsList();
    public Int32Pair[] get_Filters();
    public XmlQueryType[] get_Types();
    public XmlCollation[] get_Collations();
    public String[] get_GlobalNames();
    public EarlyBoundInfo[] get_EarlyBound();
}
internal class System.Xml.Xsl.Runtime.XmlRawWriterWrapper : XmlRawWriter {
    public XmlWriterSettings Settings { get; }
    public XmlRawWriterWrapper(XmlWriter writer);
    public virtual XmlWriterSettings get_Settings();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteCData(string text);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void Close();
    public virtual void Flush();
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    protected virtual void Dispose(bool disposing);
    internal virtual void WriteXmlDeclaration(XmlStandalone standalone);
    internal virtual void WriteXmlDeclaration(string xmldecl);
    internal virtual void StartElementContent();
    internal virtual void WriteEndElement(string prefix, string localName, string ns);
    internal virtual void WriteFullEndElement(string prefix, string localName, string ns);
    internal virtual void WriteNamespaceDeclaration(string prefix, string ns);
}
internal abstract class System.Xml.Xsl.Runtime.XmlSequenceWriter : object {
    public abstract virtual XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable);
    public abstract virtual void EndTree();
    public abstract virtual void WriteItem(XPathItem item);
}
internal abstract class System.Xml.Xsl.Runtime.XmlSortKey : object {
    unknown int Priority {public set; }
    public void set_Priority(int value);
    public XmlSortKey AddSortKey(XmlSortKey sortKey);
    protected int BreakSortingTie(XmlSortKey that);
    protected int CompareToEmpty(object obj);
    public abstract virtual int CompareTo(object that);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XmlSortKeyAccumulator : ValueType {
    private XmlSortKey[] keys;
    private int pos;
    private static int DefaultSortKeyCount;
    public Array Keys { get; }
    public void Create();
    public void AddStringSortKey(XmlCollation collation, string value);
    public void AddDecimalSortKey(XmlCollation collation, decimal value);
    public void AddIntegerSortKey(XmlCollation collation, long value);
    public void AddIntSortKey(XmlCollation collation, int value);
    public void AddDoubleSortKey(XmlCollation collation, double value);
    public void AddDateTimeSortKey(XmlCollation collation, DateTime value);
    public void AddEmptySortKey(XmlCollation collation);
    public void FinishSortKeys();
    public Array get_Keys();
}
internal enum System.Xml.Xsl.Runtime.XmlState : Enum {
    public int value__;
    public static XmlState WithinSequence;
    public static XmlState EnumAttrs;
    public static XmlState WithinContent;
    public static XmlState WithinAttr;
    public static XmlState WithinNmsp;
    public static XmlState WithinComment;
    public static XmlState WithinPI;
}
internal class System.Xml.Xsl.Runtime.XmlStringSortKey : XmlSortKey {
    public XmlStringSortKey(SortKey sortKey, bool descendingOrder);
    public XmlStringSortKey(Byte[] sortKey, bool descendingOrder);
    public virtual int CompareTo(object obj);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XPathFollowingIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private bool needFirst;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator input, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
    internal static bool MoveFirst(XmlNavigatorFilter filter, XPathNavigator nav);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XPathFollowingMergeIterator : ValueType {
    private XmlNavigatorFilter filter;
    private IteratorState state;
    private XPathNavigator navCurrent;
    private XPathNavigator navNext;
    public XPathNavigator Current { get; }
    public void Create(XmlNavigatorFilter filter);
    public IteratorResult MoveNext(XPathNavigator input);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator : ValueType {
    private XmlNavigatorFilter filter;
    private XPathNavigator navCurrent;
    private XmlNavigatorStack navStack;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator input, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XPathPrecedingIterator : ValueType {
    private XmlNavigatorStack stack;
    private XPathNavigator navCurrent;
    public XPathNavigator Current { get; }
    public void Create(XPathNavigator context, XmlNavigatorFilter filter);
    public bool MoveNext();
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator : ValueType {
    private XmlNavigatorFilter filter;
    private IteratorState state;
    private XPathNavigator navCurrent;
    private XPathNavigator navNext;
    private XmlNavigatorStack navStack;
    public XPathNavigator Current { get; }
    public void Create(XmlNavigatorFilter filter);
    public IteratorResult MoveNext(XPathNavigator input);
    public XPathNavigator get_Current();
}
[EditorBrowsableAttribute("1")]
public static class System.Xml.Xsl.Runtime.XsltConvert : object {
    internal static Type BooleanType;
    internal static Type ByteArrayType;
    internal static Type ByteType;
    internal static Type DateTimeType;
    internal static Type DecimalType;
    internal static Type DoubleType;
    internal static Type ICollectionType;
    internal static Type IEnumerableType;
    internal static Type IListType;
    internal static Type Int16Type;
    internal static Type Int32Type;
    internal static Type Int64Type;
    internal static Type IXPathNavigableType;
    internal static Type ObjectType;
    internal static Type SByteType;
    internal static Type SingleType;
    internal static Type StringType;
    internal static Type TimeSpanType;
    internal static Type UInt16Type;
    internal static Type UInt32Type;
    internal static Type UInt64Type;
    internal static Type UriType;
    internal static Type VoidType;
    internal static Type XmlAtomicValueType;
    internal static Type XmlQualifiedNameType;
    internal static Type XPathItemType;
    internal static Type XPathNavigatorArrayType;
    internal static Type XPathNavigatorType;
    internal static Type XPathNodeIteratorType;
    private static XsltConvert();
    public static bool ToBoolean(XPathItem item);
    public static bool ToBoolean(IList`1<XPathItem> listItems);
    public static double ToDouble(string value);
    public static double ToDouble(XPathItem item);
    public static double ToDouble(IList`1<XPathItem> listItems);
    public static XPathNavigator ToNode(XPathItem item);
    public static XPathNavigator ToNode(IList`1<XPathItem> listItems);
    public static IList`1<XPathNavigator> ToNodeSet(XPathItem item);
    public static IList`1<XPathNavigator> ToNodeSet(IList`1<XPathItem> listItems);
    public static string ToString(double value);
    public static string ToString(XPathItem item);
    public static string ToString(IList`1<XPathItem> listItems);
    public static string ToString(DateTime value);
    public static double ToDouble(decimal value);
    public static double ToDouble(int value);
    public static double ToDouble(long value);
    public static decimal ToDecimal(double value);
    public static int ToInt(double value);
    public static long ToLong(double value);
    public static DateTime ToDateTime(string value);
    internal static XmlAtomicValue ConvertToType(XmlAtomicValue value, XmlQueryType destinationType);
    public static IList`1<XPathNavigator> EnsureNodeSet(IList`1<XPathItem> listItems);
    internal static XmlQueryType InferXsltType(Type clrType);
}
[EditorBrowsableAttribute("1")]
public static class System.Xml.Xsl.Runtime.XsltFunctions : object {
    private static XsltFunctions();
    public static bool StartsWith(string s1, string s2);
    public static bool Contains(string s1, string s2);
    public static string SubstringBefore(string s1, string s2);
    public static string SubstringAfter(string s1, string s2);
    public static string Substring(string value, double startIndex);
    public static string Substring(string value, double startIndex, double length);
    public static string NormalizeSpace(string value);
    public static string Translate(string arg, string mapString, string transString);
    public static bool Lang(string value, XPathNavigator context);
    public static double Round(double value);
    public static XPathItem SystemProperty(XmlQualifiedName name);
    public static string BaseUri(XPathNavigator navigator);
    public static string OuterXml(XPathNavigator navigator);
    public static string EXslObjectType(IList`1<XPathItem> value);
    public static double MSNumber(IList`1<XPathItem> value);
    public static string MSFormatDateTime(string dateTime, string format, string lang, bool isDate);
    public static double MSStringCompare(string s1, string s2, string lang, string options);
    public static string MSUtc(string dateTime);
    public static string MSLocalName(string name);
    public static string MSNamespaceUri(string name, XPathNavigator currentNode);
}
[EditorBrowsableAttribute("1")]
public class System.Xml.Xsl.Runtime.XsltLibrary : object {
    internal static int InvariantCultureLcid;
    internal XsltLibrary(XmlQueryRuntime runtime);
    public string FormatMessage(string res, IList`1<string> args);
    public int CheckScriptNamespace(string nsUri);
    public bool ElementAvailable(XmlQualifiedName name);
    public bool FunctionAvailable(XmlQualifiedName name);
    public int RegisterDecimalFormat(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters);
    public double RegisterDecimalFormatter(string formatPicture, string infinitySymbol, string nanSymbol, string characters);
    public string FormatNumberStatic(double value, double decimalFormatterIndex);
    public string FormatNumberDynamic(double value, string formatPicture, XmlQualifiedName decimalFormatName, string errorMessageName);
    public string NumberFormat(IList`1<XPathItem> value, string formatString, double lang, string letterValue, string groupingSeparator, double groupingSize);
    public int LangToLcid(string lang, bool forwardCompatibility);
    internal static int LangToLcidInternal(string lang, bool forwardCompatibility, IErrorHelper errorHelper);
    public bool EqualityOperator(double opCode, IList`1<XPathItem> left, IList`1<XPathItem> right);
    public bool RelationalOperator(double opCode, IList`1<XPathItem> left, IList`1<XPathItem> right);
    public bool IsSameNodeSort(XPathNavigator nav1, XPathNavigator nav2);
    [ConditionalAttribute("DEBUG")]
internal static void CheckXsltValue(XPathItem item);
    [ConditionalAttribute("DEBUG")]
internal static void CheckXsltValue(IList`1<XPathItem> val);
}
internal static class System.Xml.Xsl.Runtime.XsltMethods : object {
    public static MethodInfo FormatMessage;
    public static MethodInfo EnsureNodeSet;
    public static MethodInfo EqualityOperator;
    public static MethodInfo RelationalOperator;
    public static MethodInfo StartsWith;
    public static MethodInfo Contains;
    public static MethodInfo SubstringBefore;
    public static MethodInfo SubstringAfter;
    public static MethodInfo Substring2;
    public static MethodInfo Substring3;
    public static MethodInfo NormalizeSpace;
    public static MethodInfo Translate;
    public static MethodInfo Lang;
    public static MethodInfo Floor;
    public static MethodInfo Ceiling;
    public static MethodInfo Round;
    public static MethodInfo SystemProperty;
    public static MethodInfo BaseUri;
    public static MethodInfo OuterXml;
    public static MethodInfo OnCurrentNodeChanged;
    public static MethodInfo MSFormatDateTime;
    public static MethodInfo MSStringCompare;
    public static MethodInfo MSUtc;
    public static MethodInfo MSNumber;
    public static MethodInfo MSLocalName;
    public static MethodInfo MSNamespaceUri;
    public static MethodInfo EXslObjectType;
    public static MethodInfo CheckScriptNamespace;
    public static MethodInfo FunctionAvailable;
    public static MethodInfo ElementAvailable;
    public static MethodInfo RegisterDecimalFormat;
    public static MethodInfo RegisterDecimalFormatter;
    public static MethodInfo FormatNumberStatic;
    public static MethodInfo FormatNumberDynamic;
    public static MethodInfo IsSameNodeSort;
    public static MethodInfo LangToLcid;
    public static MethodInfo NumberFormat;
    private static XsltMethods();
    public static MethodInfo GetMethod(Type className, string methName);
    public static MethodInfo GetMethod(Type className, string methName, Type[] args);
}
[DebuggerDisplayAttribute("{Uri} [{StartLine},{StartPos} -- {EndLine},{EndPos}]")]
internal class System.Xml.Xsl.SourceLineInfo : object {
    protected string uriString;
    protected Location start;
    protected Location end;
    protected static int NoSourceMagicNumber;
    public static SourceLineInfo NoSource;
    public string Uri { get; }
    public int StartLine { get; }
    public int StartPos { get; }
    public int EndLine { get; }
    public int EndPos { get; }
    public Location End { get; }
    public Location Start { get; }
    public bool IsNoSource { get; }
    public SourceLineInfo(string uriString, int startLine, int startPos, int endLine, int endPos);
    public SourceLineInfo(string uriString, Location start, Location end);
    private static SourceLineInfo();
    public sealed virtual string get_Uri();
    public int get_StartLine();
    public int get_StartPos();
    public int get_EndLine();
    public int get_EndPos();
    public sealed virtual Location get_End();
    public sealed virtual Location get_Start();
    public sealed virtual bool get_IsNoSource();
    [ConditionalAttribute("DEBUG")]
public static void Validate(ISourceLineInfo lineInfo);
    public static string GetFileName(string uriString);
}
internal class System.Xml.Xsl.StringPair : ValueType {
    private string left;
    private string right;
    public string Left { get; }
    public string Right { get; }
    public StringPair(string left, string right);
    public string get_Left();
    public string get_Right();
}
internal class System.Xml.Xsl.XmlILCommand : object {
    public ExecuteDelegate ExecuteDelegate { get; }
    public XmlQueryStaticData StaticData { get; }
    public XmlILCommand(ExecuteDelegate delExec, XmlQueryStaticData staticData);
    public ExecuteDelegate get_ExecuteDelegate();
    public XmlQueryStaticData get_StaticData();
    public IList Evaluate(string contextDocumentUri, XmlResolver dataSources, XsltArgumentList argumentList);
    public void Execute(object defaultDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter writer);
}
internal class System.Xml.Xsl.XmlILGenerator : object {
    public XmlILCommand Generate(QilExpression query, TypeBuilder typeBldr);
    public void CreateTypeInitializer(XmlQueryStaticData staticData);
}
[FlagsAttribute]
internal enum System.Xml.Xsl.XmlNodeKindFlags : Enum {
    public int value__;
    public static XmlNodeKindFlags None;
    public static XmlNodeKindFlags Document;
    public static XmlNodeKindFlags Element;
    public static XmlNodeKindFlags Attribute;
    public static XmlNodeKindFlags Text;
    public static XmlNodeKindFlags Comment;
    public static XmlNodeKindFlags PI;
    public static XmlNodeKindFlags Namespace;
    public static XmlNodeKindFlags Content;
    public static XmlNodeKindFlags Any;
}
internal class System.Xml.Xsl.XmlQualifiedNameTest : XmlQualifiedName {
    public static XmlQualifiedNameTest Wildcard { get; }
    public bool IsWildcard { get; }
    public bool IsNameWildcard { get; }
    public bool IsNamespaceWildcard { get; }
    private static XmlQualifiedNameTest();
    public static XmlQualifiedNameTest get_Wildcard();
    public static XmlQualifiedNameTest New(string name, string ns);
    public bool get_IsWildcard();
    public bool get_IsNameWildcard();
    public bool get_IsNamespaceWildcard();
    public bool IsSubsetOf(XmlQualifiedNameTest other);
    public bool HasIntersection(XmlQualifiedNameTest other);
    public virtual string ToString();
}
internal class System.Xml.Xsl.XmlQueryCardinality : ValueType {
    private int value;
    public static XmlQueryCardinality None { get; }
    public static XmlQueryCardinality Zero { get; }
    public static XmlQueryCardinality One { get; }
    public static XmlQueryCardinality ZeroOrOne { get; }
    public static XmlQueryCardinality More { get; }
    public static XmlQueryCardinality NotOne { get; }
    public static XmlQueryCardinality OneOrMore { get; }
    public static XmlQueryCardinality ZeroOrMore { get; }
    public XmlQueryCardinality(string s);
    public XmlQueryCardinality(BinaryReader reader);
    private static XmlQueryCardinality();
    public static XmlQueryCardinality get_None();
    public static XmlQueryCardinality get_Zero();
    public static XmlQueryCardinality get_One();
    public static XmlQueryCardinality get_ZeroOrOne();
    public static XmlQueryCardinality get_More();
    public static XmlQueryCardinality get_NotOne();
    public static XmlQueryCardinality get_OneOrMore();
    public static XmlQueryCardinality get_ZeroOrMore();
    public bool Equals(XmlQueryCardinality other);
    public static bool op_Equality(XmlQueryCardinality left, XmlQueryCardinality right);
    public static bool op_Inequality(XmlQueryCardinality left, XmlQueryCardinality right);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static XmlQueryCardinality op_BitwiseOr(XmlQueryCardinality left, XmlQueryCardinality right);
    public static XmlQueryCardinality op_BitwiseAnd(XmlQueryCardinality left, XmlQueryCardinality right);
    public static XmlQueryCardinality op_Multiply(XmlQueryCardinality left, XmlQueryCardinality right);
    public static XmlQueryCardinality op_Addition(XmlQueryCardinality left, XmlQueryCardinality right);
    public static bool op_LessThanOrEqual(XmlQueryCardinality left, XmlQueryCardinality right);
    public static bool op_GreaterThanOrEqual(XmlQueryCardinality left, XmlQueryCardinality right);
    public XmlQueryCardinality AtMost();
    public bool NeverSubset(XmlQueryCardinality other);
    public string ToString(string format);
    public virtual string ToString();
    public void GetObjectData(BinaryWriter writer);
}
internal abstract class System.Xml.Xsl.XmlQueryType : ListBase`1<XmlQueryType> {
    public XmlTypeCode TypeCode { get; }
    public XmlQualifiedNameTest NameTest { get; }
    public XmlSchemaType SchemaType { get; }
    public bool IsNillable { get; }
    public XmlNodeKindFlags NodeKinds { get; }
    public bool IsStrict { get; }
    public XmlQueryCardinality Cardinality { get; }
    public XmlQueryType Prime { get; }
    public bool IsNotRtf { get; }
    public bool IsDod { get; }
    public XmlValueConverter ClrMapping { get; }
    public bool IsEmpty { get; }
    public bool IsSingleton { get; }
    public bool MaybeEmpty { get; }
    public bool MaybeMany { get; }
    public bool IsNode { get; }
    public bool IsAtomicValue { get; }
    public bool IsNumeric { get; }
    private static XmlQueryType();
    public abstract virtual XmlTypeCode get_TypeCode();
    public abstract virtual XmlQualifiedNameTest get_NameTest();
    public abstract virtual XmlSchemaType get_SchemaType();
    public abstract virtual bool get_IsNillable();
    public abstract virtual XmlNodeKindFlags get_NodeKinds();
    public abstract virtual bool get_IsStrict();
    public abstract virtual XmlQueryCardinality get_Cardinality();
    public abstract virtual XmlQueryType get_Prime();
    public abstract virtual bool get_IsNotRtf();
    public abstract virtual bool get_IsDod();
    public abstract virtual XmlValueConverter get_ClrMapping();
    public bool IsSubtypeOf(XmlQueryType baseType);
    public bool NeverSubtypeOf(XmlQueryType baseType);
    public bool Equals(XmlQueryType that);
    public static bool op_Equality(XmlQueryType left, XmlQueryType right);
    public static bool op_Inequality(XmlQueryType left, XmlQueryType right);
    public bool get_IsEmpty();
    public bool get_IsSingleton();
    public bool get_MaybeEmpty();
    public bool get_MaybeMany();
    public bool get_IsNode();
    public bool get_IsAtomicValue();
    public bool get_IsNumeric();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public abstract virtual void GetObjectData(BinaryWriter writer);
}
internal static class System.Xml.Xsl.XmlQueryTypeFactory : object {
    public static XmlQueryType None;
    public static XmlQueryType Empty;
    public static XmlQueryType Item;
    public static XmlQueryType ItemS;
    public static XmlQueryType Node;
    public static XmlQueryType NodeS;
    public static XmlQueryType Element;
    public static XmlQueryType ElementS;
    public static XmlQueryType Document;
    public static XmlQueryType DocumentS;
    public static XmlQueryType Attribute;
    public static XmlQueryType AttributeQ;
    public static XmlQueryType AttributeS;
    public static XmlQueryType Namespace;
    public static XmlQueryType NamespaceS;
    public static XmlQueryType Text;
    public static XmlQueryType TextS;
    public static XmlQueryType Comment;
    public static XmlQueryType CommentS;
    public static XmlQueryType PI;
    public static XmlQueryType PIS;
    public static XmlQueryType DocumentOrElement;
    public static XmlQueryType DocumentOrElementQ;
    public static XmlQueryType DocumentOrElementS;
    public static XmlQueryType Content;
    public static XmlQueryType ContentS;
    public static XmlQueryType DocumentOrContent;
    public static XmlQueryType DocumentOrContentS;
    public static XmlQueryType AttributeOrContent;
    public static XmlQueryType AttributeOrContentS;
    public static XmlQueryType AnyAtomicType;
    public static XmlQueryType AnyAtomicTypeS;
    public static XmlQueryType String;
    public static XmlQueryType StringX;
    public static XmlQueryType StringXS;
    public static XmlQueryType Boolean;
    public static XmlQueryType BooleanX;
    public static XmlQueryType Int;
    public static XmlQueryType IntX;
    public static XmlQueryType IntXS;
    public static XmlQueryType IntegerX;
    public static XmlQueryType LongX;
    public static XmlQueryType DecimalX;
    public static XmlQueryType FloatX;
    public static XmlQueryType Double;
    public static XmlQueryType DoubleX;
    public static XmlQueryType DateTimeX;
    public static XmlQueryType QNameX;
    public static XmlQueryType UntypedDocument;
    public static XmlQueryType UntypedElement;
    public static XmlQueryType UntypedAttribute;
    public static XmlQueryType UntypedNode;
    public static XmlQueryType UntypedNodeS;
    public static XmlQueryType NodeNotRtf;
    public static XmlQueryType NodeNotRtfQ;
    public static XmlQueryType NodeNotRtfS;
    public static XmlQueryType NodeSDod;
    private static XmlQueryTypeFactory();
    public static XmlQueryType Type(XmlTypeCode code, bool isStrict);
    public static XmlQueryType Type(XmlSchemaSimpleType schemaType, bool isStrict);
    public static XmlQueryType Choice(XmlQueryType left, XmlQueryType right);
    public static XmlQueryType Choice(XmlQueryType[] types);
    public static XmlQueryType NodeChoice(XmlNodeKindFlags kinds);
    public static XmlQueryType Sequence(XmlQueryType left, XmlQueryType right);
    public static XmlQueryType PrimeProduct(XmlQueryType t, XmlQueryCardinality c);
    public static XmlQueryType Product(XmlQueryType t, XmlQueryCardinality c);
    public static XmlQueryType AtMost(XmlQueryType t, XmlQueryCardinality c);
    public static XmlQueryType Type(XPathNodeType kind, XmlQualifiedNameTest nameTest, XmlSchemaType contentType, bool isNillable);
    [ConditionalAttribute("DEBUG")]
public static void CheckSerializability(XmlQueryType type);
    public static void Serialize(BinaryWriter writer, XmlQueryType type);
    public static XmlQueryType Deserialize(BinaryReader reader);
}
internal interface System.Xml.Xsl.XPath.IFocus {
    public abstract virtual QilNode GetCurrent();
    public abstract virtual QilNode GetPosition();
    public abstract virtual QilNode GetLast();
}
internal interface System.Xml.Xsl.XPath.IXPathBuilder`1 {
    public abstract virtual void StartBuild();
    public abstract virtual Node EndBuild(Node result);
    public abstract virtual Node String(string value);
    public abstract virtual Node Number(double value);
    public abstract virtual Node Operator(XPathOperator op, Node left, Node right);
    public abstract virtual Node Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name);
    public abstract virtual Node JoinStep(Node left, Node right);
    public abstract virtual Node Predicate(Node node, Node condition, bool reverseStep);
    public abstract virtual Node Variable(string prefix, string name);
    public abstract virtual Node Function(string prefix, string name, IList`1<Node> args);
}
internal interface System.Xml.Xsl.XPath.IXPathEnvironment {
    public XPathQilFactory Factory { get; }
    public abstract virtual XPathQilFactory get_Factory();
    public abstract virtual QilNode ResolveVariable(string prefix, string name);
    public abstract virtual QilNode ResolveFunction(string prefix, string name, IList`1<QilNode> args, IFocus env);
    public abstract virtual string ResolvePrefix(string prefix);
}
internal enum System.Xml.Xsl.XPath.LexKind : Enum {
    public int value__;
    public static LexKind Unknown;
    public static LexKind Or;
    public static LexKind And;
    public static LexKind Eq;
    public static LexKind Ne;
    public static LexKind Lt;
    public static LexKind Le;
    public static LexKind Gt;
    public static LexKind Ge;
    public static LexKind Plus;
    public static LexKind Minus;
    public static LexKind Multiply;
    public static LexKind Divide;
    public static LexKind Modulo;
    public static LexKind UnaryMinus;
    public static LexKind Union;
    public static LexKind LastOperator;
    public static LexKind DotDot;
    public static LexKind ColonColon;
    public static LexKind SlashSlash;
    public static LexKind Number;
    public static LexKind Axis;
    public static LexKind Name;
    public static LexKind String;
    public static LexKind Eof;
    public static LexKind FirstStringable;
    public static LexKind LastNonChar;
    public static LexKind LParens;
    public static LexKind RParens;
    public static LexKind LBracket;
    public static LexKind RBracket;
    public static LexKind Dot;
    public static LexKind At;
    public static LexKind Comma;
    public static LexKind Star;
    public static LexKind Slash;
    public static LexKind Dollar;
    public static LexKind RBrace;
}
internal enum System.Xml.Xsl.XPath.XPathAxis : Enum {
    public int value__;
    public static XPathAxis Unknown;
    public static XPathAxis Ancestor;
    public static XPathAxis AncestorOrSelf;
    public static XPathAxis Attribute;
    public static XPathAxis Child;
    public static XPathAxis Descendant;
    public static XPathAxis DescendantOrSelf;
    public static XPathAxis Following;
    public static XPathAxis FollowingSibling;
    public static XPathAxis Namespace;
    public static XPathAxis Parent;
    public static XPathAxis Preceding;
    public static XPathAxis PrecedingSibling;
    public static XPathAxis Self;
    public static XPathAxis Root;
}
internal class System.Xml.Xsl.XPath.XPathBuilder : object {
    protected QilNode fixupCurrent;
    protected QilNode fixupPosition;
    protected QilNode fixupLast;
    protected int numFixupCurrent;
    protected int numFixupPosition;
    protected int numFixupLast;
    public static XmlTypeCode[] argAny;
    public static XmlTypeCode[] argNodeSet;
    public static XmlTypeCode[] argBoolean;
    public static XmlTypeCode[] argDouble;
    public static XmlTypeCode[] argString;
    public static XmlTypeCode[] argString2;
    public static XmlTypeCode[] argString3;
    public static XmlTypeCode[] argFnSubstr;
    public static Dictionary`2<string, FunctionInfo`1<FuncId>> FunctionTable;
    private XPathQilFactory System.Xml.Xsl.XPath.IXPathEnvironment.Factory { get; }
    public XPathBuilder(IXPathEnvironment environment);
    private static XPathBuilder();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetCurrent();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetPosition();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetLast();
    private sealed virtual override XPathQilFactory System.Xml.Xsl.XPath.IXPathEnvironment.get_Factory();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IXPathEnvironment.ResolveVariable(string prefix, string name);
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IXPathEnvironment.ResolveFunction(string prefix, string name, IList`1<QilNode> args, IFocus env);
    private sealed virtual override string System.Xml.Xsl.XPath.IXPathEnvironment.ResolvePrefix(string prefix);
    public virtual void StartBuild();
    public virtual QilNode EndBuild(QilNode result);
    public virtual QilNode String(string value);
    public virtual QilNode Number(double value);
    public virtual QilNode Operator(XPathOperator op, QilNode left, QilNode right);
    public static XmlNodeKindFlags AxisTypeMask(XmlNodeKindFlags inputTypeMask, XPathNodeType nodeType, XPathAxis xpathAxis);
    public virtual QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name);
    public virtual QilNode JoinStep(QilNode left, QilNode right);
    public virtual QilNode Predicate(QilNode nodeset, QilNode predicate, bool isReverseStep);
    public static QilNode PredicateToBoolean(QilNode predicate, XPathQilFactory f, IXPathEnvironment env);
    public static QilNode BuildOnePredicate(QilNode nodeset, QilNode predicate, bool isReverseStep, XPathQilFactory f, FixupVisitor fixupVisitor, Int32& numFixupCurrent, Int32& numFixupPosition, Int32& numFixupLast);
    public virtual QilNode Variable(string prefix, string name);
    public virtual QilNode Function(string prefix, string name, IList`1<QilNode> args);
    public static bool IsFunctionAvailable(string localName, string nsUri);
}
internal class System.Xml.Xsl.XPath.XPathCompileException : XslLoadException {
    public string queryString;
    public int startChar;
    public int endChar;
    protected XPathCompileException(SerializationInfo info, StreamingContext context);
    internal XPathCompileException(string queryString, int startChar, int endChar, string resId, String[] args);
    internal XPathCompileException(string resId, String[] args);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string MarkOutError();
    internal virtual string FormatDetailedMessage();
}
internal enum System.Xml.Xsl.XPath.XPathOperator : Enum {
    public int value__;
    public static XPathOperator Unknown;
    public static XPathOperator Or;
    public static XPathOperator And;
    public static XPathOperator Eq;
    public static XPathOperator Ne;
    public static XPathOperator Lt;
    public static XPathOperator Le;
    public static XPathOperator Gt;
    public static XPathOperator Ge;
    public static XPathOperator Plus;
    public static XPathOperator Minus;
    public static XPathOperator Multiply;
    public static XPathOperator Divide;
    public static XPathOperator Modulo;
    public static XPathOperator UnaryMinus;
    public static XPathOperator Union;
    public static XPathOperator LastXPath1Operator;
    public static XPathOperator UnaryPlus;
    public static XPathOperator Idiv;
    public static XPathOperator Is;
    public static XPathOperator After;
    public static XPathOperator Before;
    public static XPathOperator Range;
    public static XPathOperator Except;
    public static XPathOperator Intersect;
    public static XPathOperator ValEq;
    public static XPathOperator ValNe;
    public static XPathOperator ValLt;
    public static XPathOperator ValLe;
    public static XPathOperator ValGt;
    public static XPathOperator ValGe;
}
internal class System.Xml.Xsl.XPath.XPathParser`1 : object {
    private static XPathParser`1();
    public Node Parse(XPathScanner scanner, IXPathBuilder`1<Node> builder, LexKind endLex);
    internal static bool IsStep(LexKind lexKind);
    internal static void InternalParseNodeTest(XPathScanner scanner, XPathAxis axis, XPathNodeType& nodeType, String& nodePrefix, String& nodeName);
}
internal class System.Xml.Xsl.XPath.XPathQilFactory : QilPatternFactory {
    public XPathQilFactory(QilFactory f, bool debug);
    public QilNode Error(string res, QilNode args);
    public QilNode Error(ISourceLineInfo lineInfo, string res, String[] args);
    public QilIterator FirstNode(QilNode n);
    public bool IsAnyType(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckAny(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckNode(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckNodeSet(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckNodeNotRtf(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckString(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckStringS(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckDouble(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckBool(QilNode n);
    public bool CannotBeNodeSet(QilNode n);
    public QilNode SafeDocOrderDistinct(QilNode n);
    public QilNode InvokeFormatMessage(QilNode res, QilNode args);
    public QilNode InvokeEqualityOperator(QilNodeType op, QilNode left, QilNode right);
    public QilNode InvokeRelationalOperator(QilNodeType op, QilNode left, QilNode right);
    public QilNode ConvertToType(XmlTypeCode requiredType, QilNode n);
    public QilNode ConvertToString(QilNode n);
    public QilNode ConvertToBoolean(QilNode n);
    public QilNode ConvertToNumber(QilNode n);
    public QilNode ConvertToNode(QilNode n);
    public QilNode ConvertToNodeSet(QilNode n);
    public QilNode TryEnsureNodeSet(QilNode n);
    public QilNode EnsureNodeSet(QilNode n);
    public QilNode InvokeEnsureNodeSet(QilNode n);
    public QilNode Id(QilNode context, QilNode id);
    public QilNode InvokeStartsWith(QilNode str1, QilNode str2);
    public QilNode InvokeContains(QilNode str1, QilNode str2);
    public QilNode InvokeSubstringBefore(QilNode str1, QilNode str2);
    public QilNode InvokeSubstringAfter(QilNode str1, QilNode str2);
    public QilNode InvokeSubstring(QilNode str, QilNode start);
    public QilNode InvokeSubstring(QilNode str, QilNode start, QilNode length);
    public QilNode InvokeNormalizeSpace(QilNode str);
    public QilNode InvokeTranslate(QilNode str1, QilNode str2, QilNode str3);
    public QilNode InvokeLang(QilNode lang, QilNode context);
    public QilNode InvokeFloor(QilNode value);
    public QilNode InvokeCeiling(QilNode value);
    public QilNode InvokeRound(QilNode value);
}
internal class System.Xml.Xsl.XPath.XPathScanner : object {
    public string Source { get; }
    public LexKind Kind { get; }
    public int LexStart { get; }
    public int LexSize { get; }
    public int PrevLexEnd { get; }
    public string Name { get; }
    public string Prefix { get; }
    public string RawValue { get; }
    public string StringValue { get; }
    public bool CanBeFunction { get; }
    public XPathAxis Axis { get; }
    public XPathScanner(string xpathExpr);
    public XPathScanner(string xpathExpr, int startFrom);
    public string get_Source();
    public LexKind get_Kind();
    public int get_LexStart();
    public int get_LexSize();
    public int get_PrevLexEnd();
    public string get_Name();
    public string get_Prefix();
    public string get_RawValue();
    public string get_StringValue();
    public bool get_CanBeFunction();
    public XPathAxis get_Axis();
    public void NextLex();
    public void PassToken(LexKind t);
    public void CheckToken(LexKind t);
    public XPathCompileException CreateException(string resId, String[] args);
}
internal static class System.Xml.Xsl.XPathConvert : object {
    public static Double[] C10toN;
    private static XPathConvert();
    public static UInt32 DblHi(double dbl);
    public static UInt32 DblLo(double dbl);
    public static bool IsSpecial(double dbl);
    public static UInt32 NotZero(UInt32 u);
    public static UInt32 AddU(UInt32& u1, UInt32 u2);
    public static UInt32 MulU(UInt32 u1, UInt32 u2, UInt32& uHi);
    public static int CbitZeroLeft(UInt32 u);
    public static bool IsInteger(double dbl, Int32& value);
    public static string DoubleToString(double dbl);
    public static double StringToDouble(string s);
}
[FlagsAttribute]
internal enum System.Xml.Xsl.XslFlags : Enum {
    public int value__;
    public static XslFlags None;
    public static XslFlags String;
    public static XslFlags Number;
    public static XslFlags Boolean;
    public static XslFlags Node;
    public static XslFlags Nodeset;
    public static XslFlags Rtf;
    public static XslFlags TypeFilter;
    public static XslFlags AnyType;
    public static XslFlags Current;
    public static XslFlags Position;
    public static XslFlags Last;
    public static XslFlags FocusFilter;
    public static XslFlags FullFocus;
    public static XslFlags HasCalls;
    public static XslFlags MayBeDefault;
    public static XslFlags SideEffects;
    public static XslFlags Stop;
}
internal class System.Xml.Xsl.XslLoadException : XslTransformException {
    public string SourceUri { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    protected XslLoadException(SerializationInfo info, StreamingContext context);
    internal XslLoadException(string res, String[] args);
    internal XslLoadException(Exception inner, ISourceLineInfo lineInfo);
    internal XslLoadException(CompilerError error);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal void SetSourceLineInfo(ISourceLineInfo lineInfo);
    public virtual string get_SourceUri();
    public virtual int get_LineNumber();
    public virtual int get_LinePosition();
    internal static string CreateMessage(ISourceLineInfo lineInfo, string res, String[] args);
    internal virtual string FormatDetailedMessage();
}
internal static class System.Xml.Xsl.Xslt.AstFactory : object {
    private static AstFactory();
    public static XslNode XslNode(XslNodeType nodeType, QilName name, string arg, XslVersion xslVer);
    public static XslNode ApplyImports(QilName mode, Stylesheet sheet, XslVersion xslVer);
    public static XslNodeEx ApplyTemplates(QilName mode, string select, ContextInfo ctxInfo, XslVersion xslVer);
    public static XslNodeEx ApplyTemplates(QilName mode);
    public static NodeCtor Attribute(string nameAvt, string nsAvt, XslVersion xslVer);
    public static AttributeSet AttributeSet(QilName name);
    public static XslNodeEx CallTemplate(QilName name, ContextInfo ctxInfo);
    public static XslNode Choose();
    public static XslNode Comment();
    public static XslNode Copy();
    public static XslNode CopyOf(string select, XslVersion xslVer);
    public static NodeCtor Element(string nameAvt, string nsAvt, XslVersion xslVer);
    public static XslNode Error(string message);
    public static XslNodeEx ForEach(string select, ContextInfo ctxInfo, XslVersion xslVer);
    public static XslNode If(string test, XslVersion xslVer);
    public static Key Key(QilName name, string match, string use, XslVersion xslVer);
    public static XslNode List();
    public static XslNode LiteralAttribute(QilName name, string value, XslVersion xslVer);
    public static XslNode LiteralElement(QilName name);
    public static XslNode Message(bool term);
    public static XslNode Nop();
    public static Number Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer);
    public static XslNode Otherwise();
    public static XslNode PI(string name, XslVersion xslVer);
    public static Sort Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer);
    public static Template Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer);
    public static XslNode Text(string data);
    public static XslNode Text(string data, SerializationHints hints);
    public static XslNode UseAttributeSet(QilName name);
    public static VarPar VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer);
    public static VarPar WithParam(QilName name);
    public static QilName QName(string local, string uri, string prefix);
    public static QilName QName(string local);
}
internal class System.Xml.Xsl.Xslt.AttributeSet : ProtoTemplate {
    public CycleCheck CycleCheck;
    public AttributeSet(QilName name, XslVersion xslVer);
    public virtual string GetDebugName();
    public void AddContent(XslNode node);
    public void MergeContent(AttributeSet other);
}
internal class System.Xml.Xsl.Xslt.Compiler : object {
    public XsltSettings Settings;
    public bool IsDebug;
    public string ScriptAssemblyPath;
    public int Version;
    public string inputTypeAnnotations;
    public CompilerResults CompilerResults;
    public int CurrentPrecedence;
    public XslNode StartApplyTemplates;
    public RootLevel Root;
    public Scripts Scripts;
    public Output Output;
    public List`1<VarPar> ExternalPars;
    public List`1<VarPar> GlobalVars;
    public List`1<WhitespaceRule> WhitespaceRules;
    public DecimalFormats DecimalFormats;
    public Keys Keys;
    public List`1<ProtoTemplate> AllTemplates;
    public Dictionary`2<QilName, VarPar> AllGlobalVarPars;
    public Dictionary`2<QilName, Template> NamedTemplates;
    public Dictionary`2<QilName, AttributeSet> AttributeSets;
    public Dictionary`2<string, NsAlias> NsAliases;
    public string PhantomNCName;
    public Compiler(XsltSettings settings, bool debug, string scriptAssemblyPath);
    public CompilerResults Compile(object stylesheet, XmlResolver xmlResolver, QilExpression& qil);
    public Stylesheet CreateStylesheet();
    public void AddModule(string baseUri);
    public void ApplyNsAliases(String& prefix, String& nsUri);
    public bool SetNsAlias(string ssheetNsUri, string resultNsUri, string resultPrefix, int importPrecedence);
    public void MergeWithStylesheet(Stylesheet sheet);
    public static string ConstructQName(string prefix, string localName);
    public bool ParseQName(string qname, String& prefix, String& localName, IErrorHelper errorHelper);
    public bool ParseNameTest(string nameTest, String& prefix, String& localName, IErrorHelper errorHelper);
    public void ValidatePiName(string name, IErrorHelper errorHelper);
    public string CreatePhantomNamespace();
    public bool IsPhantomNamespace(string namespaceName);
    public bool IsPhantomName(QilName qname);
    public void EnterForwardsCompatible();
    public bool ExitForwardsCompatible(bool fwdCompat);
    public CompilerError CreateError(ISourceLineInfo lineInfo, string res, String[] args);
    public void ReportError(ISourceLineInfo lineInfo, string res, String[] args);
    public void ReportWarning(ISourceLineInfo lineInfo, string res, String[] args);
}
internal class System.Xml.Xsl.Xslt.CompilerScopeManager`1 : object {
    public bool ForwardCompatibility { get; public set; }
    public bool BackwardCompatibility { get; public set; }
    public bool CanHaveApplyImports { get; public set; }
    public CompilerScopeManager`1(KeywordsTable atoms);
    public void EnterScope();
    public void ExitScope();
    [ConditionalAttribute("DEBUG")]
public void CheckEmpty();
    public bool EnterScope(NsDecl nsDecl);
    public void AddVariable(QilName varName, V value);
    public string LookupNamespace(string prefix);
    public void AddNsDeclaration(string prefix, string nsUri);
    public void AddExNamespace(string nsUri);
    public bool IsExNamespace(string nsUri);
    public V LookupVariable(string localName, string uri);
    public bool IsLocalVariable(string localName, string uri);
    public bool get_ForwardCompatibility();
    public void set_ForwardCompatibility(bool value);
    public bool get_BackwardCompatibility();
    public void set_BackwardCompatibility(bool value);
    public bool get_CanHaveApplyImports();
    public void set_CanHaveApplyImports(bool value);
    [IteratorStateMachineAttribute("System.Xml.Xsl.Xslt.CompilerScopeManager`1/<GetActiveRecords>d__1")]
internal IEnumerable`1<ScopeRecord<V>> GetActiveRecords();
    public NamespaceEnumerator<V> GetEnumerator();
}
internal enum System.Xml.Xsl.Xslt.CycleCheck : Enum {
    public int value__;
    public static CycleCheck NotStarted;
    public static CycleCheck Processing;
    public static CycleCheck Completed;
}
internal class System.Xml.Xsl.Xslt.DecimalFormatDecl : object {
    public XmlQualifiedName Name;
    public string InfinitySymbol;
    public string NanSymbol;
    public Char[] Characters;
    public static DecimalFormatDecl Default;
    public DecimalFormatDecl(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters);
    private static DecimalFormatDecl();
}
internal class System.Xml.Xsl.Xslt.DecimalFormats : KeyedCollection`2<XmlQualifiedName, DecimalFormatDecl> {
    protected virtual XmlQualifiedName GetKeyForItem(DecimalFormatDecl format);
}
internal class System.Xml.Xsl.Xslt.FunctionFocus : ValueType {
    private bool isSet;
    private QilParameter current;
    private QilParameter position;
    private QilParameter last;
    public bool IsFocusSet { get; }
    public void StartFocus(IList`1<QilNode> args, XslFlags flags);
    public void StopFocus();
    public bool get_IsFocusSet();
    public sealed virtual QilNode GetCurrent();
    public sealed virtual QilNode GetPosition();
    public sealed virtual QilNode GetLast();
}
internal class System.Xml.Xsl.Xslt.InvokeGenerator : QilCloneVisitor {
    public InvokeGenerator(XsltQilFactory f, bool debug);
    public QilNode GenerateInvoke(QilFunction func, IList`1<XslNode> actualArgs);
    protected virtual QilNode VisitReference(QilNode n);
    protected virtual QilNode VisitFunction(QilFunction n);
}
internal class System.Xml.Xsl.Xslt.Key : XslNode {
    public string Match;
    public string Use;
    public QilFunction Function;
    public Key(QilName name, string match, string use, XslVersion xslVer);
    public string GetDebugName();
}
internal class System.Xml.Xsl.Xslt.KeyMatchBuilder : XPathBuilder {
    public KeyMatchBuilder(IXPathEnvironment env);
    public virtual void StartBuild();
    public virtual QilNode EndBuild(QilNode result);
    public virtual IXPathBuilder`1<QilNode> GetPredicateBuilder(QilNode ctx);
}
internal class System.Xml.Xsl.Xslt.Keys : KeyedCollection`2<QilName, List`1<Key>> {
    protected virtual QilName GetKeyForItem(List`1<Key> list);
}
internal class System.Xml.Xsl.Xslt.KeywordsTable : object {
    public XmlNameTable NameTable;
    public string AnalyzeString;
    public string ApplyImports;
    public string ApplyTemplates;
    public string Assembly;
    public string Attribute;
    public string AttributeSet;
    public string CallTemplate;
    public string CaseOrder;
    public string CDataSectionElements;
    public string Character;
    public string CharacterMap;
    public string Choose;
    public string Comment;
    public string Copy;
    public string CopyOf;
    public string Count;
    public string DataType;
    public string DecimalFormat;
    public string DecimalSeparator;
    public string DefaultCollation;
    public string DefaultValidation;
    public string Digit;
    public string DisableOutputEscaping;
    public string DocTypePublic;
    public string DocTypeSystem;
    public string Document;
    public string Element;
    public string Elements;
    public string Encoding;
    public string ExcludeResultPrefixes;
    public string ExtensionElementPrefixes;
    public string Fallback;
    public string ForEach;
    public string ForEachGroup;
    public string Format;
    public string From;
    public string Function;
    public string GroupingSeparator;
    public string GroupingSize;
    public string Href;
    public string Id;
    public string If;
    public string ImplementsPrefix;
    public string Import;
    public string ImportSchema;
    public string Include;
    public string Indent;
    public string Infinity;
    public string Key;
    public string Lang;
    public string Language;
    public string LetterValue;
    public string Level;
    public string Match;
    public string MatchingSubstring;
    public string MediaType;
    public string Message;
    public string Method;
    public string MinusSign;
    public string Mode;
    public string Name;
    public string Namespace;
    public string NamespaceAlias;
    public string NaN;
    public string NextMatch;
    public string NonMatchingSubstring;
    public string Number;
    public string OmitXmlDeclaration;
    public string Order;
    public string Otherwise;
    public string Output;
    public string OutputCharacter;
    public string OutputVersion;
    public string Param;
    public string PatternSeparator;
    public string Percent;
    public string PerformSort;
    public string PerMille;
    public string PreserveSpace;
    public string Priority;
    public string ProcessingInstruction;
    public string Required;
    public string ResultDocument;
    public string ResultPrefix;
    public string Script;
    public string Select;
    public string Separator;
    public string Sequence;
    public string Sort;
    public string Space;
    public string Standalone;
    public string StripSpace;
    public string Stylesheet;
    public string StylesheetPrefix;
    public string Template;
    public string Terminate;
    public string Test;
    public string Text;
    public string Transform;
    public string UrnMsxsl;
    public string UriXml;
    public string UriXsl;
    public string UriWdXsl;
    public string Use;
    public string UseAttributeSets;
    public string UseWhen;
    public string Using;
    public string Value;
    public string ValueOf;
    public string Variable;
    public string Version;
    public string When;
    public string WithParam;
    public string Xml;
    public string Xmlns;
    public string XPathDefaultNamespace;
    public string ZeroDigit;
    public KeywordsTable(XmlNameTable nt);
}
internal class System.Xml.Xsl.Xslt.LoopFocus : ValueType {
    private XPathQilFactory f;
    private QilIterator current;
    private QilIterator cached;
    private QilIterator last;
    public bool IsFocusSet { get; }
    public LoopFocus(XPathQilFactory f);
    public void SetFocus(QilIterator current);
    public bool get_IsFocusSet();
    public sealed virtual QilNode GetCurrent();
    public sealed virtual QilNode GetPosition();
    public sealed virtual QilNode GetLast();
    public void EnsureCache();
    public void Sort(QilNode sortKeys);
    public QilLoop ConstructLoop(QilNode body);
}
internal class System.Xml.Xsl.Xslt.MatcherBuilder : object {
    public MatcherBuilder(XPathQilFactory f, ReferenceReplacer refReplacer, InvokeGenerator invkGen);
    public void CollectPatterns(StylesheetLevel sheet, QilName mode);
    public QilNode BuildMatcher(QilIterator it, IList`1<XslNode> actualArgs, QilNode otherwise);
}
internal class System.Xml.Xsl.Xslt.NodeCtor : XslNode {
    public string NameAvt;
    public string NsAvt;
    public NodeCtor(XslNodeType nt, string nameAvt, string nsAvt, XslVersion xslVer);
}
internal class System.Xml.Xsl.Xslt.NsAlias : object {
    public string ResultNsUri;
    public string ResultPrefix;
    public int ImportPrecedence;
    public NsAlias(string resultNsUri, string resultPrefix, int importPrecedence);
}
internal class System.Xml.Xsl.Xslt.NsDecl : object {
    public NsDecl Prev;
    public string Prefix;
    public string NsUri;
    public NsDecl(NsDecl prev, string prefix, string nsUri);
}
internal class System.Xml.Xsl.Xslt.Number : XslNode {
    public NumberLevel Level;
    public string Count;
    public string From;
    public string Value;
    public string Format;
    public string Lang;
    public string LetterValue;
    public string GroupingSeparator;
    public string GroupingSize;
    public Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer);
}
internal enum System.Xml.Xsl.Xslt.NumberLevel : Enum {
    public int value__;
    public static NumberLevel Single;
    public static NumberLevel Multiple;
    public static NumberLevel Any;
}
internal class System.Xml.Xsl.Xslt.Output : object {
    public XmlWriterSettings Settings;
    public string Version;
    public string Encoding;
    public XmlQualifiedName Method;
    public static int NeverDeclaredPrec;
    public int MethodPrec;
    public int VersionPrec;
    public int EncodingPrec;
    public int OmitXmlDeclarationPrec;
    public int StandalonePrec;
    public int DocTypePublicPrec;
    public int DocTypeSystemPrec;
    public int IndentPrec;
    public int MediaTypePrec;
}
internal class System.Xml.Xsl.Xslt.OutputScopeManager : object {
    public void Reset();
    public void PushScope();
    public void PopScope();
    public void AddNamespace(string prefix, string uri);
    public void InvalidateAllPrefixes();
    public void InvalidateNonDefaultPrefixes();
    public string LookupNamespace(string prefix);
}
internal class System.Xml.Xsl.Xslt.Pattern : ValueType {
    public TemplateMatch Match;
    public int Priority;
    public Pattern(TemplateMatch match, int priority);
}
internal class System.Xml.Xsl.Xslt.PatternBag : object {
    public Dictionary`2<QilName, List`1<Pattern>> FixedNamePatterns;
    public List`1<QilName> FixedNamePatternsNames;
    public List`1<Pattern> NonFixedNamePatterns;
    public void Clear();
    public void Add(Pattern pattern);
}
internal abstract class System.Xml.Xsl.Xslt.ProtoTemplate : XslNode {
    public QilFunction Function;
    public ProtoTemplate(XslNodeType nt, QilName name, XslVersion xslVer);
    public abstract virtual string GetDebugName();
}
internal class System.Xml.Xsl.Xslt.QilGenerator : object {
    public static Dictionary`2<string, FunctionInfo`1<FuncId>> FunctionTable;
    private XPathQilFactory System.Xml.Xsl.XPath.IXPathEnvironment.Factory { get; }
    private static QilGenerator();
    public static QilExpression CompileStylesheet(Compiler compiler);
    public sealed virtual void ReportError(string res, String[] args);
    public sealed virtual void ReportWarning(string res, String[] args);
    private sealed virtual override XPathQilFactory System.Xml.Xsl.XPath.IXPathEnvironment.get_Factory();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetCurrent();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetPosition();
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IFocus.GetLast();
    private sealed virtual override string System.Xml.Xsl.XPath.IXPathEnvironment.ResolvePrefix(string prefix);
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IXPathEnvironment.ResolveVariable(string prefix, string name);
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IXPathEnvironment.ResolveFunction(string prefix, string name, IList`1<QilNode> args, IFocus env);
    public static bool IsFunctionAvailable(string localName, string nsUri);
    public static bool IsElementAvailable(XmlQualifiedName name);
}
internal class System.Xml.Xsl.Xslt.QilStrConcatenator : object {
    public QilStrConcatenator(XPathQilFactory f);
    public void Reset();
    public void Append(string value);
    public void Append(char value);
    public void Append(QilNode value);
    public QilNode ToQil();
}
internal class System.Xml.Xsl.Xslt.ReferenceReplacer : QilReplaceVisitor {
    public ReferenceReplacer(QilFactory f);
    public QilNode Replace(QilNode expr, QilReference lookFor, QilReference replaceBy);
    protected virtual QilNode VisitReference(QilNode n);
}
internal class System.Xml.Xsl.Xslt.RootLevel : StylesheetLevel {
    public RootLevel(Stylesheet principal);
}
internal class System.Xml.Xsl.Xslt.ScriptClass : object {
    public string ns;
    public CompilerInfo compilerInfo;
    public StringCollection refAssemblies;
    public StringCollection nsImports;
    public CodeTypeDeclaration typeDecl;
    public bool refAssembliesByHref;
    public Dictionary`2<string, string> scriptUris;
    public string endUri;
    public Location endLoc;
    public ISourceLineInfo EndLineInfo { get; }
    public ScriptClass(string ns, CompilerInfo compilerInfo);
    private static ScriptClass();
    public void AddScriptBlock(string source, string uriString, int lineNumber, Location end);
    public ISourceLineInfo get_EndLineInfo();
}
internal class System.Xml.Xsl.Xslt.Scripts : object {
    public Dictionary`2<string, Type> ScriptClasses { get; }
    public Scripts(Compiler compiler);
    private static Scripts();
    public Dictionary`2<string, Type> get_ScriptClasses();
    public XmlExtensionFunction ResolveFunction(string name, string ns, int numArgs, IErrorHelper errorHelper);
    public ScriptClass GetScriptClass(string ns, string language, IErrorHelper errorHelper);
    public void CompileScripts();
}
internal class System.Xml.Xsl.Xslt.SingletonFocus : ValueType {
    private XPathQilFactory f;
    private SingletonFocusType focusType;
    private QilIterator current;
    public SingletonFocus(XPathQilFactory f);
    public void SetFocus(SingletonFocusType focusType);
    public void SetFocus(QilIterator current);
    public sealed virtual QilNode GetCurrent();
    public sealed virtual QilNode GetPosition();
    public sealed virtual QilNode GetLast();
}
internal enum System.Xml.Xsl.Xslt.SingletonFocusType : Enum {
    public int value__;
    public static SingletonFocusType None;
    public static SingletonFocusType InitialDocumentNode;
    public static SingletonFocusType InitialContextNode;
    public static SingletonFocusType Iterator;
}
internal class System.Xml.Xsl.Xslt.Sort : XslNode {
    public string Lang;
    public string DataType;
    public string Order;
    public string CaseOrder;
    public Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer);
}
internal class System.Xml.Xsl.Xslt.Stylesheet : StylesheetLevel {
    public List`1<Uri> ImportHrefs;
    public List`1<XslNode> GlobalVarPars;
    public Dictionary`2<QilName, AttributeSet> AttributeSets;
    public List`1[] WhitespaceRules;
    public List`1<Template> Templates;
    public Dictionary`2<QilName, List`1<TemplateMatch>> TemplateMatches;
    public int ImportPrecedence { get; }
    public Stylesheet(Compiler compiler, int importPrecedence);
    public void AddTemplateMatch(Template template, QilLoop filter);
    public void SortTemplateMatches();
    public int get_ImportPrecedence();
    public void AddWhitespaceRule(int index, WhitespaceRule rule);
    public bool AddVarPar(VarPar var);
    public bool AddTemplate(Template template);
}
internal class System.Xml.Xsl.Xslt.StylesheetLevel : object {
    public Stylesheet[] Imports;
    public Dictionary`2<QilName, XslFlags> ModeFlags;
    public Dictionary`2<QilName, List`1<QilFunction>> ApplyFunctions;
}
internal class System.Xml.Xsl.Xslt.Template : ProtoTemplate {
    public string Match;
    public QilName Mode;
    public double Priority;
    public int ImportPrecedence;
    public int OrderNumber;
    public Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer);
    public virtual string GetDebugName();
}
internal class System.Xml.Xsl.Xslt.TemplateMatch : object {
    public static TemplateMatchComparer Comparer;
    public XmlNodeKindFlags NodeKind { get; }
    public QilName QName { get; }
    public QilIterator Iterator { get; }
    public QilNode Condition { get; }
    public QilFunction TemplateFunction { get; }
    public TemplateMatch(Template template, QilLoop filter);
    private static TemplateMatch();
    public XmlNodeKindFlags get_NodeKind();
    public QilName get_QName();
    public QilIterator get_Iterator();
    public QilNode get_Condition();
    public QilFunction get_TemplateFunction();
}
internal class System.Xml.Xsl.Xslt.Text : XslNode {
    public SerializationHints Hints;
    public Text(string data, SerializationHints hints, XslVersion xslVer);
}
internal class System.Xml.Xsl.Xslt.VarPar : XslNode {
    public XslFlags DefValueFlags;
    public QilNode Value;
    public VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer);
}
internal class System.Xml.Xsl.Xslt.XPathPatternBuilder : object {
    public QilNode FixupNode { get; }
    public XPathPatternBuilder(IXPathEnvironment environment);
    public QilNode get_FixupNode();
    public virtual void StartBuild();
    [ConditionalAttribute("DEBUG")]
public void AssertFilter(QilLoop filter);
    public virtual QilNode EndBuild(QilNode result);
    public sealed virtual QilNode Operator(XPathOperator op, QilNode left, QilNode right);
    public sealed virtual QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name);
    public sealed virtual QilNode JoinStep(QilNode left, QilNode right);
    private sealed virtual override QilNode System.Xml.Xsl.XPath.IXPathBuilder<System.Xml.Xsl.Qil.QilNode>.Predicate(QilNode node, QilNode condition, bool isReverseStep);
    public QilNode BuildPredicates(QilNode nodeset, List`1<QilNode> predicates);
    public sealed virtual QilNode Function(string prefix, string name, IList`1<QilNode> args);
    public sealed virtual QilNode String(string value);
    public sealed virtual QilNode Number(double value);
    public sealed virtual QilNode Variable(string prefix, string name);
    public static void SetPriority(QilNode node, double priority);
    public static double GetPriority(QilNode node);
    public static void CleanAnnotation(QilNode node);
    public sealed virtual IXPathBuilder`1<QilNode> GetPredicateBuilder(QilNode ctx);
}
internal class System.Xml.Xsl.Xslt.XPathPatternParser : object {
    public QilNode Parse(XPathScanner scanner, IPatternBuilder ptrnBuilder);
}
internal class System.Xml.Xsl.Xslt.XslAstAnalyzer : XslVisitor`1<XslFlags> {
    public XslFlags Analyze(Compiler compiler);
    protected virtual XslFlags Visit(XslNode node);
    protected virtual XslFlags VisitChildren(XslNode node);
    protected virtual XslFlags VisitAttributeSet(AttributeSet node);
    protected virtual XslFlags VisitTemplate(Template node);
    protected virtual XslFlags VisitApplyImports(XslNode node);
    protected virtual XslFlags VisitApplyTemplates(XslNode node);
    protected virtual XslFlags VisitAttribute(NodeCtor node);
    protected virtual XslFlags VisitCallTemplate(XslNode node);
    protected virtual XslFlags VisitComment(XslNode node);
    protected virtual XslFlags VisitCopy(XslNode node);
    protected virtual XslFlags VisitCopyOf(XslNode node);
    protected virtual XslFlags VisitElement(NodeCtor node);
    protected virtual XslFlags VisitError(XslNode node);
    protected virtual XslFlags VisitForEach(XslNode node);
    protected virtual XslFlags VisitIf(XslNode node);
    protected virtual XslFlags VisitLiteralAttribute(XslNode node);
    protected virtual XslFlags VisitLiteralElement(XslNode node);
    protected virtual XslFlags VisitMessage(XslNode node);
    protected virtual XslFlags VisitNumber(Number node);
    protected virtual XslFlags VisitPI(XslNode node);
    protected virtual XslFlags VisitSort(Sort node);
    protected virtual XslFlags VisitText(Text node);
    protected virtual XslFlags VisitUseAttributeSet(XslNode node);
    protected virtual XslFlags VisitValueOf(XslNode node);
    protected virtual XslFlags VisitValueOfDoe(XslNode node);
    protected virtual XslFlags VisitParam(VarPar node);
    protected virtual XslFlags VisitVariable(VarPar node);
    protected virtual XslFlags VisitWithParam(VarPar node);
}
internal class System.Xml.Xsl.Xslt.XslAstRewriter : object {
    private static XslAstRewriter();
    public void Rewrite(Compiler compiler);
}
internal class System.Xml.Xsl.Xslt.XslNode : object {
    public XslNodeType NodeType;
    public ISourceLineInfo SourceLine;
    public NsDecl Namespaces;
    public QilName Name;
    public object Arg;
    public XslVersion XslVersion;
    public XslFlags Flags;
    public string Select { get; }
    public bool ForwardsCompatible { get; }
    public IList`1<XslNode> Content { get; }
    internal string TraceName { get; }
    public XslNode(XslNodeType nodeType, QilName name, object arg, XslVersion xslVer);
    public XslNode(XslNodeType nodeType);
    private static XslNode();
    public string get_Select();
    public bool get_ForwardsCompatible();
    public IList`1<XslNode> get_Content();
    public void SetContent(List`1<XslNode> content);
    public void AddContent(XslNode node);
    public void InsertContent(IEnumerable`1<XslNode> collection);
    internal string get_TraceName();
}
internal class System.Xml.Xsl.Xslt.XslNodeEx : XslNode {
    public ISourceLineInfo ElemNameLi;
    public ISourceLineInfo EndTagLi;
    public XslNodeEx(XslNodeType t, QilName name, object arg, ContextInfo ctxInfo, XslVersion xslVer);
    public XslNodeEx(XslNodeType t, QilName name, object arg, XslVersion xslVer);
}
internal enum System.Xml.Xsl.Xslt.XslNodeType : Enum {
    public int value__;
    public static XslNodeType Unknown;
    public static XslNodeType ApplyImports;
    public static XslNodeType ApplyTemplates;
    public static XslNodeType Attribute;
    public static XslNodeType AttributeSet;
    public static XslNodeType CallTemplate;
    public static XslNodeType Choose;
    public static XslNodeType Comment;
    public static XslNodeType Copy;
    public static XslNodeType CopyOf;
    public static XslNodeType Element;
    public static XslNodeType Error;
    public static XslNodeType ForEach;
    public static XslNodeType If;
    public static XslNodeType Key;
    public static XslNodeType List;
    public static XslNodeType LiteralAttribute;
    public static XslNodeType LiteralElement;
    public static XslNodeType Message;
    public static XslNodeType Nop;
    public static XslNodeType Number;
    public static XslNodeType Otherwise;
    public static XslNodeType Param;
    public static XslNodeType PI;
    public static XslNodeType Sort;
    public static XslNodeType Template;
    public static XslNodeType Text;
    public static XslNodeType UseAttributeSet;
    public static XslNodeType ValueOf;
    public static XslNodeType ValueOfDoe;
    public static XslNodeType Variable;
    public static XslNodeType WithParam;
}
internal class System.Xml.Xsl.Xslt.XsltInput : object {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    public string Value { get; }
    public string BaseUri { get; }
    public string QualifiedName { get; }
    public bool IsEmptyElement { get; }
    public string Uri { get; }
    public Location Start { get; }
    public Location End { get; }
    public DelayedQName ElementName { get; }
    public bool CanHaveApplyImports { get; public set; }
    public bool ForwardCompatibility { get; }
    public bool BackwardCompatibility { get; }
    public XslVersion XslVersion { get; }
    public XsltInput(XmlReader reader, Compiler compiler, KeywordsTable atoms);
    private static XsltInput();
    public XmlNodeType get_NodeType();
    public string get_LocalName();
    public string get_NamespaceUri();
    public string get_Prefix();
    public string get_Value();
    public string get_BaseUri();
    public string get_QualifiedName();
    public bool get_IsEmptyElement();
    public string get_Uri();
    public Location get_Start();
    public Location get_End();
    public bool FindStylesheetElement();
    public void Finish();
    public bool MoveToFirstChild();
    public bool MoveToNextSibling();
    public void SkipNode();
    public void MoveToElement();
    public bool MoveToLiteralAttribute(int attNum);
    public bool MoveToXsltAttribute(int attNum, string attName);
    public bool IsRequiredAttribute(int attNum);
    public bool AttributeExists(int attNum, string attName);
    public DelayedQName get_ElementName();
    public bool IsNs(string ns);
    public bool IsKeyword(string kwd);
    public bool IsXsltNamespace();
    public bool IsNullNamespace();
    public bool IsXsltAttribute(string kwd);
    public bool IsXsltKeyword(string kwd);
    public bool get_CanHaveApplyImports();
    public void set_CanHaveApplyImports(bool value);
    public bool IsExtensionNamespace(string uri);
    public bool get_ForwardCompatibility();
    public bool get_BackwardCompatibility();
    public XslVersion get_XslVersion();
    public ContextInfo GetAttributes();
    public ContextInfo GetAttributes(XsltAttribute[] attributes);
    public ContextInfo GetLiteralAttributes(bool asStylesheet);
    public void GetVersionAttribute();
    public ISourceLineInfo BuildLineInfo();
    public ISourceLineInfo BuildNameLineInfo();
    public ISourceLineInfo BuildReaderLineInfo();
    public string LookupXmlNamespace(string prefix);
    public sealed virtual void ReportError(string res, String[] args);
    public void ReportErrorFC(string res, String[] args);
    public sealed virtual void ReportWarning(string res, String[] args);
}
internal class System.Xml.Xsl.Xslt.XsltLoader : object {
    internal static QilName nullMode;
    public static int V1Opt;
    public static int V1Req;
    public static int V2Opt;
    public static int V2Req;
    private static XsltLoader();
    public void Load(Compiler compiler, object stylesheet, XmlResolver xmlResolver);
    internal static XslNode SetInfo(XslNode to, List`1<XslNode> content, ContextInfo info);
    public sealed virtual void ReportError(string res, String[] args);
    public sealed virtual void ReportWarning(string res, String[] args);
    public void CheckError(bool cond, string res, String[] args);
}
internal class System.Xml.Xsl.Xslt.XsltQilFactory : XPathQilFactory {
    public XsltQilFactory(QilFactory f, bool debug);
    [ConditionalAttribute("DEBUG")]
public void CheckXsltType(QilNode n);
    [ConditionalAttribute("DEBUG")]
public void CheckQName(QilNode n);
    public QilNode DefaultValueMarker();
    public QilNode IsDefaultValueMarker(QilNode n);
    public QilNode InvokeIsSameNodeSort(QilNode n1, QilNode n2);
    public QilNode InvokeSystemProperty(QilNode n);
    public QilNode InvokeElementAvailable(QilNode n);
    public QilNode InvokeCheckScriptNamespace(string nsUri);
    public QilNode InvokeFunctionAvailable(QilNode n);
    public QilNode InvokeBaseUri(QilNode n);
    public QilNode InvokeOnCurrentNodeChanged(QilNode n);
    public QilNode InvokeLangToLcid(QilNode n, bool fwdCompat);
    public QilNode InvokeNumberFormat(QilNode value, QilNode format, QilNode lang, QilNode letterValue, QilNode groupingSeparator, QilNode groupingSize);
    public QilNode InvokeRegisterDecimalFormat(DecimalFormatDecl format);
    public QilNode InvokeRegisterDecimalFormatter(QilNode formatPicture, DecimalFormatDecl format);
    public QilNode InvokeFormatNumberStatic(QilNode value, QilNode decimalFormatIndex);
    public QilNode InvokeFormatNumberDynamic(QilNode value, QilNode formatPicture, QilNode decimalFormatName, QilNode errorMessageName);
    public QilNode InvokeOuterXml(QilNode n);
    public QilNode InvokeMsFormatDateTime(QilNode datetime, QilNode format, QilNode lang, QilNode isDate);
    public QilNode InvokeMsStringCompare(QilNode x, QilNode y, QilNode lang, QilNode options);
    public QilNode InvokeMsUtc(QilNode n);
    public QilNode InvokeMsNumber(QilNode n);
    public QilNode InvokeMsLocalName(QilNode n);
    public QilNode InvokeMsNamespaceUri(QilNode n, QilNode currentNode);
    public QilNode InvokeEXslObjectType(QilNode n);
}
internal enum System.Xml.Xsl.Xslt.XslVersion : Enum {
    public int value__;
    public static XslVersion Version10;
    public static XslVersion ForwardsCompatible;
    public static XslVersion Current;
}
internal abstract class System.Xml.Xsl.Xslt.XslVisitor`1 : object {
    protected virtual T Visit(XslNode node);
    protected virtual T VisitApplyImports(XslNode node);
    protected virtual T VisitApplyTemplates(XslNode node);
    protected virtual T VisitAttribute(NodeCtor node);
    protected virtual T VisitAttributeSet(AttributeSet node);
    protected virtual T VisitCallTemplate(XslNode node);
    protected virtual T VisitChoose(XslNode node);
    protected virtual T VisitComment(XslNode node);
    protected virtual T VisitCopy(XslNode node);
    protected virtual T VisitCopyOf(XslNode node);
    protected virtual T VisitElement(NodeCtor node);
    protected virtual T VisitError(XslNode node);
    protected virtual T VisitForEach(XslNode node);
    protected virtual T VisitIf(XslNode node);
    protected virtual T VisitKey(Key node);
    protected virtual T VisitList(XslNode node);
    protected virtual T VisitLiteralAttribute(XslNode node);
    protected virtual T VisitLiteralElement(XslNode node);
    protected virtual T VisitMessage(XslNode node);
    protected virtual T VisitNop(XslNode node);
    protected virtual T VisitNumber(Number node);
    protected virtual T VisitOtherwise(XslNode node);
    protected virtual T VisitParam(VarPar node);
    protected virtual T VisitPI(XslNode node);
    protected virtual T VisitSort(Sort node);
    protected virtual T VisitTemplate(Template node);
    protected virtual T VisitText(Text node);
    protected virtual T VisitUseAttributeSet(XslNode node);
    protected virtual T VisitValueOf(XslNode node);
    protected virtual T VisitValueOfDoe(XslNode node);
    protected virtual T VisitVariable(VarPar node);
    protected virtual T VisitWithParam(VarPar node);
    protected virtual T VisitUnknown(XslNode node);
    protected virtual T VisitChildren(XslNode node);
}
internal abstract class System.Xml.Xsl.XsltOld.Action : object {
    internal static int Initialized;
    internal static int Finished;
    internal abstract virtual void Execute(Processor processor, ActionFrame frame);
    internal virtual void ReplaceNamespaceAlias(Compiler compiler);
    internal virtual DbgData GetDbgData(ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.ActionFrame : object {
    internal PrefixQName CalulatedName { get; internal set; }
    internal string StoredOutput { get; internal set; }
    internal int State { get; internal set; }
    internal int Counter { get; internal set; }
    internal ActionFrame Container { get; }
    internal XPathNavigator Node { get; }
    internal XPathNodeIterator NodeSet { get; }
    internal XPathNodeIterator NewNodeSet { get; }
    private XPathNavigator System.Xml.Xsl.XsltOld.Debugger.IStackFrame.Instruction { get; }
    private XPathNodeIterator System.Xml.Xsl.XsltOld.Debugger.IStackFrame.NodeSet { get; }
    internal PrefixQName get_CalulatedName();
    internal void set_CalulatedName(PrefixQName value);
    internal string get_StoredOutput();
    internal void set_StoredOutput(string value);
    internal int get_State();
    internal void set_State(int value);
    internal int get_Counter();
    internal void set_Counter(int value);
    internal ActionFrame get_Container();
    internal XPathNavigator get_Node();
    internal XPathNodeIterator get_NodeSet();
    internal XPathNodeIterator get_NewNodeSet();
    internal int IncrementCounter();
    internal void AllocateVariables(int count);
    internal object GetVariable(int index);
    internal void SetVariable(int index, object value);
    internal void SetParameter(XmlQualifiedName name, object value);
    internal void ResetParams();
    internal object GetParameter(XmlQualifiedName name);
    internal void InitNodeSet(XPathNodeIterator nodeSet);
    internal void InitNewNodeSet(XPathNodeIterator nodeSet);
    internal void SortNewNodeSet(Processor proc, ArrayList sortarray);
    internal void Finished();
    internal void Inherit(ActionFrame parent);
    internal void Init(Action action, XPathNodeIterator nodeSet);
    internal void Init(ActionFrame containerFrame, XPathNodeIterator nodeSet);
    internal void SetAction(Action action);
    internal void SetAction(Action action, int state);
    internal void Exit();
    internal bool Execute(Processor processor);
    internal bool NextNode(Processor proc);
    internal bool NewNextNode(Processor proc);
    private sealed virtual override XPathNavigator System.Xml.Xsl.XsltOld.Debugger.IStackFrame.get_Instruction();
    private sealed virtual override XPathNodeIterator System.Xml.Xsl.XsltOld.Debugger.IStackFrame.get_NodeSet();
    private sealed virtual override int System.Xml.Xsl.XsltOld.Debugger.IStackFrame.GetVariablesCount();
    private sealed virtual override XPathNavigator System.Xml.Xsl.XsltOld.Debugger.IStackFrame.GetVariable(int varIndex);
    private sealed virtual override object System.Xml.Xsl.XsltOld.Debugger.IStackFrame.GetVariableValue(int varIndex);
}
internal class System.Xml.Xsl.XsltOld.ApplyImportsAction : CompiledAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.ApplyTemplatesAction : ContainerAction {
    private static ApplyTemplatesAction();
    internal static ApplyTemplatesAction BuiltInRule();
    internal static ApplyTemplatesAction BuiltInRule(XmlQualifiedName mode);
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.AttributeAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.AttributeSetAction : ContainerAction {
    internal XmlQualifiedName name;
    internal XmlQualifiedName Name { get; }
    internal XmlQualifiedName get_Name();
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal void Merge(AttributeSetAction attributeAction);
}
internal class System.Xml.Xsl.XsltOld.Avt : object {
    public bool IsConstant { get; }
    public bool get_IsConstant();
    internal string Evaluate(Processor processor, ActionFrame frame);
    internal static Avt CompileAvt(Compiler compiler, string avtText);
}
internal class System.Xml.Xsl.XsltOld.AvtEvent : TextEvent {
    public AvtEvent(int key);
    public virtual bool Output(Processor processor, ActionFrame frame);
    public virtual string Evaluate(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.BeginEvent : Event {
    public BeginEvent(Compiler compiler);
    public virtual void ReplaceNamespaceAlias(Compiler compiler);
    public virtual bool Output(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.BuilderInfo : object {
    internal String[] TextInfo;
    internal int TextInfoCount;
    internal bool search;
    internal HtmlElementProps htmlProps;
    internal HtmlAttributeProps htmlAttrProps;
    internal string Name { get; }
    internal string LocalName { get; internal set; }
    internal string NamespaceURI { get; internal set; }
    internal string Prefix { get; internal set; }
    internal string Value { get; internal set; }
    internal XmlNodeType NodeType { get; internal set; }
    internal int Depth { get; internal set; }
    internal bool IsEmptyTag { get; internal set; }
    internal void Initialize(string prefix, string name, string nspace);
    internal void Initialize(BuilderInfo src);
    internal BuilderInfo Clone();
    internal string get_Name();
    internal string get_LocalName();
    internal void set_LocalName(string value);
    internal string get_NamespaceURI();
    internal void set_NamespaceURI(string value);
    internal string get_Prefix();
    internal void set_Prefix(string value);
    internal string get_Value();
    internal void set_Value(string value);
    internal void ValueAppend(string s, bool disableEscaping);
    internal XmlNodeType get_NodeType();
    internal void set_NodeType(XmlNodeType value);
    internal int get_Depth();
    internal void set_Depth(int value);
    internal bool get_IsEmptyTag();
    internal void set_IsEmptyTag(bool value);
}
internal class System.Xml.Xsl.XsltOld.BuiltInRuleTextAction : Action {
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CallTemplateAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.ChooseAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
}
internal class System.Xml.Xsl.XsltOld.CommentAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal abstract class System.Xml.Xsl.XsltOld.CompiledAction : Action {
    internal abstract virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    public void CompileAttributes(Compiler compiler);
    internal static string PrecalculateAvt(Avt& avt);
    public void CheckEmpty(Compiler compiler);
    public void CheckRequiredAttribute(Compiler compiler, object attrValue, string attrName);
    public void CheckRequiredAttribute(Compiler compiler, bool attr, string attrName);
}
internal class System.Xml.Xsl.XsltOld.Compiler : object {
    internal static int InvalidQueryKey;
    internal static double RootPriority;
    internal StringBuilder AvtStringBuilder;
    internal Stylesheet stylesheet;
    internal Stylesheet rootStylesheet;
    public bool AllowBuiltInMode;
    public static XmlQualifiedName BuiltInMode;
    internal KeywordsTable Atoms { get; }
    internal int Stylesheetid { get; internal set; }
    internal NavigatorInput Document { get; }
    internal NavigatorInput Input { get; }
    internal Stylesheet CompiledStylesheet { get; }
    internal RootAction RootAction { get; internal set; }
    internal List`1<TheQuery> QueryStore { get; }
    public IXsltDebugger Debugger { get; }
    internal bool ForwardCompatibility { get; internal set; }
    internal bool CanHaveApplyImports { get; internal set; }
    protected InputScopeManager ScopeManager { get; }
    internal string DefaultNamespace { get; }
    internal XmlQualifiedName CurrentMode { get; }
    private static Compiler();
    internal KeywordsTable get_Atoms();
    internal int get_Stylesheetid();
    internal void set_Stylesheetid(int value);
    internal NavigatorInput get_Document();
    internal NavigatorInput get_Input();
    internal bool Advance();
    internal bool Recurse();
    internal bool ToParent();
    internal Stylesheet get_CompiledStylesheet();
    internal RootAction get_RootAction();
    internal void set_RootAction(RootAction value);
    internal List`1<TheQuery> get_QueryStore();
    public virtual IXsltDebugger get_Debugger();
    internal string GetUnicRtfId();
    internal void Compile(NavigatorInput input, XmlResolver xmlResolver, Evidence evidence);
    internal bool get_ForwardCompatibility();
    internal void set_ForwardCompatibility(bool value);
    internal bool get_CanHaveApplyImports();
    internal void set_CanHaveApplyImports(bool value);
    internal void InsertExtensionNamespace(string value);
    internal void InsertExcludedNamespace(string value);
    internal void InsertExtensionNamespace();
    internal void InsertExcludedNamespace();
    internal bool IsExtensionNamespace(string nspace);
    internal bool IsExcludedNamespace(string nspace);
    internal void PushLiteralScope();
    internal void PushNamespaceScope();
    protected InputScopeManager get_ScopeManager();
    internal virtual void PopScope();
    internal InputScopeManager CloneScopeManager();
    internal int InsertVariable(VariableAction variable);
    internal void AddNamespaceAlias(string StylesheetURI, NamespaceInfo AliasInfo);
    internal bool IsNamespaceAlias(string StylesheetURI);
    internal NamespaceInfo FindNamespaceAlias(string StylesheetURI);
    internal string ResolveXmlNamespace(string prefix);
    internal string ResolveXPathNamespace(string prefix);
    internal string get_DefaultNamespace();
    internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey);
    internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo);
    internal bool GetYesNo(string value);
    internal string GetSingleAttribute(string attributeAtom);
    internal XmlQualifiedName CreateXPathQName(string qname);
    internal XmlQualifiedName CreateXmlQName(string qname);
    internal static XPathDocument LoadDocument(XmlTextReaderImpl reader);
    internal bool IsCircularReference(string href);
    internal Uri ResolveUri(string relativeUri);
    internal NavigatorInput ResolveDocument(Uri absoluteUri);
    internal void PushInputDocument(NavigatorInput newInput);
    internal void PopInputDocument();
    internal void PushStylesheet(Stylesheet stylesheet);
    internal Stylesheet PopStylesheet();
    internal void AddAttributeSet(AttributeSetAction attributeSet);
    internal void AddTemplate(TemplateAction template);
    internal void BeginTemplate(TemplateAction template);
    internal void EndTemplate();
    internal XmlQualifiedName get_CurrentMode();
    internal int AddQuery(string xpathQuery);
    internal int AddQuery(string xpathQuery, bool allowVar, bool allowKey, bool isPattern);
    internal int AddStringQuery(string xpathQuery);
    internal int AddBooleanQuery(string xpathQuery);
    internal void AddScript(string source, ScriptingLanguage lang, string ns, string fileName, int lineNumber);
    public string GetNsAlias(String& prefix);
    internal ArrayList CompileAvt(string avtText, Boolean& constant);
    internal ArrayList CompileAvt(string avtText);
    public virtual ApplyImportsAction CreateApplyImportsAction();
    public virtual ApplyTemplatesAction CreateApplyTemplatesAction();
    public virtual AttributeAction CreateAttributeAction();
    public virtual AttributeSetAction CreateAttributeSetAction();
    public virtual CallTemplateAction CreateCallTemplateAction();
    public virtual ChooseAction CreateChooseAction();
    public virtual CommentAction CreateCommentAction();
    public virtual CopyAction CreateCopyAction();
    public virtual CopyOfAction CreateCopyOfAction();
    public virtual ElementAction CreateElementAction();
    public virtual ForEachAction CreateForEachAction();
    public virtual IfAction CreateIfAction(ConditionType type);
    public virtual MessageAction CreateMessageAction();
    public virtual NewInstructionAction CreateNewInstructionAction();
    public virtual NumberAction CreateNumberAction();
    public virtual ProcessingInstructionAction CreateProcessingInstructionAction();
    public virtual void CreateRootAction();
    public virtual SortAction CreateSortAction();
    public virtual TemplateAction CreateTemplateAction();
    public virtual TemplateAction CreateSingleTemplateAction();
    public virtual TextAction CreateTextAction();
    public virtual UseAttributeSetsAction CreateUseAttributeSetsAction();
    public virtual ValueOfAction CreateValueOfAction();
    public virtual VariableAction CreateVariableAction(VariableType type);
    public virtual WithParamAction CreateWithParamAction();
    public virtual BeginEvent CreateBeginEvent();
    public virtual TextEvent CreateTextEvent();
    public XsltException UnexpectedKeyword();
}
internal class System.Xml.Xsl.XsltOld.ContainerAction : CompiledAction {
    internal ArrayList containedActions;
    internal CopyCodeAction lastCopyCodeAction;
    protected static int ProcessingChildren;
    internal virtual void Compile(Compiler compiler);
    internal void CompileStylesheetAttributes(Compiler compiler);
    internal void CompileSingleTemplate(Compiler compiler);
    protected void CompileDocument(Compiler compiler, bool inInclude);
    internal Stylesheet CompileImport(Compiler compiler, Uri uri, int id);
    internal void CompileNamespaceAlias(Compiler compiler);
    internal void CompileKey(Compiler compiler);
    protected void CompileDecimalFormat(Compiler compiler);
    internal bool CheckAttribute(bool valid, Compiler compiler);
    protected void CompileSpace(Compiler compiler, bool preserve);
    protected void CompileTopLevelElements(Compiler compiler);
    protected void CompileTemplate(Compiler compiler);
    protected void CompileOnceTemplate(Compiler compiler);
    internal void AddAction(Action action);
    protected void AddEvent(Event copyEvent);
    protected void AddEvents(ArrayList copyEvents);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    internal Action GetAction(int actionIndex);
    internal void CheckDuplicateParams(XmlQualifiedName name);
    internal virtual void ReplaceNamespaceAlias(Compiler compiler);
}
internal class System.Xml.Xsl.XsltOld.CopyAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CopyAttributesAction : Action {
    private static CopyAttributesAction();
    internal static CopyAttributesAction GetAction();
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CopyCodeAction : Action {
    internal void AddEvent(Event copyEvent);
    internal void AddEvents(ArrayList copyEvents);
    internal virtual void ReplaceNamespaceAlias(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    internal virtual DbgData GetDbgData(ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CopyNamespacesAction : Action {
    private static CopyNamespacesAction();
    internal static CopyNamespacesAction GetAction();
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CopyNodeSetAction : Action {
    private static CopyNodeSetAction();
    internal static CopyNodeSetAction GetAction();
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.CopyOfAction : CompiledAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.DbgCompiler : Compiler {
    public IXsltDebugger Debugger { get; }
    public VariableAction[] GlobalVariables { get; }
    public VariableAction[] LocalVariables { get; }
    public DbgCompiler(IXsltDebugger debugger);
    public virtual IXsltDebugger get_Debugger();
    public virtual VariableAction[] get_GlobalVariables();
    public virtual VariableAction[] get_LocalVariables();
    internal virtual void PopScope();
    public virtual ApplyImportsAction CreateApplyImportsAction();
    public virtual ApplyTemplatesAction CreateApplyTemplatesAction();
    public virtual AttributeAction CreateAttributeAction();
    public virtual AttributeSetAction CreateAttributeSetAction();
    public virtual CallTemplateAction CreateCallTemplateAction();
    public virtual ChooseAction CreateChooseAction();
    public virtual CommentAction CreateCommentAction();
    public virtual CopyAction CreateCopyAction();
    public virtual CopyOfAction CreateCopyOfAction();
    public virtual ElementAction CreateElementAction();
    public virtual ForEachAction CreateForEachAction();
    public virtual IfAction CreateIfAction(ConditionType type);
    public virtual MessageAction CreateMessageAction();
    public virtual NewInstructionAction CreateNewInstructionAction();
    public virtual NumberAction CreateNumberAction();
    public virtual ProcessingInstructionAction CreateProcessingInstructionAction();
    public virtual void CreateRootAction();
    public virtual SortAction CreateSortAction();
    public virtual TemplateAction CreateTemplateAction();
    public virtual TemplateAction CreateSingleTemplateAction();
    public virtual TextAction CreateTextAction();
    public virtual UseAttributeSetsAction CreateUseAttributeSetsAction();
    public virtual ValueOfAction CreateValueOfAction();
    public virtual VariableAction CreateVariableAction(VariableType type);
    public virtual WithParamAction CreateWithParamAction();
    public virtual BeginEvent CreateBeginEvent();
    public virtual TextEvent CreateTextEvent();
}
internal class System.Xml.Xsl.XsltOld.DbgData : object {
    public XPathNavigator StyleSheet { get; }
    public VariableAction[] Variables { get; }
    public static DbgData Empty { get; }
    public DbgData(Compiler compiler);
    private static DbgData();
    public XPathNavigator get_StyleSheet();
    public VariableAction[] get_Variables();
    internal void ReplaceVariables(VariableAction[] vars);
    public static DbgData get_Empty();
}
internal interface System.Xml.Xsl.XsltOld.Debugger.IStackFrame {
    public XPathNavigator Instruction { get; }
    public XPathNodeIterator NodeSet { get; }
    public abstract virtual XPathNavigator get_Instruction();
    public abstract virtual XPathNodeIterator get_NodeSet();
    public abstract virtual int GetVariablesCount();
    public abstract virtual XPathNavigator GetVariable(int varIndex);
    public abstract virtual object GetVariableValue(int varIndex);
}
internal interface System.Xml.Xsl.XsltOld.Debugger.IXsltDebugger {
    public abstract virtual string GetBuiltInTemplatesUri();
    public abstract virtual void OnInstructionCompile(XPathNavigator styleSheetNavigator);
    public abstract virtual void OnInstructionExecute(IXsltProcessor xsltProcessor);
}
internal interface System.Xml.Xsl.XsltOld.Debugger.IXsltProcessor {
    public int StackDepth { get; }
    public abstract virtual int get_StackDepth();
    public abstract virtual IStackFrame GetStackFrame(int depth);
}
internal class System.Xml.Xsl.XsltOld.DocumentKeyList : ValueType {
    private XPathNavigator rootNav;
    private Hashtable keyTable;
    public XPathNavigator RootNav { get; }
    public Hashtable KeyTable { get; }
    public DocumentKeyList(XPathNavigator rootNav, Hashtable keyTable);
    public XPathNavigator get_RootNav();
    public Hashtable get_KeyTable();
}
internal class System.Xml.Xsl.XsltOld.DocumentScope : object {
    protected NamespaceDecl scopes;
    internal NamespaceDecl Scopes { get; }
    internal NamespaceDecl get_Scopes();
    internal NamespaceDecl AddNamespace(string prefix, string uri, string prevDefaultNsUri);
    internal string ResolveAtom(string prefix);
    internal string ResolveNonAtom(string prefix);
}
internal class System.Xml.Xsl.XsltOld.ElementAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.EndEvent : Event {
    internal EndEvent(XPathNodeType nodeType);
    public virtual bool Output(Processor processor, ActionFrame frame);
}
internal abstract class System.Xml.Xsl.XsltOld.Event : object {
    internal DbgData DbgData { get; }
    public virtual void ReplaceNamespaceAlias(Compiler compiler);
    public abstract virtual bool Output(Processor processor, ActionFrame frame);
    internal void OnInstructionExecute(Processor processor);
    internal virtual DbgData get_DbgData();
}
internal class System.Xml.Xsl.XsltOld.ForEachAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    protected void CompileSortElements(Compiler compiler);
}
internal class System.Xml.Xsl.XsltOld.HtmlAttributeProps : object {
    public bool Abr { get; }
    public bool Uri { get; }
    public bool Name { get; }
    private static HtmlAttributeProps();
    public static HtmlAttributeProps Create(bool abr, bool uri, bool name);
    public bool get_Abr();
    public bool get_Uri();
    public bool get_Name();
    public static HtmlAttributeProps GetProps(string name);
}
internal class System.Xml.Xsl.XsltOld.HtmlElementProps : object {
    public bool Empty { get; }
    public bool AbrParent { get; }
    public bool UriParent { get; }
    public bool NoEntities { get; }
    public bool BlockWS { get; }
    public bool Head { get; }
    public bool NameParent { get; }
    private static HtmlElementProps();
    public static HtmlElementProps Create(bool empty, bool abrParent, bool uriParent, bool noEntities, bool blockWS, bool head, bool nameParent);
    public bool get_Empty();
    public bool get_AbrParent();
    public bool get_UriParent();
    public bool get_NoEntities();
    public bool get_BlockWS();
    public bool get_Head();
    public bool get_NameParent();
    public static HtmlElementProps GetProps(string name);
}
internal class System.Xml.Xsl.XsltOld.IfAction : ContainerAction {
    internal IfAction(ConditionType type);
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.InputScope : DocumentScope {
    internal InputScope Parent { get; }
    internal Hashtable Variables { get; }
    internal bool ForwardCompatibility { get; internal set; }
    internal bool CanHaveApplyImports { get; internal set; }
    internal InputScope(InputScope parent);
    internal InputScope get_Parent();
    internal Hashtable get_Variables();
    internal bool get_ForwardCompatibility();
    internal void set_ForwardCompatibility(bool value);
    internal bool get_CanHaveApplyImports();
    internal void set_CanHaveApplyImports(bool value);
    internal void Init(InputScope parent);
    internal void InsertExtensionNamespace(string nspace);
    internal bool IsExtensionNamespace(string nspace);
    internal void InsertExcludedNamespace(string nspace);
    internal bool IsExcludedNamespace(string nspace);
    internal void InsertVariable(VariableAction variable);
    internal int GetVeriablesCount();
    public VariableAction ResolveVariable(XmlQualifiedName qname);
    public VariableAction ResolveGlobalVariable(XmlQualifiedName qname);
}
internal class System.Xml.Xsl.XsltOld.InputScopeManager : object {
    internal InputScope CurrentScope { get; }
    internal InputScope VariableScope { get; }
    public XPathNavigator Navigator { get; }
    public string DefaultNamespace { get; }
    public InputScopeManager(XPathNavigator navigator, InputScope rootScope);
    internal InputScope get_CurrentScope();
    internal InputScope get_VariableScope();
    internal InputScopeManager Clone();
    public XPathNavigator get_Navigator();
    internal InputScope PushScope();
    internal void PopScope();
    internal void PushNamespace(string prefix, string nspace);
    public string get_DefaultNamespace();
    public string ResolveXmlNamespace(string prefix);
    public string ResolveXPathNamespace(string prefix);
    internal void InsertExtensionNamespaces(String[] nsList);
    internal bool IsExtensionNamespace(string nspace);
    internal void InsertExcludedNamespaces(String[] nsList);
    internal bool IsExcludedNamespace(string nspace);
}
internal class System.Xml.Xsl.XsltOld.Key : object {
    public XmlQualifiedName Name { get; }
    public int MatchKey { get; }
    public int UseKey { get; }
    public Key(XmlQualifiedName name, int matchkey, int usekey);
    public XmlQualifiedName get_Name();
    public int get_MatchKey();
    public int get_UseKey();
    public void AddKey(XPathNavigator root, Hashtable table);
    public Hashtable GetKeys(XPathNavigator root);
    public Key Clone();
}
internal class System.Xml.Xsl.XsltOld.MessageAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.NamespaceDecl : object {
    internal string Prefix { get; }
    internal string Uri { get; }
    internal string PrevDefaultNsUri { get; }
    internal NamespaceDecl Next { get; }
    internal NamespaceDecl(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next);
    internal string get_Prefix();
    internal string get_Uri();
    internal string get_PrevDefaultNsUri();
    internal NamespaceDecl get_Next();
    internal void Init(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next);
}
internal class System.Xml.Xsl.XsltOld.NamespaceEvent : Event {
    public NamespaceEvent(NavigatorInput input);
    public virtual void ReplaceNamespaceAlias(Compiler compiler);
    public virtual bool Output(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.NamespaceInfo : object {
    internal string prefix;
    internal string nameSpace;
    internal int stylesheetId;
    internal NamespaceInfo(string prefix, string nameSpace, int stylesheetId);
}
internal class System.Xml.Xsl.XsltOld.NavigatorInput : object {
    internal NavigatorInput Next { get; internal set; }
    internal string Href { get; }
    internal KeywordsTable Atoms { get; }
    internal XPathNavigator Navigator { get; }
    internal InputScopeManager InputScopeManager { get; }
    internal int LineNumber { get; }
    internal int LinePosition { get; }
    internal XPathNodeType NodeType { get; }
    internal string Name { get; }
    internal string LocalName { get; }
    internal string NamespaceURI { get; }
    internal string Prefix { get; }
    internal string Value { get; }
    internal bool IsEmptyTag { get; }
    internal string BaseURI { get; }
    internal NavigatorInput(XPathNavigator navigator, string baseUri, InputScope rootScope);
    internal NavigatorInput(XPathNavigator navigator);
    internal NavigatorInput get_Next();
    internal void set_Next(NavigatorInput value);
    internal string get_Href();
    internal KeywordsTable get_Atoms();
    internal XPathNavigator get_Navigator();
    internal InputScopeManager get_InputScopeManager();
    internal bool Advance();
    internal bool Recurse();
    internal bool ToParent();
    internal void Close();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal XPathNodeType get_NodeType();
    internal string get_Name();
    internal string get_LocalName();
    internal string get_NamespaceURI();
    internal string get_Prefix();
    internal string get_Value();
    internal bool get_IsEmptyTag();
    internal string get_BaseURI();
    internal bool MoveToFirstAttribute();
    internal bool MoveToNextAttribute();
    internal bool MoveToFirstNamespace();
    internal bool MoveToNextNamespace();
    [ConditionalAttribute("DEBUG")]
internal void AssertInput();
}
internal class System.Xml.Xsl.XsltOld.NavigatorOutput : object {
    internal XPathNavigator Navigator { get; }
    internal NavigatorOutput(string baseUri);
    internal XPathNavigator get_Navigator();
    public sealed virtual OutputResult RecordDone(RecordBuilder record);
    public sealed virtual void TheEnd();
}
internal class System.Xml.Xsl.XsltOld.NewInstructionAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal void CompileSelectiveTemplate(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.NumberAction : ContainerAction {
    private static NumberAction();
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Compile(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.OutKeywords : object {
    internal string Empty { get; }
    internal string Lang { get; }
    internal string Space { get; }
    internal string Xmlns { get; }
    internal string Xml { get; }
    internal string XmlNamespace { get; }
    internal string XmlnsNamespace { get; }
    internal OutKeywords(XmlNameTable nameTable);
    internal string get_Empty();
    internal string get_Lang();
    internal string get_Space();
    internal string get_Xmlns();
    internal string get_Xml();
    internal string get_XmlNamespace();
    internal string get_XmlnsNamespace();
}
internal class System.Xml.Xsl.XsltOld.OutputScope : DocumentScope {
    internal string Name { get; }
    internal string Namespace { get; }
    internal string Prefix { get; internal set; }
    internal XmlSpace Space { get; internal set; }
    internal string Lang { get; internal set; }
    internal bool Mixed { get; internal set; }
    internal bool ToCData { get; internal set; }
    internal HtmlElementProps HtmlElementProps { get; internal set; }
    internal string get_Name();
    internal string get_Namespace();
    internal string get_Prefix();
    internal void set_Prefix(string value);
    internal XmlSpace get_Space();
    internal void set_Space(XmlSpace value);
    internal string get_Lang();
    internal void set_Lang(string value);
    internal bool get_Mixed();
    internal void set_Mixed(bool value);
    internal bool get_ToCData();
    internal void set_ToCData(bool value);
    internal HtmlElementProps get_HtmlElementProps();
    internal void set_HtmlElementProps(HtmlElementProps value);
    internal void Init(string name, string nspace, string prefix, XmlSpace space, string lang, bool mixed);
    internal bool FindPrefix(string urn, String& prefix);
}
internal class System.Xml.Xsl.XsltOld.OutputScopeManager : object {
    internal string DefaultNamespace { get; }
    internal OutputScope CurrentElementScope { get; }
    internal XmlSpace XmlSpace { get; }
    internal string XmlLang { get; }
    internal OutputScopeManager(XmlNameTable nameTable, OutKeywords atoms);
    internal string get_DefaultNamespace();
    internal OutputScope get_CurrentElementScope();
    internal XmlSpace get_XmlSpace();
    internal string get_XmlLang();
    internal void PushNamespace(string prefix, string nspace);
    internal void PushScope(string name, string nspace, string prefix);
    internal void PopScope();
    internal string ResolveNamespace(string prefix);
    internal string ResolveNamespace(string prefix, Boolean& thisScope);
    internal bool FindPrefix(string nspace, String& prefix);
    internal string GeneratePrefix(string format);
}
internal class System.Xml.Xsl.XsltOld.PrefixQName : object {
    public string Prefix;
    public string Name;
    public string Namespace;
    internal void ClearPrefix();
    internal void SetQName(string qname);
    public static void ParseQualifiedName(string qname, String& prefix, String& local);
    public static bool ValidatePrefix(string prefix);
}
internal class System.Xml.Xsl.XsltOld.ProcessingInstructionAction : ContainerAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    internal static bool IsProcessingInstructionName(string name);
}
internal class System.Xml.Xsl.XsltOld.Processor : object {
    public PermissionSet permissions;
    internal XPathNavigator Current { get; }
    internal ExecResult ExecutionResult { get; internal set; }
    internal Stylesheet Stylesheet { get; }
    internal XmlResolver Resolver { get; }
    internal ArrayList SortArray { get; }
    internal Key[] KeyList { get; }
    internal RootAction RootAction { get; }
    internal XPathNavigator Document { get; }
    internal ArrayList NumberList { get; }
    internal IXsltDebugger Debugger { get; }
    internal HWStack ActionStack { get; }
    internal RecordBuilder Builder { get; }
    internal XsltOutput Output { get; }
    internal XmlNameTable NameTable { get; }
    internal bool CanContinue { get; }
    internal bool ExecutionDone { get; }
    private int System.Xml.Xsl.XsltOld.Debugger.IXsltProcessor.StackDepth { get; }
    public Processor(XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, Stylesheet stylesheet, List`1<TheQuery> queryStore, RootAction rootAction, IXsltDebugger debugger);
    internal XPathNavigator get_Current();
    internal ExecResult get_ExecutionResult();
    internal void set_ExecutionResult(ExecResult value);
    internal Stylesheet get_Stylesheet();
    internal XmlResolver get_Resolver();
    internal ArrayList get_SortArray();
    internal Key[] get_KeyList();
    internal XPathNavigator GetNavigator(Uri ruri);
    internal void AddSort(Sort sortinfo);
    internal void InitSortArray();
    internal object GetGlobalParameter(XmlQualifiedName qname);
    internal object GetExtensionObject(string nsUri);
    internal object GetScriptObject(string nsUri);
    internal RootAction get_RootAction();
    internal XPathNavigator get_Document();
    internal StringBuilder GetSharedStringBuilder();
    internal void ReleaseSharedStringBuilder();
    internal ArrayList get_NumberList();
    internal IXsltDebugger get_Debugger();
    internal HWStack get_ActionStack();
    internal RecordBuilder get_Builder();
    internal XsltOutput get_Output();
    public ReaderOutput StartReader();
    public void Execute(Stream stream);
    public void Execute(TextWriter writer);
    public void Execute(XmlWriter writer);
    internal void Execute();
    internal ActionFrame PushNewFrame();
    internal void PushActionFrame(Action action, XPathNodeIterator nodeSet);
    internal void PushActionFrame(ActionFrame container);
    internal void PushActionFrame(ActionFrame container, XPathNodeIterator nodeSet);
    internal void PushTemplateLookup(XPathNodeIterator nodeSet, XmlQualifiedName mode, Stylesheet importsOf);
    internal string GetQueryExpression(int key);
    internal Query GetCompiledQuery(int key);
    internal Query GetValueQuery(int key);
    internal Query GetValueQuery(int key, XsltCompileContext context);
    internal string ValueOf(ActionFrame context, int key);
    internal string ValueOf(XPathNavigator n);
    internal XPathNodeIterator StartQuery(XPathNodeIterator context, int key);
    internal object Evaluate(ActionFrame context, int key);
    internal object RunQuery(ActionFrame context, int key);
    internal string EvaluateString(ActionFrame context, int key);
    internal bool EvaluateBoolean(ActionFrame context, int key);
    internal bool Matches(XPathNavigator context, int key);
    internal XmlNameTable get_NameTable();
    internal bool get_CanContinue();
    internal bool get_ExecutionDone();
    internal void ResetOutput();
    internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty);
    internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search);
    internal bool TextEvent(string text);
    internal bool TextEvent(string text, bool disableOutputEscaping);
    internal bool EndEvent(XPathNodeType nodeType);
    internal bool CopyBeginEvent(XPathNavigator node, bool emptyflag);
    internal bool CopyTextEvent(XPathNavigator node);
    internal bool CopyEndEvent(XPathNavigator node);
    internal static bool IsRoot(XPathNavigator navigator);
    internal void PushOutput(RecordOutput output);
    internal RecordOutput PopOutput();
    internal bool SetDefaultOutput(OutputMethod method);
    internal object GetVariableValue(VariableAction variable);
    internal void SetParameter(XmlQualifiedName name, object value);
    internal void ResetParams();
    internal object GetParameter(XmlQualifiedName name);
    internal void PushDebuggerStack();
    internal void PopDebuggerStack();
    internal void OnInstructionExecute();
    internal XmlQualifiedName GetPrevioseMode();
    internal void SetCurrentMode(XmlQualifiedName mode);
    private sealed virtual override int System.Xml.Xsl.XsltOld.Debugger.IXsltProcessor.get_StackDepth();
    private sealed virtual override IStackFrame System.Xml.Xsl.XsltOld.Debugger.IXsltProcessor.GetStackFrame(int depth);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.Xsl.XsltOld.ReaderOutput : XmlReader {
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public char QuoteChar { get; }
    public bool IsDefault { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public XmlNameTable NameTable { get; }
    internal ReaderOutput(Processor processor);
    private static ReaderOutput();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual char get_QuoteChar();
    public virtual bool get_IsDefault();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual int get_AttributeCount();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual bool Read();
    public virtual bool get_EOF();
    public virtual void Close();
    public virtual ReadState get_ReadState();
    public virtual string ReadString();
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual XmlNameTable get_NameTable();
    public virtual string LookupNamespace(string prefix);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    public sealed virtual OutputResult RecordDone(RecordBuilder record);
    public sealed virtual void TheEnd();
}
internal class System.Xml.Xsl.XsltOld.RecordBuilder : object {
    internal int OutputState { get; internal set; }
    internal RecordBuilder Next { get; internal set; }
    internal RecordOutput Output { get; }
    internal BuilderInfo MainNode { get; }
    internal ArrayList AttributeList { get; }
    internal int AttributeCount { get; }
    internal OutputScopeManager Manager { get; }
    internal RecordBuilder(RecordOutput output, XmlNameTable nameTable);
    internal int get_OutputState();
    internal void set_OutputState(int value);
    internal RecordBuilder get_Next();
    internal void set_Next(RecordBuilder value);
    internal RecordOutput get_Output();
    internal BuilderInfo get_MainNode();
    internal ArrayList get_AttributeList();
    internal int get_AttributeCount();
    internal OutputScopeManager get_Manager();
    internal OutputResult BeginEvent(int state, XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search);
    internal OutputResult TextEvent(int state, string text, bool disableOutputEscaping);
    internal OutputResult EndEvent(int state, XPathNodeType nodeType);
    internal void Reset();
    internal void TheEnd();
    internal string GetPrefixForNamespace(string nspace);
}
internal interface System.Xml.Xsl.XsltOld.RecordOutput {
    public abstract virtual OutputResult RecordDone(RecordBuilder record);
    public abstract virtual void TheEnd();
}
internal class System.Xml.Xsl.XsltOld.RootAction : TemplateBaseAction {
    public Stylesheet builtInSheet;
    public PermissionSet permissions;
    internal XsltOutput Output { get; }
    internal List`1<Key> KeyList { get; }
    internal XsltOutput get_Output();
    internal virtual void Compile(Compiler compiler);
    internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey);
    internal AttributeSetAction GetAttributeSet(XmlQualifiedName name);
    public void PorcessAttributeSets(Stylesheet rootStylesheet);
    internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo);
    internal DecimalFormat GetDecimalFormat(XmlQualifiedName name);
    internal List`1<Key> get_KeyList();
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal enum System.Xml.Xsl.XsltOld.ScriptingLanguage : Enum {
    public int value__;
    public static ScriptingLanguage JScript;
    public static ScriptingLanguage VisualBasic;
    public static ScriptingLanguage CSharp;
}
internal abstract class System.Xml.Xsl.XsltOld.SequentialOutput : object {
    protected Encoding encoding;
    internal SequentialOutput(Processor processor);
    private static SequentialOutput();
    public void OmitXmlDecl();
    public sealed virtual OutputResult RecordDone(RecordBuilder record);
    public sealed virtual void TheEnd();
    internal abstract virtual void Write(char outputChar);
    internal abstract virtual void Write(string outputText);
    internal abstract virtual void Close();
}
internal class System.Xml.Xsl.XsltOld.Sort : object {
    internal int select;
    internal string lang;
    internal XmlDataType dataType;
    internal XmlSortOrder order;
    internal XmlCaseOrder caseOrder;
    public Sort(int sortkey, string xmllang, XmlDataType datatype, XmlSortOrder xmlorder, XmlCaseOrder xmlcaseorder);
}
internal class System.Xml.Xsl.XsltOld.SortAction : CompiledAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.StateMachine : object {
    internal static int Error;
    internal static int DepthMask;
    internal static int DepthUp;
    internal static int DepthDown;
    internal static int BeginChild;
    internal static int HadChild;
    internal static int EmptyTag;
    internal static int BeginRecord;
    internal static int EndRecord;
    internal static int PushScope;
    internal static int PopScope;
    internal int State { get; internal set; }
    private static StateMachine();
    internal int get_State();
    internal void set_State(int value);
    internal void Reset();
    internal static int StateOnly(int state);
    internal int BeginOutlook(XPathNodeType nodeType);
    internal int Begin(XPathNodeType nodeType);
    internal int EndOutlook(XPathNodeType nodeType);
    internal int End(XPathNodeType nodeType);
}
internal class System.Xml.Xsl.XsltOld.StringOutput : SequentialOutput {
    internal string Result { get; }
    internal StringOutput(Processor processor);
    internal string get_Result();
    internal virtual void Write(char outputChar);
    internal virtual void Write(string outputText);
    internal virtual void Close();
}
internal class System.Xml.Xsl.XsltOld.Stylesheet : object {
    internal bool Whitespace { get; }
    internal ArrayList Imports { get; }
    internal Hashtable AttributeSetTable { get; }
    internal Hashtable ScriptObjectTypes { get; }
    internal bool get_Whitespace();
    internal ArrayList get_Imports();
    internal Hashtable get_AttributeSetTable();
    internal void AddSpace(Compiler compiler, string query, double Priority, bool PreserveSpace);
    internal void SortWhiteSpace();
    internal bool PreserveWhiteSpace(Processor proc, XPathNavigator node);
    internal void AddAttributeSet(AttributeSetAction attributeSet);
    internal void AddTemplate(TemplateAction template);
    internal void ProcessTemplates();
    internal void ReplaceNamespaceAlias(Compiler compiler);
    internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator, XmlQualifiedName mode);
    internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator, XmlQualifiedName mode);
    internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator);
    internal TemplateAction FindTemplate(XmlQualifiedName name);
    internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator);
    internal Hashtable get_ScriptObjectTypes();
}
internal class System.Xml.Xsl.XsltOld.TemplateAction : TemplateBaseAction {
    internal int MatchKey { get; }
    internal XmlQualifiedName Name { get; }
    internal double Priority { get; }
    internal XmlQualifiedName Mode { get; }
    internal int TemplateId { get; internal set; }
    internal int get_MatchKey();
    internal XmlQualifiedName get_Name();
    internal double get_Priority();
    internal XmlQualifiedName get_Mode();
    internal int get_TemplateId();
    internal void set_TemplateId(int value);
    internal virtual void Compile(Compiler compiler);
    internal virtual void CompileSingle(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    protected void CompileParameters(Compiler compiler);
    internal virtual void ReplaceNamespaceAlias(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal abstract class System.Xml.Xsl.XsltOld.TemplateBaseAction : ContainerAction {
    protected int variableCount;
    public int AllocateVariableSlot();
    public void ReleaseVariableSlots(int n);
}
internal class System.Xml.Xsl.XsltOld.TemplateLookupAction : Action {
    protected XmlQualifiedName mode;
    protected Stylesheet importsOf;
    internal void Initialize(XmlQualifiedName mode, Stylesheet importsOf);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    internal Action BuiltInTemplate(XPathNavigator node);
}
internal class System.Xml.Xsl.XsltOld.TemplateLookupActionDbg : TemplateLookupAction {
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.TemplateManager : object {
    internal ArrayList templates;
    internal XmlQualifiedName Mode { get; }
    internal TemplateManager(Stylesheet stylesheet, XmlQualifiedName mode);
    private static TemplateManager();
    internal XmlQualifiedName get_Mode();
    internal void AddTemplate(TemplateAction template);
    internal void ProcessTemplates();
    internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator);
}
internal class System.Xml.Xsl.XsltOld.TextAction : CompiledAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.TextEvent : Event {
    public TextEvent(string text);
    public TextEvent(Compiler compiler);
    public virtual bool Output(Processor processor, ActionFrame frame);
    public virtual string Evaluate(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.TextOnlyOutput : object {
    internal XsltOutput Output { get; }
    public TextWriter Writer { get; }
    internal TextOnlyOutput(Processor processor, Stream stream);
    internal TextOnlyOutput(Processor processor, TextWriter writer);
    internal XsltOutput get_Output();
    public TextWriter get_Writer();
    public sealed virtual OutputResult RecordDone(RecordBuilder record);
    public sealed virtual void TheEnd();
}
internal class System.Xml.Xsl.XsltOld.TextOutput : SequentialOutput {
    internal TextOutput(Processor processor, Stream stream);
    internal TextOutput(Processor processor, TextWriter writer);
    internal virtual void Write(char outputChar);
    internal virtual void Write(string outputText);
    internal virtual void Close();
}
internal class System.Xml.Xsl.XsltOld.TheQuery : object {
    internal InputScopeManager _ScopeManager;
    internal CompiledXpathExpr CompiledQuery { get; }
    internal TheQuery(CompiledXpathExpr compiledQuery, InputScopeManager manager);
    internal CompiledXpathExpr get_CompiledQuery();
}
internal class System.Xml.Xsl.XsltOld.UseAttributeSetsAction : CompiledAction {
    internal XmlQualifiedName[] UsedSets { get; }
    internal XmlQualifiedName[] get_UsedSets();
    internal virtual void Compile(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.ValueOfAction : CompiledAction {
    private static ValueOfAction();
    internal static Action BuiltInRule();
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.VariableAction : ContainerAction {
    public static object BeingComputedMark;
    protected XmlQualifiedName name;
    protected string nameStr;
    protected string baseUri;
    protected int selectKey;
    protected int stylesheetid;
    protected VariableType varType;
    internal int Stylesheetid { get; }
    internal XmlQualifiedName Name { get; }
    internal string NameStr { get; }
    internal VariableType VarType { get; }
    internal int VarKey { get; }
    internal bool IsGlobal { get; }
    private XPathResultType System.Xml.Xsl.IXsltContextVariable.VariableType { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsLocal { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsParam { get; }
    internal VariableAction(VariableType type);
    private static VariableAction();
    internal int get_Stylesheetid();
    internal XmlQualifiedName get_Name();
    internal string get_NameStr();
    internal VariableType get_VarType();
    internal int get_VarKey();
    internal bool get_IsGlobal();
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
    private sealed virtual override XPathResultType System.Xml.Xsl.IXsltContextVariable.get_VariableType();
    private sealed virtual override object System.Xml.Xsl.IXsltContextVariable.Evaluate(XsltContext xsltContext);
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsLocal();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsParam();
}
internal enum System.Xml.Xsl.XsltOld.VariableType : Enum {
    public int value__;
    public static VariableType GlobalVariable;
    public static VariableType GlobalParameter;
    public static VariableType LocalVariable;
    public static VariableType LocalParameter;
    public static VariableType WithParameter;
}
internal class System.Xml.Xsl.XsltOld.WithParamAction : VariableAction {
    internal virtual void Compile(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XsltOld.WriterOutput : object {
    internal WriterOutput(Processor processor, XmlWriter writer);
    public sealed virtual OutputResult RecordDone(RecordBuilder record);
    public sealed virtual void TheEnd();
}
internal class System.Xml.Xsl.XsltOld.XsltCompileContext : XsltContext {
    public string DefaultNamespace { get; }
    public bool Whitespace { get; }
    internal XsltCompileContext(InputScopeManager manager, Processor processor);
    private static XsltCompileContext();
    internal void Recycle();
    internal void Reinitialize(InputScopeManager manager, Processor processor);
    public virtual int CompareDocument(string baseUri, string nextbaseUri);
    public virtual string get_DefaultNamespace();
    public virtual string LookupNamespace(string prefix);
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
    internal object EvaluateVariable(VariableAction variable);
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    public static XPathResultType GetXPathType(Type type);
}
internal class System.Xml.Xsl.XsltOld.XsltOutput : CompiledAction {
    internal OutputMethod Method { get; }
    internal bool OmitXmlDeclaration { get; }
    internal bool HasStandalone { get; }
    internal bool Standalone { get; }
    internal string DoctypePublic { get; }
    internal string DoctypeSystem { get; }
    internal Hashtable CDataElements { get; }
    internal bool Indent { get; }
    internal Encoding Encoding { get; }
    internal string MediaType { get; }
    internal OutputMethod get_Method();
    internal bool get_OmitXmlDeclaration();
    internal bool get_HasStandalone();
    internal bool get_Standalone();
    internal string get_DoctypePublic();
    internal string get_DoctypeSystem();
    internal Hashtable get_CDataElements();
    internal bool get_Indent();
    internal Encoding get_Encoding();
    internal string get_MediaType();
    internal XsltOutput CreateDerivedOutput(OutputMethod method);
    internal virtual void Compile(Compiler compiler);
    internal virtual bool CompileAttribute(Compiler compiler);
    internal virtual void Execute(Processor processor, ActionFrame frame);
}
internal class System.Xml.Xsl.XslTransformException : XsltException {
    protected XslTransformException(SerializationInfo info, StreamingContext context);
    public XslTransformException(Exception inner, string res, String[] args);
    public XslTransformException(string message);
    internal XslTransformException(string res, String[] args);
    internal static string CreateMessage(string res, String[] args);
    internal virtual string FormatDetailedMessage();
    public virtual string ToString();
}
