[FriendAccessAllowedAttribute]
internal static class MS.Internal.AssemblyHelper : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static AssemblyHelper();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[FriendAccessAllowedAttribute]
internal static bool IsLoaded(UncommonAssembly assemblyEnum);
    internal static SystemDrawingExtensionMethods ExtensionsForSystemDrawing(bool force);
    internal static SystemXmlExtensionMethods ExtensionsForSystemXml(bool force);
    internal static SystemXmlLinqExtensionMethods ExtensionsForSystemXmlLinq(bool force);
    internal static SystemDataExtensionMethods ExtensionsForSystemData(bool force);
    internal static SystemCoreExtensionMethods ExtensionsForSystemCore(bool force);
}
internal class MS.Internal.AvTrace : object {
    public bool IsEnabled { get; }
    public bool SuppressGeneratedParameters { get; public set; }
    public bool IsEnabledOverride { get; }
    public bool EnabledByDebugger { get; public set; }
    public AvTrace(GetTraceSourceDelegate getTraceSourceDelegate, ClearTraceSourceDelegate clearTraceSourceDelegate);
    private static AvTrace();
    public void Refresh();
    public bool get_IsEnabled();
    public bool get_SuppressGeneratedParameters();
    public void set_SuppressGeneratedParameters(bool value);
    public bool get_IsEnabledOverride();
    public bool get_EnabledByDebugger();
    public void set_EnabledByDebugger(bool value);
    public static void OnRefresh();
    [CompilerGeneratedAttribute]
public void add_TraceExtraMessages(AvTraceEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TraceExtraMessages(AvTraceEventHandler value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[FriendAccessAllowedAttribute]
internal static bool IsWpfTracingEnabledInRegistry();
    internal static bool IsDebuggerAttached();
    public void Trace(TraceEventType type, int eventId, string message, String[] labels, Object[] parameters);
    public void TraceStartStop(int eventID, string message, String[] labels, Object[] parameters);
    public static string ToStringHelper(object value);
    public static string AntiFormat(string s);
    public static string TypeName(object value);
    public static int GetHashCodeHelper(object value);
    public static Type GetTypeHelper(object value);
}
internal class MS.Internal.AvTraceBuilder : object {
    public AvTraceBuilder(string message);
    public void Append(string message);
    public void AppendFormat(string message, Object[] args);
    public void AppendFormat(string message, object arg1);
    public void AppendFormat(string message, object arg1, object arg2);
    public void AppendFormat(string message, string arg1);
    public void AppendFormat(string message, string arg1, string arg2);
    public virtual string ToString();
}
internal class MS.Internal.AvTraceDetails : object {
    public int Id { get; }
    public string Message { get; }
    public String[] Labels { get; }
    public AvTraceDetails(int id, String[] labels);
    public int get_Id();
    public virtual string get_Message();
    public String[] get_Labels();
}
internal class MS.Internal.AvTraceEventHandler : MulticastDelegate {
    public AvTraceEventHandler(object object, IntPtr method);
    public virtual void Invoke(AvTraceBuilder traceBuilder, Object[] parameters, int start);
    public virtual IAsyncResult BeginInvoke(AvTraceBuilder traceBuilder, Object[] parameters, int start, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.AvTraceFormat : AvTraceDetails {
    public string Message { get; }
    public AvTraceFormat(AvTraceDetails details, Object[] args);
    public virtual string get_Message();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.BaseHashHelper : object {
    private static BaseHashHelper();
    [FriendAccessAllowedAttribute]
internal static void RegisterTypes(Assembly assembly, Type[] types);
    [FriendAccessAllowedAttribute]
internal static bool HasReliableHashCode(object item);
}
internal class MS.Internal.ClearTraceSourceDelegate : MulticastDelegate {
    public ClearTraceSourceDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.ComponentModel.APCustomTypeDescriptor : ValueType {
    private ICustomTypeDescriptor _parent;
    private DependencyObject _instance;
    internal APCustomTypeDescriptor(ICustomTypeDescriptor parent, object instance);
    private static APCustomTypeDescriptor();
    public sealed virtual PropertyDescriptorCollection GetProperties();
    public sealed virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public sealed virtual AttributeCollection GetAttributes();
    public sealed virtual string GetClassName();
    public sealed virtual string GetComponentName();
    public sealed virtual TypeConverter GetConverter();
    public sealed virtual EventDescriptor GetDefaultEvent();
    public sealed virtual PropertyDescriptor GetDefaultProperty();
    public sealed virtual object GetEditor(Type editorBaseType);
    public sealed virtual EventDescriptorCollection GetEvents();
    public sealed virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public sealed virtual object GetPropertyOwner(PropertyDescriptor property);
}
internal class MS.Internal.ComponentModel.AttachedPropertyMethodSelector : Binder {
    public virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public virtual object ChangeType(object value, Type type, CultureInfo culture);
    public virtual void ReorderArgumentArray(Object[]& args, object state);
    public virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
internal class MS.Internal.ComponentModel.AttachInfo : object {
    internal AttachInfo(DependencyProperty dp);
    internal bool CanAttach(DependencyObject instance);
}
internal class MS.Internal.ComponentModel.DependencyObjectPropertyDescriptor : PropertyDescriptor {
    public AttributeCollection Attributes { get; }
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal bool IsAttached { get; }
    internal PropertyMetadata Metadata { get; }
    internal static Type AttachedPropertyBrowsableAttributeType { get; }
    internal DependencyObjectPropertyDescriptor(PropertyDescriptor property, DependencyProperty dp, Type objectType);
    internal DependencyObjectPropertyDescriptor(DependencyProperty dp, Type ownerType);
    private static DependencyObjectPropertyDescriptor();
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual bool get_SupportsChangeEvents();
    internal DependencyProperty get_DependencyProperty();
    internal bool get_IsAttached();
    internal PropertyMetadata get_Metadata();
    internal static void ClearCache();
    internal static MethodInfo GetAttachedPropertyMethod(DependencyProperty dp);
    protected virtual AttributeCollection CreateAttributeCollection();
    internal static Type get_AttachedPropertyBrowsableAttributeType();
}
internal class MS.Internal.ComponentModel.DependencyObjectProvider : TypeDescriptionProvider {
    private static DependencyObjectProvider();
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    public virtual IDictionary GetCache(object instance);
    internal static AttachInfo GetAttachInfo(DependencyProperty dp);
    internal static DependencyObjectPropertyDescriptor GetAttachedPropertyDescriptor(DependencyProperty dp, Type targetType);
    internal static DependencyPropertyKind GetDependencyPropertyKind(DependencyProperty dp, Type targetType);
}
[AttributeUsageAttribute("64")]
internal class MS.Internal.ComponentModel.DependencyPropertyAttribute : Attribute {
    public object TypeId { get; }
    internal bool IsAttached { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal DependencyPropertyAttribute(DependencyProperty dependencyProperty, bool isAttached);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
    internal bool get_IsAttached();
    internal DependencyProperty get_DependencyProperty();
}
internal class MS.Internal.ComponentModel.DependencyPropertyKind : object {
    internal bool IsInternal { get; }
    internal bool IsAttached { get; }
    internal bool IsDirect { get; }
    internal DependencyPropertyKind(DependencyProperty dp, Type targetType);
    internal bool get_IsInternal();
    internal bool get_IsAttached();
    internal bool get_IsDirect();
}
internal class MS.Internal.ComponentModel.DPCustomTypeDescriptor : ValueType {
    private ICustomTypeDescriptor _parent;
    private Type _objectType;
    private object _instance;
    private static PropertyFilterOptions _anySet;
    private static PropertyFilterOptions _anyValid;
    internal DPCustomTypeDescriptor(ICustomTypeDescriptor parent, Type objectType, object instance);
    private static DPCustomTypeDescriptor();
    public sealed virtual string GetComponentName();
    public sealed virtual PropertyDescriptorCollection GetProperties();
    public sealed virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public sealed virtual AttributeCollection GetAttributes();
    public sealed virtual string GetClassName();
    public sealed virtual TypeConverter GetConverter();
    public sealed virtual EventDescriptor GetDefaultEvent();
    public sealed virtual PropertyDescriptor GetDefaultProperty();
    public sealed virtual object GetEditor(Type editorBaseType);
    public sealed virtual EventDescriptorCollection GetEvents();
    public sealed virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public sealed virtual object GetPropertyOwner(PropertyDescriptor property);
    internal static void ClearCache();
}
internal class MS.Internal.ComponentModel.PropertyChangeTracker : Expression {
    internal EventHandler Changed;
    internal bool CanClose { get; }
    internal PropertyChangeTracker(DependencyObject obj, DependencyProperty property);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal void Close();
    internal bool get_CanClose();
}
internal class MS.Internal.ComponentModel.PropertyDescriptorComparer : object {
    public sealed virtual bool Equals(PropertyDescriptor p1, PropertyDescriptor p2);
    public sealed virtual int GetHashCode(PropertyDescriptor p);
}
internal class MS.Internal.ComponentModel.PropertyKey : ValueType {
    internal DependencyProperty DependencyProperty;
    internal Type AttachedType;
    private int _hashCode;
    internal PropertyKey(Type attachedType, DependencyProperty prop);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyKey key);
    public static bool op_Equality(PropertyKey key1, PropertyKey key2);
    public static bool op_Inequality(PropertyKey key1, PropertyKey key2);
}
internal class MS.Internal.ComponentModel.ReferenceEqualityComparer : object {
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ContentType : object {
    internal string TypeComponent { get; }
    internal string SubTypeComponent { get; }
    internal Enumerator<string, string> ParameterValuePairs { get; }
    internal static ContentType Empty { get; }
    internal string OriginalString { get; }
    internal ContentType(string contentType);
    private static ContentType();
    internal string get_TypeComponent();
    internal string get_SubTypeComponent();
    internal Enumerator<string, string> get_ParameterValuePairs();
    internal static ContentType get_Empty();
    internal string get_OriginalString();
    internal bool AreTypeAndSubTypeEqual(ContentType contentType);
    internal bool AreTypeAndSubTypeEqual(ContentType contentType, bool allowParameterValuePairs);
    public virtual string ToString();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.CopyOnWriteList : object {
    public ArrayList List { get; }
    protected object SyncRoot { get; }
    protected ArrayList LiveList { get; }
    public CopyOnWriteList(object syncRoot);
    public ArrayList get_List();
    public virtual bool Add(object obj);
    public virtual bool Remove(object obj);
    protected object get_SyncRoot();
    protected ArrayList get_LiveList();
    protected bool Internal_Add(object obj);
    protected bool Internal_Insert(int index, object obj);
    protected bool RemoveAt(int index);
    protected void DoCopyOnWriteCheck();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.CriticalExceptions : object {
    [FriendAccessAllowedAttribute]
internal static bool IsCriticalException(Exception ex);
    [FriendAccessAllowedAttribute]
internal static bool IsCriticalApplicationException(Exception ex);
    [FriendAccessAllowedAttribute]
internal static Exception Unwrap(Exception ex);
}
[FriendAccessAllowedAttribute]
internal abstract class MS.Internal.DefaultValueFactory : object {
    internal object DefaultValue { get; }
    internal abstract virtual object get_DefaultValue();
    internal abstract virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.DoubleUtil : object {
    internal static double DBL_EPSILON;
    internal static float FLT_MIN;
    public static bool AreClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool IsOne(double value);
    public static bool IsZero(double value);
    public static bool AreClose(Point point1, Point point2);
    public static bool AreClose(Size size1, Size size2);
    public static bool AreClose(Vector vector1, Vector vector2);
    public static bool AreClose(Rect rect1, Rect rect2);
    public static bool IsBetweenZeroAndOne(double val);
    public static int DoubleToInt(double val);
    public static bool RectHasNaN(Rect r);
    public static bool IsNaN(double value);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FreezableDefaultValueFactory : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal FreezableDefaultValueFactory(Freezable defaultValue);
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal static class MS.Internal.GenericsInstances : object {
    private static GenericsInstances();
}
internal class MS.Internal.GetTraceSourceDelegate : MulticastDelegate {
    public GetTraceSourceDelegate(object object, IntPtr method);
    public virtual TraceSource Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TraceSource EndInvoke(IAsyncResult result);
}
internal static class MS.Internal.Hashing.WindowsBase.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.InheritanceContextChangedEventManager : WeakEventManager {
    public static void AddListener(DependencyObject source, IWeakEventListener listener);
    public static void RemoveListener(DependencyObject source, IWeakEventListener listener);
    public static void AddHandler(DependencyObject source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(DependencyObject source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
internal static class MS.Internal.InheritanceContextHelper : object {
    [FriendAccessAllowedAttribute]
internal static void ProvideContextForObject(DependencyObject context, DependencyObject newValue);
    [FriendAccessAllowedAttribute]
internal static void RemoveContextFromObject(DependencyObject context, DependencyObject oldValue);
    [FriendAccessAllowedAttribute]
internal static void AddInheritanceContext(DependencyObject newInheritanceContext, DependencyObject value, Boolean& hasMultipleInheritanceContexts, DependencyObject& inheritanceContext);
    [FriendAccessAllowedAttribute]
internal static void RemoveInheritanceContext(DependencyObject oldInheritanceContext, DependencyObject value, Boolean& hasMultipleInheritanceContexts, DependencyObject& inheritanceContext);
}
internal enum MS.Internal.Interop.ADLT : Enum {
    public int value__;
    public static ADLT RECENT;
    public static ADLT FREQUENT;
}
internal class MS.Internal.Interop.CHANGEFILTERSTRUCT : ValueType {
    public UInt32 cbSize;
    public MSGFLTINFO ExtStatus;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.DOGIF : Enum {
    public int value__;
    public static DOGIF DEFAULT;
    public static DOGIF TRAVERSE_LINK;
    public static DOGIF NO_HDROP;
    public static DOGIF NO_URL;
    public static DOGIF ONLY_IF_ONE;
}
internal enum MS.Internal.Interop.Facility : Enum {
    public int value__;
    public static Facility Null;
    public static Facility Rpc;
    public static Facility Dispatch;
    public static Facility Storage;
    public static Facility Itf;
    public static Facility Win32;
    public static Facility Windows;
    public static Facility Control;
    public static Facility Ese;
}
internal enum MS.Internal.Interop.FDAP : Enum {
    public UInt32 value__;
    public static FDAP BOTTOM;
    public static FDAP TOP;
}
internal enum MS.Internal.Interop.FDEOR : Enum {
    public int value__;
    public static FDEOR DEFAULT;
    public static FDEOR ACCEPT;
    public static FDEOR REFUSE;
}
internal enum MS.Internal.Interop.FDESVR : Enum {
    public int value__;
    public static FDESVR DEFAULT;
    public static FDESVR ACCEPT;
    public static FDESVR REFUSE;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.FOS : Enum {
    public UInt32 value__;
    public static FOS OVERWRITEPROMPT;
    public static FOS STRICTFILETYPES;
    public static FOS NOCHANGEDIR;
    public static FOS PICKFOLDERS;
    public static FOS FORCEFILESYSTEM;
    public static FOS ALLNONSTORAGEITEMS;
    public static FOS NOVALIDATE;
    public static FOS ALLOWMULTISELECT;
    public static FOS PATHMUSTEXIST;
    public static FOS FILEMUSTEXIST;
    public static FOS CREATEPROMPT;
    public static FOS SHAREAWARE;
    public static FOS NOREADONLYRETURN;
    public static FOS NOTESTFILECREATE;
    public static FOS HIDEMRUPLACES;
    public static FOS HIDEPINNEDPLACES;
    public static FOS NODEREFERENCELINKS;
    public static FOS DONTADDTORECENT;
    public static FOS FORCESHOWHIDDEN;
    public static FOS DEFAULTNOMINIMODE;
    public static FOS FORCEPREVIEWPANEON;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.GPS : Enum {
    public int value__;
    public static GPS DEFAULT;
    public static GPS HANDLERPROPERTIESONLY;
    public static GPS READWRITE;
    public static GPS TEMPORARY;
    public static GPS FASTPROPERTIESONLY;
    public static GPS OPENSLOWITEM;
    public static GPS DELAYCREATION;
    public static GPS BESTEFFORT;
    public static GPS NO_OPLOCK;
    public static GPS MASK_VALID;
}
internal class MS.Internal.Interop.HRESULT : ValueType {
    private UInt32 _value;
    public static HRESULT S_OK;
    public static HRESULT S_FALSE;
    public static HRESULT E_NOTIMPL;
    public static HRESULT E_NOINTERFACE;
    public static HRESULT E_POINTER;
    public static HRESULT E_ABORT;
    public static HRESULT E_FAIL;
    public static HRESULT E_UNEXPECTED;
    public static HRESULT DISP_E_MEMBERNOTFOUND;
    public static HRESULT DISP_E_TYPEMISMATCH;
    public static HRESULT DISP_E_UNKNOWNNAME;
    public static HRESULT DISP_E_EXCEPTION;
    public static HRESULT DISP_E_OVERFLOW;
    public static HRESULT DISP_E_BADINDEX;
    public static HRESULT DISP_E_BADPARAMCOUNT;
    public static HRESULT DISP_E_PARAMNOTOPTIONAL;
    public static HRESULT SCRIPT_E_REPORTED;
    public static HRESULT STG_E_INVALIDFUNCTION;
    public static HRESULT DESTS_E_NO_MATCHING_ASSOC_HANDLER;
    public static HRESULT E_ACCESSDENIED;
    public static HRESULT E_OUTOFMEMORY;
    public static HRESULT E_INVALIDARG;
    public static HRESULT COR_E_OBJECTDISPOSED;
    public static HRESULT WC_E_GREATERTHAN;
    public static HRESULT WC_E_SYNTAX;
    public Facility Facility { get; }
    public int Code { get; }
    public bool Succeeded { get; }
    public bool Failed { get; }
    public HRESULT(UInt32 i);
    private static HRESULT();
    public static HRESULT Make(bool severe, Facility facility, int code);
    public Facility get_Facility();
    public static Facility GetFacility(int errorCode);
    public int get_Code();
    public static int GetCode(int error);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HRESULT hrLeft, HRESULT hrRight);
    public static bool op_Inequality(HRESULT hrLeft, HRESULT hrRight);
    public bool get_Succeeded();
    public bool get_Failed();
    public void ThrowIfFailed();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public void ThrowIfFailed(string message);
    public Exception GetException();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public Exception GetException(string message);
}
internal enum MS.Internal.Interop.KDC : Enum {
    public int value__;
    public static KDC FREQUENT;
    public static KDC RECENT;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.KF_FLAG : Enum {
    public UInt32 value__;
    public static KF_FLAG DEFAULT;
    public static KF_FLAG CREATE;
    public static KF_FLAG DONT_VERIFY;
    public static KF_FLAG DONT_UNEXPAND;
    public static KF_FLAG NO_ALIAS;
    public static KF_FLAG INIT;
    public static KF_FLAG DEFAULT_PATH;
    public static KF_FLAG NOT_PARENT_RELATIVE;
    public static KF_FLAG SIMPLE_IDLIST;
    public static KF_FLAG ALIAS_ONLY;
}
internal enum MS.Internal.Interop.MSGFLT : Enum {
    public int value__;
    public static MSGFLT RESET;
    public static MSGFLT ALLOW;
    public static MSGFLT DISALLOW;
}
internal enum MS.Internal.Interop.MSGFLTINFO : Enum {
    public int value__;
    public static MSGFLTINFO NONE;
    public static MSGFLTINFO ALREADYALLOWED_FORWND;
    public static MSGFLTINFO ALREADYDISALLOWED_FORWND;
    public static MSGFLTINFO ALLOWED_HIGHER;
}
[SecurityCriticalAttribute]
internal class MS.Internal.Interop.PROPVARIANT : object {
    public VarEnum VarType { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public VarEnum get_VarType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public string GetValue();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public void SetValue(bool f);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public void SetValue(string val);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public void Clear();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SFGAO : Enum {
    public UInt32 value__;
    public static SFGAO CANCOPY;
    public static SFGAO CANMOVE;
    public static SFGAO CANLINK;
    public static SFGAO STORAGE;
    public static SFGAO CANRENAME;
    public static SFGAO CANDELETE;
    public static SFGAO HASPROPSHEET;
    public static SFGAO DROPTARGET;
    public static SFGAO CAPABILITYMASK;
    public static SFGAO ENCRYPTED;
    public static SFGAO ISSLOW;
    public static SFGAO GHOSTED;
    public static SFGAO LINK;
    public static SFGAO SHARE;
    public static SFGAO READONLY;
    public static SFGAO HIDDEN;
    public static SFGAO DISPLAYATTRMASK;
    public static SFGAO FILESYSANCESTOR;
    public static SFGAO FOLDER;
    public static SFGAO FILESYSTEM;
    public static SFGAO HASSUBFOLDER;
    public static SFGAO CONTENTSMASK;
    public static SFGAO VALIDATE;
    public static SFGAO REMOVABLE;
    public static SFGAO COMPRESSED;
    public static SFGAO BROWSABLE;
    public static SFGAO NONENUMERATED;
    public static SFGAO NEWCONTENT;
    public static SFGAO CANMONIKER;
    public static SFGAO HASSTORAGE;
    public static SFGAO STREAM;
    public static SFGAO STORAGEANCESTOR;
    public static SFGAO STORAGECAPMASK;
    public static SFGAO PKEYSFGAOMASK;
}
internal enum MS.Internal.Interop.SHARD : Enum {
    public int value__;
    public static SHARD PIDL;
    public static SHARD PATHA;
    public static SHARD PATHW;
    public static SHARD APPIDINFO;
    public static SHARD APPIDINFOIDLIST;
    public static SHARD LINK;
    public static SHARD APPIDINFOLINK;
    public static SHARD SHELLITEM;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SHCONTF : Enum {
    public int value__;
    public static SHCONTF CHECKING_FOR_CHILDREN;
    public static SHCONTF FOLDERS;
    public static SHCONTF NONFOLDERS;
    public static SHCONTF INCLUDEHIDDEN;
    public static SHCONTF INIT_ON_FIRST_NEXT;
    public static SHCONTF NETPRINTERSRCH;
    public static SHCONTF SHAREABLE;
    public static SHCONTF STORAGE;
    public static SHCONTF NAVIGATION_ENUM;
    public static SHCONTF FASTITEMS;
    public static SHCONTF FLATLIST;
    public static SHCONTF ENABLE_ASYNC;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SHGDN : Enum {
    public int value__;
    public static SHGDN SHGDN_NORMAL;
    public static SHGDN SHGDN_INFOLDER;
    public static SHGDN SHGDN_FOREDITING;
    public static SHGDN SHGDN_FORADDRESSBAR;
    public static SHGDN SHGDN_FORPARSING;
}
internal enum MS.Internal.Interop.SIATTRIBFLAGS : Enum {
    public int value__;
    public static SIATTRIBFLAGS AND;
    public static SIATTRIBFLAGS OR;
    public static SIATTRIBFLAGS APPCOMPAT;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SICHINT : Enum {
    public UInt32 value__;
    public static SICHINT DISPLAY;
    public static SICHINT ALLFIELDS;
    public static SICHINT CANONICAL;
    public static SICHINT TEST_FILESYSPATH_IF_NOT_EQUAL;
}
internal enum MS.Internal.Interop.SIGDN : Enum {
    public UInt32 value__;
    public static SIGDN NORMALDISPLAY;
    public static SIGDN PARENTRELATIVEPARSING;
    public static SIGDN DESKTOPABSOLUTEPARSING;
    public static SIGDN PARENTRELATIVEEDITING;
    public static SIGDN DESKTOPABSOLUTEEDITING;
    public static SIGDN FILESYSPATH;
    public static SIGDN URL;
    public static SIGDN PARENTRELATIVEFORADDRESSBAR;
    public static SIGDN PARENTRELATIVE;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.SLGP : Enum {
    public int value__;
    public static SLGP SHORTPATH;
    public static SLGP UNCPRIORITY;
    public static SLGP RAWPATH;
}
internal enum MS.Internal.Interop.SM : Enum {
    public int value__;
    public static SM CXSCREEN;
    public static SM CYSCREEN;
    public static SM CXVSCROLL;
    public static SM CYHSCROLL;
    public static SM CYCAPTION;
    public static SM CXBORDER;
    public static SM CYBORDER;
    public static SM CXFIXEDFRAME;
    public static SM CYFIXEDFRAME;
    public static SM CYVTHUMB;
    public static SM CXHTHUMB;
    public static SM CXICON;
    public static SM CYICON;
    public static SM CXCURSOR;
    public static SM CYCURSOR;
    public static SM CYMENU;
    public static SM CXFULLSCREEN;
    public static SM CYFULLSCREEN;
    public static SM CYKANJIWINDOW;
    public static SM MOUSEPRESENT;
    public static SM CYVSCROLL;
    public static SM CXHSCROLL;
    public static SM DEBUG;
    public static SM SWAPBUTTON;
    public static SM CXMIN;
    public static SM CYMIN;
    public static SM CXSIZE;
    public static SM CYSIZE;
    public static SM CXFRAME;
    public static SM CXSIZEFRAME;
    public static SM CYFRAME;
    public static SM CYSIZEFRAME;
    public static SM CXMINTRACK;
    public static SM CYMINTRACK;
    public static SM CXDOUBLECLK;
    public static SM CYDOUBLECLK;
    public static SM CXICONSPACING;
    public static SM CYICONSPACING;
    public static SM MENUDROPALIGNMENT;
    public static SM PENWINDOWS;
    public static SM DBCSENABLED;
    public static SM CMOUSEBUTTONS;
    public static SM SECURE;
    public static SM CXEDGE;
    public static SM CYEDGE;
    public static SM CXMINSPACING;
    public static SM CYMINSPACING;
    public static SM CXSMICON;
    public static SM CYSMICON;
    public static SM CYSMCAPTION;
    public static SM CXSMSIZE;
    public static SM CYSMSIZE;
    public static SM CXMENUSIZE;
    public static SM CYMENUSIZE;
    public static SM ARRANGE;
    public static SM CXMINIMIZED;
    public static SM CYMINIMIZED;
    public static SM CXMAXTRACK;
    public static SM CYMAXTRACK;
    public static SM CXMAXIMIZED;
    public static SM CYMAXIMIZED;
    public static SM NETWORK;
    public static SM CLEANBOOT;
    public static SM CXDRAG;
    public static SM CYDRAG;
    public static SM SHOWSOUNDS;
    public static SM CXMENUCHECK;
    public static SM CYMENUCHECK;
    public static SM SLOWMACHINE;
    public static SM MIDEASTENABLED;
    public static SM MOUSEWHEELPRESENT;
    public static SM XVIRTUALSCREEN;
    public static SM YVIRTUALSCREEN;
    public static SM CXVIRTUALSCREEN;
    public static SM CYVIRTUALSCREEN;
    public static SM CMONITORS;
    public static SM SAMEDISPLAYFORMAT;
    public static SM IMMENABLED;
    public static SM CXFOCUSBORDER;
    public static SM CYFOCUSBORDER;
    public static SM TABLETPC;
    public static SM MEDIACENTER;
    public static SM REMOTESESSION;
    public static SM REMOTECONTROL;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.STPF : Enum {
    public int value__;
    public static STPF NONE;
    public static STPF USEAPPTHUMBNAILALWAYS;
    public static STPF USEAPPTHUMBNAILWHENACTIVE;
    public static STPF USEAPPPEEKALWAYS;
    public static STPF USEAPPPEEKWHENACTIVE;
}
internal static class MS.Internal.Interop.STR_GPS : object {
    public static string HANDLERPROPERTIESONLY;
    public static string FASTPROPERTIESONLY;
    public static string OPENSLOWITEM;
    public static string DELAYCREATION;
    public static string BESTEFFORT;
    public static string NO_OPLOCK;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.TBPF : Enum {
    public int value__;
    public static TBPF NOPROGRESS;
    public static TBPF INDETERMINATE;
    public static TBPF NORMAL;
    public static TBPF ERROR;
    public static TBPF PAUSED;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.THB : Enum {
    public UInt32 value__;
    public static THB BITMAP;
    public static THB ICON;
    public static THB TOOLTIP;
    public static THB FLAGS;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.THBF : Enum {
    public UInt32 value__;
    public static THBF ENABLED;
    public static THBF DISABLED;
    public static THBF DISMISSONCLICK;
    public static THBF NOBACKGROUND;
    public static THBF HIDDEN;
    public static THBF NONINTERACTIVE;
}
[BestFitMappingAttribute("False")]
internal class MS.Internal.Interop.WIN32_FIND_DATAW : object {
    public FileAttributes dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public int nFileSizeHigh;
    public int nFileSizeLow;
    public int dwReserved0;
    public int dwReserved1;
    public string cFileName;
    public string cAlternateFileName;
}
internal static class MS.Internal.Interop.Win32Constant : object {
    internal static int MAX_PATH;
    internal static int INFOTIPSIZE;
    internal static int TRUE;
    internal static int FALSE;
}
internal class MS.Internal.Interop.Win32Error : ValueType {
    private int _value;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INVALID_FUNCTION;
    public static Win32Error ERROR_FILE_NOT_FOUND;
    public static Win32Error ERROR_PATH_NOT_FOUND;
    public static Win32Error ERROR_TOO_MANY_OPEN_FILES;
    public static Win32Error ERROR_ACCESS_DENIED;
    public static Win32Error ERROR_INVALID_HANDLE;
    public static Win32Error ERROR_OUTOFMEMORY;
    public static Win32Error ERROR_NO_MORE_FILES;
    public static Win32Error ERROR_SHARING_VIOLATION;
    public static Win32Error ERROR_INVALID_PARAMETER;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NESTING_NOT_ALLOWED;
    public static Win32Error ERROR_KEY_DELETED;
    public static Win32Error ERROR_NO_MATCH;
    public static Win32Error ERROR_BAD_DEVICE;
    public static Win32Error ERROR_CANCELLED;
    public static Win32Error ERROR_INVALID_WINDOW_HANDLE;
    public static Win32Error ERROR_TIMEOUT;
    public static Win32Error ERROR_INVALID_DATATYPE;
    public Win32Error(int i);
    private static Win32Error();
    public static HRESULT op_Explicit(Win32Error error);
    public HRESULT ToHRESULT();
    [SecurityCriticalAttribute]
public static Win32Error GetLastError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Win32Error errLeft, Win32Error errRight);
    public static bool op_Inequality(Win32Error errLeft, Win32Error errRight);
}
internal enum MS.Internal.Interop.WindowMessage : Enum {
    public int value__;
    public static WindowMessage WM_NULL;
    public static WindowMessage WM_CREATE;
    public static WindowMessage WM_DESTROY;
    public static WindowMessage WM_MOVE;
    public static WindowMessage WM_SIZE;
    public static WindowMessage WM_ACTIVATE;
    public static WindowMessage WM_SETFOCUS;
    public static WindowMessage WM_KILLFOCUS;
    public static WindowMessage WM_ENABLE;
    public static WindowMessage WM_SETREDRAW;
    public static WindowMessage WM_SETTEXT;
    public static WindowMessage WM_GETTEXT;
    public static WindowMessage WM_GETTEXTLENGTH;
    public static WindowMessage WM_PAINT;
    public static WindowMessage WM_CLOSE;
    public static WindowMessage WM_QUERYENDSESSION;
    public static WindowMessage WM_QUIT;
    public static WindowMessage WM_QUERYOPEN;
    public static WindowMessage WM_ERASEBKGND;
    public static WindowMessage WM_SYSCOLORCHANGE;
    public static WindowMessage WM_ENDSESSION;
    public static WindowMessage WM_SHOWWINDOW;
    public static WindowMessage WM_CTLCOLOR;
    public static WindowMessage WM_WININICHANGE;
    public static WindowMessage WM_SETTINGCHANGE;
    public static WindowMessage WM_DEVMODECHANGE;
    public static WindowMessage WM_ACTIVATEAPP;
    public static WindowMessage WM_FONTCHANGE;
    public static WindowMessage WM_TIMECHANGE;
    public static WindowMessage WM_CANCELMODE;
    public static WindowMessage WM_SETCURSOR;
    public static WindowMessage WM_MOUSEACTIVATE;
    public static WindowMessage WM_CHILDACTIVATE;
    public static WindowMessage WM_QUEUESYNC;
    public static WindowMessage WM_GETMINMAXINFO;
    public static WindowMessage WM_PAINTICON;
    public static WindowMessage WM_ICONERASEBKGND;
    public static WindowMessage WM_NEXTDLGCTL;
    public static WindowMessage WM_SPOOLERSTATUS;
    public static WindowMessage WM_DRAWITEM;
    public static WindowMessage WM_MEASUREITEM;
    public static WindowMessage WM_DELETEITEM;
    public static WindowMessage WM_VKEYTOITEM;
    public static WindowMessage WM_CHARTOITEM;
    public static WindowMessage WM_SETFONT;
    public static WindowMessage WM_GETFONT;
    public static WindowMessage WM_SETHOTKEY;
    public static WindowMessage WM_GETHOTKEY;
    public static WindowMessage WM_QUERYDRAGICON;
    public static WindowMessage WM_COMPAREITEM;
    public static WindowMessage WM_GETOBJECT;
    public static WindowMessage WM_COMPACTING;
    public static WindowMessage WM_COMMNOTIFY;
    public static WindowMessage WM_WINDOWPOSCHANGING;
    public static WindowMessage WM_WINDOWPOSCHANGED;
    public static WindowMessage WM_POWER;
    public static WindowMessage WM_COPYDATA;
    public static WindowMessage WM_CANCELJOURNAL;
    public static WindowMessage WM_NOTIFY;
    public static WindowMessage WM_INPUTLANGCHANGEREQUEST;
    public static WindowMessage WM_INPUTLANGCHANGE;
    public static WindowMessage WM_TCARD;
    public static WindowMessage WM_HELP;
    public static WindowMessage WM_USERCHANGED;
    public static WindowMessage WM_NOTIFYFORMAT;
    public static WindowMessage WM_CONTEXTMENU;
    public static WindowMessage WM_STYLECHANGING;
    public static WindowMessage WM_STYLECHANGED;
    public static WindowMessage WM_DISPLAYCHANGE;
    public static WindowMessage WM_GETICON;
    public static WindowMessage WM_SETICON;
    public static WindowMessage WM_NCCREATE;
    public static WindowMessage WM_NCDESTROY;
    public static WindowMessage WM_NCCALCSIZE;
    public static WindowMessage WM_NCHITTEST;
    public static WindowMessage WM_NCPAINT;
    public static WindowMessage WM_NCACTIVATE;
    public static WindowMessage WM_GETDLGCODE;
    public static WindowMessage WM_SYNCPAINT;
    public static WindowMessage WM_MOUSEQUERY;
    public static WindowMessage WM_NCMOUSEMOVE;
    public static WindowMessage WM_NCLBUTTONDOWN;
    public static WindowMessage WM_NCLBUTTONUP;
    public static WindowMessage WM_NCLBUTTONDBLCLK;
    public static WindowMessage WM_NCRBUTTONDOWN;
    public static WindowMessage WM_NCRBUTTONUP;
    public static WindowMessage WM_NCRBUTTONDBLCLK;
    public static WindowMessage WM_NCMBUTTONDOWN;
    public static WindowMessage WM_NCMBUTTONUP;
    public static WindowMessage WM_NCMBUTTONDBLCLK;
    public static WindowMessage WM_NCXBUTTONDOWN;
    public static WindowMessage WM_NCXBUTTONUP;
    public static WindowMessage WM_NCXBUTTONDBLCLK;
    public static WindowMessage WM_INPUT;
    public static WindowMessage WM_KEYFIRST;
    public static WindowMessage WM_KEYDOWN;
    public static WindowMessage WM_KEYUP;
    public static WindowMessage WM_CHAR;
    public static WindowMessage WM_DEADCHAR;
    public static WindowMessage WM_SYSKEYDOWN;
    public static WindowMessage WM_SYSKEYUP;
    public static WindowMessage WM_SYSCHAR;
    public static WindowMessage WM_SYSDEADCHAR;
    public static WindowMessage WM_KEYLAST;
    public static WindowMessage WM_IME_STARTCOMPOSITION;
    public static WindowMessage WM_IME_ENDCOMPOSITION;
    public static WindowMessage WM_IME_COMPOSITION;
    public static WindowMessage WM_IME_KEYLAST;
    public static WindowMessage WM_INITDIALOG;
    public static WindowMessage WM_COMMAND;
    public static WindowMessage WM_SYSCOMMAND;
    public static WindowMessage WM_TIMER;
    public static WindowMessage WM_HSCROLL;
    public static WindowMessage WM_VSCROLL;
    public static WindowMessage WM_INITMENU;
    public static WindowMessage WM_INITMENUPOPUP;
    public static WindowMessage WM_MENUSELECT;
    public static WindowMessage WM_MENUCHAR;
    public static WindowMessage WM_ENTERIDLE;
    public static WindowMessage WM_UNINITMENUPOPUP;
    public static WindowMessage WM_CHANGEUISTATE;
    public static WindowMessage WM_UPDATEUISTATE;
    public static WindowMessage WM_QUERYUISTATE;
    public static WindowMessage WM_CTLCOLORMSGBOX;
    public static WindowMessage WM_CTLCOLOREDIT;
    public static WindowMessage WM_CTLCOLORLISTBOX;
    public static WindowMessage WM_CTLCOLORBTN;
    public static WindowMessage WM_CTLCOLORDLG;
    public static WindowMessage WM_CTLCOLORSCROLLBAR;
    public static WindowMessage WM_CTLCOLORSTATIC;
    public static WindowMessage WM_MOUSEMOVE;
    public static WindowMessage WM_MOUSEFIRST;
    public static WindowMessage WM_LBUTTONDOWN;
    public static WindowMessage WM_LBUTTONUP;
    public static WindowMessage WM_LBUTTONDBLCLK;
    public static WindowMessage WM_RBUTTONDOWN;
    public static WindowMessage WM_RBUTTONUP;
    public static WindowMessage WM_RBUTTONDBLCLK;
    public static WindowMessage WM_MBUTTONDOWN;
    public static WindowMessage WM_MBUTTONUP;
    public static WindowMessage WM_MBUTTONDBLCLK;
    public static WindowMessage WM_MOUSEWHEEL;
    public static WindowMessage WM_XBUTTONDOWN;
    public static WindowMessage WM_XBUTTONUP;
    public static WindowMessage WM_XBUTTONDBLCLK;
    public static WindowMessage WM_MOUSEHWHEEL;
    public static WindowMessage WM_MOUSELAST;
    public static WindowMessage WM_PARENTNOTIFY;
    public static WindowMessage WM_ENTERMENULOOP;
    public static WindowMessage WM_EXITMENULOOP;
    public static WindowMessage WM_NEXTMENU;
    public static WindowMessage WM_SIZING;
    public static WindowMessage WM_CAPTURECHANGED;
    public static WindowMessage WM_MOVING;
    public static WindowMessage WM_POWERBROADCAST;
    public static WindowMessage WM_DEVICECHANGE;
    public static WindowMessage WM_IME_SETCONTEXT;
    public static WindowMessage WM_IME_NOTIFY;
    public static WindowMessage WM_IME_CONTROL;
    public static WindowMessage WM_IME_COMPOSITIONFULL;
    public static WindowMessage WM_IME_SELECT;
    public static WindowMessage WM_IME_CHAR;
    public static WindowMessage WM_IME_REQUEST;
    public static WindowMessage WM_IME_KEYDOWN;
    public static WindowMessage WM_IME_KEYUP;
    public static WindowMessage WM_MDICREATE;
    public static WindowMessage WM_MDIDESTROY;
    public static WindowMessage WM_MDIACTIVATE;
    public static WindowMessage WM_MDIRESTORE;
    public static WindowMessage WM_MDINEXT;
    public static WindowMessage WM_MDIMAXIMIZE;
    public static WindowMessage WM_MDITILE;
    public static WindowMessage WM_MDICASCADE;
    public static WindowMessage WM_MDIICONARRANGE;
    public static WindowMessage WM_MDIGETACTIVE;
    public static WindowMessage WM_MDISETMENU;
    public static WindowMessage WM_ENTERSIZEMOVE;
    public static WindowMessage WM_EXITSIZEMOVE;
    public static WindowMessage WM_DROPFILES;
    public static WindowMessage WM_MDIREFRESHMENU;
    public static WindowMessage WM_MOUSEHOVER;
    public static WindowMessage WM_NCMOUSELEAVE;
    public static WindowMessage WM_MOUSELEAVE;
    public static WindowMessage WM_WTSSESSION_CHANGE;
    public static WindowMessage WM_TABLET_DEFBASE;
    public static WindowMessage WM_TABLET_MAXOFFSET;
    public static WindowMessage WM_TABLET_ADDED;
    public static WindowMessage WM_TABLET_DELETED;
    public static WindowMessage WM_TABLET_FLICK;
    public static WindowMessage WM_TABLET_QUERYSYSTEMGESTURESTATUS;
    public static WindowMessage WM_CUT;
    public static WindowMessage WM_COPY;
    public static WindowMessage WM_PASTE;
    public static WindowMessage WM_CLEAR;
    public static WindowMessage WM_UNDO;
    public static WindowMessage WM_RENDERFORMAT;
    public static WindowMessage WM_RENDERALLFORMATS;
    public static WindowMessage WM_DESTROYCLIPBOARD;
    public static WindowMessage WM_DRAWCLIPBOARD;
    public static WindowMessage WM_PAINTCLIPBOARD;
    public static WindowMessage WM_VSCROLLCLIPBOARD;
    public static WindowMessage WM_SIZECLIPBOARD;
    public static WindowMessage WM_ASKCBFORMATNAME;
    public static WindowMessage WM_CHANGECBCHAIN;
    public static WindowMessage WM_HSCROLLCLIPBOARD;
    public static WindowMessage WM_QUERYNEWPALETTE;
    public static WindowMessage WM_PALETTEISCHANGING;
    public static WindowMessage WM_PALETTECHANGED;
    public static WindowMessage WM_HOTKEY;
    public static WindowMessage WM_PRINT;
    public static WindowMessage WM_PRINTCLIENT;
    public static WindowMessage WM_APPCOMMAND;
    public static WindowMessage WM_THEMECHANGED;
    public static WindowMessage WM_DWMCOMPOSITIONCHANGED;
    public static WindowMessage WM_DWMNCRENDERINGCHANGED;
    public static WindowMessage WM_DWMCOLORIZATIONCOLORCHANGED;
    public static WindowMessage WM_DWMWINDOWMAXIMIZEDCHANGE;
    public static WindowMessage WM_HANDHELDFIRST;
    public static WindowMessage WM_HANDHELDLAST;
    public static WindowMessage WM_AFXFIRST;
    public static WindowMessage WM_AFXLAST;
    public static WindowMessage WM_PENWINFIRST;
    public static WindowMessage WM_PENWINLAST;
    public static WindowMessage WM_DWMSENDICONICTHUMBNAIL;
    public static WindowMessage WM_DWMSENDICONICLIVEPREVIEWBITMAP;
    public static WindowMessage WM_USER;
    public static WindowMessage WM_APP;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.Invariant : object {
    internal static bool Strict { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Invariant();
    internal static void Assert(bool condition);
    internal static void Assert(bool condition, string invariantMessage);
    internal static void Assert(bool condition, string invariantMessage, string detailMessage);
    internal static bool get_Strict();
    internal static void set_Strict(bool value);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.BLOB : ValueType {
    public UInt32 cbSize;
    public IntPtr pBlobData;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.BSTRBLOB : ValueType {
    public UInt32 cbSize;
    public IntPtr pData;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CArray : ValueType {
    public UInt32 cElems;
    public IntPtr pElems;
}
internal class MS.Internal.IO.Packaging.CaseInsensitiveOrdinalStringComparer : object {
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object str);
}
internal class MS.Internal.IO.Packaging.CertificatePart : object {
    internal static string RelationshipType { get; }
    internal static string PartNamePrefix { get; }
    internal static string PartNameExtension { get; }
    internal static ContentType ContentType { get; }
    internal Uri Uri { get; }
    internal CertificatePart(Package container, Uri partName);
    private static CertificatePart();
    internal static string get_RelationshipType();
    internal static string get_PartNamePrefix();
    internal static string get_PartNameExtension();
    internal static ContentType get_ContentType();
    internal Uri get_Uri();
    internal X509Certificate2 GetCertificate();
    internal void SetCertificate(X509Certificate2 certificate);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CFStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool StreamDisposed { get; }
    internal CFStream(IStream underlyingStream, FileAccess openAccess, StreamInfo creator);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void CheckDisposedStatus();
    internal bool get_StreamDisposed();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileDeflateTransform : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Decompress(Stream source, Stream sink);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Compress(Stream source, Stream sink);
}
internal abstract class MS.Internal.IO.Packaging.CompoundFile.CompoundFileReference : object {
    public string FullName { get; }
    public abstract virtual string get_FullName();
    private sealed virtual override int System.IComparable.CompareTo(object ob);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal static int Save(CompoundFileReference reference, BinaryWriter writer);
    internal static CompoundFileReference Load(BinaryReader reader, Int32& bytesRead);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileStorageReference : CompoundFileReference {
    public string FullName { get; }
    public CompoundFileStorageReference(string fullName);
    public virtual string get_FullName();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object o);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompoundFileStreamReference : CompoundFileReference {
    public string FullName { get; }
    public CompoundFileStreamReference(string fullName);
    public CompoundFileStreamReference(string storageName, string streamName);
    public virtual string get_FullName();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object o);
}
internal class MS.Internal.IO.Packaging.CompoundFile.CompressionTransform : object {
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    public object TransformIdentifier { get; }
    internal static string ClassTransformIdentifier { get; }
    public CompressionTransform(TransformEnvironment myEnvironment);
    private static CompressionTransform();
    public sealed virtual bool get_IsReady();
    public sealed virtual bool get_FixedSettings();
    public sealed virtual object get_TransformIdentifier();
    internal static string get_ClassTransformIdentifier();
    private sealed virtual override Stream System.IO.Packaging.IDataTransform.GetTransformedStream(Stream encodedStream, IDictionary transformContext);
}
[FriendAccessAllowedAttribute]
[FlagsAttribute]
internal enum MS.Internal.IO.Packaging.CompoundFile.ContainerFlags : Enum {
    public int value__;
    public static ContainerFlags HostInBrowser;
    public static ContainerFlags Writable;
    public static ContainerFlags Metro;
    public static ContainerFlags ExecuteInstrumentation;
}
internal static class MS.Internal.IO.Packaging.CompoundFile.ContainerUtilities : object {
    internal static char PathSeparator;
    internal static string PathSeparatorAsString;
    internal static int Int16Size { get; }
    internal static int Int32Size { get; }
    internal static int Int64Size { get; }
    internal static CaseInsensitiveOrdinalStringComparer StringCaseInsensitiveComparer { get; }
    private static ContainerUtilities();
    internal static int get_Int16Size();
    internal static int get_Int32Size();
    internal static int get_Int64Size();
    internal static CaseInsensitiveOrdinalStringComparer get_StringCaseInsensitiveComparer();
    internal static int CalculateDWordPadBytesLength(int length);
    internal static int WriteByteLengthPrefixedDWordPaddedUnicodeString(BinaryWriter writer, string outputString);
    internal static string ReadByteLengthPrefixedDWordPaddedUnicodeString(BinaryReader reader);
    internal static string ReadByteLengthPrefixedDWordPaddedUnicodeString(BinaryReader reader, Int32& bytesRead);
    internal static void CheckAgainstNull(object paramRef, string testStringIdentifier);
    internal static String[] ConvertBackSlashPathToStringArrayPath(string backSlashPath);
    internal static string ConvertStringArrayPathToBackSlashPath(IList arrayPath);
    internal static string ConvertStringArrayPathToBackSlashPath(IList storages, string streamName);
    internal static void CheckStringAgainstNullAndEmpty(string testString, string testStringIdentifier);
    internal static void CheckStringAgainstReservedName(string nameString, string nameStringIdentifier);
    internal static bool IsReservedName(string nameString);
    internal static void CheckStringForEmbeddedPathSeparator(string testString, string testStringIdentifier);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CompoundFile.FormatVersion : object {
    public VersionPair ReaderVersion { get; public set; }
    public VersionPair WriterVersion { get; public set; }
    public VersionPair UpdaterVersion { get; public set; }
    public string FeatureIdentifier { get; }
    public FormatVersion(string featureId, VersionPair version);
    public FormatVersion(string featureId, VersionPair writerVersion, VersionPair readerVersion, VersionPair updaterVersion);
    public VersionPair get_ReaderVersion();
    public void set_ReaderVersion(VersionPair value);
    public VersionPair get_WriterVersion();
    public void set_WriterVersion(VersionPair value);
    public VersionPair get_UpdaterVersion();
    public void set_UpdaterVersion(VersionPair value);
    public string get_FeatureIdentifier();
    public static FormatVersion LoadFromStream(Stream stream);
    public int SaveToStream(Stream stream);
    public bool IsReadableBy(VersionPair version);
    public bool IsUpdatableBy(VersionPair version);
    internal static FormatVersion LoadFromStream(Stream stream, Int32& bytesRead);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATPROPSETSTG {
    public abstract virtual int Next(UInt32 celt, STATPROPSETSTG rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATPROPSETSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATPROPSTG {
    public abstract virtual int Next(UInt32 celt, STATPROPSTG rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATPROPSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IEnumSTATSTG {
    public abstract virtual void Next(UInt32 celt, STATSTG& rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumSTATSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IPropertySetStorage {
    public abstract virtual void Create(Guid& rfmtid, Guid& pclsid, UInt32 grfFlags, UInt32 grfMode, IPropertyStorage& ppprstg);
    public abstract virtual int Open(Guid& rfmtid, UInt32 grfMode, IPropertyStorage& ppprstg);
    public abstract virtual void Delete(Guid& rfmtid);
    public abstract virtual void Enum(IEnumSTATPROPSETSTG& ppenum);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IPropertyStorage {
    public abstract virtual int ReadMultiple(UInt32 cpspec, PROPSPEC[] rgpspec, PROPVARIANT[] rgpropvar);
    public abstract virtual void WriteMultiple(UInt32 cpspec, PROPSPEC[] rgpspec, PROPVARIANT[] rgpropvar, UInt32 propidNameFirst);
    public abstract virtual void DeleteMultiple(UInt32 cpspec, PROPSPEC[] rgpspec);
    public abstract virtual void ReadPropertyNames(UInt32 cpropid, UInt32[] rgpropid, String[] rglpwstrName);
    public abstract virtual void WritePropertyNames(UInt32 cpropid, UInt32[] rgpropid, String[] rglpwstrName);
    public abstract virtual void DeletePropertyNames(UInt32 cpropid, UInt32[] rgpropid);
    public abstract virtual void Commit(UInt32 grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void Enum(IEnumSTATPROPSTG& ppenum);
    public abstract virtual void SetTimes(FILETIME& pctime, FILETIME& patime, FILETIME& pmtime);
    public abstract virtual void SetClass(Guid& clsid);
    public abstract virtual void Stat(STATPROPSETSTG& pstatpsstg);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IStorage {
    public abstract virtual int CreateStream(string pwcsName, int grfMode, int reserved1, int reserved2, IStream& ppstm);
    public abstract virtual int OpenStream(string pwcsName, int reserved1, int grfMode, int reserved2, IStream& ppstm);
    public abstract virtual int CreateStorage(string pwcsName, int grfMode, int reserved1, int reserved2, IStorage& ppstg);
    public abstract virtual int OpenStorage(string pwcsName, IStorage pstgPriority, int grfMode, IntPtr snbExclude, int reserved, IStorage& ppstg);
    public abstract virtual void CopyTo(int ciidExclude, Guid[] rgiidExclude, IntPtr snbExclude, IStorage ppstg);
    public abstract virtual void MoveElementTo(string pwcsName, IStorage pstgDest, string pwcsNewName, int grfFlags);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void EnumElements(int reserved1, IntPtr reserved2, int reserved3, IEnumSTATSTG& ppEnum);
    public abstract virtual void DestroyElement(string pwcsName);
    public abstract virtual void RenameElement(string pwcsOldName, string pwcsNewName);
    public abstract virtual void SetElementTimes(string pwcsName, FILETIME pctime, FILETIME patime, FILETIME pmtime);
    public abstract virtual void SetClass(Guid& clsid);
    public abstract virtual void SetStateBits(int grfStateBits, int grfMask);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
}
internal interface MS.Internal.IO.Packaging.CompoundFile.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, Int32& pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, Int32& pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, Int64& plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, Int64& pcbRead, Int64& pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
internal class MS.Internal.IO.Packaging.CompoundFile.RightsManagementEncryptedStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RightsManagementEncryptedStream(Stream baseStream, CryptoProvider cryptoProvider);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.CompoundFile.RightsManagementEncryptionTransform : object {
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    internal int TransformIdentifierType { get; }
    public object TransformIdentifier { get; }
    internal CryptoProvider CryptoProvider { get; internal set; }
    internal static string ClassTransformIdentifier { get; }
    internal RightsManagementEncryptionTransform(TransformEnvironment transformEnvironment);
    private static RightsManagementEncryptionTransform();
    internal PublishLicense LoadPublishLicense();
    internal void SavePublishLicense(PublishLicense publishLicense);
    internal UseLicense LoadUseLicense(ContentUser user);
    internal void SaveUseLicense(ContentUser user, UseLicense useLicense);
    internal void DeleteUseLicense(ContentUser user);
    internal IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
    public sealed virtual bool get_IsReady();
    public sealed virtual bool get_FixedSettings();
    internal int get_TransformIdentifierType();
    public sealed virtual object get_TransformIdentifier();
    internal CryptoProvider get_CryptoProvider();
    internal void set_CryptoProvider(CryptoProvider value);
    internal static string get_ClassTransformIdentifier();
    private sealed virtual override Stream System.IO.Packaging.IDataTransform.GetTransformedStream(Stream encodedStream, IDictionary transformContext);
    internal void EnumUseLicenseStreams(UseLicenseStreamCallback callback, object param);
    internal UseLicense LoadUseLicenseAndUserFromStream(BinaryReader utf8Reader, ContentUser& user);
    internal void SaveUseLicenseForUser(ContentUser user, UseLicense useLicense);
}
internal static class MS.Internal.IO.Packaging.CompoundFile.SafeNativeCompoundFileConstants : object {
    internal static int STGM_READ;
    internal static int STGM_WRITE;
    internal static int STGM_READWRITE;
    internal static int STGM_READWRITE_Bits;
    internal static int STGM_SHARE_DENY_NONE;
    internal static int STGM_SHARE_DENY_READ;
    internal static int STGM_SHARE_DENY_WRITE;
    internal static int STGM_SHARE_EXCLUSIVE;
    internal static int STGM_PRIORITY;
    internal static int STGM_CREATE;
    internal static int STGM_CONVERT;
    internal static int STGM_FAILIFTHERE;
    internal static int STGM_DIRECT;
    internal static int STGM_TRANSACTED;
    internal static int STGM_NOSCRATCH;
    internal static int STGM_NOSNAPSHOT;
    internal static int STGM_SIMPLE;
    internal static int STGM_DIRECT_SWMR;
    internal static int STGM_DELETEONRELEASE;
    internal static int STREAM_SEEK_SET;
    internal static int STREAM_SEEK_CUR;
    internal static int STREAM_SEEK_END;
    internal static int STATFLAG_NONAME;
    internal static int STATFLAG_NOOPEN;
    internal static int STGTY_STORAGE;
    internal static int STGTY_STREAM;
    internal static int STGTY_LOCKBYTES;
    internal static int STGTY_PROPERTY;
    internal static UInt32 PROPSETFLAG_ANSI;
    internal static int S_OK;
    internal static int S_FALSE;
    internal static int STG_E_FILENOTFOUND;
    internal static int STG_E_ACCESSDENIED;
    internal static int STG_E_FILEALREADYEXISTS;
    internal static int STG_E_INVALIDNAME;
    internal static int STG_E_INVALIDFLAG;
}
[SecurityCriticalAttribute("1")]
[SecurityTreatAsSafeAttribute]
internal static class MS.Internal.IO.Packaging.CompoundFile.SafeNativeCompoundFileMethods : object {
    internal static void UpdateModeFlagFromFileAccess(FileAccess access, Int32& grfMode);
    internal static int SafeStgCreateDocfileOnStream(Stream s, int grfMode, IStorage& ppstgOpen);
    internal static int SafeStgOpenStorageOnStream(Stream s, int grfMode, IStorage& ppstgOpen);
    internal static int SafeStgCreateStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, IStorage& ppObjectOpen);
    internal static int SafeStgOpenStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, IStorage& ppObjectOpen);
    internal static int SafePropVariantClear(PROPVARIANT& pvar);
}
internal class MS.Internal.IO.Packaging.CompoundFile.StreamWithDictionary : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    internal bool Disposed { get; }
    internal StreamWithDictionary(Stream wrappedStream, IDictionary wrappedDictionary);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object val);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object index);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object index, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool get_Disposed();
}
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.IO.Packaging.CompoundFile.UnsafeNativeCompoundFileMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int StgCreateDocfileOnILockBytes(UnsafeNativeILockBytes plkbyt, int grfMode, int reserved, UnsafeNativeIStorage& ppstgOpen);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int StgOpenStorageOnILockBytes(UnsafeNativeILockBytes plkbyt, UnsafeNativeIStorage pStgPriority, int grfMode, IntPtr snbExclude, int reserved, UnsafeNativeIStorage& ppstgOpen);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int StgCreateStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, UnsafeNativeIStorage& ppObjectOpen);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int StgOpenStorageEx(string pwcsName, int grfMode, int stgfmt, int grfAttrs, IntPtr pStgOptions, IntPtr reserved2, Guid& riid, UnsafeNativeIStorage& ppObjectOpen);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int PropVariantClear(PROPVARIANT& pvar);
}
internal class MS.Internal.IO.Packaging.CompoundFile.UserUseLicenseDictionaryLoader : object {
    internal Dictionary`2<ContentUser, UseLicense> LoadedDictionary { get; }
    internal UserUseLicenseDictionaryLoader(RightsManagementEncryptionTransform rmet);
    internal Dictionary`2<ContentUser, UseLicense> get_LoadedDictionary();
}
internal class MS.Internal.IO.Packaging.CompoundFile.VersionedStream : Stream {
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    protected Stream BaseStream { get; }
    internal VersionedStream(Stream baseStream, VersionedStreamOwner versionOwner);
    protected VersionedStream(Stream baseStream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected Stream get_BaseStream();
    protected virtual void Dispose(bool disposing);
    protected void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.CompoundFile.VersionedStreamOwner : VersionedStream {
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal bool IsUpdatable { get; }
    internal bool IsReadable { get; }
    internal VersionedStreamOwner(Stream baseStream, FormatVersion codeVersion);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    internal bool get_IsUpdatable();
    internal bool get_IsReadable();
    internal void WriteAttempt();
    internal void ReadAttempt();
    internal void ReadAttempt(bool throwIfEmpty);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CompoundFile.VersionPair : object {
    public short Major { get; }
    public short Minor { get; }
    internal VersionPair(short major, short minor);
    public short get_Major();
    public short get_Minor();
    public virtual string ToString();
    public static bool op_Equality(VersionPair v1, VersionPair v2);
    public static bool op_Inequality(VersionPair v1, VersionPair v2);
    public static bool op_LessThan(VersionPair v1, VersionPair v2);
    public static bool op_GreaterThan(VersionPair v1, VersionPair v2);
    public static bool op_LessThanOrEqual(VersionPair v1, VersionPair v2);
    public static bool op_GreaterThanOrEqual(VersionPair v1, VersionPair v2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
}
internal class MS.Internal.IO.Packaging.CompressEmulationStream : Stream {
    protected Stream _baseStream;
    protected Stream _tempStream;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal CompressEmulationStream(Stream baseStream, Stream tempStream, long position, IDeflateTransform transformer);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    protected void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.CompressStream : Stream {
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal bool IsDisposed { get; }
    internal CompressStream(Stream baseStream, long length);
    internal CompressStream(Stream baseStream, long length, bool creating);
    private static CompressStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    internal bool IsDirty(bool closingFlag);
    internal bool get_IsDisposed();
    protected virtual void Dispose(bool disposing);
    internal void Reset();
}
internal class MS.Internal.IO.Packaging.CustomSignedXml : SignedXml {
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.CY : ValueType {
    public UInt32 Lo;
    public int Hi;
}
internal class MS.Internal.IO.Packaging.DeflateEmulationTransform : object {
    public sealed virtual void Decompress(Stream source, Stream sink);
    public sealed virtual void Compress(Stream source, Stream sink);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.FormatId : object {
    internal static Guid SummaryInformation;
    internal static Guid DocumentSummaryInformation;
    private static FormatId();
}
internal interface MS.Internal.IO.Packaging.IDeflateTransform {
    public abstract virtual void Decompress(Stream source, Stream sink);
    public abstract virtual void Compress(Stream source, Stream sink);
}
internal class MS.Internal.IO.Packaging.IgnoreFlushAndCloseStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal IgnoreFlushAndCloseStream(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.InterleavedZipPartStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal InterleavedZipPartStream(ZipPackagePart owningPart, FileMode mode, FileAccess access);
    internal InterleavedZipPartStream(string partName, List`1<PieceInfo> sortedPieceInfoList, FileMode mode, FileAccess access);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.InternalRelationshipCollection : object {
    internal InternalRelationshipCollection(PackagePart part);
    internal InternalRelationshipCollection(Package package);
    private static InternalRelationshipCollection();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<PackageRelationship> System.Collections.Generic.IEnumerable<System.IO.Packaging.PackageRelationship>.GetEnumerator();
    public Enumerator<PackageRelationship> GetEnumerator();
    internal PackageRelationship Add(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    internal PackageRelationship GetRelationship(string id);
    internal void Delete(string id);
    internal void Clear();
    internal void Flush();
    internal void CloseInStreamingCreationMode();
    internal static void ThrowIfInvalidRelationshipType(string relationshipType);
    internal static void ThrowIfInvalidXsdId(string id);
    internal static void WriteRelationshipsAsXml(XmlWriter writer, IEnumerable`1<PackageRelationship> relationships, bool alwaysWriteTargetModeAttribute, bool inStreamingProduction);
}
internal interface MS.Internal.IO.Packaging.ITrackingMemoryStreamFactory {
    public abstract virtual MemoryStream Create();
    public abstract virtual MemoryStream Create(int capacity);
    public abstract virtual void ReportMemoryUsageDelta(int delta);
}
internal class MS.Internal.IO.Packaging.MemoryStreamBlock : object {
    internal MemoryStream Stream { get; }
    internal long Offset { get; internal set; }
    internal long EndOffset { get; }
    internal MemoryStreamBlock(MemoryStream stream, long offset);
    internal MemoryStream get_Stream();
    internal long get_Offset();
    internal void set_Offset(long value);
    internal long get_EndOffset();
    private sealed virtual override int System.IComparable<MS.Internal.IO.Packaging.MemoryStreamBlock>.CompareTo(MemoryStreamBlock other);
}
internal enum MS.Internal.IO.Packaging.PackageXmlEnum : Enum {
    public int value__;
    public static PackageXmlEnum NotDefined;
    public static PackageXmlEnum XmlSchemaInstanceNamespace;
    public static PackageXmlEnum XmlSchemaInstanceNamespacePrefix;
    public static PackageXmlEnum XmlNamespacePrefix;
    public static PackageXmlEnum PackageCorePropertiesNamespace;
    public static PackageXmlEnum DublinCorePropertiesNamespace;
    public static PackageXmlEnum DublinCoreTermsNamespace;
    public static PackageXmlEnum DublinCorePropertiesNamespacePrefix;
    public static PackageXmlEnum DublincCoreTermsNamespacePrefix;
    public static PackageXmlEnum CoreProperties;
    public static PackageXmlEnum Type;
    public static PackageXmlEnum Creator;
    public static PackageXmlEnum Identifier;
    public static PackageXmlEnum Title;
    public static PackageXmlEnum Subject;
    public static PackageXmlEnum Description;
    public static PackageXmlEnum Language;
    public static PackageXmlEnum Created;
    public static PackageXmlEnum Modified;
    public static PackageXmlEnum ContentType;
    public static PackageXmlEnum Keywords;
    public static PackageXmlEnum Category;
    public static PackageXmlEnum Version;
    public static PackageXmlEnum LastModifiedBy;
    public static PackageXmlEnum ContentStatus;
    public static PackageXmlEnum Revision;
    public static PackageXmlEnum LastPrinted;
}
internal static class MS.Internal.IO.Packaging.PackageXmlStringTable : object {
    internal static NameTable NameTable { get; }
    private static PackageXmlStringTable();
    internal static PackageXmlEnum GetEnumOf(object xmlString);
    internal static string GetXmlString(PackageXmlEnum id);
    internal static object GetXmlStringAsObject(PackageXmlEnum id);
    internal static PackageXmlEnum GetXmlNamespace(PackageXmlEnum id);
    internal static string GetValueType(PackageXmlEnum id);
    internal static NameTable get_NameTable();
    internal static NameTable CloneNameTable();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PackagingUtilities : object {
    internal static string RelationshipNamespaceUri;
    internal static ContentType RelationshipPartContentType;
    internal static string ContainerFileExtension;
    internal static string XamlFileExtension;
    internal static object IsoStoreSyncRoot { get; }
    internal static object IsolatedStorageFileLock { get; }
    private static PackagingUtilities();
    internal static void PerformInitailReadAndVerifyEncoding(XmlTextReader reader);
    internal static void VerifyStreamReadArgs(Stream s, Byte[] buffer, int offset, int count);
    internal static void VerifyStreamWriteArgs(Stream s, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(Stream stream, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(Stream stream, Byte[] buffer, int offset, int requestedCount, int requiredCount);
    internal static int ReliableRead(BinaryReader reader, Byte[] buffer, int offset, int count);
    internal static int ReliableRead(BinaryReader reader, Byte[] buffer, int offset, int requestedCount, int requiredCount);
    internal static long CopyStream(Stream sourceStream, Stream targetStream, long bytesToCopy, int bufferSize);
    internal static Stream CreateUserScopedIsolatedStorageFileStreamWithRandomName(int retryCount, String& fileName);
    internal static void CalculateOverlap(long block1Offset, long block1Size, long block2Offset, long block2Size, Int64& overlapBlockOffset, Int64& overlapBlockSize);
    internal static int GetNonXmlnsAttributeCount(XmlReader reader);
    internal static object get_IsoStoreSyncRoot();
    internal static object get_IsolatedStorageFileLock();
}
internal class MS.Internal.IO.Packaging.PartBasedPackageProperties : PackageProperties {
    public string Creator { get; public set; }
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Category { get; public set; }
    public string Keywords { get; public set; }
    public string Description { get; public set; }
    public string ContentType { get; public set; }
    public string ContentStatus { get; public set; }
    public string Version { get; public set; }
    public string Revision { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string LastModifiedBy { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public string Language { get; public set; }
    public string Identifier { get; public set; }
    internal PartBasedPackageProperties(Package package);
    private static PartBasedPackageProperties();
    public virtual string get_Creator();
    public virtual void set_Creator(string value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual string get_Category();
    public virtual void set_Category(string value);
    public virtual string get_Keywords();
    public virtual void set_Keywords(string value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual string get_ContentStatus();
    public virtual void set_ContentStatus(string value);
    public virtual string get_Version();
    public virtual void set_Version(string value);
    public virtual string get_Revision();
    public virtual void set_Revision(string value);
    public virtual Nullable`1<DateTime> get_Created();
    public virtual void set_Created(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Modified();
    public virtual void set_Modified(Nullable`1<DateTime> value);
    public virtual string get_LastModifiedBy();
    public virtual void set_LastModifiedBy(string value);
    public virtual Nullable`1<DateTime> get_LastPrinted();
    public virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public virtual string get_Language();
    public virtual void set_Language(string value);
    public virtual string get_Identifier();
    public virtual void set_Identifier(string value);
    internal void Flush();
    internal void Close();
    internal static void ValidateXsiType(XmlTextReader reader, object ns, string name);
}
internal class MS.Internal.IO.Packaging.PartManifestEntry : ValueType {
    private Uri _owningPartUri;
    private Uri _uri;
    private ContentType _contentType;
    private string _hashAlgorithm;
    private string _hashValue;
    private List`1<string> _transforms;
    private List`1<PackageRelationshipSelector> _relationshipSelectors;
    internal bool IsRelationshipEntry { get; }
    internal Uri Uri { get; }
    internal ContentType ContentType { get; }
    internal string HashAlgorithm { get; }
    internal string HashValue { get; }
    internal List`1<string> Transforms { get; }
    internal List`1<PackageRelationshipSelector> RelationshipSelectors { get; }
    internal Uri OwningPartUri { get; }
    internal PartManifestEntry(Uri uri, ContentType contentType, string hashAlgorithm, string hashValue, List`1<string> transforms, List`1<PackageRelationshipSelector> relationshipSelectors);
    internal bool get_IsRelationshipEntry();
    internal Uri get_Uri();
    internal ContentType get_ContentType();
    internal string get_HashAlgorithm();
    internal string get_HashValue();
    internal List`1<string> get_Transforms();
    internal List`1<PackageRelationshipSelector> get_RelationshipSelectors();
    internal Uri get_OwningPartUri();
}
internal class MS.Internal.IO.Packaging.PieceInfo : object {
    internal string NormalizedPrefixName { get; }
    internal string PrefixName { get; }
    internal int PieceNumber { get; }
    internal bool IsLastPiece { get; }
    internal ValidatedPartUri PartUri { get; }
    internal ZipFileInfo ZipFileInfo { get; }
    internal PieceInfo(ZipFileInfo zipFileInfo, ValidatedPartUri partUri, string prefixName, int pieceNumber, bool isLastPiece);
    internal string get_NormalizedPrefixName();
    internal string get_PrefixName();
    internal int get_PieceNumber();
    internal bool get_IsLastPiece();
    internal ValidatedPartUri get_PartUri();
    internal ZipFileInfo get_ZipFileInfo();
}
internal class MS.Internal.IO.Packaging.PieceNameComparer : object {
    private sealed virtual override int System.Collections.Generic.IComparer<MS.Internal.IO.Packaging.PieceInfo>.Compare(PieceInfo pieceInfoA, PieceInfo pieceInfoB);
}
internal static class MS.Internal.IO.Packaging.PieceNameHelper : object {
    internal static PieceNameComparer PieceNameComparer { get; }
    private static PieceNameHelper();
    internal static PieceNameComparer get_PieceNameComparer();
    internal static string CreatePieceName(string partName, int pieceNumber, bool isLastPiece);
    internal static bool TryCreatePieceInfo(ZipFileInfo zipFileInfo, PieceInfo& pieceInfo);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PropertyId : object {
    internal static UInt32 Title;
    internal static UInt32 Subject;
    internal static UInt32 Creator;
    internal static UInt32 Keywords;
    internal static UInt32 Description;
    internal static UInt32 LastModifiedBy;
    internal static UInt32 Revision;
    internal static UInt32 LastPrinted;
    internal static UInt32 DateCreated;
    internal static UInt32 DateModified;
    internal static UInt32 Category;
    internal static UInt32 Identifier;
    internal static UInt32 ContentType;
    internal static UInt32 Language;
    internal static UInt32 Version;
    internal static UInt32 ContentStatus;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPSPEC : ValueType {
    internal UInt32 propType;
    internal PROPSPECunion union;
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.IO.Packaging.PropSpecType : Enum {
    public int value__;
    public static PropSpecType Name;
    public static PropSpecType Id;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPSPECunion : ValueType {
    internal IntPtr name;
    internal UInt32 propId;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PROPVARIANT : ValueType {
    internal VARTYPE vt;
    internal ushort wReserved1;
    internal ushort wReserved2;
    internal ushort wReserved3;
    internal PropVariantUnion union;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.PropVariantUnion : ValueType {
    internal sbyte cVal;
    internal byte bVal;
    internal short iVal;
    internal ushort uiVal;
    internal int lVal;
    internal UInt32 ulVal;
    internal int intVal;
    internal UInt32 uintVal;
    internal long hVal;
    internal ulong uhVal;
    internal float fltVal;
    internal double dblVal;
    internal short boolVal;
    internal int scode;
    internal CY cyVal;
    internal double date;
    internal FILETIME filetime;
    internal IntPtr puuid;
    internal IntPtr pclipdata;
    internal IntPtr bstrVal;
    internal BSTRBLOB bstrblobVal;
    internal BLOB blob;
    internal IntPtr pszVal;
    internal IntPtr pwszVal;
    internal IntPtr punkVal;
    internal IntPtr pdispVal;
    internal IntPtr pStream;
    internal IntPtr pStorage;
    internal IntPtr pVersionedStream;
    internal IntPtr parray;
    internal CArray cArray;
    internal IntPtr pcVal;
    internal IntPtr pbVal;
    internal IntPtr piVal;
    internal IntPtr puiVal;
    internal IntPtr plVal;
    internal IntPtr pulVal;
    internal IntPtr pintVal;
    internal IntPtr puintVal;
    internal IntPtr pfltVal;
    internal IntPtr pdblVal;
    internal IntPtr pboolVal;
    internal IntPtr pdecVal;
    internal IntPtr pscode;
    internal IntPtr pcyVal;
    internal IntPtr pdate;
    internal IntPtr pbstrVal;
    internal IntPtr ppunkVal;
    internal IntPtr ppdispVal;
    internal IntPtr pparray;
    internal IntPtr pvarVal;
}
internal class MS.Internal.IO.Packaging.SparseMemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal List`1<MemoryStreamBlock> MemoryBlockCollection { get; }
    internal long MemoryConsumption { get; }
    internal SparseMemoryStream(long lowWaterMark, long highWaterMark);
    internal SparseMemoryStream(long lowWaterMark, long highWaterMark, bool autoCloseSmallBlockGaps);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    internal void WriteToStream(Stream stream);
    protected virtual void Dispose(bool disposing);
    internal List`1<MemoryStreamBlock> get_MemoryBlockCollection();
    internal long get_MemoryConsumption();
}
internal class MS.Internal.IO.Packaging.STATPROPSETSTG : ValueType {
    private Guid fmtid;
    private Guid clsid;
    private UInt32 grfFlags;
    private FILETIME mtime;
    private FILETIME ctime;
    private FILETIME atime;
    private UInt32 dwOSVersion;
}
internal class MS.Internal.IO.Packaging.STATPROPSTG : ValueType {
    private string lpwstrName;
    private UInt32 propid;
    private VARTYPE vt;
}
internal class MS.Internal.IO.Packaging.StorageBasedPackageProperties : PackageProperties {
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Creator { get; public set; }
    public string Keywords { get; public set; }
    public string Description { get; public set; }
    public string LastModifiedBy { get; public set; }
    public string Revision { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string Category { get; public set; }
    public string Identifier { get; public set; }
    public string ContentType { get; public set; }
    public string Language { get; public set; }
    public string Version { get; public set; }
    public string ContentStatus { get; public set; }
    internal StorageBasedPackageProperties(StorageRoot root);
    protected virtual override void Finalize();
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual string get_Creator();
    public virtual void set_Creator(string value);
    public virtual string get_Keywords();
    public virtual void set_Keywords(string value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    public virtual string get_LastModifiedBy();
    public virtual void set_LastModifiedBy(string value);
    public virtual string get_Revision();
    public virtual void set_Revision(string value);
    public virtual Nullable`1<DateTime> get_LastPrinted();
    public virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Created();
    public virtual void set_Created(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Modified();
    public virtual void set_Modified(Nullable`1<DateTime> value);
    public virtual string get_Category();
    public virtual void set_Category(string value);
    public virtual string get_Identifier();
    public virtual void set_Identifier(string value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual string get_Language();
    public virtual void set_Language(string value);
    public virtual string get_Version();
    public virtual void set_Version(string value);
    public virtual string get_ContentStatus();
    public virtual void set_ContentStatus(string value);
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.StreamingZipPartStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal StreamingZipPartStream(string partName, ZipArchive zipArchive, CompressionMethodEnum compressionMethod, DeflateOptionEnum deflateOption, FileMode mode, FileAccess access);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.TrackingMemoryStream : MemoryStream {
    internal TrackingMemoryStream(ITrackingMemoryStreamFactory memoryStreamFactory);
    internal TrackingMemoryStream(ITrackingMemoryStreamFactory memoryStreamFactory, int capacity);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.TrackingMemoryStreamFactory : object {
    internal long CurrentMemoryConsumption { get; }
    public sealed virtual MemoryStream Create();
    public sealed virtual MemoryStream Create(int capacity);
    public sealed virtual void ReportMemoryUsageDelta(int delta);
    internal long get_CurrentMemoryConsumption();
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.IO.Packaging.VARTYPE : Enum {
    public short value__;
    public static VARTYPE VT_BSTR;
    public static VARTYPE VT_LPSTR;
    public static VARTYPE VT_FILETIME;
}
internal class MS.Internal.IO.Packaging.XmlDigitalSignatureProcessor : object {
    internal static ContentType ContentType { get; }
    internal PackagePart SignaturePart { get; }
    internal List`1<Uri> PartManifest { get; }
    internal List`1<PackageRelationshipSelector> RelationshipManifest { get; }
    internal X509Certificate2 Signer { get; }
    internal Byte[] SignatureValue { get; }
    internal Signature Signature { get; internal set; }
    internal PackageDigitalSignature PackageSignature { get; }
    internal DateTime SigningTime { get; }
    internal string TimeFormat { get; }
    internal XmlDigitalSignatureProcessor(PackageDigitalSignatureManager manager, PackagePart signaturePart, PackageDigitalSignature packageSignature);
    private static XmlDigitalSignatureProcessor();
    internal static PackageDigitalSignature Sign(PackageDigitalSignatureManager manager, PackagePart signaturePart, IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, X509Certificate2 signer, string signatureId, bool embedCertificate, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    internal bool Verify();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool Verify(X509Certificate2 signer);
    internal List`1<string> GetPartTransformList(Uri partName);
    internal static ContentType get_ContentType();
    internal PackagePart get_SignaturePart();
    internal List`1<Uri> get_PartManifest();
    internal List`1<PackageRelationshipSelector> get_RelationshipManifest();
    internal X509Certificate2 get_Signer();
    internal Byte[] get_SignatureValue();
    internal Signature get_Signature();
    internal void set_Signature(Signature value);
    internal PackageDigitalSignature get_PackageSignature();
    internal DateTime get_SigningTime();
    internal string get_TimeFormat();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static string GenerateDigestValue(Stream s, string transformName, HashAlgorithm hashAlgorithm);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static string GenerateDigestValue(Stream s, List`1<string> transforms, HashAlgorithm hashAlgorithm);
    internal static Stream GenerateRelationshipNodeStream(IEnumerable`1<PackageRelationship> relationships);
    internal static HashAlgorithm GetHashAlgorithm(string hashAlgorithmName);
    internal static bool IsValidXmlCanonicalizationTransform(string transformName);
}
internal static class MS.Internal.IO.Packaging.XmlSignatureManifest : object {
    internal static void ParseManifest(PackageDigitalSignatureManager manager, XmlReader reader, List`1& partManifest, List`1& partEntryManifest, List`1& relationshipManifest);
    internal static XmlNode GenerateManifest(PackageDigitalSignatureManager manager, XmlDocument xDoc, HashAlgorithm hashAlgorithm, IEnumerable`1<Uri> parts, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
}
internal static class MS.Internal.IO.Packaging.XmlSignatureProperties : object {
    internal static string DefaultDateTimeFormat { get; }
    private static XmlSignatureProperties();
    internal static string get_DefaultDateTimeFormat();
    internal static bool LegalFormat(string candidateFormat);
    internal static XmlElement AssembleSignatureProperties(XmlDocument xDoc, DateTime dateTime, string xmlDateTimeFormat, string signatureId);
    internal static DateTime ParseSigningTime(XmlReader reader, string signatureId, String& timeFormat);
}
internal static class MS.Internal.IO.Packaging.XTable : object {
    private static XTable();
    internal static string Get(ID i);
}
internal enum MS.Internal.IO.Zip.CompressionMethodEnum : Enum {
    public ushort value__;
    public static CompressionMethodEnum Stored;
    public static CompressionMethodEnum Deflated;
}
internal class MS.Internal.IO.Zip.Crc32Calculator : object {
    internal UInt32 Crc { get; }
    private static Crc32Calculator();
    internal UInt32 CalculateStreamCrc(Stream stream);
    internal void Accumulate(Byte[] buffer, int offset, int count);
    internal UInt32 get_Crc();
    internal void ClearCrc();
}
internal enum MS.Internal.IO.Zip.DeflateOptionEnum : Enum {
    public byte value__;
    public static DeflateOptionEnum Normal;
    public static DeflateOptionEnum Maximum;
    public static DeflateOptionEnum Fast;
    public static DeflateOptionEnum SuperFast;
    public static DeflateOptionEnum None;
}
internal interface MS.Internal.IO.Zip.IZipIOBlock {
    public long Offset { get; }
    public long Size { get; }
    public abstract virtual long get_Offset();
    public abstract virtual long get_Size();
    public abstract virtual bool GetDirtyFlag(bool closingFlag);
    public abstract virtual void Move(long shiftSize);
    public abstract virtual void Save();
    public abstract virtual void UpdateReferences(bool closingFlag);
    public abstract virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
}
internal enum MS.Internal.IO.Zip.PreSaveNotificationScanControlInstruction : Enum {
    public int value__;
    public static PreSaveNotificationScanControlInstruction Continue;
    public static PreSaveNotificationScanControlInstruction Stop;
}
internal class MS.Internal.IO.Zip.ProgressiveCrcCalculatingStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ProgressiveCrcCalculatingStream(ZipIOBlockManager blockManager, Stream underlyingStream);
    internal ProgressiveCrcCalculatingStream(ZipIOBlockManager blockManager, Stream underlyingStream, UInt32 expectedCrc);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    internal UInt32 CalculateCrc();
}
internal class MS.Internal.IO.Zip.WriteTimeStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal WriteTimeStream(Stream baseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Zip.ZipArchive : object {
    internal FileAccess OpenAccess { get; }
    private static ZipArchive();
    internal static ZipArchive OpenOnFile(string path, FileMode mode, FileAccess access, FileShare share, bool streaming);
    internal static ZipArchive OpenOnStream(Stream stream, FileMode mode, FileAccess access, bool streaming);
    internal ZipFileInfo AddFile(string zipFileName, CompressionMethodEnum compressionMethod, DeflateOptionEnum deflateOption);
    internal ZipFileInfo GetFile(string zipFileName);
    internal bool FileExists(string zipFileName);
    internal void DeleteFile(string zipFileName);
    internal ZipFileInfoCollection GetFiles();
    internal void Flush();
    internal void Close();
    public sealed virtual void Dispose();
    internal static void VerifyVersionNeededToExtract(ushort version);
    internal FileAccess get_OpenAccess();
}
internal class MS.Internal.IO.Zip.ZipFileInfo : object {
    internal string Name { get; }
    internal ZipArchive ZipArchive { get; }
    internal CompressionMethodEnum CompressionMethod { get; }
    internal DateTime LastModFileDateTime { get; }
    internal DeflateOptionEnum DeflateOption { get; }
    internal bool FolderFlag { get; }
    internal bool VolumeLabelFlag { get; }
    internal ZipIOLocalFileBlock LocalFileBlock { get; }
    internal ZipFileInfo(ZipArchive zipArchive, ZipIOLocalFileBlock fileBlock);
    internal Stream GetStream(FileMode mode, FileAccess access);
    internal string get_Name();
    internal ZipArchive get_ZipArchive();
    internal CompressionMethodEnum get_CompressionMethod();
    internal DateTime get_LastModFileDateTime();
    internal DeflateOptionEnum get_DeflateOption();
    internal bool get_FolderFlag();
    internal bool get_VolumeLabelFlag();
    internal ZipIOLocalFileBlock get_LocalFileBlock();
}
internal class MS.Internal.IO.Zip.ZipFileInfoCollection : object {
    internal ZipFileInfoCollection(ICollection zipFileInfoCollection);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.IO.Zip.ZipIOBlockManager : object {
    internal bool IsCentralDirectoryBlockLoaded { get; }
    internal ZipIOCentralDirectoryBlock CentralDirectoryBlock { get; }
    internal ZipIOZip64EndOfCentralDirectoryBlock Zip64EndOfCentralDirectoryBlock { get; }
    internal ZipIOZip64EndOfCentralDirectoryLocatorBlock Zip64EndOfCentralDirectoryLocatorBlock { get; }
    internal ZipIOEndOfCentralDirectoryBlock EndOfCentralDirectoryBlock { get; }
    internal Stream Stream { get; }
    internal bool Streaming { get; }
    internal BinaryReader BinaryReader { get; }
    internal BinaryWriter BinaryWriter { get; }
    internal Encoding Encoding { get; }
    internal bool DirtyFlag { get; internal set; }
    internal static int MaxFileNameSize { get; }
    internal ZipIOBlockManager(Stream archiveStream, bool streaming, bool ownStream);
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool get_IsCentralDirectoryBlockLoaded();
    internal ZipIOCentralDirectoryBlock get_CentralDirectoryBlock();
    internal ZipIOZip64EndOfCentralDirectoryBlock get_Zip64EndOfCentralDirectoryBlock();
    internal ZipIOZip64EndOfCentralDirectoryLocatorBlock get_Zip64EndOfCentralDirectoryLocatorBlock();
    internal ZipIOEndOfCentralDirectoryBlock get_EndOfCentralDirectoryBlock();
    internal Stream get_Stream();
    internal bool get_Streaming();
    internal BinaryReader get_BinaryReader();
    internal BinaryWriter get_BinaryWriter();
    internal Encoding get_Encoding();
    internal void set_DirtyFlag(bool value);
    internal bool get_DirtyFlag();
    internal static int get_MaxFileNameSize();
    internal void CreateEndOfCentralDirectoryBlock();
    internal void LoadEndOfCentralDirectoryBlock();
    internal ZipIOLocalFileBlock CreateLocalFileBlock(string zipFileName, CompressionMethodEnum compressionMethod, DeflateOptionEnum deflateOption);
    internal ZipIOLocalFileBlock LoadLocalFileBlock(string zipFileName);
    internal void RemoveLocalFileBlock(ZipIOLocalFileBlock localFileBlock);
    internal void MoveData(long moveBlockSourceOffset, long moveBlockTargetOffset, long moveBlockSize);
    internal void SaveStream(ZipIOLocalFileBlock blockRequestingFlush, bool closingFlag);
    internal void Save(bool closingFlag);
    internal static UInt32 ToMsDosDateTime(DateTime dateTime);
    internal static DateTime FromMsDosDateTime(UInt32 dosDateTime);
    internal static string ValidateNormalizeFileName(string zipFileName);
    internal static int CopyBytes(short value, Byte[] buffer, int offset);
    internal static int CopyBytes(int value, Byte[] buffer, int offset);
    internal static int CopyBytes(long value, Byte[] buffer, int offset);
    internal static int CopyBytes(ushort value, Byte[] buffer, int offset);
    internal static int CopyBytes(UInt32 value, Byte[] buffer, int offset);
    internal static int CopyBytes(ulong value, Byte[] buffer, int offset);
    internal static ulong ConvertToUInt64(UInt32 loverAddressValue, UInt32 higherAddressValue);
    internal static ZipIOVersionNeededToExtract CalcVersionNeededToExtractFromCompression(CompressionMethodEnum compression);
    internal static PreSaveNotificationScanControlInstruction CommonPreSaveNotificationHandler(Stream stream, long offset, long size, long onDiskOffset, long onDiskSize, SparseMemoryStream& cachePrefixStream);
    protected void Dispose(bool disposing);
}
internal class MS.Internal.IO.Zip.ZipIOCentralDirectoryBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal int Count { get; }
    internal bool IsZip64BitRequiredForStoring { get; }
    private static ZipIOCentralDirectoryBlock();
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal int get_Count();
    internal static ZipIOCentralDirectoryBlock SeekableLoad(ZipIOBlockManager blockManager);
    internal static ZipIOCentralDirectoryBlock CreateNew(ZipIOBlockManager blockManager);
    internal bool get_IsZip64BitRequiredForStoring();
    internal void AddFileBlock(ZipIOLocalFileBlock fileBlock);
    internal void RemoveFileBlock(string fileName);
    internal bool FileExists(string fileName);
    internal ZipIOCentralDirectoryFileHeader GetCentralDirectoryFileHeader(string fileName);
    internal ICollection GetFileNamesCollection();
}
internal class MS.Internal.IO.Zip.ZipIOCentralDirectoryDigitalSignature : object {
    internal static ZipIOCentralDirectoryDigitalSignature ParseRecord(BinaryReader reader);
}
internal class MS.Internal.IO.Zip.ZipIOCentralDirectoryFileHeader : object {
    internal string FileName { get; }
    internal ushort VersionNeededToExtract { get; }
    internal ushort GeneralPurposeBitFlag { get; }
    internal CompressionMethodEnum CompressionMethod { get; }
    internal long Size { get; }
    internal long OffsetOfLocalHeader { get; }
    internal long CompressedSize { get; }
    internal long UncompressedSize { get; }
    internal UInt32 Crc32 { get; }
    internal UInt32 DiskNumberStart { get; }
    internal bool FolderFlag { get; }
    internal bool VolumeLabelFlag { get; }
    internal static ZipIOCentralDirectoryFileHeader CreateNew(Encoding encoding, ZipIOLocalFileBlock fileBlock);
    internal static ZipIOCentralDirectoryFileHeader ParseRecord(BinaryReader reader, Encoding encoding);
    internal void Save(BinaryWriter writer);
    internal bool UpdateIfNeeded(ZipIOLocalFileBlock fileBlock);
    internal string get_FileName();
    internal ushort get_VersionNeededToExtract();
    internal ushort get_GeneralPurposeBitFlag();
    internal CompressionMethodEnum get_CompressionMethod();
    internal long get_Size();
    internal long get_OffsetOfLocalHeader();
    internal long get_CompressedSize();
    internal long get_UncompressedSize();
    internal UInt32 get_Crc32();
    internal UInt32 get_DiskNumberStart();
    internal bool get_FolderFlag();
    internal bool get_VolumeLabelFlag();
    internal void MoveReference(long shiftSize);
}
internal class MS.Internal.IO.Zip.ZipIOEndOfCentralDirectoryBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal UInt32 NumberOfThisDisk { get; }
    internal UInt32 NumberOfTheDiskWithTheStartOfTheCentralDirectory { get; }
    internal UInt32 TotalNumberOfEntriesInTheCentralDirectoryOnThisDisk { get; }
    internal UInt32 TotalNumberOfEntriesInTheCentralDirectory { get; }
    internal UInt32 SizeOfTheCentralDirectory { get; }
    internal UInt32 OffsetOfStartOfCentralDirectory { get; }
    internal bool ContainValuesHintingToPossibilityOfZip64 { get; }
    private static ZipIOEndOfCentralDirectoryBlock();
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal static ZipIOEndOfCentralDirectoryBlock SeekableLoad(ZipIOBlockManager blockManager);
    internal static ZipIOEndOfCentralDirectoryBlock CreateNew(ZipIOBlockManager blockManager, long offset);
    internal void ValidateZip64TriggerValues();
    internal UInt32 get_NumberOfThisDisk();
    internal UInt32 get_NumberOfTheDiskWithTheStartOfTheCentralDirectory();
    internal UInt32 get_TotalNumberOfEntriesInTheCentralDirectoryOnThisDisk();
    internal UInt32 get_TotalNumberOfEntriesInTheCentralDirectory();
    internal UInt32 get_SizeOfTheCentralDirectory();
    internal UInt32 get_OffsetOfStartOfCentralDirectory();
    internal bool get_ContainValuesHintingToPossibilityOfZip64();
}
internal class MS.Internal.IO.Zip.ZipIOExtraField : object {
    internal ushort Size { get; }
    internal ZipIOZip64ExtraFieldUsage Zip64ExtraFieldUsage { get; internal set; }
    internal UInt32 DiskNumberOfFileStart { get; }
    internal long OffsetOfLocalHeader { get; internal set; }
    internal long CompressedSize { get; internal set; }
    internal long UncompressedSize { get; internal set; }
    internal static ZipIOExtraField CreateNew(bool createPadding);
    internal static ZipIOExtraField ParseRecord(BinaryReader reader, ZipIOZip64ExtraFieldUsage zip64extraFieldUsage, ushort expectedExtraFieldSize);
    internal void Save(BinaryWriter writer);
    internal void UpdatePadding(long size);
    internal ushort get_Size();
    internal ZipIOZip64ExtraFieldUsage get_Zip64ExtraFieldUsage();
    internal void set_Zip64ExtraFieldUsage(ZipIOZip64ExtraFieldUsage value);
    internal UInt32 get_DiskNumberOfFileStart();
    internal long get_OffsetOfLocalHeader();
    internal void set_OffsetOfLocalHeader(long value);
    internal long get_CompressedSize();
    internal void set_CompressedSize(long value);
    internal long get_UncompressedSize();
    internal void set_UncompressedSize(long value);
}
internal class MS.Internal.IO.Zip.ZipIOExtraFieldElement : object {
    internal ushort SizeField { get; }
    internal Byte[] DataField { get; }
    internal ushort Size { get; }
    internal static ushort MinimumSize { get; }
    internal ZipIOExtraFieldElement(ushort id);
    private static ZipIOExtraFieldElement();
    internal static ZipIOExtraFieldElement Parse(BinaryReader reader, ZipIOZip64ExtraFieldUsage zip64extraFieldUsage);
    internal virtual void ParseDataField(BinaryReader reader, ushort size);
    internal virtual void Save(BinaryWriter writer);
    internal virtual ushort get_SizeField();
    internal virtual Byte[] get_DataField();
    internal virtual ushort get_Size();
    internal static ushort get_MinimumSize();
}
internal class MS.Internal.IO.Zip.ZipIOExtraFieldPaddingElement : ZipIOExtraFieldElement {
    internal ushort Size { get; }
    internal ushort SizeField { get; }
    internal static ushort ConstantFieldId { get; }
    internal static ushort MinimumFieldDataSize { get; }
    internal static ushort SignatureSize { get; }
    internal ushort PaddingSize { get; internal set; }
    private static ZipIOExtraFieldPaddingElement();
    internal static ZipIOExtraFieldPaddingElement CreateNew();
    internal virtual void ParseDataField(BinaryReader reader, ushort size);
    internal static bool MatchesPaddingSignature(Byte[] sniffiedBytes);
    internal virtual void Save(BinaryWriter writer);
    internal virtual ushort get_Size();
    internal virtual ushort get_SizeField();
    internal static ushort get_ConstantFieldId();
    internal static ushort get_MinimumFieldDataSize();
    internal static ushort get_SignatureSize();
    internal ushort get_PaddingSize();
    internal void set_PaddingSize(ushort value);
}
internal class MS.Internal.IO.Zip.ZipIOExtraFieldZip64Element : ZipIOExtraFieldElement {
    internal ushort Size { get; }
    internal ushort SizeField { get; }
    internal static ushort ConstantFieldId { get; }
    internal long UncompressedSize { get; internal set; }
    internal long CompressedSize { get; internal set; }
    internal long OffsetOfLocalHeader { get; internal set; }
    internal UInt32 DiskNumber { get; }
    internal ZipIOZip64ExtraFieldUsage Zip64ExtraFieldUsage { get; internal set; }
    internal static ZipIOExtraFieldZip64Element CreateNew();
    internal virtual void ParseDataField(BinaryReader reader, ushort size);
    internal virtual void Save(BinaryWriter writer);
    internal virtual ushort get_Size();
    internal virtual ushort get_SizeField();
    internal static ushort get_ConstantFieldId();
    internal long get_UncompressedSize();
    internal void set_UncompressedSize(long value);
    internal long get_CompressedSize();
    internal void set_CompressedSize(long value);
    internal long get_OffsetOfLocalHeader();
    internal void set_OffsetOfLocalHeader(long value);
    internal UInt32 get_DiskNumber();
    internal ZipIOZip64ExtraFieldUsage get_Zip64ExtraFieldUsage();
    internal void set_Zip64ExtraFieldUsage(ZipIOZip64ExtraFieldUsage value);
}
internal class MS.Internal.IO.Zip.ZipIOFileItemStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool DirtyFlag { get; }
    internal bool DataChanged { get; }
    internal long Offset { get; }
    internal ZipIOFileItemStream(ZipIOBlockManager blockManager, ZipIOLocalFileBlock block, long persistedOffset, long persistedSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    internal PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal bool get_DirtyFlag();
    internal bool get_DataChanged();
    internal long get_Offset();
    internal void Move(long shiftSize);
    internal void SaveStreaming();
    internal void Save();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Zip.ZipIOLocalFileBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal ushort VersionNeededToExtract { get; }
    internal ushort GeneralPurposeBitFlag { get; }
    internal CompressionMethodEnum CompressionMethod { get; }
    internal UInt32 LastModFileDateTime { get; }
    internal UInt32 Crc32 { get; }
    internal long CompressedSize { get; }
    internal long UncompressedSize { get; }
    internal DeflateOptionEnum DeflateOption { get; }
    internal string FileName { get; }
    internal bool FolderFlag { get; }
    internal bool VolumeLabelFlag { get; }
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    internal void SaveStreaming(bool closingFlag);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    public sealed virtual void Dispose();
    internal static ZipIOLocalFileBlock SeekableLoad(ZipIOBlockManager blockManager, string fileName);
    internal static ZipIOLocalFileBlock CreateNew(ZipIOBlockManager blockManager, string fileName, CompressionMethodEnum compressionMethod, DeflateOptionEnum deflateOption);
    internal Stream GetStream(FileMode mode, FileAccess access);
    internal void DeregisterExposedStream(Stream exposedStream);
    internal void CheckDisposed();
    internal ushort get_VersionNeededToExtract();
    internal ushort get_GeneralPurposeBitFlag();
    internal CompressionMethodEnum get_CompressionMethod();
    internal UInt32 get_LastModFileDateTime();
    internal UInt32 get_Crc32();
    internal long get_CompressedSize();
    internal long get_UncompressedSize();
    internal DeflateOptionEnum get_DeflateOption();
    internal string get_FileName();
    internal bool get_FolderFlag();
    internal bool get_VolumeLabelFlag();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Zip.ZipIOLocalFileDataDescriptor : object {
    internal long Size { get; }
    internal UInt32 Crc32 { get; internal set; }
    internal long CompressedSize { get; internal set; }
    internal long UncompressedSize { get; internal set; }
    internal static ZipIOLocalFileDataDescriptor CreateNew();
    internal static ZipIOLocalFileDataDescriptor ParseRecord(BinaryReader reader, long compressedSizeFromCentralDir, long uncompressedSizeFromCentralDir, UInt32 crc32FromCentralDir, ushort versionNeededToExtract);
    internal void Save(BinaryWriter writer);
    internal long get_Size();
    internal UInt32 get_Crc32();
    internal void set_Crc32(UInt32 value);
    internal long get_CompressedSize();
    internal void set_CompressedSize(long value);
    internal long get_UncompressedSize();
    internal void set_UncompressedSize(long value);
}
internal class MS.Internal.IO.Zip.ZipIOLocalFileHeader : object {
    internal ushort VersionNeededToExtract { get; }
    internal ushort GeneralPurposeBitFlag { get; }
    internal CompressionMethodEnum CompressionMethod { get; }
    internal UInt32 LastModFileDateTime { get; internal set; }
    internal UInt32 Crc32 { get; internal set; }
    internal long CompressedSize { get; }
    internal long UncompressedSize { get; }
    internal string FileName { get; }
    internal long Size { get; }
    internal bool StreamingCreationFlag { get; internal set; }
    internal DeflateOptionEnum DeflateOption { get; internal set; }
    internal static int FixedMinimalRecordSize { get; }
    internal static ZipIOLocalFileHeader CreateNew(string fileName, Encoding encoding, CompressionMethodEnum compressionMethod, DeflateOptionEnum deflateOption, bool streaming);
    internal static ZipIOLocalFileHeader ParseRecord(BinaryReader reader, Encoding encoding);
    internal void Save(BinaryWriter writer);
    internal ushort get_VersionNeededToExtract();
    internal ushort get_GeneralPurposeBitFlag();
    internal CompressionMethodEnum get_CompressionMethod();
    internal UInt32 get_LastModFileDateTime();
    internal void set_LastModFileDateTime(UInt32 value);
    internal UInt32 get_Crc32();
    internal void set_Crc32(UInt32 value);
    internal long get_CompressedSize();
    internal long get_UncompressedSize();
    internal string get_FileName();
    internal long get_Size();
    internal bool get_StreamingCreationFlag();
    internal void set_StreamingCreationFlag(bool value);
    internal DeflateOptionEnum get_DeflateOption();
    internal void set_DeflateOption(DeflateOptionEnum value);
    internal static int get_FixedMinimalRecordSize();
    internal void UpdateZip64Structures(long compressedSize, long uncompressedSize, long offset);
    internal void UpdatePadding(long headerSizeChange);
}
internal class MS.Internal.IO.Zip.ZipIOModeEnforcingStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Disposed { get; }
    internal ZipIOModeEnforcingStream(Stream baseStream, FileAccess access, ZipIOBlockManager blockManager, ZipIOLocalFileBlock block);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    internal bool get_Disposed();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Zip.ZipIORawDataFileBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal long DiskImageShift { get; }
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal long get_DiskImageShift();
    internal static ZipIORawDataFileBlock Assign(ZipIOBlockManager blockManager, long offset, long size);
    internal bool DiskImageContains(IZipIOBlock block);
    internal bool DiskImageContains(long offset);
    internal void SplitIntoPrefixSuffix(IZipIOBlock block, ZipIORawDataFileBlock& prefixBlock, ZipIORawDataFileBlock& suffixBlock);
}
internal enum MS.Internal.IO.Zip.ZipIOVersionNeededToExtract : Enum {
    public ushort value__;
    public static ZipIOVersionNeededToExtract StoredData;
    public static ZipIOVersionNeededToExtract VolumeLabel;
    public static ZipIOVersionNeededToExtract DeflatedData;
    public static ZipIOVersionNeededToExtract Zip64FileFormat;
}
internal class MS.Internal.IO.Zip.ZipIOZip64EndOfCentralDirectoryBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal long OffsetOfStartOfCentralDirectory { get; }
    internal int TotalNumberOfEntriesInTheCentralDirectory { get; }
    internal long SizeOfCentralDirectory { get; }
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal static ZipIOZip64EndOfCentralDirectoryBlock SeekableLoad(ZipIOBlockManager blockManager);
    internal static ZipIOZip64EndOfCentralDirectoryBlock CreateNew(ZipIOBlockManager blockManager);
    internal long get_OffsetOfStartOfCentralDirectory();
    internal int get_TotalNumberOfEntriesInTheCentralDirectory();
    internal long get_SizeOfCentralDirectory();
}
internal class MS.Internal.IO.Zip.ZipIOZip64EndOfCentralDirectoryLocatorBlock : object {
    public long Offset { get; }
    public long Size { get; }
    internal long OffsetOfZip64EndOfCentralDirectoryRecord { get; }
    public sealed virtual long get_Offset();
    public sealed virtual long get_Size();
    public sealed virtual bool GetDirtyFlag(bool closingFlag);
    public sealed virtual void Move(long shiftSize);
    public sealed virtual void Save();
    public sealed virtual void UpdateReferences(bool closingFlag);
    public sealed virtual PreSaveNotificationScanControlInstruction PreSaveNotification(long offset, long size);
    internal static ZipIOZip64EndOfCentralDirectoryLocatorBlock SeekableLoad(ZipIOBlockManager blockManager);
    internal static ZipIOZip64EndOfCentralDirectoryLocatorBlock CreateNew(ZipIOBlockManager blockManager);
    internal static bool SniffTheBlockSignature(ZipIOBlockManager blockManager);
    internal long get_OffsetOfZip64EndOfCentralDirectoryRecord();
}
internal enum MS.Internal.IO.Zip.ZipIOZip64ExtraFieldUsage : Enum {
    public int value__;
    public static ZipIOZip64ExtraFieldUsage None;
    public static ZipIOZip64ExtraFieldUsage UncompressedSize;
    public static ZipIOZip64ExtraFieldUsage CompressedSize;
    public static ZipIOZip64ExtraFieldUsage OffsetOfLocalHeader;
    public static ZipIOZip64ExtraFieldUsage DiskNumber;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.BooleanBoxes : object {
    internal static object TrueBox;
    internal static object FalseBox;
    private static BooleanBoxes();
    internal static object Box(bool value);
}
[FlagsAttribute]
internal enum MS.Internal.MatrixTypes : Enum {
    public int value__;
    public static MatrixTypes TRANSFORM_IS_IDENTITY;
    public static MatrixTypes TRANSFORM_IS_TRANSLATION;
    public static MatrixTypes TRANSFORM_IS_SCALING;
    public static MatrixTypes TRANSFORM_IS_UNKNOWN;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.MatrixUtil : object {
    internal static void TransformRect(Rect& rect, Matrix& matrix);
    internal static void MultiplyMatrix(Matrix& matrix1, Matrix& matrix2);
    internal static void PrependOffset(Matrix& matrix, double offsetX, double offsetY);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.NamedObject : object {
    public NamedObject(string name);
    public virtual string ToString();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ObservableCollectionDefaultValueFactory`1 : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Permissions.CompoundFileIOPermission : InternalParameterlessPermissionBase {
    public CompoundFileIOPermission(PermissionState state);
    public virtual IPermission Copy();
}
[FriendAccessAllowedAttribute]
internal abstract class MS.Internal.Permissions.InternalParameterlessPermissionBase : CodeAccessPermission {
    protected InternalParameterlessPermissionBase(PermissionState state);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement elem);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Permissions.RightsManagementPermission : InternalParameterlessPermissionBase {
    public RightsManagementPermission(PermissionState state);
    public virtual IPermission Copy();
}
internal class MS.Internal.Permissions.UserInitiatedRoutedEventPermission : InternalParameterlessPermissionBase {
    public UserInitiatedRoutedEventPermission(PermissionState state);
    public virtual IPermission Copy();
}
[AttributeUsageAttribute("64")]
internal class MS.Internal.Permissions.UserInitiatedRoutedEventPermissionAttribute : CodeAccessSecurityAttribute {
    public UserInitiatedRoutedEventPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.PlatformCulture : object {
    public static CultureInfo Value { get; }
    public static CultureInfo get_Value();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.ReaderWriterLockWrapper : object {
    internal IDisposable WriteLock { get; }
    internal IDisposable ReadLock { get; }
    internal IDisposable get_WriteLock();
    internal IDisposable get_ReadLock();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.RegistryKeys : object {
    internal static string WPF;
    internal static string WPF_Features;
    internal static string value_MediaImageDisallow;
    internal static string value_MediaVideoDisallow;
    internal static string value_MediaAudioDisallow;
    internal static string value_WebBrowserDisallow;
    internal static string value_ScriptInteropDisallow;
    internal static string value_AutomationWeakReferenceDisallow;
    internal static string WPF_Hosting;
    internal static string value_DisableXbapErrorPage;
    internal static string value_UnblockWebBrowserControl;
    internal static string HKCU_XpsViewer;
    internal static string value_IsolatedStorageUserQuota;
    internal static string HKLM_XpsViewerLocalServer32;
    internal static string HKLM_IetfLanguage;
    internal static string FRAMEWORK_RegKey;
    internal static string FRAMEWORK_RegKey_FullPath;
    internal static string FRAMEWORK_InstallPath_RegValue;
    [SecurityCriticalAttribute]
internal static bool ReadLocalMachineBool(string key, string valueName);
}
internal static class MS.Internal.ResourceIDHelper : object {
    internal static string GetResourceIDFromRelativePath(string relPath);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Security.AttachmentService : object {
    [SecurityCriticalAttribute]
internal static void SaveWithUI(IntPtr parent, Uri source, Uri target);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.AcquireLicenseFlags : Enum {
    public UInt32 value__;
    public static AcquireLicenseFlags NonSilent;
    public static AcquireLicenseFlags NoPersist;
    public static AcquireLicenseFlags Cancel;
    public static AcquireLicenseFlags FetchAdvisory;
    public static AcquireLicenseFlags NoUI;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.ActivationFlags : Enum {
    public UInt32 value__;
    public static ActivationFlags Machine;
    public static ActivationFlags GroupIdentity;
    public static ActivationFlags Temporary;
    public static ActivationFlags Cancel;
    public static ActivationFlags Silent;
    public static ActivationFlags SharedGroupIdentity;
    public static ActivationFlags Delayed;
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.ActivationServerInfo : object {
    public UInt32 Version;
    internal string PubKey;
    internal string Url;
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.BoundLicenseParams : object {
    internal UInt32 uVersion;
    internal UInt32 hEnablingPrincipal;
    internal UInt32 hSecureStore;
    public string wszRightsRequested;
    public string wszRightsGroup;
    internal UInt32 DRMIDuVersion;
    public string DRMIDIdType;
    public string DRMIDId;
    internal UInt32 cAuthenticatorCount;
    internal IntPtr rghAuthenticators;
    public string wszDefaultEnablingPrincipalCredentials;
    internal UInt32 dwFlags;
}
internal class MS.Internal.Security.RightsManagement.CallbackDelegate : MulticastDelegate {
    public CallbackDelegate(object object, IntPtr method);
    public virtual int Invoke(StatusMessage status, int hr, IntPtr pvParam, IntPtr pvContext);
    public virtual IAsyncResult BeginInvoke(StatusMessage status, int hr, IntPtr pvParam, IntPtr pvContext, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.CallbackHandler : object {
    internal CallbackDelegate CallbackDelegate { get; }
    internal string CallbackData { get; }
    internal CallbackDelegate get_CallbackDelegate();
    internal string get_CallbackData();
    internal void WaitForCompletion();
    public sealed virtual void Dispose();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.ClientSession : object {
    internal ClientSession(ContentUser user);
    internal ClientSession(ContentUser user, UserActivationMode userActivationMode);
    private static ClientSession();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal static ClientSession DefaultUserClientSession(AuthenticationType authentication);
    internal bool IsMachineActivated();
    internal void ActivateMachine(AuthenticationType authentication);
    internal bool IsUserActivated();
    internal ContentUser ActivateUser(AuthenticationType authentication, UserActivationMode userActivationMode);
    internal bool IsClientLicensorCertificatePresent();
    internal void AcquireClientLicensorCertificate();
    internal void BuildSecureEnvironment(string applicationManifest);
    internal string GetMachineCert();
    internal List`1<string> EnumerateUsersCertificateIds(ContentUser user, EnumerateLicenseFlags certificateType);
    internal void DeleteLicense(string licenseId);
    internal void RemoveUsersCertificates(EnumerateLicenseFlags certificateType);
    internal static string GetLicenseOnSession(SafeRightsManagementSessionHandle sessionHandle, EnumerateLicenseFlags enumerateLicenseFlags, int index);
    internal string EnumerateLicense(EnumerateLicenseFlags enumerateLicenseFlags, int index);
    internal PublishLicense SignIssuanceLicense(IssuanceLicense issuanceLicense, UseLicense& authorUseLicense);
    internal UseLicense AcquireUseLicense(string publishLicense, bool noUI);
    internal CryptoProvider TryBindUseLicenseToAllIdentites(string serializedUseLicense);
    internal static string GetOwnerLicense(SafeRightsManagementPubHandle issuanceLicenseHandle);
    internal static ContentUser ExtractUserFromCertificateChain(string certificateChain);
    internal static ContentUser ExtractUserFromCertificate(string certificate);
    internal static string ExtractCertificateIdFromCertificateChain(string certificateChain);
    internal static string ExtractCertificateIdFromCertificate(string certificate);
    internal static Dictionary`2<string, string> ExtractApplicationSpecificDataFromLicense(string useLicenseChain);
    internal static void GetContentIdFromLicense(string useLicenseChain, String& contentId, String& contentIdType);
    internal static string GetContentIdFromPublishLicense(string publishLicense);
    internal static Uri GetUseLicenseAcquisitionUriFromPublishLicense(string publishLicense);
    internal static void GetReferralInfoFromPublishLicense(string publishLicense, String& referralInfoName, Uri& referralInfoUri);
    internal static string GetSecurityProviderPath();
    internal static Nullable`1<ContentRight> GetRightFromString(string rightName);
    internal static string GetStringFromRight(ContentRight right);
}
internal enum MS.Internal.Security.RightsManagement.DistributionPointInfo : Enum {
    public int value__;
    public static DistributionPointInfo LicenseAcquisition;
    public static DistributionPointInfo Publishing;
    public static DistributionPointInfo ReferralInfo;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.EnumerateLicenseFlags : Enum {
    public UInt32 value__;
    public static EnumerateLicenseFlags Machine;
    public static EnumerateLicenseFlags GroupIdentity;
    public static EnumerateLicenseFlags GroupIdentityName;
    public static EnumerateLicenseFlags GroupIdentityLid;
    public static EnumerateLicenseFlags SpecifiedGroupIdentity;
    public static EnumerateLicenseFlags Eul;
    public static EnumerateLicenseFlags EulLid;
    public static EnumerateLicenseFlags ClientLicensor;
    public static EnumerateLicenseFlags ClientLicensorLid;
    public static EnumerateLicenseFlags SpecifiedClientLicensor;
    public static EnumerateLicenseFlags RevocationList;
    public static EnumerateLicenseFlags RevocationListLid;
    public static EnumerateLicenseFlags Expired;
}
internal static class MS.Internal.Security.RightsManagement.Errors : object {
    internal static string GetLocalizedFailureCodeMessageWithDefault(RightsManagementFailureCode failureCode);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ThrowOnErrorCode(int hr);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.IssuanceLicense : object {
    internal SafeRightsManagementPubHandle Handle { get; }
    internal IssuanceLicense(DateTime validFrom, DateTime validUntil, string referralInfoName, Uri referralInfoUri, ContentUser owner, string issuanceLicense, SafeRightsManagementHandle boundLicenseHandle, Guid contentId, ICollection`1<ContentGrant> grantCollection, IDictionary`2<int, LocalizedNameDescriptionPair> localizedNameDescriptionDictionary, IDictionary`2<string, string> applicationSpecificDataDictionary, int rightValidityIntervalDays, RevocationPoint revocationPoint);
    internal SafeRightsManagementPubHandle get_Handle();
    public virtual string ToString();
    internal void UpdateUnsignedPublishLicense(UnsignedPublishLicense unsignedPublishLicense);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal enum MS.Internal.Security.RightsManagement.LicenseAttributeEncoding : Enum {
    public int value__;
    public static LicenseAttributeEncoding Base64;
    public static LicenseAttributeEncoding String;
    public static LicenseAttributeEncoding Long;
    public static LicenseAttributeEncoding Time;
    public static LicenseAttributeEncoding UInt;
    public static LicenseAttributeEncoding Raw;
}
internal static class MS.Internal.Security.RightsManagement.NativeConstants : object {
    public static UInt32 DrmCallbackVersion;
    internal static string TAG_ASCII;
    internal static string TAG_XRML;
    internal static string TAG_FILENAME;
    internal static string TAG_MSGUID;
    internal static string PLUG_STANDARDENABLINGPRINCIPAL;
    internal static string PLUG_STANDARDRIGHTSINTERPRETER;
    internal static string PLUG_STANDARDEBDECRYPTOR;
    internal static string PLUG_STANDARDEBENCRYPTOR;
    internal static string PLUG_STANDARDEBCRYPTOPROVIDER;
    internal static string PLUG_STANDARDLIBRARY;
    internal static string ALGORITHMID_DES;
    internal static string ALGORITHMID_COCKTAIL;
    internal static string ALGORITHMID_AES;
    internal static string ALGORITHMID_RC4;
    internal static string QUERY_OBJECTIDTYPE;
    internal static string QUERY_OBJECTID;
    internal static string QUERY_NAME;
    internal static string QUERY_CONTENTIDTYPE;
    internal static string QUERY_CONTENTIDVALUE;
    internal static string QUERY_CONTENTSKUTYPE;
    internal static string QUERY_CONTENTSKUVALUE;
    internal static string QUERY_MANIFESTSOURCE;
    internal static string QUERY_MACHINECERTSOURCE;
    internal static string QUERY_APIVERSION;
    internal static string QUERY_SECREPVERSION;
    internal static string QUERY_BLOCKSIZE;
    internal static string QUERY_ACCESSCONDITION;
    internal static string QUERY_ADDRESSTYPE;
    internal static string QUERY_ADDRESSVALUE;
    internal static string QUERY_APPDATANAME;
    internal static string QUERY_APPDATAVALUE;
    internal static string QUERY_CONDITIONLIST;
    internal static string QUERY_DISTRIBUTIONPOINT;
    internal static string QUERY_OBJECTTYPE;
    internal static string QUERY_ENABLINGPRINCIPALIDTYPE;
    internal static string QUERY_ENABLINGPRINCIPALIDVALUE;
    internal static string QUERY_GROUPIDENTITYPRINCIPAL;
    internal static string QUERY_FIRSTUSETAG;
    internal static string QUERY_FROMTIME;
    internal static string QUERY_IDTYPE;
    internal static string QUERY_IDVALUE;
    internal static string QUERY_ISSUEDPRINCIPAL;
    internal static string QUERY_ISSUEDTIME;
    internal static string QUERY_ISSUER;
    internal static string QUERY_OWNER;
    internal static string QUERY_PRINCIPAL;
    internal static string QUERY_PRINCIPALIDVALUE;
    internal static string QUERY_PRINCIPALIDTYPE;
    internal static string QUERY_RANGETIMECONDITION;
    internal static string QUERY_OSEXCLUSIONCONDITION;
    internal static string QUERY_INTERVALTIMECONDITION;
    internal static string QUERY_INTERVALTIMEINTERVAL;
    internal static string QUERY_MAXVERSION;
    internal static string QUERY_MINVERSION;
    internal static string QUERY_REFRESHPERIOD;
    internal static string QUERY_REVOCATIONCONDITION;
    internal static string QUERY_RIGHT;
    internal static string QUERY_RIGHTSGROUP;
    internal static string QUERY_RIGHTSPARAMETERNAME;
    internal static string QUERY_RIGHTSPARAMETERVALUE;
    internal static string QUERY_SKUTYPE;
    internal static string QUERY_SKUVALUE;
    internal static string QUERY_TIMEINTERVAL;
    internal static string QUERY_UNTILTIME;
    internal static string QUERY_VALIDITYFROMTIME;
    internal static string QUERY_VALIDITYUNTILTIME;
    internal static string QUERY_WORK;
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.RevocationPoint : object {
    internal string Id { get; internal set; }
    internal string IdType { get; internal set; }
    internal Uri Url { get; internal set; }
    internal SystemTime Frequency { get; internal set; }
    internal string Name { get; internal set; }
    internal string PublicKey { get; internal set; }
    internal string get_Id();
    internal void set_Id(string value);
    internal string get_IdType();
    internal void set_IdType(string value);
    internal Uri get_Url();
    internal void set_Url(Uri value);
    internal SystemTime get_Frequency();
    internal void set_Frequency(SystemTime value);
    internal string get_Name();
    internal void set_Name(string value);
    internal string get_PublicKey();
    internal void set_PublicKey(string value);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.RightNameExpirationInfoPair : object {
    internal string RightName { get; }
    internal DateTime ValidFrom { get; }
    internal DateTime ValidUntil { get; }
    internal RightNameExpirationInfoPair(string rightName, DateTime validFrom, DateTime validUntil);
    internal string get_RightName();
    internal DateTime get_ValidFrom();
    internal DateTime get_ValidUntil();
}
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.Security.RightsManagement.SafeNativeMethods : object {
    internal static int DRMCreateClientSession(CallbackDelegate pfnCallback, UInt32 uCallbackVersion, string GroupIDProviderType, string GroupID, SafeRightsManagementSessionHandle& phSession);
    internal static int DRMCloseSession(UInt32 sessionHandle);
    internal static int DRMCloseHandle(UInt32 handle);
    internal static int DRMCloseQueryHandle(UInt32 queryHandle);
    internal static int DRMCloseEnvironmentHandle(UInt32 envHandle);
    internal static int DRMInitEnvironment(UInt32 eSecurityProviderType, UInt32 eSpecification, string securityProvider, string manifestCredentials, string machineCredentials, SafeRightsManagementEnvironmentHandle& environmentHandle, SafeRightsManagementHandle& defaultLibrary);
    internal static int DRMIsActivated(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, ActivationServerInfo activationServerInfo);
    internal static int DRMActivate(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, UInt32 uLangID, ActivationServerInfo activationServerInfo, IntPtr context, IntPtr parentWindowHandle);
    internal static int DRMCreateLicenseStorageSession(SafeRightsManagementEnvironmentHandle hEnv, SafeRightsManagementHandle hDefLib, SafeRightsManagementSessionHandle hClientSession, UInt32 uFlags, string IssuanceLicense, SafeRightsManagementSessionHandle& phLicenseStorageSession);
    internal static int DRMAcquireLicense(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, string GroupIdentityCredential, string RequestedRights, string CustomData, string url, IntPtr context);
    internal static int DRMEnumerateLicense(SafeRightsManagementSessionHandle hSession, UInt32 uFlags, UInt32 uIndex, Boolean& pfSharedFlag, UInt32& puCertDataLen, StringBuilder wszCertificateData);
    internal static int DRMGetServiceLocation(SafeRightsManagementSessionHandle clientSessionHandle, UInt32 serviceType, UInt32 serviceLocation, string issuanceLicense, UInt32& serviceUrlLength, StringBuilder serviceUrl);
    internal static int DRMDeconstructCertificateChain(string chain, UInt32 index, UInt32& certificateLength, StringBuilder certificate);
    internal static int DRMParseUnboundLicense(string certificate, SafeRightsManagementQueryHandle& queryRootHandle);
    internal static int DRMGetUnboundLicenseObjectCount(SafeRightsManagementQueryHandle queryRootHandle, string subObjectType, UInt32& objectCount);
    internal static int DRMGetBoundLicenseObject(SafeRightsManagementHandle queryRootHandle, string subObjectType, UInt32 index, SafeRightsManagementHandle& subQueryHandle);
    internal static int DRMGetUnboundLicenseObject(SafeRightsManagementQueryHandle queryRootHandle, string subObjectType, UInt32 index, SafeRightsManagementQueryHandle& subQueryHandle);
    internal static int DRMGetUnboundLicenseAttribute(SafeRightsManagementQueryHandle queryRootHandle, string attributeType, UInt32 index, UInt32& encodingType, UInt32& bufferSize, Byte[] buffer);
    internal static int DRMGetBoundLicenseAttribute(SafeRightsManagementHandle queryRootHandle, string attributeType, UInt32 index, UInt32& encodingType, UInt32& bufferSize, Byte[] buffer);
    internal static int DRMCreateIssuanceLicense(SystemTime timeFrom, SystemTime timeUntil, string referralInfoName, string referralInfoUrl, SafeRightsManagementPubHandle ownerUserHandle, string issuanceLicense, SafeRightsManagementHandle boundLicenseHandle, SafeRightsManagementPubHandle& issuanceLicenseHandle);
    internal static int DRMCreateUser(string userName, string userId, string userIdType, SafeRightsManagementPubHandle& userHandle);
    internal static int DRMGetUsers(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 index, SafeRightsManagementPubHandle& userHandle);
    internal static int DRMGetUserRights(SafeRightsManagementPubHandle issuanceLicenseHandle, SafeRightsManagementPubHandle userHandle, UInt32 index, SafeRightsManagementPubHandle& rightHandle);
    internal static int DRMGetUserInfo(SafeRightsManagementPubHandle userHandle, UInt32& userNameLength, StringBuilder userName, UInt32& userIdLength, StringBuilder userId, UInt32& userIdTypeLength, StringBuilder userIdType);
    internal static int DRMGetRightInfo(SafeRightsManagementPubHandle rightHandle, UInt32& rightNameLength, StringBuilder rightName, SystemTime timeFrom, SystemTime timeUntil);
    internal static int DRMCreateRight(string rightName, SystemTime timeFrom, SystemTime timeUntil, UInt32 countExtendedInfo, String[] extendedInfoNames, String[] extendedInfoValues, SafeRightsManagementPubHandle& rightHandle);
    internal static int DRMGetIssuanceLicenseTemplate(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& issuanceLicenseTemplateLength, StringBuilder issuanceLicenseTemplate);
    internal static int DRMClosePubHandle(UInt32 pubHandle);
    internal static int DRMAddRightWithUser(SafeRightsManagementPubHandle issuanceLicenseHandle, SafeRightsManagementPubHandle rightHandle, SafeRightsManagementPubHandle userHandle);
    internal static int DRMSetMetaData(SafeRightsManagementPubHandle issuanceLicenseHandle, string contentId, string contentIdType, string SkuId, string SkuIdType, string contentType, string contentName);
    internal static int DRMGetIssuanceLicenseInfo(SafeRightsManagementPubHandle issuanceLicenseHandle, SystemTime timeFrom, SystemTime timeUntil, UInt32 flags, UInt32& distributionPointNameLength, StringBuilder DistributionPointName, UInt32& distributionPointUriLength, StringBuilder DistributionPointUri, SafeRightsManagementPubHandle& ownerHandle, Boolean& officialFlag);
    internal static int DRMGetSecurityProvider(UInt32 flags, UInt32& typeLength, StringBuilder type, UInt32& pathLength, StringBuilder path);
    internal static int DRMDeleteLicense(SafeRightsManagementSessionHandle hSession, string wszLicenseId);
    internal static int DRMSetNameAndDescription(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, UInt32 localeId, string name, string description);
    internal static int DRMGetNameAndDescription(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 uIndex, UInt32& localeId, UInt32& nameLength, StringBuilder name, UInt32& descriptionLength, StringBuilder description);
    internal static int DRMGetSignedIssuanceLicense(SafeRightsManagementEnvironmentHandle environmentHandle, SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 flags, Byte[] symmetricKey, UInt32 symmetricKeyByteCount, string symmetricKeyType, string clientLicensorCertificate, CallbackDelegate pfnCallback, string Url, UInt32 context);
    internal static int DRMGetOwnerLicense(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& ownerLicenseLength, StringBuilder ownerLicense);
    internal static int DRMCreateBoundLicense(SafeRightsManagementEnvironmentHandle environmentHandle, BoundLicenseParams boundLicenseParams, string licenseChain, SafeRightsManagementHandle& boundLicenseHandle, UInt32& errorLogHandle);
    internal static int DRMCreateEnablingBitsDecryptor(SafeRightsManagementHandle boundLicenseHandle, string right, UInt32 auxLibrary, string auxPlugin, SafeRightsManagementHandle& decryptorHandle);
    internal static int DRMCreateEnablingBitsEncryptor(SafeRightsManagementHandle boundLicenseHandle, string right, UInt32 auxLibrary, string auxPlugin, SafeRightsManagementHandle& encryptorHandle);
    internal static int DRMDecrypt(SafeRightsManagementHandle cryptoProvHandle, UInt32 position, UInt32 inputByteCount, Byte[] inputBuffer, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMEncrypt(SafeRightsManagementHandle cryptoProvHandle, UInt32 position, UInt32 inputByteCount, Byte[] inputBuffer, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMGetInfo(SafeRightsManagementHandle handle, string attributeType, UInt32& encodingType, UInt32& outputByteCount, Byte[] outputBuffer);
    internal static int DRMGetApplicationSpecificData(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 index, UInt32& nameLength, StringBuilder name, UInt32& valueLength, StringBuilder value);
    internal static int DRMSetApplicationSpecificData(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, string name, string value);
    internal static int DRMGetIntervalTime(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& days);
    internal static int DRMSetIntervalTime(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32 days);
    internal static int DRMGetRevocationPoint(SafeRightsManagementPubHandle issuanceLicenseHandle, UInt32& idLength, StringBuilder id, UInt32& idTypeLength, StringBuilder idType, UInt32& urlLength, StringBuilder url, SystemTime frequency, UInt32& nameLength, StringBuilder name, UInt32& publicKeyLength, StringBuilder publicKey);
    internal static int DRMSetRevocationPoint(SafeRightsManagementPubHandle issuanceLicenseHandle, bool flagDelete, string id, string idType, string url, SystemTime frequency, string name, string publicKey);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementEnvironmentHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementEnvironmentHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal static SafeRightsManagementHandle InvalidHandle { get; }
    internal SafeRightsManagementHandle(UInt32 handle);
    private static SafeRightsManagementHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeRightsManagementHandle get_InvalidHandle();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementPubHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal static SafeRightsManagementPubHandle InvalidHandle { get; }
    internal SafeRightsManagementPubHandle(UInt32 handle);
    private static SafeRightsManagementPubHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeRightsManagementPubHandle get_InvalidHandle();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementQueryHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementQueryHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SafeRightsManagementSessionHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeRightsManagementSessionHandle(UInt32 handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal enum MS.Internal.Security.RightsManagement.SecurityProviderType : Enum {
    public UInt32 value__;
    public static SecurityProviderType SoftwareSecRep;
}
internal enum MS.Internal.Security.RightsManagement.ServiceLocation : Enum {
    public UInt32 value__;
    public static ServiceLocation Internet;
    public static ServiceLocation Enterprise;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.ServiceType : Enum {
    public UInt32 value__;
    public static ServiceType Activation;
    public static ServiceType Certification;
    public static ServiceType Publishing;
    public static ServiceType ClientLicensor;
}
[FlagsAttribute]
internal enum MS.Internal.Security.RightsManagement.SignIssuanceLicenseFlags : Enum {
    public UInt32 value__;
    public static SignIssuanceLicenseFlags Online;
    public static SignIssuanceLicenseFlags Offline;
    public static SignIssuanceLicenseFlags Cancel;
    public static SignIssuanceLicenseFlags ServerIssuanceLicense;
    public static SignIssuanceLicenseFlags AutoGenerateKey;
    public static SignIssuanceLicenseFlags OwnerLicenseNoPersist;
}
internal enum MS.Internal.Security.RightsManagement.SpecType : Enum {
    public UInt32 value__;
    public static SpecType Unknown;
    public static SpecType FileName;
}
internal enum MS.Internal.Security.RightsManagement.StatusMessage : Enum {
    public UInt32 value__;
    public static StatusMessage ActivateMachine;
    public static StatusMessage ActivateGroupIdentity;
    public static StatusMessage AcquireLicense;
    public static StatusMessage AcquireAdvisory;
    public static StatusMessage SignIssuanceLicense;
    public static StatusMessage AcquireClientLicensor;
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Security.RightsManagement.SystemTime : object {
    internal static UInt32 Size { get; }
    internal SystemTime(DateTime dateTime);
    internal SystemTime(Byte[] dataBuffer);
    internal static UInt32 get_Size();
    internal DateTime GetDateTime(DateTime defaultValue);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalData`1 : ValueType {
    [SecurityCriticalAttribute]
private T _value;
    internal T Value { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal SecurityCriticalData`1(T value);
    [SecurityCriticalAttribute]
internal T get_Value();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataClass`1 : object {
    internal T Value { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal SecurityCriticalDataClass`1(T value);
    [SecurityCriticalAttribute]
internal T get_Value();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataForSet`1 : ValueType {
    [SecurityCriticalAttribute]
private T _value;
    internal T Value { get; internal set; }
    [SecurityCriticalAttribute]
internal SecurityCriticalDataForSet`1(T value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal T get_Value();
    [SecurityCriticalAttribute]
internal void set_Value(T value);
}
[FriendAccessAllowedAttribute]
[FlagsAttribute]
internal enum MS.Internal.ShutDownEvents : Enum {
    public ushort value__;
    public static ShutDownEvents DomainUnload;
    public static ShutDownEvents ProcessExit;
    public static ShutDownEvents DispatcherShutdown;
    public static ShutDownEvents AppDomain;
    public static ShutDownEvents All;
}
[FriendAccessAllowedAttribute]
internal abstract class MS.Internal.ShutDownListener : WeakReference {
    [SecurityCriticalAttribute]
internal ShutDownListener(object target);
    [SecurityCriticalAttribute]
internal ShutDownListener(object target, ShutDownEvents events);
    internal abstract virtual void OnShutDown(object target, object sender, EventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void StopListening();
}
internal abstract class MS.Internal.SystemCoreExtensionMethods : object {
    internal abstract virtual bool IsIDynamicMetaObjectProvider(object item);
    internal abstract virtual object NewDynamicPropertyAccessor(Type ownerType, string propertyName);
    internal abstract virtual object GetIndexerAccessor(int rank);
}
internal abstract class MS.Internal.SystemDataExtensionMethods : object {
    internal abstract virtual bool IsDataView(IBindingList list);
    internal abstract virtual bool IsDataRowView(object item);
    internal abstract virtual bool IsSqlNull(object value);
    internal abstract virtual bool IsSqlNullableType(Type type);
    internal abstract virtual bool IsDataSetCollectionProperty(PropertyDescriptor pd);
    internal abstract virtual bool DetermineWhetherDBNullIsValid(object item, string columnName, object arg);
}
internal abstract class MS.Internal.SystemDrawingExtensionMethods : object {
    internal abstract virtual bool IsBitmap(object data);
    internal abstract virtual bool IsImage(object data);
    internal abstract virtual bool IsMetafile(object data);
    [SecurityCriticalAttribute]
internal abstract virtual IntPtr GetHandleFromMetafile(object data);
    internal abstract virtual object GetMetafileFromHemf(IntPtr hMetafile);
    internal abstract virtual object GetBitmap(object data);
    [SecurityCriticalAttribute]
internal abstract virtual IntPtr GetHBitmap(object data, Int32& width, Int32& height);
    [SecurityCriticalAttribute]
internal abstract virtual IntPtr GetHBitmapFromBitmap(object data);
    [SecurityCriticalAttribute]
internal abstract virtual IntPtr ConvertMetafileToHBitmap(IntPtr handle);
    internal abstract virtual Stream GetCommentFromGifStream(Stream stream);
    internal abstract virtual CodeAccessPermission NewSafePrintingPermission();
    internal abstract virtual CodeAccessPermission NewDefaultPrintingPermission();
    internal abstract virtual void SaveMetafileToImageStream(MemoryStream metafileStream, Stream imageStream);
    [SecurityCriticalAttribute]
internal abstract virtual object GetBitmapFromBitmapSource(object source);
}
internal abstract class MS.Internal.SystemXmlExtensionMethods : object {
    internal abstract virtual bool IsXmlNode(object item);
    internal abstract virtual bool IsXmlNamespaceManager(object item);
    internal abstract virtual bool TryGetValueFromXmlNode(object item, string name, Object& value);
    internal abstract virtual IComparer PrepareXmlComparer(IEnumerable collection, SortDescriptionCollection sort, CultureInfo culture);
    internal abstract virtual bool IsEmptyXmlDataCollection(object parent);
    internal abstract virtual string GetXmlTagName(object item, DependencyObject target);
    internal abstract virtual object FindXmlNodeWithInnerText(IEnumerable items, object innerText, Int32& index);
    internal abstract virtual object GetInnerText(object item);
}
internal abstract class MS.Internal.SystemXmlLinqExtensionMethods : object {
    internal abstract virtual bool IsXElement(object item);
    internal abstract virtual string GetXElementTagName(object item);
    internal abstract virtual bool IsXLinqCollectionProperty(PropertyDescriptor pd);
    internal abstract virtual bool IsXLinqNonIdempotentProperty(PropertyDescriptor pd);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TextServicesLoader : object {
    internal static bool ServicesInstalled { get; }
    private static TextServicesLoader();
    [SecurityCriticalAttribute]
internal static ITfThreadMgr Load();
    internal static bool get_ServicesInstalled();
}
internal class MS.Internal.Threading.CatchExceptionDelegate : MulticastDelegate {
    public CatchExceptionDelegate(object object, IntPtr method);
    public virtual bool Invoke(object source, Exception e, Delegate catchHandler);
    public virtual IAsyncResult BeginInvoke(object source, Exception e, Delegate catchHandler, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Threading.ExceptionFilterHelper : object {
    internal ExceptionFilterHelper(InternalRealCallDelegate internalRealCall, FilterExceptionDelegate filterException, CatchExceptionDelegate catchException);
    internal object TryCatchWhen(object source, Delegate method, object args, int numArgs, Delegate catchHandler);
}
internal class MS.Internal.Threading.FilterExceptionDelegate : MulticastDelegate {
    public FilterExceptionDelegate(object object, IntPtr method);
    public virtual bool Invoke(object source, Exception e);
    public virtual IAsyncResult BeginInvoke(object source, Exception e, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Threading.InternalRealCallDelegate : MulticastDelegate {
    public InternalRealCallDelegate(object object, IntPtr method);
    public virtual object Invoke(Delegate method, object args, int numArgs);
    public virtual IAsyncResult BeginInvoke(Delegate method, object args, int numArgs, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TokenizerHelper : object {
    internal int _currentTokenIndex;
    internal int _currentTokenLength;
    internal bool FoundSeparator { get; }
    internal TokenizerHelper(string str, IFormatProvider formatProvider);
    internal TokenizerHelper(string str, char quoteChar, char separator);
    internal string GetCurrentToken();
    internal void LastTokenRequired();
    internal bool NextToken();
    internal string NextTokenRequired();
    internal string NextTokenRequired(bool allowQuotedToken);
    internal bool NextToken(bool allowQuotedToken);
    internal bool NextToken(bool allowQuotedToken, char separator);
    internal static char GetNumericListSeparator(IFormatProvider provider);
    internal bool get_FoundSeparator();
}
internal static class MS.Internal.TraceDependencyProperty : object {
    public static AvTraceDetails ApplyTemplateContent { get; }
    public static AvTraceDetails Register { get; }
    public static AvTraceDetails UpdateEffectiveValueStart { get; }
    public static AvTraceDetails UpdateEffectiveValueStop { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceDependencyProperty();
    public static AvTraceDetails get_ApplyTemplateContent();
    public static AvTraceDetails get_Register();
    public static AvTraceDetails get_UpdateEffectiveValueStart();
    public static AvTraceDetails get_UpdateEffectiveValueStop();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceFreezable : object {
    public static AvTraceDetails UnableToFreezeExpression { get; }
    public static AvTraceDetails UnableToFreezeDispatcherObjectWithThreadAffinity { get; }
    public static AvTraceDetails UnableToFreezeFreezableSubProperty { get; }
    public static AvTraceDetails UnableToFreezeAnimatedProperties { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceFreezable();
    public static AvTraceDetails get_UnableToFreezeExpression();
    public static AvTraceDetails get_UnableToFreezeDispatcherObjectWithThreadAffinity();
    public static AvTraceDetails get_UnableToFreezeFreezableSubProperty();
    public static AvTraceDetails get_UnableToFreezeAnimatedProperties();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceLevelStore : object {
    private static TraceLevelStore();
    internal static PresentationTraceLevel GetTraceLevel(object element);
    internal static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
}
internal static class MS.Internal.TraceNameScope : object {
    public static AvTraceDetails RegisterName { get; }
    public static AvTraceDetails UnregisterName { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceNameScope();
    public static AvTraceDetails get_RegisterName();
    public static AvTraceDetails get_UnregisterName();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
[FriendAccessAllowedAttribute]
internal enum MS.Internal.UncommonAssembly : Enum {
    public int value__;
    public static UncommonAssembly System_Drawing;
    public static UncommonAssembly System_Xml;
    public static UncommonAssembly System_Xml_Linq;
    public static UncommonAssembly System_Data;
    public static UncommonAssembly System_Core;
}
internal static class MS.Internal.Utilities : object {
    internal static bool IsOSVistaOrNewer { get; }
    internal static bool IsOSWindows7OrNewer { get; }
    internal static bool IsOSWindows8OrNewer { get; }
    internal static bool IsCompositionEnabled { get; }
    private static Utilities();
    internal static bool get_IsOSVistaOrNewer();
    internal static bool get_IsOSWindows7OrNewer();
    internal static bool get_IsOSWindows8OrNewer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool get_IsCompositionEnabled();
    internal static void SafeDispose(T& disposable);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SafeRelease(T& comObject);
}
internal class MS.Internal.Utility.WeakReferenceKey`1 : object {
    public T Item { get; }
    public WeakReferenceKey`1(T item);
    public T get_Item();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal static class MS.Internal.Verify : object {
    public static void IsApartmentState(ApartmentState requiredState);
    public static void IsNeitherNullNorEmpty(string value, string name);
    public static void IsNotNull(T obj, string name);
    public static void IsTrue(bool expression, string name, string message);
    public static void AreNotEqual(T actual, T notExpected, string parameterName, string message);
    public static void FileExists(string filePath, string parameterName);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.WeakEventTable : DispatcherObject {
    internal static WeakEventTable CurrentWeakEventTable { get; }
    internal IDisposable ReadLock { get; }
    internal IDisposable WriteLock { get; }
    internal WeakEventManager Item { get; internal set; }
    internal WeakEventManager Item { get; internal set; }
    internal object Item { get; internal set; }
    internal bool IsCleanupEnabled { get; internal set; }
    internal static WeakEventTable get_CurrentWeakEventTable();
    internal IDisposable get_ReadLock();
    internal IDisposable get_WriteLock();
    internal WeakEventManager get_Item(Type managerType);
    internal void set_Item(Type managerType, WeakEventManager value);
    internal WeakEventManager get_Item(Type eventSourceType, string eventName);
    internal void set_Item(Type eventSourceType, string eventName, WeakEventManager value);
    internal object get_Item(WeakEventManager manager, object source);
    internal void set_Item(WeakEventManager manager, object source, object value);
    internal bool get_IsCleanupEnabled();
    internal void set_IsCleanupEnabled(bool value);
    internal void Remove(WeakEventManager manager, object source);
    internal void ScheduleCleanup();
    internal static bool Cleanup();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.WeakReferenceList : CopyOnWriteList {
    public int Count { get; }
    public WeakReferenceList(object syncRoot);
    public WeakReferenceListEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Contains(object item);
    public int get_Count();
    public virtual bool Add(object obj);
    public bool Add(object obj, bool skipFind);
    public virtual bool Remove(object obj);
    public bool Insert(int index, object obj);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.WeakReferenceListEnumerator : ValueType {
    private int _i;
    private ArrayList _List;
    private object _StrongReference;
    private object System.Collections.IEnumerator.Current { get; }
    public object Current { get; }
    public WeakReferenceListEnumerator(ArrayList List);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class MS.Internal.WindowsBase.BuildInfo : object {
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_VERSION;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFontCache;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
    internal static string FontCachePortName;
    internal static string FontCacheServiceName;
}
internal static class MS.Internal.WindowsBase.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.WindowsBase.FriendAccessAllowedAttribute : Attribute {
}
internal class MS.Internal.WindowsBase.GCNotificationToken : object {
    protected virtual override void Finalize();
    internal static void RegisterCallback(WaitCallback callback, object state);
}
[SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.WindowsBase.NativeMethodsSetLastError : object {
    private static NativeMethodsSetLastError();
    public static bool EnableWindow(HandleRef hWnd, bool enable);
    public static IntPtr GetAncestor(IntPtr hwnd, int gaFlags);
    public static int GetKeyboardLayoutList(int size, IntPtr[] hkls);
    public static IntPtr GetParent(HandleRef hWnd);
    public static IntPtr GetWindow(IntPtr hWnd, int uCmd);
    public static int GetWindowLong(HandleRef hWnd, int nIndex);
    public static int GetWindowLong(IntPtr hWnd, int nIndex);
    public static WndProc GetWindowLongWndProc(HandleRef hWnd, int nIndex);
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex);
    public static IntPtr GetWindowLongPtr(HandleRef hWnd, int nIndex);
    public static WndProc GetWindowLongPtrWndProc(HandleRef hWnd, int nIndex);
    public static int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
    public static int GetWindowTextLength(HandleRef hWnd);
    public static int MapWindowPoints(HandleRef hWndFrom, HandleRef hWndTo, RECT& rect, int cPoints);
    public static IntPtr SetFocus(HandleRef hWnd);
    public static int SetWindowLong(HandleRef hWnd, int nIndex, int dwNewLong);
    public static int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    public static int SetWindowLongWndProc(HandleRef hWnd, int nIndex, WndProc dwNewLong);
    public static IntPtr SetWindowLongPtr(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLongPtrWndProc(HandleRef hWnd, int nIndex, WndProc dwNewLong);
}
internal static class MS.Internal.WindowsBase.SafeSecurityHelper : object {
    internal static string IMAGE;
    private static SafeSecurityHelper();
    internal static Assembly GetLoadedAssembly(AssemblyName assemblyName);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.WindowsBase.SecurityHelper : object {
    private static SecurityHelper();
    [SecuritySafeCriticalAttribute]
internal static bool CheckUnmanagedCodePermission();
    [SecurityCriticalAttribute]
internal static void DemandUnmanagedCode();
    [SecurityCriticalAttribute]
internal static void DemandRightsManagementPermission();
    [SecurityCriticalAttribute]
internal static void DemandCompoundFileIOPermission();
    [SecurityCriticalAttribute]
internal static void DemandPathDiscovery(string path);
    [SecuritySafeCriticalAttribute]
internal static void RunClassConstructor(Type t);
    [SecuritySafeCriticalAttribute]
internal static Exception GetExceptionForHR(int hr);
    [SecuritySafeCriticalAttribute]
internal static void ThrowExceptionForHR(int hr);
    [SecuritySafeCriticalAttribute]
internal static int GetHRForException(Exception exception);
    [SecurityCriticalAttribute]
internal static void DemandUIWindowPermission();
    [SecurityCriticalAttribute]
internal static void DemandUnrestrictedUIPermission();
    internal static bool AreStringTypesEqual(string m1, string m2);
    [SecurityCriticalAttribute]
internal static object ReadRegistryValue(RegistryKey baseRegistryKey, string keyName, string valueName);
}
internal static class MS.Internal.WindowsBase.SR : object {
    internal static ResourceManager ResourceManager { get; }
    private static SR();
    internal static string Get(string id);
    internal static string Get(string id, Object[] args);
    internal static ResourceManager get_ResourceManager();
}
internal class MS.Internal.WindowsBase.SRID : ValueType {
    public static string Default;
    public static string UnexpectedParameterType;
    public static string CannotConvertStringToType;
    public static string CannotConvertType;
    public static string StringEmpty;
    public static string ParameterCannotBeNegative;
    public static string Enum_Invalid;
    public static string Collection_BadType;
    public static string Collection_CopyTo_IndexGreaterThanOrEqualToArrayLength;
    public static string Collection_CopyTo_NumberOfElementsExceedsArrayLength;
    public static string Collection_CopyTo_ArrayCannotBeMultidimensional;
    public static string CollectionNumberOfElementsMustBeLessOrEqualTo;
    public static string Enumerator_VerifyContext;
    public static string Animation_ChildMustBeKeyFrame;
    public static string Animation_NoTextChildren;
    public static string Animation_InvalidBaseValue;
    public static string Animation_InvalidTimeKeyTime;
    public static string Animation_InvalidResolvedKeyTimes;
    public static string Animation_InvalidAnimationUsingKeyFramesDuration;
    public static string Animation_Invalid_DefaultValue;
    public static string Freezable_CantBeFrozen;
    public static string CannotModifyReadOnlyContainer;
    public static string CannotRetrievePartsOfWriteOnlyContainer;
    public static string TokenizerHelperPrematureStringTermination;
    public static string TokenizerHelperMissingEndQuote;
    public static string TokenizerHelperExtraDataEncountered;
    public static string TokenizerHelperEmptyToken;
    public static string InvalidPermissionType;
    public static string InvalidPermissionStateValue;
    public static string SecurityExceptionForSettingSandboxExternalToTrue;
    public static string FileFormatException;
    public static string FileFormatExceptionWithFileName;
    public static string TypeMetadataCannotChangeAfterUse;
    public static string Visual_ArgumentOutOfRange;
    public static string WPF_UILanguage;
    public static string Rect_CannotModifyEmptyRect;
    public static string Rect_CannotCallMethod;
    public static string Size_WidthAndHeightCannotBeNegative;
    public static string Size_WidthCannotBeNegative;
    public static string Size_HeightCannotBeNegative;
    public static string Size_CannotModifyEmptySize;
    public static string Transform_NotInvertible;
    public static string General_Expected_Type;
    public static string ReferenceIsNull;
    public static string ParameterMustBeBetween;
    public static string Freezable_UnregisteredHandler;
    public static string Freezable_AttemptToUseInnerValueWithDifferentThread;
    public static string Freezable_CantFreeze;
    public static string Freezable_NotAContext;
    public static string FrugalList_TargetMapCannotHoldAllData;
    public static string FrugalList_CannotPromoteBeyondArray;
    public static string FrugalMap_TargetMapCannotHoldAllData;
    public static string FrugalMap_CannotPromoteBeyondHashtable;
    public static string Unsupported_Key;
    public static string InvalidPriority;
    public static string InvalidPriorityRangeOrder;
    public static string DispatcherHasShutdown;
    public static string ThreadMayNotWaitOnOperationsAlreadyExecutingOnTheSameThread;
    public static string VerifyAccess;
    public static string MismatchedDispatchers;
    public static string DispatcherProcessingDisabledButStillPumping;
    public static string DispatcherProcessingDisabled;
    public static string DispatcherPriorityAwaiterInvalid;
    public static string DispatcherYieldNoAvailableDispatcher;
    public static string ExceptionFilterCodeNotPresent;
    public static string Unsupported_Modifier;
    public static string TimeSpanPeriodOutOfRange_TooSmall;
    public static string TimeSpanPeriodOutOfRange_TooLarge;
    public static string ClearOnReadOnlyObjectNotAllowed;
    public static string DefaultValueAutoAssignFailed;
    public static string DefaultValueMayNotBeExpression;
    public static string DefaultValueMayNotBeUnset;
    public static string DefaultValueMustBeFreeThreaded;
    public static string DefaultValuePropertyTypeMismatch;
    public static string DefaultValueInvalid;
    public static string DTypeNotSupportForSystemType;
    public static string InvalidPropertyValue;
    public static string LocalValueEnumerationOutOfBounds;
    public static string LocalValueEnumerationReset;
    public static string LocalValueEnumerationInvalidated;
    public static string MissingCreateDefaultValue;
    public static string OverridingMetadataDoesNotMatchBaseMetadataType;
    public static string PropertyAlreadyRegistered;
    public static string PropertyNotReadOnly;
    public static string ReadOnlyChangeNotAllowed;
    public static string ReadOnlyKeyNotAuthorized;
    public static string ReadOnlyOverrideNotAllowed;
    public static string ReadOnlyOverrideKeyNotAuthorized;
    public static string ReadOnlyDesignerCoersionNotAllowed;
    public static string SetOnReadOnlyObjectNotAllowed;
    public static string ShareableExpressionsCannotChangeSources;
    public static string SharingNonSharableExpression;
    public static string SpecialMethodMustBePublic;
    public static string SourcesMustBeInSameThread;
    public static string SourceChangeExpressionMismatch;
    public static string TooManyDependencyProperties;
    public static string TypeMetadataAlreadyInUse;
    public static string TypeMetadataAlreadyRegistered;
    public static string TypeMustBeDependencyObjectDerived;
    public static string UnknownExpressionMode;
    public static string BufferTooSmall;
    public static string BufferOffsetNegative;
    public static string CompoundFilePathNullEmpty;
    public static string CanNotCreateContainerOnReadOnlyStream;
    public static string CanNotCreateAsReadOnly;
    public static string CanNotCreateInReadOnly;
    public static string CanNotCreateStorageRootOnNonReadableStream;
    public static string CanNotDelete;
    public static string CanNotDeleteAccessDenied;
    public static string CanNotCreateAccessDenied;
    public static string CanNotDeleteInReadOnly;
    public static string CanNotDeleteNonEmptyStorage;
    public static string CanNotDeleteRoot;
    public static string CanNotOnNonExistStorage;
    public static string CanNotOpenStorage;
    public static string ContainerNotFound;
    public static string ContainerCanNotOpen;
    public static string CreateModeMustBeCreateOrOpen;
    public static string CFAPIFailure;
    public static string DataSpaceLabelInUse;
    public static string DataSpaceLabelInvalidEmpty;
    public static string DataSpaceLabelUndefined;
    public static string DataSpaceManagerDisposed;
    public static string DataSpaceMapEntryInvalid;
    public static string FileAccessInvalid;
    public static string FileAlreadyExists;
    public static string FileModeUnsupported;
    public static string FileModeInvalid;
    public static string FileShareUnsupported;
    public static string FileShareInvalid;
    public static string ILockBytesStreamMustSeek;
    public static string InvalidArgumentValue;
    public static string InvalidCondition01;
    public static string InvalidStringFormat;
    public static string InvalidTableType;
    public static string MoveToDestNotExist;
    public static string MoveToNYI;
    public static string NameAlreadyInUse;
    public static string NameCanNotHaveDelimiter;
    public static string NamedAPIFailure;
    public static string NameTableCorruptStg;
    public static string NameTableCorruptMem;
    public static string NameTableVersionMismatchRead;
    public static string NameTableVersionMismatchWrite;
    public static string NYIDefault;
    public static string PathHasEmptyElement;
    public static string ReadCountNegative;
    public static string SeekFailed;
    public static string SeekNegative;
    public static string SeekOriginInvalid;
    public static string StorageFlagsUnsupported;
    public static string StorageAlreadyExist;
    public static string StreamAlreadyExist;
    public static string StorageInfoDisposed;
    public static string StorageNotExist;
    public static string StorageRootDisposed;
    public static string StreamInfoDisposed;
    public static string StreamLengthNegative;
    public static string StreamNotExist;
    public static string StreamNameNotValid;
    public static string StreamTimeStampNotImplemented;
    public static string StringCanNotBeReservedName;
    public static string TimeStampNotAvailable;
    public static string TransformLabelInUse;
    public static string TransformLabelUndefined;
    public static string TransformObjectConstructorParam;
    public static string TransformObjectImplementIDataTransform;
    public static string TransformObjectInitFailed;
    public static string TransformTypeUnsupported;
    public static string TransformStackValid;
    public static string UnableToCreateOnStream;
    public static string UnableToCreateStorage;
    public static string UnableToCreateStream;
    public static string UnableToOpenStream;
    public static string UnsupportedTypeEncounteredWhenBuildingStgEnum;
    public static string WriteFailure;
    public static string WriteOnlyUnsupported;
    public static string WriteSizeNegative;
    public static string CFM_CorruptMetadataStream;
    public static string CFM_CorruptMetadataStream_Root;
    public static string CFM_CorruptMetadataStream_DuplicateKey;
    public static string CFM_ObjectMustBeCompoundFileMetadataKey;
    public static string CFM_ReadOnlyContainer;
    public static string CFM_TypeTableFormat;
    public static string CFM_UnicodeCharInvalid;
    public static string CFM_ValueMustBeString;
    public static string CFM_XMLCharInvalid;
    public static string CanNotCompareDiffTypes;
    public static string CFRCorrupt;
    public static string CFRCorruptMultiStream;
    public static string CFRCorruptStgFollowStm;
    public static string DelimiterLeading;
    public static string DelimiterTrailing;
    public static string OffsetNegative;
    public static string UnknownReferenceComponentType;
    public static string UnknownReferenceSerialize;
    public static string MalformedCompoundFilePath;
    public static string CannotMakeStreamLengthNegative;
    public static string CorruptStream;
    public static string LengthNotSupported;
    public static string ReadBufferTooSmall;
    public static string ReadNotSupported;
    public static string SeekNotSupported;
    public static string SetLengthNotSupported;
    public static string SetPositionNotSupported;
    public static string StreamPositionNegative;
    public static string TransformParametersFixed;
    public static string WriteBufferTooSmall;
    public static string WriteCountNegative;
    public static string WriteNotSupported;
    public static string ZLibVersionError;
    public static string ExpectedVersionPairObject;
    public static string VersionNumberComponentNegative;
    public static string ZeroLengthFeatureID;
    public static string VersionStreamMissing;
    public static string VersionUpdateFailure;
    public static string CannotRemoveSignatureFromReadOnlyFile;
    public static string CannotSignReadOnlyFile;
    public static string DigSigCannotLocateCertificate;
    public static string DigSigDuplicateCertificate;
    public static string CertSelectionDialogTitle;
    public static string CertSelectionDialogMessage;
    public static string DuplicateSignature;
    public static string XmlSignatureParseError;
    public static string RequiredXmlAttributeMissing;
    public static string UnexpectedXmlTag;
    public static string RequiredTagNotFound;
    public static string PackageSignatureObjectTagRequired;
    public static string PackageSignatureReferenceTagRequired;
    public static string MoreThanOnePackageSpecificReference;
    public static string InvalidUriAttribute;
    public static string NoCounterSignUnsignedContainer;
    public static string BadSignatureTimeFormatString;
    public static string PackageSignatureCorruption;
    public static string UnsupportedHashAlgorithm;
    public static string RelationshipTransformNotFollowedByCanonicalizationTransform;
    public static string MultipleRelationshipTransformsFound;
    public static string UnsupportedTransformAlgorithm;
    public static string UnsupportedCanonicalizationMethod;
    public static string HashAlgorithmMustBeReusable;
    public static string PartReferenceUriMalformed;
    public static string SignatureOriginNotFound;
    public static string MultipleSignatureOrigins;
    public static string NothingToSign;
    public static string EmptySignatureId;
    public static string SignatureDeleted;
    public static string SignaturePackageObjectTagMustBeUnique;
    public static string PackageSpecificReferenceTagMustBeUnique;
    public static string SignatureObjectIdMustBeUnique;
    public static string CanOnlyCounterSignSignatureParts;
    public static string CertificatePartContentTypeMismatch;
    public static string CertificateKeyTypeNotSupported;
    public static string PartToSignMissing;
    public static string DuplicateObjectId;
    public static string CallbackParameterInvalid;
    public static string CannotChangePublishLicense;
    public static string CannotChangeCryptoProvider;
    public static string ExcessiveLengthPrefix;
    public static string GetOlePropertyFailed;
    public static string InvalidAuthenticationTypeString;
    public static string InvalidDocumentPropertyType;
    public static string InvalidDocumentPropertyVariantType;
    public static string InvalidTypePrefixedUserName;
    public static string InvalidTransformFeatureName;
    public static string PackageNotFound;
    public static string NoPublishLicenseStream;
    public static string NoUseLicenseStorage;
    public static string ReaderVersionError;
    public static string PublishLicenseStreamCorrupt;
    public static string PublishLicenseNotFound;
    public static string RightsManagementEncryptionTransformNotFound;
    public static string MultipleRightsManagementEncryptionTransformFound;
    public static string StreamNeedsReadWriteAccess;
    public static string CryptoProviderCanNotDecrypt;
    public static string CryptoProviderCanNotMergeBlocks;
    public static string EncryptedPackageEnvelopeDisposed;
    public static string CryptoProviderDisposed;
    public static string UpdaterVersionError;
    public static string DictionaryIsReadOnly;
    public static string CryptoProviderIsNotReady;
    public static string UseLicenseStreamCorrupt;
    public static string EncryptedDataStreamCorrupt;
    public static string UnknownDocumentProperty;
    public static string WrongDocumentPropertyVariantType;
    public static string UserIsNotActivated;
    public static string UserHasNoClientLicensorCert;
    public static string EncryptionRightIsNotGranted;
    public static string DecryptionRightIsNotGranted;
    public static string NoPrivilegesForPublishLicenseDecryption;
    public static string InvalidPublishLicense;
    public static string PublishLicenseStreamHeaderTooLong;
    public static string OnlyPassportOrWindowsAuthenticatedUsersAreAllowed;
    public static string RmExceptionGenericMessage;
    public static string RmExceptionInvalidLicense;
    public static string RmExceptionInfoNotInLicense;
    public static string RmExceptionInvalidLicenseSignature;
    public static string RmExceptionEncryptionNotPermitted;
    public static string RmExceptionRightNotGranted;
    public static string RmExceptionInvalidVersion;
    public static string RmExceptionInvalidEncodingType;
    public static string RmExceptionInvalidNumericalValue;
    public static string RmExceptionInvalidAlgorithmType;
    public static string RmExceptionEnvironmentNotLoaded;
    public static string RmExceptionEnvironmentCannotLoad;
    public static string RmExceptionTooManyLoadedEnvironments;
    public static string RmExceptionIncompatibleObjects;
    public static string RmExceptionLibraryFail;
    public static string RmExceptionEnablingPrincipalFailure;
    public static string RmExceptionInfoNotPresent;
    public static string RmExceptionBadGetInfoQuery;
    public static string RmExceptionKeyTypeUnsupported;
    public static string RmExceptionCryptoOperationUnsupported;
    public static string RmExceptionClockRollbackDetected;
    public static string RmExceptionQueryReportsNoResults;
    public static string RmExceptionUnexpectedException;
    public static string RmExceptionBindValidityTimeViolated;
    public static string RmExceptionBrokenCertChain;
    public static string RmExceptionBindPolicyViolation;
    public static string RmExceptionManifestPolicyViolation;
    public static string RmExceptionBindRevokedLicense;
    public static string RmExceptionBindRevokedIssuer;
    public static string RmExceptionBindRevokedPrincipal;
    public static string RmExceptionBindRevokedResource;
    public static string RmExceptionBindRevokedModule;
    public static string RmExceptionBindContentNotInEndUseLicense;
    public static string RmExceptionBindAccessPrincipalNotEnabling;
    public static string RmExceptionBindAccessUnsatisfied;
    public static string RmExceptionBindIndicatedPrincipalMissing;
    public static string RmExceptionBindMachineNotFoundInGroupIdentity;
    public static string RmExceptionLibraryUnsupportedPlugIn;
    public static string RmExceptionBindRevocationListStale;
    public static string RmExceptionBindNoApplicableRevocationList;
    public static string RmExceptionInvalidHandle;
    public static string RmExceptionBindIntervalTimeViolated;
    public static string RmExceptionBindNoSatisfiedRightsGroup;
    public static string RmExceptionBindSpecifiedWorkMissing;
    public static string RmExceptionNoMoreData;
    public static string RmExceptionLicenseAcquisitionFailed;
    public static string RmExceptionIdMismatch;
    public static string RmExceptionTooManyCertificates;
    public static string RmExceptionNoDistributionPointUrlFound;
    public static string RmExceptionAlreadyInProgress;
    public static string RmExceptionGroupIdentityNotSet;
    public static string RmExceptionRecordNotFound;
    public static string RmExceptionNoConnect;
    public static string RmExceptionNoLicense;
    public static string RmExceptionNeedsMachineActivation;
    public static string RmExceptionNeedsGroupIdentityActivation;
    public static string RmExceptionActivationFailed;
    public static string RmExceptionAborted;
    public static string RmExceptionOutOfQuota;
    public static string RmExceptionAuthenticationFailed;
    public static string RmExceptionServerError;
    public static string RmExceptionInstallationFailed;
    public static string RmExceptionHidCorrupted;
    public static string RmExceptionInvalidServerResponse;
    public static string RmExceptionServiceNotFound;
    public static string RmExceptionUseDefault;
    public static string RmExceptionServerNotFound;
    public static string RmExceptionInvalidEmail;
    public static string RmExceptionValidityTimeViolation;
    public static string RmExceptionOutdatedModule;
    public static string RmExceptionServiceMoved;
    public static string RmExceptionServiceGone;
    public static string RmExceptionAdEntryNotFound;
    public static string RmExceptionNotAChain;
    public static string RmExceptionRequestDenied;
    public static string RmExceptionNotSet;
    public static string RmExceptionMetadataNotSet;
    public static string RmExceptionRevocationInfoNotSet;
    public static string RmExceptionInvalidTimeInfo;
    public static string RmExceptionRightNotSet;
    public static string RmExceptionLicenseBindingToWindowsIdentityFailed;
    public static string RmExceptionInvalidIssuanceLicenseTemplate;
    public static string RmExceptionInvalidKeyLength;
    public static string RmExceptionExpiredOfficialIssuanceLicenseTemplate;
    public static string RmExceptionInvalidClientLicensorCertificate;
    public static string RmExceptionHidInvalid;
    public static string RmExceptionEmailNotVerified;
    public static string RmExceptionDebuggerDetected;
    public static string RmExceptionInvalidLockboxType;
    public static string RmExceptionInvalidLockboxPath;
    public static string RmExceptionInvalidRegistryPath;
    public static string RmExceptionNoAesCryptoProvider;
    public static string RmExceptionGlobalOptionAlreadySet;
    public static string RmExceptionOwnerLicenseNotFound;
    public static string ZipZeroSizeFileIsNotValidArchive;
    public static string CanNotWriteInReadOnlyMode;
    public static string CanNotReadInWriteOnlyMode;
    public static string CanNotReadWriteInReadOnlyWriteOnlyMode;
    public static string AttemptedToCreateDuplicateFileName;
    public static string FileDoesNotExists;
    public static string TruncateAppendModesNotSupported;
    public static string OnlyFileShareReadAndFileShareNoneSupported;
    public static string CanNotReadDataFromStreamWhichDoesNotSupportReading;
    public static string CanNotWriteDataToStreamWhichDoesNotSupportWriting;
    public static string CanNotOperateOnStreamWhichDoesNotSupportSeeking;
    public static string UnsupportedCombinationOfModeAccessShareStreaming;
    public static string CorruptedData;
    public static string NotSupportedMultiDisk;
    public static string ZipArchiveDisposed;
    public static string ZipFileItemDisposed;
    public static string NotSupportedVersionNeededToExtract;
    public static string Zip64StructuresTooLarge;
    public static string ZipNotSupportedEncryptedArchive;
    public static string ZipNotSupportedSignedArchive;
    public static string ZipNotSupportedCompressionMethod;
    public static string CompressLengthMismatch;
    public static string CreateNewOnNonEmptyStream;
    public static string PartDoesNotExist;
    public static string PartAlreadyExists;
    public static string PartNamePrefixExists;
    public static string IncompatibleModeOrAccess;
    public static string URIShouldNotBeAbsolute;
    public static string UriShouldBeAbsolute;
    public static string ContainerAndPartModeIncompatible;
    public static string UnsupportedCombinationOfModeAccess;
    public static string NullStreamReturned;
    public static string ObjectDisposed;
    public static string ReadOnlyStream;
    public static string WriteOnlyStream;
    public static string ParentContainerClosed;
    public static string PackagePartDeleted;
    public static string RelationshipToRelationshipIllegal;
    public static string RelationshipPartsCannotHaveRelationships;
    public static string RelationshipPartIncorrectContentType;
    public static string PackageRelationshipDoesNotExist;
    public static string PackagePartRelationshipDoesNotExist;
    public static string RelationshipTargetMustBeRelative;
    public static string RequiredRelationshipAttributeMissing;
    public static string RelationshipTagDoesntMatchSchema;
    public static string RelationshipsTagHasExtraAttributes;
    public static string UnknownTagEncountered;
    public static string ExpectedRelationshipsElementTag;
    public static string InvalidXmlBaseAttributePresent;
    public static string NotAUniqueRelationshipId;
    public static string NotAValidXmlIdString;
    public static string InvalidValueForTheAttribute;
    public static string InvalidRelationshipType;
    public static string PartUriShouldStartWithForwardSlash;
    public static string PartUriShouldNotEndWithForwardSlash;
    public static string UriShouldBePackScheme;
    public static string PartUriIsEmpty;
    public static string InvalidPartUri;
    public static string RelationshipPartUriNotExpected;
    public static string RelationshipPartUriExpected;
    public static string NotAValidRelationshipPartUri;
    public static string FragmentMustStartWithHash;
    public static string PartUriCannotHaveAFragment;
    public static string PartUriShouldNotStartWithTwoForwardSlashes;
    public static string InnerPackageUriHasFragment;
    public static string StreamObjectDisposed;
    public static string NullContentTypeProvided;
    public static string GetContentTypeCoreNotImplemented;
    public static string RequiredAttributeMissing;
    public static string RequiredAttributeEmpty;
    public static string TypesTagHasExtraAttributes;
    public static string TypesElementExpected;
    public static string TypesXmlDoesNotMatchSchema;
    public static string DefaultTagDoesNotMatchSchema;
    public static string OverrideTagDoesNotMatchSchema;
    public static string ElementIsNotEmptyElement;
    public static string BadPackageFormat;
    public static string StreamingModeNotSupportedForConsumption;
    public static string StreamingPackageProductionImpliesWriteOnlyAccess;
    public static string StreamingPackageProductionRequiresSingleWriter;
    public static string MethodAvailableOnlyInStreamingCreation;
    public static string OperationIsNotSupportedInStreamingProduction;
    public static string OnlyWriteOperationsAreSupportedInStreamingCreation;
    public static string OperationViolatesWriteOnceSemantics;
    public static string OnlyStreamingProductionIsSupported;
    public static string IOBufferOverflow;
    public static string StreamDoesNotSupportWrite;
    public static string MoreThanOneMetadataRelationships;
    public static string NoExternalTargetForMetadataRelationship;
    public static string CorePropertiesElementExpected;
    public static string NoStructuredContentInsideProperties;
    public static string UnknownNamespaceInCorePropertiesPart;
    public static string InvalidPropertyNameInCorePropertiesPart;
    public static string PropertyStartTagExpected;
    public static string XsdDateTimeExpected;
    public static string DanglingMetadataRelationship;
    public static string WrongContentTypeForPropertyPart;
    public static string PropertyWrongNumbOfAttribsDefinedOn;
    public static string UnknownDCDateTimeXsiType;
    public static string DuplicateCorePropertyName;
    public static string StorageBasedPackagePropertiesDiposed;
    public static string EncodingNotSupported;
    public static string DuplicatePiecesFound;
    public static string PieceDoesNotExist;
    public static string ServiceTypeAlreadyAdded;
    public static string QualifiedNameHasWrongFormat;
    public static string ParserAttributeArgsHigh;
    public static string ParserAttributeArgsLow;
    public static string ParserAssemblyLoadVersionMismatch;
    public static string ToStringNull;
    public static string ConvertToException;
    public static string ConvertFromException;
    public static string SortDescriptionPropertyNameCannotBeEmpty;
    public static string CannotChangeAfterSealed;
    public static string BadPropertyForGroup;
    public static string CurrentChangingCannotBeCanceled;
    public static string NotSupported_ReadOnlyCollection;
    public static string Arg_RankMultiDimNotSupported;
    public static string Arg_NonZeroLowerBound;
    public static string ArgumentOutOfRange_NeedNonNegNum;
    public static string Arg_ArrayPlusOffTooSmall;
    public static string Argument_InvalidArrayType;
    public static string ReachOutOfRange;
    public static string InvalidPermissionState;
    public static string TargetNotWebBrowserPermissionLevel;
    public static string TargetNotMediaPermissionLevel;
    public static string BadXml;
    public static string InvalidPermissionLevel;
    public static string XCRChoiceOnlyInAC;
    public static string XCRChoiceAfterFallback;
    public static string XCRRequiresAttribNotFound;
    public static string XCRInvalidRequiresAttribute;
    public static string XCRFallbackOnlyInAC;
    public static string XCRChoiceNotFound;
    public static string XCRMultipleFallbackFound;
    public static string XCRInvalidAttribInElement;
    public static string XCRUnknownCompatElement;
    public static string XCRInvalidACChild;
    public static string XCRInvalidFormat;
    public static string XCRUndefinedPrefix;
    public static string XCRUnknownCompatAttrib;
    public static string XCRNSProcessContentNotIgnorable;
    public static string XCRDuplicateProcessContent;
    public static string XCRInvalidProcessContent;
    public static string XCRDuplicateWildcardProcessContent;
    public static string XCRMustUnderstandFailed;
    public static string XCRNSPreserveNotIgnorable;
    public static string XCRDuplicatePreserve;
    public static string XCRInvalidPreserve;
    public static string XCRDuplicateWildcardPreserve;
    public static string XCRInvalidXMLName;
    public static string XCRCompatCycle;
    public static string EventNotFound;
    public static string ListenerDidNotHandleEvent;
    public static string ListenerDidNotHandleEventDetail;
    public static string NoMulticastHandlers;
    public static string InvariantFailure;
    public static string ContentTypeCannotHaveLeadingTrailingLWS;
    public static string InvalidTypeSubType;
    public static string ExpectingParameterValuePairs;
    public static string InvalidParameterValuePair;
    public static string InvalidToken;
    public static string InvalidParameterValue;
    public static string InvalidLinearWhiteSpaceCharacter;
    public static string ExpectingSemicolon;
    public static string HwndSubclassMultipleAttach;
    public static string UnableToLocateResource;
    public static string SplashScreenIsLoading;
    public static string NameScopeNameNotEmptyString;
    public static string NameScopeNameNotFound;
    public static string NameScopeDuplicateNamesNotAllowed;
    public static string NameScopeNotFound;
    public static string NameScopeInvalidIdentifierName;
    public static string NoDependencyProperty;
    public static string MarkupExtensionArrayType;
    public static string MarkupExtensionArrayBadType;
    public static string MarkupExtensionNoContext;
    public static string MarkupExtensionBadStatic;
    public static string MarkupExtensionStaticMember;
    public static string MarkupExtensionTypeName;
    public static string MarkupExtensionTypeNameBad;
    public static string MustBeOfType;
    public static string Verify_ApartmentState;
    public static string Verify_NeitherNullNorEmpty;
    public static string Verify_AreNotEqual;
    public static string Verify_FileExists;
    public static string InvalidEvent;
    public static string CompatibilityPreferencesSealed;
}
internal class MS.Internal.WindowsBase.WeakRefKey : WeakReference {
    public WeakRefKey(object target);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
internal class MS.Utility.ArrayItemList`1 : FrugalListBase`1<T> {
    public int Capacity { get; }
    public ArrayItemList`1(int size);
    public ArrayItemList`1(ICollection collection);
    public ArrayItemList`1(ICollection`1<T> collection);
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public void Promote(ArrayItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal class MS.Utility.ArrayObjectMap : FrugalMapBase {
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.ClassicTraceProvider : TraceProvider {
    [SecurityCriticalAttribute]
internal virtual void Register(Guid providerGuid);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
    [SecurityCriticalAttribute]
internal virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
}
internal class MS.Utility.EventData : ValueType {
    internal ulong Ptr;
    internal UInt32 Size;
    internal UInt32 Reserved;
}
internal static class MS.Utility.EventTrace : object {
    internal static TraceProvider EventProvider;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static EventTrace();
    internal static void EasyTraceEvent(Keyword keywords, Event eventID);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, object param1);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID, object param1);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, object param1, object param2);
    internal static void EasyTraceEvent(Keyword keywords, Level level, Event eventID, object param1, object param2);
    internal static void EasyTraceEvent(Keyword keywords, Event eventID, object param1, object param2, object param3);
    internal static bool IsEnabled(Keyword flag, Level level);
    internal static Guid GetGuidForEvent(Event arg);
    internal static ushort GetTaskForEvent(Event arg);
    internal static byte GetOpcodeForEvent(Event arg);
    internal static byte GetVersionForEvent(Event arg);
}
internal abstract class MS.Utility.FrugalListBase`1 : object {
    protected int _count;
    public int Count { get; }
    public int Capacity { get; }
    public int get_Count();
    internal void TrustedSetCount(int newCount);
    public abstract virtual int get_Capacity();
    public abstract virtual FrugalListStoreState Add(T value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual int IndexOf(T value);
    public abstract virtual void Insert(int index, T value);
    public abstract virtual void SetAt(int index, T value);
    public abstract virtual bool Remove(T value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual T EntryAt(int index);
    public abstract virtual void Promote(FrugalListBase`1<T> newList);
    public abstract virtual T[] ToArray();
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual object Clone();
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal enum MS.Utility.FrugalListStoreState : Enum {
    public int value__;
    public static FrugalListStoreState Success;
    public static FrugalListStoreState SingleItemList;
    public static FrugalListStoreState ThreeItemList;
    public static FrugalListStoreState SixItemList;
    public static FrugalListStoreState Array;
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalMap : ValueType {
    internal FrugalMapBase _mapStore;
    public object Item { get; public set; }
    public int Count { get; }
    public object get_Item(int key);
    public void set_Item(int key, object value);
    public void Sort();
    public void GetKeyValuePair(int index, Int32& key, Object& value);
    public void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public int get_Count();
}
internal abstract class MS.Utility.FrugalMapBase : object {
    protected static int INVALIDKEY;
    public int Count { get; }
    public abstract virtual FrugalMapStoreState InsertEntry(int key, object value);
    public abstract virtual void RemoveEntry(int key);
    public abstract virtual object Search(int key);
    public abstract virtual void Sort();
    public abstract virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public abstract virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public abstract virtual void Promote(FrugalMapBase newMap);
    public abstract virtual int get_Count();
}
internal class MS.Utility.FrugalMapIterationCallback : MulticastDelegate {
    public FrugalMapIterationCallback(object object, IntPtr method);
    public virtual void Invoke(ArrayList list, int key, object value);
    public virtual IAsyncResult BeginInvoke(ArrayList list, int key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum MS.Utility.FrugalMapStoreState : Enum {
    public int value__;
    public static FrugalMapStoreState Success;
    public static FrugalMapStoreState ThreeObjectMap;
    public static FrugalMapStoreState SixObjectMap;
    public static FrugalMapStoreState Array;
    public static FrugalMapStoreState SortedArray;
    public static FrugalMapStoreState Hashtable;
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalObjectList`1 : object {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalObjectList`1(int size);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalObjectList`1<T> Clone();
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class MS.Utility.FrugalStructList`1 : ValueType {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalStructList`1(int size);
    public FrugalStructList`1(ICollection collection);
    public FrugalStructList`1(ICollection`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalStructList`1<T> Clone();
}
internal class MS.Utility.HashObjectMap : FrugalMapBase {
    internal static int MINSIZE;
    internal Hashtable _entries;
    public int Count { get; }
    private static HashObjectMap();
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
internal class MS.Utility.InsertionSortMap : ValueType {
    internal LargeSortedObjectMap _mapStore;
    public object Item { get; public set; }
    public int Count { get; }
    public object get_Item(int key);
    public void set_Item(int key, object value);
    public void Sort();
    public void GetKeyValuePair(int index, Int32& key, Object& value);
    public void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public int get_Count();
}
[FriendAccessAllowedAttribute]
internal class MS.Utility.ItemStructList`1 : ValueType {
    public T[] List;
    public int Count;
    public ItemStructList`1(int capacity);
    public void EnsureIndex(int index);
    public bool IsValidIndex(int index);
    public int IndexOf(T value);
    public bool Contains(T value);
    public void Add(T item);
    public void Add(T& item);
    public int Add();
    public int Add(int delta);
    public void Sort();
    public void AppendTo(ItemStructList`1& destinationList);
    public T[] ToArray();
    public void Clear();
    public void Remove(T value);
}
internal class MS.Utility.LargeSortedObjectMap : FrugalMapBase {
    internal int _count;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.ManifestTraceProvider : TraceProvider {
    [SecurityCriticalAttribute]
internal virtual void Register(Guid providerGuid);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
    [SecurityCriticalAttribute]
internal virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
}
internal class MS.Utility.SingleItemList`1 : FrugalListBase`1<T> {
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
}
internal class MS.Utility.SingleObjectMap : FrugalMapBase {
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.SixItemList`1 : FrugalListBase`1<T> {
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
}
internal class MS.Utility.SixObjectMap : FrugalMapBase {
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.SortedObjectMap : FrugalMapBase {
    internal int _count;
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal class MS.Utility.ThreeItemList`1 : FrugalListBase`1<T> {
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
}
internal class MS.Utility.ThreeObjectMap : FrugalMapBase {
    public int Count { get; }
    public virtual FrugalMapStoreState InsertEntry(int key, object value);
    public virtual void RemoveEntry(int key);
    public virtual object Search(int key);
    public virtual void Sort();
    public virtual void GetKeyValuePair(int index, Int32& key, Object& value);
    public virtual void Iterate(ArrayList list, FrugalMapIterationCallback callback);
    public virtual void Promote(FrugalMapBase newMap);
    public virtual int get_Count();
}
internal abstract class MS.Utility.TraceProvider : object {
    protected bool _enabled;
    protected Level _level;
    protected Keyword _keywords;
    protected Keyword _matchAllKeyword;
    protected SecurityCriticalDataForSet`1<ulong> _registrationHandle;
    internal Keyword Keywords { get; }
    internal Keyword MatchAllKeywords { get; }
    internal Level Level { get; }
    [SecurityCriticalAttribute]
internal abstract virtual void Register(Guid providerGuid);
    [SecurityCriticalAttribute]
internal abstract virtual UInt32 EventWrite(Event eventID, Keyword keywords, Level level, int argc, EventData* argv);
    internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level);
    internal Keyword get_Keywords();
    internal Keyword get_MatchAllKeywords();
    internal Level get_Level();
    internal bool IsEnabled(Keyword keyword, Level level);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level, object eventData);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal UInt32 TraceEvent(Event eventID, Keyword keywords, Level level, Object[] eventPayload);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Win32.ClassicEtw : object {
    internal static int WNODE_FLAG_TRACED_GUID;
    internal static int WNODE_FLAG_USE_MOF_PTR;
    internal static int MAX_MOF_FIELDS;
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 RegisterTraceGuidsW(ControlCallback cbFunc, IntPtr context, Guid& providerGuid, int taskGuidCount, TRACE_GUID_REGISTRATION& taskGuids, string mofImagePath, string mofResourceName, UInt64& regHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 UnregisterTraceGuids(ulong regHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetTraceEnableFlags(ulong traceHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static byte GetTraceEnableLevel(ulong traceHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static long GetTraceLoggerHandle(WNODE_HEADER* data);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 TraceEvent(ulong traceHandle, EVENT_HEADER* header);
}
internal static class MS.Win32.ExternDll : object {
    public static string Activeds;
    public static string Advapi32;
    public static string Comctl32;
    public static string Comdlg32;
    public static string DwmAPI;
    public static string Gdi32;
    public static string Gdiplus;
    public static string Hhctrl;
    public static string Imm32;
    public static string Kernel32;
    public static string Loadperf;
    public static string Mqrt;
    public static string Mscoree;
    public static string MsDrm;
    public static string Mshwgst;
    public static string Msi;
    public static string NaturalLanguage6;
    public static string Ntdll;
    public static string Ole32;
    public static string Oleacc;
    public static string Oleaut32;
    public static string Olepro32;
    public static string Penimc;
    public static string PresentationHostDll;
    public static string PresentationNativeDll;
    public static string Psapi;
    public static string Shell32;
    public static string Shfolder;
    public static string Urlmon;
    public static string User32;
    public static string Uxtheme;
    public static string Version;
    public static string Vsassert;
    public static string Wininet;
    public static string Winmm;
    public static string Winspool;
}
internal static class MS.Win32.HandleCollector : object {
    private static HandleCollector();
    internal static IntPtr Add(IntPtr handle, int type);
    [SecuritySafeCriticalAttribute]
internal static SafeHandle Add(SafeHandle handle, int type);
    internal static void Add(int type);
    internal static int RegisterType(string typeName, int expense, int initialThreshold);
    internal static IntPtr Remove(IntPtr handle, int type);
    [SecuritySafeCriticalAttribute]
internal static SafeHandle Remove(SafeHandle handle, int type);
    internal static void Remove(int type);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndSubclass : object {
    internal static WindowMessage DetachMessage;
    [SecurityCriticalAttribute]
private static HwndSubclass();
    [SecurityCriticalAttribute]
internal HwndSubclass(HwndWrapperHook hook);
    [SecurityCriticalAttribute]
public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal IntPtr Attach(IntPtr hwnd);
    [SecurityCriticalAttribute]
internal bool Detach(bool force);
    [SecurityCriticalAttribute]
internal bool CriticalDetach(bool force);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void RequestDetach(bool force);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RequestDetach(IntPtr hwnd, IntPtr subclass, bool force);
    [SecurityCriticalAttribute]
internal IntPtr SubclassWndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
internal IntPtr CriticalAttach(IntPtr hwnd);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndWrapper : DispatcherObject {
    public IntPtr Handle { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static HwndWrapper();
    [SecurityCriticalAttribute]
public HwndWrapper(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, HwndWrapperHook[] hooks);
    protected virtual override void Finalize();
    public virtual void Dispose();
    [SecurityCriticalAttribute]
public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    [SecurityCriticalAttribute]
public void AddHook(HwndWrapperHook hook);
    [SecurityCriticalAttribute]
internal void AddHookLast(HwndWrapperHook hook);
    [SecurityCriticalAttribute]
public void RemoveHook(HwndWrapperHook hook);
    [SecurityCriticalAttribute]
internal static object DestroyWindow(object args);
    [SecurityCriticalAttribute]
internal static object UnregisterClass(object arg);
}
[SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal class MS.Win32.HwndWrapperHook : MulticastDelegate {
    public HwndWrapperHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal static class MS.Win32.ManagedWndProcTracker : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static ManagedWndProcTracker();
    [SecurityCriticalAttribute]
internal static void TrackHwndSubclass(HwndSubclass subclass, IntPtr hwnd);
    [SecurityCriticalAttribute]
internal static void UnhookHwndSubclass(HwndSubclass subclass);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Win32.ManifestEtw : object {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback, Void* callbackContext, UInt64& registrationHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 EventUnregister(ulong registrationHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 EventWrite(ulong registrationHandle, EventDescriptor& eventDescriptor, UInt32 userDataCount, EventData* userData);
}
internal class MS.Win32.MessageOnlyHwndWrapper : HwndWrapper {
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.NativeMethods : object {
    public static IntPtr InvalidIntPtr;
    public static IntPtr LPSTR_TEXTCALLBACK;
    public static HandleRef NullHandleRef;
    public static int ERROR;
    public static int BITMAPINFO_MAX_COLORSIZE;
    public static int PAGE_READWRITE;
    public static int FILE_MAP_READ;
    public static int APPCOMMAND_BROWSER_BACKWARD;
    public static int APPCOMMAND_BROWSER_FORWARD;
    public static int APPCOMMAND_BROWSER_REFRESH;
    public static int APPCOMMAND_BROWSER_STOP;
    public static int APPCOMMAND_BROWSER_SEARCH;
    public static int APPCOMMAND_BROWSER_FAVORITES;
    public static int APPCOMMAND_BROWSER_HOME;
    public static int APPCOMMAND_VOLUME_MUTE;
    public static int APPCOMMAND_VOLUME_DOWN;
    public static int APPCOMMAND_VOLUME_UP;
    public static int APPCOMMAND_MEDIA_NEXTTRACK;
    public static int APPCOMMAND_MEDIA_PREVIOUSTRACK;
    public static int APPCOMMAND_MEDIA_STOP;
    public static int APPCOMMAND_MEDIA_PLAY_PAUSE;
    public static int APPCOMMAND_LAUNCH_MAIL;
    public static int APPCOMMAND_LAUNCH_MEDIA_SELECT;
    public static int APPCOMMAND_LAUNCH_APP1;
    public static int APPCOMMAND_LAUNCH_APP2;
    public static int APPCOMMAND_BASS_DOWN;
    public static int APPCOMMAND_BASS_BOOST;
    public static int APPCOMMAND_BASS_UP;
    public static int APPCOMMAND_TREBLE_DOWN;
    public static int APPCOMMAND_TREBLE_UP;
    public static int APPCOMMAND_MICROPHONE_VOLUME_MUTE;
    public static int APPCOMMAND_MICROPHONE_VOLUME_DOWN;
    public static int APPCOMMAND_MICROPHONE_VOLUME_UP;
    public static int APPCOMMAND_HELP;
    public static int APPCOMMAND_FIND;
    public static int APPCOMMAND_NEW;
    public static int APPCOMMAND_OPEN;
    public static int APPCOMMAND_CLOSE;
    public static int APPCOMMAND_SAVE;
    public static int APPCOMMAND_PRINT;
    public static int APPCOMMAND_UNDO;
    public static int APPCOMMAND_REDO;
    public static int APPCOMMAND_COPY;
    public static int APPCOMMAND_CUT;
    public static int APPCOMMAND_PASTE;
    public static int APPCOMMAND_REPLY_TO_MAIL;
    public static int APPCOMMAND_FORWARD_MAIL;
    public static int APPCOMMAND_SEND_MAIL;
    public static int APPCOMMAND_SPELL_CHECK;
    public static int APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE;
    public static int APPCOMMAND_MIC_ON_OFF_TOGGLE;
    public static int APPCOMMAND_CORRECTION_LIST;
    public static int APPCOMMAND_MEDIA_PLAY;
    public static int APPCOMMAND_MEDIA_PAUSE;
    public static int APPCOMMAND_MEDIA_RECORD;
    public static int APPCOMMAND_MEDIA_FAST_FORWARD;
    public static int APPCOMMAND_MEDIA_REWIND;
    public static int APPCOMMAND_MEDIA_CHANNEL_UP;
    public static int APPCOMMAND_MEDIA_CHANNEL_DOWN;
    public static int FAPPCOMMAND_MOUSE;
    public static int FAPPCOMMAND_KEY;
    public static int FAPPCOMMAND_OEM;
    public static int FAPPCOMMAND_MASK;
    public static int BI_RGB;
    public static int BITSPIXEL;
    public static int cmb4;
    public static int CS_DBLCLKS;
    public static int CS_DROPSHADOW;
    public static int CS_SAVEBITS;
    public static int CF_TEXT;
    public static int CF_BITMAP;
    public static int CF_METAFILEPICT;
    public static int CF_SYLK;
    public static int CF_DIF;
    public static int CF_TIFF;
    public static int CF_OEMTEXT;
    public static int CF_DIB;
    public static int CF_PALETTE;
    public static int CF_PENDATA;
    public static int CF_RIFF;
    public static int CF_WAVE;
    public static int CF_UNICODETEXT;
    public static int CF_ENHMETAFILE;
    public static int CF_HDROP;
    public static int CF_LOCALE;
    public static int CLSCTX_INPROC_SERVER;
    public static int CLSCTX_LOCAL_SERVER;
    public static int CW_USEDEFAULT;
    public static int CWP_SKIPINVISIBLE;
    public static int COLOR_WINDOW;
    public static int CB_ERR;
    public static int CBN_SELCHANGE;
    public static int CBN_DBLCLK;
    public static int CBN_EDITCHANGE;
    public static int CBN_EDITUPDATE;
    public static int CBN_DROPDOWN;
    public static int CBN_CLOSEUP;
    public static int CBN_SELENDOK;
    public static int CBS_SIMPLE;
    public static int CBS_DROPDOWN;
    public static int CBS_DROPDOWNLIST;
    public static int CBS_OWNERDRAWFIXED;
    public static int CBS_OWNERDRAWVARIABLE;
    public static int CBS_AUTOHSCROLL;
    public static int CBS_HASSTRINGS;
    public static int CBS_NOINTEGRALHEIGHT;
    public static int CB_GETEDITSEL;
    public static int CB_LIMITTEXT;
    public static int CB_SETEDITSEL;
    public static int CB_ADDSTRING;
    public static int CB_DELETESTRING;
    public static int CB_GETCURSEL;
    public static int CB_GETLBTEXT;
    public static int CB_GETLBTEXTLEN;
    public static int CB_INSERTSTRING;
    public static int CB_RESETCONTENT;
    public static int CB_FINDSTRING;
    public static int CB_SETCURSEL;
    public static int CB_SHOWDROPDOWN;
    public static int CB_GETITEMDATA;
    public static int CB_SETITEMHEIGHT;
    public static int CB_GETITEMHEIGHT;
    public static int CB_GETDROPPEDSTATE;
    public static int CB_FINDSTRINGEXACT;
    public static int CB_SETDROPPEDWIDTH;
    public static int CDRF_DODEFAULT;
    public static int CDRF_NEWFONT;
    public static int CDRF_SKIPDEFAULT;
    public static int CDRF_NOTIFYPOSTPAINT;
    public static int CDRF_NOTIFYITEMDRAW;
    public static int CDRF_NOTIFYSUBITEMDRAW;
    public static int CDDS_PREPAINT;
    public static int CDDS_POSTPAINT;
    public static int CDDS_ITEM;
    public static int CDDS_SUBITEM;
    public static int CDDS_ITEMPREPAINT;
    public static int CDDS_ITEMPOSTPAINT;
    public static int CDIS_SELECTED;
    public static int CDIS_GRAYED;
    public static int CDIS_DISABLED;
    public static int CDIS_CHECKED;
    public static int CDIS_FOCUS;
    public static int CDIS_DEFAULT;
    public static int CDIS_HOT;
    public static int CDIS_MARKED;
    public static int CDIS_INDETERMINATE;
    public static int CDIS_SHOWKEYBOARDCUES;
    public static int CLR_NONE;
    public static int CLR_DEFAULT;
    public static int CCM_SETVERSION;
    public static int CCM_GETVERSION;
    public static int CCS_NORESIZE;
    public static int CCS_NOPARENTALIGN;
    public static int CCS_NODIVIDER;
    public static int CBEM_INSERTITEMA;
    public static int CBEM_GETITEMA;
    public static int CBEM_SETITEMA;
    public static int CBEM_INSERTITEMW;
    public static int CBEM_SETITEMW;
    public static int CBEM_GETITEMW;
    public static int CBEN_ENDEDITA;
    public static int CBEN_ENDEDITW;
    public static int CONNECT_E_NOCONNECTION;
    public static int CONNECT_E_CANNOTCONNECT;
    public static int CTRLINFO_EATS_RETURN;
    public static int CTRLINFO_EATS_ESCAPE;
    public static int CSIDL_DESKTOP;
    public static int CSIDL_INTERNET;
    public static int CSIDL_PROGRAMS;
    public static int CSIDL_PERSONAL;
    public static int CSIDL_FAVORITES;
    public static int CSIDL_STARTUP;
    public static int CSIDL_RECENT;
    public static int CSIDL_SENDTO;
    public static int CSIDL_STARTMENU;
    public static int CSIDL_DESKTOPDIRECTORY;
    public static int CSIDL_TEMPLATES;
    public static int CSIDL_APPDATA;
    public static int CSIDL_LOCAL_APPDATA;
    public static int CSIDL_INTERNET_CACHE;
    public static int CSIDL_COOKIES;
    public static int CSIDL_HISTORY;
    public static int CSIDL_COMMON_APPDATA;
    public static int CSIDL_SYSTEM;
    public static int CSIDL_PROGRAM_FILES;
    public static int CSIDL_PROGRAM_FILES_COMMON;
    public static int DUPLICATE;
    public static int DISPID_VALUE;
    public static int DISPID_UNKNOWN;
    public static int DISPID_PROPERTYPUT;
    public static int DISPATCH_METHOD;
    public static int DISPATCH_PROPERTYGET;
    public static int DISPATCH_PROPERTYPUT;
    public static int DISPATCH_PROPERTYPUTREF;
    public static int DV_E_DVASPECT;
    public static int DEFAULT_GUI_FONT;
    public static int DIB_RGB_COLORS;
    public static int DRAGDROP_E_NOTREGISTERED;
    public static int DRAGDROP_E_ALREADYREGISTERED;
    public static int DUPLICATE_SAME_ACCESS;
    public static int DFC_CAPTION;
    public static int DFC_MENU;
    public static int DFC_SCROLL;
    public static int DFC_BUTTON;
    public static int DFCS_CAPTIONCLOSE;
    public static int DFCS_CAPTIONMIN;
    public static int DFCS_CAPTIONMAX;
    public static int DFCS_CAPTIONRESTORE;
    public static int DFCS_CAPTIONHELP;
    public static int DFCS_MENUARROW;
    public static int DFCS_MENUCHECK;
    public static int DFCS_MENUBULLET;
    public static int DFCS_SCROLLUP;
    public static int DFCS_SCROLLDOWN;
    public static int DFCS_SCROLLLEFT;
    public static int DFCS_SCROLLRIGHT;
    public static int DFCS_SCROLLCOMBOBOX;
    public static int DFCS_BUTTONCHECK;
    public static int DFCS_BUTTONRADIO;
    public static int DFCS_BUTTON3STATE;
    public static int DFCS_BUTTONPUSH;
    public static int DFCS_INACTIVE;
    public static int DFCS_PUSHED;
    public static int DFCS_CHECKED;
    public static int DFCS_FLAT;
    public static int DT_LEFT;
    public static int DT_RIGHT;
    public static int DT_VCENTER;
    public static int DT_SINGLELINE;
    public static int DT_NOCLIP;
    public static int DT_CALCRECT;
    public static int DT_NOPREFIX;
    public static int DT_EDITCONTROL;
    public static int DT_EXPANDTABS;
    public static int DT_END_ELLIPSIS;
    public static int DT_RTLREADING;
    public static int DT_WORDBREAK;
    public static int DCX_WINDOW;
    public static int DCX_CACHE;
    public static int DCX_LOCKWINDOWUPDATE;
    public static int DI_NORMAL;
    public static int DLGC_WANTARROWS;
    public static int DLGC_WANTTAB;
    public static int DLGC_WANTALLKEYS;
    public static int DLGC_WANTCHARS;
    public static int DTM_GETSYSTEMTIME;
    public static int DTM_SETSYSTEMTIME;
    public static int DTM_SETRANGE;
    public static int DTM_SETFORMATA;
    public static int DTM_SETFORMATW;
    public static int DTM_SETMCCOLOR;
    public static int DTM_SETMCFONT;
    public static int DTS_UPDOWN;
    public static int DTS_SHOWNONE;
    public static int DTS_LONGDATEFORMAT;
    public static int DTS_TIMEFORMAT;
    public static int DTS_RIGHTALIGN;
    public static int DTN_DATETIMECHANGE;
    public static int DTN_USERSTRINGA;
    public static int DTN_USERSTRINGW;
    public static int DTN_WMKEYDOWNA;
    public static int DTN_WMKEYDOWNW;
    public static int DTN_FORMATA;
    public static int DTN_FORMATW;
    public static int DTN_FORMATQUERYA;
    public static int DTN_FORMATQUERYW;
    public static int DTN_DROPDOWN;
    public static int DTN_CLOSEUP;
    public static int DVASPECT_CONTENT;
    public static int DVASPECT_TRANSPARENT;
    public static int DVASPECT_OPAQUE;
    public static int E_NOTIMPL;
    public static int E_OUTOFMEMORY;
    public static int E_INVALIDARG;
    public static int E_NOINTERFACE;
    public static int E_FAIL;
    public static int E_ABORT;
    public static int E_UNEXPECTED;
    public static int INET_E_DEFAULT_ACTION;
    public static int ETO_OPAQUE;
    public static int ETO_CLIPPED;
    public static int EMR_POLYTEXTOUTA;
    public static int EMR_POLYTEXTOUTW;
    public static int EDGE_RAISED;
    public static int EDGE_SUNKEN;
    public static int EDGE_ETCHED;
    public static int EDGE_BUMP;
    public static int ES_LEFT;
    public static int ES_CENTER;
    public static int ES_RIGHT;
    public static int ES_MULTILINE;
    public static int ES_UPPERCASE;
    public static int ES_LOWERCASE;
    public static int ES_AUTOVSCROLL;
    public static int ES_AUTOHSCROLL;
    public static int ES_NOHIDESEL;
    public static int ES_READONLY;
    public static int ES_PASSWORD;
    public static int EN_CHANGE;
    public static int EN_UPDATE;
    public static int EN_HSCROLL;
    public static int EN_VSCROLL;
    public static int EN_ALIGN_LTR_EC;
    public static int EN_ALIGN_RTL_EC;
    public static int EC_LEFTMARGIN;
    public static int EC_RIGHTMARGIN;
    public static int EM_GETSEL;
    public static int EM_SETSEL;
    public static int EM_SCROLL;
    public static int EM_SCROLLCARET;
    public static int EM_GETMODIFY;
    public static int EM_SETMODIFY;
    public static int EM_GETLINECOUNT;
    public static int EM_REPLACESEL;
    public static int EM_GETLINE;
    public static int EM_LIMITTEXT;
    public static int EM_CANUNDO;
    public static int EM_UNDO;
    public static int EM_SETPASSWORDCHAR;
    public static int EM_GETPASSWORDCHAR;
    public static int EM_EMPTYUNDOBUFFER;
    public static int EM_SETREADONLY;
    public static int EM_SETMARGINS;
    public static int EM_POSFROMCHAR;
    public static int EM_CHARFROMPOS;
    public static int EM_LINEFROMCHAR;
    public static int EM_LINEINDEX;
    public static int FNERR_SUBCLASSFAILURE;
    public static int FNERR_INVALIDFILENAME;
    public static int FNERR_BUFFERTOOSMALL;
    public static int GMEM_MOVEABLE;
    public static int GMEM_ZEROINIT;
    public static int GMEM_DDESHARE;
    public static int GCL_WNDPROC;
    public static int GWL_WNDPROC;
    public static int GWL_HWNDPARENT;
    public static int GWL_STYLE;
    public static int GWL_EXSTYLE;
    public static int GWL_ID;
    public static int GW_HWNDFIRST;
    public static int GW_HWNDLAST;
    public static int GW_HWNDNEXT;
    public static int GW_HWNDPREV;
    public static int GW_CHILD;
    public static int GMR_VISIBLE;
    public static int GMR_DAYSTATE;
    public static int GDI_ERROR;
    public static int GDTR_MIN;
    public static int GDTR_MAX;
    public static int GDT_VALID;
    public static int GDT_NONE;
    public static int GA_PARENT;
    public static int GA_ROOT;
    public static int GCS_COMPREADSTR;
    public static int GCS_COMPREADATTR;
    public static int GCS_COMPREADCLAUSE;
    public static int GCS_COMPSTR;
    public static int GCS_COMPATTR;
    public static int GCS_COMPCLAUSE;
    public static int GCS_CURSORPOS;
    public static int GCS_DELTASTART;
    public static int GCS_RESULTREADSTR;
    public static int GCS_RESULTREADCLAUSE;
    public static int GCS_RESULTSTR;
    public static int GCS_RESULTCLAUSE;
    public static int ATTR_INPUT;
    public static int ATTR_TARGET_CONVERTED;
    public static int ATTR_CONVERTED;
    public static int ATTR_TARGET_NOTCONVERTED;
    public static int ATTR_INPUT_ERROR;
    public static int ATTR_FIXEDCONVERTED;
    public static int NI_COMPOSITIONSTR;
    public static int IMN_CLOSESTATUSWINDOW;
    public static int IMN_OPENSTATUSWINDOW;
    public static int IMN_CHANGECANDIDATE;
    public static int IMN_CLOSECANDIDATE;
    public static int IMN_OPENCANDIDATE;
    public static int IMN_SETCONVERSIONMODE;
    public static int IMN_SETSENTENCEMODE;
    public static int IMN_SETOPENSTATUS;
    public static int IMN_SETCANDIDATEPOS;
    public static int IMN_SETCOMPOSITIONFONT;
    public static int IMN_SETCOMPOSITIONWINDOW;
    public static int IMN_SETSTATUSWINDOWPOS;
    public static int IMN_GUIDELINE;
    public static int IMN_PRIVATE;
    public static int CPS_COMPLETE;
    public static int CPS_CANCEL;
    public static int CFS_DEFAULT;
    public static int CFS_RECT;
    public static int CFS_POINT;
    public static int CFS_FORCE_POSITION;
    public static int CFS_CANDIDATEPOS;
    public static int CFS_EXCLUDE;
    public static int IME_CMODE_ALPHANUMERIC;
    public static int IME_CMODE_NATIVE;
    public static int IME_CMODE_CHINESE;
    public static int IME_CMODE_HANGEUL;
    public static int IME_CMODE_HANGUL;
    public static int IME_CMODE_JAPANESE;
    public static int IME_CMODE_KATAKANA;
    public static int IME_CMODE_LANGUAGE;
    public static int IME_CMODE_FULLSHAPE;
    public static int IME_CMODE_ROMAN;
    public static int IME_CMODE_CHARCODE;
    public static int IME_CMODE_HANJACONVERT;
    public static int IME_CMODE_SOFTKBD;
    public static int IME_CMODE_NOCONVERSION;
    public static int IME_CMODE_EUDC;
    public static int IME_CMODE_SYMBOL;
    public static int IME_CMODE_FIXED;
    public static int IME_CMODE_RESERVED;
    public static int IME_SMODE_NONE;
    public static int IME_SMODE_PLAURALCLAUSE;
    public static int IME_SMODE_SINGLECONVERT;
    public static int IME_SMODE_AUTOMATIC;
    public static int IME_SMODE_PHRASEPREDICT;
    public static int IME_SMODE_CONVERSATION;
    public static int IME_SMODE_RESERVED;
    public static int IME_CAND_UNKNOWN;
    public static int IME_CAND_READ;
    public static int IME_CAND_CODE;
    public static int IME_CAND_MEANING;
    public static int IME_CAND_RADICAL;
    public static int IME_CAND_STROKE;
    public static int IMR_COMPOSITIONWINDOW;
    public static int IMR_CANDIDATEWINDOW;
    public static int IMR_COMPOSITIONFONT;
    public static int IMR_RECONVERTSTRING;
    public static int IMR_CONFIRMRECONVERTSTRING;
    public static int IMR_QUERYCHARPOSITION;
    public static int IMR_DOCUMENTFEED;
    public static int IME_CONFIG_GENERAL;
    public static int IME_CONFIG_REGISTERWORD;
    public static int IME_CONFIG_SELECTDICTIONARY;
    public static int IGP_GETIMEVERSION;
    public static int IGP_PROPERTY;
    public static int IGP_CONVERSION;
    public static int IGP_SENTENCE;
    public static int IGP_UI;
    public static int IGP_SETCOMPSTR;
    public static int IGP_SELECT;
    public static int IME_PROP_AT_CARET;
    public static int IME_PROP_SPECIAL_UI;
    public static int IME_PROP_CANDLIST_START_FROM_1;
    public static int IME_PROP_UNICODE;
    public static int IME_PROP_COMPLETE_ON_UNSELECT;
    public static int HC_ACTION;
    public static int HC_GETNEXT;
    public static int HC_SKIP;
    public static int HTNOWHERE;
    public static int HTCLIENT;
    public static int HTBOTTOM;
    public static int HTTRANSPARENT;
    public static int HTBOTTOMLEFT;
    public static int HTBOTTOMRIGHT;
    public static int HELPINFO_WINDOW;
    public static int HCF_HIGHCONTRASTON;
    public static int HDI_ORDER;
    public static int HDI_WIDTH;
    public static int HDM_GETITEMCOUNT;
    public static int HDM_INSERTITEMA;
    public static int HDM_INSERTITEMW;
    public static int HDM_GETITEMA;
    public static int HDM_GETITEMW;
    public static int HDM_SETITEMA;
    public static int HDM_SETITEMW;
    public static int HDN_ITEMCHANGINGA;
    public static int HDN_ITEMCHANGINGW;
    public static int HDN_ITEMCHANGEDA;
    public static int HDN_ITEMCHANGEDW;
    public static int HDN_ITEMCLICKA;
    public static int HDN_ITEMCLICKW;
    public static int HDN_ITEMDBLCLICKA;
    public static int HDN_ITEMDBLCLICKW;
    public static int HDN_DIVIDERDBLCLICKA;
    public static int HDN_DIVIDERDBLCLICKW;
    public static int HDN_BEGINTDRAG;
    public static int HDN_BEGINTRACKA;
    public static int HDN_BEGINTRACKW;
    public static int HDN_ENDDRAG;
    public static int HDN_ENDTRACKA;
    public static int HDN_ENDTRACKW;
    public static int HDN_TRACKA;
    public static int HDN_TRACKW;
    public static int HDN_GETDISPINFOA;
    public static int HDN_GETDISPINFOW;
    public static HandleRef HWND_TOP;
    public static HandleRef HWND_BOTTOM;
    public static HandleRef HWND_TOPMOST;
    public static HandleRef HWND_NOTOPMOST;
    public static int INPLACE_E_NOTOOLSPACE;
    public static int ICON_SMALL;
    public static int ICON_BIG;
    public static int IDC_ARROW;
    public static int IDC_IBEAM;
    public static int IDC_WAIT;
    public static int IDC_CROSS;
    public static int IDC_SIZEALL;
    public static int IDC_SIZENWSE;
    public static int IDC_SIZENESW;
    public static int IDC_SIZEWE;
    public static int IDC_SIZENS;
    public static int IDC_UPARROW;
    public static int IDC_NO;
    public static int IDC_APPSTARTING;
    public static int IDC_HELP;
    public static int IMAGE_ICON;
    public static int IMAGE_CURSOR;
    public static int ICC_LISTVIEW_CLASSES;
    public static int ICC_TREEVIEW_CLASSES;
    public static int ICC_BAR_CLASSES;
    public static int ICC_TAB_CLASSES;
    public static int ICC_PROGRESS_CLASS;
    public static int ICC_DATE_CLASSES;
    public static int ILC_MASK;
    public static int ILC_COLOR;
    public static int ILC_COLOR4;
    public static int ILC_COLOR8;
    public static int ILC_COLOR16;
    public static int ILC_COLOR24;
    public static int ILC_COLOR32;
    public static int ILC_MIRROR;
    public static int ILD_NORMAL;
    public static int ILD_TRANSPARENT;
    public static int ILD_MASK;
    public static int ILD_ROP;
    public static int ILP_NORMAL;
    public static int ILP_DOWNLEVEL;
    public static int ILS_NORMAL;
    public static int ILS_GLOW;
    public static int ILS_SHADOW;
    public static int ILS_SATURATE;
    public static int ILS_ALPHA;
    public static int CSC_NAVIGATEFORWARD;
    public static int CSC_NAVIGATEBACK;
    public static int STG_E_CANTSAVE;
    public static int LOGPIXELSX;
    public static int LOGPIXELSY;
    public static int LB_ERR;
    public static int LB_ERRSPACE;
    public static int LBN_SELCHANGE;
    public static int LBN_DBLCLK;
    public static int LB_ADDSTRING;
    public static int LB_INSERTSTRING;
    public static int LB_DELETESTRING;
    public static int LB_RESETCONTENT;
    public static int LB_SETSEL;
    public static int LB_SETCURSEL;
    public static int LB_GETSEL;
    public static int LB_GETCARETINDEX;
    public static int LB_GETCURSEL;
    public static int LB_GETTEXT;
    public static int LB_GETTEXTLEN;
    public static int LB_GETTOPINDEX;
    public static int LB_FINDSTRING;
    public static int LB_GETSELCOUNT;
    public static int LB_GETSELITEMS;
    public static int LB_SETTABSTOPS;
    public static int LB_SETHORIZONTALEXTENT;
    public static int LB_SETCOLUMNWIDTH;
    public static int LB_SETTOPINDEX;
    public static int LB_GETITEMRECT;
    public static int LB_SETITEMHEIGHT;
    public static int LB_GETITEMHEIGHT;
    public static int LB_FINDSTRINGEXACT;
    public static int LB_ITEMFROMPOINT;
    public static int LB_SETLOCALE;
    public static int LWA_ALPHA;
    public static int MEMBERID_NIL;
    public static int MAX_PATH;
    public static int MA_ACTIVATE;
    public static int MA_ACTIVATEANDEAT;
    public static int MA_NOACTIVATE;
    public static int MA_NOACTIVATEANDEAT;
    public static int MM_TEXT;
    public static int MM_ANISOTROPIC;
    public static int MK_LBUTTON;
    public static int MK_RBUTTON;
    public static int MK_SHIFT;
    public static int MK_CONTROL;
    public static int MK_MBUTTON;
    public static int MNC_EXECUTE;
    public static int MNC_SELECT;
    public static int MIIM_STATE;
    public static int MIIM_ID;
    public static int MIIM_SUBMENU;
    public static int MIIM_TYPE;
    public static int MIIM_DATA;
    public static int MIIM_STRING;
    public static int MIIM_BITMAP;
    public static int MIIM_FTYPE;
    public static int MB_OK;
    public static int MF_BYCOMMAND;
    public static int MF_BYPOSITION;
    public static int MF_ENABLED;
    public static int MF_GRAYED;
    public static int MF_POPUP;
    public static int MF_SYSMENU;
    public static int MFS_DISABLED;
    public static int MFT_MENUBREAK;
    public static int MFT_SEPARATOR;
    public static int MFT_RIGHTORDER;
    public static int MFT_RIGHTJUSTIFY;
    public static int MDIS_ALLCHILDSTYLES;
    public static int MDITILE_VERTICAL;
    public static int MDITILE_HORIZONTAL;
    public static int MDITILE_SKIPDISABLED;
    public static int MCM_SETMAXSELCOUNT;
    public static int MCM_SETSELRANGE;
    public static int MCM_GETMONTHRANGE;
    public static int MCM_GETMINREQRECT;
    public static int MCM_SETCOLOR;
    public static int MCM_SETTODAY;
    public static int MCM_GETTODAY;
    public static int MCM_HITTEST;
    public static int MCM_SETFIRSTDAYOFWEEK;
    public static int MCM_SETRANGE;
    public static int MCM_SETMONTHDELTA;
    public static int MCM_GETMAXTODAYWIDTH;
    public static int MCHT_TITLE;
    public static int MCHT_CALENDAR;
    public static int MCHT_TODAYLINK;
    public static int MCHT_TITLEBK;
    public static int MCHT_TITLEMONTH;
    public static int MCHT_TITLEYEAR;
    public static int MCHT_TITLEBTNNEXT;
    public static int MCHT_TITLEBTNPREV;
    public static int MCHT_CALENDARBK;
    public static int MCHT_CALENDARDATE;
    public static int MCHT_CALENDARDATENEXT;
    public static int MCHT_CALENDARDATEPREV;
    public static int MCHT_CALENDARDAY;
    public static int MCHT_CALENDARWEEKNUM;
    public static int MCSC_TEXT;
    public static int MCSC_TITLEBK;
    public static int MCSC_TITLETEXT;
    public static int MCSC_MONTHBK;
    public static int MCSC_TRAILINGTEXT;
    public static int MCN_SELCHANGE;
    public static int MCN_GETDAYSTATE;
    public static int MCN_SELECT;
    public static int MCS_DAYSTATE;
    public static int MCS_MULTISELECT;
    public static int MCS_WEEKNUMBERS;
    public static int MCS_NOTODAYCIRCLE;
    public static int MCS_NOTODAY;
    public static int MSAA_MENU_SIG;
    public static int OLECONTF_EMBEDDINGS;
    public static int OLECONTF_LINKS;
    public static int OLECONTF_OTHERS;
    public static int OLECONTF_ONLYUSER;
    public static int OLECONTF_ONLYIFRUNNING;
    public static int OLEMISC_RECOMPOSEONRESIZE;
    public static int OLEMISC_INSIDEOUT;
    public static int OLEMISC_ACTIVATEWHENVISIBLE;
    public static int OLEMISC_ACTSLIKEBUTTON;
    public static int OLEMISC_SETCLIENTSITEFIRST;
    public static int OLEIVERB_PRIMARY;
    public static int OLEIVERB_SHOW;
    public static int OLEIVERB_HIDE;
    public static int OLEIVERB_UIACTIVATE;
    public static int OLEIVERB_INPLACEACTIVATE;
    public static int OLEIVERB_DISCARDUNDOSTATE;
    public static int OLEIVERB_PROPERTIES;
    public static int XFORMCOORDS_POSITION;
    public static int XFORMCOORDS_SIZE;
    public static int XFORMCOORDS_HIMETRICTOCONTAINER;
    public static int XFORMCOORDS_CONTAINERTOHIMETRIC;
    public static int OFN_READONLY;
    public static int OFN_OVERWRITEPROMPT;
    public static int OFN_HIDEREADONLY;
    public static int OFN_NOCHANGEDIR;
    public static int OFN_ENABLEHOOK;
    public static int OFN_NOVALIDATE;
    public static int OFN_ALLOWMULTISELECT;
    public static int OFN_PATHMUSTEXIST;
    public static int OFN_FILEMUSTEXIST;
    public static int OFN_CREATEPROMPT;
    public static int OFN_EXPLORER;
    public static int OFN_NODEREFERENCELINKS;
    public static int OFN_ENABLESIZING;
    public static int OFN_USESHELLITEM;
    public static int PDERR_SETUPFAILURE;
    public static int PDERR_PARSEFAILURE;
    public static int PDERR_RETDEFFAILURE;
    public static int PDERR_LOADDRVFAILURE;
    public static int PDERR_GETDEVMODEFAIL;
    public static int PDERR_INITFAILURE;
    public static int PDERR_NODEVICES;
    public static int PDERR_NODEFAULTPRN;
    public static int PDERR_DNDMMISMATCH;
    public static int PDERR_CREATEICFAILURE;
    public static int PDERR_PRINTERNOTFOUND;
    public static int PDERR_DEFAULTDIFFERENT;
    public static int PD_ALLPAGES;
    public static int PD_SELECTION;
    public static int PD_PAGENUMS;
    public static int PD_NOSELECTION;
    public static int PD_NOPAGENUMS;
    public static int PD_COLLATE;
    public static int PD_PRINTTOFILE;
    public static int PD_PRINTSETUP;
    public static int PD_NOWARNING;
    public static int PD_RETURNDC;
    public static int PD_RETURNIC;
    public static int PD_RETURNDEFAULT;
    public static int PD_SHOWHELP;
    public static int PD_ENABLEPRINTHOOK;
    public static int PD_ENABLESETUPHOOK;
    public static int PD_ENABLEPRINTTEMPLATE;
    public static int PD_ENABLESETUPTEMPLATE;
    public static int PD_ENABLEPRINTTEMPLATEHANDLE;
    public static int PD_ENABLESETUPTEMPLATEHANDLE;
    public static int PD_USEDEVMODECOPIES;
    public static int PD_USEDEVMODECOPIESANDCOLLATE;
    public static int PD_DISABLEPRINTTOFILE;
    public static int PD_HIDEPRINTTOFILE;
    public static int PD_NONETWORKBUTTON;
    public static int PD_CURRENTPAGE;
    public static int PD_NOCURRENTPAGE;
    public static int PD_EXCLUSIONFLAGS;
    public static int PD_USELARGETEMPLATE;
    public static int PSD_MINMARGINS;
    public static int PSD_MARGINS;
    public static int PSD_INHUNDREDTHSOFMILLIMETERS;
    public static int PSD_DISABLEMARGINS;
    public static int PSD_DISABLEPRINTER;
    public static int PSD_DISABLEORIENTATION;
    public static int PSD_DISABLEPAPER;
    public static int PSD_SHOWHELP;
    public static int PSD_ENABLEPAGESETUPHOOK;
    public static int PSD_NONETWORKBUTTON;
    public static int PS_SOLID;
    public static int PS_DOT;
    public static int PLANES;
    public static int PRF_CHECKVISIBLE;
    public static int PRF_NONCLIENT;
    public static int PRF_CLIENT;
    public static int PRF_ERASEBKGND;
    public static int PRF_CHILDREN;
    public static int PM_NOREMOVE;
    public static int PM_REMOVE;
    public static int PM_NOYIELD;
    public static int PBM_SETRANGE;
    public static int PBM_SETPOS;
    public static int PBM_SETSTEP;
    public static int PBM_SETRANGE32;
    public static int PBM_SETBARCOLOR;
    public static int PBM_SETBKCOLOR;
    public static int PSM_SETTITLEA;
    public static int PSM_SETTITLEW;
    public static int PSM_SETFINISHTEXTA;
    public static int PSM_SETFINISHTEXTW;
    public static int PATCOPY;
    public static int PATINVERT;
    public static int QS_KEY;
    public static int QS_MOUSEMOVE;
    public static int QS_MOUSEBUTTON;
    public static int QS_POSTMESSAGE;
    public static int QS_TIMER;
    public static int QS_PAINT;
    public static int QS_SENDMESSAGE;
    public static int QS_HOTKEY;
    public static int QS_ALLPOSTMESSAGE;
    public static int QS_MOUSE;
    public static int QS_INPUT;
    public static int QS_ALLEVENTS;
    public static int QS_ALLINPUT;
    public static int RDW_INVALIDATE;
    public static int RDW_ALLCHILDREN;
    public static int stc4;
    public static int SHGFP_TYPE_CURRENT;
    public static int STGM_READ;
    public static int STGM_WRITE;
    public static int STGM_READWRITE;
    public static int STGM_SHARE_EXCLUSIVE;
    public static int STGM_CREATE;
    public static int STGM_TRANSACTED;
    public static int STGM_CONVERT;
    public static int STGM_DELETEONRELEASE;
    public static int STGTY_STORAGE;
    public static int STGTY_STREAM;
    public static int STGTY_LOCKBYTES;
    public static int STGTY_PROPERTY;
    public static int STARTF_USESHOWWINDOW;
    public static int SB_HORZ;
    public static int SB_VERT;
    public static int SB_CTL;
    public static int SB_LINEUP;
    public static int SB_LINELEFT;
    public static int SB_LINEDOWN;
    public static int SB_LINERIGHT;
    public static int SB_PAGEUP;
    public static int SB_PAGELEFT;
    public static int SB_PAGEDOWN;
    public static int SB_PAGERIGHT;
    public static int SB_THUMBPOSITION;
    public static int SB_THUMBTRACK;
    public static int SB_LEFT;
    public static int SB_RIGHT;
    public static int SB_ENDSCROLL;
    public static int SB_TOP;
    public static int SB_BOTTOM;
    public static int SIZE_MAXIMIZED;
    public static int ESB_ENABLE_BOTH;
    public static int ESB_DISABLE_BOTH;
    public static int SORT_DEFAULT;
    public static int SUBLANG_DEFAULT;
    public static int SW_HIDE;
    public static int SW_NORMAL;
    public static int SW_SHOWMINIMIZED;
    public static int SW_SHOWMAXIMIZED;
    public static int SW_MAXIMIZE;
    public static int SW_SHOWNOACTIVATE;
    public static int SW_SHOW;
    public static int SW_MINIMIZE;
    public static int SW_SHOWMINNOACTIVE;
    public static int SW_SHOWNA;
    public static int SW_RESTORE;
    public static int SW_MAX;
    public static int SWP_NOSIZE;
    public static int SWP_NOMOVE;
    public static int SWP_NOZORDER;
    public static int SWP_NOACTIVATE;
    public static int SWP_SHOWWINDOW;
    public static int SWP_HIDEWINDOW;
    public static int SWP_DRAWFRAME;
    public static int MB_ICONHAND;
    public static int MB_ICONQUESTION;
    public static int MB_ICONEXCLAMATION;
    public static int MB_ICONASTERISK;
    public static int SW_SCROLLCHILDREN;
    public static int SW_INVALIDATE;
    public static int SW_ERASE;
    public static int SW_SMOOTHSCROLL;
    public static int SC_SIZE;
    public static int SC_MINIMIZE;
    public static int SC_MAXIMIZE;
    public static int SC_CLOSE;
    public static int SC_KEYMENU;
    public static int SC_RESTORE;
    public static int SC_MOVE;
    public static int SS_LEFT;
    public static int SS_CENTER;
    public static int SS_RIGHT;
    public static int SS_OWNERDRAW;
    public static int SS_NOPREFIX;
    public static int SS_SUNKEN;
    public static int SBS_HORZ;
    public static int SBS_VERT;
    public static int SIF_RANGE;
    public static int SIF_PAGE;
    public static int SIF_POS;
    public static int SIF_TRACKPOS;
    public static int SIF_ALL;
    public static int SPI_GETFONTSMOOTHING;
    public static int SPI_GETDROPSHADOW;
    public static int SPI_GETFLATMENU;
    public static int SPI_GETFONTSMOOTHINGTYPE;
    public static int SPI_GETFONTSMOOTHINGCONTRAST;
    public static int SPI_ICONHORIZONTALSPACING;
    public static int SPI_ICONVERTICALSPACING;
    public static int SPI_GETICONMETRICS;
    public static int SPI_GETICONTITLEWRAP;
    public static int SPI_GETICONTITLELOGFONT;
    public static int SPI_GETKEYBOARDCUES;
    public static int SPI_GETKEYBOARDDELAY;
    public static int SPI_GETKEYBOARDPREF;
    public static int SPI_GETKEYBOARDSPEED;
    public static int SPI_GETMOUSEHOVERWIDTH;
    public static int SPI_GETMOUSEHOVERHEIGHT;
    public static int SPI_GETMOUSEHOVERTIME;
    public static int SPI_GETMOUSESPEED;
    public static int SPI_GETMENUDROPALIGNMENT;
    public static int SPI_GETMENUFADE;
    public static int SPI_GETMENUSHOWDELAY;
    public static int SPI_GETCOMBOBOXANIMATION;
    public static int SPI_GETCLIENTAREAANIMATION;
    public static int SPI_GETGRADIENTCAPTIONS;
    public static int SPI_GETHOTTRACKING;
    public static int SPI_GETLISTBOXSMOOTHSCROLLING;
    public static int SPI_GETMENUANIMATION;
    public static int SPI_GETSELECTIONFADE;
    public static int SPI_GETTOOLTIPANIMATION;
    public static int SPI_GETUIEFFECTS;
    public static int SPI_GETACTIVEWINDOWTRACKING;
    public static int SPI_GETACTIVEWNDTRKTIMEOUT;
    public static int SPI_GETANIMATION;
    public static int SPI_GETBORDER;
    public static int SPI_GETCARETWIDTH;
    public static int SPI_GETMOUSEVANISH;
    public static int SPI_GETDRAGFULLWINDOWS;
    public static int SPI_GETNONCLIENTMETRICS;
    public static int SPI_GETWORKAREA;
    public static int SPI_GETHIGHCONTRAST;
    public static int SPI_GETDEFAULTINPUTLANG;
    public static int SPI_GETSNAPTODEFBUTTON;
    public static int SPI_GETWHEELSCROLLLINES;
    public static int SBARS_SIZEGRIP;
    public static int SB_SETTEXTA;
    public static int SB_SETTEXTW;
    public static int SB_GETTEXTA;
    public static int SB_GETTEXTW;
    public static int SB_GETTEXTLENGTHA;
    public static int SB_GETTEXTLENGTHW;
    public static int SB_SETPARTS;
    public static int SB_SIMPLE;
    public static int SB_GETRECT;
    public static int SB_SETICON;
    public static int SB_SETTIPTEXTA;
    public static int SB_SETTIPTEXTW;
    public static int SB_GETTIPTEXTA;
    public static int SB_GETTIPTEXTW;
    public static int SBT_OWNERDRAW;
    public static int SBT_NOBORDERS;
    public static int SBT_POPOUT;
    public static int SBT_RTLREADING;
    public static int SRCCOPY;
    public static int SRCAND;
    public static int SRCPAINT;
    public static int NOTSRCCOPY;
    public static int STATFLAG_DEFAULT;
    public static int STATFLAG_NONAME;
    public static int STATFLAG_NOOPEN;
    public static int STGC_DEFAULT;
    public static int STGC_OVERWRITE;
    public static int STGC_ONLYIFCURRENT;
    public static int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE;
    public static int STREAM_SEEK_SET;
    public static int STREAM_SEEK_CUR;
    public static int STREAM_SEEK_END;
    public static int S_OK;
    public static int S_FALSE;
    public static int TRANSPARENT;
    public static int OPAQUE;
    public static int TME_HOVER;
    public static int TME_LEAVE;
    public static int TPM_LEFTBUTTON;
    public static int TPM_RIGHTBUTTON;
    public static int TPM_LEFTALIGN;
    public static int TPM_RIGHTALIGN;
    public static int TPM_VERTICAL;
    public static int TV_FIRST;
    public static int TBSTATE_CHECKED;
    public static int TBSTATE_ENABLED;
    public static int TBSTATE_HIDDEN;
    public static int TBSTATE_INDETERMINATE;
    public static int TBSTYLE_BUTTON;
    public static int TBSTYLE_SEP;
    public static int TBSTYLE_CHECK;
    public static int TBSTYLE_DROPDOWN;
    public static int TBSTYLE_TOOLTIPS;
    public static int TBSTYLE_FLAT;
    public static int TBSTYLE_LIST;
    public static int TBSTYLE_EX_DRAWDDARROWS;
    public static int TB_ENABLEBUTTON;
    public static int TB_ISBUTTONCHECKED;
    public static int TB_ISBUTTONINDETERMINATE;
    public static int TB_ADDBUTTONSA;
    public static int TB_ADDBUTTONSW;
    public static int TB_INSERTBUTTONA;
    public static int TB_INSERTBUTTONW;
    public static int TB_DELETEBUTTON;
    public static int TB_GETBUTTON;
    public static int TB_SAVERESTOREA;
    public static int TB_SAVERESTOREW;
    public static int TB_ADDSTRINGA;
    public static int TB_ADDSTRINGW;
    public static int TB_BUTTONSTRUCTSIZE;
    public static int TB_SETBUTTONSIZE;
    public static int TB_AUTOSIZE;
    public static int TB_GETROWS;
    public static int TB_GETBUTTONTEXTA;
    public static int TB_GETBUTTONTEXTW;
    public static int TB_SETIMAGELIST;
    public static int TB_GETRECT;
    public static int TB_GETBUTTONSIZE;
    public static int TB_GETBUTTONINFOW;
    public static int TB_SETBUTTONINFOW;
    public static int TB_GETBUTTONINFOA;
    public static int TB_SETBUTTONINFOA;
    public static int TB_MAPACCELERATORA;
    public static int TB_SETEXTENDEDSTYLE;
    public static int TB_MAPACCELERATORW;
    public static int TB_GETTOOLTIPS;
    public static int TB_SETTOOLTIPS;
    public static int TBIF_IMAGE;
    public static int TBIF_TEXT;
    public static int TBIF_STATE;
    public static int TBIF_STYLE;
    public static int TBIF_COMMAND;
    public static int TBIF_SIZE;
    public static int TBN_GETBUTTONINFOA;
    public static int TBN_GETBUTTONINFOW;
    public static int TBN_QUERYINSERT;
    public static int TBN_DROPDOWN;
    public static int TBN_HOTITEMCHANGE;
    public static int TBN_GETDISPINFOA;
    public static int TBN_GETDISPINFOW;
    public static int TBN_GETINFOTIPA;
    public static int TBN_GETINFOTIPW;
    public static int TTS_ALWAYSTIP;
    public static int TTS_NOPREFIX;
    public static int TTS_NOANIMATE;
    public static int TTS_NOFADE;
    public static int TTS_BALLOON;
    public static int TTI_WARNING;
    public static int TTF_IDISHWND;
    public static int TTF_RTLREADING;
    public static int TTF_TRACK;
    public static int TTF_CENTERTIP;
    public static int TTF_SUBCLASS;
    public static int TTF_TRANSPARENT;
    public static int TTF_ABSOLUTE;
    public static int TTDT_AUTOMATIC;
    public static int TTDT_RESHOW;
    public static int TTDT_AUTOPOP;
    public static int TTDT_INITIAL;
    public static int TTM_TRACKACTIVATE;
    public static int TTM_TRACKPOSITION;
    public static int TTM_ACTIVATE;
    public static int TTM_POP;
    public static int TTM_ADJUSTRECT;
    public static int TTM_SETDELAYTIME;
    public static int TTM_SETTITLEA;
    public static int TTM_SETTITLEW;
    public static int TTM_ADDTOOLA;
    public static int TTM_ADDTOOLW;
    public static int TTM_DELTOOLA;
    public static int TTM_DELTOOLW;
    public static int TTM_NEWTOOLRECTA;
    public static int TTM_NEWTOOLRECTW;
    public static int TTM_RELAYEVENT;
    public static int TTM_GETTIPBKCOLOR;
    public static int TTM_SETTIPBKCOLOR;
    public static int TTM_SETTIPTEXTCOLOR;
    public static int TTM_GETTIPTEXTCOLOR;
    public static int TTM_GETTOOLINFOA;
    public static int TTM_GETTOOLINFOW;
    public static int TTM_SETTOOLINFOA;
    public static int TTM_SETTOOLINFOW;
    public static int TTM_HITTESTA;
    public static int TTM_HITTESTW;
    public static int TTM_GETTEXTA;
    public static int TTM_GETTEXTW;
    public static int TTM_UPDATE;
    public static int TTM_UPDATETIPTEXTA;
    public static int TTM_UPDATETIPTEXTW;
    public static int TTM_ENUMTOOLSA;
    public static int TTM_ENUMTOOLSW;
    public static int TTM_GETCURRENTTOOLA;
    public static int TTM_GETCURRENTTOOLW;
    public static int TTM_WINDOWFROMPOINT;
    public static int TTM_GETDELAYTIME;
    public static int TTM_SETMAXTIPWIDTH;
    public static int TTN_GETDISPINFOA;
    public static int TTN_GETDISPINFOW;
    public static int TTN_SHOW;
    public static int TTN_POP;
    public static int TTN_NEEDTEXTA;
    public static int TTN_NEEDTEXTW;
    public static int TBS_AUTOTICKS;
    public static int TBS_VERT;
    public static int TBS_TOP;
    public static int TBS_BOTTOM;
    public static int TBS_BOTH;
    public static int TBS_NOTICKS;
    public static int TBM_GETPOS;
    public static int TBM_SETTIC;
    public static int TBM_SETPOS;
    public static int TBM_SETRANGE;
    public static int TBM_SETRANGEMIN;
    public static int TBM_SETRANGEMAX;
    public static int TBM_SETTICFREQ;
    public static int TBM_SETPAGESIZE;
    public static int TBM_SETLINESIZE;
    public static int TB_LINEUP;
    public static int TB_LINEDOWN;
    public static int TB_PAGEUP;
    public static int TB_PAGEDOWN;
    public static int TB_THUMBPOSITION;
    public static int TB_THUMBTRACK;
    public static int TB_TOP;
    public static int TB_BOTTOM;
    public static int TB_ENDTRACK;
    public static int TVS_HASBUTTONS;
    public static int TVS_HASLINES;
    public static int TVS_LINESATROOT;
    public static int TVS_EDITLABELS;
    public static int TVS_SHOWSELALWAYS;
    public static int TVS_RTLREADING;
    public static int TVS_CHECKBOXES;
    public static int TVS_TRACKSELECT;
    public static int TVS_FULLROWSELECT;
    public static int TVS_NONEVENHEIGHT;
    public static int TVS_INFOTIP;
    public static int TVS_NOTOOLTIPS;
    public static int TVIF_TEXT;
    public static int TVIF_IMAGE;
    public static int TVIF_PARAM;
    public static int TVIF_STATE;
    public static int TVIF_HANDLE;
    public static int TVIF_SELECTEDIMAGE;
    public static int TVIS_SELECTED;
    public static int TVIS_EXPANDED;
    public static int TVIS_EXPANDEDONCE;
    public static int TVIS_STATEIMAGEMASK;
    public static int TVI_ROOT;
    public static int TVI_FIRST;
    public static int TVM_INSERTITEMA;
    public static int TVM_INSERTITEMW;
    public static int TVM_DELETEITEM;
    public static int TVM_EXPAND;
    public static int TVE_COLLAPSE;
    public static int TVE_EXPAND;
    public static int TVM_GETITEMRECT;
    public static int TVM_GETINDENT;
    public static int TVM_SETINDENT;
    public static int TVM_SETIMAGELIST;
    public static int TVM_GETNEXTITEM;
    public static int TVGN_NEXT;
    public static int TVGN_PREVIOUS;
    public static int TVGN_FIRSTVISIBLE;
    public static int TVGN_NEXTVISIBLE;
    public static int TVGN_PREVIOUSVISIBLE;
    public static int TVGN_CARET;
    public static int TVM_SELECTITEM;
    public static int TVM_GETITEMA;
    public static int TVM_GETITEMW;
    public static int TVM_SETITEMA;
    public static int TVM_SETITEMW;
    public static int TVM_EDITLABELA;
    public static int TVM_EDITLABELW;
    public static int TVM_GETEDITCONTROL;
    public static int TVM_GETVISIBLECOUNT;
    public static int TVM_HITTEST;
    public static int TVM_ENSUREVISIBLE;
    public static int TVM_ENDEDITLABELNOW;
    public static int TVM_GETISEARCHSTRINGA;
    public static int TVM_GETISEARCHSTRINGW;
    public static int TVM_SETITEMHEIGHT;
    public static int TVM_GETITEMHEIGHT;
    public static int TVN_SELCHANGINGA;
    public static int TVN_SELCHANGINGW;
    public static int TVN_GETINFOTIPA;
    public static int TVN_GETINFOTIPW;
    public static int TVN_SELCHANGEDA;
    public static int TVN_SELCHANGEDW;
    public static int TVC_UNKNOWN;
    public static int TVC_BYMOUSE;
    public static int TVC_BYKEYBOARD;
    public static int TVN_GETDISPINFOA;
    public static int TVN_GETDISPINFOW;
    public static int TVN_SETDISPINFOA;
    public static int TVN_SETDISPINFOW;
    public static int TVN_ITEMEXPANDINGA;
    public static int TVN_ITEMEXPANDINGW;
    public static int TVN_ITEMEXPANDEDA;
    public static int TVN_ITEMEXPANDEDW;
    public static int TVN_BEGINDRAGA;
    public static int TVN_BEGINDRAGW;
    public static int TVN_BEGINRDRAGA;
    public static int TVN_BEGINRDRAGW;
    public static int TVN_BEGINLABELEDITA;
    public static int TVN_BEGINLABELEDITW;
    public static int TVN_ENDLABELEDITA;
    public static int TVN_ENDLABELEDITW;
    public static int TCS_BOTTOM;
    public static int TCS_RIGHT;
    public static int TCS_FLATBUTTONS;
    public static int TCS_HOTTRACK;
    public static int TCS_VERTICAL;
    public static int TCS_TABS;
    public static int TCS_BUTTONS;
    public static int TCS_MULTILINE;
    public static int TCS_RIGHTJUSTIFY;
    public static int TCS_FIXEDWIDTH;
    public static int TCS_RAGGEDRIGHT;
    public static int TCS_OWNERDRAWFIXED;
    public static int TCS_TOOLTIPS;
    public static int TCM_SETIMAGELIST;
    public static int TCIF_TEXT;
    public static int TCIF_IMAGE;
    public static int TCM_GETITEMA;
    public static int TCM_GETITEMW;
    public static int TCM_SETITEMA;
    public static int TCM_SETITEMW;
    public static int TCM_INSERTITEMA;
    public static int TCM_INSERTITEMW;
    public static int TCM_DELETEITEM;
    public static int TCM_DELETEALLITEMS;
    public static int TCM_GETITEMRECT;
    public static int TCM_GETCURSEL;
    public static int TCM_SETCURSEL;
    public static int TCM_ADJUSTRECT;
    public static int TCM_SETITEMSIZE;
    public static int TCM_SETPADDING;
    public static int TCM_GETROWCOUNT;
    public static int TCM_GETTOOLTIPS;
    public static int TCM_SETTOOLTIPS;
    public static int TCN_SELCHANGE;
    public static int TCN_SELCHANGING;
    public static int TBSTYLE_WRAPPABLE;
    public static int TVM_SETBKCOLOR;
    public static int TVM_SETTEXTCOLOR;
    public static int TYMED_NULL;
    public static int TVM_GETLINECOLOR;
    public static int TVM_SETLINECOLOR;
    public static int TVM_SETTOOLTIPS;
    public static int TVSIL_STATE;
    public static int TVM_SORTCHILDRENCB;
    public static int UIS_SET;
    public static int UIS_CLEAR;
    public static int UIS_INITIALIZE;
    public static int UISF_HIDEFOCUS;
    public static int UISF_HIDEACCEL;
    public static int UISF_ACTIVE;
    public static int VK_TAB;
    public static int VK_SHIFT;
    public static int VK_CONTROL;
    public static int VK_MENU;
    public static int WH_JOURNALPLAYBACK;
    public static int WH_GETMESSAGE;
    public static int WH_MOUSE;
    public static int WSF_VISIBLE;
    public static int WA_INACTIVE;
    public static int WA_ACTIVE;
    public static int WA_CLICKACTIVE;
    public static int WHEEL_DELTA;
    public static int WM_REFLECT;
    public static int WM_CHOOSEFONT_GETLOGFONT;
    public static int WS_OVERLAPPED;
    public static int WS_POPUP;
    public static int WS_CHILD;
    public static int WS_MINIMIZE;
    public static int WS_VISIBLE;
    public static int WS_DISABLED;
    public static int WS_CLIPSIBLINGS;
    public static int WS_CLIPCHILDREN;
    public static int WS_MAXIMIZE;
    public static int WS_CAPTION;
    public static int WS_BORDER;
    public static int WS_DLGFRAME;
    public static int WS_VSCROLL;
    public static int WS_HSCROLL;
    public static int WS_SYSMENU;
    public static int WS_THICKFRAME;
    public static int WS_TABSTOP;
    public static int WS_MINIMIZEBOX;
    public static int WS_MAXIMIZEBOX;
    public static int WS_EX_DLGMODALFRAME;
    public static int WS_EX_TRANSPARENT;
    public static int WS_EX_MDICHILD;
    public static int WS_EX_TOOLWINDOW;
    public static int WS_EX_WINDOWEDGE;
    public static int WS_EX_CLIENTEDGE;
    public static int WS_EX_CONTEXTHELP;
    public static int WS_EX_RIGHT;
    public static int WS_EX_LEFT;
    public static int WS_EX_RTLREADING;
    public static int WS_EX_LEFTSCROLLBAR;
    public static int WS_EX_CONTROLPARENT;
    public static int WS_EX_STATICEDGE;
    public static int WS_EX_APPWINDOW;
    public static int WS_EX_LAYERED;
    public static int WS_EX_TOPMOST;
    public static int WS_EX_LAYOUTRTL;
    public static int WS_EX_NOINHERITLAYOUT;
    public static int WS_EX_COMPOSITED;
    public static int WPF_SETMINPOSITION;
    public static int WPF_RESTORETOMAXIMIZED;
    public static int WHITE_BRUSH;
    public static int NULL_BRUSH;
    public static int XBUTTON1;
    public static int XBUTTON2;
    public static int CDN_FIRST;
    public static int CDN_INITDONE;
    public static int CDN_SELCHANGE;
    public static int CDN_SHAREVIOLATION;
    public static int CDN_FILEOK;
    public static int CDM_FIRST;
    public static int CDM_GETSPEC;
    public static int CDM_GETFILEPATH;
    public static int DWL_MSGRESULT;
    public static int PBT_APMPOWERSTATUSCHANGE;
    public static int EVENT_SYSTEM_MOVESIZESTART;
    public static int EVENT_SYSTEM_MOVESIZEEND;
    public static int EVENT_OBJECT_STATECHANGE;
    public static int EVENT_OBJECT_FOCUS;
    public static int OBJID_CLIENT;
    public static int WINEVENT_OUTOFCONTEXT;
    public static UInt32 RIDI_DEVICEINFO;
    public static UInt32 RIM_TYPEHID;
    public static ushort HID_USAGE_PAGE_DIGITIZER;
    public static ushort HID_USAGE_DIGITIZER_DIGITIZER;
    public static ushort HID_USAGE_DIGITIZER_PEN;
    public static ushort HID_USAGE_DIGITIZER_LIGHTPEN;
    public static ushort HID_USAGE_DIGITIZER_TOUCHSCREEN;
    public static int AC_SRC_OVER;
    public static int ULW_COLORKEY;
    public static int ULW_ALPHA;
    public static int ULW_OPAQUE;
    public static int FEATURE_OBJECT_CACHING;
    public static int FEATURE_ZONE_ELEVATION;
    public static int FEATURE_MIME_HANDLING;
    public static int FEATURE_MIME_SNIFFING;
    public static int FEATURE_WINDOW_RESTRICTIONS;
    public static int FEATURE_WEBOC_POPUPMANAGEMENT;
    public static int FEATURE_BEHAVIORS;
    public static int FEATURE_DISABLE_MK_PROTOCOL;
    public static int FEATURE_LOCALMACHINE_LOCKDOWN;
    public static int FEATURE_SECURITYBAND;
    public static int FEATURE_RESTRICT_ACTIVEXINSTALL;
    public static int FEATURE_VALIDATE_NAVIGATE_URL;
    public static int FEATURE_RESTRICT_FILEDOWNLOAD;
    public static int FEATURE_ADDON_MANAGEMENT;
    public static int FEATURE_PROTOCOL_LOCKDOWN;
    public static int FEATURE_HTTP_USERNAME_PASSWORD_DISABLE;
    public static int FEATURE_SAFE_BINDTOOBJECT;
    public static int FEATURE_UNC_SAVEDFILECHECK;
    public static int FEATURE_GET_URL_DOM_FILEPATH_UNENCODED;
    public static int FEATURE_TABBED_BROWSING;
    public static int FEATURE_SSLUX;
    public static int FEATURE_DISABLE_NAVIGATION_SOUNDS;
    public static int FEATURE_DISABLE_LEGACY_COMPRESSION;
    public static int FEATURE_FORCE_ADDR_AND_STATUS;
    public static int FEATURE_XMLHTTP;
    public static int FEATURE_DISABLE_TELNET_PROTOCOL;
    public static int FEATURE_FEEDS;
    public static int FEATURE_BLOCK_INPUT_PROMPTS;
    public static int GET_FEATURE_FROM_PROCESS;
    public static int SET_FEATURE_ON_PROCESS;
    public static int URLZONE_LOCAL_MACHINE;
    public static int URLZONE_INTRANET;
    public static int URLZONE_TRUSTED;
    public static int URLZONE_INTERNET;
    public static int URLZONE_UNTRUSTED;
    public static byte URLPOLICY_ALLOW;
    public static byte URLPOLICY_QUERY;
    public static byte URLPOLICY_DISALLOW;
    public static int URLACTION_FEATURE_ZONE_ELEVATION;
    public static int PUAF_NOUI;
    public static int MUTZ_NOSAVEDFILECHECK;
    public static int SIZE_RESTORED;
    public static int SIZE_MINIMIZED;
    public static int WS_EX_NOACTIVATE;
    public static int VK_LSHIFT;
    public static int VK_RMENU;
    public static int VK_LMENU;
    public static int VK_LCONTROL;
    public static int VK_RCONTROL;
    public static int VK_LBUTTON;
    public static int VK_RBUTTON;
    public static int VK_MBUTTON;
    public static int VK_XBUTTON1;
    public static int VK_XBUTTON2;
    public static int PM_QS_SENDMESSAGE;
    public static int PM_QS_POSTMESSAGE;
    public static int MWMO_WAITALL;
    public static int MWMO_ALERTABLE;
    public static int MWMO_INPUTAVAILABLE;
    public static IntPtr HWND_MESSAGE;
    internal static UInt32 DELETE;
    internal static UInt32 READ_CONTROL;
    internal static UInt32 WRITE_DAC;
    internal static UInt32 WRITE_OWNER;
    internal static UInt32 SYNCHRONIZE;
    internal static UInt32 STANDARD_RIGHTS_REQUIRED;
    internal static UInt32 STANDARD_RIGHTS_READ;
    internal static UInt32 STANDARD_RIGHTS_WRITE;
    internal static UInt32 STANDARD_RIGHTS_EXECUTE;
    internal static UInt32 STANDARD_RIGHTS_ALL;
    internal static UInt32 SPECIFIC_RIGHTS_ALL;
    internal static UInt32 ACCESS_SYSTEM_SECURITY;
    internal static UInt32 MAXIMUM_ALLOWED;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 GENERIC_WRITE;
    internal static UInt32 GENERIC_EXECUTE;
    internal static UInt32 GENERIC_ALL;
    internal static UInt32 FILE_READ_DATA;
    internal static UInt32 FILE_LIST_DIRECTORY;
    internal static UInt32 FILE_WRITE_DATA;
    internal static UInt32 FILE_ADD_FILE;
    internal static UInt32 FILE_APPEND_DATA;
    internal static UInt32 FILE_ADD_SUBDIRECTORY;
    internal static UInt32 FILE_CREATE_PIPE_INSTANCE;
    internal static UInt32 FILE_READ_EA;
    internal static UInt32 FILE_WRITE_EA;
    internal static UInt32 FILE_EXECUTE;
    internal static UInt32 FILE_TRAVERSE;
    internal static UInt32 FILE_DELETE_CHILD;
    internal static UInt32 FILE_READ_ATTRIBUTES;
    internal static UInt32 FILE_WRITE_ATTRIBUTES;
    internal static UInt32 FILE_ALL_ACCESS;
    internal static UInt32 FILE_GENERIC_READ;
    internal static UInt32 FILE_GENERIC_WRITE;
    internal static UInt32 FILE_GENERIC_EXECUTE;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_SHARE_WRITE;
    internal static UInt32 FILE_SHARE_DELETE;
    internal static int ERROR_ALREADY_EXISTS;
    internal static int OPEN_EXISTING;
    internal static int PAGE_READONLY;
    internal static int SECTION_MAP_READ;
    internal static int FILE_ATTRIBUTE_NORMAL;
    internal static int FILE_ATTRIBUTE_TEMPORARY;
    internal static int FILE_FLAG_DELETE_ON_CLOSE;
    internal static int CREATE_ALWAYS;
    public static int QS_EVENT;
    public static int VK_CANCEL;
    public static int VK_BACK;
    public static int VK_CLEAR;
    public static int VK_RETURN;
    public static int VK_PAUSE;
    public static int VK_CAPITAL;
    public static int VK_KANA;
    public static int VK_HANGEUL;
    public static int VK_HANGUL;
    public static int VK_JUNJA;
    public static int VK_FINAL;
    public static int VK_HANJA;
    public static int VK_KANJI;
    public static int VK_ESCAPE;
    public static int VK_CONVERT;
    public static int VK_NONCONVERT;
    public static int VK_ACCEPT;
    public static int VK_MODECHANGE;
    public static int VK_SPACE;
    public static int VK_PRIOR;
    public static int VK_NEXT;
    public static int VK_END;
    public static int VK_HOME;
    public static int VK_LEFT;
    public static int VK_UP;
    public static int VK_RIGHT;
    public static int VK_DOWN;
    public static int VK_SELECT;
    public static int VK_PRINT;
    public static int VK_EXECUTE;
    public static int VK_SNAPSHOT;
    public static int VK_INSERT;
    public static int VK_DELETE;
    public static int VK_HELP;
    public static int VK_0;
    public static int VK_1;
    public static int VK_2;
    public static int VK_3;
    public static int VK_4;
    public static int VK_5;
    public static int VK_6;
    public static int VK_7;
    public static int VK_8;
    public static int VK_9;
    public static int VK_A;
    public static int VK_B;
    public static int VK_C;
    public static int VK_D;
    public static int VK_E;
    public static int VK_F;
    public static int VK_G;
    public static int VK_H;
    public static int VK_I;
    public static int VK_J;
    public static int VK_K;
    public static int VK_L;
    public static int VK_M;
    public static int VK_N;
    public static int VK_O;
    public static int VK_P;
    public static int VK_Q;
    public static int VK_R;
    public static int VK_S;
    public static int VK_T;
    public static int VK_U;
    public static int VK_V;
    public static int VK_W;
    public static int VK_X;
    public static int VK_Y;
    public static int VK_Z;
    public static int VK_LWIN;
    public static int VK_RWIN;
    public static int VK_APPS;
    public static int VK_POWER;
    public static int VK_SLEEP;
    public static int VK_NUMPAD0;
    public static int VK_NUMPAD1;
    public static int VK_NUMPAD2;
    public static int VK_NUMPAD3;
    public static int VK_NUMPAD4;
    public static int VK_NUMPAD5;
    public static int VK_NUMPAD6;
    public static int VK_NUMPAD7;
    public static int VK_NUMPAD8;
    public static int VK_NUMPAD9;
    public static int VK_MULTIPLY;
    public static int VK_ADD;
    public static int VK_SEPARATOR;
    public static int VK_SUBTRACT;
    public static int VK_DECIMAL;
    public static int VK_DIVIDE;
    public static int VK_F1;
    public static int VK_F2;
    public static int VK_F3;
    public static int VK_F4;
    public static int VK_F5;
    public static int VK_F6;
    public static int VK_F7;
    public static int VK_F8;
    public static int VK_F9;
    public static int VK_F10;
    public static int VK_F11;
    public static int VK_F12;
    public static int VK_F13;
    public static int VK_F14;
    public static int VK_F15;
    public static int VK_F16;
    public static int VK_F17;
    public static int VK_F18;
    public static int VK_F19;
    public static int VK_F20;
    public static int VK_F21;
    public static int VK_F22;
    public static int VK_F23;
    public static int VK_F24;
    public static int VK_NUMLOCK;
    public static int VK_SCROLL;
    public static int VK_RSHIFT;
    public static int VK_BROWSER_BACK;
    public static int VK_BROWSER_FORWARD;
    public static int VK_BROWSER_REFRESH;
    public static int VK_BROWSER_STOP;
    public static int VK_BROWSER_SEARCH;
    public static int VK_BROWSER_FAVORITES;
    public static int VK_BROWSER_HOME;
    public static int VK_VOLUME_MUTE;
    public static int VK_VOLUME_DOWN;
    public static int VK_VOLUME_UP;
    public static int VK_MEDIA_NEXT_TRACK;
    public static int VK_MEDIA_PREV_TRACK;
    public static int VK_MEDIA_STOP;
    public static int VK_MEDIA_PLAY_PAUSE;
    public static int VK_LAUNCH_MAIL;
    public static int VK_LAUNCH_MEDIA_SELECT;
    public static int VK_LAUNCH_APP1;
    public static int VK_LAUNCH_APP2;
    public static int VK_PROCESSKEY;
    public static int VK_PACKET;
    public static int VK_ATTN;
    public static int VK_CRSEL;
    public static int VK_EXSEL;
    public static int VK_EREOF;
    public static int VK_PLAY;
    public static int VK_ZOOM;
    public static int VK_NONAME;
    public static int VK_PA1;
    public static int VK_OEM_CLEAR;
    internal static int ENDSESSION_LOGOFF;
    internal static int ERROR_SUCCESS;
    public static int LOCALE_FONTSIGNATURE;
    public static int SWP_NOREDRAW;
    public static int SWP_FRAMECHANGED;
    public static int SWP_NOCOPYBITS;
    public static int SWP_NOOWNERZORDER;
    public static int SWP_NOSENDCHANGING;
    public static int SWP_NOREPOSITION;
    public static int SWP_DEFERERASE;
    public static int SWP_ASYNCWINDOWPOS;
    public static int SPI_GETCURSORSHADOW;
    public static int SPI_SETCURSORSHADOW;
    public static int SPI_GETFOCUSBORDERWIDTH;
    public static int SPI_SETFOCUSBORDERWIDTH;
    public static int SPI_GETFOCUSBORDERHEIGHT;
    public static int SPI_SETFOCUSBORDERHEIGHT;
    public static int SPI_GETSTYLUSHOTTRACKING;
    public static int SPI_SETSTYLUSHOTTRACKING;
    public static int SPI_GETTOOLTIPFADE;
    public static int SPI_SETTOOLTIPFADE;
    public static int SPI_GETFOREGROUNDFLASHCOUNT;
    public static int SPI_SETFOREGROUNDFLASHCOUNT;
    public static int SPI_SETCARETWIDTH;
    public static int SPI_SETMOUSEVANISH;
    public static int SPI_SETHIGHCONTRAST;
    public static int SPI_SETKEYBOARDPREF;
    public static int SPI_SETFLATMENU;
    public static int SPI_SETDROPSHADOW;
    public static int SPI_SETWORKAREA;
    public static int SPI_SETICONMETRICS;
    public static int SPI_SETDRAGWIDTH;
    public static int SPI_SETDRAGHEIGHT;
    public static int SPI_SETPENWINDOWS;
    public static int SPI_SETMOUSEBUTTONSWAP;
    public static int SPI_SETSHOWSOUNDS;
    public static int SPI_SETKEYBOARDCUES;
    public static int SPI_SETKEYBOARDDELAY;
    public static int SPI_SETSNAPTODEFBUTTON;
    public static int SPI_SETWHEELSCROLLLINES;
    public static int SPI_SETMOUSEHOVERWIDTH;
    public static int SPI_SETMOUSEHOVERHEIGHT;
    public static int SPI_SETMOUSEHOVERTIME;
    public static int SPI_SETMENUDROPALIGNMENT;
    public static int SPI_SETMENUFADE;
    public static int SPI_SETMENUSHOWDELAY;
    public static int SPI_SETCOMBOBOXANIMATION;
    public static int SPI_SETCLIENTAREAANIMATION;
    public static int SPI_SETGRADIENTCAPTIONS;
    public static int SPI_SETHOTTRACKING;
    public static int SPI_SETLISTBOXSMOOTHSCROLLING;
    public static int SPI_SETMENUANIMATION;
    public static int SPI_SETSELECTIONFADE;
    public static int SPI_SETTOOLTIPANIMATION;
    public static int SPI_SETUIEFFECTS;
    public static int SPI_SETANIMATION;
    public static int SPI_SETDRAGFULLWINDOWS;
    public static int SPI_SETBORDER;
    public static int SPI_SETNONCLIENTMETRICS;
    public static int LANG_KOREAN;
    public static int MB_YESNO;
    public static int MB_SYSTEMMODAL;
    public static int IDYES;
    public static int PM_QS_INPUT;
    public static int PM_QS_PAINT;
    public static int SW_PARENTCLOSING;
    public static int SW_PARENTOPENING;
    public static int SC_MOUSEMOVE;
    public static int SPI_SETKEYBOARDSPEED;
    internal static int TYMED_HGLOBAL;
    internal static int TYMED_FILE;
    internal static int TYMED_ISTREAM;
    internal static int TYMED_ISTORAGE;
    internal static int TYMED_GDI;
    internal static int TYMED_MFPICT;
    internal static int TYMED_ENHMF;
    public static int WS_OVERLAPPEDWINDOW;
    public static int KEYEVENTF_EXTENDEDKEY;
    public static int KEYEVENTF_KEYUP;
    public static int KEYEVENTF_UNICODE;
    public static int KEYEVENTF_SCANCODE;
    public static int MOUSEEVENTF_MOVE;
    public static int MOUSEEVENTF_LEFTDOWN;
    public static int MOUSEEVENTF_LEFTUP;
    public static int MOUSEEVENTF_RIGHTDOWN;
    public static int MOUSEEVENTF_RIGHTUP;
    public static int MOUSEEVENTF_MIDDLEDOWN;
    public static int MOUSEEVENTF_MIDDLEUP;
    public static int MOUSEEVENTF_XDOWN;
    public static int MOUSEEVENTF_XUP;
    public static int MOUSEEVENTF_WHEEL;
    public static int MOUSEEVENTF_VIRTUALDESK;
    public static int MOUSEEVENTF_ABSOLUTE;
    public static int MOUSEEVENTF_ACTUAL;
    public static int GWL_HINSTANCE;
    public static int GWL_USERDATA;
    public static int GCL_MENUNAME;
    public static int GCL_HBRBACKGROUND;
    public static int GCL_HCURSOR;
    public static int GCL_HICON;
    public static int GCL_HMODULE;
    public static int GCL_CBWNDEXTRA;
    public static int GCL_CBCLSEXTRA;
    public static int GCL_STYLE;
    public static int GCW_ATOM;
    public static int GCL_HICONSM;
    public static int MONITOR_DEFAULTTONULL;
    public static int MONITOR_DEFAULTTOPRIMARY;
    public static int MONITOR_DEFAULTTONEAREST;
    public static UInt32 WTNCA_NODRAWCAPTION;
    public static UInt32 WTNCA_NODRAWICON;
    public static UInt32 WTNCA_NOSYSMENU;
    public static UInt32 WTNCA_VALIDBITS;
    internal static int NO_ERROR;
    public static int VK_OEM_1;
    public static int VK_OEM_PLUS;
    public static int VK_OEM_COMMA;
    public static int VK_OEM_MINUS;
    public static int VK_OEM_PERIOD;
    public static int VK_OEM_2;
    public static int VK_OEM_3;
    public static int VK_C1;
    public static int VK_C2;
    public static int VK_OEM_4;
    public static int VK_OEM_5;
    public static int VK_OEM_6;
    public static int VK_OEM_7;
    public static int VK_OEM_8;
    public static int VK_OEM_AX;
    public static int VK_OEM_102;
    public static int VK_OEM_RESET;
    public static int VK_OEM_JUMP;
    public static int VK_OEM_PA1;
    public static int VK_OEM_PA2;
    public static int VK_OEM_PA3;
    public static int VK_OEM_WSCTRL;
    public static int VK_OEM_CUSEL;
    public static int VK_OEM_ATTN;
    public static int VK_OEM_FINISH;
    public static int VK_OEM_COPY;
    public static int VK_OEM_AUTO;
    public static int VK_OEM_ENLW;
    public static int VK_OEM_BACKTAB;
    public static int DRAGDROP_S_DROP;
    public static int DRAGDROP_S_CANCEL;
    public static int DRAGDROP_S_USEDEFAULTCURSORS;
    public static int TME_CANCEL;
    public static int IDC_HAND;
    public static int DM_ORIENTATION;
    public static int DM_PAPERSIZE;
    public static int DM_PAPERLENGTH;
    public static int DM_PAPERWIDTH;
    public static int DM_PRINTQUALITY;
    public static int DM_YRESOLUTION;
    public static int MM_ISOTROPIC;
    public static int DM_OUT_BUFFER;
    public static int E_HANDLE;
    public static int SPI_SETFONTSMOOTHING;
    public static int SPI_SETFONTSMOOTHINGTYPE;
    public static int SPI_SETFONTSMOOTHINGCONTRAST;
    public static int SPI_SETFONTSMOOTHINGORIENTATION;
    public static int SPI_SETDISPLAYPIXELSTRUCTURE;
    public static int SPI_SETDISPLAYGAMMA;
    public static int SPI_SETDISPLAYCLEARTYPELEVEL;
    public static int SPI_SETDISPLAYTEXTCONTRASTLEVEL;
    public static int GMMP_USE_DISPLAY_POINTS;
    public static int GMMP_USE_HIGH_RESOLUTION_POINTS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_PATH_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_DRIVE;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_FILE_EXISTS;
    public static int ERROR_INVALID_PARAMETER;
    public static int ERROR_FILENAME_EXCED_RANGE;
    public static int ERROR_NO_MORE_ITEMS;
    public static int ERROR_OPERATION_ABORTED;
    public static int LR_DEFAULTCOLOR;
    public static int LR_MONOCHROME;
    public static int LR_COLOR;
    public static int LR_COPYRETURNORG;
    public static int LR_COPYDELETEORG;
    public static int LR_LOADFROMFILE;
    public static int LR_LOADTRANSPARENT;
    public static int LR_DEFAULTSIZE;
    public static int LR_VGACOLOR;
    public static int LR_LOADMAP3DCOLORS;
    public static int LR_CREATEDIBSECTION;
    public static int LR_COPYFROMRESOURCE;
    public static int LR_SHARED;
    public static int WTS_CONSOLE_CONNECT;
    public static int WTS_CONSOLE_DISCONNECT;
    public static int WTS_REMOTE_CONNECT;
    public static int WTS_REMOTE_DISCONNECT;
    public static int WTS_SESSION_LOCK;
    public static int WTS_SESSION_UNLOCK;
    public static UInt32 NOTIFY_FOR_THIS_SESSION;
    public static int PBT_APMSUSPEND;
    public static int PBT_APMRESUMECRITICAL;
    public static int PBT_APMRESUMESUSPEND;
    public static int PBT_APMRESUMEAUTOMATIC;
    public static int PBT_POWERSETTINGCHANGE;
    public static Guid GUID_MONITOR_POWER_ON;
    public static UInt32 PROFILE_READ;
    private static NativeMethods();
    public static bool Succeeded(int hr);
    public static bool Failed(int hr);
    public static int SignedHIWORD(int n);
    public static int SignedLOWORD(int n);
    public static int MakeHRFromErrorCode(int errorCode);
    [SecurityCriticalAttribute]
internal static IntPtr SetEnhMetaFileBits(UInt32 cbBuffer, Byte[] buffer);
    public static int SignedHIWORD(IntPtr intPtr);
    public static int SignedLOWORD(IntPtr intPtr);
    public static int IntPtrToInt32(IntPtr intPtr);
    [SecurityCriticalAttribute]
public static int EndDoc(HDC hdc);
    [SecurityCriticalAttribute]
public static int ExtEscape(HDC hdc, int nEscape, int cbInput, PrinterEscape* lpvInData, int cbOutput, Void* lpvOutData);
    [SecurityCriticalAttribute]
public static int StartDoc(HDC hdc, DocInfo& docInfo);
    [SecurityCriticalAttribute]
public static int OpenPrinterA(string printerName, IntPtr* phPrinter, Void* pDefaults);
    [SecurityCriticalAttribute]
public static int ClosePrinter(IntPtr hPrinter);
    [SecurityCriticalAttribute]
public static int EndPage(HDC hdc);
    [SecurityCriticalAttribute]
public static int StartPage(HDC hdc);
}
[FriendAccessAllowedAttribute]
internal static class MS.Win32.SafeNativeMethods : object {
    public static UInt32 CT_CTYPE1;
    public static UInt32 CT_CTYPE2;
    public static UInt32 CT_CTYPE3;
    public static ushort C1_SPACE;
    public static ushort C1_PUNCT;
    public static ushort C1_BLANK;
    public static ushort C3_NONSPACING;
    public static ushort C3_DIACRITIC;
    public static ushort C3_VOWELMARK;
    public static ushort C3_KATAKANA;
    public static ushort C3_HIRAGANA;
    public static ushort C3_HALFWIDTH;
    public static ushort C3_FULLWIDTH;
    public static ushort C3_IDEOGRAPH;
    public static ushort C3_KASHIDA;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetMessagePos();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr GetKeyboardLayout(int dwLayout);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr ActivateKeyboardLayout(HandleRef hkl, int uFlags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetKeyboardLayoutList(int size, IntPtr[] hkls);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void GetMonitorInfo(HandleRef hmonitor, MONITORINFOEX info);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr MonitorFromPoint(POINTSTRUCT pt, int flags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr MonitorFromRect(RECT& rect, int flags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr MonitorFromWindow(HandleRef handle, int flags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static CursorHandle LoadCursor(HandleRef hInst, IntPtr iconId);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr GetCursor();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int ShowCursor(bool show);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool AdjustWindowRectEx(RECT& lpRect, int dwStyle, bool bMenu, int dwExStyle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void GetClientRect(HandleRef hWnd, RECT& rect);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void GetWindowRect(HandleRef hWnd, RECT& rect);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetDoubleClickTime();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsWindowEnabled(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsWindowVisible(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool ReleaseCapture();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool TrackMouseEvent(TRACKMOUSEEVENT tme);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void SetTimer(HandleRef hWnd, int nIDEvent, int uElapse);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool TrySetTimer(HandleRef hWnd, int nIDEvent, int uElapse);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool KillTimer(HandleRef hwnd, int idEvent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetTickCount();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int MessageBeep(int uType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsWindowUnicode(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr SetCursor(HandleRef hcursor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr SetCursor(SafeHandle hcursor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void ScreenToClient(HandleRef hWnd, POINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetCurrentProcessId();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetCurrentThreadId();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr GetCapture();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr SetCapture(HandleRef hwnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int MapVirtualKey(int nVirtKey, int nMapType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool InSendMessage();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsUxThemeActive();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool SetCaretPos(int x, int y);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool DestroyCaret();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetCaretBlinkTime();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool GetStringTypeEx(UInt32 locale, UInt32 infoType, Char[] sourceString, int count, UInt16[] charTypes);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int GetSysColor(int nIndex);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsClipboardFormatAvailable(int format);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsDebuggerPresent();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void QueryPerformanceCounter(Int64& lpPerformanceCount);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void QueryPerformanceFrequency(Int64& lpFrequency);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int GetMessageTime();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int GetWindowStyle(HandleRef hWnd, bool exStyle);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.UnsafeNativeMethods : object {
    public static int MB_PRECOMPOSED;
    public static int MB_COMPOSITE;
    public static int MB_USEGLYPHCHARS;
    public static int MB_ERR_INVALID_CHARS;
    public static int WAIT_FAILED;
    internal static UInt32 INTERNET_COOKIE_THIRD_PARTY;
    internal static UInt32 INTERNET_COOKIE_EVALUATE_P3P;
    internal static UInt32 INTERNET_COOKIE_IS_RESTRICTED;
    internal static UInt32 COOKIE_STATE_REJECT;
    public static int PROCESS_VM_READ;
    public static int PROCESS_QUERY_INFORMATION;
    internal static IntPtr INVALID_HANDLE_VALUE;
    internal static int PAGE_NOACCESS;
    internal static int PAGE_READONLY;
    internal static int PAGE_READWRITE;
    internal static int PAGE_WRITECOPY;
    internal static int PAGE_EXECUTE;
    internal static int PAGE_EXECUTE_READ;
    internal static int PAGE_EXECUTE_READWRITE;
    internal static int PAGE_EXECUTE_WRITECOPY;
    internal static int PAGE_GUARD;
    internal static int PAGE_NOCACHE;
    internal static int PAGE_WRITECOMBINE;
    internal static int MEM_COMMIT;
    internal static int MEM_RESERVE;
    internal static int MEM_DECOMMIT;
    internal static int MEM_RELEASE;
    internal static int MEM_FREE;
    internal static int MEM_PRIVATE;
    internal static int MEM_MAPPED;
    internal static int MEM_RESET;
    internal static int MEM_TOP_DOWN;
    internal static int MEM_WRITE_WATCH;
    internal static int MEM_PHYSICAL;
    internal static int MEM_4MB_PAGES;
    internal static int SEC_FILE;
    internal static int SEC_IMAGE;
    internal static int SEC_RESERVE;
    internal static int SEC_COMMIT;
    internal static int SEC_NOCACHE;
    internal static int MEM_IMAGE;
    internal static int WRITE_WATCH_FLAG_RESET;
    internal static int SECTION_ALL_ACCESS;
    internal static int STANDARD_RIGHTS_REQUIRED;
    internal static int SECTION_QUERY;
    internal static int SECTION_MAP_WRITE;
    internal static int SECTION_MAP_READ;
    internal static int SECTION_MAP_EXECUTE;
    internal static int SECTION_EXTEND_SIZE;
    internal static int FILE_MAP_COPY;
    internal static int FILE_MAP_WRITE;
    internal static int FILE_MAP_READ;
    internal static int FILE_MAP_ALL_ACCESS;
    internal static int SDDL_REVISION_1;
    internal static int SDDL_REVISION;
    public static int EventObjectUIFragmentCreate;
    internal static int STATUS_SUCCESS;
    internal static int STATUS_TIMEOUT;
    internal static int STATUS_BUFFER_TOO_SMALL;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int TF_CLIENTID_NULL;
    public static char TS_CHAR_EMBEDDED;
    public static char TS_CHAR_REGION;
    public static char TS_CHAR_REPLACEMENT;
    public static int TS_DEFAULT_SELECTION;
    public static int TS_S_ASYNC;
    public static int TS_E_NOSELECTION;
    public static int TS_E_NOLAYOUT;
    public static int TS_E_INVALIDPOINT;
    public static int TS_E_SYNCHRONOUS;
    public static int TS_E_READONLY;
    public static int TS_E_FORMAT;
    public static int TF_INVALID_COOKIE;
    public static int TF_DICTATION_ON;
    public static int TF_COMMANDING_ON;
    public static Guid IID_ITextStoreACPSink;
    public static Guid IID_ITfThreadFocusSink;
    public static Guid IID_ITfTextEditSink;
    public static Guid IID_ITfLanguageProfileNotifySink;
    public static Guid IID_ITfCompartmentEventSink;
    public static Guid IID_ITfTransitoryExtensionSink;
    public static Guid GUID_TFCAT_TIP_KEYBOARD;
    public static Guid GUID_PROP_ATTRIBUTE;
    public static Guid GUID_PROP_LANGID;
    public static Guid GUID_PROP_READING;
    public static Guid GUID_PROP_INPUTSCOPE;
    public static Guid GUID_COMPARTMENT_KEYBOARD_DISABLED;
    public static Guid GUID_COMPARTMENT_KEYBOARD_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_HANDWRITING_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_SPEECH_DISABLED;
    public static Guid GUID_COMPARTMENT_SPEECH_OPENCLOSE;
    public static Guid GUID_COMPARTMENT_SPEECH_GLOBALSTATE;
    public static Guid GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION;
    public static Guid GUID_COMPARTMENT_KEYBOARD_INPUTMODE_SENTENCE;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION_DOCUMENTMANAGER;
    public static Guid GUID_COMPARTMENT_TRANSITORYEXTENSION_PARENT;
    public static Guid Clsid_SpeechTip;
    public static Guid Guid_Null;
    public static Guid IID_ITfFnCustomSpeechCommand;
    public static Guid IID_ITfFnReconversion;
    public static Guid IID_ITfFnConfigure;
    public static Guid IID_ITfFnConfigureRegisterWord;
    public static Guid TSATTRID_Font_FaceName;
    public static Guid TSATTRID_Font_SizePts;
    public static Guid TSATTRID_Font_Style_Height;
    public static Guid TSATTRID_Text_VerticalWriting;
    public static Guid TSATTRID_Text_Orientation;
    public static Guid TSATTRID_Text_ReadOnly;
    public static Guid GUID_SYSTEM_FUNCTIONPROVIDER;
    private static UnsafeNativeMethods();
    [SecurityCriticalAttribute]
public static object PtrToStructure(IntPtr lparam, Type cls);
    [SecurityCriticalAttribute]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int OleGetClipboard(IDataObject& data);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int OleSetClipboard(IDataObject pDataObj);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int OleFlushClipboard();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int GetCurrentThemeName(StringBuilder pszThemeFileName, int dwMaxNameChars, StringBuilder pszColorBuff, int dwMaxColorChars, StringBuilder pszSizeBuff, int cchMaxSizeChars);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int DwmIsCompositionEnabled(Int32& enabled);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static IntPtr GetCurrentThread();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static WindowMessage RegisterWindowMessage(string msg);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static bool SetWindowPos(HandleRef hWnd, HandleRef hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static IntPtr GetWindow(HandleRef hWnd, int uCmd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int GetClassName(HandleRef hwnd, StringBuilder lpClassName, int nMaxCount);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int MessageBox(HandleRef hWnd, string text, string caption, int type);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int CriticalSetWindowTheme(HandleRef hWnd, string subAppName, string subIdList);
    public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CriticalCreateCompatibleBitmap(HandleRef hDC, int width, int height);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CriticalGetStockObject(int stockObject);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int CriticalFillRect(IntPtr hdc, RECT& rcFill, IntPtr brush);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int GetBitmapBits(HandleRef hbmp, int cbBuffer, Byte[] lpvBits);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ShowWindow(HandleRef hWnd, int nCmdShow);
    [SecurityCriticalAttribute]
public static void DeleteObject(HandleRef hObject);
    [SecurityCriticalAttribute]
public static bool DeleteObjectNoThrow(HandleRef hObject);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static bool IntDeleteObject(HandleRef hObject);
    public static IntPtr SelectObject(HandleRef hdc, IntPtr obj);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static IntPtr SelectObject(HandleRef hdc, BitmapHandle obj);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static IntPtr CriticalSelectObject(HandleRef hdc, IntPtr obj);
    public static int GetClipboardFormatName(int format, StringBuilder lpString, int cchMax);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int RegisterClipboardFormat(string format);
    public static bool BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool CriticalPrintWindow(HandleRef hWnd, HandleRef hDC, int flags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool CriticalRedrawWindow(HandleRef hWnd, IntPtr lprcUpdate, IntPtr hrgnUpdate, int flags);
    public static int DragQueryFile(HandleRef hDrop, int iFile, StringBuilder lpszFile, int cch);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static IntPtr ShellExecute(HandleRef hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool ShellExecuteEx(ShellExecuteInfo lpExecInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int MultiByteToWideChar(int CodePage, int dwFlags, Byte[] lpMultiByteStr, int cchMultiByte, StringBuilder lpWideCharStr, int cchWideChar);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int WideCharToMultiByte(int codePage, int flags, string wideStr, int chars, Byte[] pOutBytes, int bufferBytes, IntPtr defaultChar, IntPtr pDefaultUsed);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void CopyMemoryW(IntPtr pdst, string psrc, int cb);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void CopyMemoryW(IntPtr pdst, Char[] psrc, int cb);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void CopyMemory(IntPtr pdst, Byte[] psrc, int cb);
    [SecurityCriticalAttribute]
public static void GetKeyboardState(Byte[] keystate);
    [SecurityCriticalAttribute]
internal static string GetModuleFileName(HandleRef hModule);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool TranslateMessage(MSG& msg);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr DispatchMessage(MSG& msg);
    [SecurityCriticalAttribute]
public static void PostThreadMessage(int id, int msg, IntPtr wparam, IntPtr lparam);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int ObjectFromLresult(IntPtr lResult, Guid& iid, IntPtr wParam, IAccessible& ppvObject);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool IsWinEventHookInstalled(int winevent);
    [SecurityCriticalAttribute]
public static int OleInitialize();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int CoRegisterPSClsid(Guid& riid, Guid& rclsid);
    public static bool EnumThreadWindows(int dwThreadId, EnumThreadWindowsCallback lpfn, HandleRef lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int OleUninitialize();
    [SecurityCriticalAttribute]
public static bool CloseHandleNoThrow(HandleRef handle);
    [SecurityCriticalAttribute]
public static int CreateStreamOnHGlobal(IntPtr hGlobal, bool fDeleteOnRelease, IStream& istream);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CriticalCreateCompatibleDC(HandleRef hDC);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static IntPtr CreateCompatibleDC(HandleRef hDC);
    [SecurityCriticalAttribute]
public static bool UnmapViewOfFileNoThrow(HandleRef pvBaseAddress);
    [SecurityCriticalAttribute]
public static bool EnableWindow(HandleRef hWnd, bool enable);
    [SecurityCriticalAttribute]
public static bool EnableWindowNoThrow(HandleRef hWnd, bool enable);
    public static int GetObject(HandleRef hObject, int nSize, BITMAP bm);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetFocus();
    [SecurityCriticalAttribute]
internal static bool GetCursorPos(POINT pt);
    [SecurityCriticalAttribute]
internal static bool TryGetCursorPos(POINT pt);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int GetWindowThreadProcessId(HandleRef hWnd, Int32& lpdwProcessId);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static short GetKeyState(int keyCode);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void DoDragDrop(IDataObject dataObject, IOleDropSource dropSource, int allowedEffects, Int32[] finalEffect);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void ReleaseStgMedium(STGMEDIUM& medium);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool InvalidateRect(HandleRef hWnd, IntPtr rect, bool erase);
    [SecurityCriticalAttribute]
internal static int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
    [SecurityCriticalAttribute]
internal static int GetWindowTextLength(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GlobalAlloc(int uFlags, IntPtr dwBytes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GlobalReAlloc(HandleRef handle, IntPtr bytes, int flags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GlobalLock(HandleRef handle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool GlobalUnlock(HandleRef handle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GlobalFree(HandleRef handle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GlobalSize(HandleRef handle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmSetConversionStatus(HandleRef hIMC, int conversion, int sentence);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmGetConversionStatus(HandleRef hIMC, Int32& conversion, Int32& sentence);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr ImmGetContext(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmReleaseContext(HandleRef hWnd, HandleRef hIMC);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr ImmAssociateContext(HandleRef hWnd, HandleRef hIMC);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmSetOpenStatus(HandleRef hIMC, bool open);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmGetOpenStatus(HandleRef hIMC);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ImmNotifyIME(HandleRef hIMC, int dwAction, int dwIndex, int dwValue);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmGetProperty(HandleRef hkl, int flags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Char[] lpBuf, int dwBufLen);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Byte[] lpBuf, int dwBufLen);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, Int32[] lpBuf, int dwBufLen);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmGetCompositionString(HandleRef hIMC, int dwIndex, IntPtr lpBuf, int dwBufLen);
    public static int ImmConfigureIME(HandleRef hkl, HandleRef hwnd, int dwData, IntPtr pvoid);
    public static int ImmConfigureIME(HandleRef hkl, HandleRef hwnd, int dwData, REGISTERWORD& registerWord);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmSetCompositionWindow(HandleRef hIMC, COMPOSITIONFORM& compform);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ImmSetCandidateWindow(HandleRef hIMC, CANDIDATEFORM& candform);
    public static IntPtr ImmGetDefaultIMEWnd(HandleRef hwnd);
    [SecurityCriticalAttribute]
internal static IntPtr SetFocus(HandleRef hWnd);
    [SecurityCriticalAttribute]
internal static bool TrySetFocus(HandleRef hWnd);
    [SecurityCriticalAttribute]
internal static bool TrySetFocus(HandleRef hWnd, IntPtr& result);
    [SecurityCriticalAttribute]
internal static IntPtr GetParent(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetAncestor(HandleRef hWnd, int flags);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static bool IsChild(HandleRef hWndParent, HandleRef hwnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr SetParent(HandleRef hWnd, HandleRef hWndParent);
    [SecurityCriticalAttribute]
internal static IntPtr GetModuleHandle(string modName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CallWindowProc(IntPtr wndProc, IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr DefWindowProc(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr IntGetProcAddress(HandleRef hModule, string lpProcName);
    [SecurityCriticalAttribute]
public static IntPtr GetProcAddress(HandleRef hModule, string lpProcName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetProcAddressNoThrow(HandleRef hModule, string lpProcName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr LoadLibrary(string lpFileName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int GetSystemMetrics(SM nIndex);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SystemParametersInfo(int nAction, int nParam, RECT& rc, int nUpdate);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SystemParametersInfo(int nAction, int nParam, Int32& value, int ignore);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SystemParametersInfo(int nAction, int nParam, Boolean& value, int ignore);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SystemParametersInfo(int nAction, int nParam, HIGHCONTRAST_I& rc, int nUpdate);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SystemParametersInfo(int nAction, int nParam, NONCLIENTMETRICS metrics, int nUpdate);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool GetSystemPowerStatus(SYSTEM_POWER_STATUS& systemPowerStatus);
    [SecurityCriticalAttribute]
public static void ClientToScreen(HandleRef hWnd, POINT pt);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetDesktopWindow();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetForegroundWindow();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int RegisterDragDrop(HandleRef hwnd, IOleDropTarget target);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int RevokeDragDrop(HandleRef hwnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool PeekMessage(MSG& msg, HandleRef hwnd, WindowMessage msgMin, WindowMessage msgMax, int remove);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SetProp(HandleRef hWnd, string propName, HandleRef data);
    [SecurityCriticalAttribute]
internal static void PostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool TryPostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static void NotifyWinEvent(int winEvent, HandleRef hwnd, int objType, int objID);
    [SecurityCriticalAttribute]
public static IntPtr BeginPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool EndPaint(HandleRef hWnd, PAINTSTRUCT& lpPaint);
    [SecurityCriticalAttribute]
public static IntPtr GetDC(HandleRef hWnd);
    [SecurityCriticalAttribute]
public static int ReleaseDC(HandleRef hWnd, HandleRef hDC);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int GetDeviceCaps(HandleRef hDC, int nIndex);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr GetActiveWindow();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SetForegroundWindow(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CommDlgExtendedError();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetOpenFileName(OPENFILENAME_I ofn);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetSaveFileName(OPENFILENAME_I ofn);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool SetLayeredWindowAttributes(HandleRef hwnd, int crKey, byte bAlpha, int dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, POINT pptDst, POINT pSizeDst, IntPtr hdcSrc, POINT pptSrc, int crKey, BLENDFUNCTION& pBlend, int dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr SetActiveWindow(HandleRef hWnd);
    [SecurityCriticalAttribute]
public static bool DestroyCursor(IntPtr hCurs);
    [SecurityCriticalAttribute]
public static bool DestroyIcon(IntPtr hIcon);
    [SecurityCriticalAttribute]
public static bool DeleteObject(IntPtr hObject);
    [SecurityCriticalAttribute]
internal static BitmapHandle CreateDIBSection(HandleRef hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, SafeFileMappingHandle hSection, int dwOffset);
    [SecurityCriticalAttribute]
internal static BitmapHandle CreateBitmap(int width, int height, int planes, int bitsPerPixel, Byte[] lpvBits);
    [SecurityCriticalAttribute]
internal static bool DestroyIcon(HandleRef handle);
    [SecurityCriticalAttribute]
internal static IconHandle CreateIconIndirect(ICONINFO iconInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool IsWindow(HandleRef hWnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void DeleteDC(HandleRef hDC);
    [SecurityCriticalAttribute]
public static void CriticalDeleteDC(HandleRef hDC);
    [SecurityCriticalAttribute]
public static bool GetMessageW(MSG& msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
    [SecurityCriticalAttribute]
public static IntPtr WindowFromPoint(int x, int y);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr IntCreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, object pvParam);
    [SecurityCriticalAttribute]
public static IntPtr CreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, object pvParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool IntDestroyWindow(HandleRef hWnd);
    [SecurityCriticalAttribute]
public static void DestroyWindow(HandleRef hWnd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static IntPtr SetWinEventHook(int eventMin, int eventMax, IntPtr hmodWinEventProc, WinEventProcDef WinEventReentrancyFilter, UInt32 idProcess, UInt32 idThread, int dwFlags);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool UnhookWinEvent(IntPtr winEventHook);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static void EnumChildWindows(HandleRef hwndParent, EnumChildrenCallback lpEnumFunc, HandleRef lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int GetWindowRgn(HandleRef hWnd, HandleRef hRgn);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool PtInRegion(HandleRef hRgn, int X, int Y);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 GetRawInputDeviceList(RAWINPUTDEVICELIST[] ridl, UInt32& numDevices, UInt32 sizeInBytes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static UInt32 GetRawInputDeviceInfo(IntPtr hDevice, UInt32 command, RID_DEVICE_INFO& ridInfo, UInt32& sizeInBytes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static UInt32 _GetTempFileName(string tmpPath, string prefix, UInt32 uniqueIdOrZero, StringBuilder tmpFileName);
    [SecurityCriticalAttribute]
internal static UInt32 GetTempFileName(string tmpPath, string prefix, UInt32 uniqueIdOrZero, StringBuilder tmpFileName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int ExtractIconEx(string szExeFileName, int nIconIndex, IconHandle& phiconLarge, IconHandle& phiconSmall, int nIcons);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IconHandle CreateIcon(IntPtr hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, Byte[] lpbANDbits, Byte[] lpbXORbits);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool CreateCaret(HandleRef hwnd, BitmapHandle hbitmap, int width, int height);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ShowCaret(HandleRef hwnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool HideCaret(HandleRef hwnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool ShowWindowAsync(HandleRef hWnd, int nCmdShow);
    internal static IconHandle LoadImageIcon(IntPtr hinst, string stName, int nType, int cxDesired, int cyDesired, int nFlags);
    internal static CursorHandle LoadImageCursor(IntPtr hinst, string stName, int nType, int cxDesired, int cyDesired, int nFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CoInternetIsFeatureEnabled(int featureEntry, int dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CoInternetSetFeatureEnabled(int featureEntry, int dwFlags, bool fEnable);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CoInternetIsFeatureZoneElevationEnabled(string szFromURL, string szToURL, IInternetSecurityManager secMgr, int dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void ProcessUnhandledException_DLL(string errMsg);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetVersionEx(OSVERSIONINFOEX ver);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CoInternetCreateSecurityManager(object pIServiceProvider, Object& ppISecurityManager, int dwReserved);
    [ReliabilityContractAttribute("3", "2")]
internal static IntPtr LocalFree(IntPtr hMem);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, SECURITY_ATTRIBUTES lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr GetMessageExtraInfo();
    [SecurityCriticalAttribute]
internal static int WaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, bool bWaitAll, int dwMilliseconds, bool bAlertable);
    [SecurityCriticalAttribute]
internal static int MsgWaitForMultipleObjectsEx(int nCount, IntPtr[] pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static ushort IntRegisterClassEx(WNDCLASSEX_D wc_d);
    [SecurityCriticalAttribute]
internal static ushort RegisterClassEx(WNDCLASSEX_D wc_d);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int IntUnregisterClass(IntPtr atomString, IntPtr hInstance);
    [SecurityCriticalAttribute]
internal static void UnregisterClass(IntPtr atomString, IntPtr hInstance);
    [SecurityCriticalAttribute]
internal static HRESULT ChangeWindowMessageFilterEx(IntPtr hwnd, WindowMessage message, MSGFLT action, MSGFLTINFO& extStatus);
    [SecurityCriticalAttribute]
internal static string ObtainUserAgentString();
    internal static IntPtr SendMessage(IntPtr hWnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr UnsafeSendMessage(IntPtr hWnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr RegisterPowerSettingNotification(IntPtr hRecipient, Guid* pGuid, int Flags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr UnregisterPowerSettingNotification(IntPtr hPowerNotify);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr SendMessage(HandleRef hWnd, WindowMessage msg, IntPtr wParam, IconHandle iconHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetLastError(int dwErrorCode);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool GetLayeredWindowAttributes(HandleRef hwnd, IntPtr pcrKey, IntPtr pbAlpha, IntPtr pdwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static SafeFileMappingHandle CreateFileMapping(SafeFileHandle hFile, SECURITY_ATTRIBUTES lpFileMappingAttributes, int flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static SafeViewOfFileHandle MapViewOfFileEx(SafeFileMappingHandle hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap, IntPtr lpBaseAddress);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static IntPtr SetWindowLong(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    [SecurityCriticalAttribute]
internal static IntPtr CriticalSetWindowLong(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    [SecurityCriticalAttribute]
internal static IntPtr CriticalSetWindowLong(HandleRef hWnd, int nIndex, WndProc dwNewLong);
    [SecurityCriticalAttribute]
internal static IntPtr GetWindowLongPtr(HandleRef hWnd, int nIndex);
    [SecurityCriticalAttribute]
internal static int GetWindowLong(HandleRef hWnd, int nIndex);
    [SecurityCriticalAttribute]
internal static WndProc GetWindowLongWndProc(HandleRef hWnd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool PlaySound(string soundName, IntPtr hmod, PlaySoundFlags soundFlags);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool InternetGetCookieEx(string Url, string cookieName, StringBuilder cookieData, UInt32& pchCookieData, UInt32 flags, IntPtr reserved);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static UInt32 InternetSetCookieEx(string Url, string CookieName, string cookieData, UInt32 flags, string p3pHeader);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int GetLocaleInfoW(int locale, int type, string data, int dataSize);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int FindNLSString(int locale, UInt32 flags, string sourceString, int sourceCount, string findString, int findCount, Int32& found);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void SetWindowText(HandleRef hWnd, string text);
    [SecurityCriticalAttribute]
internal static void GetIconInfo(HandleRef hIcon, ICONINFO& piconinfo);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void GetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void SetWindowPlacement(HandleRef hWnd, WINDOWPLACEMENT& placement);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool SystemParametersInfo(int nAction, int nParam, ANIMATIONINFO anim, int nUpdate);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool SystemParametersInfo(int nAction, int nParam, ICONMETRICS metrics, int nUpdate);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool BeginPanningFeedback(HandleRef hwnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool UpdatePanningFeedback(HandleRef hwnd, int lTotalOverpanOffsetX, int lTotalOverpanOffsetY, bool fInInertia);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool EndPanningFeedback(HandleRef hwnd, bool fAnimateBack);
    public static bool SetEvent(IntPtr hEvent);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int SetEvent(SafeWaitHandle hHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int WaitForSingleObject(SafeWaitHandle hHandle, int dwMilliseconds);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetMouseMovePointsEx(UInt32 cbSize, MOUSEMOVEPOINT& pointsIn, MOUSEMOVEPOINT[] pointsBufferOut, int nBufPoints, UInt32 resolution);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetFileSizeEx(SafeFileHandle hFile, LARGE_INTEGER& lpFileSize);
    internal static bool ConvertStringSecurityDescriptorToSecurityDescriptor(string stringSecurityDescriptor, int stringSDRevision, IntPtr& securityDescriptor, IntPtr securityDescriptorSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static SafeFileMappingHandle OpenFileMapping(int dwDesiredAccess, bool bInheritHandle, string lpName);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, int flAllocationType, int flProtect);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int OleIsCurrentClipboard(IDataObject pDataObj);
    internal static int GetOEMCP();
    internal static int RtlNtStatusToDosError(int Status);
    internal static bool NtSuccess(int err);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void NtCheck(int err);
    [SecurityCriticalAttribute]
internal static int SafeReleaseComObject(object o);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetUrlCacheConfigInfo(InternetCacheConfigInfo& pInternetCacheConfigInfo, UInt32& cbCacheConfigInfo, UInt32 fieldControl);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool WTSRegisterSessionNotification(IntPtr hwnd, UInt32 dwFlags);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool WTSUnRegisterSessionNotification(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static IntPtr GetCurrentProcess();
    [SecurityCriticalAttribute]
public static bool DuplicateHandle(IntPtr hSourceProcess, SafeWaitHandle hSourceHandle, IntPtr hTargetProcessHandle, IntPtr& hTargetHandle, UInt32 dwDesiredAccess, bool fInheritHandle, UInt32 dwOptions);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool IsIconic(IntPtr hWnd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static HandleRef SetWindowsHookEx(HookType idHook, HookProc lpfn, IntPtr hMod, int dwThreadId);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static bool UnhookWindowsHookEx(HandleRef hhk);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static IntPtr CallNextHookEx(HandleRef hhk, int nCode, IntPtr wParam, IntPtr lParam);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int TF_CreateThreadMgr(ITfThreadMgr& threadManager);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public static int TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles& profiles);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr& dam);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
public static int TF_CreateCategoryMgr(ITfCategoryMgr& catmgr);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Count = {Count}")]
[FriendAccessAllowedAttribute]
internal class System.Collections.ObjectModel.WeakReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public WeakReadOnlyCollection`1(IList`1<WeakReference> list);
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Collections.Specialized.CollectionChangedEventManager : WeakEventManager {
    public static void AddListener(INotifyCollectionChanged source, IWeakEventListener listener);
    public static void RemoveListener(INotifyCollectionChanged source, IWeakEventListener listener);
    public static void AddHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void RemoveHandler(INotifyCollectionChanged source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.CurrentChangedEventManager : WeakEventManager {
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    public static void AddHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(ICollectionView source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.CurrentChangingEventArgs : EventArgs {
    public bool IsCancelable { get; }
    public bool Cancel { get; public set; }
    public CurrentChangingEventArgs(bool isCancelable);
    public bool get_IsCancelable();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.ComponentModel.CurrentChangingEventHandler : MulticastDelegate {
    public CurrentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CurrentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CurrentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CurrentChangingEventManager : WeakEventManager {
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    public static void AddHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    public static void RemoveHandler(ICollectionView source, EventHandler`1<CurrentChangingEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.DependencyPropertyDescriptor : PropertyDescriptor {
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public PropertyMetadata Metadata { get; }
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public string Description { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    public TypeConverter Converter { get; }
    public bool IsBrowsable { get; }
    public bool IsLocalizable { get; }
    public bool SupportsChangeEvents { get; }
    public CoerceValueCallback DesignerCoerceValueCallback { get; public set; }
    private static DependencyPropertyDescriptor();
    public static DependencyPropertyDescriptor FromProperty(PropertyDescriptor property);
    internal static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type ownerType, Type targetType, bool ignorePropertyType);
    public static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type targetType);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType);
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType, bool ignorePropertyType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public DependencyProperty get_DependencyProperty();
    public bool get_IsAttached();
    public PropertyMetadata get_Metadata();
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual string get_Description();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    public virtual TypeConverter get_Converter();
    public virtual bool get_IsBrowsable();
    public virtual bool get_IsLocalizable();
    public virtual bool get_SupportsChangeEvents();
    public CoerceValueCallback get_DesignerCoerceValueCallback();
    public void set_DesignerCoerceValueCallback(CoerceValueCallback value);
    internal static void ClearCache();
}
public class System.ComponentModel.ErrorsChangedEventManager : WeakEventManager {
    public static void AddHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    public static void RemoveHandler(INotifyDataErrorInfo source, EventHandler`1<DataErrorsChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public abstract class System.ComponentModel.GroupDescription : object {
    public ObservableCollection`1<object> GroupNames { get; }
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public ObservableCollection`1<object> get_GroupNames();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupNames();
    public abstract virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
    public virtual bool NamesMatch(object groupName, object itemName);
}
public interface System.ComponentModel.ICollectionView {
    public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public bool IsEmpty { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual void set_Culture(CultureInfo value);
    public abstract virtual bool Contains(object item);
    public abstract virtual IEnumerable get_SourceCollection();
    public abstract virtual Predicate`1<object> get_Filter();
    public abstract virtual void set_Filter(Predicate`1<object> value);
    public abstract virtual bool get_CanFilter();
    public abstract virtual SortDescriptionCollection get_SortDescriptions();
    public abstract virtual bool get_CanSort();
    public abstract virtual bool get_CanGroup();
    public abstract virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public abstract virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Refresh();
    public abstract virtual IDisposable DeferRefresh();
    public abstract virtual object get_CurrentItem();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual bool get_IsCurrentAfterLast();
    public abstract virtual bool get_IsCurrentBeforeFirst();
    public abstract virtual bool MoveCurrentToFirst();
    public abstract virtual bool MoveCurrentToLast();
    public abstract virtual bool MoveCurrentToNext();
    public abstract virtual bool MoveCurrentToPrevious();
    public abstract virtual bool MoveCurrentTo(object item);
    public abstract virtual bool MoveCurrentToPosition(int position);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanged(EventHandler value);
}
public interface System.ComponentModel.ICollectionViewFactory {
    public abstract virtual ICollectionView CreateView();
}
public interface System.ComponentModel.ICollectionViewLiveShaping {
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public abstract virtual bool get_CanChangeLiveSorting();
    public abstract virtual bool get_CanChangeLiveFiltering();
    public abstract virtual bool get_CanChangeLiveGrouping();
    public abstract virtual Nullable`1<bool> get_IsLiveSorting();
    public abstract virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveFiltering();
    public abstract virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_IsLiveGrouping();
    public abstract virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public abstract virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public abstract virtual ObservableCollection`1<string> get_LiveGroupingProperties();
}
public interface System.ComponentModel.IEditableCollectionView {
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public abstract virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public abstract virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public abstract virtual bool get_CanAddNew();
    public abstract virtual object AddNew();
    public abstract virtual void CommitNew();
    public abstract virtual void CancelNew();
    public abstract virtual bool get_IsAddingNew();
    public abstract virtual object get_CurrentAddItem();
    public abstract virtual bool get_CanRemove();
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void Remove(object item);
    public abstract virtual void EditItem(object item);
    public abstract virtual void CommitEdit();
    public abstract virtual void CancelEdit();
    public abstract virtual bool get_CanCancelEdit();
    public abstract virtual bool get_IsEditingItem();
    public abstract virtual object get_CurrentEditItem();
}
public interface System.ComponentModel.IEditableCollectionViewAddNewItem {
    public bool CanAddNewItem { get; }
    public abstract virtual bool get_CanAddNewItem();
    public abstract virtual object AddNewItem(object newItem);
}
public interface System.ComponentModel.IItemProperties {
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public abstract virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
}
public class System.ComponentModel.ItemPropertyInfo : object {
    public string Name { get; }
    public Type PropertyType { get; }
    public object Descriptor { get; }
    public ItemPropertyInfo(string name, Type type, object descriptor);
    public string get_Name();
    public Type get_PropertyType();
    public object get_Descriptor();
}
public enum System.ComponentModel.NewItemPlaceholderPosition : Enum {
    public int value__;
    public static NewItemPlaceholderPosition None;
    public static NewItemPlaceholderPosition AtBeginning;
    public static NewItemPlaceholderPosition AtEnd;
}
public class System.ComponentModel.PropertyChangedEventManager : WeakEventManager {
    private static PropertyChangedEventManager();
    public static void AddListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    public static void RemoveListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    public static void AddHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void RemoveHandler(INotifyPropertyChanged source, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
}
[AttributeUsageAttribute("192")]
public class System.ComponentModel.PropertyFilterAttribute : Attribute {
    public static PropertyFilterAttribute Default;
    public PropertyFilterOptions Filter { get; }
    public PropertyFilterAttribute(PropertyFilterOptions filter);
    private static PropertyFilterAttribute();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool Match(object value);
    public PropertyFilterOptions get_Filter();
}
[FlagsAttribute]
public enum System.ComponentModel.PropertyFilterOptions : Enum {
    public int value__;
    public static PropertyFilterOptions None;
    public static PropertyFilterOptions Invalid;
    public static PropertyFilterOptions SetValues;
    public static PropertyFilterOptions UnsetValues;
    public static PropertyFilterOptions Valid;
    public static PropertyFilterOptions All;
}
public class System.ComponentModel.SortDescription : ValueType {
    private string _propertyName;
    private ListSortDirection _direction;
    private bool _sealed;
    public string PropertyName { get; public set; }
    public ListSortDirection Direction { get; public set; }
    public bool IsSealed { get; }
    public SortDescription(string propertyName, ListSortDirection direction);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public ListSortDirection get_Direction();
    public void set_Direction(ListSortDirection value);
    public bool get_IsSealed();
    public virtual bool Equals(object obj);
    public static bool op_Equality(SortDescription sd1, SortDescription sd2);
    public static bool op_Inequality(SortDescription sd1, SortDescription sd2);
    public virtual int GetHashCode();
    internal void Seal();
}
public class System.ComponentModel.SortDescriptionCollection : Collection`1<SortDescription> {
    public static SortDescriptionCollection Empty;
    private static SortDescriptionCollection();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, SortDescription item);
    protected virtual void SetItem(int index, SortDescription item);
}
public enum System.Diagnostics.PresentationTraceLevel : Enum {
    public int value__;
    public static PresentationTraceLevel None;
    public static PresentationTraceLevel Low;
    public static PresentationTraceLevel Medium;
    public static PresentationTraceLevel High;
}
public static class System.Diagnostics.PresentationTraceSources : object {
    public static DependencyProperty TraceLevelProperty;
    internal static TraceSource _DependencyPropertySource;
    internal static TraceSource _FreezableSource;
    internal static TraceSource _NameScopeSource;
    internal static TraceSource _RoutedEventSource;
    internal static TraceSource _AnimationSource;
    internal static TraceSource _DataBindingSource;
    internal static TraceSource _DocumentsSource;
    internal static TraceSource _ResourceDictionarySource;
    internal static TraceSource _MarkupSource;
    internal static TraceSource _HwndHostSource;
    internal static TraceSource _ShellSource;
    public static TraceSource DependencyPropertySource { get; }
    public static TraceSource FreezableSource { get; }
    public static TraceSource NameScopeSource { get; }
    public static TraceSource RoutedEventSource { get; }
    public static TraceSource AnimationSource { get; }
    public static TraceSource DataBindingSource { get; }
    public static TraceSource DocumentsSource { get; }
    public static TraceSource ResourceDictionarySource { get; }
    public static TraceSource MarkupSource { get; }
    public static TraceSource HwndHostSource { get; }
    public static TraceSource ShellSource { get; }
    private static PresentationTraceSources();
    public static PresentationTraceLevel GetTraceLevel(object element);
    public static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
    public static void Refresh();
    [CompilerGeneratedAttribute]
internal static void add_TraceRefresh(TraceRefreshEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_TraceRefresh(TraceRefreshEventHandler value);
    public static TraceSource get_DependencyPropertySource();
    public static TraceSource get_FreezableSource();
    public static TraceSource get_NameScopeSource();
    public static TraceSource get_RoutedEventSource();
    public static TraceSource get_AnimationSource();
    public static TraceSource get_DataBindingSource();
    public static TraceSource get_DocumentsSource();
    public static TraceSource get_ResourceDictionarySource();
    public static TraceSource get_MarkupSource();
    public static TraceSource get_HwndHostSource();
    public static TraceSource get_ShellSource();
}
internal class System.Diagnostics.TraceRefreshEventHandler : MulticastDelegate {
    public TraceRefreshEventHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.IO.Compression.ZLibNative : object {
    public static string ZLibNativeDllName;
    public static string ZLibVersion;
    internal static IntPtr ZNullPtr;
    public static int Deflate_DefaultWindowBits;
    public static int Deflate_DefaultMemLevel;
    private static ZLibNative();
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle, int windowBits);
    [SecurityCriticalAttribute]
public static int ZLibCompileFlags();
}
public class System.IO.FileFormatException : FormatException {
    public Uri SourceUri { get; }
    public FileFormatException(string message);
    public FileFormatException(string message, Exception innerException);
    public FileFormatException(Uri sourceUri);
    public FileFormatException(Uri sourceUri, string message);
    public FileFormatException(Uri sourceUri, Exception innerException);
    public FileFormatException(Uri sourceUri, string message, Exception innerException);
    protected FileFormatException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public Uri get_SourceUri();
}
public enum System.IO.Packaging.CertificateEmbeddingOption : Enum {
    public int value__;
    public static CertificateEmbeddingOption InCertificatePart;
    public static CertificateEmbeddingOption InSignaturePart;
    public static CertificateEmbeddingOption NotEmbedded;
}
public enum System.IO.Packaging.CompressionOption : Enum {
    public int value__;
    public static CompressionOption NotCompressed;
    public static CompressionOption Normal;
    public static CompressionOption Maximum;
    public static CompressionOption Fast;
    public static CompressionOption SuperFast;
}
internal class System.IO.Packaging.DataSpaceManager : object {
    internal static int TransformIdentifierTypes_PredefinedTransformName;
    internal int Count { get; }
    private static DataSpaceManager();
    internal DataSpaceManager(StorageRoot containerInstance);
    internal int get_Count();
    public void Dispose();
    internal void RemoveContainerFromDataSpaceMap(CompoundFileReference target);
    internal void CheckDisposedStatus();
    internal void DefineDataSpace(String[] transformStack, string newDataSpaceLabel);
    internal bool DataSpaceIsDefined(string dataSpaceLabel);
    internal string DataSpaceOf(CompoundFileReference target);
    internal List`1<IDataTransform> GetTransformsForStreamInfo(StreamInfo streamInfo);
    internal string DefineDataSpace(String[] transformStack);
    internal bool TransformLabelIsDefined(string transformLabel);
    internal Stream GetPrimaryInstanceStreamOf(string transformLabel);
    internal StorageInfo GetInstanceDataStorageOf(string transformLabel);
    internal IDataTransform GetTransformFromName(string transformLabel);
    internal void DefineTransform(string transformClassName, string newTransformLabel);
    internal string DefineTransform(string transformClassName);
    [CompilerGeneratedAttribute]
internal void add_OnTransformInitialization(TransformInitializeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_OnTransformInitialization(TransformInitializeEventHandler value);
    internal void CallTransformInitializers(TransformInitializationEventArgs initArguments);
    internal void CreateDataSpaceMapping(CompoundFileReference containerReference, string label);
    internal Stream CreateDataSpaceStream(CompoundFileStreamReference containerReference, Stream rawStream);
}
public class System.IO.Packaging.EncryptedPackageEnvelope : object {
    public RightsManagementInformation RightsManagementInformation { get; }
    public PackageProperties PackageProperties { get; }
    public FileAccess FileOpenAccess { get; }
    public StorageInfo StorageInfo { get; }
    internal static string EncryptionTransformName { get; }
    internal static string PackageStreamName { get; }
    internal static string DataspaceLabelRMEncryptionNoCompression { get; }
    internal EncryptedPackageEnvelope(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    internal EncryptedPackageEnvelope(string envelopeFileName, FileAccess access, FileShare sharing);
    internal EncryptedPackageEnvelope(Stream envelopeStream);
    public static EncryptedPackageEnvelope Create(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Create(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Open(string envelopeFileName);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access, FileShare sharing);
    public static EncryptedPackageEnvelope Open(Stream envelopeStream);
    public static bool IsEncryptedPackageEnvelope(string fileName);
    public static bool IsEncryptedPackageEnvelope(Stream stream);
    public void Flush();
    public void Close();
    public sealed virtual void Dispose();
    public RightsManagementInformation get_RightsManagementInformation();
    public PackageProperties get_PackageProperties();
    public FileAccess get_FileOpenAccess();
    public Package GetPackage();
    public StorageInfo get_StorageInfo();
    internal Stream GetPackageStream();
    internal static string get_EncryptionTransformName();
    internal static string get_PackageStreamName();
    internal static string get_DataspaceLabelRMEncryptionNoCompression();
    protected virtual void Dispose(bool disposing);
}
public enum System.IO.Packaging.EncryptionOption : Enum {
    public int value__;
    public static EncryptionOption None;
    public static EncryptionOption RightsManagement;
}
internal interface System.IO.Packaging.IDataTransform {
    public bool IsReady { get; }
    public bool FixedSettings { get; }
    public object TransformIdentifier { get; }
    public abstract virtual bool get_IsReady();
    public abstract virtual bool get_FixedSettings();
    public abstract virtual object get_TransformIdentifier();
    public abstract virtual Stream GetTransformedStream(Stream encodedDataStream, IDictionary transformContext);
}
public class System.IO.Packaging.InvalidSignatureEventHandler : MulticastDelegate {
    public InvalidSignatureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SignatureVerificationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SignatureVerificationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.IO.Packaging.Package : object {
    public FileAccess FileOpenAccess { get; }
    public PackageProperties PackageProperties { get; }
    internal bool InStreamingCreation { get; }
    protected Package(FileAccess openFileAccess);
    protected Package(FileAccess openFileAccess, bool streaming);
    private static Package();
    public FileAccess get_FileOpenAccess();
    public PackageProperties get_PackageProperties();
    public static Package Open(string path);
    public static Package Open(string path, FileMode packageMode);
    public static Package Open(string path, FileMode packageMode, FileAccess packageAccess);
    public static Package Open(string path, FileMode packageMode, FileAccess packageAccess, FileShare packageShare);
    public static Package Open(Stream stream);
    public static Package Open(Stream stream, FileMode packageMode);
    public static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess);
    public PackagePart CreatePart(Uri partUri, string contentType);
    public PackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
    public PackagePart GetPart(Uri partUri);
    public virtual bool PartExists(Uri partUri);
    public void DeletePart(Uri partUri);
    public PackagePartCollection GetParts();
    private sealed virtual override void System.IDisposable.Dispose();
    public void Close();
    public void Flush();
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    public void DeleteRelationship(string id);
    public PackageRelationshipCollection GetRelationships();
    public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
    public PackageRelationship GetRelationship(string id);
    public bool RelationshipExists(string id);
    protected abstract virtual PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
    protected abstract virtual PackagePart GetPartCore(Uri partUri);
    protected abstract virtual void DeletePartCore(Uri partUri);
    protected abstract virtual PackagePart[] GetPartsCore();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void FlushCore();
    internal bool get_InStreamingCreation();
    internal void ThrowIfInStreamingCreation(string methodName);
    internal void ThrowIfNotInStreamingCreation(string methodName);
    internal void ThrowIfReadOnly();
    internal void ThrowIfWriteOnly();
    internal static void ThrowIfFileModeInvalid(FileMode mode);
    internal static void ThrowIfFileAccessInvalid(FileAccess access);
    internal static void ThrowIfCompressionOptionInvalid(CompressionOption compressionOption);
    internal static Package Open(string path, FileMode packageMode, FileAccess packageAccess, FileShare packageShare, bool streaming);
    [FriendAccessAllowedAttribute]
internal static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess, bool streaming);
    internal void FlushPackageRelationships();
    internal void ClosePackageRelationships();
}
public class System.IO.Packaging.PackageDigitalSignature : object {
    public ReadOnlyCollection`1<Uri> SignedParts { get; }
    public ReadOnlyCollection`1<PackageRelationshipSelector> SignedRelationshipSelectors { get; }
    public PackagePart SignaturePart { get; }
    public X509Certificate Signer { get; }
    public DateTime SigningTime { get; }
    public string TimeFormat { get; }
    public Byte[] SignatureValue { get; }
    public string SignatureType { get; }
    public Signature Signature { get; public set; }
    public CertificateEmbeddingOption CertificateEmbeddingOption { get; }
    internal PackageDigitalSignature(PackageDigitalSignatureManager manager, XmlDigitalSignatureProcessor processor);
    internal PackageDigitalSignature(PackageDigitalSignatureManager manager, PackagePart signaturePart);
    public ReadOnlyCollection`1<Uri> get_SignedParts();
    public ReadOnlyCollection`1<PackageRelationshipSelector> get_SignedRelationshipSelectors();
    public PackagePart get_SignaturePart();
    public X509Certificate get_Signer();
    public DateTime get_SigningTime();
    public string get_TimeFormat();
    public Byte[] get_SignatureValue();
    public string get_SignatureType();
    public Signature get_Signature();
    public void set_Signature(Signature value);
    public CertificateEmbeddingOption get_CertificateEmbeddingOption();
    public List`1<string> GetPartTransformList(Uri partName);
    public VerifyResult Verify();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public VerifyResult Verify(X509Certificate signingCertificate);
    internal void Invalidate();
    internal CertificatePart GetCertificatePart();
    internal void SetCertificatePart(CertificatePart certificatePart);
}
public class System.IO.Packaging.PackageDigitalSignatureManager : object {
    public bool IsSigned { get; }
    public ReadOnlyCollection`1<PackageDigitalSignature> Signatures { get; }
    public Dictionary`2<string, string> TransformMapping { get; }
    public IntPtr ParentWindow { get; public set; }
    public string HashAlgorithm { get; public set; }
    public CertificateEmbeddingOption CertificateOption { get; public set; }
    public string TimeFormat { get; public set; }
    public Uri SignatureOrigin { get; }
    public static string SignatureOriginRelationshipType { get; }
    public static string DefaultHashAlgorithm { get; }
    internal Package Package { get; }
    public PackageDigitalSignatureManager(Package package);
    private static PackageDigitalSignatureManager();
    [CompilerGeneratedAttribute]
public void add_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    public bool get_IsSigned();
    public ReadOnlyCollection`1<PackageDigitalSignature> get_Signatures();
    public Dictionary`2<string, string> get_TransformMapping();
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public string get_HashAlgorithm();
    public void set_HashAlgorithm(string value);
    public CertificateEmbeddingOption get_CertificateOption();
    public void set_CertificateOption(CertificateEmbeddingOption value);
    public string get_TimeFormat();
    public void set_TimeFormat(string value);
    public Uri get_SignatureOrigin();
    public static string get_SignatureOriginRelationshipType();
    public static string get_DefaultHashAlgorithm();
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId);
    [SecurityCriticalAttribute]
public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId, IEnumerable`1<DataObject> signatureObjects, IEnumerable`1<Reference> objectReferences);
    public PackageDigitalSignature Countersign();
    public PackageDigitalSignature Countersign(X509Certificate certificate);
    public PackageDigitalSignature Countersign(X509Certificate certificate, IEnumerable`1<Uri> signatures);
    public VerifyResult VerifySignatures(bool exitOnFailure);
    public void RemoveSignature(Uri signatureUri);
    public void RemoveAllSignatures();
    public PackageDigitalSignature GetSignature(Uri signatureUri);
    [SecurityCriticalAttribute]
public static X509ChainStatusFlags VerifyCertificate(X509Certificate certificate);
    internal Package get_Package();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static X509Certificate PromptForSigningCertificate(IntPtr hwndParent);
}
public abstract class System.IO.Packaging.PackagePart : object {
    public Uri Uri { get; }
    public string ContentType { get; }
    public Package Package { get; }
    public CompressionOption CompressionOption { get; }
    internal bool IsRelationshipPart { get; }
    internal bool IsDeleted { get; internal set; }
    internal bool IsClosed { get; }
    internal ContentType ValidatedContentType { get; }
    protected PackagePart(Package package, Uri partUri);
    protected PackagePart(Package package, Uri partUri, string contentType);
    protected PackagePart(Package package, Uri partUri, string contentType, CompressionOption compressionOption);
    public Uri get_Uri();
    public string get_ContentType();
    public Package get_Package();
    public CompressionOption get_CompressionOption();
    protected virtual string GetContentTypeCore();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    protected abstract virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    public void DeleteRelationship(string id);
    public PackageRelationshipCollection GetRelationships();
    public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
    public PackageRelationship GetRelationship(string id);
    public bool RelationshipExists(string id);
    internal bool get_IsRelationshipPart();
    internal bool get_IsDeleted();
    internal void set_IsDeleted(bool value);
    internal bool get_IsClosed();
    internal ContentType get_ValidatedContentType();
    internal void ClearRelationships();
    internal void Flush();
    internal void Close();
    internal void FlushRelationships();
    internal void CloseRelationships();
}
public class System.IO.Packaging.PackagePartCollection : object {
    internal PackagePartCollection(SortedList`2<ValidatedPartUri, PackagePart> partList);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<PackagePart> System.Collections.Generic.IEnumerable<System.IO.Packaging.PackagePart>.GetEnumerator();
    public IEnumerator`1<PackagePart> GetEnumerator();
}
public abstract class System.IO.Packaging.PackageProperties : object {
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Creator { get; public set; }
    public string Keywords { get; public set; }
    public string Description { get; public set; }
    public string LastModifiedBy { get; public set; }
    public string Revision { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string Category { get; public set; }
    public string Identifier { get; public set; }
    public string ContentType { get; public set; }
    public string Language { get; public set; }
    public string Version { get; public set; }
    public string ContentStatus { get; public set; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual string get_Creator();
    public abstract virtual void set_Creator(string value);
    public abstract virtual string get_Keywords();
    public abstract virtual void set_Keywords(string value);
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual string get_LastModifiedBy();
    public abstract virtual void set_LastModifiedBy(string value);
    public abstract virtual string get_Revision();
    public abstract virtual void set_Revision(string value);
    public abstract virtual Nullable`1<DateTime> get_LastPrinted();
    public abstract virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_Created();
    public abstract virtual void set_Created(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_Modified();
    public abstract virtual void set_Modified(Nullable`1<DateTime> value);
    public abstract virtual string get_Category();
    public abstract virtual void set_Category(string value);
    public abstract virtual string get_Identifier();
    public abstract virtual void set_Identifier(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_Language();
    public abstract virtual void set_Language(string value);
    public abstract virtual string get_Version();
    public abstract virtual void set_Version(string value);
    public abstract virtual string get_ContentStatus();
    public abstract virtual void set_ContentStatus(string value);
}
public class System.IO.Packaging.PackageRelationship : object {
    public Uri SourceUri { get; }
    public Uri TargetUri { get; }
    public string RelationshipType { get; }
    public TargetMode TargetMode { get; }
    public string Id { get; }
    public Package Package { get; }
    internal static Uri ContainerRelationshipPartName { get; }
    internal bool Saved { get; internal set; }
    internal PackageRelationship(Package package, PackagePart sourcePart, Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    private static PackageRelationship();
    public Uri get_SourceUri();
    public Uri get_TargetUri();
    public string get_RelationshipType();
    public TargetMode get_TargetMode();
    public string get_Id();
    public Package get_Package();
    internal static Uri get_ContainerRelationshipPartName();
    internal bool get_Saved();
    internal void set_Saved(bool value);
}
public class System.IO.Packaging.PackageRelationshipCollection : object {
    internal PackageRelationshipCollection(InternalRelationshipCollection relationships, string filter);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<PackageRelationship> GetEnumerator();
}
public class System.IO.Packaging.PackageRelationshipSelector : object {
    public Uri SourceUri { get; }
    public PackageRelationshipSelectorType SelectorType { get; }
    public string SelectionCriteria { get; }
    public PackageRelationshipSelector(Uri sourceUri, PackageRelationshipSelectorType selectorType, string selectionCriteria);
    public Uri get_SourceUri();
    public PackageRelationshipSelectorType get_SelectorType();
    public string get_SelectionCriteria();
    public List`1<PackageRelationship> Select(Package package);
}
public enum System.IO.Packaging.PackageRelationshipSelectorType : Enum {
    public int value__;
    public static PackageRelationshipSelectorType Id;
    public static PackageRelationshipSelectorType Type;
}
public static class System.IO.Packaging.PackUriHelper : object {
    internal static char ForwardSlashChar;
    internal static char BackwardSlashChar;
    public static string UriSchemePack;
    internal static Uri PackageRootUri { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static PackUriHelper();
    public static Uri Create(Uri packageUri);
    public static Uri Create(Uri packageUri, Uri partUri);
    public static Uri Create(Uri packageUri, Uri partUri, string fragment);
    public static Uri GetPackageUri(Uri packUri);
    public static Uri GetPartUri(Uri packUri);
    public static Uri CreatePartUri(Uri partUri);
    public static Uri ResolvePartUri(Uri sourcePartUri, Uri targetUri);
    public static Uri GetRelativeUri(Uri sourcePartUri, Uri targetPartUri);
    public static Uri GetNormalizedPartUri(Uri partUri);
    public static int ComparePackUri(Uri firstPackUri, Uri secondPackUri);
    public static int ComparePartUri(Uri firstPartUri, Uri secondPartUri);
    public static bool IsRelationshipPartUri(Uri partUri);
    public static Uri GetRelationshipPartUri(Uri partUri);
    public static Uri GetSourcePartUriFromRelationshipPartUri(Uri relationshipPartUri);
    internal static Uri get_PackageRootUri();
    internal static bool IsPackUri(Uri uri);
    internal static bool TryValidatePartUri(Uri partUri, ValidatedPartUri& validatedPartUri);
    internal static ValidatedPartUri ValidatePartUri(Uri partUri);
    internal static string GetStringForPartUri(Uri partUri);
    internal static void ValidateAndGetPackUriComponents(Uri packUri, Uri& packageUri, Uri& partUri);
}
public class System.IO.Packaging.RightsManagementInformation : object {
    public CryptoProvider CryptoProvider { get; public set; }
    internal RightsManagementInformation(RightsManagementEncryptionTransform rmet);
    public CryptoProvider get_CryptoProvider();
    public void set_CryptoProvider(CryptoProvider value);
    public PublishLicense LoadPublishLicense();
    public void SavePublishLicense(PublishLicense publishLicense);
    public UseLicense LoadUseLicense(ContentUser userKey);
    public void SaveUseLicense(ContentUser userKey, UseLicense useLicense);
    public void DeleteUseLicense(ContentUser userKey);
    public IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
}
public class System.IO.Packaging.SignatureVerificationEventArgs : EventArgs {
    public PackageDigitalSignature Signature { get; }
    public VerifyResult VerifyResult { get; }
    internal SignatureVerificationEventArgs(PackageDigitalSignature signature, VerifyResult result);
    public PackageDigitalSignature get_Signature();
    public VerifyResult get_VerifyResult();
}
public class System.IO.Packaging.StorageInfo : object {
    internal StorageInfoCore core;
    public string Name { get; }
    internal string FullNameInternal { get; }
    internal StorageRoot Root { get; }
    internal bool Exists { get; }
    internal IStorage SafeIStorage { get; }
    internal bool StorageDisposed { get; }
    internal StorageInfo(IStorage safeIStorage);
    internal StorageInfo(StorageInfo parent, string fileName);
    private static StorageInfo();
    internal StreamInfoCore CoreForChildStream(string streamName);
    public string get_Name();
    public StreamInfo CreateStream(string name, CompressionOption compressionOption, EncryptionOption encryptionOption);
    public StreamInfo CreateStream(string name);
    public StreamInfo GetStreamInfo(string name);
    public bool StreamExists(string name);
    public void DeleteStream(string name);
    public StorageInfo CreateSubStorage(string name);
    public StorageInfo GetSubStorageInfo(string name);
    public bool SubStorageExists(string name);
    public void DeleteSubStorage(string name);
    public StreamInfo[] GetStreams();
    public StorageInfo[] GetSubStorages();
    internal string get_FullNameInternal();
    internal StorageRoot get_Root();
    internal bool get_Exists();
    internal void Create();
    internal bool Delete(bool recursive, string name);
    internal void RemoveSubStorageEntryFromDataSpaceMap(StorageInfo storageInfo);
    internal void DestroyElement(string elementNameInternal);
    internal bool FindStatStgOfName(string streamName, STATSTG& statStg);
    internal bool StorageIsEmpty();
    internal void InvalidateEnumerators();
    internal ArrayList BuildFullNameFromParentName();
    internal ArrayList BuildFullNameInternalFromParentNameInternal();
    internal IStorage get_SafeIStorage();
    internal static void RecursiveStorageInfoCoreRelease(StorageInfoCore startCore);
    internal void CheckDisposedStatus();
    internal bool get_StorageDisposed();
}
internal class System.IO.Packaging.StorageInfoCore : object {
    internal string storageName;
    internal IStorage safeIStorage;
    internal Hashtable validEnumerators;
    internal Hashtable elementInfoCores;
    internal StorageInfoCore(string nameStorage);
    internal StorageInfoCore(string nameStorage, IStorage storage);
}
internal class System.IO.Packaging.StorageRoot : StorageInfo {
    internal FileAccess OpenAccess { get; }
    internal bool RootDisposed { get; }
    internal FileAccess get_OpenAccess();
    internal static StorageRoot CreateOnStream(Stream baseStream);
    internal static StorageRoot CreateOnStream(Stream baseStream, FileMode mode);
    internal static StorageRoot Open(string path);
    internal static StorageRoot Open(string path, FileMode mode);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static StorageRoot Open(string path, FileMode mode, FileAccess access, FileShare share, int sectorSize);
    internal void Close();
    internal void Flush();
    internal DataSpaceManager GetDataSpaceManager();
    internal IStorage GetRootIStorage();
    internal void CheckRootDisposedStatus();
    internal bool get_RootDisposed();
}
public class System.IO.Packaging.StreamInfo : object {
    public CompressionOption CompressionOption { get; }
    public EncryptionOption EncryptionOption { get; }
    public string Name { get; }
    internal bool StreamInfoDisposed { get; }
    internal CompoundFileStreamReference StreamReference { get; }
    internal StreamInfo(StorageInfo parent, string streamName);
    internal StreamInfo(StorageInfo parent, string streamName, CompressionOption compressionOption, EncryptionOption encryptionOption);
    public CompressionOption get_CompressionOption();
    public EncryptionOption get_EncryptionOption();
    public string get_Name();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    internal Stream Create();
    internal Stream Create(string dataSpaceLabel);
    internal Stream Create(FileMode mode, FileAccess access, string dataSpace);
    internal void Delete();
    internal bool InternalExists();
    internal void CheckDisposedStatus();
    internal bool get_StreamInfoDisposed();
    internal void CheckAccessMode(int grfMode);
    internal CompoundFileStreamReference get_StreamReference();
}
internal class System.IO.Packaging.StreamInfoCore : object {
    internal string streamName;
    internal IStream safeIStream;
    internal string dataSpaceLabel;
    internal object exposedStream;
    internal StreamInfoCore(string nameStream, string label);
    internal StreamInfoCore(string nameStream, string label, IStream s);
}
public enum System.IO.Packaging.TargetMode : Enum {
    public int value__;
    public static TargetMode Internal;
    public static TargetMode External;
}
internal class System.IO.Packaging.TransformEnvironment : object {
    internal bool RequireOtherInstanceData { get; internal set; }
    internal bool RequireInstanceDataUnaltered { get; internal set; }
    internal bool DefaultInstanceDataTransform { get; internal set; }
    internal string TransformLabel { get; }
    internal TransformEnvironment(DataSpaceManager host, string instanceLabel);
    internal bool get_RequireOtherInstanceData();
    internal void set_RequireOtherInstanceData(bool value);
    internal bool get_RequireInstanceDataUnaltered();
    internal void set_RequireInstanceDataUnaltered(bool value);
    internal bool get_DefaultInstanceDataTransform();
    internal void set_DefaultInstanceDataTransform(bool value);
    internal string get_TransformLabel();
    internal Stream GetPrimaryInstanceData();
    internal StorageInfo GetInstanceDataStorage();
}
internal class System.IO.Packaging.TransformInitializationEventArgs : EventArgs {
    internal IDataTransform DataTransform { get; }
    internal string DataSpaceLabel { get; }
    internal string Path { get; }
    internal string TransformInstanceLabel { get; }
    internal TransformInitializationEventArgs(IDataTransform instance, string dataSpaceInstanceLabel, string transformedStreamPath, string transformInstanceLabel);
    internal IDataTransform get_DataTransform();
    internal string get_DataSpaceLabel();
    internal string get_Path();
    internal string get_TransformInstanceLabel();
}
public enum System.IO.Packaging.VerifyResult : Enum {
    public int value__;
    public static VerifyResult Success;
    public static VerifyResult InvalidSignature;
    public static VerifyResult CertificateRequired;
    public static VerifyResult InvalidCertificate;
    public static VerifyResult ReferenceNotFound;
    public static VerifyResult NotSigned;
}
public class System.IO.Packaging.ZipPackage : Package {
    internal ZipPackage(string path, FileMode mode, FileAccess access, FileShare share, bool streaming);
    internal ZipPackage(Stream s, FileMode mode, FileAccess access, bool streaming);
    private static ZipPackage();
    protected virtual PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
    protected virtual PackagePart GetPartCore(Uri partUri);
    protected virtual void DeletePartCore(Uri partUri);
    protected virtual PackagePart[] GetPartsCore();
    protected virtual void FlushCore();
    protected virtual void Dispose(bool disposing);
    internal static string GetZipItemNameFromOpcName(string opcName);
    internal static string GetOpcNameFromZipItemName(string zipItemName);
    internal static void GetZipCompressionMethodFromOpcCompressionOption(CompressionOption compressionOption, CompressionMethodEnum& compressionMethod, DeflateOptionEnum& deflateOption);
}
public class System.IO.Packaging.ZipPackagePart : PackagePart {
    internal List`1<PieceInfo> PieceDescriptors { get; }
    internal ZipFileInfo ZipFileInfo { get; }
    internal ZipPackagePart(ZipPackage container, ZipFileInfo zipFileInfo, ValidatedPartUri partUri, string contentType, CompressionOption compressionOption);
    internal ZipPackagePart(ZipPackage container, ZipArchive zipArchive, ValidatedPartUri partUri, string contentType, CompressionOption compressionOption);
    internal ZipPackagePart(ZipPackage container, ZipArchive zipArchive, List`1<PieceInfo> pieces, ValidatedPartUri partUri, string contentType, CompressionOption compressionOption);
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    internal List`1<PieceInfo> get_PieceDescriptors();
    internal ZipFileInfo get_ZipFileInfo();
}
public class System.Security.Permissions.MediaPermission : CodeAccessPermission {
    public MediaPermissionAudio Audio { get; }
    public MediaPermissionVideo Video { get; }
    public MediaPermissionImage Image { get; }
    public MediaPermission(PermissionState state);
    public MediaPermission(MediaPermissionAudio permissionAudio);
    public MediaPermission(MediaPermissionVideo permissionVideo);
    public MediaPermission(MediaPermissionImage permissionImage);
    public MediaPermission(MediaPermissionAudio permissionAudio, MediaPermissionVideo permissionVideo, MediaPermissionImage permissionImage);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public MediaPermissionAudio get_Audio();
    public MediaPermissionVideo get_Video();
    public MediaPermissionImage get_Image();
    internal static void VerifyMediaPermissionAudio(MediaPermissionAudio level);
    internal static void VerifyMediaPermissionVideo(MediaPermissionVideo level);
    internal static void VerifyMediaPermissionImage(MediaPermissionImage level);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.MediaPermissionAttribute : CodeAccessSecurityAttribute {
    public MediaPermissionAudio Audio { get; public set; }
    public MediaPermissionVideo Video { get; public set; }
    public MediaPermissionImage Image { get; public set; }
    public MediaPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
    public MediaPermissionAudio get_Audio();
    public void set_Audio(MediaPermissionAudio value);
    public MediaPermissionVideo get_Video();
    public void set_Video(MediaPermissionVideo value);
    public MediaPermissionImage get_Image();
    public void set_Image(MediaPermissionImage value);
}
public enum System.Security.Permissions.MediaPermissionAudio : Enum {
    public int value__;
    public static MediaPermissionAudio NoAudio;
    public static MediaPermissionAudio SiteOfOriginAudio;
    public static MediaPermissionAudio SafeAudio;
    public static MediaPermissionAudio AllAudio;
}
public enum System.Security.Permissions.MediaPermissionImage : Enum {
    public int value__;
    public static MediaPermissionImage NoImage;
    public static MediaPermissionImage SiteOfOriginImage;
    public static MediaPermissionImage SafeImage;
    public static MediaPermissionImage AllImage;
}
public enum System.Security.Permissions.MediaPermissionVideo : Enum {
    public int value__;
    public static MediaPermissionVideo NoVideo;
    public static MediaPermissionVideo SiteOfOriginVideo;
    public static MediaPermissionVideo SafeVideo;
    public static MediaPermissionVideo AllVideo;
}
public class System.Security.Permissions.WebBrowserPermission : CodeAccessPermission {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermission(PermissionState state);
    public WebBrowserPermission(WebBrowserPermissionLevel webBrowserPermissionLevel);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
    internal static void VerifyWebBrowserPermissionLevel(WebBrowserPermissionLevel level);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.WebBrowserPermissionAttribute : CodeAccessSecurityAttribute {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
}
public enum System.Security.Permissions.WebBrowserPermissionLevel : Enum {
    public int value__;
    public static WebBrowserPermissionLevel None;
    public static WebBrowserPermissionLevel Safe;
    public static WebBrowserPermissionLevel Unrestricted;
}
public enum System.Security.RightsManagement.AuthenticationType : Enum {
    public int value__;
    public static AuthenticationType Windows;
    public static AuthenticationType Passport;
    public static AuthenticationType WindowsPassport;
    public static AuthenticationType Internal;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.ContentGrant : object {
    public ContentUser User { get; }
    public ContentRight Right { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidUntil { get; }
    public ContentGrant(ContentUser user, ContentRight right);
    public ContentGrant(ContentUser user, ContentRight right, DateTime validFrom, DateTime validUntil);
    public ContentUser get_User();
    public ContentRight get_Right();
    public DateTime get_ValidFrom();
    public DateTime get_ValidUntil();
}
public enum System.Security.RightsManagement.ContentRight : Enum {
    public int value__;
    public static ContentRight View;
    public static ContentRight Edit;
    public static ContentRight Print;
    public static ContentRight Extract;
    public static ContentRight ObjectModel;
    public static ContentRight Owner;
    public static ContentRight ViewRightsData;
    public static ContentRight Forward;
    public static ContentRight Reply;
    public static ContentRight ReplyAll;
    public static ContentRight Sign;
    public static ContentRight DocumentEdit;
    public static ContentRight Export;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.ContentUser : object {
    [SecurityTreatAsSafeAttribute]
internal static ContentUserComparer _contentUserComparer;
    public AuthenticationType AuthenticationType { get; }
    public string Name { get; }
    public static ContentUser AnyoneUser { get; }
    public static ContentUser OwnerUser { get; }
    internal string AuthenticationProviderType { get; }
    public ContentUser(string name, AuthenticationType authenticationType);
    private static ContentUser();
    public AuthenticationType get_AuthenticationType();
    public string get_Name();
    public bool IsAuthenticated();
    public virtual bool Equals(object obj);
    public static ContentUser get_AnyoneUser();
    public static ContentUser get_OwnerUser();
    public virtual int GetHashCode();
    internal string get_AuthenticationProviderType();
    [SecurityTreatAsSafeAttribute]
internal bool GenericEquals(ContentUser userObj);
    internal static bool CompareToAnyone(string name);
    internal static bool CompareToOwner(string name);
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.CryptoProvider : object {
    public int BlockSize { get; }
    public bool CanMergeBlocks { get; }
    public ReadOnlyCollection`1<ContentGrant> BoundGrants { get; }
    public bool CanEncrypt { get; }
    public bool CanDecrypt { get; }
    internal CryptoProvider(List`1<SafeRightsManagementHandle> boundLicenseHandleList, List`1<RightNameExpirationInfoPair> rightsInfoList, ContentUser owner);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public Byte[] Encrypt(Byte[] clearText);
    public Byte[] Decrypt(Byte[] cryptoText);
    protected virtual void Dispose(bool disposing);
    public int get_BlockSize();
    public bool get_CanMergeBlocks();
    public ReadOnlyCollection`1<ContentGrant> get_BoundGrants();
    public bool get_CanEncrypt();
    public bool get_CanDecrypt();
    internal UnsignedPublishLicense DecryptPublishLicense(string serializedPublishLicense);
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.LocalizedNameDescriptionPair : object {
    public string Name { get; }
    public string Description { get; }
    public LocalizedNameDescriptionPair(string name, string description);
    public string get_Name();
    public string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.PublishLicense : object {
    public string ReferralInfoName { get; }
    public Uri ReferralInfoUri { get; }
    public Guid ContentId { get; }
    public Uri UseLicenseAcquisitionUrl { get; }
    public PublishLicense(string signedPublishLicense);
    public UnsignedPublishLicense DecryptUnsignedPublishLicense(CryptoProvider cryptoProvider);
    public string get_ReferralInfoName();
    public Uri get_ReferralInfoUri();
    public Guid get_ContentId();
    public Uri get_UseLicenseAcquisitionUrl();
    public virtual string ToString();
    public UseLicense AcquireUseLicense(SecureEnvironment secureEnvironment);
    public UseLicense AcquireUseLicenseNoUI(SecureEnvironment secureEnvironment);
}
public class System.Security.RightsManagement.RightsManagementException : Exception {
    public RightsManagementFailureCode FailureCode { get; }
    public RightsManagementException(string message);
    public RightsManagementException(string message, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message);
    public RightsManagementException(RightsManagementFailureCode failureCode, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message, Exception innerException);
    protected RightsManagementException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public RightsManagementFailureCode get_FailureCode();
}
public enum System.Security.RightsManagement.RightsManagementFailureCode : Enum {
    public int value__;
    public static RightsManagementFailureCode Success;
    public static RightsManagementFailureCode InvalidLicense;
    public static RightsManagementFailureCode InfoNotInLicense;
    public static RightsManagementFailureCode InvalidLicenseSignature;
    public static RightsManagementFailureCode EncryptionNotPermitted;
    public static RightsManagementFailureCode RightNotGranted;
    public static RightsManagementFailureCode InvalidVersion;
    public static RightsManagementFailureCode InvalidEncodingType;
    public static RightsManagementFailureCode InvalidNumericalValue;
    public static RightsManagementFailureCode InvalidAlgorithmType;
    public static RightsManagementFailureCode EnvironmentNotLoaded;
    public static RightsManagementFailureCode EnvironmentCannotLoad;
    public static RightsManagementFailureCode TooManyLoadedEnvironments;
    public static RightsManagementFailureCode IncompatibleObjects;
    public static RightsManagementFailureCode LibraryFail;
    public static RightsManagementFailureCode EnablingPrincipalFailure;
    public static RightsManagementFailureCode InfoNotPresent;
    public static RightsManagementFailureCode BadGetInfoQuery;
    public static RightsManagementFailureCode KeyTypeUnsupported;
    public static RightsManagementFailureCode CryptoOperationUnsupported;
    public static RightsManagementFailureCode ClockRollbackDetected;
    public static RightsManagementFailureCode QueryReportsNoResults;
    public static RightsManagementFailureCode UnexpectedException;
    public static RightsManagementFailureCode BindValidityTimeViolated;
    public static RightsManagementFailureCode BrokenCertChain;
    public static RightsManagementFailureCode BindPolicyViolation;
    public static RightsManagementFailureCode ManifestPolicyViolation;
    public static RightsManagementFailureCode BindRevokedLicense;
    public static RightsManagementFailureCode BindRevokedIssuer;
    public static RightsManagementFailureCode BindRevokedPrincipal;
    public static RightsManagementFailureCode BindRevokedResource;
    public static RightsManagementFailureCode BindRevokedModule;
    public static RightsManagementFailureCode BindContentNotInEndUseLicense;
    public static RightsManagementFailureCode BindAccessPrincipalNotEnabling;
    public static RightsManagementFailureCode BindAccessUnsatisfied;
    public static RightsManagementFailureCode BindIndicatedPrincipalMissing;
    public static RightsManagementFailureCode BindMachineNotFoundInGroupIdentity;
    public static RightsManagementFailureCode LibraryUnsupportedPlugIn;
    public static RightsManagementFailureCode BindRevocationListStale;
    public static RightsManagementFailureCode BindNoApplicableRevocationList;
    public static RightsManagementFailureCode InvalidHandle;
    public static RightsManagementFailureCode BindIntervalTimeViolated;
    public static RightsManagementFailureCode BindNoSatisfiedRightsGroup;
    public static RightsManagementFailureCode BindSpecifiedWorkMissing;
    public static RightsManagementFailureCode NoMoreData;
    public static RightsManagementFailureCode LicenseAcquisitionFailed;
    public static RightsManagementFailureCode IdMismatch;
    public static RightsManagementFailureCode TooManyCertificates;
    public static RightsManagementFailureCode NoDistributionPointUrlFound;
    public static RightsManagementFailureCode AlreadyInProgress;
    public static RightsManagementFailureCode GroupIdentityNotSet;
    public static RightsManagementFailureCode RecordNotFound;
    public static RightsManagementFailureCode NoConnect;
    public static RightsManagementFailureCode NoLicense;
    public static RightsManagementFailureCode NeedsMachineActivation;
    public static RightsManagementFailureCode NeedsGroupIdentityActivation;
    public static RightsManagementFailureCode ActivationFailed;
    public static RightsManagementFailureCode Aborted;
    public static RightsManagementFailureCode OutOfQuota;
    public static RightsManagementFailureCode AuthenticationFailed;
    public static RightsManagementFailureCode ServerError;
    public static RightsManagementFailureCode InstallationFailed;
    public static RightsManagementFailureCode HidCorrupted;
    public static RightsManagementFailureCode InvalidServerResponse;
    public static RightsManagementFailureCode ServiceNotFound;
    public static RightsManagementFailureCode UseDefault;
    public static RightsManagementFailureCode ServerNotFound;
    public static RightsManagementFailureCode InvalidEmail;
    public static RightsManagementFailureCode ValidityTimeViolation;
    public static RightsManagementFailureCode OutdatedModule;
    public static RightsManagementFailureCode ServiceMoved;
    public static RightsManagementFailureCode ServiceGone;
    public static RightsManagementFailureCode AdEntryNotFound;
    public static RightsManagementFailureCode NotAChain;
    public static RightsManagementFailureCode RequestDenied;
    public static RightsManagementFailureCode NotSet;
    public static RightsManagementFailureCode MetadataNotSet;
    public static RightsManagementFailureCode RevocationInfoNotSet;
    public static RightsManagementFailureCode InvalidTimeInfo;
    public static RightsManagementFailureCode RightNotSet;
    public static RightsManagementFailureCode LicenseBindingToWindowsIdentityFailed;
    public static RightsManagementFailureCode InvalidIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidKeyLength;
    public static RightsManagementFailureCode ExpiredOfficialIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidClientLicensorCertificate;
    public static RightsManagementFailureCode HidInvalid;
    public static RightsManagementFailureCode EmailNotVerified;
    public static RightsManagementFailureCode DebuggerDetected;
    public static RightsManagementFailureCode InvalidLockboxType;
    public static RightsManagementFailureCode InvalidLockboxPath;
    public static RightsManagementFailureCode InvalidRegistryPath;
    public static RightsManagementFailureCode NoAesCryptoProvider;
    public static RightsManagementFailureCode GlobalOptionAlreadySet;
    public static RightsManagementFailureCode OwnerLicenseNotFound;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.SecureEnvironment : object {
    public ContentUser User { get; }
    public string ApplicationManifest { get; }
    internal ClientSession ClientSession { get; }
    public static SecureEnvironment Create(string applicationManifest, ContentUser user);
    public static SecureEnvironment Create(string applicationManifest, AuthenticationType authentication, UserActivationMode userActivationMode);
    public static bool IsUserActivated(ContentUser user);
    public static void RemoveActivatedUser(ContentUser user);
    public static ReadOnlyCollection`1<ContentUser> GetActivatedUsers();
    public sealed virtual void Dispose();
    public ContentUser get_User();
    public string get_ApplicationManifest();
    protected virtual void Dispose(bool disposing);
    internal ClientSession get_ClientSession();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.UnsignedPublishLicense : object {
    public ContentUser Owner { get; public set; }
    public string ReferralInfoName { get; public set; }
    public Uri ReferralInfoUri { get; public set; }
    public Guid ContentId { get; public set; }
    public ICollection`1<ContentGrant> Grants { get; }
    public IDictionary`2<int, LocalizedNameDescriptionPair> LocalizedNameDescriptionDictionary { get; }
    internal int RightValidityIntervalDays { get; internal set; }
    internal IDictionary`2<string, string> ApplicationSpecificDataDictionary { get; }
    internal RevocationPoint RevocationPoint { get; internal set; }
    public UnsignedPublishLicense(string publishLicenseTemplate);
    internal UnsignedPublishLicense(SafeRightsManagementHandle boundLicenseHandle, string publishLicenseTemplate);
    public PublishLicense Sign(SecureEnvironment secureEnvironment, UseLicense& authorUseLicense);
    public ContentUser get_Owner();
    public void set_Owner(ContentUser value);
    public string get_ReferralInfoName();
    public void set_ReferralInfoName(string value);
    public Uri get_ReferralInfoUri();
    public void set_ReferralInfoUri(Uri value);
    public Guid get_ContentId();
    public void set_ContentId(Guid value);
    public ICollection`1<ContentGrant> get_Grants();
    public IDictionary`2<int, LocalizedNameDescriptionPair> get_LocalizedNameDescriptionDictionary();
    public virtual string ToString();
    internal int get_RightValidityIntervalDays();
    internal void set_RightValidityIntervalDays(int value);
    internal IDictionary`2<string, string> get_ApplicationSpecificDataDictionary();
    internal RevocationPoint get_RevocationPoint();
    internal void set_RevocationPoint(RevocationPoint value);
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.UseLicense : object {
    public ContentUser Owner { get; }
    public Guid ContentId { get; }
    public IDictionary`2<string, string> ApplicationData { get; }
    public UseLicense(string useLicense);
    public ContentUser get_Owner();
    public Guid get_ContentId();
    public virtual string ToString();
    public CryptoProvider Bind(SecureEnvironment secureEnvironment);
    public IDictionary`2<string, string> get_ApplicationData();
    public virtual bool Equals(object x);
    public virtual int GetHashCode();
}
public enum System.Security.RightsManagement.UserActivationMode : Enum {
    public int value__;
    public static UserActivationMode Permanent;
    public static UserActivationMode Temporary;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.AlternativeExpressionStorageCallback : MulticastDelegate {
    public AlternativeExpressionStorageCallback(object object, IntPtr method);
    public virtual Expression Invoke(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.AttachedPropertyBrowsableAttribute : Attribute {
    internal bool UnionResults { get; }
    internal virtual bool get_UnionResults();
    [FriendAccessAllowedAttribute]
internal abstract virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForTypeAttribute : AttachedPropertyBrowsableAttribute {
    public Type TargetType { get; }
    public object TypeId { get; }
    internal bool UnionResults { get; }
    public AttachedPropertyBrowsableForTypeAttribute(Type targetType);
    public Type get_TargetType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
    internal virtual bool get_UnionResults();
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute : AttachedPropertyBrowsableAttribute {
    public Type AttributeType { get; }
    public AttachedPropertyBrowsableWhenAttributePresentAttribute(Type attributeType);
    public Type get_AttributeType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
public static class System.Windows.BaseCompatibilityPreferences : object {
    public static bool ReuseDispatcherSynchronizationContextInstance { get; public set; }
    public static bool FlowDispatcherSynchronizationContextPriority { get; public set; }
    public static bool InlineDispatcherSynchronizationContextSend { get; public set; }
    private static BaseCompatibilityPreferences();
    public static bool get_ReuseDispatcherSynchronizationContextInstance();
    public static void set_ReuseDispatcherSynchronizationContextInstance(bool value);
    internal static bool GetReuseDispatcherSynchronizationContextInstance();
    public static bool get_FlowDispatcherSynchronizationContextPriority();
    public static void set_FlowDispatcherSynchronizationContextPriority(bool value);
    internal static bool GetFlowDispatcherSynchronizationContextPriority();
    public static bool get_InlineDispatcherSynchronizationContextSend();
    public static void set_InlineDispatcherSynchronizationContextSend(bool value);
    internal static bool GetInlineDispatcherSynchronizationContextSend();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.BaseValueSourceInternal : Enum {
    public short value__;
    public static BaseValueSourceInternal Unknown;
    public static BaseValueSourceInternal Default;
    public static BaseValueSourceInternal Inherited;
    public static BaseValueSourceInternal ThemeStyle;
    public static BaseValueSourceInternal ThemeStyleTrigger;
    public static BaseValueSourceInternal Style;
    public static BaseValueSourceInternal TemplateTrigger;
    public static BaseValueSourceInternal StyleTrigger;
    public static BaseValueSourceInternal ImplicitReference;
    public static BaseValueSourceInternal ParentTemplate;
    public static BaseValueSourceInternal ParentTemplateTrigger;
    public static BaseValueSourceInternal Local;
}
public class System.Windows.CoerceValueCallback : MulticastDelegate {
    public CoerceValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, object baseValue);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, object baseValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.Windows.Converters.Int32RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.PointValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.SizeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.VectorValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public abstract class System.Windows.Data.DataSourceProvider : object {
    [DefaultValueAttribute("True")]
public bool IsInitialLoadEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public object Data { get; }
    public Exception Error { get; }
    protected bool IsRefreshDeferred { get; }
    protected Dispatcher Dispatcher { get; protected set; }
    private static DataSourceProvider();
    public void InitialLoad();
    public void Refresh();
    public bool get_IsInitialLoadEnabled();
    public void set_IsInitialLoadEnabled(bool value);
    public object get_Data();
    [CompilerGeneratedAttribute]
public void add_DataChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataChanged(EventHandler value);
    public Exception get_Error();
    public virtual IDisposable DeferRefresh();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected bool get_IsRefreshDeferred();
    protected Dispatcher get_Dispatcher();
    protected void set_Dispatcher(Dispatcher value);
    protected virtual void BeginQuery();
    protected void OnQueryFinished(object newData);
    protected virtual void OnQueryFinished(object newData, Exception error, DispatcherOperationCallback completionWork, object callbackArguments);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void BeginInit();
    protected virtual void EndInit();
}
internal class System.Windows.DeferredMutableDefaultReference : DeferredReference {
    internal PropertyMetadata SourceMetadata { get; }
    protected DependencyObject SourceObject { get; }
    protected DependencyProperty SourceProperty { get; }
    internal DeferredMutableDefaultReference(PropertyMetadata metadata, DependencyObject d, DependencyProperty dp);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal PropertyMetadata get_SourceMetadata();
    protected DependencyObject get_SourceObject();
    protected DependencyProperty get_SourceProperty();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.DeferredReference : object {
    internal abstract virtual object GetValue(BaseValueSourceInternal valueSource);
    internal abstract virtual Type GetValueType();
}
[TypeDescriptionProviderAttribute("MS.Internal.ComponentModel.DependencyObjectProvider")]
[NameScopePropertyAttribute("NameScope", "System.Windows.NameScope")]
public class System.Windows.DependencyObject : DispatcherObject {
    [FriendAccessAllowedAttribute]
internal static DependencyProperty DirectDependencyProperty;
    internal object _contextStorage;
    [FriendAccessAllowedAttribute]
internal static object ExpressionInAlternativeStore;
    internal static UncommonField`1<object> DependentListMapField;
    internal static DependencyObjectType DType;
    public DependencyObjectType DependencyObjectType { get; }
    public bool IsSealed { get; }
    [FriendAccessAllowedAttribute]
internal bool IsInheritanceContextSealed { get; internal set; }
    internal bool Freezable_Frozen { get; internal set; }
    internal bool Freezable_HasMultipleInheritanceContexts { get; internal set; }
    internal bool Freezable_UsingHandlerList { get; internal set; }
    internal bool Freezable_UsingContextList { get; internal set; }
    internal bool Freezable_UsingSingletonHandler { get; internal set; }
    internal bool Freezable_UsingSingletonContext { get; internal set; }
    internal bool Animatable_IsResourceInvalidationNecessary { get; internal set; }
    internal bool IAnimatable_HasAnimatedProperties { get; internal set; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool CanBeInheritanceContext { get; internal set; }
    internal EffectiveValueEntry[] EffectiveValues { get; }
    internal UInt32 EffectiveValuesCount { get; private set; }
    internal UInt32 InheritableEffectiveValuesCount { get; internal set; }
    internal DependencyObject InheritanceParent { get; }
    internal bool IsSelfInheritanceParent { get; }
    [FriendAccessAllowedAttribute]
internal int EffectiveValuesInitialSize { get; }
    private static DependencyObject();
    public DependencyObjectType get_DependencyObjectType();
    [FriendAccessAllowedAttribute]
internal virtual void Seal();
    public bool get_IsSealed();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public object GetValue(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry GetValueEntry(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, RequestFlags requests);
    public void SetValue(DependencyProperty dp, object value);
    public void SetCurrentValue(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetValue(DependencyProperty dp, bool value);
    [FriendAccessAllowedAttribute]
internal void SetCurrentValue(DependencyProperty dp, bool value);
    [FriendAccessAllowedAttribute]
internal void SetValueInternal(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetCurrentValueInternal(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetDeferredValue(DependencyProperty dp, DeferredReference deferredReference);
    [FriendAccessAllowedAttribute]
internal void SetCurrentDeferredValue(DependencyProperty dp, DeferredReference deferredReference);
    [FriendAccessAllowedAttribute]
internal void SetMutableDefaultValue(DependencyProperty dp, object value);
    [FriendAccessAllowedAttribute]
internal void SetValue(DependencyPropertyKey dp, bool value);
    public void SetValue(DependencyPropertyKey key, object value);
    [FriendAccessAllowedAttribute]
internal bool ProvideSelfAsInheritanceContext(object value, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool ProvideSelfAsInheritanceContext(DependencyObject doValue, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool RemoveSelfAsInheritanceContext(object value, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal bool RemoveSelfAsInheritanceContext(DependencyObject doValue, DependencyProperty dp);
    public void ClearValue(DependencyProperty dp);
    public void ClearValue(DependencyPropertyKey key);
    internal bool ContainsValue(DependencyProperty dp);
    internal static void ChangeExpressionSources(Expression expr, DependencyObject d, DependencyProperty dp, DependencySource[] newSources);
    public void CoerceValue(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal void InvalidateSubProperty(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal void NotifySubPropertyChange(DependencyProperty dp);
    public void InvalidateProperty(DependencyProperty dp);
    internal void InvalidateProperty(DependencyProperty dp, bool preserveCurrentValue);
    [FriendAccessAllowedAttribute]
internal UpdateResult UpdateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry& newEntry, bool coerceWithDeferredReference, bool coerceWithCurrentValue, OperationType operationType);
    [FriendAccessAllowedAttribute]
internal void NotifyPropertyChange(DependencyPropertyChangedEventArgs args);
    internal virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal GetValueSource(DependencyProperty dp, PropertyMetadata metadata, Boolean& hasModifiers);
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal GetValueSource(DependencyProperty dp, PropertyMetadata metadata, Boolean& hasModifiers, Boolean& isExpression, Boolean& isAnimated, Boolean& isCoerced, Boolean& isCurrent);
    public object ReadLocalValue(DependencyProperty dp);
    internal object ReadLocalValueEntry(EntryIndex entryIndex, DependencyProperty dp, bool allowDeferredReferences);
    public LocalValueEnumerator GetLocalValueEnumerator();
    internal bool get_IsInheritanceContextSealed();
    internal void set_IsInheritanceContextSealed(bool value);
    internal bool get_Freezable_Frozen();
    internal void set_Freezable_Frozen(bool value);
    internal bool get_Freezable_HasMultipleInheritanceContexts();
    internal void set_Freezable_HasMultipleInheritanceContexts(bool value);
    internal bool get_Freezable_UsingHandlerList();
    internal void set_Freezable_UsingHandlerList(bool value);
    internal bool get_Freezable_UsingContextList();
    internal void set_Freezable_UsingContextList(bool value);
    internal bool get_Freezable_UsingSingletonHandler();
    internal void set_Freezable_UsingSingletonHandler(bool value);
    internal bool get_Freezable_UsingSingletonContext();
    internal void set_Freezable_UsingSingletonContext(bool value);
    [FriendAccessAllowedAttribute]
internal bool get_Animatable_IsResourceInvalidationNecessary();
    [FriendAccessAllowedAttribute]
internal void set_Animatable_IsResourceInvalidationNecessary(bool value);
    [FriendAccessAllowedAttribute]
internal bool get_IAnimatable_HasAnimatedProperties();
    [FriendAccessAllowedAttribute]
internal void set_IAnimatable_HasAnimatedProperties(bool value);
    internal static void UpdateSourceDependentLists(DependencyObject d, DependencyProperty dp, DependencySource[] sources, Expression expr, bool add);
    internal static void ValidateSources(DependencyObject d, DependencySource[] newSources, Expression expr);
    [FriendAccessAllowedAttribute]
internal static void RegisterForAlternativeExpressionStorage(AlternativeExpressionStorageCallback getExpressionCore, AlternativeExpressionStorageCallback& getExpression);
    internal bool HasAnyExpression();
    [FriendAccessAllowedAttribute]
internal bool HasExpression(EntryIndex entryIndex, DependencyProperty dp);
    [FriendAccessAllowedAttribute]
internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    [FriendAccessAllowedAttribute]
internal void OnInheritanceContextChanged(EventArgs args);
    [FriendAccessAllowedAttribute]
internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    [FriendAccessAllowedAttribute]
internal void add_InheritanceContextChanged(EventHandler value);
    [FriendAccessAllowedAttribute]
internal void remove_InheritanceContextChanged(EventHandler value);
    internal virtual bool get_HasMultipleInheritanceContexts();
    [FriendAccessAllowedAttribute]
internal bool get_CanBeInheritanceContext();
    [FriendAccessAllowedAttribute]
internal void set_CanBeInheritanceContext(bool value);
    [FriendAccessAllowedAttribute]
internal static bool IsTreeWalkOperation(OperationType operation);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertNoInheritanceContextListeners();
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry[] get_EffectiveValues();
    [FriendAccessAllowedAttribute]
internal UInt32 get_EffectiveValuesCount();
    private void set_EffectiveValuesCount(UInt32 value);
    [FriendAccessAllowedAttribute]
internal UInt32 get_InheritableEffectiveValuesCount();
    internal void set_InheritableEffectiveValuesCount(UInt32 value);
    [FriendAccessAllowedAttribute]
internal void BeginPropertyInitialization();
    [FriendAccessAllowedAttribute]
internal void EndPropertyInitialization();
    [FriendAccessAllowedAttribute]
internal DependencyObject get_InheritanceParent();
    [FriendAccessAllowedAttribute]
internal bool get_IsSelfInheritanceParent();
    [FriendAccessAllowedAttribute]
internal void SetIsSelfInheritanceParent();
    [FriendAccessAllowedAttribute]
internal void SynchronizeInheritanceParent(DependencyObject parent);
    [FriendAccessAllowedAttribute]
internal EntryIndex LookupEntry(int targetIndex);
    internal virtual int get_EffectiveValuesInitialSize();
    internal void SetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry newEntry, EffectiveValueEntry oldEntry);
    [FriendAccessAllowedAttribute]
internal void SetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, int targetIndex, PropertyMetadata metadata, object value, BaseValueSourceInternal valueSource);
    internal void UnsetEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata);
}
public class System.Windows.DependencyObjectType : object {
    public int Id { get; }
    public Type SystemType { get; }
    public DependencyObjectType BaseType { get; }
    public string Name { get; }
    private static DependencyObjectType();
    public static DependencyObjectType FromSystemType(Type systemType);
    [FriendAccessAllowedAttribute]
internal static DependencyObjectType FromSystemTypeInternal(Type systemType);
    public int get_Id();
    public Type get_SystemType();
    public DependencyObjectType get_BaseType();
    public string get_Name();
    public bool IsInstanceOfType(DependencyObject dependencyObject);
    public bool IsSubclassOf(DependencyObjectType dependencyObjectType);
    public virtual int GetHashCode();
}
[TypeConverterAttribute("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.DependencyPropertyValueSerializer")]
public class System.Windows.DependencyProperty : object {
    public static object UnsetValue;
    internal InsertionSortMap _metadataMap;
    internal static ItemStructList`1<DependencyProperty> RegisteredPropertyList;
    internal static object Synchronized;
    public string Name { get; }
    public Type PropertyType { get; }
    public Type OwnerType { get; }
    public PropertyMetadata DefaultMetadata { get; }
    public ValidateValueCallback ValidateValueCallback { get; }
    public int GlobalIndex { get; }
    internal bool IsObjectType { get; }
    internal bool IsValueType { get; }
    internal bool IsFreezableType { get; }
    internal bool IsStringType { get; }
    internal bool IsPotentiallyInherited { get; }
    internal bool IsDefaultValueChanged { get; }
    internal bool IsPotentiallyUsingDefaultValueFactory { get; }
    public bool ReadOnly { get; }
    internal DependencyPropertyKey DependencyPropertyKey { get; }
    internal CoerceValueCallback DesignerCoerceValueCallback { get; internal set; }
    internal static int RegisteredPropertyCount { get; }
    internal static IEnumerable RegisteredProperties { get; }
    private static DependencyProperty();
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    internal void ValidateFactoryDefaultValue(object defaultValue);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyPropertyKey key);
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(DependencyObjectType dependencyObjectType);
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(Type forType);
    public PropertyMetadata GetMetadata(Type forType);
    public PropertyMetadata GetMetadata(DependencyObject dependencyObject);
    public PropertyMetadata GetMetadata(DependencyObjectType dependencyObjectType);
    public DependencyProperty AddOwner(Type ownerType);
    public DependencyProperty AddOwner(Type ownerType, PropertyMetadata typeMetadata);
    public string get_Name();
    public Type get_PropertyType();
    public Type get_OwnerType();
    public PropertyMetadata get_DefaultMetadata();
    public ValidateValueCallback get_ValidateValueCallback();
    public int get_GlobalIndex();
    internal bool get_IsObjectType();
    internal bool get_IsValueType();
    internal bool get_IsFreezableType();
    internal bool get_IsStringType();
    internal bool get_IsPotentiallyInherited();
    internal bool get_IsDefaultValueChanged();
    internal bool get_IsPotentiallyUsingDefaultValueFactory();
    public virtual int GetHashCode();
    public bool IsValidType(object value);
    public bool IsValidValue(object value);
    public bool get_ReadOnly();
    internal DependencyPropertyKey get_DependencyPropertyKey();
    internal void VerifyReadOnlyKey(DependencyPropertyKey candidateKey);
    internal bool IsValidValueInternal(object value);
    [FriendAccessAllowedAttribute]
internal static DependencyProperty FromName(string name, Type ownerType);
    public virtual string ToString();
    internal static bool IsValidType(object value, Type propertyType);
    internal static int GetUniqueGlobalIndex(Type ownerType, string name);
    internal CoerceValueCallback get_DesignerCoerceValueCallback();
    internal void set_DesignerCoerceValueCallback(CoerceValueCallback value);
    internal static int get_RegisteredPropertyCount();
    [IteratorStateMachineAttribute("System.Windows.DependencyProperty/<get_RegisteredProperties>d__1")]
internal static IEnumerable get_RegisteredProperties();
}
public class System.Windows.DependencyPropertyChangedEventArgs : ValueType {
    private DependencyProperty _property;
    private PropertyMetadata _metadata;
    private PrivateFlags _flags;
    private EffectiveValueEntry _oldEntry;
    private EffectiveValueEntry _newEntry;
    private OperationType _operationType;
    public DependencyProperty Property { get; }
    [FriendAccessAllowedAttribute]
internal bool IsAValueChange { get; internal set; }
    [FriendAccessAllowedAttribute]
internal bool IsASubPropertyChange { get; internal set; }
    [FriendAccessAllowedAttribute]
internal PropertyMetadata Metadata { get; }
    [FriendAccessAllowedAttribute]
internal OperationType OperationType { get; }
    public object OldValue { get; }
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry OldEntry { get; }
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal OldValueSource { get; }
    [FriendAccessAllowedAttribute]
internal bool IsOldValueModified { get; }
    [FriendAccessAllowedAttribute]
internal bool IsOldValueDeferred { get; }
    public object NewValue { get; }
    [FriendAccessAllowedAttribute]
internal EffectiveValueEntry NewEntry { get; }
    [FriendAccessAllowedAttribute]
internal BaseValueSourceInternal NewValueSource { get; }
    [FriendAccessAllowedAttribute]
internal bool IsNewValueModified { get; }
    [FriendAccessAllowedAttribute]
internal bool IsNewValueDeferred { get; }
    public DependencyPropertyChangedEventArgs(DependencyProperty property, object oldValue, object newValue);
    [FriendAccessAllowedAttribute]
internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, object oldValue, object newValue);
    internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, object value);
    internal DependencyPropertyChangedEventArgs(DependencyProperty property, PropertyMetadata metadata, bool isAValueChange, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry, OperationType operationType);
    public DependencyProperty get_Property();
    internal bool get_IsAValueChange();
    internal void set_IsAValueChange(bool value);
    internal bool get_IsASubPropertyChange();
    internal void set_IsASubPropertyChange(bool value);
    internal PropertyMetadata get_Metadata();
    internal OperationType get_OperationType();
    public object get_OldValue();
    internal EffectiveValueEntry get_OldEntry();
    internal BaseValueSourceInternal get_OldValueSource();
    internal bool get_IsOldValueModified();
    internal bool get_IsOldValueDeferred();
    public object get_NewValue();
    internal EffectiveValueEntry get_NewEntry();
    internal BaseValueSourceInternal get_NewValueSource();
    internal bool get_IsNewValueModified();
    internal bool get_IsNewValueDeferred();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(DependencyPropertyChangedEventArgs args);
    public static bool op_Equality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    public static bool op_Inequality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
}
public class System.Windows.DependencyPropertyChangedEventHandler : MulticastDelegate {
    public DependencyPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DependencyPropertyKey : object {
    public DependencyProperty DependencyProperty { get; }
    internal DependencyPropertyKey(DependencyProperty dp);
    public DependencyProperty get_DependencyProperty();
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    internal void SetDependencyProperty(DependencyProperty dp);
}
internal class System.Windows.DependencyPropertyValueSerializer : ValueSerializer {
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual IEnumerable`1<Type> TypeReferences(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
internal class System.Windows.DependencySource : object {
    public DependencyObject DependencyObject { get; }
    public DependencyProperty DependencyProperty { get; }
    public DependencySource(DependencyObject d, DependencyProperty dp);
    public DependencyObject get_DependencyObject();
    public DependencyProperty get_DependencyProperty();
}
internal class System.Windows.Dependent : ValueType {
    private DependencyProperty _DP;
    private WeakReference _wrDO;
    private WeakReference _wrEX;
    public DependencyObject DO { get; }
    public DependencyProperty DP { get; }
    public Expression Expr { get; }
    public Dependent(DependencyObject o, DependencyProperty p, Expression e);
    public bool IsValid();
    public DependencyObject get_DO();
    public DependencyProperty get_DP();
    public Expression get_Expr();
    public virtual bool Equals(object o);
    public static bool op_Equality(Dependent first, Dependent second);
    public static bool op_Inequality(Dependent first, Dependent second);
    public virtual int GetHashCode();
}
internal class System.Windows.DependentList : FrugalObjectList`1<Dependent> {
    public bool IsEmpty { get; }
    public void Add(DependencyObject d, DependencyProperty dp, Expression expr);
    public void Remove(DependencyObject d, DependencyProperty dp, Expression expr);
    public bool get_IsEmpty();
    public void InvalidateDependents(DependencyObject source, DependencyPropertyChangedEventArgs sourceArgs);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.EffectiveValueEntry : ValueType {
    private object _value;
    private short _propertyIndex;
    private FullValueSource _source;
    public int PropertyIndex { get; public set; }
    internal object Value { get; internal set; }
    internal BaseValueSourceInternal BaseValueSourceInternal { get; internal set; }
    internal bool IsDeferredReference { get; private set; }
    internal bool IsExpression { get; private set; }
    internal bool IsAnimated { get; private set; }
    internal bool IsCoerced { get; private set; }
    internal bool HasModifiers { get; }
    internal FullValueSource FullValueSource { get; }
    internal bool HasExpressionMarker { get; internal set; }
    internal bool IsCoercedWithCurrentValue { get; internal set; }
    internal object LocalValue { get; internal set; }
    internal ModifiedValue ModifiedValue { get; }
    internal EffectiveValueEntry(DependencyProperty dp);
    internal EffectiveValueEntry(DependencyProperty dp, BaseValueSourceInternal valueSource);
    internal EffectiveValueEntry(DependencyProperty dp, FullValueSource fullValueSource);
    internal static EffectiveValueEntry CreateDefaultValueEntry(DependencyProperty dp, object value);
    internal void SetExpressionValue(object value, object baseValue);
    internal void SetAnimatedValue(object value, object baseValue);
    internal void SetCoercedValue(object value, object baseValue, bool skipBaseValueChecks, bool coerceWithCurrentValue);
    internal void ResetAnimatedValue();
    internal void ResetCoercedValue();
    internal void ResetValue(object value, bool hasExpressionMarker);
    internal void RestoreExpressionMarker();
    public int get_PropertyIndex();
    public void set_PropertyIndex(int value);
    internal object get_Value();
    internal void set_Value(object value);
    internal BaseValueSourceInternal get_BaseValueSourceInternal();
    internal void set_BaseValueSourceInternal(BaseValueSourceInternal value);
    internal bool get_IsDeferredReference();
    private void set_IsDeferredReference(bool value);
    internal bool get_IsExpression();
    private void set_IsExpression(bool value);
    internal bool get_IsAnimated();
    private void set_IsAnimated(bool value);
    internal bool get_IsCoerced();
    private void set_IsCoerced(bool value);
    internal bool get_HasModifiers();
    internal FullValueSource get_FullValueSource();
    internal bool get_HasExpressionMarker();
    internal void set_HasExpressionMarker(bool value);
    internal bool get_IsCoercedWithCurrentValue();
    internal void set_IsCoercedWithCurrentValue(bool value);
    internal EffectiveValueEntry GetFlattenedEntry(RequestFlags requests);
    internal void SetAnimationBaseValue(object animationBaseValue);
    internal void SetCoersionBaseValue(object coersionBaseValue);
    internal object get_LocalValue();
    internal void set_LocalValue(object value);
    internal ModifiedValue get_ModifiedValue();
    internal void Clear();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.EntryIndex : ValueType {
    private UInt32 _store;
    public bool Found { get; }
    public UInt32 Index { get; }
    public EntryIndex(UInt32 index);
    public EntryIndex(UInt32 index, bool found);
    public bool get_Found();
    public UInt32 get_Index();
}
[TypeConverterAttribute("System.Windows.ExpressionConverter")]
public class System.Windows.Expression : object {
    [FriendAccessAllowedAttribute]
internal static object NoValue;
    internal bool Attachable { get; }
    internal bool Shareable { get; }
    internal bool ForwardsInvalidations { get; }
    internal bool SupportsUnboundSources { get; }
    internal bool HasBeenAttached { get; }
    internal bool HasBeenDetached { get; }
    internal Expression(ExpressionMode mode);
    private static Expression();
    [FriendAccessAllowedAttribute]
internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    internal virtual DependencySource[] GetSources();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal void ChangeSources(DependencyObject d, DependencyProperty dp, DependencySource[] newSources);
    internal bool get_Attachable();
    internal bool get_Shareable();
    internal bool get_ForwardsInvalidations();
    internal bool get_SupportsUnboundSources();
    internal bool get_HasBeenAttached();
    internal bool get_HasBeenDetached();
    internal void MarkAttached();
    internal void MarkDetached();
}
public class System.Windows.ExpressionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal enum System.Windows.ExpressionMode : Enum {
    public int value__;
    public static ExpressionMode None;
    public static ExpressionMode NonSharable;
    public static ExpressionMode ForwardsInvalidations;
    public static ExpressionMode SupportsUnboundSources;
}
public abstract class System.Windows.Freezable : DependencyObject {
    public bool CanFreeze { get; }
    public bool IsFrozen { get; }
    internal bool IsFrozenInternal { get; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    private static Freezable();
    public Freezable Clone();
    public Freezable CloneCurrentValue();
    public Freezable GetAsFrozen();
    public Freezable GetCurrentValueAsFrozen();
    public bool get_CanFreeze();
    public void Freeze();
    public bool get_IsFrozen();
    internal bool get_IsFrozenInternal();
    public void add_Changed(EventHandler value);
    public void remove_Changed(EventHandler value);
    internal void add_ChangedInternal(EventHandler value);
    internal void remove_ChangedInternal(EventHandler value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected Freezable CreateInstance();
    protected abstract virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected void ReadPreamble();
    protected void WritePreamble();
    protected void WritePostscript();
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue);
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue, DependencyProperty property);
    protected internal static bool Freeze(Freezable freezable, bool isChecking);
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal void ClearContextAndHandlers();
    internal void FireChanged();
    internal virtual void Seal();
    internal bool Freeze(bool isChecking);
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal void AddContextInformation(DependencyObject context, DependencyProperty property);
    [FriendAccessAllowedAttribute]
internal virtual DependencyObject get_InheritanceContext();
    [FriendAccessAllowedAttribute]
internal virtual bool get_HasMultipleInheritanceContexts();
}
internal class System.Windows.FreezeValueCallback : MulticastDelegate {
    public FreezeValueCallback(object object, IntPtr method);
    public virtual bool Invoke(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.FullValueSource : Enum {
    public short value__;
    public static FullValueSource ValueSourceMask;
    public static FullValueSource ModifiersMask;
    public static FullValueSource IsExpression;
    public static FullValueSource IsAnimated;
    public static FullValueSource IsCoerced;
    public static FullValueSource IsPotentiallyADeferredReference;
    public static FullValueSource HasExpressionMarker;
    public static FullValueSource IsCoercedWithCurrentValue;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.GetReadOnlyValueCallback : MulticastDelegate {
    public GetReadOnlyValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, BaseValueSourceInternal& source);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, BaseValueSourceInternal& source, AsyncCallback callback, object object);
    public virtual object EndInvoke(BaseValueSourceInternal& source, IAsyncResult result);
}
public enum System.Windows.Input.FocusNavigationDirection : Enum {
    public int value__;
    public static FocusNavigationDirection Next;
    public static FocusNavigationDirection Previous;
    public static FocusNavigationDirection First;
    public static FocusNavigationDirection Last;
    public static FocusNavigationDirection Left;
    public static FocusNavigationDirection Right;
    public static FocusNavigationDirection Up;
    public static FocusNavigationDirection Down;
}
[TypeConverterAttribute("System.Windows.Input.KeyConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyValueSerializer")]
public enum System.Windows.Input.Key : Enum {
    public int value__;
    public static Key None;
    public static Key Cancel;
    public static Key Back;
    public static Key Tab;
    public static Key LineFeed;
    public static Key Clear;
    public static Key Return;
    public static Key Enter;
    public static Key Pause;
    public static Key Capital;
    public static Key CapsLock;
    public static Key KanaMode;
    public static Key HangulMode;
    public static Key JunjaMode;
    public static Key FinalMode;
    public static Key HanjaMode;
    public static Key KanjiMode;
    public static Key Escape;
    public static Key ImeConvert;
    public static Key ImeNonConvert;
    public static Key ImeAccept;
    public static Key ImeModeChange;
    public static Key Space;
    public static Key Prior;
    public static Key PageUp;
    public static Key Next;
    public static Key PageDown;
    public static Key End;
    public static Key Home;
    public static Key Left;
    public static Key Up;
    public static Key Right;
    public static Key Down;
    public static Key Select;
    public static Key Print;
    public static Key Execute;
    public static Key Snapshot;
    public static Key PrintScreen;
    public static Key Insert;
    public static Key Delete;
    public static Key Help;
    public static Key D0;
    public static Key D1;
    public static Key D2;
    public static Key D3;
    public static Key D4;
    public static Key D5;
    public static Key D6;
    public static Key D7;
    public static Key D8;
    public static Key D9;
    public static Key A;
    public static Key B;
    public static Key C;
    public static Key D;
    public static Key E;
    public static Key F;
    public static Key G;
    public static Key H;
    public static Key I;
    public static Key J;
    public static Key K;
    public static Key L;
    public static Key M;
    public static Key N;
    public static Key O;
    public static Key P;
    public static Key Q;
    public static Key R;
    public static Key S;
    public static Key T;
    public static Key U;
    public static Key V;
    public static Key W;
    public static Key X;
    public static Key Y;
    public static Key Z;
    public static Key LWin;
    public static Key RWin;
    public static Key Apps;
    public static Key Sleep;
    public static Key NumPad0;
    public static Key NumPad1;
    public static Key NumPad2;
    public static Key NumPad3;
    public static Key NumPad4;
    public static Key NumPad5;
    public static Key NumPad6;
    public static Key NumPad7;
    public static Key NumPad8;
    public static Key NumPad9;
    public static Key Multiply;
    public static Key Add;
    public static Key Separator;
    public static Key Subtract;
    public static Key Decimal;
    public static Key Divide;
    public static Key F1;
    public static Key F2;
    public static Key F3;
    public static Key F4;
    public static Key F5;
    public static Key F6;
    public static Key F7;
    public static Key F8;
    public static Key F9;
    public static Key F10;
    public static Key F11;
    public static Key F12;
    public static Key F13;
    public static Key F14;
    public static Key F15;
    public static Key F16;
    public static Key F17;
    public static Key F18;
    public static Key F19;
    public static Key F20;
    public static Key F21;
    public static Key F22;
    public static Key F23;
    public static Key F24;
    public static Key NumLock;
    public static Key Scroll;
    public static Key LeftShift;
    public static Key RightShift;
    public static Key LeftCtrl;
    public static Key RightCtrl;
    public static Key LeftAlt;
    public static Key RightAlt;
    public static Key BrowserBack;
    public static Key BrowserForward;
    public static Key BrowserRefresh;
    public static Key BrowserStop;
    public static Key BrowserSearch;
    public static Key BrowserFavorites;
    public static Key BrowserHome;
    public static Key VolumeMute;
    public static Key VolumeDown;
    public static Key VolumeUp;
    public static Key MediaNextTrack;
    public static Key MediaPreviousTrack;
    public static Key MediaStop;
    public static Key MediaPlayPause;
    public static Key LaunchMail;
    public static Key SelectMedia;
    public static Key LaunchApplication1;
    public static Key LaunchApplication2;
    public static Key Oem1;
    public static Key OemSemicolon;
    public static Key OemPlus;
    public static Key OemComma;
    public static Key OemMinus;
    public static Key OemPeriod;
    public static Key Oem2;
    public static Key OemQuestion;
    public static Key Oem3;
    public static Key OemTilde;
    public static Key AbntC1;
    public static Key AbntC2;
    public static Key Oem4;
    public static Key OemOpenBrackets;
    public static Key Oem5;
    public static Key OemPipe;
    public static Key Oem6;
    public static Key OemCloseBrackets;
    public static Key Oem7;
    public static Key OemQuotes;
    public static Key Oem8;
    public static Key Oem102;
    public static Key OemBackslash;
    public static Key ImeProcessed;
    public static Key System;
    public static Key OemAttn;
    public static Key DbeAlphanumeric;
    public static Key OemFinish;
    public static Key DbeKatakana;
    public static Key OemCopy;
    public static Key DbeHiragana;
    public static Key OemAuto;
    public static Key DbeSbcsChar;
    public static Key OemEnlw;
    public static Key DbeDbcsChar;
    public static Key OemBackTab;
    public static Key DbeRoman;
    public static Key Attn;
    public static Key DbeNoRoman;
    public static Key CrSel;
    public static Key DbeEnterWordRegisterMode;
    public static Key ExSel;
    public static Key DbeEnterImeConfigureMode;
    public static Key EraseEof;
    public static Key DbeFlushString;
    public static Key Play;
    public static Key DbeCodeInput;
    public static Key Zoom;
    public static Key DbeNoCodeInput;
    public static Key NoName;
    public static Key DbeDetermineString;
    public static Key Pa1;
    public static Key DbeEnterDialogConversionMode;
    public static Key OemClear;
    public static Key DeadCharProcessed;
}
public class System.Windows.Input.KeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.KeyInterop : object {
    public static Key KeyFromVirtualKey(int virtualKey);
    public static int VirtualKeyFromKey(Key key);
}
public class System.Windows.Input.KeyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[TypeConverterAttribute("System.Windows.Input.ModifierKeysConverter")]
[ValueSerializerAttribute("System.Windows.Input.ModifierKeysValueSerializer")]
[FlagsAttribute]
public enum System.Windows.Input.ModifierKeys : Enum {
    public int value__;
    public static ModifierKeys None;
    public static ModifierKeys Alt;
    public static ModifierKeys Control;
    public static ModifierKeys Shift;
    public static ModifierKeys Windows;
}
public class System.Windows.Input.ModifierKeysConverter : TypeConverter {
    private static ModifierKeysConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public static bool IsDefinedModifierKeys(ModifierKeys modifierKeys);
    internal static string MatchModifiers(ModifierKeys modifierKeys);
}
public class System.Windows.Input.ModifierKeysValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.TraversalRequest : object {
    public bool Wrapped { get; public set; }
    public FocusNavigationDirection FocusNavigationDirection { get; }
    public TraversalRequest(FocusNavigationDirection focusNavigationDirection);
    public bool get_Wrapped();
    public void set_Wrapped(bool value);
    public FocusNavigationDirection get_FocusNavigationDirection();
}
[TypeConverterAttribute("System.Windows.Int32RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.Int32RectValueSerializer")]
public class System.Windows.Int32Rect : ValueType {
    internal int _x;
    internal int _y;
    internal int _width;
    internal int _height;
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public static Int32Rect Empty { get; }
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public Int32Rect(int x, int y, int width, int height);
    private static Int32Rect();
    public static bool op_Equality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool op_Inequality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool Equals(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public virtual bool Equals(object o);
    public bool Equals(Int32Rect value);
    public virtual int GetHashCode();
    public static Int32Rect Parse(string source);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Int32Rect get_Empty();
    public bool get_IsEmpty();
    public bool get_HasArea();
    internal void ValidateForDirtyRect(string paramName, int width, int height);
}
public class System.Windows.Int32RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Interop.ComponentDispatcher : object {
    public static bool IsThreadModal { get; }
    public static MSG CurrentKeyboardMessage { get; }
    internal static MSG UnsecureCurrentKeyboardMessage { get; internal set; }
    private static ComponentDispatcher();
    [SecurityCriticalAttribute]
public static bool get_IsThreadModal();
    [SecurityCriticalAttribute]
public static MSG get_CurrentKeyboardMessage();
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static MSG get_UnsecureCurrentKeyboardMessage();
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static void set_UnsecureCurrentKeyboardMessage(MSG value);
    [SecurityCriticalAttribute]
public static void PushModal();
    [SecurityCriticalAttribute]
internal static void CriticalPushModal();
    [SecurityCriticalAttribute]
public static void PopModal();
    [SecurityCriticalAttribute]
internal static void CriticalPopModal();
    [SecurityCriticalAttribute]
public static void RaiseIdle();
    [SecurityCriticalAttribute]
public static bool RaiseThreadMessage(MSG& msg);
    [SecurityCriticalAttribute]
public static void add_ThreadIdle(EventHandler value);
    [SecurityCriticalAttribute]
public static void remove_ThreadIdle(EventHandler value);
    [SecurityCriticalAttribute]
public static void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public static void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public static void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public static void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
internal static void CriticalAddThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    [SecurityCriticalAttribute]
internal static void CriticalRemoveThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    [SecurityCriticalAttribute]
public static void add_EnterThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public static void remove_EnterThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public static void add_LeaveThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public static void remove_LeaveThreadModal(EventHandler value);
}
internal class System.Windows.Interop.ComponentDispatcherThread : object {
    public bool IsThreadModal { get; }
    public MSG CurrentKeyboardMessage { get; public set; }
    public bool get_IsThreadModal();
    [SecurityCriticalAttribute]
public MSG get_CurrentKeyboardMessage();
    [SecurityCriticalAttribute]
public void set_CurrentKeyboardMessage(MSG value);
    [SecurityCriticalAttribute]
public void PushModal();
    [SecurityCriticalAttribute]
public void PopModal();
    [SecurityCriticalAttribute]
public void RaiseIdle();
    [SecurityCriticalAttribute]
public bool RaiseThreadMessage(MSG& msg);
    [SecurityCriticalAttribute]
public void add_ThreadIdle(EventHandler value);
    [SecurityCriticalAttribute]
public void remove_ThreadIdle(EventHandler value);
    [SecurityCriticalAttribute]
public void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public void AddThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    [SecurityCriticalAttribute]
public void RemoveThreadPreprocessMessageHandlerFirst(ThreadMessageEventHandler handler);
    [SecurityCriticalAttribute]
public void add_EnterThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public void remove_EnterThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public void add_LeaveThreadModal(EventHandler value);
    [SecurityCriticalAttribute]
public void remove_LeaveThreadModal(EventHandler value);
}
public interface System.Windows.Interop.IKeyboardInputSink {
    public IKeyboardInputSite KeyboardInputSite { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual IKeyboardInputSite RegisterKeyboardInputSink(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
public abstract virtual bool TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool TabInto(TraversalRequest request);
    public abstract virtual IKeyboardInputSite get_KeyboardInputSite();
    [SecurityCriticalAttribute]
public abstract virtual void set_KeyboardInputSite(IKeyboardInputSite value);
    [SecurityCriticalAttribute]
public abstract virtual bool OnMnemonic(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
public abstract virtual bool TranslateChar(MSG& msg, ModifierKeys modifiers);
    public abstract virtual bool HasFocusWithin();
}
public interface System.Windows.Interop.IKeyboardInputSite {
    public IKeyboardInputSink Sink { get; }
    [SecurityCriticalAttribute]
public abstract virtual void Unregister();
    public abstract virtual IKeyboardInputSink get_Sink();
    public abstract virtual bool OnNoMoreTabStops(TraversalRequest request);
}
public class System.Windows.Interop.MSG : ValueType {
    [SecurityCriticalAttribute]
private IntPtr _hwnd;
    [SecurityCriticalAttribute]
private int _message;
    [SecurityCriticalAttribute]
private IntPtr _wParam;
    [SecurityCriticalAttribute]
private IntPtr _lParam;
    [SecurityCriticalAttribute]
private int _time;
    [SecurityCriticalAttribute]
private int _pt_x;
    [SecurityCriticalAttribute]
private int _pt_y;
    public IntPtr hwnd { get; public set; }
    public int message { get; public set; }
    public IntPtr wParam { get; public set; }
    public IntPtr lParam { get; public set; }
    public int time { get; public set; }
    public int pt_x { get; public set; }
    public int pt_y { get; public set; }
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal MSG(IntPtr hwnd, int message, IntPtr wParam, IntPtr lParam, int time, int pt_x, int pt_y);
    [SecurityCriticalAttribute]
public IntPtr get_hwnd();
    [SecurityCriticalAttribute]
public void set_hwnd(IntPtr value);
    [SecurityCriticalAttribute]
public int get_message();
    [SecurityCriticalAttribute]
public void set_message(int value);
    [SecurityCriticalAttribute]
public IntPtr get_wParam();
    [SecurityCriticalAttribute]
public void set_wParam(IntPtr value);
    [SecurityCriticalAttribute]
public IntPtr get_lParam();
    [SecurityCriticalAttribute]
public void set_lParam(IntPtr value);
    [SecurityCriticalAttribute]
public int get_time();
    [SecurityCriticalAttribute]
public void set_time(int value);
    [SecurityCriticalAttribute]
public int get_pt_x();
    [SecurityCriticalAttribute]
public void set_pt_x(int value);
    [SecurityCriticalAttribute]
public int get_pt_y();
    [SecurityCriticalAttribute]
public void set_pt_y(int value);
}
public class System.Windows.Interop.ThreadMessageEventHandler : MulticastDelegate {
    public ThreadMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(MSG& msg, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(MSG& msg, Boolean& handled, AsyncCallback callback, object object);
    public virtual void EndInvoke(MSG& msg, Boolean& handled, IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal interface System.Windows.ISealable {
    public bool CanSeal { get; }
    public bool IsSealed { get; }
    public abstract virtual bool get_CanSeal();
    public abstract virtual void Seal();
    public abstract virtual bool get_IsSealed();
}
public interface System.Windows.IWeakEventListener {
    public abstract virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.LocalValueEntry : ValueType {
    internal DependencyProperty _dp;
    internal object _value;
    public DependencyProperty Property { get; }
    public object Value { get; }
    internal LocalValueEntry(DependencyProperty dp, object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LocalValueEntry obj1, LocalValueEntry obj2);
    public static bool op_Inequality(LocalValueEntry obj1, LocalValueEntry obj2);
    public DependencyProperty get_Property();
    public object get_Value();
}
public class System.Windows.LocalValueEnumerator : ValueType {
    private int _index;
    private LocalValueEntry[] _snapshot;
    private int _count;
    public LocalValueEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public int Count { get; }
    internal LocalValueEnumerator(LocalValueEntry[] snapshot, int count);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public static bool op_Inequality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public LocalValueEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public int get_Count();
}
internal class System.Windows.Markup.DateTimeConverter2 : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.DateTimeValueSerializerContext : object {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public sealed virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
    public sealed virtual ValueSerializer GetValueSerializerFor(Type type);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual object GetService(Type serviceType);
}
[FlagsAttribute]
public enum System.Windows.Markup.DesignerSerializationOptions : Enum {
    public int value__;
    public static DesignerSerializationOptions SerializeAsAttribute;
}
[AttributeUsageAttribute("448")]
public class System.Windows.Markup.DesignerSerializationOptionsAttribute : Attribute {
    public DesignerSerializationOptions DesignerSerializationOptions { get; }
    public DesignerSerializationOptionsAttribute(DesignerSerializationOptions designerSerializationOptions);
    public DesignerSerializationOptions get_DesignerSerializationOptions();
}
internal class System.Windows.Markup.HandleAttributeCallback : MulticastDelegate {
    public HandleAttributeCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth);
    public virtual IAsyncResult BeginInvoke(int elementDepth, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Markup.HandleElementCallback : MulticastDelegate {
    public HandleElementCallback(object object, IntPtr method);
    public virtual void Invoke(int elementDepth, Boolean& more);
    public virtual IAsyncResult BeginInvoke(int elementDepth, Boolean& more, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& more, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Windows.Markup.InternalTypeHelper : object {
    protected internal abstract virtual object CreateInstance(Type type, CultureInfo culture);
    protected internal abstract virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected internal abstract virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
    protected internal abstract virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected internal abstract virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
}
[ObsoleteAttribute("IReceiveMarkupExtension has been deprecated. This interface is no longer in use.")]
public interface System.Windows.Markup.IReceiveMarkupExtension {
    public abstract virtual void ReceiveMarkupExtension(string property, MarkupExtension markupExtension, IServiceProvider serviceProvider);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Markup.IsXmlNamespaceSupportedCallback : MulticastDelegate {
    public IsXmlNamespaceSupportedCallback(object object, IntPtr method);
    public virtual bool Invoke(string xmlNamespace, String& newXmlNamespace);
    public virtual IAsyncResult BeginInvoke(string xmlNamespace, String& newXmlNamespace, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& newXmlNamespace, IAsyncResult result);
}
internal static class System.Windows.Markup.NameValidationHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool NameValidationCallback(object candidateName);
    [FriendAccessAllowedAttribute]
internal static bool IsValidIdentifierName(string name);
}
public abstract class System.Windows.Markup.Primitives.MarkupObject : object {
    public Type ObjectType { get; }
    public object Instance { get; }
    public IEnumerable`1<MarkupProperty> Properties { get; }
    public AttributeCollection Attributes { get; }
    public abstract virtual Type get_ObjectType();
    public abstract virtual object get_Instance();
    public virtual IEnumerable`1<MarkupProperty> get_Properties();
    internal abstract virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public abstract virtual void AssignRootContext(IValueSerializerContext context);
    public abstract virtual AttributeCollection get_Attributes();
}
public abstract class System.Windows.Markup.Primitives.MarkupProperty : object {
    public string Name { get; }
    public Type PropertyType { get; }
    internal bool IsCollectionProperty { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsConstructorArgument { get; }
    public bool IsValueAsString { get; }
    public bool IsContent { get; }
    public bool IsKey { get; }
    public bool IsComposite { get; }
    public object Value { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_PropertyType();
    internal bool get_IsCollectionProperty();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsValueAsString();
    public virtual bool get_IsContent();
    public virtual bool get_IsKey();
    public virtual bool get_IsComposite();
    public abstract virtual object get_Value();
    public abstract virtual string get_StringValue();
    public abstract virtual IEnumerable`1<Type> get_TypeReferences();
    public abstract virtual IEnumerable`1<MarkupObject> get_Items();
    public abstract virtual AttributeCollection get_Attributes();
    internal virtual void VerifyOnlySerializableTypes();
}
internal static class System.Windows.Markup.ReflectionHelper : object {
    private static ReflectionHelper();
    internal static Type GetQualifiedType(string typeName);
    internal static bool IsNullableType(Type type);
    internal static bool IsInternalType(Type type);
    internal static bool IsPublicType(Type type);
    internal static Type GetSystemType(Type type);
    internal static Type GetReflectionType(object item);
    internal static string GetTypeConverterAttributeData(Type type, Type& converterType);
    internal static string GetTypeConverterAttributeData(MemberInfo mi, Type& converterType);
    internal static string GetCustomAttributeData(Type t, Type attrType, bool allowTypeAlso, Boolean& attributeDataFound, Type& typeValue);
    internal static void ResetCacheForAssembly(string assemblyName);
    internal static Assembly LoadAssembly(string assemblyName, string assemblyPath);
    internal static Assembly GetAlreadyLoadedAssembly(string assemblyNameLookup);
}
[EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public class System.Windows.Markup.ServiceProviders : object {
    public sealed virtual object GetService(Type serviceType);
    public void AddService(Type serviceType, object service);
}
internal static class System.Windows.Markup.TypeConverterHelper : object {
    internal static CultureInfo InvariantEnglishUS { get; }
    private static TypeConverterHelper();
    internal static CultureInfo get_InvariantEnglishUS();
    internal static MemberInfo GetMemberInfoForPropertyConverter(object dpOrPiOrMi);
    internal static Type GetConverterType(MemberInfo memberInfo);
    internal static Type GetConverterType(Type type);
    internal static Type GetCoreConverterTypeFromCustomType(Type type);
    internal static TypeConverter GetCoreConverterFromCustomType(Type type);
    internal static TypeConverter GetTypeConverter(Type type);
}
internal class System.Windows.Markup.TypeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Markup.XmlCompatibilityReader : XmlWrappingReader {
    public string Value { get; }
    public string NamespaceURI { get; }
    public int Depth { get; }
    public bool HasAttributes { get; }
    public int AttributeCount { get; }
    unknown bool Normalization {public set; }
    internal Encoding Encoding { get; }
    public XmlCompatibilityReader(XmlReader baseReader);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported);
    public XmlCompatibilityReader(XmlReader baseReader, IsXmlNamespaceSupportedCallback isXmlNamespaceSupported, IEnumerable`1<string> supportedNamespaces);
    public XmlCompatibilityReader(XmlReader baseReader, IEnumerable`1<string> supportedNamespaces);
    private static XmlCompatibilityReader();
    public void DeclareNamespaceCompatibility(string newNamespace, string oldNamespace);
    public virtual bool Read();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string LookupNamespace(string prefix);
    public virtual string get_Value();
    public virtual string get_NamespaceURI();
    public virtual int get_Depth();
    public virtual bool get_HasAttributes();
    public virtual int get_AttributeCount();
    public void set_Normalization(bool value);
    internal Encoding get_Encoding();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.XmlWrappingReader : XmlReader {
    protected XmlReader _reader;
    protected IXmlLineInfo _readerAsIXmlLineInfo;
    protected IXmlNamespaceResolver _readerAsResolver;
    public XmlReaderSettings Settings { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Prefix { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public int Depth { get; }
    public string BaseURI { get; }
    public bool IsEmptyElement { get; }
    public bool IsDefault { get; }
    public char QuoteChar { get; }
    public XmlSpace XmlSpace { get; }
    public string XmlLang { get; }
    public IXmlSchemaInfo SchemaInfo { get; }
    public Type ValueType { get; }
    public int AttributeCount { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public bool CanResolveEntity { get; }
    public bool EOF { get; }
    public ReadState ReadState { get; }
    public bool HasAttributes { get; }
    public XmlNameTable NameTable { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    protected XmlReader Reader { get; protected set; }
    internal XmlWrappingReader(XmlReader baseReader);
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_CanResolveEntity();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_HasAttributes();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual bool Read();
    public virtual void Close();
    public virtual void Skip();
    public virtual string LookupNamespace(string prefix);
    private sealed virtual override string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName);
    private sealed virtual override IDictionary`2<string, string> System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    protected virtual void Dispose(bool disposing);
    public virtual bool HasLineInfo();
    public virtual int get_LineNumber();
    public virtual int get_LinePosition();
    protected XmlReader get_Reader();
    protected void set_Reader(XmlReader value);
}
public class System.Windows.Media.Converters.MatrixValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[AttributeUsageAttribute("1")]
public class System.Windows.Media.DisableDpiAwarenessAttribute : Attribute {
}
[TypeConverterAttribute("System.Windows.Media.MatrixConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.MatrixValueSerializer")]
public class System.Windows.Media.Matrix : ValueType {
    private static int c_identityHashCode;
    internal double _m11;
    internal double _m12;
    internal double _m21;
    internal double _m22;
    internal double _offsetX;
    internal double _offsetY;
    internal MatrixTypes _type;
    internal int _padding;
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    private static Matrix();
    public static Matrix get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public static Matrix op_Multiply(Matrix trans1, Matrix trans2);
    public static Matrix Multiply(Matrix trans1, Matrix trans2);
    public void Append(Matrix matrix);
    public void Prepend(Matrix matrix);
    public void Rotate(double angle);
    public void RotatePrepend(double angle);
    public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    public void Scale(double scaleX, double scaleY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    public void Skew(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    public void Translate(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
    public Point Transform(Point point);
    public void Transform(Point[] points);
    public Vector Transform(Vector vector);
    public void Transform(Vector[] vectors);
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    internal void MultiplyVector(Double& x, Double& y);
    internal void MultiplyPoint(Double& x, Double& y);
    internal static Matrix CreateRotationRadians(double angle);
    internal static Matrix CreateRotationRadians(double angle, double centerX, double centerY);
    internal static Matrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY);
    internal static Matrix CreateScaling(double scaleX, double scaleY);
    internal static Matrix CreateSkewRadians(double skewX, double skewY);
    internal static Matrix CreateTranslation(double offsetX, double offsetY);
    public static bool op_Equality(Matrix matrix1, Matrix matrix2);
    public static bool op_Inequality(Matrix matrix1, Matrix matrix2);
    public static bool Equals(Matrix matrix1, Matrix matrix2);
    public virtual bool Equals(object o);
    public bool Equals(Matrix value);
    public virtual int GetHashCode();
    public static Matrix Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.MatrixConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.ModifiedValue : object {
    internal object BaseValue { get; internal set; }
    internal object ExpressionValue { get; internal set; }
    internal object AnimatedValue { get; internal set; }
    internal object CoercedValue { get; internal set; }
    internal object get_BaseValue();
    internal void set_BaseValue(object value);
    internal object get_ExpressionValue();
    internal void set_ExpressionValue(object value);
    internal object get_AnimatedValue();
    internal void set_AnimatedValue(object value);
    internal object get_CoercedValue();
    internal void set_CoercedValue(object value);
    internal void SetBaseValue(object value, bool useWeakReference);
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.NameScope : object {
    public static DependencyProperty NameScopeProperty;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    private static NameScope();
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    internal static INameScope NameScopeFromObject(object obj);
    public static void SetNameScope(DependencyObject dependencyObject, INameScope value);
    [DesignerSerializationVisibilityAttribute("0")]
public static INameScope GetNameScope(DependencyObject dependencyObject);
    private IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.OperationType : Enum {
    public byte value__;
    public static OperationType Unknown;
    public static OperationType AddChild;
    public static OperationType RemoveChild;
    public static OperationType Inherit;
    public static OperationType ChangeMutableDefaultValue;
}
[TypeConverterAttribute("System.Windows.PointConverter")]
[ValueSerializerAttribute("System.Windows.Converters.PointValueSerializer")]
public class System.Windows.Point : ValueType {
    internal double _x;
    internal double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public static bool Equals(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
    public static Point Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public void Offset(double offsetX, double offsetY);
    public static Point op_Addition(Point point, Vector vector);
    public static Point Add(Point point, Vector vector);
    public static Point op_Subtraction(Point point, Vector vector);
    public static Point Subtract(Point point, Vector vector);
    public static Vector op_Subtraction(Point point1, Point point2);
    public static Vector Subtract(Point point1, Point point2);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static Point Multiply(Point point, Matrix matrix);
    public static Size op_Explicit(Point point);
    public static Vector op_Explicit(Point point);
}
public class System.Windows.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.PropertyChangedCallback : MulticastDelegate {
    public PropertyChangedCallback(object object, IntPtr method);
    public virtual void Invoke(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.PropertyMetadata : object {
    [FriendAccessAllowedAttribute]
internal MetadataFlags _flags;
    public object DefaultValue { get; public set; }
    internal bool UsingDefaultValueFactory { get; }
    public PropertyChangedCallback PropertyChangedCallback { get; public set; }
    public CoerceValueCallback CoerceValueCallback { get; public set; }
    [FriendAccessAllowedAttribute]
internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    [FriendAccessAllowedAttribute]
internal FreezeValueCallback FreezeValueCallback { get; internal set; }
    protected bool IsSealed { get; }
    internal bool IsDefaultValueModified { get; }
    internal bool IsInherited { get; internal set; }
    internal bool Sealed { get; internal set; }
    public PropertyMetadata(object defaultValue);
    public PropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    private static PropertyMetadata();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal bool get_UsingDefaultValueFactory();
    [FriendAccessAllowedAttribute]
internal object GetDefaultValue(DependencyObject owner, DependencyProperty property);
    internal void ClearCachedDefaultValue(DependencyObject owner, DependencyProperty property);
    internal static void PromoteAllCachedDefaultValues(DependencyObject owner);
    internal static void RemoveAllCachedDefaultValues(Freezable owner);
    internal bool DefaultValueWasSet();
    public PropertyChangedCallback get_PropertyChangedCallback();
    public void set_PropertyChangedCallback(PropertyChangedCallback value);
    public CoerceValueCallback get_CoerceValueCallback();
    public void set_CoerceValueCallback(CoerceValueCallback value);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
    internal FreezeValueCallback get_FreezeValueCallback();
    internal void set_FreezeValueCallback(FreezeValueCallback value);
    internal virtual PropertyMetadata CreateInstance();
    internal PropertyMetadata Copy(DependencyProperty dp);
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    internal void InvokeMerge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
    protected bool get_IsSealed();
    internal void Seal(DependencyProperty dp, Type targetType);
    internal bool get_IsDefaultValueModified();
    internal bool get_IsInherited();
    internal void set_IsInherited(bool value);
    [FriendAccessAllowedAttribute]
internal void WriteFlag(MetadataFlags id, bool value);
    [FriendAccessAllowedAttribute]
internal bool ReadFlag(MetadataFlags id);
    [FriendAccessAllowedAttribute]
internal bool get_Sealed();
    internal void set_Sealed(bool value);
}
[TypeConverterAttribute("System.Windows.RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.RectValueSerializer")]
public class System.Windows.Rect : ValueType {
    internal double _x;
    internal double _y;
    internal double _width;
    internal double _height;
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Point Location { get; public set; }
    public Size Size { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public Rect(Point location, Size size);
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point point, Vector vector);
    public Rect(Size size);
    private static Rect();
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public static bool Equals(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public bool Equals(Rect value);
    public virtual int GetHashCode();
    public static Rect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public Point get_Location();
    public void set_Location(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public Point get_TopLeft();
    public Point get_TopRight();
    public Point get_BottomLeft();
    public Point get_BottomRight();
    public bool Contains(Point point);
    public bool Contains(double x, double y);
    public bool Contains(Rect rect);
    public bool IntersectsWith(Rect rect);
    public void Intersect(Rect rect);
    public static Rect Intersect(Rect rect1, Rect rect2);
    public void Union(Rect rect);
    public static Rect Union(Rect rect1, Rect rect2);
    public void Union(Point point);
    public static Rect Union(Rect rect, Point point);
    public void Offset(Vector offsetVector);
    public void Offset(double offsetX, double offsetY);
    public static Rect Offset(Rect rect, Vector offsetVector);
    public static Rect Offset(Rect rect, double offsetX, double offsetY);
    public void Inflate(Size size);
    public void Inflate(double width, double height);
    public static Rect Inflate(Rect rect, Size size);
    public static Rect Inflate(Rect rect, double width, double height);
    public static Rect Transform(Rect rect, Matrix matrix);
    public void Transform(Matrix matrix);
    public void Scale(double scaleX, double scaleY);
}
public class System.Windows.RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.RequestFlags : Enum {
    public int value__;
    public static RequestFlags FullyResolved;
    public static RequestFlags AnimationBaseValue;
    public static RequestFlags CoercionBaseValue;
    public static RequestFlags DeferredReferences;
    public static RequestFlags SkipDefault;
    public static RequestFlags RawEntry;
}
[TypeConverterAttribute("System.Windows.SizeConverter")]
[ValueSerializerAttribute("System.Windows.Converters.SizeValueSerializer")]
public class System.Windows.Size : ValueType {
    internal double _width;
    internal double _height;
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public Size(double width, double height);
    private static Size();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public static bool Equals(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    public static Size Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Size get_Empty();
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Vector op_Explicit(Size size);
    public static Point op_Explicit(Size size);
}
public class System.Windows.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[SecurityCriticalAttribute("1")]
public class System.Windows.SplashScreen : object {
    [SecurityCriticalAttribute]
public SplashScreen(string resourceName);
    [SecurityCriticalAttribute]
public SplashScreen(Assembly resourceAssembly, string resourceName);
    [SecurityCriticalAttribute]
public void Show(bool autoClose);
    [SecurityCriticalAttribute]
public void Show(bool autoClose, bool topMost);
    [SecurityCriticalAttribute]
public void Close(TimeSpan fadeoutDuration);
}
public class System.Windows.Threading.Dispatcher : object {
    internal bool _exitAllFrames;
    internal bool _hasShutdownStarted;
    internal int _disableProcessingCount;
    internal DispatcherSynchronizationContext _defaultDispatcherSynchronizationContext;
    internal object _instanceLock;
    public static Dispatcher CurrentDispatcher { get; }
    public Thread Thread { get; }
    public bool HasShutdownStarted { get; }
    public bool HasShutdownFinished { get; }
    [EditorBrowsableAttribute("2")]
public DispatcherHooks Hooks { get; }
    internal object Reserved0 { get; internal set; }
    internal object Reserved1 { get; internal set; }
    internal object Reserved2 { get; internal set; }
    internal object Reserved3 { get; internal set; }
    internal object Reserved4 { get; internal set; }
    internal object PtsCache { get; internal set; }
    internal object InputMethod { get; internal set; }
    internal object InputManager { get; internal set; }
    [FriendAccessAllowedAttribute]
unknown bool IsTSFMessagePumpEnabled {internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Dispatcher();
    public static Dispatcher get_CurrentDispatcher();
    public static Dispatcher FromThread(Thread thread);
    public Thread get_Thread();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
    [SecurityCriticalAttribute]
public void BeginInvokeShutdown(DispatcherPriority priority);
    [SecurityCriticalAttribute]
public void InvokeShutdown();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal void CriticalInvokeShutdown();
    public bool get_HasShutdownStarted();
    public bool get_HasShutdownFinished();
    [CompilerGeneratedAttribute]
public void add_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ShutdownFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownFinished(EventHandler value);
    [SecurityCriticalAttribute]
public static void Run();
    [SecurityCriticalAttribute]
public static void PushFrame(DispatcherFrame frame);
    [SecurityCriticalAttribute]
public static void ExitAllFrames();
    public static DispatcherPriorityAwaitable Yield();
    public static DispatcherPriorityAwaitable Yield(DispatcherPriority priority);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, DispatcherPriority priority, Object[] args);
    public void Invoke(Action callback);
    public void Invoke(Action callback, DispatcherPriority priority);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public TResult Invoke(Func`1<TResult> callback);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public DispatcherOperation InvokeAsync(Action callback);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);
    [SecuritySafeCriticalAttribute]
public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority);
    [SecuritySafeCriticalAttribute]
public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, Object[] args);
    public object Invoke(Delegate method, Object[] args);
    public object Invoke(Delegate method, DispatcherPriority priority, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, DispatcherPriority priority, Object[] args);
    [SecuritySafeCriticalAttribute]
internal object LegacyInvokeImpl(DispatcherPriority priority, TimeSpan timeout, Delegate method, object args, int numArgs);
    public DispatcherProcessingDisabled DisableProcessing();
    public static void ValidatePriority(DispatcherPriority priority, string parameterName);
    [SecurityCriticalAttribute]
public DispatcherHooks get_Hooks();
    [SecurityCriticalAttribute]
public void add_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    [SecurityCriticalAttribute]
public void remove_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved0();
    [FriendAccessAllowedAttribute]
internal void set_Reserved0(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved1();
    [FriendAccessAllowedAttribute]
internal void set_Reserved1(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved2();
    [FriendAccessAllowedAttribute]
internal void set_Reserved2(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved3();
    [FriendAccessAllowedAttribute]
internal void set_Reserved3(object value);
    [FriendAccessAllowedAttribute]
internal object get_Reserved4();
    [FriendAccessAllowedAttribute]
internal void set_Reserved4(object value);
    [FriendAccessAllowedAttribute]
internal object get_PtsCache();
    [FriendAccessAllowedAttribute]
internal void set_PtsCache(object value);
    [FriendAccessAllowedAttribute]
internal object get_InputMethod();
    [FriendAccessAllowedAttribute]
internal void set_InputMethod(object value);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal object get_InputManager();
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal void set_InputManager(object value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool SetPriority(DispatcherOperation operation, DispatcherPriority priority);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool Abort(DispatcherOperation operation);
    internal void set_IsTSFMessagePumpEnabled(bool value);
    [SecurityCriticalAttribute]
internal bool CriticalRequestProcessing(bool force);
    internal void PromoteTimers(int currentTimeInTicks);
    internal void AddTimer(DispatcherTimer timer);
    internal void RemoveTimer(DispatcherTimer timer);
    internal void UpdateWin32Timer();
    [FriendAccessAllowedAttribute]
internal object WrappedInvoke(Delegate callback, object args, int numArgs, Delegate catchHandler);
}
public class System.Windows.Threading.DispatcherEventArgs : EventArgs {
    public Dispatcher Dispatcher { get; }
    internal DispatcherEventArgs(Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
}
public class System.Windows.Threading.DispatcherFrame : DispatcherObject {
    public bool Continue { get; public set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static DispatcherFrame();
    public DispatcherFrame(bool exitWhenRequested);
    public bool get_Continue();
    [SecurityCriticalAttribute]
public void set_Continue(bool value);
}
public class System.Windows.Threading.DispatcherHookEventArgs : EventArgs {
    public Dispatcher Dispatcher { get; }
    public DispatcherOperation Operation { get; }
    public DispatcherHookEventArgs(DispatcherOperation operation);
    public Dispatcher get_Dispatcher();
    public DispatcherOperation get_Operation();
}
public class System.Windows.Threading.DispatcherHookEventHandler : MulticastDelegate {
    public DispatcherHookEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherHookEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherHookEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherHooks : object {
    [SecurityCriticalAttribute]
public void add_DispatcherInactive(EventHandler value);
    [SecurityCriticalAttribute]
public void remove_DispatcherInactive(EventHandler value);
    [SecurityCriticalAttribute]
public void add_OperationPosted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void remove_OperationPosted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void add_OperationStarted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void remove_OperationStarted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void add_OperationCompleted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void remove_OperationCompleted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void add_OperationPriorityChanged(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void remove_OperationPriorityChanged(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void add_OperationAborted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
public void remove_OperationAborted(DispatcherHookEventHandler value);
    [SecurityCriticalAttribute]
internal void RaiseDispatcherInactive(Dispatcher dispatcher);
    [SecurityCriticalAttribute]
internal void RaiseOperationPosted(Dispatcher dispatcher, DispatcherOperation operation);
    [SecurityCriticalAttribute]
internal void RaiseOperationStarted(Dispatcher dispatcher, DispatcherOperation operation);
    [SecurityCriticalAttribute]
internal void RaiseOperationCompleted(Dispatcher dispatcher, DispatcherOperation operation);
    [SecurityCriticalAttribute]
internal void RaiseOperationPriorityChanged(Dispatcher dispatcher, DispatcherOperation operation);
    [SecurityCriticalAttribute]
internal void RaiseOperationAborted(Dispatcher dispatcher, DispatcherOperation operation);
}
public abstract class System.Windows.Threading.DispatcherObject : object {
    [EditorBrowsableAttribute("2")]
public Dispatcher Dispatcher { get; }
    public Dispatcher get_Dispatcher();
    [FriendAccessAllowedAttribute]
internal void DetachFromDispatcher();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
}
public class System.Windows.Threading.DispatcherOperation : object {
    internal Delegate _method;
    internal DispatcherOperationStatus _status;
    internal PriorityItem`1<DispatcherOperation> _item;
    internal DispatcherOperationTaskSource _taskSource;
    public Dispatcher Dispatcher { get; }
    public DispatcherPriority Priority { get; public set; }
    public DispatcherOperationStatus Status { get; }
    public Task Task { get; }
    internal string Name { get; }
    internal long Id { get; }
    public object Result { get; }
    [SecuritySafeCriticalAttribute]
private static DispatcherOperation();
    [SecurityCriticalAttribute]
internal DispatcherOperation(Dispatcher dispatcher, Delegate method, DispatcherPriority priority, object args, int numArgs, DispatcherOperationTaskSource taskSource, bool useAsyncSemantics);
    [SecurityCriticalAttribute]
internal DispatcherOperation(Dispatcher dispatcher, Delegate method, DispatcherPriority priority, object args, int numArgs);
    [SecurityCriticalAttribute]
internal DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, Action action);
    [SecurityCriticalAttribute]
internal DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, Delegate method, Object[] args);
    public Dispatcher get_Dispatcher();
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public DispatcherOperationStatus get_Status();
    public Task get_Task();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter GetAwaiter();
    public DispatcherOperationStatus Wait();
    [SecurityCriticalAttribute]
public DispatcherOperationStatus Wait(TimeSpan timeout);
    public bool Abort();
    internal string get_Name();
    [SecurityCriticalAttribute]
internal long get_Id();
    public object get_Result();
    public void add_Aborted(EventHandler value);
    public void remove_Aborted(EventHandler value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    [SecurityCriticalAttribute]
internal void Invoke();
    [SecurityCriticalAttribute]
internal void InvokeCompletions();
    protected virtual object InvokeDelegateCore();
}
public class System.Windows.Threading.DispatcherOperation`1 : DispatcherOperation {
    public Task`1<TResult> Task { get; }
    public TResult Result { get; }
    [SecurityCriticalAttribute]
internal DispatcherOperation`1(Dispatcher dispatcher, DispatcherPriority priority, Func`1<TResult> func);
    public Task`1<TResult> get_Task();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter`1<TResult> GetAwaiter();
    public TResult get_Result();
    protected virtual object InvokeDelegateCore();
}
public class System.Windows.Threading.DispatcherOperationCallback : MulticastDelegate {
    public DispatcherOperationCallback(object object, IntPtr method);
    public virtual object Invoke(object arg);
    public virtual IAsyncResult BeginInvoke(object arg, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
internal class System.Windows.Threading.DispatcherOperationTaskMapping : object {
    public DispatcherOperation Operation { get; private set; }
    public DispatcherOperationTaskMapping(DispatcherOperation operation);
    [CompilerGeneratedAttribute]
public DispatcherOperation get_Operation();
    [CompilerGeneratedAttribute]
private void set_Operation(DispatcherOperation value);
}
internal abstract class System.Windows.Threading.DispatcherOperationTaskSource : object {
    public abstract virtual void Initialize(DispatcherOperation operation);
    public abstract virtual Task GetTask();
    public abstract virtual void SetCanceled();
    public abstract virtual void SetResult(object result);
    public abstract virtual void SetException(Exception exception);
}
internal class System.Windows.Threading.DispatcherOperationTaskSource`1 : DispatcherOperationTaskSource {
    public virtual void Initialize(DispatcherOperation operation);
    public virtual Task GetTask();
    public virtual void SetCanceled();
    public virtual void SetResult(object result);
    public virtual void SetException(Exception exception);
}
public enum System.Windows.Threading.DispatcherPriority : Enum {
    public int value__;
    public static DispatcherPriority Invalid;
    public static DispatcherPriority Inactive;
    public static DispatcherPriority SystemIdle;
    public static DispatcherPriority ApplicationIdle;
    public static DispatcherPriority ContextIdle;
    public static DispatcherPriority Background;
    public static DispatcherPriority Input;
    public static DispatcherPriority Loaded;
    public static DispatcherPriority Render;
    public static DispatcherPriority DataBind;
    public static DispatcherPriority Normal;
    public static DispatcherPriority Send;
}
public class System.Windows.Threading.DispatcherPriorityAwaitable : ValueType {
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    internal DispatcherPriorityAwaitable(Dispatcher dispatcher, DispatcherPriority priority);
    public DispatcherPriorityAwaiter GetAwaiter();
}
public class System.Windows.Threading.DispatcherPriorityAwaiter : ValueType {
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    public bool IsCompleted { get; }
    internal DispatcherPriorityAwaiter(Dispatcher dispatcher, DispatcherPriority priority);
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
}
public class System.Windows.Threading.DispatcherProcessingDisabled : ValueType {
    internal Dispatcher _dispatcher;
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
    public static bool op_Inequality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
}
public class System.Windows.Threading.DispatcherSynchronizationContext : SynchronizationContext {
    internal Dispatcher _dispatcher;
    public DispatcherSynchronizationContext(Dispatcher dispatcher);
    public DispatcherSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    [SecurityCriticalAttribute]
[PrePrepareMethodAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public virtual SynchronizationContext CreateCopy();
}
public class System.Windows.Threading.DispatcherTimer : object {
    internal int _dueTimeInTicks;
    public Dispatcher Dispatcher { get; }
    public bool IsEnabled { get; public set; }
    public TimeSpan Interval { get; public set; }
    public object Tag { get; public set; }
    public DispatcherTimer(DispatcherPriority priority);
    public DispatcherTimer(DispatcherPriority priority, Dispatcher dispatcher);
    public DispatcherTimer(TimeSpan interval, DispatcherPriority priority, EventHandler callback, Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public void Start();
    public void Stop();
    [CompilerGeneratedAttribute]
public void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Tick(EventHandler value);
    public object get_Tag();
    public void set_Tag(object value);
    internal void Promote();
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventArgs : DispatcherEventArgs {
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal DispatcherUnhandledExceptionEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
    internal void Initialize(Exception exception, bool handled);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs : DispatcherEventArgs {
    public Exception Exception { get; }
    public bool RequestCatch { get; public set; }
    internal DispatcherUnhandledExceptionFilterEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_RequestCatch();
    public void set_RequestCatch(bool value);
    internal void Initialize(Exception exception, bool requestCatch);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionFilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Threading.ExceptionWrapper : object {
    public object TryCatchWhen(object source, Delegate callback, object args, int numArgs, Delegate catchHandler);
    [CompilerGeneratedAttribute]
public void add_Catch(CatchHandler value);
    [CompilerGeneratedAttribute]
public void remove_Catch(CatchHandler value);
    [CompilerGeneratedAttribute]
public void add_Filter(FilterHandler value);
    [CompilerGeneratedAttribute]
public void remove_Filter(FilterHandler value);
}
internal class System.Windows.Threading.PriorityChain`1 : object {
    public DispatcherPriority Priority { get; public set; }
    public int Count { get; public set; }
    public PriorityItem`1<T> Head { get; public set; }
    public PriorityItem`1<T> Tail { get; public set; }
    public PriorityChain`1(DispatcherPriority priority);
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public int get_Count();
    public void set_Count(int value);
    public PriorityItem`1<T> get_Head();
    public void set_Head(PriorityItem`1<T> value);
    public PriorityItem`1<T> get_Tail();
    public void set_Tail(PriorityItem`1<T> value);
}
internal class System.Windows.Threading.PriorityItem`1 : object {
    public T Data { get; }
    public bool IsQueued { get; }
    internal PriorityItem`1<T> SequentialPrev { get; internal set; }
    internal PriorityItem`1<T> SequentialNext { get; internal set; }
    internal PriorityChain`1<T> Chain { get; internal set; }
    internal PriorityItem`1<T> PriorityPrev { get; internal set; }
    internal PriorityItem`1<T> PriorityNext { get; internal set; }
    public PriorityItem`1(T data);
    public T get_Data();
    public bool get_IsQueued();
    internal PriorityItem`1<T> get_SequentialPrev();
    internal void set_SequentialPrev(PriorityItem`1<T> value);
    internal PriorityItem`1<T> get_SequentialNext();
    internal void set_SequentialNext(PriorityItem`1<T> value);
    internal PriorityChain`1<T> get_Chain();
    internal void set_Chain(PriorityChain`1<T> value);
    internal PriorityItem`1<T> get_PriorityPrev();
    internal void set_PriorityPrev(PriorityItem`1<T> value);
    internal PriorityItem`1<T> get_PriorityNext();
    internal void set_PriorityNext(PriorityItem`1<T> value);
}
internal class System.Windows.Threading.PriorityQueue`1 : object {
    public DispatcherPriority MaxPriority { get; }
    public DispatcherPriority get_MaxPriority();
    public PriorityItem`1<T> Enqueue(DispatcherPriority priority, T data);
    public T Dequeue();
    public T Peek();
    public void RemoveItem(PriorityItem`1<T> item);
    public void ChangeItemPriority(PriorityItem`1<T> item, DispatcherPriority priority);
    internal void InsertItemInPriorityChain(PriorityItem`1<T> item, PriorityChain`1<T> chain, PriorityItem`1<T> after);
    internal void InsertItemInSequentialChain(PriorityItem`1<T> item, PriorityItem`1<T> after);
}
internal class System.Windows.Threading.PriorityRange : ValueType {
    public static PriorityRange All;
    public static PriorityRange None;
    private DispatcherPriority _min;
    private bool _isMinInclusive;
    private DispatcherPriority _max;
    private bool _isMaxInclusive;
    public DispatcherPriority Min { get; }
    public DispatcherPriority Max { get; }
    public bool IsMinInclusive { get; }
    public bool IsMaxInclusive { get; }
    public bool IsValid { get; }
    public PriorityRange(DispatcherPriority min, DispatcherPriority max);
    public PriorityRange(DispatcherPriority min, bool isMinInclusive, DispatcherPriority max, bool isMaxInclusive);
    private static PriorityRange();
    public DispatcherPriority get_Min();
    public DispatcherPriority get_Max();
    public bool get_IsMinInclusive();
    public bool get_IsMaxInclusive();
    public bool get_IsValid();
    public bool Contains(DispatcherPriority priority);
    public bool Contains(PriorityRange priorityRange);
    public virtual bool Equals(object o);
    public bool Equals(PriorityRange priorityRange);
    public static bool op_Equality(PriorityRange priorityRange1, PriorityRange priorityRange2);
    public static bool op_Inequality(PriorityRange priorityRange1, PriorityRange priorityRange2);
    public virtual int GetHashCode();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.UncommonField`1 : object {
    internal int GlobalIndex { get; }
    public UncommonField`1(T defaultValue);
    public void SetValue(DependencyObject instance, T value);
    public T GetValue(DependencyObject instance);
    public void ClearValue(DependencyObject instance);
    internal int get_GlobalIndex();
}
[FriendAccessAllowedAttribute]
internal enum System.Windows.UpdateResult : Enum {
    public int value__;
    public static UpdateResult ValueChanged;
    public static UpdateResult NotificationSent;
    public static UpdateResult InheritedValueOverridden;
}
public class System.Windows.ValidateValueCallback : MulticastDelegate {
    public ValidateValueCallback(object object, IntPtr method);
    public virtual bool Invoke(object value);
    public virtual IAsyncResult BeginInvoke(object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.VectorConverter")]
[ValueSerializerAttribute("System.Windows.Converters.VectorValueSerializer")]
public class System.Windows.Vector : ValueType {
    internal double _x;
    internal double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Length { get; }
    public double LengthSquared { get; }
    public Vector(double x, double y);
    public static bool op_Equality(Vector vector1, Vector vector2);
    public static bool op_Inequality(Vector vector1, Vector vector2);
    public static bool Equals(Vector vector1, Vector vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector value);
    public virtual int GetHashCode();
    public static Vector Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double CrossProduct(Vector vector1, Vector vector2);
    public static double AngleBetween(Vector vector1, Vector vector2);
    public static Vector op_UnaryNegation(Vector vector);
    public void Negate();
    public static Vector op_Addition(Vector vector1, Vector vector2);
    public static Vector Add(Vector vector1, Vector vector2);
    public static Vector op_Subtraction(Vector vector1, Vector vector2);
    public static Vector Subtract(Vector vector1, Vector vector2);
    public static Point op_Addition(Vector vector, Point point);
    public static Point Add(Vector vector, Point point);
    public static Vector op_Multiply(Vector vector, double scalar);
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector op_Multiply(double scalar, Vector vector);
    public static Vector Multiply(double scalar, Vector vector);
    public static Vector op_Division(Vector vector, double scalar);
    public static Vector Divide(Vector vector, double scalar);
    public static Vector op_Multiply(Vector vector, Matrix matrix);
    public static Vector Multiply(Vector vector, Matrix matrix);
    public static double op_Multiply(Vector vector1, Vector vector2);
    public static double Multiply(Vector vector1, Vector vector2);
    public static double Determinant(Vector vector1, Vector vector2);
    public static Size op_Explicit(Vector vector);
    public static Point op_Explicit(Vector vector);
}
public class System.Windows.VectorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Windows.WeakEventManager : DispatcherObject {
    protected IDisposable ReadLock { get; }
    protected IDisposable WriteLock { get; }
    protected object Item { get; protected set; }
    internal static MethodInfo DeliverEventMethodInfo { get; }
    private static WeakEventManager();
    protected IDisposable get_ReadLock();
    protected IDisposable get_WriteLock();
    protected object get_Item(object source);
    protected void set_Item(object source, object value);
    internal static MethodInfo get_DeliverEventMethodInfo();
    protected virtual ListenerList NewListenerList();
    protected abstract virtual void StartListening(object source);
    protected abstract virtual void StopListening(object source);
    protected static WeakEventManager GetCurrentManager(Type managerType);
    protected static void SetCurrentManager(Type managerType, WeakEventManager manager);
    internal static WeakEventManager GetCurrentManager(Type eventSourceType, string eventName);
    internal static void SetCurrentManager(Type eventSourceType, string eventName, WeakEventManager manager);
    protected void Remove(object source);
    protected void ProtectedAddListener(object source, IWeakEventListener listener);
    protected void ProtectedRemoveListener(object source, IWeakEventListener listener);
    protected void ProtectedAddHandler(object source, Delegate handler);
    protected void ProtectedRemoveHandler(object source, Delegate handler);
    protected void DeliverEvent(object sender, EventArgs args);
    protected void DeliverEventToList(object sender, EventArgs args, ListenerList list);
    protected void ScheduleCleanup();
    protected virtual bool Purge(object source, object data, bool purgeAll);
    internal bool PurgeInternal(object source, object data, bool purgeAll);
    [FriendAccessAllowedAttribute]
internal static bool Cleanup();
    [FriendAccessAllowedAttribute]
internal static void SetCleanupEnabled(bool value);
}
public class System.Windows.WeakEventManager`2 : WeakEventManager {
    public static void AddHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    public static void RemoveHandler(TEventSource source, string eventName, EventHandler`1<TEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
