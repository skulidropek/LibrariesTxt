internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string EcmaPublicKeyFull;
    internal static string SilverlightPublicKey;
    internal static string SilverlightPublicKeyToken;
    internal static string SilverlightPublicKeyFull;
    internal static string SilverlightPlatformPublicKey;
    internal static string SilverlightPlatformPublicKeyToken;
    internal static string SilverlightPlatformPublicKeyFull;
    internal static string PlatformPublicKey;
    internal static string PlatformPublicKeyToken;
    internal static string PlatformPublicKeyFull;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string SystemDataOracleClient;
    internal static string System;
    internal static string SystemCore;
    internal static string SystemNumerics;
    internal static string SystemRuntimeRemoting;
    internal static string SystemThreadingTasksDataflow;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string MicrosoftPublicKeyToken;
    internal static string MicrosoftPublicKeyFull;
    internal static string SharedLibPublicKey;
    internal static string SharedLibPublicKeyToken;
    internal static string SharedLibPublicKeyFull;
    internal static string SystemComponentModelDataAnnotations;
    internal static string SystemConfiguration;
    internal static string SystemConfigurationInstall;
    internal static string SystemDeployment;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemNetHttp;
    internal static string SystemNetHttpWebRequest;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemRuntimeWindowsRuntime;
    internal static string SystemRuntimeWindowsRuntimeUIXaml;
    internal static string SystemSecurity;
    internal static string SystemServiceModelWeb;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebAbstractions;
    internal static string SystemWebDynamicData;
    internal static string SystemWebDynamicDataDesign;
    internal static string SystemWebEntityDesign;
    internal static string SystemWebExtensions;
    internal static string SystemWebExtensionsDesign;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebRouting;
    internal static string SystemWebServices;
    internal static string WindowsBase;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVisualStudioWindowsForms;
    internal static string VJSharpCodeProvider;
    internal static string ASPBrowserCapsPublicKey;
    internal static string ASPBrowserCapsFactory;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftVisualStudioWeb;
    internal static string MicrosoftWebDesign;
    internal static string MicrosoftVSDesignerMobile;
    internal static string MicrosoftJScript;
}
internal static class FXAssembly : object {
    internal static string Version;
}
public class System.Net.Http.ByteArrayContent : HttpContent {
    public ByteArrayContent(Byte[] content);
    public ByteArrayContent(Byte[] content, int offset, int count);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
}
public enum System.Net.Http.ClientCertificateOption : Enum {
    public int value__;
    public static ClientCertificateOption Manual;
    public static ClientCertificateOption Automatic;
}
public abstract class System.Net.Http.DelegatingHandler : HttpMessageHandler {
    public HttpMessageHandler InnerHandler { get; public set; }
    protected DelegatingHandler(HttpMessageHandler innerHandler);
    public HttpMessageHandler get_InnerHandler();
    public void set_InnerHandler(HttpMessageHandler value);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Net.Http.DelegatingStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class System.Net.Http.FormUrlEncodedContent : ByteArrayContent {
    public FormUrlEncodedContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
}
public class System.Net.Http.Headers.AuthenticationHeaderValue : object {
    public string Scheme { get; }
    public string Parameter { get; }
    public AuthenticationHeaderValue(string scheme);
    public AuthenticationHeaderValue(string scheme, string parameter);
    public string get_Scheme();
    public string get_Parameter();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static AuthenticationHeaderValue Parse(string input);
    public static bool TryParse(string input, AuthenticationHeaderValue& parsedValue);
    internal static int GetAuthenticationLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal abstract class System.Net.Http.Headers.BaseHeaderParser : HttpHeaderParser {
    protected BaseHeaderParser(bool supportsMultipleValues);
    protected abstract virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    public sealed virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
internal class System.Net.Http.Headers.ByteArrayHeaderParser : HttpHeaderParser {
    internal static ByteArrayHeaderParser Parser;
    private static ByteArrayHeaderParser();
    public virtual string ToString(object value);
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
internal class System.Net.Http.Headers.CacheControlHeaderParser : BaseHeaderParser {
    internal static CacheControlHeaderParser Parser;
    private static CacheControlHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
public class System.Net.Http.Headers.CacheControlHeaderValue : object {
    public bool NoCache { get; public set; }
    public ICollection`1<string> NoCacheHeaders { get; }
    public bool NoStore { get; public set; }
    public Nullable`1<TimeSpan> MaxAge { get; public set; }
    public Nullable`1<TimeSpan> SharedMaxAge { get; public set; }
    public bool MaxStale { get; public set; }
    public Nullable`1<TimeSpan> MaxStaleLimit { get; public set; }
    public Nullable`1<TimeSpan> MinFresh { get; public set; }
    public bool NoTransform { get; public set; }
    public bool OnlyIfCached { get; public set; }
    public bool Public { get; public set; }
    public bool Private { get; public set; }
    public ICollection`1<string> PrivateHeaders { get; }
    public bool MustRevalidate { get; public set; }
    public bool ProxyRevalidate { get; public set; }
    public ICollection`1<NameValueHeaderValue> Extensions { get; }
    private static CacheControlHeaderValue();
    public bool get_NoCache();
    public void set_NoCache(bool value);
    public ICollection`1<string> get_NoCacheHeaders();
    public bool get_NoStore();
    public void set_NoStore(bool value);
    public Nullable`1<TimeSpan> get_MaxAge();
    public void set_MaxAge(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_SharedMaxAge();
    public void set_SharedMaxAge(Nullable`1<TimeSpan> value);
    public bool get_MaxStale();
    public void set_MaxStale(bool value);
    public Nullable`1<TimeSpan> get_MaxStaleLimit();
    public void set_MaxStaleLimit(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_MinFresh();
    public void set_MinFresh(Nullable`1<TimeSpan> value);
    public bool get_NoTransform();
    public void set_NoTransform(bool value);
    public bool get_OnlyIfCached();
    public void set_OnlyIfCached(bool value);
    public bool get_Public();
    public void set_Public(bool value);
    public bool get_Private();
    public void set_Private(bool value);
    public ICollection`1<string> get_PrivateHeaders();
    public bool get_MustRevalidate();
    public void set_MustRevalidate(bool value);
    public bool get_ProxyRevalidate();
    public void set_ProxyRevalidate(bool value);
    public ICollection`1<NameValueHeaderValue> get_Extensions();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CacheControlHeaderValue Parse(string input);
    public static bool TryParse(string input, CacheControlHeaderValue& parsedValue);
    internal static int GetCacheControlLength(string input, int startIndex, CacheControlHeaderValue storeValue, CacheControlHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.ContentDispositionHeaderValue : object {
    public string DispositionType { get; public set; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public string Name { get; public set; }
    public string FileName { get; public set; }
    public string FileNameStar { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ReadDate { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source);
    public ContentDispositionHeaderValue(string dispositionType);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_Name();
    public void set_Name(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_FileNameStar();
    public void set_FileNameStar(string value);
    public Nullable`1<DateTimeOffset> get_CreationDate();
    public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ModificationDate();
    public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ReadDate();
    public void set_ReadDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<long> get_Size();
    public void set_Size(Nullable`1<long> value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    public static ContentDispositionHeaderValue Parse(string input);
    public static bool TryParse(string input, ContentDispositionHeaderValue& parsedValue);
    internal static int GetDispositionTypeLength(string input, int startIndex, Object& parsedValue);
}
public class System.Net.Http.Headers.ContentRangeHeaderValue : object {
    public string Unit { get; public set; }
    public Nullable`1<long> From { get; }
    public Nullable`1<long> To { get; }
    public Nullable`1<long> Length { get; }
    public bool HasLength { get; }
    public bool HasRange { get; }
    public ContentRangeHeaderValue(long from, long to, long length);
    public ContentRangeHeaderValue(long length);
    public ContentRangeHeaderValue(long from, long to);
    public string get_Unit();
    public void set_Unit(string value);
    public Nullable`1<long> get_From();
    public Nullable`1<long> get_To();
    public Nullable`1<long> get_Length();
    public bool get_HasLength();
    public bool get_HasRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ContentRangeHeaderValue Parse(string input);
    public static bool TryParse(string input, ContentRangeHeaderValue& parsedValue);
    internal static int GetContentRangeLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.DateHeaderParser : HttpHeaderParser {
    internal static DateHeaderParser Parser;
    private static DateHeaderParser();
    public virtual string ToString(object value);
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
public class System.Net.Http.Headers.EntityTagHeaderValue : object {
    public string Tag { get; }
    public bool IsWeak { get; }
    public static EntityTagHeaderValue Any { get; }
    public EntityTagHeaderValue(string tag);
    public EntityTagHeaderValue(string tag, bool isWeak);
    public string get_Tag();
    public bool get_IsWeak();
    public static EntityTagHeaderValue get_Any();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static EntityTagHeaderValue Parse(string input);
    public static bool TryParse(string input, EntityTagHeaderValue& parsedValue);
    internal static int GetEntityTagLength(string input, int startIndex, EntityTagHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.GenericHeaderParser : BaseHeaderParser {
    internal static HttpHeaderParser HostParser;
    internal static HttpHeaderParser TokenListParser;
    internal static HttpHeaderParser SingleValueNameValueWithParametersParser;
    internal static HttpHeaderParser MultipleValueNameValueWithParametersParser;
    internal static HttpHeaderParser SingleValueNameValueParser;
    internal static HttpHeaderParser MultipleValueNameValueParser;
    internal static HttpHeaderParser MailAddressParser;
    internal static HttpHeaderParser SingleValueProductParser;
    internal static HttpHeaderParser MultipleValueProductParser;
    internal static HttpHeaderParser RangeConditionParser;
    internal static HttpHeaderParser SingleValueAuthenticationParser;
    internal static HttpHeaderParser MultipleValueAuthenticationParser;
    internal static HttpHeaderParser RangeParser;
    internal static HttpHeaderParser RetryConditionParser;
    internal static HttpHeaderParser ContentRangeParser;
    internal static HttpHeaderParser ContentDispositionParser;
    internal static HttpHeaderParser SingleValueStringWithQualityParser;
    internal static HttpHeaderParser MultipleValueStringWithQualityParser;
    internal static HttpHeaderParser SingleValueEntityTagParser;
    internal static HttpHeaderParser MultipleValueEntityTagParser;
    internal static HttpHeaderParser SingleValueViaParser;
    internal static HttpHeaderParser MultipleValueViaParser;
    internal static HttpHeaderParser SingleValueWarningParser;
    internal static HttpHeaderParser MultipleValueWarningParser;
    public IEqualityComparer Comparer { get; }
    private static GenericHeaderParser();
    public virtual IEqualityComparer get_Comparer();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal static class System.Net.Http.Headers.HeaderUtilities : object {
    internal static string ConnectionClose;
    internal static TransferCodingHeaderValue TransferEncodingChunked;
    internal static NameValueWithParametersHeaderValue ExpectContinue;
    internal static string BytesUnit;
    internal static Action`2<HttpHeaderValueCollection`1<string>, string> TokenValidator;
    private static HeaderUtilities();
    internal static void SetQuality(ICollection`1<NameValueHeaderValue> parameters, Nullable`1<double> value);
    internal static Nullable`1<double> GetQuality(ICollection`1<NameValueHeaderValue> parameters);
    internal static void CheckValidToken(string value, string parameterName);
    internal static void CheckValidComment(string value, string parameterName);
    internal static void CheckValidQuotedString(string value, string parameterName);
    internal static bool AreEqualCollections(ICollection`1<T> x, ICollection`1<T> y);
    internal static bool AreEqualCollections(ICollection`1<T> x, ICollection`1<T> y, IEqualityComparer`1<T> comparer);
    internal static int GetNextNonEmptyOrWhitespaceIndex(string input, int startIndex, bool skipEmptyValues, Boolean& separatorFound);
    internal static Nullable`1<DateTimeOffset> GetDateTimeOffsetValue(string headerName, HttpHeaders store);
    internal static Nullable`1<TimeSpan> GetTimeSpanValue(string headerName, HttpHeaders store);
    internal static bool TryParseInt32(string value, Int32& result);
    internal static bool TryParseInt64(string value, Int64& result);
    internal static string DumpHeaders(HttpHeaders[] headers);
    internal static bool IsValidEmailAddress(string value);
}
public class System.Net.Http.Headers.HttpContentHeaders : HttpHeaders {
    public ICollection`1<string> Allow { get; }
    public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    public ICollection`1<string> ContentEncoding { get; }
    public ICollection`1<string> ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public Uri ContentLocation { get; public set; }
    public Byte[] ContentMD5 { get; public set; }
    public ContentRangeHeaderValue ContentRange { get; public set; }
    public MediaTypeHeaderValue ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    internal HttpContentHeaders(Func`1<Nullable`1<long>> calculateLengthFunc);
    private static HttpContentHeaders();
    public ICollection`1<string> get_Allow();
    public ContentDispositionHeaderValue get_ContentDisposition();
    public void set_ContentDisposition(ContentDispositionHeaderValue value);
    public ICollection`1<string> get_ContentEncoding();
    public ICollection`1<string> get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Uri get_ContentLocation();
    public void set_ContentLocation(Uri value);
    public Byte[] get_ContentMD5();
    public void set_ContentMD5(Byte[] value);
    public ContentRangeHeaderValue get_ContentRange();
    public void set_ContentRange(ContentRangeHeaderValue value);
    public MediaTypeHeaderValue get_ContentType();
    public void set_ContentType(MediaTypeHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
    internal static void AddKnownHeaders(HashSet`1<string> headerSet);
}
internal class System.Net.Http.Headers.HttpGeneralHeaders : object {
    public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    internal HttpGeneralHeaders(HttpHeaders parent);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal static void AddParsers(Dictionary`2<string, HttpHeaderParser> parserStore);
    internal static void AddKnownHeaders(HashSet`1<string> headerSet);
    internal void AddSpecialsFrom(HttpGeneralHeaders sourceHeaders);
}
internal abstract class System.Net.Http.Headers.HttpHeaderParser : object {
    internal static string DefaultSeparator;
    public bool SupportsMultipleValues { get; }
    public string Separator { get; }
    public IEqualityComparer Comparer { get; }
    protected HttpHeaderParser(bool supportsMultipleValues);
    protected HttpHeaderParser(bool supportsMultipleValues, string separator);
    public bool get_SupportsMultipleValues();
    public string get_Separator();
    public virtual IEqualityComparer get_Comparer();
    public abstract virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
    public object ParseValue(string value, object storeValue, Int32& index);
    public virtual string ToString(object value);
}
public abstract class System.Net.Http.Headers.HttpHeaders : object {
    public void Add(string name, string value);
    public void Add(string name, IEnumerable`1<string> values);
    public bool TryAddWithoutValidation(string name, string value);
    public bool TryAddWithoutValidation(string name, IEnumerable`1<string> values);
    public void Clear();
    public bool Remove(string name);
    public IEnumerable`1<string> GetValues(string name);
    public bool TryGetValues(string name, IEnumerable`1& values);
    public bool Contains(string name);
    public virtual string ToString();
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaders/<GetHeaderStrings>d__15")]
internal IEnumerable`1<KeyValuePair`2<string, string>> GetHeaderStrings();
    internal string GetHeaderString(string headerName);
    internal string GetHeaderString(string headerName, object exclude);
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaders/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void SetConfiguration(Dictionary`2<string, HttpHeaderParser> parserStore, HashSet`1<string> invalidHeaders);
    internal void AddParsedValue(string name, object value);
    internal void SetParsedValue(string name, object value);
    internal void SetOrRemoveParsedValue(string name, object value);
    internal bool RemoveParsedValue(string name, object value);
    internal bool ContainsParsedValue(string name, object value);
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
    internal bool TryParseAndAddValue(string name, string value);
    internal object GetParsedValues(string name);
}
public class System.Net.Http.Headers.HttpHeaderValueCollection`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal bool IsSpecialValueSet { get; }
    internal HttpHeaderValueCollection`1(string headerName, HttpHeaders store);
    internal HttpHeaderValueCollection`1(string headerName, HttpHeaders store, Action`2<HttpHeaderValueCollection`1<T>, T> validator);
    internal HttpHeaderValueCollection`1(string headerName, HttpHeaders store, T specialValue);
    internal HttpHeaderValueCollection`1(string headerName, HttpHeaders store, T specialValue, Action`2<HttpHeaderValueCollection`1<T>, T> validator);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal bool get_IsSpecialValueSet();
    public sealed virtual void Add(T item);
    public void ParseAdd(string input);
    public bool TryParseAdd(string input);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaderValueCollection`1/<GetEnumerator>d__21")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal string GetHeaderStringWithoutSpecial();
    internal void SetSpecialValue();
    internal void RemoveSpecialValue();
}
public class System.Net.Http.Headers.HttpRequestHeaders : HttpHeaders {
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> Accept { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptCharset { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptEncoding { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptLanguage { get; }
    public AuthenticationHeaderValue Authorization { get; public set; }
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> Expect { get; }
    public Nullable`1<bool> ExpectContinue { get; public set; }
    public string From { get; public set; }
    public string Host { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfMatch { get; }
    public Nullable`1<DateTimeOffset> IfModifiedSince { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfNoneMatch { get; }
    public RangeConditionHeaderValue IfRange { get; public set; }
    public Nullable`1<DateTimeOffset> IfUnmodifiedSince { get; public set; }
    public Nullable`1<int> MaxForwards { get; public set; }
    public AuthenticationHeaderValue ProxyAuthorization { get; public set; }
    public RangeHeaderValue Range { get; public set; }
    public Uri Referrer { get; public set; }
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> TE { get; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent { get; }
    public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    private static HttpRequestHeaders();
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> get_Accept();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptCharset();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptEncoding();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptLanguage();
    public AuthenticationHeaderValue get_Authorization();
    public void set_Authorization(AuthenticationHeaderValue value);
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> get_Expect();
    public Nullable`1<bool> get_ExpectContinue();
    public void set_ExpectContinue(Nullable`1<bool> value);
    public string get_From();
    public void set_From(string value);
    public string get_Host();
    public void set_Host(string value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfMatch();
    public Nullable`1<DateTimeOffset> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfNoneMatch();
    public RangeConditionHeaderValue get_IfRange();
    public void set_IfRange(RangeConditionHeaderValue value);
    public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_MaxForwards();
    public void set_MaxForwards(Nullable`1<int> value);
    public AuthenticationHeaderValue get_ProxyAuthorization();
    public void set_ProxyAuthorization(AuthenticationHeaderValue value);
    public RangeHeaderValue get_Range();
    public void set_Range(RangeHeaderValue value);
    public Uri get_Referrer();
    public void set_Referrer(Uri value);
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> get_TE();
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent();
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal static void AddKnownHeaders(HashSet`1<string> headerSet);
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
}
public class System.Net.Http.Headers.HttpResponseHeaders : HttpHeaders {
    public HttpHeaderValueCollection`1<string> AcceptRanges { get; }
    public Nullable`1<TimeSpan> Age { get; public set; }
    public EntityTagHeaderValue ETag { get; public set; }
    public Uri Location { get; public set; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> ProxyAuthenticate { get; }
    public RetryConditionHeaderValue RetryAfter { get; public set; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> Server { get; }
    public HttpHeaderValueCollection`1<string> Vary { get; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    private static HttpResponseHeaders();
    public HttpHeaderValueCollection`1<string> get_AcceptRanges();
    public Nullable`1<TimeSpan> get_Age();
    public void set_Age(Nullable`1<TimeSpan> value);
    public EntityTagHeaderValue get_ETag();
    public void set_ETag(EntityTagHeaderValue value);
    public Uri get_Location();
    public void set_Location(Uri value);
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_ProxyAuthenticate();
    public RetryConditionHeaderValue get_RetryAfter();
    public void set_RetryAfter(RetryConditionHeaderValue value);
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_Server();
    public HttpHeaderValueCollection`1<string> get_Vary();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_WwwAuthenticate();
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal static void AddKnownHeaders(HashSet`1<string> headerSet);
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
}
internal class System.Net.Http.Headers.Int32NumberHeaderParser : BaseHeaderParser {
    internal static Int32NumberHeaderParser Parser;
    private static Int32NumberHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.Int64NumberHeaderParser : BaseHeaderParser {
    internal static Int64NumberHeaderParser Parser;
    private static Int64NumberHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.MediaTypeHeaderParser : BaseHeaderParser {
    internal static MediaTypeHeaderParser SingleValueParser;
    internal static MediaTypeHeaderParser SingleValueWithQualityParser;
    internal static MediaTypeHeaderParser MultipleValuesParser;
    private static MediaTypeHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
public class System.Net.Http.Headers.MediaTypeHeaderValue : object {
    public string CharSet { get; public set; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public string MediaType { get; public set; }
    protected MediaTypeHeaderValue(MediaTypeHeaderValue source);
    public MediaTypeHeaderValue(string mediaType);
    public string get_CharSet();
    public void set_CharSet(string value);
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_MediaType();
    public void set_MediaType(string value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MediaTypeHeaderValue Parse(string input);
    public static bool TryParse(string input, MediaTypeHeaderValue& parsedValue);
    internal static int GetMediaTypeLength(string input, int startIndex, Func`1<MediaTypeHeaderValue> mediaTypeCreator, MediaTypeHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public MediaTypeWithQualityHeaderValue(string mediaType);
    public MediaTypeWithQualityHeaderValue(string mediaType, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    private sealed virtual override object System.ICloneable.Clone();
    public static MediaTypeWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, MediaTypeWithQualityHeaderValue& parsedValue);
}
public class System.Net.Http.Headers.NameValueHeaderValue : object {
    public string Name { get; }
    public string Value { get; public set; }
    public NameValueHeaderValue(string name);
    public NameValueHeaderValue(string name, string value);
    protected NameValueHeaderValue(NameValueHeaderValue source);
    private static NameValueHeaderValue();
    public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static NameValueHeaderValue Parse(string input);
    public static bool TryParse(string input, NameValueHeaderValue& parsedValue);
    public virtual string ToString();
    internal static void ToString(ICollection`1<NameValueHeaderValue> values, char separator, bool leadingSeparator, StringBuilder destination);
    internal static string ToString(ICollection`1<NameValueHeaderValue> values, char separator, bool leadingSeparator);
    internal static int GetHashCode(ICollection`1<NameValueHeaderValue> values);
    internal static int GetNameValueLength(string input, int startIndex, NameValueHeaderValue& parsedValue);
    internal static int GetNameValueLength(string input, int startIndex, Func`1<NameValueHeaderValue> nameValueCreator, NameValueHeaderValue& parsedValue);
    internal static int GetNameValueListLength(string input, int startIndex, char delimiter, ICollection`1<NameValueHeaderValue> nameValueCollection);
    internal static NameValueHeaderValue Find(ICollection`1<NameValueHeaderValue> values, string name);
    internal static int GetValueLength(string input, int startIndex);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.NameValueWithParametersHeaderValue : NameValueHeaderValue {
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public NameValueWithParametersHeaderValue(string name);
    public NameValueWithParametersHeaderValue(string name, string value);
    protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source);
    private static NameValueWithParametersHeaderValue();
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static NameValueWithParametersHeaderValue Parse(string input);
    public static bool TryParse(string input, NameValueWithParametersHeaderValue& parsedValue);
    internal static int GetNameValueWithParametersLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.ObjectCollection`1 : Collection`1<T> {
    public ObjectCollection`1(Action`1<T> validator);
    private static ObjectCollection`1();
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
}
public class System.Net.Http.Headers.ProductHeaderValue : object {
    public string Name { get; }
    public string Version { get; }
    public ProductHeaderValue(string name);
    public ProductHeaderValue(string name, string version);
    public string get_Name();
    public string get_Version();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductHeaderValue Parse(string input);
    public static bool TryParse(string input, ProductHeaderValue& parsedValue);
    internal static int GetProductLength(string input, int startIndex, ProductHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.ProductInfoHeaderParser : HttpHeaderParser {
    internal static ProductInfoHeaderParser SingleValueParser;
    internal static ProductInfoHeaderParser MultipleValueParser;
    private static ProductInfoHeaderParser();
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
public class System.Net.Http.Headers.ProductInfoHeaderValue : object {
    public ProductHeaderValue Product { get; }
    public string Comment { get; }
    public ProductInfoHeaderValue(string productName, string productVersion);
    public ProductInfoHeaderValue(ProductHeaderValue product);
    public ProductInfoHeaderValue(string comment);
    public ProductHeaderValue get_Product();
    public string get_Comment();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductInfoHeaderValue Parse(string input);
    public static bool TryParse(string input, ProductInfoHeaderValue& parsedValue);
    internal static int GetProductInfoLength(string input, int startIndex, ProductInfoHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RangeConditionHeaderValue : object {
    public Nullable`1<DateTimeOffset> Date { get; }
    public EntityTagHeaderValue EntityTag { get; }
    public RangeConditionHeaderValue(DateTimeOffset date);
    public RangeConditionHeaderValue(EntityTagHeaderValue entityTag);
    public RangeConditionHeaderValue(string entityTag);
    public Nullable`1<DateTimeOffset> get_Date();
    public EntityTagHeaderValue get_EntityTag();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeConditionHeaderValue Parse(string input);
    public static bool TryParse(string input, RangeConditionHeaderValue& parsedValue);
    internal static int GetRangeConditionLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RangeHeaderValue : object {
    public string Unit { get; public set; }
    public ICollection`1<RangeItemHeaderValue> Ranges { get; }
    public RangeHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    public string get_Unit();
    public void set_Unit(string value);
    public ICollection`1<RangeItemHeaderValue> get_Ranges();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeHeaderValue Parse(string input);
    public static bool TryParse(string input, RangeHeaderValue& parsedValue);
    internal static int GetRangeLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RangeItemHeaderValue : object {
    public Nullable`1<long> From { get; }
    public Nullable`1<long> To { get; }
    public RangeItemHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    public Nullable`1<long> get_From();
    public Nullable`1<long> get_To();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static int GetRangeItemListLength(string input, int startIndex, ICollection`1<RangeItemHeaderValue> rangeCollection);
    internal static int GetRangeItemLength(string input, int startIndex, RangeItemHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RetryConditionHeaderValue : object {
    public Nullable`1<DateTimeOffset> Date { get; }
    public Nullable`1<TimeSpan> Delta { get; }
    public RetryConditionHeaderValue(DateTimeOffset date);
    public RetryConditionHeaderValue(TimeSpan delta);
    public Nullable`1<DateTimeOffset> get_Date();
    public Nullable`1<TimeSpan> get_Delta();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RetryConditionHeaderValue Parse(string input);
    public static bool TryParse(string input, RetryConditionHeaderValue& parsedValue);
    internal static int GetRetryConditionLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.StringWithQualityHeaderValue : object {
    public string Value { get; }
    public Nullable`1<double> Quality { get; }
    public StringWithQualityHeaderValue(string value);
    public StringWithQualityHeaderValue(string value, double quality);
    public string get_Value();
    public Nullable`1<double> get_Quality();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, StringWithQualityHeaderValue& parsedValue);
    internal static int GetStringWithQualityLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.TimeSpanHeaderParser : BaseHeaderParser {
    internal static TimeSpanHeaderParser Parser;
    private static TimeSpanHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.TransferCodingHeaderParser : BaseHeaderParser {
    internal static TransferCodingHeaderParser SingleValueParser;
    internal static TransferCodingHeaderParser MultipleValueParser;
    internal static TransferCodingHeaderParser SingleValueWithQualityParser;
    internal static TransferCodingHeaderParser MultipleValueWithQualityParser;
    private static TransferCodingHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
public class System.Net.Http.Headers.TransferCodingHeaderValue : object {
    public string Value { get; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    protected TransferCodingHeaderValue(TransferCodingHeaderValue source);
    public TransferCodingHeaderValue(string value);
    public string get_Value();
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public static TransferCodingHeaderValue Parse(string input);
    public static bool TryParse(string input, TransferCodingHeaderValue& parsedValue);
    internal static int GetTransferCodingLength(string input, int startIndex, Func`1<TransferCodingHeaderValue> transferCodingCreator, TransferCodingHeaderValue& parsedValue);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public TransferCodingWithQualityHeaderValue(string value);
    public TransferCodingWithQualityHeaderValue(string value, double quality);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    private sealed virtual override object System.ICloneable.Clone();
    public static TransferCodingWithQualityHeaderValue Parse(string input);
    public static bool TryParse(string input, TransferCodingWithQualityHeaderValue& parsedValue);
}
internal class System.Net.Http.Headers.UriHeaderParser : HttpHeaderParser {
    internal static UriHeaderParser RelativeOrAbsoluteUriParser;
    private static UriHeaderParser();
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
    public virtual string ToString(object value);
}
public class System.Net.Http.Headers.ViaHeaderValue : object {
    public string ProtocolName { get; }
    public string ProtocolVersion { get; }
    public string ReceivedBy { get; }
    public string Comment { get; }
    public ViaHeaderValue(string protocolVersion, string receivedBy);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment);
    public string get_ProtocolName();
    public string get_ProtocolVersion();
    public string get_ReceivedBy();
    public string get_Comment();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ViaHeaderValue Parse(string input);
    public static bool TryParse(string input, ViaHeaderValue& parsedValue);
    internal static int GetViaLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.WarningHeaderValue : object {
    public int Code { get; }
    public string Agent { get; }
    public string Text { get; }
    public Nullable`1<DateTimeOffset> Date { get; }
    public WarningHeaderValue(int code, string agent, string text);
    public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date);
    public int get_Code();
    public string get_Agent();
    public string get_Text();
    public Nullable`1<DateTimeOffset> get_Date();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static WarningHeaderValue Parse(string input);
    public static bool TryParse(string input, WarningHeaderValue& parsedValue);
    internal static int GetWarningLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.HttpClient : HttpMessageInvoker {
    public HttpRequestHeaders DefaultRequestHeaders { get; }
    public Uri BaseAddress { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public long MaxResponseContentBufferSize { get; public set; }
    public HttpClient(HttpMessageHandler handler);
    public HttpClient(HttpMessageHandler handler, bool disposeHandler);
    private static HttpClient();
    public HttpRequestHeaders get_DefaultRequestHeaders();
    public Uri get_BaseAddress();
    public void set_BaseAddress(Uri value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public long get_MaxResponseContentBufferSize();
    public void set_MaxResponseContentBufferSize(long value);
    public Task`1<string> GetStringAsync(string requestUri);
    public Task`1<string> GetStringAsync(Uri requestUri);
    public Task`1<Byte[]> GetByteArrayAsync(string requestUri);
    public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri);
    public Task`1<Stream> GetStreamAsync(string requestUri);
    public Task`1<Stream> GetStreamAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content);
    public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public void CancelPendingRequests();
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Http.HttpClientHandler : HttpMessageHandler {
    public bool SupportsAutomaticDecompression { get; }
    public bool SupportsProxy { get; }
    public bool SupportsRedirectConfiguration { get; }
    public bool UseCookies { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ClientCertificateOption ClientCertificateOptions { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool UseProxy { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public int MaxAutomaticRedirections { get; public set; }
    public long MaxRequestContentBufferSize { get; public set; }
    private static HttpClientHandler();
    public virtual bool get_SupportsAutomaticDecompression();
    public virtual bool get_SupportsProxy();
    public virtual bool get_SupportsRedirectConfiguration();
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    public ClientCertificateOption get_ClientCertificateOptions();
    public void set_ClientCertificateOptions(ClientCertificateOption value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_UseProxy();
    public void set_UseProxy(bool value);
    public IWebProxy get_Proxy();
    [SecuritySafeCriticalAttribute]
public void set_Proxy(IWebProxy value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public int get_MaxAutomaticRedirections();
    public void set_MaxAutomaticRedirections(int value);
    public long get_MaxRequestContentBufferSize();
    public void set_MaxRequestContentBufferSize(long value);
    protected virtual void Dispose(bool disposing);
    internal virtual void InitializeWebRequest(HttpRequestMessage request, HttpWebRequest webRequest);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    internal void CheckDisposedOrStarted();
}
public enum System.Net.Http.HttpCompletionOption : Enum {
    public int value__;
    public static HttpCompletionOption ResponseContentRead;
    public static HttpCompletionOption ResponseHeadersRead;
}
public abstract class System.Net.Http.HttpContent : object {
    internal static long MaxBufferSize;
    internal static Encoding DefaultStringEncoding;
    public HttpContentHeaders Headers { get; }
    private static HttpContent();
    public HttpContentHeaders get_Headers();
    public Task`1<string> ReadAsStringAsync();
    public Task`1<Byte[]> ReadAsByteArrayAsync();
    public Task`1<Stream> ReadAsStreamAsync();
    protected abstract virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    public Task CopyToAsync(Stream stream, TransportContext context);
    public Task CopyToAsync(Stream stream);
    internal void CopyTo(Stream stream);
    public Task LoadIntoBufferAsync();
    public Task LoadIntoBufferAsync(long maxBufferSize);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected internal abstract virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public abstract class System.Net.Http.HttpMessageHandler : object {
    protected internal abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class System.Net.Http.HttpMessageInvoker : object {
    public HttpMessageInvoker(HttpMessageHandler handler);
    public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Http.HttpMethod : object {
    public static HttpMethod Get { get; }
    public static HttpMethod Put { get; }
    public static HttpMethod Post { get; }
    public static HttpMethod Delete { get; }
    public static HttpMethod Head { get; }
    public static HttpMethod Options { get; }
    public static HttpMethod Trace { get; }
    public string Method { get; }
    public HttpMethod(string method);
    private static HttpMethod();
    public static HttpMethod get_Get();
    public static HttpMethod get_Put();
    public static HttpMethod get_Post();
    public static HttpMethod get_Delete();
    public static HttpMethod get_Head();
    public static HttpMethod get_Options();
    public static HttpMethod get_Trace();
    public string get_Method();
    public sealed virtual bool Equals(HttpMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(HttpMethod left, HttpMethod right);
    public static bool op_Inequality(HttpMethod left, HttpMethod right);
}
internal enum System.Net.Http.HttpParseResult : Enum {
    public int value__;
    public static HttpParseResult Parsed;
    public static HttpParseResult NotParsed;
    public static HttpParseResult InvalidFormat;
}
public class System.Net.Http.HttpRequestException : Exception {
    public HttpRequestException(string message);
    public HttpRequestException(string message, Exception inner);
    private static HttpRequestException();
}
public class System.Net.Http.HttpRequestMessage : object {
    public Version Version { get; public set; }
    public HttpContent Content { get; public set; }
    public HttpMethod Method { get; public set; }
    public Uri RequestUri { get; public set; }
    public HttpRequestHeaders Headers { get; }
    public IDictionary`2<string, object> Properties { get; }
    public HttpRequestMessage(HttpMethod method, Uri requestUri);
    public HttpRequestMessage(HttpMethod method, string requestUri);
    public Version get_Version();
    public void set_Version(Version value);
    public HttpContent get_Content();
    public void set_Content(HttpContent value);
    public HttpMethod get_Method();
    public void set_Method(HttpMethod value);
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
    public HttpRequestHeaders get_Headers();
    public IDictionary`2<string, object> get_Properties();
    public virtual string ToString();
    internal bool MarkAsSent();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class System.Net.Http.HttpResponseMessage : object {
    public Version Version { get; public set; }
    public HttpContent Content { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public HttpResponseHeaders Headers { get; }
    public HttpRequestMessage RequestMessage { get; public set; }
    public bool IsSuccessStatusCode { get; }
    public HttpResponseMessage(HttpStatusCode statusCode);
    public Version get_Version();
    public void set_Version(Version value);
    public HttpContent get_Content();
    public void set_Content(HttpContent value);
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    public string get_ReasonPhrase();
    public void set_ReasonPhrase(string value);
    public HttpResponseHeaders get_Headers();
    public HttpRequestMessage get_RequestMessage();
    public void set_RequestMessage(HttpRequestMessage value);
    public bool get_IsSuccessStatusCode();
    public HttpResponseMessage EnsureSuccessStatusCode();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal static class System.Net.Http.HttpRuleParser : object {
    internal static char CR;
    internal static char LF;
    internal static int MaxInt64Digits;
    internal static int MaxInt32Digits;
    internal static Encoding DefaultHttpEncoding;
    private static HttpRuleParser();
    internal static bool IsTokenChar(char character);
    internal static int GetTokenLength(string input, int startIndex);
    internal static int GetWhitespaceLength(string input, int startIndex);
    internal static bool ContainsInvalidNewLine(string value);
    internal static bool ContainsInvalidNewLine(string value, int startIndex);
    internal static int GetNumberLength(string input, int startIndex, bool allowDecimal);
    internal static int GetHostLength(string input, int startIndex, bool allowToken, String& host);
    internal static HttpParseResult GetCommentLength(string input, int startIndex, Int32& length);
    internal static HttpParseResult GetQuotedStringLength(string input, int startIndex, Int32& length);
    internal static HttpParseResult GetQuotedPairLength(string input, int startIndex, Int32& length);
    internal static string DateToString(DateTimeOffset dateTime);
    internal static bool TryStringToDate(string input, DateTimeOffset& result);
}
[ExtensionAttribute]
internal static class System.Net.Http.HttpUtilities : object {
    internal static Version DefaultVersion;
    internal static Byte[] EmptyByteArray;
    private static HttpUtilities();
    internal static bool IsHttpUri(Uri uri);
    internal static bool HandleFaultsAndCancelation(Task task, TaskCompletionSource`1<T> tcs);
    [ExtensionAttribute]
internal static Task ContinueWithStandard(Task task, Action`1<Task> continuation);
    [ExtensionAttribute]
internal static Task ContinueWithStandard(Task`1<T> task, Action`1<Task`1<T>> continuation);
}
[ComVisibleAttribute("True")]
[GuidAttribute("5e7abb2c-f2c1-4a61-bd35-deb7a08ab0f1")]
[InterfaceTypeAttribute("1")]
internal interface System.Net.Http.INetworkTransportSettings {
    public abstract virtual void ApplySetting(TRANSPORT_SETTING_ID& settingId, int lengthIn, IntPtr valueIn, Int32& lengthOut, IntPtr& valueOut);
    public abstract virtual void QuerySetting(TRANSPORT_SETTING_ID& settingId, int lengthIn, IntPtr valueIn, Int32& lengthOut, IntPtr& valueOut);
}
[ComVisibleAttribute("True")]
[GuidAttribute("79eb1402-0ab8-49c0-9e14-a1ae4ba93058")]
[InterfaceTypeAttribute("1")]
internal interface System.Net.Http.INotificationTransportSync {
    public abstract virtual void CompleteDelivery();
    public abstract virtual void Flush();
}
public abstract class System.Net.Http.MessageProcessingHandler : DelegatingHandler {
    protected MessageProcessingHandler(HttpMessageHandler innerHandler);
    protected abstract virtual HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);
    protected abstract virtual HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);
    protected internal sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.Net.Http.MultipartContent : HttpContent {
    public MultipartContent(string subtype);
    public MultipartContent(string subtype, string boundary);
    public virtual void Add(HttpContent content);
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<HttpContent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.MultipartFormDataContent : MultipartContent {
    public MultipartFormDataContent(string boundary);
    public virtual void Add(HttpContent content);
    public void Add(HttpContent content, string name);
    public void Add(HttpContent content, string name, string fileName);
}
[ComVisibleAttribute("True")]
internal class System.Net.Http.RtcRequestMessage : HttpRequestMessage {
    internal RtcState state;
    internal RtcRequestMessage(HttpMethod method, Uri uri);
    private static RtcRequestMessage();
    [SecuritySafeCriticalAttribute]
public sealed virtual void ApplySetting(TRANSPORT_SETTING_ID& settingId, int lengthIn, IntPtr valueIn, Int32& lengthOut, IntPtr& valueOut);
    [SecuritySafeCriticalAttribute]
public sealed virtual void QuerySetting(TRANSPORT_SETTING_ID& settingId, int lengthIn, IntPtr valueIn, Int32& lengthOut, IntPtr& valueOut);
    public sealed virtual void CompleteDelivery();
    public sealed virtual void Flush();
}
[ExtensionAttribute]
internal static class System.Net.Http.RtcRequestMessageExtensions : object {
    [ExtensionAttribute]
internal static void SetRtcOptions(HttpRequestMessage request, HttpWebRequest webRequest);
    [ExtensionAttribute]
internal static void MarkRtcFlushComplete(HttpRequestMessage request);
    [ExtensionAttribute]
internal static void AbortRtcRequest(HttpRequestMessage request);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.Net.Http.SR : object {
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string net_http_argument_empty_string { get; }
    internal static string net_http_client_absolute_baseaddress_required { get; }
    internal static string net_http_client_content_headers { get; }
    internal static string net_http_client_execution_error { get; }
    internal static string net_http_client_http_baseaddress_required { get; }
    internal static string net_http_client_invalid_requesturi { get; }
    internal static string net_http_client_request_already_sent { get; }
    internal static string net_http_client_request_headers { get; }
    internal static string net_http_client_response_headers { get; }
    internal static string net_http_client_send_canceled { get; }
    internal static string net_http_client_send_completed { get; }
    internal static string net_http_client_send_error { get; }
    internal static string net_http_content_buffersize_exceeded { get; }
    internal static string net_http_content_buffersize_limit { get; }
    internal static string net_http_content_encoding_set { get; }
    internal static string net_http_content_field_too_long { get; }
    internal static string net_http_content_invalid_charset { get; }
    internal static string net_http_content_no_task_returned { get; }
    internal static string net_http_content_readonly_stream { get; }
    internal static string net_http_content_stream_already_read { get; }
    internal static string net_http_content_stream_copy_error { get; }
    internal static string net_http_copyto_array_too_small { get; }
    internal static string net_http_handler_nocontentlength { get; }
    internal static string net_http_handler_norequest { get; }
    internal static string net_http_handler_noresponse { get; }
    internal static string net_http_handler_not_assigned { get; }
    internal static string net_http_headers_cant_add_any_to_collection { get; }
    internal static string net_http_headers_invalid_etag_name { get; }
    internal static string net_http_headers_invalid_from_header { get; }
    internal static string net_http_headers_invalid_header_name { get; }
    internal static string net_http_headers_invalid_host_header { get; }
    internal static string net_http_headers_invalid_range { get; }
    internal static string net_http_headers_invalid_value { get; }
    internal static string net_http_headers_no_newlines { get; }
    internal static string net_http_headers_not_allowed_header_name { get; }
    internal static string net_http_headers_not_found { get; }
    internal static string net_http_headers_single_value_header { get; }
    internal static string net_http_httpmethod_format_error { get; }
    internal static string net_http_invalid_enable_first { get; }
    internal static string net_http_log_content_no_task_returned_copytoasync { get; }
    internal static string net_http_log_content_null { get; }
    internal static string net_http_log_content_offload_async { get; }
    internal static string net_http_log_headers_invalid_quality { get; }
    internal static string net_http_log_headers_invalid_value { get; }
    internal static string net_http_log_headers_no_newlines { get; }
    internal static string net_http_log_headers_wrong_email_format { get; }
    internal static string net_http_message_not_success_statuscode { get; }
    internal static string net_http_operation_started { get; }
    internal static string net_http_parser_invalid_base64_string { get; }
    internal static string net_http_parser_invalid_date_format { get; }
    internal static string net_http_read_error { get; }
    internal static string net_http_reasonphrase_format_error { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_net_http_argument_empty_string();
    internal static string get_net_http_client_absolute_baseaddress_required();
    internal static string get_net_http_client_content_headers();
    internal static string get_net_http_client_execution_error();
    internal static string get_net_http_client_http_baseaddress_required();
    internal static string get_net_http_client_invalid_requesturi();
    internal static string get_net_http_client_request_already_sent();
    internal static string get_net_http_client_request_headers();
    internal static string get_net_http_client_response_headers();
    internal static string get_net_http_client_send_canceled();
    internal static string get_net_http_client_send_completed();
    internal static string get_net_http_client_send_error();
    internal static string get_net_http_content_buffersize_exceeded();
    internal static string get_net_http_content_buffersize_limit();
    internal static string get_net_http_content_encoding_set();
    internal static string get_net_http_content_field_too_long();
    internal static string get_net_http_content_invalid_charset();
    internal static string get_net_http_content_no_task_returned();
    internal static string get_net_http_content_readonly_stream();
    internal static string get_net_http_content_stream_already_read();
    internal static string get_net_http_content_stream_copy_error();
    internal static string get_net_http_copyto_array_too_small();
    internal static string get_net_http_handler_nocontentlength();
    internal static string get_net_http_handler_norequest();
    internal static string get_net_http_handler_noresponse();
    internal static string get_net_http_handler_not_assigned();
    internal static string get_net_http_headers_cant_add_any_to_collection();
    internal static string get_net_http_headers_invalid_etag_name();
    internal static string get_net_http_headers_invalid_from_header();
    internal static string get_net_http_headers_invalid_header_name();
    internal static string get_net_http_headers_invalid_host_header();
    internal static string get_net_http_headers_invalid_range();
    internal static string get_net_http_headers_invalid_value();
    internal static string get_net_http_headers_no_newlines();
    internal static string get_net_http_headers_not_allowed_header_name();
    internal static string get_net_http_headers_not_found();
    internal static string get_net_http_headers_single_value_header();
    internal static string get_net_http_httpmethod_format_error();
    internal static string get_net_http_invalid_enable_first();
    internal static string get_net_http_log_content_no_task_returned_copytoasync();
    internal static string get_net_http_log_content_null();
    internal static string get_net_http_log_content_offload_async();
    internal static string get_net_http_log_headers_invalid_quality();
    internal static string get_net_http_log_headers_invalid_value();
    internal static string get_net_http_log_headers_no_newlines();
    internal static string get_net_http_log_headers_wrong_email_format();
    internal static string get_net_http_message_not_success_statuscode();
    internal static string get_net_http_operation_started();
    internal static string get_net_http_parser_invalid_base64_string();
    internal static string get_net_http_parser_invalid_date_format();
    internal static string get_net_http_read_error();
    internal static string get_net_http_reasonphrase_format_error();
}
public class System.Net.Http.StreamContent : HttpContent {
    public StreamContent(Stream content);
    public StreamContent(Stream content, int bufferSize);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
}
internal class System.Net.Http.StreamToStreamCopy : object {
    public StreamToStreamCopy(Stream source, Stream destination, int bufferSize, bool disposeSource);
    public Task StartAsync();
}
public class System.Net.Http.StringContent : ByteArrayContent {
    public StringContent(string content);
    public StringContent(string content, Encoding encoding);
    public StringContent(string content, Encoding encoding, string mediaType);
}
internal class System.Net.Http.TRANSPORT_SETTING_ID : ValueType {
    public Guid Guid;
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
