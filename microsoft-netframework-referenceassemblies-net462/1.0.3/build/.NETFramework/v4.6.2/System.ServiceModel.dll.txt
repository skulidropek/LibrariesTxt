internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string EcmaPublicKeyFull;
    internal static string SilverlightPublicKey;
    internal static string SilverlightPublicKeyToken;
    internal static string SilverlightPublicKeyFull;
    internal static string SilverlightPlatformPublicKey;
    internal static string SilverlightPlatformPublicKeyToken;
    internal static string SilverlightPlatformPublicKeyFull;
    internal static string PlatformPublicKey;
    internal static string PlatformPublicKeyToken;
    internal static string PlatformPublicKeyFull;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string SystemDataOracleClient;
    internal static string System;
    internal static string SystemCore;
    internal static string SystemNumerics;
    internal static string SystemRuntimeRemoting;
    internal static string SystemThreadingTasksDataflow;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string MicrosoftPublicKeyToken;
    internal static string MicrosoftPublicKeyFull;
    internal static string SharedLibPublicKey;
    internal static string SharedLibPublicKeyToken;
    internal static string SharedLibPublicKeyFull;
    internal static string SystemComponentModelDataAnnotations;
    internal static string SystemConfiguration;
    internal static string SystemConfigurationInstall;
    internal static string SystemDeployment;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemNetHttp;
    internal static string SystemNetHttpWebRequest;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemRuntimeWindowsRuntime;
    internal static string SystemRuntimeWindowsRuntimeUIXaml;
    internal static string SystemSecurity;
    internal static string SystemServiceModelWeb;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebAbstractions;
    internal static string SystemWebDynamicData;
    internal static string SystemWebDynamicDataDesign;
    internal static string SystemWebEntityDesign;
    internal static string SystemWebExtensions;
    internal static string SystemWebExtensionsDesign;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebRouting;
    internal static string SystemWebServices;
    internal static string WindowsBase;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVisualStudioWindowsForms;
    internal static string VJSharpCodeProvider;
    internal static string ASPBrowserCapsPublicKey;
    internal static string ASPBrowserCapsFactory;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftVisualStudioWeb;
    internal static string MicrosoftWebDesign;
    internal static string MicrosoftVSDesignerMobile;
    internal static string MicrosoftJScript;
}
internal static class FXAssembly : object {
    internal static string Version;
}
[ComVisibleAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000001-0000-0000-C000-000000000046")]
internal interface IClassFactory {
    public abstract virtual object CreateInstance(object pUnkOuter, Guid riid);
    public abstract virtual void LockServer(bool fLock);
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
}
public class System.Collections.Generic.KeyedByTypeCollection`1 : KeyedCollection`2<Type, TItem> {
    public KeyedByTypeCollection`1(IEnumerable`1<TItem> items);
    public T Find();
    public T Remove();
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    protected virtual Type GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void SetItem(int index, TItem item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedCollection`1 : object {
    public int Count { get; }
    protected List`1<T> Items { get; }
    public object SyncRoot { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public SynchronizedCollection`1(object syncRoot);
    public SynchronizedCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedCollection`1(object syncRoot, T[] list);
    public sealed virtual int get_Count();
    protected List`1<T> get_Items();
    public object get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public abstract class System.Collections.Generic.SynchronizedKeyedCollection`2 : SynchronizedCollection`1<T> {
    public T Item { get; }
    protected IDictionary`2<K, T> Dictionary { get; }
    protected SynchronizedKeyedCollection`2(object syncRoot);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer, int dictionaryCreationThreshold);
    public T get_Item(K key);
    protected IDictionary`2<K, T> get_Dictionary();
    protected void ChangeItemKey(T item, K newKey);
    protected virtual void ClearItems();
    public bool Contains(K key);
    protected abstract virtual K GetKeyForItem(T item);
    protected virtual void InsertItem(int index, T item);
    public bool Remove(K key);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedReadOnlyCollection`1 : object {
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SynchronizedReadOnlyCollection`1(object syncRoot);
    public SynchronizedReadOnlyCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedReadOnlyCollection`1(object syncRoot, T[] list);
    internal SynchronizedReadOnlyCollection`1(object syncRoot, List`1<T> list, bool makeCopy);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
internal class System.Collections.ObjectModel.FreezableCollection`1 : Collection`1<T> {
    public bool IsFrozen { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public FreezableCollection`1(IList`1<T> list);
    public bool get_IsFrozen();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public void Freeze();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
}
public class System.IO.PipeException : IOException {
    public int ErrorCode { get; }
    public PipeException(string message);
    public PipeException(string message, int errorCode);
    public PipeException(string message, Exception inner);
    protected PipeException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
}
internal static class System.LocalAppContext : object {
    private static LocalAppContext();
    public static bool IsSwitchEnabled(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
internal static class System.Security.Cryptography.CngLightup : object {
    private static CngLightup();
    internal static RSA GetRSAPublicKey(X509Certificate2 cert);
    internal static RSA GetRSAPrivateKey(X509Certificate2 cert);
    internal static DSA GetDSAPublicKey(X509Certificate2 cert);
    internal static DSA GetDSAPrivateKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPrivateKey(X509Certificate2 cert);
    internal static Byte[] Pkcs1SignData(RSA rsa, Byte[] data, string hashAlgorithmName);
    internal static bool Pkcs1VerifyData(RSA rsa, Byte[] data, Byte[] signature, string hashAlgorithmName);
    internal static Byte[] Pkcs1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] Pkcs1Decrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Decrypt(RSA rsa, Byte[] data);
}
internal class System.ServiceModel.ActionMismatchAddressingException : ProtocolException {
    public string HttpActionHeader { get; }
    public string SoapActionHeader { get; }
    public ActionMismatchAddressingException(string message, string soapActionHeader, string httpActionHeader);
    protected ActionMismatchAddressingException(SerializationInfo info, StreamingContext context);
    public string get_HttpActionHeader();
    public string get_SoapActionHeader();
    internal Message ProvideFault(MessageVersion messageVersion);
}
public class System.ServiceModel.ActionNotSupportedException : CommunicationException {
    public ActionNotSupportedException(string message);
    public ActionNotSupportedException(string message, Exception innerException);
    protected ActionNotSupportedException(SerializationInfo info, StreamingContext context);
    internal Message ProvideFault(MessageVersion messageVersion);
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.Activation.AspNetCompatibilityRequirementsAttribute : Attribute {
    public AspNetCompatibilityRequirementsMode RequirementsMode { get; public set; }
    public AspNetCompatibilityRequirementsMode get_RequirementsMode();
    public void set_RequirementsMode(AspNetCompatibilityRequirementsMode value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
public enum System.ServiceModel.Activation.AspNetCompatibilityRequirementsMode : Enum {
    public int value__;
    public static AspNetCompatibilityRequirementsMode NotAllowed;
    public static AspNetCompatibilityRequirementsMode Allowed;
    public static AspNetCompatibilityRequirementsMode Required;
}
internal static class System.ServiceModel.Activation.AspNetCompatibilityRequirementsModeHelper : object {
    public static bool IsDefined(AspNetCompatibilityRequirementsMode x);
    public static void Validate(AspNetCompatibilityRequirementsMode value);
}
internal class System.ServiceModel.Activation.AspNetEnvironment : object {
    public static AspNetEnvironment Current { get; protected set; }
    public static bool Enabled { get; }
    public bool RequiresImpersonation { get; }
    public bool AspNetCompatibilityEnabled { get; }
    public string ConfigurationPath { get; }
    public bool IsConfigurationBased { get; }
    public string CurrentVirtualPath { get; }
    public string XamlFileBaseLocation { get; }
    public bool UsingIntegratedPipeline { get; }
    public string WebSocketVersion { get; }
    public bool IsWebSocketModuleLoaded { get; }
    public bool IsSimpleApplicationHost { get; }
    private static AspNetEnvironment();
    public static AspNetEnvironment get_Current();
    protected static void set_Current(AspNetEnvironment value);
    public static bool get_Enabled();
    public bool get_RequiresImpersonation();
    public virtual bool get_AspNetCompatibilityEnabled();
    public virtual string get_ConfigurationPath();
    public virtual bool get_IsConfigurationBased();
    public virtual string get_CurrentVirtualPath();
    public virtual string get_XamlFileBaseLocation();
    public virtual bool get_UsingIntegratedPipeline();
    public virtual string get_WebSocketVersion();
    public bool get_IsWebSocketModuleLoaded();
    public virtual void AddHostingBehavior(ServiceHostBase serviceHost, ServiceDescription description);
    public virtual bool IsWindowsAuthenticationConfigured();
    public virtual List`1<Uri> GetBaseAddresses(Uri addressTemplate);
    public virtual bool IsWebConfigAboveApplication(object configHostingContext);
    public virtual void EnsureCompatibilityRequirements(ServiceDescription description);
    public virtual bool TryGetFullVirtualPath(String& virtualPath);
    public virtual string GetAnnotationFromHost(ServiceHostBase host);
    public virtual void EnsureAllReferencedAssemblyLoaded();
    public virtual BaseUriWithWildcard GetBaseUri(string transportScheme, Uri listenUri);
    public virtual void ValidateHttpSettings(string virtualPath, bool isMetadataListener, bool usingDefaultSpnList, AuthenticationSchemes& supportedSchemes, ExtendedProtectionPolicy& extendedProtectionPolicy, String& realm);
    public virtual bool ValidateHttpsSettings(string virtualPath, Boolean& requireClientCertificate);
    public virtual void ProcessNotMatchedEndpointAddress(Uri uri, string endpointName);
    public virtual void ValidateCompatibilityRequirements(AspNetCompatibilityRequirementsMode compatibilityMode);
    public virtual IAspNetMessageProperty GetHostingProperty(Message message);
    public virtual IAspNetMessageProperty GetHostingProperty(Message message, bool removeFromMessage);
    public virtual void PrepareMessageForDispatch(Message message);
    public virtual void ApplyHostedContext(TransportChannelListener listener, BindingContext context);
    internal virtual void AddMetadataBindingParameters(Uri listenUri, KeyedByTypeCollection`1<IServiceBehavior> serviceBehaviors, BindingParameterCollection bindingParameters);
    internal virtual bool IsMetadataListener(BindingParameterCollection bindingParameters);
    public virtual void IncrementBusyCount();
    public virtual void DecrementBusyCount();
    public virtual bool TraceIncrementBusyCountIsEnabled();
    public virtual bool TraceDecrementBusyCountIsEnabled();
    public virtual void TraceIncrementBusyCount(string data);
    public virtual void TraceDecrementBusyCount(string data);
    public virtual object GetConfigurationSection(string sectionPath);
    [SecurityCriticalAttribute]
public virtual object UnsafeGetConfigurationSection(string sectionPath);
    public virtual AuthenticationSchemes GetAuthenticationSchemes(Uri baseAddress);
    public virtual bool get_IsSimpleApplicationHost();
    public virtual bool IsWithinApp(string absoluteVirtualPath);
    internal static bool IsApplicationDomainHosted();
}
internal static class System.ServiceModel.Activation.Configuration.ConfigurationStrings : object {
    internal static string SectionGroupName;
    internal static string IIS_IUSRSSid;
    internal static string DiagnosticSectionName;
    internal static string NetTcpSectionName;
    internal static string NetPipeSectionName;
    internal static string AllowAccounts;
    internal static string Enabled;
    internal static string ListenBacklog;
    internal static string MaxPendingAccepts;
    internal static string MaxPendingConnections;
    internal static string PerformanceCountersEnabled;
    internal static string ReceiveTimeout;
    internal static string SecurityIdentifier;
    internal static string TeredoEnabled;
    internal static string TimeSpanOneTick;
    internal static string TimeSpanZero;
    internal static string DiagnosticSectionPath { get; }
    internal static string NetTcpSectionPath { get; }
    internal static string NetPipeSectionPath { get; }
    internal static string get_DiagnosticSectionPath();
    internal static string get_NetTcpSectionPath();
    internal static string get_NetPipeSectionPath();
}
public class System.ServiceModel.Activation.Configuration.DiagnosticSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("performanceCountersEnabled")]
public bool PerformanceCountersEnabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal static DiagnosticSection GetSection();
    public bool get_PerformanceCountersEnabled();
    public void set_PerformanceCountersEnabled(bool value);
}
public class System.ServiceModel.Activation.Configuration.NetPipeSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("allowAccounts")]
public SecurityIdentifierElementCollection AllowAccounts { get; }
    [ConfigurationPropertyAttribute("maxPendingConnections")]
[IntegerValidatorAttribute]
public int MaxPendingConnections { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingAccepts")]
[IntegerValidatorAttribute]
public int MaxPendingAccepts { get; public set; }
    [ConfigurationPropertyAttribute("receiveTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReceiveTimeout { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SecurityIdentifierElementCollection get_AllowAccounts();
    internal static NetPipeSection GetSection();
    protected virtual void InitializeDefault();
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    public TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
}
public class System.ServiceModel.Activation.Configuration.NetTcpSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("allowAccounts")]
public SecurityIdentifierElementCollection AllowAccounts { get; }
    [ConfigurationPropertyAttribute("listenBacklog")]
[IntegerValidatorAttribute]
public int ListenBacklog { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingConnections")]
[IntegerValidatorAttribute]
public int MaxPendingConnections { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingAccepts")]
[IntegerValidatorAttribute]
public int MaxPendingAccepts { get; public set; }
    [ConfigurationPropertyAttribute("receiveTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReceiveTimeout { get; public set; }
    [ConfigurationPropertyAttribute("teredoEnabled")]
public bool TeredoEnabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SecurityIdentifierElementCollection get_AllowAccounts();
    internal static NetTcpSection GetSection();
    protected virtual void InitializeDefault();
    public int get_ListenBacklog();
    public void set_ListenBacklog(int value);
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    public TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public bool get_TeredoEnabled();
    public void set_TeredoEnabled(bool value);
}
internal class System.ServiceModel.Activation.Configuration.SecurityIdentifierConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Activation.Configuration.SecurityIdentifierElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("securityIdentifier")]
[TypeConverterAttribute("System.ServiceModel.Activation.Configuration.SecurityIdentifierConverter")]
public SecurityIdentifier SecurityIdentifier { get; public set; }
    public SecurityIdentifierElement(SecurityIdentifier sid);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SecurityIdentifier get_SecurityIdentifier();
    public void set_SecurityIdentifier(SecurityIdentifier value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Activation.Configuration.SecurityIdentifierElement")]
public class System.ServiceModel.Activation.Configuration.SecurityIdentifierElementCollection : ServiceModelConfigurationElementCollection`1<SecurityIdentifierElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
    internal void SetDefaultIdentifiers();
}
public class System.ServiceModel.Activation.Configuration.ServiceModelActivationSectionGroup : ConfigurationSectionGroup {
    public DiagnosticSection Diagnostics { get; }
    public NetPipeSection NetPipe { get; }
    public NetTcpSection NetTcp { get; }
    public DiagnosticSection get_Diagnostics();
    public static ServiceModelActivationSectionGroup GetSectionGroup(Configuration config);
    public NetPipeSection get_NetPipe();
    public NetTcpSection get_NetTcp();
}
[DataContractAttribute]
[KnownTypeAttribute("System.ServiceModel.Activation.TcpDuplicateContext")]
[KnownTypeAttribute("System.ServiceModel.Activation.NamedPipeDuplicateContext")]
internal class System.ServiceModel.Activation.DuplicateContext : object {
    public Uri Via { get; }
    public Byte[] ReadData { get; }
    protected DuplicateContext(Uri via, Byte[] readData);
    public Uri get_Via();
    public Byte[] get_ReadData();
}
internal interface System.ServiceModel.Activation.IAspNetMessageProperty {
    public Uri OriginalRequestUri { get; }
    public abstract virtual Uri get_OriginalRequestUri();
    public abstract virtual IDisposable ApplyIntegrationContext();
    public abstract virtual IDisposable Impersonate();
    public abstract virtual void Close();
}
internal interface System.ServiceModel.Activation.IConnectionDuplicator {
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginDuplicate(DuplicateContext duplicateContext, AsyncCallback callback, object state);
    public abstract virtual void EndDuplicate(IAsyncResult result);
}
[ServiceContractAttribute]
internal interface System.ServiceModel.Activation.IConnectionRegister {
    [OperationContractAttribute]
public abstract virtual ListenerExceptionStatus Register(Version version, int pid, BaseUriWithWildcard path, int queueId, Guid token, string eventName);
    [OperationContractAttribute]
public abstract virtual bool ValidateUriRoute(Uri uri, IPAddress address, int port);
    [OperationContractAttribute]
public abstract virtual void Unregister();
}
[ServiceContractAttribute]
internal interface System.ServiceModel.Activation.IConnectionRegisterAsync {
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginValidateUriRoute(Uri uri, IPAddress address, int port, AsyncCallback callback, object asyncState);
    public abstract virtual bool EndValidateUriRoute(IAsyncResult result);
}
internal static class System.ServiceModel.Activation.Iis7Helper : object {
    internal static int IisVersion { get; }
    internal static bool IsIis7 { get; }
    private static Iis7Helper();
    internal static int get_IisVersion();
    internal static bool get_IsIis7();
}
[DataContractAttribute]
internal class System.ServiceModel.Activation.ListenerChannelContext : object {
    internal string AppKey { get; }
    internal int ListenerChannelId { get; }
    internal Guid Token { get; }
    internal ListenerChannelContext(string appKey, int listenerChannelId, Guid token);
    internal string get_AppKey();
    internal int get_ListenerChannelId();
    internal Guid get_Token();
    public static ListenerChannelContext Hydrate(Byte[] blob);
    public Byte[] Dehydrate();
}
internal static class System.ServiceModel.Activation.ListenerConstants : object {
    public static int DefaultListenBacklog;
    public static int DefaultMaxPendingAccepts;
    public static int DefaultMaxPendingConnections;
    public static string DefaultReceiveTimeoutString;
    public static bool DefaultTeredoEnabled;
    public static bool DefaultPerformanceCountersEnabled;
    public static int RegistrationMaxConcurrentSessions;
    public static int RegistrationMaxReceivedMessageSize;
    public static TimeSpan RegistrationCloseTimeout;
    public static int SharedConnectionBufferSize;
    public static int SharedMaxDrainSize;
    public static TimeSpan SharedSendTimeout;
    public static int SharedMaxContentTypeSize;
    public static int MaxRetries;
    public static int MaxUriSize;
    public static TimeSpan ServiceStartTimeout;
    public static int ServiceStopTimeout;
    public static TimeSpan WasConnectTimeout;
    public static string GlobalPrefix;
    public static string MsmqActivationServiceName;
    public static string NamedPipeActivationServiceName;
    public static string NamedPipeSharedMemoryName;
    public static string TcpActivationServiceName;
    public static string TcpPortSharingServiceName;
    public static string TcpSharedMemoryName;
    private static ListenerConstants();
}
internal enum System.ServiceModel.Activation.ListenerExceptionStatus : Enum {
    public int value__;
    public static ListenerExceptionStatus Success;
    public static ListenerExceptionStatus PathTooLong;
    public static ListenerExceptionStatus RegistrationQuotaExceeded;
    public static ListenerExceptionStatus ProtocolUnsupported;
    public static ListenerExceptionStatus ConflictingRegistration;
    public static ListenerExceptionStatus FailedToListen;
    public static ListenerExceptionStatus VersionUnsupported;
    public static ListenerExceptionStatus InvalidArgument;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.ServiceModel.Activation.ListenerUnsafeNativeMethods : object {
    internal static int OWNER_SECURITY_INFORMATION;
    internal static int DACL_SECURITY_INFORMATION;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    internal static int ERROR_SERVICE_ALREADY_RUNNING;
    internal static int PROCESS_QUERY_INFORMATION;
    internal static int PROCESS_DUP_HANDLE;
    internal static int READ_CONTROL;
    internal static int TOKEN_QUERY;
    internal static int WRITE_DAC;
    internal static int TOKEN_ADJUST_PRIVILEGES;
    internal static int SC_MANAGER_CONNECT;
    internal static int SC_STATUS_PROCESS_INFO;
    internal static int SERVICE_QUERY_CONFIG;
    internal static int SERVICE_QUERY_STATUS;
    internal static int SERVICE_RUNNING;
    internal static int SERVICE_START;
    internal static int SERVICE_START_PENDING;
    internal static bool IsDebuggerPresent();
    internal static void DebugBreak();
    internal static bool AdjustTokenPrivileges(SafeCloseHandle tokenHandle, bool disableAllPrivileges, TOKEN_PRIVILEGES* newState, int bufferLength, IntPtr previousState, IntPtr returnLength);
    internal static bool LookupAccountName(string systemName, string accountName, Byte[] sid, UInt32& cbSid, StringBuilder referencedDomainName, UInt32& cchReferencedDomainName, Int16& peUse);
    internal static bool LookupPrivilegeValue(IntPtr lpSystemName, string lpName, LUID* lpLuid);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CloseServiceHandle(IntPtr handle);
    internal static bool GetKernelObjectSecurity(SafeCloseHandle handle, int securityInformation, Byte[] pSecurityDescriptor, int nLength, Int32& lpnLengthNeeded);
    internal static bool GetTokenInformation(SafeCloseHandle tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, Byte[] pTokenInformation, int tokenInformationLength, Int32& returnLength);
    internal static SafeCloseHandle OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    internal static IntPtr GetCurrentProcess();
    internal static bool OpenProcessToken(SafeCloseHandle processHandle, int desiredAccess, SafeCloseHandle& tokenHandle);
    internal static SafeServiceHandle OpenSCManager(string lpMachineName, string lpDatabaseName, int dwDesiredAccess);
    internal static SafeServiceHandle OpenService(SafeServiceHandle hSCManager, string lpServiceName, int dwDesiredAccess);
    internal static bool QueryServiceConfig(SafeServiceHandle hService, Byte[] pServiceConfig, int cbBufSize, Int32& pcbBytesNeeded);
    internal static bool QueryServiceStatus(SafeServiceHandle hService, SERVICE_STATUS_PROCESS& status);
    internal static bool QueryServiceStatusEx(SafeServiceHandle hService, int InfoLevel, Byte[] pBuffer, int cbBufSize, Int32& pcbBytesNeeded);
    internal static bool SetKernelObjectSecurity(SafeCloseHandle handle, int securityInformation, Byte[] pSecurityDescriptor);
    internal static bool StartService(SafeServiceHandle hSCManager, int dwNumServiceArgs, String[] lpServiceArgVectors);
}
[DataContractAttribute]
internal class System.ServiceModel.Activation.NamedPipeDuplicateContext : DuplicateContext {
    public IntPtr Handle { get; }
    public NamedPipeDuplicateContext(IntPtr handle, Uri via, Byte[] readData);
    public IntPtr get_Handle();
}
internal class System.ServiceModel.Activation.SafeCloseHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeCloseHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Activation.SafeServiceHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public abstract class System.ServiceModel.Activation.ServiceHostFactoryBase : object {
    public abstract virtual ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses);
}
internal class System.ServiceModel.Activation.SharedMemory : object {
    [SecuritySafeCriticalAttribute]
public static SharedMemory Create(string name, Guid content, List`1<SecurityIdentifier> allowedSids);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public static string Read(string name);
    [SecuritySafeCriticalAttribute]
public static bool Read(string name, String& content);
}
internal static class System.ServiceModel.Activation.SystemWebHelper : object {
    internal static RoleProvider GetDefaultRoleProvider();
    internal static RoleProvider GetRoleProvider(string roleProviderName);
    internal static MembershipProvider GetMembershipProvider();
    internal static MembershipProvider GetMembershipProvider(string membershipProviderName);
    internal static bool IsWebConfigAboveApplication(object configHostingContext);
}
[DataContractAttribute]
[KnownTypeAttribute("System.Net.IPEndPoint")]
internal class System.ServiceModel.Activation.TcpDuplicateContext : DuplicateContext {
    public SocketInformation SocketInformation { get; }
    public TcpDuplicateContext(SocketInformation socketInformation, Uri via, Byte[] readData);
    public SocketInformation get_SocketInformation();
}
internal static class System.ServiceModel.Activation.Utility : object {
    internal static Uri FormatListenerEndpoint(string serviceName, string listenerEndPoint);
    internal static void AddRightGrantedToAccounts(List`1<SecurityIdentifier> accounts, int right, bool onProcess);
    internal static void AddRightGrantedToAccount(SecurityIdentifier account, int right);
    internal static void RemoveRightGrantedToAccount(SecurityIdentifier account, int right);
    [SecuritySafeCriticalAttribute]
internal static void KeepOnlyPrivilegeInProcess(string privilege);
    internal static SecurityIdentifier GetWindowsServiceSid(string name);
    internal static int GetPidForService(string serviceName);
    [SecuritySafeCriticalAttribute]
internal static SecurityIdentifier GetLogonSidForPid(int pid);
    [SecuritySafeCriticalAttribute]
internal static SecurityIdentifier GetUserSidForPid(int pid);
}
public class System.ServiceModel.Activation.VirtualPathExtension : object {
    public string ApplicationVirtualPath { get; private set; }
    public string SiteName { get; private set; }
    public string VirtualPath { get; private set; }
    internal VirtualPathExtension(string virtualPath, string applicationVirtualPath, string siteName);
    [CompilerGeneratedAttribute]
public string get_ApplicationVirtualPath();
    [CompilerGeneratedAttribute]
private void set_ApplicationVirtualPath(string value);
    [CompilerGeneratedAttribute]
public string get_SiteName();
    [CompilerGeneratedAttribute]
private void set_SiteName(string value);
    [CompilerGeneratedAttribute]
public string get_VirtualPath();
    [CompilerGeneratedAttribute]
private void set_VirtualPath(string value);
    public sealed virtual void Attach(ServiceHostBase owner);
    public sealed virtual void Detach(ServiceHostBase owner);
}
internal class System.ServiceModel.ActivityIdFlowDictionary : object {
    public XmlDictionaryString ActivityId;
    public XmlDictionaryString ActivityIdNamespace;
    public ActivityIdFlowDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.ActivityIdFlowStrings : object {
    public static string ActivityId;
    public static string ActivityIdNamespace;
}
public class System.ServiceModel.AddressAccessDeniedException : CommunicationException {
    public AddressAccessDeniedException(string message);
    public AddressAccessDeniedException(string message, Exception innerException);
    protected AddressAccessDeniedException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.AddressAlreadyInUseException : CommunicationException {
    public AddressAlreadyInUseException(string message);
    public AddressAlreadyInUseException(string message, Exception innerException);
    protected AddressAlreadyInUseException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.AddressFilterMode : Enum {
    public int value__;
    public static AddressFilterMode Exact;
    public static AddressFilterMode Prefix;
    public static AddressFilterMode Any;
}
internal static class System.ServiceModel.AddressFilterModeHelper : object {
    public static bool IsDefined(AddressFilterMode x);
}
internal class System.ServiceModel.Addressing10Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Anonymous;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString ReplyRelationship;
    public XmlDictionaryString NoneAddress;
    public XmlDictionaryString Metadata;
    public Addressing10Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Addressing10Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string ReplyRelationship;
    public static string NoneAddress;
    public static string Metadata;
    public static string MessageAddressingHeaderRequired;
    public static string InvalidAddressingHeader;
    public static string InvalidCardinality;
    public static string ActionMismatch;
    public static string ProblemHeaderQName;
    public static string FaultDetail;
    public static string DefaultFaultAction;
}
internal class System.ServiceModel.Addressing200408Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Anonymous;
    public XmlDictionaryString FaultAction;
    public Addressing200408Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Addressing200408Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string InvalidMessageInformationHeader;
    public static string MessageInformationHeaderRequired;
    public static string DefaultFaultAction;
}
internal class System.ServiceModel.AddressingDictionary : object {
    public XmlDictionaryString Action;
    public XmlDictionaryString To;
    public XmlDictionaryString RelatesTo;
    public XmlDictionaryString MessageId;
    public XmlDictionaryString Address;
    public XmlDictionaryString ReplyTo;
    public XmlDictionaryString Empty;
    public XmlDictionaryString From;
    public XmlDictionaryString FaultTo;
    public XmlDictionaryString EndpointReference;
    public XmlDictionaryString PortType;
    public XmlDictionaryString ServiceName;
    public XmlDictionaryString PortName;
    public XmlDictionaryString ReferenceProperties;
    public XmlDictionaryString RelationshipType;
    public XmlDictionaryString Reply;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString IdentityExtensionNamespace;
    public XmlDictionaryString Identity;
    public XmlDictionaryString Spn;
    public XmlDictionaryString Upn;
    public XmlDictionaryString Rsa;
    public XmlDictionaryString Dns;
    public XmlDictionaryString X509v3Certificate;
    public XmlDictionaryString ReferenceParameters;
    public XmlDictionaryString IsReferenceParameter;
    public AddressingDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.AddressingNoneDictionary : object {
    public XmlDictionaryString Namespace;
    public AddressingNoneDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.AddressingNoneStrings : object {
    public static string Namespace;
}
internal static class System.ServiceModel.AddressingStrings : object {
    public static string Action;
    public static string To;
    public static string RelatesTo;
    public static string MessageId;
    public static string Address;
    public static string ReplyTo;
    public static string Empty;
    public static string From;
    public static string FaultTo;
    public static string EndpointReference;
    public static string PortType;
    public static string ServiceName;
    public static string PortName;
    public static string ReferenceProperties;
    public static string RelationshipType;
    public static string Reply;
    public static string Prefix;
    public static string IdentityExtensionNamespace;
    public static string Identity;
    public static string Spn;
    public static string Upn;
    public static string Rsa;
    public static string Dns;
    public static string X509v3Certificate;
    public static string ReferenceParameters;
    public static string IsReferenceParameter;
    public static string EndpointUnavailable;
    public static string ActionNotSupported;
    public static string EndpointReferenceType;
    public static string Request;
    public static string DestinationUnreachable;
    public static string AnonymousUri;
    public static string NoneUri;
    public static string IndigoNamespace;
    public static string ChannelTerminated;
}
internal static class System.ServiceModel.Administration.AdministrationHelpers : object {
    public static Type GetServiceModelBaseType(Type type);
}
internal static class System.ServiceModel.Administration.AdministrationStrings : object {
    internal static string AcknowledgementInterval;
    internal static string Action;
    internal static string Address;
    internal static string AddressFilterMode;
    internal static string AddressHeaders;
    internal static string AllowAnonymous;
    internal static string AllowCookies;
    internal static string AllowedImpersonationLevel;
    internal static string AllowInsecureTransport;
    internal static string AllowNtlm;
    internal static string AppDomainId;
    internal static string AppDomainInfo;
    internal static string AsyncPattern;
    internal static string AuditLogLocation;
    internal static string AuthenticationMode;
    internal static string AuthenticationScheme;
    internal static string AutoDisposeParameters;
    internal static string AutomaticSessionShutdown;
    internal static string BaseAddresses;
    internal static string Behaviors;
    internal static string Binding;
    internal static string BindingElements;
    internal static string BypassProxyOnLocal;
    internal static string CacheIssuedTokens;
    internal static string CallbackContract;
    internal static string Channel;
    internal static string ChannelInitializationTimeout;
    internal static string ChannelPoolSettings;
    internal static string Channels;
    internal static string ClientBaseAddress;
    internal static string ClientCertificate;
    internal static string CloseTimeout;
    internal static string CompressionFormat;
    internal static string ConcurrencyMode;
    internal static string ConfigurationName;
    internal static string ConnectionBufferSize;
    internal static string ConnectionPoolSettings;
    internal static string ContextMode;
    internal static string Contract;
    internal static string ContractName;
    internal static string CounterInstanceName;
    internal static string CustomChannelBinding;
    internal static string CustomDeadLetterQueue;
    internal static string CustomServiceNames;
    internal static string Custom;
    internal static string DeadLetterQueue;
    internal static string DecompressionEnabled;
    internal static string DefaultAlgorithmSuite;
    internal static string Description;
    internal static string DetectReplays;
    internal static string DistinguishedName;
    internal static string Durable;
    internal static string GenerateRequestSignatureConfirmation;
    internal static string EnableKeyDerivation;
    internal static string EnableUnsecuredResponse;
    internal static string Endpoint;
    internal static string EndpointRefs;
    internal static string Endpoints;
    internal static string Encoding;
    internal static string EnsureOrderedDispatch;
    internal static string ExactlyOnce;
    internal static string ExtendedProtectionPolicy;
    internal static string Extensions;
    internal static string ExternalMetadataLocation;
    internal static string FlowControlEnabled;
    internal static string FullName;
    internal static string GetOperationCounterInstanceName;
    internal static string GetSupportedAttributes;
    internal static string GroupName;
    internal static string HostNameComparisonMode;
    internal static string HttpDigest;
    internal static string HttpGetEnabled;
    internal static string HttpGetUrl;
    internal static string HttpHelpPageUrl;
    internal static string HttpHelpPageEnabled;
    internal static string HttpsGetEnabled;
    internal static string HttpsGetUrl;
    internal static string HttpsHelpPageUrl;
    internal static string HttpsHelpPageEnabled;
    internal static string Identity;
    internal static string IdleTimeout;
    internal static string IgnoreExtensionDataObject;
    internal static string ImpersonateCallerForAllOperations;
    internal static string ImpersonateOnSerializingReply;
    internal static string Impersonation;
    internal static string InactivityTimeout;
    internal static string IncludeTimestamp;
    internal static string IncludeExceptionDetailInFaults;
    internal static string SupportFaults;
    internal static string IndigoAppName;
    internal static string IndigoNamespace;
    internal static string InitializeData;
    internal static string InstanceContextMode;
    internal static string IsCallback;
    internal static string IsDefault;
    internal static string IsInitiating;
    internal static string IsOneWay;
    internal static string IssuedCookieLifetime;
    internal static string IssuedTokenAuthentication;
    internal static string IssuedToken;
    internal static string IssuedTokenParameters;
    internal static string IssuedTransitionTokenLifetime;
    internal static string IsTerminating;
    internal static string KeepAliveEnabled;
    internal static string KeyEntropyMode;
    internal static string LeaseTimeout;
    internal static string ListenBacklog;
    internal static string ListenIPAddress;
    internal static string ListenUri;
    internal static string LocalAddress;
    internal static string Localhost;
    internal static string LocalServiceSecuritySettings;
    internal static string LogMalformedMessages;
    internal static string LogMessagesAtServiceLevel;
    internal static string LogMessagesAtTransportLevel;
    internal static string ManualAddressing;
    internal static string MaxArrayLength;
    internal static string MaxBatchSize;
    internal static string MaxBufferPoolSize;
    internal static string MaxBufferSize;
    internal static string MaxBytesPerRead;
    internal static string MaxCachedCookies;
    internal static string MaxClockSkew;
    internal static string MaxConcurrentCalls;
    internal static string MaxConcurrentInstances;
    internal static string MaxConcurrentSessions;
    internal static string MaxPendingConnections;
    internal static string MaxDepth;
    internal static string MaxPendingSessions;
    internal static string MaxAcceptedChannels;
    internal static string MaxItemsInObjectGraph;
    internal static string MaxReceivedMessageSize;
    internal static string MaxNameTableCharCount;
    internal static string MaxOutboundChannelsPerEndpoint;
    internal static string MaxOutboundConnectionsPerEndpoint;
    internal static string MaxOutputDelay;
    internal static string MaxPendingAccepts;
    internal static string MaxPendingChannels;
    internal static string MaxReadPoolSize;
    internal static string MaxPoolSize;
    internal static string MaxRetryCount;
    internal static string MaxRetryCycles;
    internal static string MaxSessionSize;
    internal static string MaxStringContentLength;
    internal static string MaxStatefulNegotiations;
    internal static string MaxTransferWindowSize;
    internal static string MaxWritePoolSize;
    internal static string MessageAuthenticationAuditLevel;
    internal static string MessageLoggingTraceListeners;
    internal static string MessageProtectionOrder;
    internal static string MessageSecurityVersion;
    internal static string MessageVersion;
    internal static string Metadata;
    internal static string MetadataExporter;
    internal static string MetadataExportInfo;
    internal static string MethodSignature;
    internal static string MsmqAuthenticationMode;
    internal static string Name;
    internal static string NamedPipeConnectionPoolSettings;
    internal static string Namespace;
    internal static string NegotiationTimeout;
    internal static string Opened;
    internal static string OpenTimeout;
    internal static string Operation;
    internal static string Operations;
    internal static string Ordered;
    internal static string PacketRoutable;
    internal static string ParameterTypes;
    internal static string Password;
    internal static string Peer;
    internal static string PeerSecurityMode;
    internal static string PeerSecuritySettings;
    internal static string PeerTransportCredentialType;
    internal static string PeerTransportSecuritySettings;
    internal static string PeerResolver;
    internal static string PerformanceCounters;
    internal static string PolicyEnforcement;
    internal static string PolicyVersion;
    internal static string Port;
    internal static string PortSharingEnabled;
    internal static string PrincipalPermissionMode;
    internal static string PrivacyNoticeVersion;
    internal static string ProcessId;
    internal static string ProtectionLevel;
    internal static string ProtectionScenario;
    internal static string ProxyAddress;
    internal static string ProxyAuthenticationScheme;
    internal static string QueuedDeliveryRequirements;
    internal static string QueueTransferProtocol;
    internal static string ReaderQuotas;
    internal static string Realm;
    internal static string ReceiveContextEnabled;
    internal static string ReceiveErrorHandling;
    internal static string ReceiveRetryCount;
    internal static string ReceiveTimeout;
    internal static string ReconnectTransportOnFailure;
    internal static string ReferralPolicy;
    internal static string ReleaseInstanceMode;
    internal static string ReleaseServiceInstanceOnTransactionComplete;
    internal static string ReliableMessagingVersion;
    internal static string RemoteAddress;
    internal static string RemoteEndpoint;
    internal static string ReplayCacheSize;
    internal static string ReplayWindow;
    internal static string ReplyAction;
    internal static string RequireClientCertificate;
    internal static string RequireOrderedDelivery;
    internal static string RequireSignatureConfirmation;
    internal static string RequirementsMode;
    internal static string ResolverMode;
    internal static string RetryCycleDelay;
    internal static string ReturnType;
    internal static string RoleProvider;
    internal static string Scheme;
    internal static string SecureConversationAuthentication;
    internal static string SecurityHeaderLayout;
    internal static string Security;
    internal static string SecurityMode;
    internal static string SecurityStateEncoder;
    internal static string SendTimeout;
    internal static string SerializationFormat;
    internal static string Service;
    internal static string ServiceAdmin;
    internal static string ServiceAppDomain;
    internal static string ServiceAuthorizationAuditLevel;
    internal static string ServiceAuthorizationManager;
    internal static string ServiceCertificate;
    internal static string ServiceConfigPath;
    internal static string ServiceModelTraceListeners;
    internal static string ServiceToEndpointAssociation;
    internal static string ServiceType;
    internal static string SessionMode;
    internal static string SessionId;
    internal static string SessionKeyRenewalInterval;
    internal static string SessionKeyRolloverInterval;
    internal static string Style;
    internal static string SupportInteractive;
    internal static string SuppressAuditFailure;
    internal static string TargetContract;
    internal static string TcpConnectionPoolSettings;
    internal static string TeredoEnabled;
    internal static string TimestampValidityDuration;
    internal static string TimeToLive;
    internal static string TraceLevel;
    internal static string TraceListener;
    internal static string TraceListenerArgument;
    internal static string TraceListenerArguments;
    internal static string Transport;
    internal static string TransactionAutoComplete;
    internal static string TransactionAutoCompleteOnSessionClose;
    internal static string TransactionFlowOption;
    internal static string TransactionIsolationLevel;
    internal static string TransactionProtocol;
    internal static string TransactionFlow;
    internal static string AllowWildcardAction;
    internal static string TransactionScopeRequired;
    internal static string TransactionTimeout;
    internal static string TransferMode;
    internal static string Type;
    internal static string UnsafeConnectionNtlmAuthentication;
    internal static string Url;
    internal static string Uri;
    internal static string Use;
    internal static string UseActiveDirectory;
    internal static string UseDefaultWebProxy;
    internal static string UseMsmqTracing;
    internal static string UserName;
    internal static string UserNameAuthentication;
    internal static string UseSourceJournal;
    internal static string UseSynchronizationContext;
    internal static string ValidateMustUnderstand;
    internal static string ValidationMode;
    internal static string ValidityDuration;
    internal static string Value;
    internal static string VirtualPath;
    internal static string WindowsAuthentication;
    internal static string Windows;
    internal static string XmlDictionaryReaderQuotas;
}
internal class System.ServiceModel.Administration.AppDomainInfo : object {
    public int Id { get; }
    public Guid InstanceId { get; }
    public string MachineName { get; }
    public string Name { get; }
    public bool IsDefaultAppDomain { get; }
    public int ProcessId { get; }
    public string ProcessName { get; }
    internal static AppDomainInfo Current { get; }
    private static AppDomainInfo();
    public int get_Id();
    public Guid get_InstanceId();
    public string get_MachineName();
    public string get_Name();
    public bool get_IsDefaultAppDomain();
    public int get_ProcessId();
    public string get_ProcessName();
    internal static AppDomainInfo get_Current();
}
internal class System.ServiceModel.Administration.AppDomainInstanceProvider : ProviderBase {
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance instance);
    internal static string GetReference();
    internal static void FillAppDomainInfo(IWmiInstance instance);
    [SecuritySafeCriticalAttribute]
private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.PutInstance(IWmiInstance instance);
}
internal class System.ServiceModel.Administration.ContractInstanceProvider : ProviderBase {
    private static ContractInstanceProvider();
    internal static string ContractReference(string contractName);
    internal static void RegisterContract(ContractDescription contract);
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance contract);
}
internal class System.ServiceModel.Administration.EndpointInfo : object {
    public Uri Address { get; }
    public Uri ListenUri { get; }
    public KeyedByTypeCollection`1<IEndpointBehavior> Behaviors { get; }
    public ContractDescription Contract { get; }
    public CustomBinding Binding { get; }
    public ServiceEndpoint Endpoint { get; }
    public AddressHeaderCollection Headers { get; }
    public EndpointIdentity Identity { get; }
    public string Name { get; }
    public string ServiceName { get; }
    internal EndpointInfo(ServiceEndpoint endpoint, string serviceName);
    public Uri get_Address();
    public Uri get_ListenUri();
    public KeyedByTypeCollection`1<IEndpointBehavior> get_Behaviors();
    public ContractDescription get_Contract();
    public CustomBinding get_Binding();
    public ServiceEndpoint get_Endpoint();
    public AddressHeaderCollection get_Headers();
    public EndpointIdentity get_Identity();
    public string get_Name();
    public string get_ServiceName();
}
internal class System.ServiceModel.Administration.EndpointInfoCollection : Collection`1<EndpointInfo> {
    internal EndpointInfoCollection(ServiceEndpointCollection endpoints, string serviceName);
}
internal class System.ServiceModel.Administration.EndpointInstanceProvider : ProviderBase {
    internal static string EndpointReference(Uri uri, string contractName);
    internal static string EndpointReference(string address, string contractName, bool local);
    internal static void FillEndpointInfo(EndpointInfo endpoint, IWmiInstance instance);
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance instance);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.InvokeMethod(IWmiMethodContext method);
}
internal interface System.ServiceModel.Administration.IWmiInstance {
    public abstract virtual IWmiInstance NewInstance(string className);
    public abstract virtual object GetProperty(string name);
    public abstract virtual void SetProperty(string name, object value);
}
internal interface System.ServiceModel.Administration.IWmiInstanceProvider {
    public abstract virtual string GetInstanceType();
    public abstract virtual void FillInstance(IWmiInstance wmiInstance);
}
internal interface System.ServiceModel.Administration.IWmiInstances {
    public abstract virtual IWmiInstance NewInstance(string className);
    public abstract virtual void AddInstance(IWmiInstance inst);
}
internal interface System.ServiceModel.Administration.IWmiMethodContext {
    public string MethodName { get; }
    public IWmiInstance Instance { get; }
    unknown object ReturnParameter {public set; }
    public abstract virtual string get_MethodName();
    public abstract virtual IWmiInstance get_Instance();
    public abstract virtual void set_ReturnParameter(object value);
    public abstract virtual object GetParameter(string name);
    public abstract virtual void SetParameter(string name, object value);
}
internal interface System.ServiceModel.Administration.IWmiProvider {
    public abstract virtual void EnumInstances(IWmiInstances instances);
    public abstract virtual bool GetInstance(IWmiInstance instance);
    public abstract virtual bool PutInstance(IWmiInstance instance);
    public abstract virtual bool DeleteInstance(IWmiInstance instance);
    public abstract virtual bool InvokeMethod(IWmiMethodContext method);
}
internal class System.ServiceModel.Administration.ManagementExtension : object {
    internal static bool IsActivated { get; }
    internal static bool IsEnabled { get; }
    internal static ICollection`1<ServiceHostBase> Services { get; }
    private static ManagementExtension();
    internal static bool get_IsActivated();
    internal static bool get_IsEnabled();
    internal static ICollection`1<ServiceHostBase> get_Services();
    internal static DateTime GetTimeOpened(ServiceHostBase service);
    public static void OnServiceOpened(ServiceHostBase serviceHostBase);
    public static void OnServiceClosing(ServiceHostBase serviceHostBase);
}
internal abstract class System.ServiceModel.Administration.ProviderBase : object {
    public static void FillCollectionInfo(ICollection info, IWmiInstance instance, string propertyName);
    public static void FillCollectionInfo(IEnumerable info, IWmiInstance instance, string propertyName);
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance contract);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.PutInstance(IWmiInstance instance);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.DeleteInstance(IWmiInstance instance);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.InvokeMethod(IWmiMethodContext method);
}
internal class System.ServiceModel.Administration.ServiceAppDomainAssociationProvider : ProviderBase {
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance instance);
}
internal class System.ServiceModel.Administration.ServiceEndpointAssociationProvider : ProviderBase {
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance instance);
}
internal class System.ServiceModel.Administration.ServiceInfo : object {
    public string ConfigurationName { get; }
    public string DistinguishedName { get; }
    public string FirstAddress { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string ServiceName { get; }
    public ServiceHostBase Service { get; }
    public KeyedByTypeCollection`1<IServiceBehavior> Behaviors { get; }
    public CommunicationState State { get; }
    public EndpointInfoCollection Endpoints { get; }
    public String[] Metadata { get; }
    internal ServiceInfo(ServiceHostBase service);
    public string get_ConfigurationName();
    public string get_DistinguishedName();
    public string get_FirstAddress();
    public string get_Name();
    public string get_Namespace();
    public string get_ServiceName();
    public ServiceHostBase get_Service();
    public KeyedByTypeCollection`1<IServiceBehavior> get_Behaviors();
    public CommunicationState get_State();
    public EndpointInfoCollection get_Endpoints();
    public String[] get_Metadata();
}
[KnownTypeAttribute("System.Collections.Generic.List`1<System.ServiceModel.Administration.ServiceInfo>")]
internal class System.ServiceModel.Administration.ServiceInfoCollection : Collection`1<ServiceInfo> {
    internal ServiceInfoCollection(IEnumerable`1<ServiceHostBase> services);
}
internal class System.ServiceModel.Administration.ServiceInstanceProvider : ProviderBase {
    private sealed virtual override void System.ServiceModel.Administration.IWmiProvider.EnumInstances(IWmiInstances instances);
    private sealed virtual override bool System.ServiceModel.Administration.IWmiProvider.GetInstance(IWmiInstance instance);
    internal static string GetReference(ServiceInfo serviceInfo);
    internal static IWmiInstance GetAppDomainInfo(IWmiInstance instance);
}
internal class System.ServiceModel.Administration.WbemException : Win32Exception {
    internal WbemException(WbemStatus hr);
    internal WbemException(int hr);
    internal WbemException(int hr, string message);
    internal static void Throw(WbemStatus hr);
    internal static void ThrowIfFail(int hr);
}
internal class System.ServiceModel.Administration.WbemInstanceNotFoundException : WbemException {
}
internal class System.ServiceModel.Administration.WbemInvalidMethodException : WbemException {
}
internal class System.ServiceModel.Administration.WbemInvalidParameterException : WbemException {
    internal WbemInvalidParameterException(string name);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Administration.WbemNative : object {
}
internal class System.ServiceModel.Administration.WbemNotSupportedException : WbemException {
}
internal class System.ServiceModel.Administration.WbemProvider : object {
    internal WbemProvider(string nameSpace, string appName);
    internal void Initialize();
    public void Register(string className, IWmiProvider wmiProvider);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemProviderInit.Initialize(string wszUser, int lFlags, string wszNamespace, string wszLocale, IWbemServices wbemServices, IWbemContext wbemContext, IWbemProviderInitSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.OpenNamespace(string nameSpace, int flags, IWbemContext wbemContext, IWbemServices& wbemServices, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.CancelAsyncCall(IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.QueryObjectSink(int flags, IWbemObjectSink& wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.GetObject(string objectPath, int flags, IWbemContext wbemContext, IWbemClassObject& wbemObject, IntPtr wbemResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.GetObjectAsync(string objectPath, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.PutClass(IWbemClassObject wbemObject, int flags, IWbemContext wbemContext, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.PutClassAsync(IWbemClassObject wbemObject, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.DeleteClass(string className, int flags, IWbemContext wbemContext, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.DeleteClassAsync(string className, int lFlags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.CreateClassEnum(string superClassName, int flags, IWbemContext wbemContext, IEnumWbemClassObject& wbemEnum);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.CreateClassEnumAsync(string superClassName, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.PutInstance(IWbemClassObject pInst, int lFlags, IWbemContext wbemContext, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.PutInstanceAsync(IWbemClassObject wbemObject, int lFlags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.DeleteInstance(string objectPath, int flags, IWbemContext wbemContext, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.DeleteInstanceAsync(string objectPath, int lFlags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.CreateInstanceEnum(string filter, int flags, IWbemContext wbemContext, IEnumWbemClassObject& wbemEnum);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.CreateInstanceEnumAsync(string className, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecQuery(string queryLanguage, string query, int flags, IWbemContext wbemContext, IEnumWbemClassObject& wbemEnum);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecQueryAsync(string queryLanguage, string query, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecNotificationQuery(string queryLanguage, string query, int flags, IWbemContext wbemContext, IEnumWbemClassObject& wbemEnum);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecNotificationQueryAsync(string queryLanguage, string query, int flags, IWbemContext wbemContext, IWbemObjectSink wbemSink);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecMethod(string objectPath, string methodName, int flags, IWbemContext wbemContext, IWbemClassObject wbemInParams, IWbemClassObject& wbemOutParams, IntPtr wbemCallResult);
    private sealed virtual override int System.ServiceModel.Administration.WbemNative.IWbemServices.ExecMethodAsync(string objectPath, string methodName, int flags, IWbemContext wbemContext, IWbemClassObject wbemInParams, IWbemObjectSink wbemSink);
    internal static void MTAExecute(WaitCallback callback, object state);
}
internal class System.ServiceModel.AtomicTransactionExternal10Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CompletionUri;
    public XmlDictionaryString Durable2PCUri;
    public XmlDictionaryString Volatile2PCUri;
    public XmlDictionaryString CommitAction;
    public XmlDictionaryString RollbackAction;
    public XmlDictionaryString CommittedAction;
    public XmlDictionaryString AbortedAction;
    public XmlDictionaryString PrepareAction;
    public XmlDictionaryString PreparedAction;
    public XmlDictionaryString ReadOnlyAction;
    public XmlDictionaryString ReplayAction;
    public XmlDictionaryString FaultAction;
    public AtomicTransactionExternal10Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.AtomicTransactionExternal10Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
}
internal class System.ServiceModel.AtomicTransactionExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CompletionUri;
    public XmlDictionaryString Durable2PCUri;
    public XmlDictionaryString Volatile2PCUri;
    public XmlDictionaryString CommitAction;
    public XmlDictionaryString RollbackAction;
    public XmlDictionaryString CommittedAction;
    public XmlDictionaryString AbortedAction;
    public XmlDictionaryString PrepareAction;
    public XmlDictionaryString PreparedAction;
    public XmlDictionaryString ReadOnlyAction;
    public XmlDictionaryString ReplayAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString UnknownTransaction;
    public AtomicTransactionExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.AtomicTransactionExternal11Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
    public static string UnknownTransaction;
}
internal class System.ServiceModel.AtomicTransactionExternalDictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString Prepare;
    public XmlDictionaryString Prepared;
    public XmlDictionaryString ReadOnly;
    public XmlDictionaryString Commit;
    public XmlDictionaryString Rollback;
    public XmlDictionaryString Committed;
    public XmlDictionaryString Aborted;
    public XmlDictionaryString Replay;
    public XmlDictionaryString CompletionCoordinatorPortType;
    public XmlDictionaryString CompletionParticipantPortType;
    public XmlDictionaryString CoordinatorPortType;
    public XmlDictionaryString ParticipantPortType;
    public XmlDictionaryString InconsistentInternalState;
    public AtomicTransactionExternalDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.AtomicTransactionExternalStrings : object {
    public static string Prefix;
    public static string Prepare;
    public static string Prepared;
    public static string ReadOnly;
    public static string Commit;
    public static string Rollback;
    public static string Committed;
    public static string Aborted;
    public static string Replay;
    public static string CompletionCoordinatorPortType;
    public static string CompletionParticipantPortType;
    public static string CoordinatorPortType;
    public static string ParticipantPortType;
    public static string InconsistentInternalState;
}
public enum System.ServiceModel.AuditLevel : Enum {
    public int value__;
    public static AuditLevel None;
    public static AuditLevel Success;
    public static AuditLevel Failure;
    public static AuditLevel SuccessOrFailure;
}
internal static class System.ServiceModel.AuditLevelHelper : object {
    public static bool IsDefined(AuditLevel auditLevel);
    public static void Validate(AuditLevel value);
}
public enum System.ServiceModel.AuditLogLocation : Enum {
    public int value__;
    public static AuditLogLocation Default;
    public static AuditLogLocation Application;
    public static AuditLogLocation Security;
}
internal static class System.ServiceModel.AuditLogLocationHelper : object {
    public static bool IsDefined(AuditLogLocation auditLogLocation);
    public static void Validate(AuditLogLocation value);
}
public class System.ServiceModel.BasicHttpBinding : HttpBindingBase {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WSMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpSecurity Security { get; public set; }
    [ObsoleteAttribute("This property is obsolete. To enable Http CookieContainer, use the AllowCookies property instead.", "False")]
[EditorBrowsableAttribute("1")]
public bool EnableHttpCookieContainer { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public BasicHttpBinding(string configurationName);
    public BasicHttpBinding(BasicHttpSecurityMode securityMode);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpSecurity get_Security();
    public void set_Security(BasicHttpSecurity value);
    public bool get_EnableHttpCookieContainer();
    public void set_EnableHttpCookieContainer(bool value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void InitializeFrom(HttpTransportBindingElement transport, MessageEncodingBindingElement encoding);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeEnableHttpCookieContainer();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.BasicHttpContextBinding : BasicHttpBinding {
    [DefaultValueAttribute("True")]
public bool ContextManagementEnabled { get; public set; }
    public BasicHttpContextBinding(BasicHttpSecurityMode securityMode);
    public BasicHttpContextBinding(string configName);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public virtual BindingElementCollection CreateBindingElements();
}
public enum System.ServiceModel.BasicHttpMessageCredentialType : Enum {
    public int value__;
    public static BasicHttpMessageCredentialType UserName;
    public static BasicHttpMessageCredentialType Certificate;
}
internal static class System.ServiceModel.BasicHttpMessageCredentialTypeHelper : object {
    internal static bool IsDefined(BasicHttpMessageCredentialType value);
}
public class System.ServiceModel.BasicHttpMessageSecurity : object {
    internal static BasicHttpMessageCredentialType DefaultClientCredentialType;
    public BasicHttpMessageCredentialType ClientCredentialType { get; public set; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    public BasicHttpMessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(BasicHttpMessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal SecurityBindingElement CreateMessageSecurity(bool isSecureTransportMode);
    internal static bool TryCreate(SecurityBindingElement sbe, BasicHttpMessageSecurity& security, Boolean& isSecureTransportMode);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAlgorithmSuite();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeClientCredentialType();
}
public class System.ServiceModel.BasicHttpsBinding : HttpBindingBase {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WSMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpsSecurity Security { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public BasicHttpsBinding(string configurationName);
    public BasicHttpsBinding(BasicHttpsSecurityMode securityMode);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpsSecurity get_Security();
    public void set_Security(BasicHttpsSecurity value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
}
public class System.ServiceModel.BasicHttpSecurity : object {
    internal static BasicHttpSecurityMode DefaultMode;
    public BasicHttpSecurityMode Mode { get; public set; }
    public HttpTransportSecurity Transport { get; public set; }
    public BasicHttpMessageSecurity Message { get; public set; }
    public BasicHttpSecurityMode get_Mode();
    public void set_Mode(BasicHttpSecurityMode value);
    public HttpTransportSecurity get_Transport();
    public void set_Transport(HttpTransportSecurity value);
    public BasicHttpMessageSecurity get_Message();
    public void set_Message(BasicHttpMessageSecurity value);
    internal void EnableTransportSecurity(HttpsTransportBindingElement https);
    internal static void EnableTransportSecurity(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal void EnableTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsEnabledTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal SecurityBindingElement CreateMessageSecurity();
    internal static bool TryCreate(SecurityBindingElement sbe, UnifiedSecurityMode mode, HttpTransportSecurity transportSecurity, BasicHttpSecurity& security);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessage();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransport();
}
public enum System.ServiceModel.BasicHttpSecurityMode : Enum {
    public int value__;
    public static BasicHttpSecurityMode None;
    public static BasicHttpSecurityMode Transport;
    public static BasicHttpSecurityMode Message;
    public static BasicHttpSecurityMode TransportWithMessageCredential;
    public static BasicHttpSecurityMode TransportCredentialOnly;
}
internal static class System.ServiceModel.BasicHttpSecurityModeHelper : object {
    internal static bool IsDefined(BasicHttpSecurityMode value);
    internal static BasicHttpSecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
public class System.ServiceModel.BasicHttpsSecurity : object {
    internal static BasicHttpsSecurityMode DefaultMode;
    public BasicHttpsSecurityMode Mode { get; public set; }
    public HttpTransportSecurity Transport { get; public set; }
    public BasicHttpMessageSecurity Message { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public BasicHttpsSecurityMode get_Mode();
    public void set_Mode(BasicHttpsSecurityMode value);
    public HttpTransportSecurity get_Transport();
    public void set_Transport(HttpTransportSecurity value);
    public BasicHttpMessageSecurity get_Message();
    public void set_Message(BasicHttpMessageSecurity value);
    internal BasicHttpSecurity get_BasicHttpSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessage();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransport();
    internal static BasicHttpSecurity ToBasicHttpSecurity(BasicHttpsSecurity basicHttpsSecurity);
    internal static BasicHttpsSecurity ToBasicHttpsSecurity(BasicHttpSecurity basicHttpSecurity);
    internal static void EnableTransportSecurity(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal static bool IsEnabledTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void EnableTransportSecurity(HttpsTransportBindingElement https);
    internal void EnableTransportAuthentication(HttpTransportBindingElement http);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal SecurityBindingElement CreateMessageSecurity();
    internal bool InternalShouldSerialize();
}
public enum System.ServiceModel.BasicHttpsSecurityMode : Enum {
    public int value__;
    public static BasicHttpsSecurityMode Transport;
    public static BasicHttpsSecurityMode TransportWithMessageCredential;
}
internal static class System.ServiceModel.BasicHttpsSecurityModeHelper : object {
    internal static bool IsDefined(BasicHttpsSecurityMode value);
    internal static BasicHttpsSecurityMode ToSecurityMode(UnifiedSecurityMode value);
    internal static BasicHttpsSecurityMode ToBasicHttpsSecurityMode(BasicHttpSecurityMode mode);
    internal static BasicHttpSecurityMode ToBasicHttpSecurityMode(BasicHttpsSecurityMode mode);
}
public enum System.ServiceModel.CacheSetting : Enum {
    public int value__;
    public static CacheSetting Default;
    public static CacheSetting AlwaysOn;
    public static CacheSetting AlwaysOff;
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.CallbackBehaviorAttribute : Attribute {
    internal static IsolationLevel DefaultIsolationLevel;
    public bool AutomaticSessionShutdown { get; public set; }
    public IsolationLevel TransactionIsolationLevel { get; public set; }
    internal bool IsolationLevelSet { get; }
    public bool IncludeExceptionDetailInFaults { get; public set; }
    public ConcurrencyMode ConcurrencyMode { get; public set; }
    public string TransactionTimeout { get; public set; }
    internal bool TransactionTimeoutSet { get; }
    public bool UseSynchronizationContext { get; public set; }
    public bool ValidateMustUnderstand { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    private static CallbackBehaviorAttribute();
    public bool get_AutomaticSessionShutdown();
    public void set_AutomaticSessionShutdown(bool value);
    public IsolationLevel get_TransactionIsolationLevel();
    public void set_TransactionIsolationLevel(IsolationLevel value);
    internal bool get_IsolationLevelSet();
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public string get_TransactionTimeout();
    public void set_TransactionTimeout(string value);
    internal bool get_TransactionTimeoutSet();
    public bool get_UseSynchronizationContext();
    public void set_UseSynchronizationContext(bool value);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
}
public abstract class System.ServiceModel.ChannelFactory : CommunicationObject {
    public ClientCredentials Credentials { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public ServiceEndpoint Endpoint { get; }
    internal IChannelFactory InnerFactory { get; }
    internal bool UseActiveAutoClose { get; internal set; }
    public ClientCredentials get_Credentials();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public ServiceEndpoint get_Endpoint();
    internal IChannelFactory get_InnerFactory();
    [CompilerGeneratedAttribute]
internal bool get_UseActiveAutoClose();
    [CompilerGeneratedAttribute]
internal void set_UseActiveAutoClose(bool value);
    protected internal void EnsureOpened();
    protected virtual void ApplyConfiguration(string configurationName);
    protected abstract virtual ServiceEndpoint CreateDescription();
    internal EndpointAddress CreateEndpointAddress(ServiceEndpoint endpoint);
    protected virtual IChannelFactory CreateFactory();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual T GetProperty();
    internal bool HasDuplexOperations();
    protected void InitializeEndpoint(string configurationName, EndpointAddress address);
    internal void InitializeEndpoint(string configurationName, EndpointAddress address, Configuration configuration);
    protected void InitializeEndpoint(ServiceEndpoint endpoint);
    protected void InitializeEndpoint(Binding binding, EndpointAddress address);
    protected virtual void OnOpened();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpening();
}
public class System.ServiceModel.ChannelFactory`1 : ChannelFactory {
    internal InstanceContext CallbackInstance { get; internal set; }
    internal Type CallbackType { get; internal set; }
    internal ServiceChannelFactory ServiceChannelFactory { get; }
    internal TypeLoader TypeLoader { get; }
    internal string CloseActivityName { get; }
    internal string OpenActivityName { get; }
    internal ActivityType OpenActivityType { get; }
    protected ChannelFactory`1(Type channelType);
    public ChannelFactory`1(string endpointConfigurationName);
    public ChannelFactory`1(string endpointConfigurationName, EndpointAddress remoteAddress);
    public ChannelFactory`1(Binding binding);
    public ChannelFactory`1(Binding binding, string remoteAddress);
    public ChannelFactory`1(Binding binding, EndpointAddress remoteAddress);
    public ChannelFactory`1(ServiceEndpoint endpoint);
    internal InstanceContext get_CallbackInstance();
    internal void set_CallbackInstance(InstanceContext value);
    internal Type get_CallbackType();
    internal void set_CallbackType(Type value);
    internal ServiceChannelFactory get_ServiceChannelFactory();
    internal TypeLoader get_TypeLoader();
    internal virtual string get_CloseActivityName();
    internal virtual string get_OpenActivityName();
    internal virtual ActivityType get_OpenActivityType();
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel();
    public TChannel CreateChannelWithIssuedToken(SecurityToken issuedToken);
    public TChannel CreateChannelWithIssuedToken(SecurityToken issuedToken, EndpointAddress address);
    public TChannel CreateChannelWithIssuedToken(SecurityToken issuedToken, EndpointAddress address, Uri via);
    public TChannel CreateChannelWithActAsToken(SecurityToken actAsToken);
    public TChannel CreateChannelWithActAsToken(SecurityToken actAsToken, EndpointAddress address);
    public TChannel CreateChannelWithActAsToken(SecurityToken actAsToken, EndpointAddress address, Uri via);
    public TChannel CreateChannelWithOnBehalfOfToken(SecurityToken onBehalfOf);
    public TChannel CreateChannelWithOnBehalfOfToken(SecurityToken onBehalfOf, EndpointAddress address);
    public TChannel CreateChannelWithOnBehalfOfToken(SecurityToken onBehalfOf, EndpointAddress address, Uri via);
    internal UChannel CreateChannel(EndpointAddress address);
    internal UChannel CreateChannel(EndpointAddress address, Uri via);
    internal bool CanCreateChannel();
    protected virtual ServiceEndpoint CreateDescription();
    protected static TChannel CreateChannel(string endpointConfigurationName);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress, Uri via);
    internal static void SetFactoryToAutoClose(TChannel channel);
}
internal class System.ServiceModel.ChannelFactoryRef`1 : object {
    public ChannelFactory`1<TChannel> ChannelFactory { get; }
    public ChannelFactoryRef`1(ChannelFactory`1<TChannel> channelFactory);
    public void AddRef();
    public bool Release();
    public void Close(TimeSpan timeout);
    public void Abort();
    public ChannelFactory`1<TChannel> get_ChannelFactory();
}
internal class System.ServiceModel.ChannelFactoryRefCache`1 : MruCache`2<EndpointTrait`1<TChannel>, ChannelFactoryRef`1<TChannel>> {
    public ChannelFactoryRefCache`1(int watermark);
    private static ChannelFactoryRefCache`1();
    protected virtual void OnSingleItemRemoved(ChannelFactoryRef`1<TChannel> item);
    protected virtual void OnItemAgedOutOfCache(ChannelFactoryRef`1<TChannel> item);
}
internal class System.ServiceModel.Channels.ActionHeader : AddressingHeader {
    public string Action { get; }
    public bool MustUnderstand { get; }
    public XmlDictionaryString DictionaryName { get; }
    public string get_Action();
    public virtual bool get_MustUnderstand();
    public virtual XmlDictionaryString get_DictionaryName();
    public static ActionHeader Create(string action, AddressingVersion addressingVersion);
    public static ActionHeader Create(XmlDictionaryString dictionaryAction, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static string ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
    public static ActionHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.AddHeaderDelegate : MulticastDelegate {
    public AddHeaderDelegate(object object, IntPtr method);
    public virtual void Invoke(string headerName, string headerValue);
    public virtual IAsyncResult BeginInvoke(string headerName, string headerValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.AddressHeader : object {
    internal bool IsReferenceProperty { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal bool get_IsReferenceProperty();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public static AddressHeader CreateAddressHeader(object value);
    public static AddressHeader CreateAddressHeader(object value, XmlObjectSerializer serializer);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value);
    internal static AddressHeader CreateAddressHeader(XmlDictionaryString name, XmlDictionaryString ns, object value);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    public virtual bool Equals(object obj);
    internal string GetComparableForm();
    internal string GetComparableForm(StringBuilder builder);
    public virtual int GetHashCode();
    public T GetValue();
    public T GetValue(XmlObjectSerializer serializer);
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected abstract virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
    public MessageHeader ToMessageHeader();
    public void WriteAddressHeader(XmlWriter writer);
    public void WriteAddressHeader(XmlDictionaryWriter writer);
    public void WriteStartAddressHeader(XmlDictionaryWriter writer);
    public void WriteAddressHeaderContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.AddressHeaderCollection : ReadOnlyCollection`1<AddressHeader> {
    internal static AddressHeaderCollection EmptyHeaderCollection { get; }
    internal bool HasReferenceProperties { get; }
    internal bool HasNonReferenceProperties { get; }
    public AddressHeaderCollection(IEnumerable`1<AddressHeader> addressHeaders);
    private static AddressHeaderCollection();
    internal static AddressHeaderCollection get_EmptyHeaderCollection();
    public void AddHeadersTo(Message message);
    public AddressHeader[] FindAll(string name, string ns);
    public AddressHeader FindHeader(string name, string ns);
    internal bool IsEquivalent(AddressHeaderCollection col);
    internal void PopulateHeaderDictionary(StringBuilder builder, Dictionary`2<string, int> headers);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader, bool isReferenceProperty);
    internal bool get_HasReferenceProperties();
    internal bool get_HasNonReferenceProperties();
    internal void WriteReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteNonReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteContentsTo(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Channels.AddressingHeader : DictionaryHeader {
    internal AddressingVersion Version { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    protected AddressingHeader(AddressingVersion version);
    internal AddressingVersion get_Version();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    public virtual XmlDictionaryString get_DictionaryNamespace();
}
public class System.ServiceModel.Channels.AddressingVersion : object {
    public static AddressingVersion WSAddressingAugust2004 { get; }
    public static AddressingVersion WSAddressing10 { get; }
    public static AddressingVersion None { get; }
    internal string Namespace { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    internal string Anonymous { get; }
    internal XmlDictionaryString DictionaryAnonymous { get; }
    internal Uri AnonymousUri { get; }
    internal Uri NoneUri { get; }
    internal string FaultAction { get; }
    internal string DefaultFaultAction { get; }
    internal MessagePartSpecification SignedMessageParts { get; }
    private static AddressingVersion();
    public static AddressingVersion get_WSAddressingAugust2004();
    public static AddressingVersion get_WSAddressing10();
    public static AddressingVersion get_None();
    internal string get_Namespace();
    internal XmlDictionaryString get_DictionaryNamespace();
    internal string get_Anonymous();
    internal XmlDictionaryString get_DictionaryAnonymous();
    internal Uri get_AnonymousUri();
    internal Uri get_NoneUri();
    internal string get_FaultAction();
    internal string get_DefaultFaultAction();
    internal MessagePartSpecification get_SignedMessageParts();
    public virtual string ToString();
}
internal class System.ServiceModel.Channels.AllowHelper : MarshalByRefObject {
    private static AllowHelper();
    public virtual object InitializeLifetimeService();
    public static IDisposable TryAllow(string newSid);
}
internal class System.ServiceModel.Channels.AppContainerInfo : object {
    internal static bool IsAppContainerSupported { get; }
    internal static bool IsRunningInAppContainer { get; }
    internal int SessionId { get; private set; }
    internal string NamedObjectPath { get; private set; }
    private static AppContainerInfo();
    internal static bool get_IsAppContainerSupported();
    internal static bool get_IsRunningInAppContainer();
    [CompilerGeneratedAttribute]
internal int get_SessionId();
    [CompilerGeneratedAttribute]
private void set_SessionId(int value);
    [CompilerGeneratedAttribute]
internal string get_NamedObjectPath();
    [CompilerGeneratedAttribute]
private void set_NamedObjectPath(string value);
    internal static AppContainerInfo CreateAppContainerInfo(string fullName, int sessionId);
    [SecuritySafeCriticalAttribute]
internal static SecurityIdentifier GetCurrentAppContainerSid();
}
public class System.ServiceModel.Channels.ApplicationContainerSettings : object {
    public static int CurrentSession;
    public static int ServiceSession;
    public string PackageFullName { get; public set; }
    public int SessionId { get; public set; }
    internal bool TargetingAppContainer { get; }
    [CompilerGeneratedAttribute]
public string get_PackageFullName();
    [CompilerGeneratedAttribute]
public void set_PackageFullName(string value);
    public int get_SessionId();
    public void set_SessionId(int value);
    internal bool get_TargetingAppContainer();
    internal ApplicationContainerSettings Clone();
    internal string GetConnectionGroupSuffix();
    internal bool IsMatch(ApplicationContainerSettings applicationContainerSettings);
}
internal static class System.ServiceModel.Channels.ApplicationContainerSettingsDefaults : object {
    internal static string CurrentUserSessionDefaultString;
    internal static string Session0ServiceSessionString;
    internal static string PackageFullNameDefaultString;
    internal static int CurrentSession;
    internal static int ServiceSession;
}
public class System.ServiceModel.Channels.AsymmetricSecurityBindingElement : SecurityBindingElement {
    internal static bool defaultAllowSerializedSigningTokenOnReply;
    public bool AllowSerializedSigningTokenOnReply { get; public set; }
    public SecurityTokenParameters InitiatorTokenParameters { get; public set; }
    public MessageProtectionOrder MessageProtectionOrder { get; public set; }
    public SecurityTokenParameters RecipientTokenParameters { get; public set; }
    public bool RequireSignatureConfirmation { get; public set; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    internal bool IsCertificateSignatureBinding { get; internal set; }
    public AsymmetricSecurityBindingElement(SecurityTokenParameters recipientTokenParameters);
    public AsymmetricSecurityBindingElement(SecurityTokenParameters recipientTokenParameters, SecurityTokenParameters initiatorTokenParameters);
    internal AsymmetricSecurityBindingElement(SecurityTokenParameters recipientTokenParameters, SecurityTokenParameters initiatorTokenParameters, bool allowSerializedSigningTokenOnReply);
    public bool get_AllowSerializedSigningTokenOnReply();
    public void set_AllowSerializedSigningTokenOnReply(bool value);
    public SecurityTokenParameters get_InitiatorTokenParameters();
    public void set_InitiatorTokenParameters(SecurityTokenParameters value);
    public MessageProtectionOrder get_MessageProtectionOrder();
    public void set_MessageProtectionOrder(MessageProtectionOrder value);
    public SecurityTokenParameters get_RecipientTokenParameters();
    public void set_RecipientTokenParameters(SecurityTokenParameters value);
    public bool get_RequireSignatureConfirmation();
    public void set_RequireSignatureConfirmation(bool value);
    internal virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    internal bool get_IsCertificateSignatureBinding();
    internal void set_IsCertificateSignatureBinding(bool value);
    public virtual void SetKeyDerivation(bool requireDerivedKeys);
    internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys);
    internal virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext);
    internal virtual bool RequiresChannelDemuxer();
    protected virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    protected virtual IChannelListener`1<TChannel> BuildChannelListenerCore(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    public virtual string ToString();
    public virtual BindingElement Clone();
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
internal enum System.ServiceModel.Channels.AsyncReceiveResult : Enum {
    public int value__;
    public static AsyncReceiveResult Completed;
    public static AsyncReceiveResult Pending;
}
internal static class System.ServiceModel.Channels.AuthenticationLevelHelper : object {
    internal static string ToString(AuthenticationLevel authenticationLevel);
}
internal class System.ServiceModel.Channels.AuthenticationSchemesBindingParameter : object {
    public AuthenticationSchemes AuthenticationSchemes { get; }
    public AuthenticationSchemesBindingParameter(AuthenticationSchemes authenticationSchemes);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public static bool TryExtract(BindingParameterCollection collection, AuthenticationSchemes& authenticationSchemes);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.AuthenticationSchemesHelper : object {
    public static bool DoesAuthTypeMatch(AuthenticationSchemes authScheme, string authType);
    [ExtensionAttribute]
public static bool IsSingleton(AuthenticationSchemes v);
    [ExtensionAttribute]
public static bool IsSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    [ExtensionAttribute]
public static bool IsNotSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    internal static string ToString(AuthenticationSchemes authScheme);
}
[DataContractAttribute]
internal class System.ServiceModel.Channels.BaseUriWithWildcard : object {
    internal Uri BaseAddress { get; }
    internal HostNameComparisonMode HostNameComparisonMode { get; }
    public BaseUriWithWildcard(Uri baseAddress, HostNameComparisonMode hostNameComparisonMode);
    internal Uri get_BaseAddress();
    internal HostNameComparisonMode get_HostNameComparisonMode();
    internal static BaseUriWithWildcard CreateHostedUri(string protocol, string binding, string path);
    internal static BaseUriWithWildcard CreateHostedPipeUri(string binding, string path);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal bool IsBaseOf(Uri fullAddress);
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext context);
    public virtual string ToString();
}
internal static class System.ServiceModel.Channels.BasicHttpBindingDefaults : object {
    internal static BasicHttpMessageCredentialType MessageSecurityClientCredentialType;
    internal static WSMessageEncoding MessageEncoding;
    internal static TransferMode TransferMode;
    internal static Encoding TextEncoding { get; }
    internal static Encoding get_TextEncoding();
}
internal class System.ServiceModel.Channels.BeginSendHandler : MulticastDelegate {
    public BeginSendHandler(object object, IntPtr method);
    public virtual IAsyncResult Invoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback asyncCallback, object state);
    public virtual IAsyncResult BeginInvoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback asyncCallback, object state, AsyncCallback callback, object object);
    public virtual IAsyncResult EndInvoke(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.BinaryEncoderDefaults : object {
    internal static int MaxSessionSize;
    internal static EnvelopeVersion EnvelopeVersion { get; }
    internal static BinaryVersion BinaryVersion { get; }
    internal static EnvelopeVersion get_EnvelopeVersion();
    internal static BinaryVersion get_BinaryVersion();
}
internal class System.ServiceModel.Channels.BinaryFormatBuilder : object {
    public int Count { get; }
    public int get_Count();
    public void AppendPrefixDictionaryElement(char prefix, int key);
    public void AppendDictionaryXmlnsAttribute(char prefix, int key);
    public void AppendPrefixDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryTextWithEndElement(int key);
    public void AppendDictionaryTextWithEndElement();
    public void AppendUniqueIDWithEndElement();
    public void AppendEndElement();
    public int GetStaticKey(int value);
    public int GetSessionKey(int value);
    public Byte[] ToByteArray();
}
internal static class System.ServiceModel.Channels.BinaryFormatParser : object {
    public static bool IsSessionKey(int value);
    public static int GetSessionKey(int value);
    public static int GetStaticKey(int value);
    public static int ParseInt32(Byte[] buffer, int offset, int size);
    public static int ParseKey(Byte[] buffer, int offset, int size);
    public static UniqueId ParseUniqueID(Byte[] buffer, int offset, int size);
    public static int MatchBytes(Byte[] buffer, int offset, int size, Byte[] buffer2);
    public static bool MatchAttributeNode(Byte[] buffer, int offset, int size);
    public static int MatchKey(Byte[] buffer, int offset, int size);
    public static int MatchInt32(Byte[] buffer, int offset, int size);
    public static int MatchUniqueID(Byte[] buffer, int offset, int size);
}
internal class System.ServiceModel.Channels.BinaryMessageEncoderFactory : MessageEncoderFactory {
    public static IXmlDictionary XmlDictionary { get; }
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxReadPoolSize { get; }
    public int MaxSessionSize { get; }
    public CompressionFormat CompressionFormat { get; }
    public BinaryMessageEncoderFactory(MessageVersion messageVersion, int maxReadPoolSize, int maxWritePoolSize, int maxSessionSize, XmlDictionaryReaderQuotas readerQuotas, long maxReceivedMessageSize, BinaryVersion version, CompressionFormat compressionFormat);
    public static IXmlDictionary get_XmlDictionary();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxReadPoolSize();
    public int get_MaxSessionSize();
    public CompressionFormat get_CompressionFormat();
    public virtual MessageEncoder CreateSessionEncoder();
}
public class System.ServiceModel.Channels.BinaryMessageEncodingBindingElement : MessageEncodingBindingElement {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CompressionFormat CompressionFormat { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    [DefaultValueAttribute("2048")]
public int MaxSessionSize { get; public set; }
    public CompressionFormat get_CompressionFormat();
    public void set_CompressionFormat(CompressionFormat value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public int get_MaxSessionSize();
    public void set_MaxSessionSize(int value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext policyContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessageVersion();
}
internal class System.ServiceModel.Channels.BinaryVersion : object {
    public static BinaryVersion Version1;
    public static BinaryVersion GZipVersion1;
    public static BinaryVersion DeflateVersion1;
    public static BinaryVersion CurrentVersion { get; }
    public string ContentType { get; }
    public string SessionContentType { get; }
    public IXmlDictionary Dictionary { get; }
    private static BinaryVersion();
    public static BinaryVersion get_CurrentVersion();
    public string get_ContentType();
    public string get_SessionContentType();
    public IXmlDictionary get_Dictionary();
}
internal class System.ServiceModel.Channels.BinderExceptionHandler : MulticastDelegate {
    public BinderExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(IReliableChannelBinder sender, Exception exception);
    public virtual IAsyncResult BeginInvoke(IReliableChannelBinder sender, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.Binding : object {
    internal static string DefaultNamespace;
    [DefaultValueAttribute("System.TimeSpan", "00:01:00")]
public TimeSpan CloseTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:01:00")]
public TimeSpan OpenTimeout { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:10:00")]
public TimeSpan ReceiveTimeout { get; public set; }
    public string Scheme { get; }
    public MessageVersion MessageVersion { get; }
    [DefaultValueAttribute("System.TimeSpan", "00:01:00")]
public TimeSpan SendTimeout { get; public set; }
    protected Binding(string name, string ns);
    public sealed virtual TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public sealed virtual TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public abstract virtual string get_Scheme();
    public MessageVersion get_MessageVersion();
    public sealed virtual TimeSpan get_SendTimeout();
    public void set_SendTimeout(TimeSpan value);
    public IChannelFactory`1<TChannel> BuildChannelFactory(Object[] parameters);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Object[] parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, Object[] parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, string listenUriRelativeAddress, Object[] parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode, Object[] parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingParameterCollection parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, BindingParameterCollection parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, string listenUriRelativeAddress, BindingParameterCollection parameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode, BindingParameterCollection parameters);
    public bool CanBuildChannelFactory(Object[] parameters);
    public virtual bool CanBuildChannelFactory(BindingParameterCollection parameters);
    public bool CanBuildChannelListener(Object[] parameters);
    public virtual bool CanBuildChannelListener(BindingParameterCollection parameters);
    public abstract virtual BindingElementCollection CreateBindingElements();
    public T GetProperty(BindingParameterCollection parameters);
    internal void EnsureInvariants(string contractName);
    internal void CopyTimeouts(IDefaultCommunicationTimeouts source);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeName();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeNamespace();
}
public class System.ServiceModel.Channels.BindingContext : object {
    public CustomBinding Binding { get; }
    public BindingParameterCollection BindingParameters { get; }
    public Uri ListenUriBaseAddress { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    public string ListenUriRelativeAddress { get; public set; }
    public BindingElementCollection RemainingBindingElements { get; }
    public BindingContext(CustomBinding binding, BindingParameterCollection parameters);
    public BindingContext(CustomBinding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode);
    public CustomBinding get_Binding();
    public BindingParameterCollection get_BindingParameters();
    public Uri get_ListenUriBaseAddress();
    public void set_ListenUriBaseAddress(Uri value);
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    public string get_ListenUriRelativeAddress();
    public void set_ListenUriRelativeAddress(string value);
    public BindingElementCollection get_RemainingBindingElements();
    public IChannelFactory`1<TChannel> BuildInnerChannelFactory();
    public IChannelListener`1<TChannel> BuildInnerChannelListener();
    public bool CanBuildInnerChannelFactory();
    public bool CanBuildInnerChannelListener();
    public T GetInnerProperty();
    public BindingContext Clone();
    internal void ValidateBindingElementsConsumed();
}
public abstract class System.ServiceModel.Channels.BindingElement : object {
    protected BindingElement(BindingElement elementToBeCloned);
    public abstract virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public abstract virtual T GetProperty(BindingContext context);
    internal T GetIndividualProperty();
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.BindingElementCollection : Collection`1<BindingElement> {
    public BindingElementCollection(IEnumerable`1<BindingElement> elements);
    public BindingElementCollection(BindingElement[] elements);
    internal BindingElementCollection(BindingElementCollection elements);
    public BindingElementCollection Clone();
    public void AddRange(BindingElement[] elements);
    public bool Contains(Type bindingElementType);
    public T Find();
    public T Remove();
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    protected virtual void InsertItem(int index, BindingElement item);
    protected virtual void SetItem(int index, BindingElement item);
}
public class System.ServiceModel.Channels.BindingParameterCollection : KeyedByTypeCollection`1<object> {
    internal BindingParameterCollection(Object[] parameters);
    internal BindingParameterCollection(BindingParameterCollection parameters);
}
public abstract class System.ServiceModel.Channels.BodyWriter : object {
    public bool IsBuffered { get; }
    internal bool IsEmpty { get; }
    internal bool IsFault { get; }
    protected BodyWriter(bool isBuffered);
    public bool get_IsBuffered();
    internal virtual bool get_IsEmpty();
    internal virtual bool get_IsFault();
    public BodyWriter CreateBufferedCopy(int maxBufferSize);
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    internal BodyWriter OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
}
internal class System.ServiceModel.Channels.BodyWriterMessage : Message {
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    protected internal BodyWriter BodyWriter { get; }
    public BodyWriterMessage(MessageVersion version, string action, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnClose();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected internal BodyWriter get_BodyWriter();
}
internal class System.ServiceModel.Channels.BodyWriterMessageBuffer : MessageBuffer {
    protected object ThisLock { get; }
    public int BufferSize { get; }
    protected BodyWriter BodyWriter { get; }
    protected MessageHeaders Headers { get; }
    protected KeyValuePair`2[] Properties { get; }
    protected bool Closed { get; }
    public BodyWriterMessageBuffer(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    protected object get_ThisLock();
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
    protected BodyWriter get_BodyWriter();
    protected MessageHeaders get_Headers();
    protected KeyValuePair`2[] get_Properties();
    protected bool get_Closed();
}
internal class System.ServiceModel.Channels.BufferedAddressHeader : AddressHeader {
    public bool IsReferencePropertyHeader { get; }
    public string Name { get; }
    public string Namespace { get; }
    public BufferedAddressHeader(XmlDictionaryReader reader);
    public BufferedAddressHeader(XmlDictionaryReader reader, bool isReferenceProperty);
    public bool get_IsReferencePropertyHeader();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.BufferedConnection : DelegatingConnection {
    public BufferedConnection(IConnection connection, TimeSpan flushTimeout, int writeBufferSize);
    public virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public virtual void EndWrite();
    public virtual void Shutdown(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.BufferedConnectionInitiator : object {
    protected TimeSpan FlushTimeout { get; }
    protected int WriteBufferSize { get; }
    public BufferedConnectionInitiator(IConnectionInitiator connectionInitiator, TimeSpan flushTimeout, int writeBufferSize);
    protected TimeSpan get_FlushTimeout();
    protected int get_WriteBufferSize();
    public sealed virtual IConnection Connect(Uri uri, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginConnect(Uri uri, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IConnection EndConnect(IAsyncResult result);
}
internal class System.ServiceModel.Channels.BufferedConnectionListener : object {
    public BufferedConnectionListener(IConnectionListener connectionListener, TimeSpan flushTimeout, int writeBufferSize);
    public sealed virtual void Dispose();
    public sealed virtual void Listen();
    public sealed virtual IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public sealed virtual IConnection EndAccept(IAsyncResult result);
}
internal class System.ServiceModel.Channels.BufferedHeader : ReadableMessageHeader {
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, string name, string ns, bool mustUnderstand, string actor, bool relay, bool isRefParam);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, MessageHeaderInfo headerInfo);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes);
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual XmlDictionaryReader GetHeaderReader();
}
internal class System.ServiceModel.Channels.BufferedMessage : ReceivedMessage {
    public MessageHeaders Headers { get; }
    internal IBufferedMessageData MessageData { get; }
    public MessageProperties Properties { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageVersion Version { get; }
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState);
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual MessageHeaders get_Headers();
    internal IBufferedMessageData get_MessageData();
    public virtual MessageProperties get_Properties();
    internal virtual RecycledMessageState get_RecycledMessageState();
    public virtual MessageVersion get_Version();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetBufferedReaderAtBody();
    public XmlDictionaryReader GetMessageReader();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal class System.ServiceModel.Channels.BufferedMessageBuffer : MessageBuffer {
    public int BufferSize { get; }
    public string MessageContentType { get; }
    public BufferedMessageBuffer(IBufferedMessageData messageData, KeyValuePair`2[] properties, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual int get_BufferSize();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal abstract class System.ServiceModel.Channels.BufferedMessageData : object {
    public ArraySegment`1<byte> Buffer { get; }
    public BufferManager BufferManager { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public MessageEncoder MessageEncoder { get; }
    public BufferedMessageData(SynchronizedPool`1<RecycledMessageState> messageStatePool);
    public sealed virtual ArraySegment`1<byte> get_Buffer();
    public BufferManager get_BufferManager();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual MessageEncoder get_MessageEncoder();
    public sealed virtual void EnableMultipleUsers();
    public sealed virtual void Close();
    public void DoReturnMessageState(RecycledMessageState messageState);
    public RecycledMessageState DoTakeMessageState();
    public sealed virtual XmlDictionaryReader GetMessageReader();
    public void OnXmlReaderClosed(XmlDictionaryReader reader);
    protected virtual void OnClosed();
    public sealed virtual RecycledMessageState TakeMessageState();
    protected abstract virtual XmlDictionaryReader TakeXmlReader();
    public sealed virtual void Open();
    public void Open(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    protected abstract virtual void ReturnXmlReader(XmlDictionaryReader xmlReader);
    public sealed virtual void ReturnMessageState(RecycledMessageState messageState);
}
internal abstract class System.ServiceModel.Channels.BufferedMessageWriter : object {
    protected abstract virtual XmlDictionaryWriter TakeXmlWriter(Stream stream);
    protected abstract virtual void ReturnXmlWriter(XmlDictionaryWriter writer);
    public ArraySegment`1<byte> WriteMessage(Message message, BufferManager bufferManager, int initialOffset, int maxSizeQuota);
    protected virtual void OnWriteStartMessage(XmlDictionaryWriter writer);
    protected virtual void OnWriteEndMessage(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.BufferedOutputAsyncStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal EventTraceActivity EventTraceActivity { get; }
    internal BufferedOutputAsyncStream(Stream stream, int bufferSize, int bufferLimit);
    private static BufferedOutputAsyncStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal EventTraceActivity get_EventTraceActivity();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
}
internal class System.ServiceModel.Channels.BufferedReceiveMessageProperty : object {
    public static string Name { get; }
    public object UserState { get; public set; }
    public BufferedRequestContext RequestContext { get; private set; }
    internal IInvokeReceivedNotification Notification { get; private set; }
    internal BufferedReceiveMessageProperty(MessageRpc& rpc);
    private static BufferedReceiveMessageProperty();
    public static string get_Name();
    [CompilerGeneratedAttribute]
public object get_UserState();
    [CompilerGeneratedAttribute]
public void set_UserState(object value);
    [CompilerGeneratedAttribute]
public BufferedRequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
private void set_RequestContext(BufferedRequestContext value);
    [CompilerGeneratedAttribute]
internal IInvokeReceivedNotification get_Notification();
    [CompilerGeneratedAttribute]
private void set_Notification(IInvokeReceivedNotification value);
    public void RegisterForReplay(OperationContext operationContext);
    public void ReplayRequest();
    public static bool TryGet(Message message, BufferedReceiveMessageProperty& property);
    public static bool TryGet(MessageProperties properties, BufferedReceiveMessageProperty& property);
}
internal class System.ServiceModel.Channels.BufferedRequestContext : RequestContext {
    public Message RequestMessage { get; }
    public RequestContext InnerRequestContext { get; }
    public BufferedRequestContext(RequestContext requestContext);
    public virtual Message get_RequestMessage();
    public RequestContext get_InnerRequestContext();
    public void DelayClose(bool delay);
    public void ReInitialize(Message requestMessage);
    public virtual void Abort();
    public virtual void Close();
    public virtual void Close(TimeSpan timeout);
    public virtual void Reply(Message message);
    public virtual void Reply(Message message, TimeSpan timeout);
    public virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndReply(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.BufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static BufferManager CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);
    internal static InternalBufferManager GetInternalBufferManager(BufferManager bufferManager);
}
internal class System.ServiceModel.Channels.BufferManagerOutputStream : BufferedOutputStream {
    public BufferManagerOutputStream(string quotaExceededString);
    public BufferManagerOutputStream(string quotaExceededString, int maxSize);
    public BufferManagerOutputStream(string quotaExceededString, int initialSize, int maxSize, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, int effectiveMaxSize, BufferManager bufferManager);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
}
internal abstract class System.ServiceModel.Channels.BytesReadPositionStream : DelegatingStream {
    public long Position { get; public set; }
    protected BytesReadPositionStream(Stream stream);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class System.ServiceModel.Channels.CallbackContextMessageHeader : MessageHeader {
    public static string CallbackContextHeaderName;
    public static string CallbackContextHeaderNamespace;
    public static string CallbackEndpointReference;
    public string Name { get; }
    public string Namespace { get; }
    public CallbackContextMessageHeader(EndpointAddress callbackAddress, AddressingVersion version);
    public virtual string get_Name();
    public virtual string get_Namespace();
    internal static ChannelProtectionRequirements GetChannelProtectionRequirements(ProtectionLevel protectionLevel);
    internal static CallbackContextMessageProperty ParseCallbackContextHeader(XmlReader reader, AddressingVersion version);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
public class System.ServiceModel.Channels.CallbackContextMessageProperty : object {
    public static string Name { get; }
    public EndpointAddress CallbackAddress { get; }
    public IDictionary`2<string, string> Context { get; }
    public CallbackContextMessageProperty(IDictionary`2<string, string> context);
    public CallbackContextMessageProperty(string listenAddress, IDictionary`2<string, string> context);
    public CallbackContextMessageProperty(Uri listenAddress, IDictionary`2<string, string> context);
    public CallbackContextMessageProperty(EndpointAddress listenAddress, IDictionary`2<string, string> context);
    public CallbackContextMessageProperty(EndpointAddress callbackAddress);
    public static string get_Name();
    public EndpointAddress get_CallbackAddress();
    public IDictionary`2<string, string> get_Context();
    public EndpointAddress CreateCallbackAddress(Uri listenAddress);
    public static bool TryGet(Message message, CallbackContextMessageProperty& contextMessageProperty);
    public static bool TryGet(MessageProperties properties, CallbackContextMessageProperty& contextMessageProperty);
    public void AddOrReplaceInMessage(Message message);
    public void AddOrReplaceInMessageProperties(MessageProperties properties);
    public sealed virtual IMessageProperty CreateCopy();
    public void GetListenAddressAndContext(EndpointAddress& listenAddress, IDictionary`2& context);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.CertificateHandle : SafeHandle {
    protected bool delete;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.CertificateName : object {
    public string DistinguishedName { get; }
    public CertificateName(string dn);
    public string get_DistinguishedName();
    public CryptoApiBlob GetCryptoApiBlob();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.CertificateStoreHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.ChainedAsyncResult : AsyncResult {
    protected ChainedAsyncResult(TimeSpan timeout, AsyncCallback callback, object state);
    public ChainedAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ChainedBeginHandler begin2, ChainedEndHandler end2);
    private static ChainedAsyncResult();
    protected void Begin(ChainedBeginHandler begin1, ChainedEndHandler end1, ChainedBeginHandler begin2, ChainedEndHandler end2);
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedBeginHandler : MulticastDelegate {
    public ChainedBeginHandler(object object, IntPtr method);
    public virtual IAsyncResult Invoke(TimeSpan timeout, AsyncCallback asyncCallback, object state);
    public virtual IAsyncResult BeginInvoke(TimeSpan timeout, AsyncCallback asyncCallback, object state, AsyncCallback callback, object object);
    public virtual IAsyncResult EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedCloseAsyncResult : ChainedAsyncResult {
    public ChainedCloseAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, IList`1<ICommunicationObject> collection);
    public ChainedCloseAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ICommunicationObject[] objs);
}
internal class System.ServiceModel.Channels.ChainedEndHandler : MulticastDelegate {
    public ChainedEndHandler(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult result);
    public virtual IAsyncResult BeginInvoke(IAsyncResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedOpenAsyncResult : ChainedAsyncResult {
    public ChainedOpenAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, IList`1<ICommunicationObject> collection);
    public ChainedOpenAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ICommunicationObject[] objs);
}
internal abstract class System.ServiceModel.Channels.ChannelAcceptor`1 : CommunicationObject {
    protected ChannelManagerBase ChannelManager { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected ChannelAcceptor`1(ChannelManagerBase channelManager);
    protected ChannelManagerBase get_ChannelManager();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.ChannelBase : CommunicationObject {
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelManagerBase Manager { get; }
    protected ChannelBase(ChannelManagerBase channelManager);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected TimeSpan get_DefaultReceiveTimeout();
    protected TimeSpan get_DefaultSendTimeout();
    protected ChannelManagerBase get_Manager();
    public virtual T GetProperty();
    protected virtual void OnClosed();
}
internal class System.ServiceModel.Channels.ChannelBindingMessageProperty : object {
    public static string Name { get; }
    public ChannelBinding ChannelBinding { get; }
    public ChannelBindingMessageProperty(ChannelBinding channelBinding, bool ownsCleanup);
    public static string get_Name();
    public ChannelBinding get_ChannelBinding();
    public static bool TryGet(Message message, ChannelBindingMessageProperty& property);
    public static bool TryGet(MessageProperties properties, ChannelBindingMessageProperty& property);
    public void AddTo(Message message);
    public void AddTo(MessageProperties properties);
    public sealed virtual IMessageProperty CreateCopy();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.ChannelBindingProviderHelper : object {
    public bool IsChannelBindingSupportEnabled { get; private set; }
    public sealed virtual void EnableChannelBindingSupport();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChannelBindingSupportEnabled();
    [CompilerGeneratedAttribute]
private void set_IsChannelBindingSupportEnabled(bool value);
}
internal static class System.ServiceModel.Channels.ChannelBindingUtility : object {
    public static ExtendedProtectionPolicy DisabledPolicy { get; }
    public static ExtendedProtectionPolicy DefaultPolicy { get; }
    private static ChannelBindingUtility();
    public static ExtendedProtectionPolicy get_DisabledPolicy();
    public static ExtendedProtectionPolicy get_DefaultPolicy();
    public static bool IsDefaultPolicy(ExtendedProtectionPolicy policy);
    public static void CopyFrom(ExtendedProtectionPolicyElement source, ExtendedProtectionPolicyElement destination);
    public static void InitializeFrom(ExtendedProtectionPolicy source, ExtendedProtectionPolicyElement destination);
    public static ExtendedProtectionPolicy BuildPolicy(ExtendedProtectionPolicyElement configurationPolicy);
    public static ChannelBinding GetToken(SslStream stream);
    public static ChannelBinding GetToken(TransportContext context);
    public static ChannelBinding DuplicateToken(ChannelBinding source);
    public static void TryAddToMessage(ChannelBinding channelBindingToken, Message message, bool messagePropertyOwnsCleanup);
    public static bool AreEqual(ExtendedProtectionPolicy policy1, ExtendedProtectionPolicy policy2);
    public static bool IsSubset(ServiceNameCollection primaryList, ServiceNameCollection subset);
    public static void Dispose(ChannelBinding& channelBinding);
}
internal class System.ServiceModel.Channels.ChannelBuilder : object {
    public CustomBinding Binding { get; public set; }
    public BindingParameterCollection BindingParameters { get; public set; }
    public ChannelBuilder(BindingContext context, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(Binding binding, BindingParameterCollection bindingParameters, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(ChannelBuilder channelBuilder);
    public CustomBinding get_Binding();
    public void set_Binding(CustomBinding value);
    public BindingParameterCollection get_BindingParameters();
    public void set_BindingParameters(BindingParameterCollection value);
    public IChannelFactory`1<TChannel> BuildChannelFactory();
    public IChannelListener`1<TChannel> BuildChannelListener();
    public IChannelListener`1<TChannel> BuildChannelListener(MessageFilter filter, int priority);
    public bool CanBuildChannelFactory();
    public bool CanBuildChannelListener();
}
internal class System.ServiceModel.Channels.ChannelDemuxer : object {
    public static TimeSpan UseDefaultReceiveTimeout;
    public TimeSpan PeekTimeout { get; public set; }
    public int MaxPendingSessions { get; public set; }
    private static ChannelDemuxer();
    public TimeSpan get_PeekTimeout();
    public void set_PeekTimeout(TimeSpan value);
    public int get_MaxPendingSessions();
    public void set_MaxPendingSessions(int value);
    public IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public IChannelListener`1<TChannel> BuildChannelListener(BindingContext context, ChannelDemuxerFilter filter);
}
internal class System.ServiceModel.Channels.ChannelDemuxerBindingElement : BindingElement {
    public TimeSpan PeekTimeout { get; public set; }
    public int MaxPendingSessions { get; public set; }
    public ChannelDemuxerBindingElement(bool cacheContextState);
    public ChannelDemuxerBindingElement(ChannelDemuxerBindingElement element);
    public TimeSpan get_PeekTimeout();
    public void set_PeekTimeout(TimeSpan value);
    public int get_MaxPendingSessions();
    public void set_MaxPendingSessions(int value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.Channels.ChannelDemuxerFilter : object {
    public MessageFilter Filter { get; }
    public int Priority { get; }
    public ChannelDemuxerFilter(MessageFilter filter, int priority);
    public MessageFilter get_Filter();
    public int get_Priority();
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase : ChannelManagerBase {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelFactoryBase(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase`1 : ChannelFactoryBase {
    protected ChannelFactoryBase`1(IDefaultCommunicationTimeouts timeouts);
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public sealed virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    protected abstract virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    protected void ValidateCreateChannel();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.ChannelListenerBase : ChannelManagerBase {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    public Uri Uri { get; }
    protected ChannelListenerBase(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public abstract virtual Uri get_Uri();
    public virtual T GetProperty();
    public sealed virtual bool WaitForChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForChannel(IAsyncResult result);
    protected abstract virtual bool OnWaitForChannel(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual bool OnEndWaitForChannel(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.ChannelListenerBase`1 : ChannelListenerBase {
    protected ChannelListenerBase`1(IDefaultCommunicationTimeouts timeouts);
    protected abstract virtual TChannel OnAcceptChannel(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual TChannel OnEndAcceptChannel(IAsyncResult result);
    public sealed virtual TChannel AcceptChannel();
    public sealed virtual TChannel AcceptChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual TChannel EndAcceptChannel(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.ChannelManagerBase : CommunicationObject {
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    internal TimeSpan InternalReceiveTimeout { get; }
    internal TimeSpan InternalSendTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected abstract virtual TimeSpan get_DefaultReceiveTimeout();
    protected abstract virtual TimeSpan get_DefaultSendTimeout();
    internal TimeSpan get_InternalReceiveTimeout();
    internal TimeSpan get_InternalSendTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    internal Exception CreateChannelTypeNotSupportedException(Type type);
}
internal class System.ServiceModel.Channels.ChannelModelIntegrationHandler : HttpMessageHandler {
    protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class System.ServiceModel.Channels.ChannelParameterCollection : Collection`1<object> {
    protected IChannel Channel { get; }
    public ChannelParameterCollection(IChannel channel);
    protected virtual IChannel get_Channel();
    public void PropagateChannelParameters(IChannel innerChannel);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, object item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, object item);
}
internal class System.ServiceModel.Channels.ChannelPool`1 : IdlingCommunicationPool`2<ChannelPoolKey, TChannel> {
    public ChannelPool`1(ChannelPoolSettings settings);
    private static ChannelPool`1();
    protected virtual void AbortItem(TChannel item);
    protected virtual void CloseItem(TChannel item, TimeSpan timeout);
    protected virtual void CloseItemAsync(TChannel item, TimeSpan timeout);
    protected virtual ChannelPoolKey GetPoolKey(EndpointAddress address, Uri via);
}
internal class System.ServiceModel.Channels.ChannelPoolKey : object {
    public ChannelPoolKey(EndpointAddress address, Uri via);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ChannelPoolKey other);
}
public class System.ServiceModel.Channels.ChannelPoolSettings : object {
    [DefaultValueAttribute("System.TimeSpan", "00:02:00")]
public TimeSpan IdleTimeout { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:10:00")]
public TimeSpan LeaseTimeout { get; public set; }
    [DefaultValueAttribute("10")]
public int MaxOutboundChannelsPerEndpoint { get; public set; }
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public TimeSpan get_LeaseTimeout();
    public void set_LeaseTimeout(TimeSpan value);
    public int get_MaxOutboundChannelsPerEndpoint();
    public void set_MaxOutboundChannelsPerEndpoint(int value);
    internal ChannelPoolSettings Clone();
    internal bool IsMatch(ChannelPoolSettings channelPoolSettings);
    internal bool InternalShouldSerialize();
}
internal abstract class System.ServiceModel.Channels.ChannelReliableSession : object {
    protected ChannelBase Channel { get; }
    protected Guard Guard { get; }
    public string Id { get; }
    public TimeSpan InitiationTime { get; protected set; }
    public UniqueId InputID { get; protected set; }
    protected FaultHelper FaultHelper { get; }
    public UniqueId OutputID { get; protected set; }
    public UniqueId SequenceID { get; }
    public IReliableFactorySettings Settings { get; }
    protected object ThisLock { get; }
    unknown UnblockChannelCloseHandler UnblockChannelCloseCallback {public set; }
    protected ChannelReliableSession(ChannelBase channel, IReliableFactorySettings settings, IReliableChannelBinder binder, FaultHelper faultHelper);
    protected ChannelBase get_Channel();
    protected Guard get_Guard();
    public sealed virtual string get_Id();
    public TimeSpan get_InitiationTime();
    protected void set_InitiationTime(TimeSpan value);
    public UniqueId get_InputID();
    protected void set_InputID(UniqueId value);
    protected FaultHelper get_FaultHelper();
    public UniqueId get_OutputID();
    protected void set_OutputID(UniqueId value);
    public abstract virtual UniqueId get_SequenceID();
    public IReliableFactorySettings get_Settings();
    protected object get_ThisLock();
    public void set_UnblockChannelCloseCallback(UnblockChannelCloseHandler value);
    public virtual void Abort();
    public virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void Close(TimeSpan timeout);
    public void CloseSession();
    public virtual void EndClose(IAsyncResult result);
    public abstract virtual void EndOpen(IAsyncResult result);
    protected virtual void FaultCore();
    public void OnLocalFault(Exception e, WsrmFault fault, RequestContext context);
    public void OnLocalFault(Exception e, Message faultMessage, RequestContext context);
    public void OnRemoteFault(WsrmFault fault);
    public void OnRemoteFault(Exception e);
    public virtual void OnFaulted();
    public abstract virtual void OnLocalActivity();
    public void OnUnknownException(Exception e);
    public abstract virtual void Open(TimeSpan timeout);
    public virtual void OnRemoteActivity(bool fastPolling);
    public bool ProcessInfo(WsrmMessageInfo info, RequestContext context);
    public bool ProcessInfo(WsrmMessageInfo info, RequestContext context, bool throwException);
    public void SetFinalAck(SequenceRangeCollection finalRanges);
    public virtual void StartInactivityTimer();
    public bool VerifyDuplexProtocolElements(WsrmMessageInfo info, RequestContext context);
    public bool VerifyDuplexProtocolElements(WsrmMessageInfo info, RequestContext context, bool throwException);
    protected virtual WsrmFault VerifyDuplexProtocolElements(WsrmMessageInfo info);
    public bool VerifySimplexProtocolElements(WsrmMessageInfo info, RequestContext context);
    public bool VerifySimplexProtocolElements(WsrmMessageInfo info, RequestContext context, bool throwException);
    protected abstract virtual WsrmFault VerifySimplexProtocolElements(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ChannelRequirements : ValueType {
    public bool usesInput;
    public bool usesReply;
    public bool usesOutput;
    public bool usesRequest;
    public SessionMode sessionMode;
    public static void ComputeContractRequirements(ContractDescription contractDescription, ChannelRequirements& requirements);
    public static Type[] ComputeRequiredChannels(ChannelRequirements& requirements);
    public static bool IsSessionful(Type channelType);
    public static bool IsOneWay(Type channelType);
    public static bool IsRequestReply(Type channelType);
    public static bool IsDuplex(Type channelType);
    public static Exception CantCreateListenerException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception CantCreateChannelException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception BindingContractMismatchException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName, String& contractChannelTypesString, String& bindingChannelTypesString);
}
internal class System.ServiceModel.Channels.ChannelTracker`2 : CommunicationObject {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public void Add(TChannel channel, TState channelReceiver);
    public void PrepareChannel(TChannel channel);
    public bool Remove(TChannel channel);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.ChannelWrapper`2 : LayeredChannel`1<TChannel> {
    public ChannelWrapper`2(ChannelManagerBase channelManager, TChannel innerChannel, TItem firstItem);
    protected abstract virtual void CloseFirstItem(TimeSpan timeout);
    protected TItem GetFirstItem();
    protected bool HaveFirstItem();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ClientContextProtocol : ContextProtocol {
    protected Uri Uri { get; }
    private bool System.ServiceModel.Channels.IContextManager.Enabled { get; private set; }
    public ClientContextProtocol(ContextExchangeMechanism contextExchangeMechanism, Uri uri, IChannel owner, Uri callbackAddress, bool contextManagementEnabled);
    protected Uri get_Uri();
    private sealed virtual override bool System.ServiceModel.Channels.IContextManager.get_Enabled();
    private sealed virtual override void System.ServiceModel.Channels.IContextManager.set_Enabled(bool value);
    public sealed virtual IDictionary`2<string, string> GetContext();
    public virtual void OnIncomingMessage(Message message);
    public virtual void OnOutgoingMessage(Message message, RequestContext requestContext);
    public sealed virtual void SetContext(IDictionary`2<string, string> context);
}
internal class System.ServiceModel.Channels.ClientDuplexConnectionReader : SessionConnectionReader {
    public ClientDuplexConnectionReader(ClientFramingDuplexSessionChannel channel, IConnection connection, ClientDuplexDecoder decoder, IConnectionOrientedTransportFactorySettings settings, MessageEncoder messageEncoder);
    protected virtual void EnsureDecoderAtEof();
    protected virtual Message DecodeMessage(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEOF, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ClientDuplexDecoder : ClientFramingDecoder {
    public int EnvelopeSize { get; }
    public string Fault { get; }
    public ClientDuplexDecoder(long streamPosition);
    public int get_EnvelopeSize();
    public virtual string get_Fault();
    public virtual int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.ClientDuplexEncoder : SessionEncoder {
    public static Byte[] ModeBytes;
    private static ClientDuplexEncoder();
}
internal abstract class System.ServiceModel.Channels.ClientFramingDecoder : FramingDecoder {
    public ClientFramingDecoderState CurrentState { get; protected set; }
    protected string CurrentStateAsString { get; }
    public string Fault { get; }
    protected ClientFramingDecoder(long streamPosition);
    public ClientFramingDecoderState get_CurrentState();
    protected void set_CurrentState(ClientFramingDecoderState value);
    protected virtual string get_CurrentStateAsString();
    public abstract virtual string get_Fault();
    public abstract virtual int Decode(Byte[] bytes, int offset, int size);
}
internal enum System.ServiceModel.Channels.ClientFramingDecoderState : Enum {
    public int value__;
    public static ClientFramingDecoderState ReadingUpgradeRecord;
    public static ClientFramingDecoderState ReadingUpgradeMode;
    public static ClientFramingDecoderState UpgradeResponse;
    public static ClientFramingDecoderState ReadingAckRecord;
    public static ClientFramingDecoderState Start;
    public static ClientFramingDecoderState ReadingFault;
    public static ClientFramingDecoderState ReadingFaultString;
    public static ClientFramingDecoderState Fault;
    public static ClientFramingDecoderState ReadingEnvelopeRecord;
    public static ClientFramingDecoderState ReadingEnvelopeSize;
    public static ClientFramingDecoderState EnvelopeStart;
    public static ClientFramingDecoderState ReadingEnvelopeBytes;
    public static ClientFramingDecoderState EnvelopeEnd;
    public static ClientFramingDecoderState ReadingEndRecord;
    public static ClientFramingDecoderState End;
}
internal class System.ServiceModel.Channels.ClientFramingDuplexSessionChannel : FramingDuplexSessionChannel {
    public ClientFramingDuplexSessionChannel(ChannelManagerBase factory, IConnectionOrientedTransportChannelFactorySettings settings, EndpointAddress remoteAddresss, Uri via, IConnectionInitiator connectionInitiator, ConnectionPool connectionPool, bool exposeConnectionProperty, bool flowIdentity);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    public virtual T GetProperty();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    protected virtual void PrepareMessage(Message message);
}
internal abstract class System.ServiceModel.Channels.ClientReliableChannelBinder`1 : ReliableChannelBinder`1<TChannel> {
    protected bool CanGetChannelForReceive { get; }
    public bool CanSendAsynchronously { get; }
    public ChannelParameterCollection ChannelParameters { get; }
    protected bool MustCloseChannel { get; }
    protected bool MustOpenChannel { get; }
    public Uri Via { get; }
    protected ClientReliableChannelBinder`1(EndpointAddress to, Uri via, IChannelFactory`1<TChannel> factory, MaskingMode maskingMode, TolerateFaultsMode faultMode, ChannelParameterCollection channelParameters, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected virtual bool get_CanGetChannelForReceive();
    public virtual bool get_CanSendAsynchronously();
    public virtual ChannelParameterCollection get_ChannelParameters();
    protected virtual bool get_MustCloseChannel();
    protected virtual bool get_MustOpenChannel();
    public sealed virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginTryGetChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public static IClientReliableChannelBinder CreateBinder(EndpointAddress to, Uri via, IChannelFactory`1<TChannel> factory, MaskingMode maskingMode, TolerateFaultsMode faultMode, ChannelParameterCollection channelParameters, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public sealed virtual Message EndRequest(IAsyncResult result);
    protected virtual bool EndTryGetChannel(IAsyncResult result);
    public sealed virtual bool EnsureChannelForRequest();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginRequest(TChannel channel, Message message, TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual Message OnEndRequest(TChannel channel, MaskingMode maskingMode, IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual Message OnRequest(TChannel channel, Message message, TimeSpan timeout, MaskingMode maskingMode);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual Message Request(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual bool TryGetChannel(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ClientReliableDuplexSessionChannel : ReliableDuplexSessionChannel {
    public ClientReliableDuplexSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters, UniqueId inputID);
    private static ClientReliableDuplexSessionChannel();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnRemoteActivity();
    protected virtual void ProcessMessage(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ClientReliableSession : ChannelReliableSession {
    unknown PollingHandler PollingCallback {public set; }
    public UniqueId SequenceID { get; }
    public ClientReliableSession(ChannelBase channel, IReliableFactorySettings factory, IClientReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID);
    public void set_PollingCallback(PollingHandler value);
    public virtual UniqueId get_SequenceID();
    public virtual void Abort();
    public virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void Close(TimeSpan timeout);
    public virtual void EndClose(IAsyncResult result);
    public virtual void EndOpen(IAsyncResult result);
    protected virtual void FaultCore();
    public virtual void OnFaulted();
    public virtual void OnLocalActivity();
    public virtual void Open(TimeSpan timeout);
    public virtual void OnRemoteActivity(bool fastPolling);
    public void ResumePolling(bool fastPolling);
    public bool StopPolling();
    protected virtual WsrmFault VerifyDuplexProtocolElements(WsrmMessageInfo info);
    protected virtual WsrmFault VerifySimplexProtocolElements(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ClientSimplexEncoder : SessionEncoder {
    public static Byte[] ModeBytes;
    private static ClientSimplexEncoder();
}
internal class System.ServiceModel.Channels.ClientSingletonDecoder : ClientFramingDecoder {
    public string Fault { get; }
    public ClientSingletonDecoder(long streamPosition);
    public virtual string get_Fault();
    public virtual int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.ClientSingletonEncoder : SingletonEncoder {
    public static Byte[] PreambleEndBytes;
    public static Byte[] ModeBytes;
    private static ClientSingletonEncoder();
    public static int CalcStartSize(EncodedVia via, EncodedContentType contentType);
    public static void EncodeStart(Byte[] buffer, int offset, EncodedVia via, EncodedContentType contentType);
}
internal static class System.ServiceModel.Channels.ClientSingletonSizedEncoder : object {
    public static Byte[] ModeBytes;
    private static ClientSingletonSizedEncoder();
    public static int CalcStartSize(EncodedVia via, EncodedContentType contentType);
    public static void EncodeStart(Byte[] buffer, int offset, EncodedVia via, EncodedContentType contentType);
}
public abstract class System.ServiceModel.Channels.ClientWebSocketFactory : object {
    public string WebSocketVersion { get; }
    public abstract virtual string get_WebSocketVersion();
    public abstract virtual WebSocket CreateWebSocket(Stream connection, WebSocketTransportSettings settings);
}
internal class System.ServiceModel.Channels.ClientWebSocketTransportDuplexSessionChannel : WebSocketTransportDuplexSessionChannel {
    protected bool IsStreamedOutput { get; }
    private static ClientWebSocketTransportDuplexSessionChannel();
    public ClientWebSocketTransportDuplexSessionChannel(HttpChannelFactory`1<IDuplexSessionChannel> channelFactory, ClientWebSocketFactory connectionFactory, EndpointAddress remoteAddresss, Uri via, ConnectionBufferPool bufferPool);
    protected virtual bool get_IsStreamedOutput();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnCleanup();
}
internal class System.ServiceModel.Channels.CloseCommunicationAsyncResult : AsyncResult {
    private object ThisLock { get; }
    public CloseCommunicationAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, object mutex);
    private object get_ThisLock();
    public sealed virtual void Dispose();
    public static void End(IAsyncResult result);
    public sealed virtual void Signal();
    public sealed virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal class System.ServiceModel.Channels.CloseSequence : BodyWriter {
    public CloseSequence(UniqueId identifier, long lastMsgNumber);
    public static CloseSequenceInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CloseSequenceInfo : WsrmRequestInfo {
    public UniqueId Identifier { get; public set; }
    public long LastMsgNumber { get; public set; }
    public string RequestName { get; }
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public long get_LastMsgNumber();
    public void set_LastMsgNumber(long value);
    public virtual string get_RequestName();
    public static CloseSequenceInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.CloseSequenceResponse : BodyWriter {
    public CloseSequenceResponse(UniqueId identifier);
    public static CloseSequenceResponseInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CloseSequenceResponseInfo : object {
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public static CloseSequenceResponseInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
public abstract class System.ServiceModel.Channels.CommunicationObject : object {
    internal bool Aborted { get; }
    internal object EventSender { get; internal set; }
    protected bool IsDisposed { get; }
    public CommunicationState State { get; }
    protected object ThisLock { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal TimeSpan InternalCloseTimeout { get; }
    internal TimeSpan InternalOpenTimeout { get; }
    internal string CloseActivityName { get; }
    internal string OpenActivityName { get; }
    internal ActivityType OpenActivityType { get; }
    internal bool TraceOpenAndClose { get; internal set; }
    protected CommunicationObject(object mutex);
    internal CommunicationObject(object mutex, object eventSender);
    internal bool get_Aborted();
    internal object get_EventSender();
    internal void set_EventSender(object value);
    protected bool get_IsDisposed();
    public sealed virtual CommunicationState get_State();
    protected object get_ThisLock();
    protected abstract virtual TimeSpan get_DefaultCloseTimeout();
    protected abstract virtual TimeSpan get_DefaultOpenTimeout();
    internal TimeSpan get_InternalCloseTimeout();
    internal TimeSpan get_InternalOpenTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    internal Exception CreateClosedException();
    internal Exception CreateFaultedException();
    internal Exception CreateAbortedException();
    internal virtual string get_CloseActivityName();
    internal virtual string get_OpenActivityName();
    internal virtual ActivityType get_OpenActivityType();
    internal bool DoneReceivingInCurrentState();
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    protected void Fault();
    internal void Fault(Exception exception);
    internal void AddPendingException(Exception exception);
    internal Exception GetPendingException();
    internal Exception GetTerminalException();
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnFaulted();
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfFaulted();
    internal void ThrowIfAborted();
    internal bool get_TraceOpenAndClose();
    internal void set_TraceOpenAndClose(bool value);
    internal void ThrowIfClosed();
    protected virtual Type GetCommunicationObjectType();
    protected internal void ThrowIfDisposed();
    internal void ThrowIfClosedOrOpened();
    protected internal void ThrowIfDisposedOrImmutable();
    protected internal void ThrowIfDisposedOrNotOpen();
    internal void ThrowIfNotOpened();
    internal void ThrowIfClosedOrNotOpen();
    internal void ThrowPending();
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual void OnEndClose(IAsyncResult result);
    protected abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnOpen(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndOpen(IAsyncResult result);
}
internal class System.ServiceModel.Channels.CommunicationObjectManager`1 : LifetimeManager {
    public CommunicationObjectManager`1(object mutex);
    public void Add(ItemType item);
    public void CloseInput();
    public void DecrementActivityCount();
    public void IncrementActivityCount();
    public void Remove(ItemType item);
    public ItemType[] ToArray();
}
internal abstract class System.ServiceModel.Channels.CommunicationPool`2 : object {
    public int MaxIdleConnectionPoolCount { get; }
    protected object ThisLock { get; }
    protected CommunicationPool`2(int maxCount);
    public int get_MaxIdleConnectionPoolCount();
    protected object get_ThisLock();
    protected abstract virtual void AbortItem(TItem item);
    protected abstract virtual void CloseItem(TItem item, TimeSpan timeout);
    protected abstract virtual void CloseItemAsync(TItem item, TimeSpan timeout);
    protected abstract virtual TKey GetPoolKey(EndpointAddress address, Uri via);
    protected virtual EndpointConnectionPool<TKey, TItem> CreateEndpointConnectionPool(TKey key);
    public bool Close(TimeSpan timeout);
    public bool TryOpen();
    protected virtual void OnClosed();
    public void AddConnection(TKey key, TItem connection, TimeSpan timeout);
    public TItem TakeConnection(EndpointAddress address, Uri via, TimeSpan timeout, TKey& key);
    public void ReturnConnection(TKey key, TItem connection, bool connectionIsStillGood, TimeSpan timeout);
}
internal enum System.ServiceModel.Channels.CommunicationWaitResult : Enum {
    public int value__;
    public static CommunicationWaitResult Waiting;
    public static CommunicationWaitResult Succeeded;
    public static CommunicationWaitResult Expired;
    public static CommunicationWaitResult Aborted;
}
internal class System.ServiceModel.Channels.ComponentExceptionHandler : MulticastDelegate {
    public ComponentExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(Exception exception);
    public virtual IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ComponentFaultedHandler : MulticastDelegate {
    public ComponentFaultedHandler(object object, IntPtr method);
    public virtual void Invoke(Exception faultException, WsrmFault fault);
    public virtual IAsyncResult BeginInvoke(Exception faultException, WsrmFault fault, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ServiceModel.Channels.CompositeDuplexBindingElement : BindingElement {
    [DefaultValueAttribute("")]
public Uri ClientBaseAddress { get; public set; }
    public Uri get_ClientBaseAddress();
    public void set_ClientBaseAddress(Uri value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
public class System.ServiceModel.Channels.CompositeDuplexBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
public enum System.ServiceModel.Channels.CompressionFormat : Enum {
    public int value__;
    public static CompressionFormat None;
    public static CompressionFormat GZip;
    public static CompressionFormat Deflate;
}
internal static class System.ServiceModel.Channels.CompressionFormatHelper : object {
    public static void Validate(CompressionFormat value);
    internal static bool IsDefined(CompressionFormat value);
}
internal class System.ServiceModel.Channels.ConnectAlgorithms : object {
    private static ConnectAlgorithms();
    public sealed virtual void Initialize(IPeerMaintainer maintainer, PeerNodeConfig config, int wantedConnectionCount, Dictionary`2<EndpointAddress, Referral> referralCache);
    public sealed virtual void Connect(TimeSpan timeout);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual void PruneConnections();
    public sealed virtual void UpdateEndpointsCollection(ICollection`1<PeerNodeAddress> src);
    public void UpdateEndpointsCollection(ICollection`1<Referral> src);
}
[MessageContractAttribute]
internal class System.ServiceModel.Channels.ConnectInfo : object {
    public PeerNodeAddress Address { get; }
    public ulong NodeId { get; }
    public ConnectInfo(ulong nodeId, PeerNodeAddress address);
    public PeerNodeAddress get_Address();
    public ulong get_NodeId();
    public bool HasBody();
}
internal class System.ServiceModel.Channels.ConnectionAcceptor : object {
    public int ConnectionCount { get; }
    public ConnectionAcceptor(IConnectionListener listener, int maxAccepts, int maxPendingConnections, ConnectionAvailableCallback callback);
    public ConnectionAcceptor(IConnectionListener listener, int maxAccepts, int maxPendingConnections, ConnectionAvailableCallback callback, ErrorCallback errorCallback);
    public int get_ConnectionCount();
    public sealed virtual void Dispose();
    public void StartAccepting();
}
internal class System.ServiceModel.Channels.ConnectionAvailableCallback : MulticastDelegate {
    public ConnectionAvailableCallback(object object, IntPtr method);
    public virtual void Invoke(IConnection connection, Action connectionDequeuedCallback);
    public virtual IAsyncResult BeginInvoke(IConnection connection, Action connectionDequeuedCallback, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ConnectionBufferPool : QueuedObjectPool`1<Byte[]> {
    public int BufferSize { get; }
    public ConnectionBufferPool(int bufferSize);
    public ConnectionBufferPool(int bufferSize, int maxFreeCount);
    public int get_BufferSize();
    protected virtual Byte[] Create();
}
internal class System.ServiceModel.Channels.ConnectionClosedCallback : MulticastDelegate {
    public ConnectionClosedCallback(object object, IntPtr method);
    public virtual void Invoke(InitialServerConnectionReader connectionReader);
    public virtual IAsyncResult BeginInvoke(InitialServerConnectionReader connectionReader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ConnectionDemuxer : object {
    public ConnectionDemuxer(IConnectionListener listener, int maxAccepts, int maxPendingConnections, TimeSpan channelInitializationTimeout, TimeSpan idleTimeout, int maxPooledConnections, TransportSettingsCallback transportSettingsCallback, SingletonPreambleDemuxCallback singletonPreambleCallback, ServerSessionPreambleDemuxCallback serverSessionPreambleCallback, ErrorCallback errorCallback);
    public sealed virtual void Dispose();
    public void ReuseConnection(IConnection connection, TimeSpan closeTimeout);
    public void StartDemuxing();
    public void StartDemuxing(Action`1<Uri> viaDelegate);
}
internal class System.ServiceModel.Channels.ConnectionMessageProperty : object {
    public static string Name { get; }
    public IConnection Connection { get; }
    public ConnectionMessageProperty(IConnection connection);
    public static string get_Name();
    public IConnection get_Connection();
}
internal class System.ServiceModel.Channels.ConnectionModeCallback : MulticastDelegate {
    public ConnectionModeCallback(object object, IntPtr method);
    public virtual void Invoke(ConnectionModeReader connectionModeReader);
    public virtual IAsyncResult BeginInvoke(ConnectionModeReader connectionModeReader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ConnectionModeReader : InitialServerConnectionReader {
    public int BufferOffset { get; }
    public int BufferSize { get; }
    public long StreamPosition { get; }
    public ConnectionModeReader(IConnection connection, ConnectionModeCallback callback, ConnectionClosedCallback closedCallback);
    public int get_BufferOffset();
    public int get_BufferSize();
    public long get_StreamPosition();
    public TimeSpan GetRemainingTimeout();
    public FramingMode GetConnectionMode();
    public void StartReading(TimeSpan receiveTimeout, Action connectionDequeuedCallback);
}
public abstract class System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement : TransportBindingElement {
    [DefaultValueAttribute("8192")]
public int ConnectionBufferSize { get; public set; }
    internal bool ExposeConnectionProperty { get; internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    public int MaxPendingConnections { get; public set; }
    internal bool IsMaxPendingConnectionsSet { get; }
    internal bool InheritBaseAddressSettings { get; internal set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:30")]
public TimeSpan ChannelInitializationTimeout { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00.2")]
public TimeSpan MaxOutputDelay { get; public set; }
    public int MaxPendingAccepts { get; public set; }
    internal bool IsMaxPendingAcceptsSet { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    internal string WsdlTransportUri { get; }
    internal ConnectionOrientedTransportBindingElement(ConnectionOrientedTransportBindingElement elementToBeCloned);
    public int get_ConnectionBufferSize();
    public void set_ConnectionBufferSize(int value);
    internal bool get_ExposeConnectionProperty();
    internal void set_ExposeConnectionProperty(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    internal bool get_IsMaxPendingConnectionsSet();
    internal bool get_InheritBaseAddressSettings();
    internal void set_InheritBaseAddressSettings(bool value);
    public TimeSpan get_ChannelInitializationTimeout();
    public void set_ChannelInitializationTimeout(TimeSpan value);
    public TimeSpan get_MaxOutputDelay();
    public void set_MaxOutputDelay(TimeSpan value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    internal bool get_IsMaxPendingAcceptsSet();
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    internal abstract virtual string get_WsdlTransportUri();
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
    private sealed virtual override void System.ServiceModel.Channels.ITransportPolicyImport.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMaxPendingAccepts();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMaxPendingConnections();
}
internal abstract class System.ServiceModel.Channels.ConnectionOrientedTransportChannelFactory`1 : TransportChannelFactory`1<TChannel> {
    public int ConnectionBufferSize { get; }
    internal IConnectionInitiator ConnectionInitiator { get; }
    public string ConnectionPoolGroupName { get; }
    public TimeSpan IdleTimeout { get; }
    public int MaxBufferSize { get; }
    public int MaxOutboundConnectionsPerEndpoint { get; }
    public TimeSpan MaxOutputDelay { get; }
    public StreamUpgradeProvider Upgrade { get; }
    public TransferMode TransferMode { get; }
    private int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.MaxBufferSize { get; }
    private TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.TransferMode { get; }
    private StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.Upgrade { get; }
    private ServiceSecurityAuditBehavior System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.AuditBehavior { get; }
    internal ConnectionOrientedTransportChannelFactory`1(ConnectionOrientedTransportBindingElement bindingElement, BindingContext context, string connectionPoolGroupName, TimeSpan idleTimeout, int maxOutboundConnectionsPerEndpoint, bool supportsImpersonationDuringAsyncOpen);
    public sealed virtual int get_ConnectionBufferSize();
    internal IConnectionInitiator get_ConnectionInitiator();
    public sealed virtual string get_ConnectionPoolGroupName();
    public sealed virtual TimeSpan get_IdleTimeout();
    public int get_MaxBufferSize();
    public sealed virtual int get_MaxOutboundConnectionsPerEndpoint();
    public sealed virtual TimeSpan get_MaxOutputDelay();
    public StreamUpgradeProvider get_Upgrade();
    public TransferMode get_TransferMode();
    private sealed virtual override int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_MaxBufferSize();
    private sealed virtual override TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_TransferMode();
    private sealed virtual override StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_Upgrade();
    private sealed virtual override ServiceSecurityAuditBehavior System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_AuditBehavior();
    public virtual T GetProperty();
    internal virtual int GetMaxBufferSize();
    internal abstract virtual IConnectionInitiator GetConnectionInitiator();
    internal abstract virtual ConnectionPool GetConnectionPool();
    internal abstract virtual void ReleaseConnectionPool(ConnectionPool pool, TimeSpan timeout);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpening();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual bool SupportsUpgrade(StreamUpgradeBindingElement upgradeBindingElement);
}
internal abstract class System.ServiceModel.Channels.ConnectionOrientedTransportChannelListener : TransportChannelListener {
    public int ConnectionBufferSize { get; }
    public TimeSpan IdleTimeout { get; }
    public int MaxPooledConnections { get; }
    internal bool ExposeConnectionProperty { get; }
    public HostNameComparisonMode HostNameComparisonMode { get; }
    public TimeSpan ChannelInitializationTimeout { get; }
    public int MaxBufferSize { get; }
    public int MaxPendingConnections { get; }
    public TimeSpan MaxOutputDelay { get; }
    public int MaxPendingAccepts { get; }
    public StreamUpgradeProvider Upgrade { get; }
    public TransferMode TransferMode { get; }
    private int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.MaxBufferSize { get; }
    private TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.TransferMode { get; }
    private StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.Upgrade { get; }
    private ServiceSecurityAuditBehavior System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.AuditBehavior { get; }
    protected ConnectionOrientedTransportChannelListener(ConnectionOrientedTransportBindingElement bindingElement, BindingContext context);
    public sealed virtual int get_ConnectionBufferSize();
    public sealed virtual TimeSpan get_IdleTimeout();
    public sealed virtual int get_MaxPooledConnections();
    internal void SetIdleTimeout(TimeSpan idleTimeout);
    internal void InitializeMaxPooledConnections(int maxOutboundConnectionsPerEndpoint);
    internal bool get_ExposeConnectionProperty();
    public HostNameComparisonMode get_HostNameComparisonMode();
    public virtual T GetProperty();
    public sealed virtual TimeSpan get_ChannelInitializationTimeout();
    public int get_MaxBufferSize();
    public sealed virtual int get_MaxPendingConnections();
    public sealed virtual TimeSpan get_MaxOutputDelay();
    public sealed virtual int get_MaxPendingAccepts();
    public StreamUpgradeProvider get_Upgrade();
    public TransferMode get_TransferMode();
    private sealed virtual override int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_MaxBufferSize();
    private sealed virtual override TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_TransferMode();
    private sealed virtual override StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_Upgrade();
    private sealed virtual override ServiceSecurityAuditBehavior System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_AuditBehavior();
    internal virtual int GetMaxBufferSize();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void ValidateUri(Uri uri);
    protected virtual bool SupportsUpgrade(StreamUpgradeBindingElement upgradeBindingElement);
}
internal static class System.ServiceModel.Channels.ConnectionOrientedTransportDefaults : object {
    internal static bool AllowNtlm;
    internal static int ConnectionBufferSize;
    internal static string ConnectionPoolGroupName;
    internal static HostNameComparisonMode HostNameComparisonMode;
    internal static string IdleTimeoutString;
    internal static string ChannelInitializationTimeoutString;
    internal static int MaxContentTypeSize;
    internal static int MaxOutboundConnectionsPerEndpoint;
    internal static int MaxPendingConnectionsConst;
    internal static string MaxOutputDelayString;
    internal static int MaxPendingAcceptsConst;
    internal static int MaxViaSize;
    internal static ProtectionLevel ProtectionLevel;
    internal static TransferMode TransferMode;
    internal static TimeSpan IdleTimeout { get; }
    internal static TimeSpan ChannelInitializationTimeout { get; }
    internal static TimeSpan MaxOutputDelay { get; }
    internal static TimeSpan get_IdleTimeout();
    internal static TimeSpan get_ChannelInitializationTimeout();
    internal static TimeSpan get_MaxOutputDelay();
    internal static int GetMaxConnections();
    internal static int GetMaxPendingConnections();
    internal static int GetMaxPendingAccepts();
}
internal abstract class System.ServiceModel.Channels.ConnectionOrientedTransportManager`1 : TransportManager {
    protected TimeSpan ChannelInitializationTimeout { get; }
    internal int ConnectionBufferSize { get; }
    internal int MaxPendingConnections { get; }
    internal TimeSpan MaxOutputDelay { get; }
    internal int MaxPendingAccepts { get; }
    internal TimeSpan IdleTimeout { get; }
    internal int MaxPooledConnections { get; }
    protected TimeSpan get_ChannelInitializationTimeout();
    internal void ApplyListenerSettings(IConnectionOrientedListenerSettings listenerSettings);
    internal int get_ConnectionBufferSize();
    internal int get_MaxPendingConnections();
    internal TimeSpan get_MaxOutputDelay();
    internal int get_MaxPendingAccepts();
    internal TimeSpan get_IdleTimeout();
    internal int get_MaxPooledConnections();
    internal bool IsCompatible(ConnectionOrientedTransportChannelListener channelListener);
    internal void OnDemuxerError(Exception exception);
    internal ISingletonChannelListener OnGetSingletonMessageHandler(ServerSingletonPreambleConnectionReader serverSingletonPreambleReader);
    internal void OnHandleServerSessionPreamble(ServerSessionPreambleConnectionReader serverSessionPreambleReader, ConnectionDemuxer connectionDemuxer);
    internal IConnectionOrientedTransportFactorySettings OnGetTransportFactorySettings(Uri via);
    internal virtual void Register(TransportChannelListener channelListener);
    internal virtual void Unregister(TransportChannelListener channelListener);
    internal void SetMessageReceivedCallback(Action messageReceivedCallback);
}
internal abstract class System.ServiceModel.Channels.ConnectionPool : IdlingCommunicationPool`2<string, IConnection> {
    public string Name { get; }
    protected ConnectionPool(IConnectionOrientedTransportChannelFactorySettings settings, TimeSpan leaseTimeout);
    public string get_Name();
    protected virtual void AbortItem(IConnection item);
    protected virtual void CloseItem(IConnection item, TimeSpan timeout);
    protected virtual void CloseItemAsync(IConnection item, TimeSpan timeout);
    public virtual bool IsCompatible(IConnectionOrientedTransportChannelFactorySettings settings);
}
internal abstract class System.ServiceModel.Channels.ConnectionPoolHelper : object {
    protected EventTraceActivity EventTraceActivity { get; }
    public ConnectionPoolHelper(ConnectionPool connectionPool, IConnectionInitiator connectionInitiator, Uri via);
    protected EventTraceActivity get_EventTraceActivity();
    protected abstract virtual IConnection AcceptPooledConnection(IConnection connection, TimeoutHelper& timeoutHelper);
    protected abstract virtual IAsyncResult BeginAcceptPooledConnection(IConnection connection, TimeoutHelper& timeoutHelper, AsyncCallback callback, object state);
    protected abstract virtual IConnection EndAcceptPooledConnection(IAsyncResult result);
    protected abstract virtual TimeoutException CreateNewConnectionTimeoutException(TimeSpan timeout, TimeoutException innerException);
    public IAsyncResult BeginEstablishConnection(TimeSpan timeout, AsyncCallback callback, object state);
    public IConnection EndEstablishConnection(IAsyncResult result);
    public IConnection EstablishConnection(TimeSpan timeout);
    public void Abort();
    public void Close(TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.ConnectionPoolRegistry : object {
    public ConnectionPool Lookup(IConnectionOrientedTransportChannelFactorySettings settings);
    protected abstract virtual ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
    public void Release(ConnectionPool pool, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ConnectionStream : Stream {
    public IConnection Connection { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public TimeSpan CloseTimeout { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool Immediate { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public TraceEventType ExceptionEventType { get; public set; }
    public ConnectionStream(IConnection connection, IDefaultCommunicationTimeouts defaultTimeouts);
    public IConnection get_Connection();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public bool get_Immediate();
    public void set_Immediate(bool value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public TraceEventType get_ExceptionEventType();
    public void set_ExceptionEventType(TraceEventType value);
    public void Abort();
    public virtual void Close();
    public virtual void Flush();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    protected int Read(Byte[] buffer, int offset, int count, TimeSpan timeout);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public void Shutdown(TimeSpan timeout);
    public IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public bool EndValidate(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ConnectionUpgradeHelper : object {
    public static IAsyncResult BeginDecodeFramingFault(ClientFramingDecoder decoder, IConnection connection, Uri via, string contentType, TimeoutHelper& timeoutHelper, AsyncCallback callback, object state);
    public static void EndDecodeFramingFault(IAsyncResult result);
    public static void DecodeFramingFault(ClientFramingDecoder decoder, IConnection connection, Uri via, string contentType, TimeoutHelper& timeoutHelper);
    public static IAsyncResult BeginInitiateUpgrade(IDefaultCommunicationTimeouts timeouts, EndpointAddress remoteAddress, IConnection connection, ClientFramingDecoder decoder, StreamUpgradeInitiator upgradeInitiator, string contentType, WindowsIdentity identityToImpersonate, TimeoutHelper timeoutHelper, AsyncCallback callback, object state);
    public static IConnection EndInitiateUpgrade(IAsyncResult result);
    public static bool InitiateUpgrade(StreamUpgradeInitiator upgradeInitiator, IConnection& connection, ClientFramingDecoder decoder, IDefaultCommunicationTimeouts defaultTimeouts, TimeoutHelper& timeoutHelper);
    public static bool ValidatePreambleResponse(Byte[] buffer, int count, ClientFramingDecoder decoder, Uri via);
}
internal static class System.ServiceModel.Channels.ConnectionUtilities : object {
    internal static void CloseNoThrow(IConnection connection, TimeSpan timeout);
    internal static void ValidateBufferBounds(ArraySegment`1<byte> buffer);
    internal static void ValidateBufferBounds(Byte[] buffer, int offset, int size);
    internal static void ValidateBufferBounds(int bufferSize, int offset, int size);
}
internal abstract class System.ServiceModel.Channels.ContentOnlyMessage : Message {
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.ContentTypeStringDecoder : StringDecoder {
    public ContentTypeStringDecoder(int sizeQuota);
    protected virtual Exception OnSizeQuotaExceeded(int size);
    public static string GetString(FramingEncodingType type);
}
internal class System.ServiceModel.Channels.ContextAddressHeader : AddressHeader {
    public string Name { get; }
    public string Namespace { get; }
    public ContextAddressHeader(IDictionary`2<string, string> context);
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Channels.ContextBindingElement : BindingElement {
    internal static ContextExchangeMechanism DefaultContextExchangeMechanism;
    internal static bool DefaultContextManagementEnabled;
    internal static ProtectionLevel DefaultProtectionLevel;
    [DefaultValueAttribute("")]
public Uri ClientCallbackAddress { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ContextExchangeMechanism ContextExchangeMechanism { get; public set; }
    [DefaultValueAttribute("True")]
public bool ContextManagementEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ProtectionLevel { get; public set; }
    public ContextBindingElement(ProtectionLevel protectionLevel);
    public ContextBindingElement(ProtectionLevel protectionLevel, ContextExchangeMechanism contextExchangeMechanism);
    public ContextBindingElement(ProtectionLevel protectionLevel, ContextExchangeMechanism contextExchangeMechanism, Uri clientCallbackAddress);
    public ContextBindingElement(ProtectionLevel protectionLevel, ContextExchangeMechanism contextExchangeMechanism, Uri clientCallbackAddress, bool contextManagementEnabled);
    [CompilerGeneratedAttribute]
public Uri get_ClientCallbackAddress();
    [CompilerGeneratedAttribute]
public void set_ClientCallbackAddress(Uri value);
    public ContextExchangeMechanism get_ContextExchangeMechanism();
    public void set_ContextExchangeMechanism(ContextExchangeMechanism value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual void ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private sealed virtual override void System.ServiceModel.Administration.IWmiInstanceProvider.FillInstance(IWmiInstance wmiInstance);
    private sealed virtual override string System.ServiceModel.Administration.IWmiInstanceProvider.GetInstanceType();
    internal static void ValidateContextBindingElementOnAllEndpointsWithSessionfulContract(ServiceDescription description, IServiceBehavior callingBehavior);
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Channels.ContextBindingElementImporter : object {
    public sealed virtual void BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    public sealed virtual void ImportContract(WsdlImporter importer, WsdlContractConversionContext context);
    public sealed virtual void ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext context);
    public virtual void ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
internal static class System.ServiceModel.Channels.ContextBindingElementPolicy : object {
    public static void ExportRequireContextAssertion(ContextBindingElement bindingElement, PolicyAssertionCollection assertions);
    public static bool TryGetHttpUseCookieAssertion(ICollection`1<XmlElement> assertions, XmlElement& httpUseCookieAssertion);
    public static bool TryImportRequireContextAssertion(PolicyAssertionCollection assertions, ContextBindingElement& bindingElement);
}
internal class System.ServiceModel.Channels.ContextChannelFactory`1 : LayeredChannelFactory`1<TChannel> {
    public ContextChannelFactory`1(BindingContext context, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
}
internal class System.ServiceModel.Channels.ContextChannelListener`1 : LayeredChannelListener`1<TChannel> {
    public ContextChannelListener`1(BindingContext context, ContextExchangeMechanism contextExchangeMechanism);
    protected virtual TChannel OnAcceptChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual TChannel OnEndAcceptChannel(IAsyncResult result);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ContextChannelRequestContext : RequestContext {
    public Message RequestMessage { get; }
    public ContextChannelRequestContext(RequestContext innerContext, ContextProtocol contextProtocol, TimeSpan defaultSendTimeout);
    public virtual Message get_RequestMessage();
    public virtual void Abort();
    public virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public virtual void Close(TimeSpan timeout);
    public virtual void Close();
    public virtual void EndReply(IAsyncResult result);
    public virtual void Reply(Message message, TimeSpan timeout);
    public virtual void Reply(Message message);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Channels.ContextDictionary : object {
    internal static ContextDictionary Empty { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    public string Item { get; public set; }
    public ContextDictionary(IDictionary`2<string, string> context);
    internal static ContextDictionary get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Add(KeyValuePair`2<string, string> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, string> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, string> item);
    public sealed virtual bool TryGetValue(string key, String& value);
    internal static bool TryValidateKeyValueSpace(string key);
}
internal class System.ServiceModel.Channels.ContextDuplexSessionChannel : ContextOutputChannelBase`1<IDuplexSessionChannel> {
    public EndpointAddress LocalAddress { get; }
    public IDuplexSession Session { get; }
    protected ContextProtocol ContextProtocol { get; }
    protected bool IsClient { get; }
    public ContextDuplexSessionChannel(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri address, Uri callbackAddress, bool contextManagementEnabled);
    public ContextDuplexSessionChannel(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual IDuplexSession get_Session();
    protected virtual ContextProtocol get_ContextProtocol();
    protected virtual bool get_IsClient();
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual Message Receive();
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
}
internal static class System.ServiceModel.Channels.ContextExchangeCorrelationHelper : object {
    public static string CorrelationName;
    private static ContextExchangeCorrelationHelper();
    public static void AddIncomingContextCorrelationData(Message message);
    public static void AddOutgoingCorrelationCallbackData(CorrelationCallbackMessageProperty callback, Message message, bool client);
    public static string GetContextCorrelationData(Message message);
    public static string GetContextCorrelationData(OperationContext operationContext);
    public static string GetCallbackContextCorrelationData(Message message);
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public enum System.ServiceModel.Channels.ContextExchangeMechanism : Enum {
    public int value__;
    public static ContextExchangeMechanism ContextSoapHeader;
    public static ContextExchangeMechanism HttpCookie;
}
internal static class System.ServiceModel.Channels.ContextExchangeMechanismHelper : object {
    public static bool IsDefined(ContextExchangeMechanism value);
}
internal class System.ServiceModel.Channels.ContextInputChannel : ContextInputChannelBase`1<IInputChannel> {
    public ContextInputChannel(ChannelManagerBase channelManager, IInputChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
}
internal abstract class System.ServiceModel.Channels.ContextInputChannelBase`1 : LayeredChannel`1<TChannel> {
    public EndpointAddress LocalAddress { get; }
    protected ContextInputChannelBase`1(ChannelManagerBase channelManager, TChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual Message Receive();
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ContextInputSessionChannel : ContextInputChannelBase`1<IInputSessionChannel> {
    public IInputSession Session { get; }
    public ContextInputSessionChannel(ChannelManagerBase channelManager, IInputSessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
    public sealed virtual IInputSession get_Session();
}
internal class System.ServiceModel.Channels.ContextMessageHeader : MessageHeader {
    public static string ContextHeaderName;
    public static string ContextHeaderNamespace;
    public static string ContextPropertyElement;
    public static string ContextPropertyNameAttribute;
    public string Name { get; }
    public string Namespace { get; }
    public ContextMessageHeader(IDictionary`2<string, string> context);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public static ContextMessageProperty GetContextFromHeaderIfExists(Message message);
    internal static ChannelProtectionRequirements GetChannelProtectionRequirements(ProtectionLevel protectionLevel);
    internal static ContextMessageProperty ParseContextHeader(XmlReader reader);
    internal static void WriteHeaderContents(XmlDictionaryWriter writer, IDictionary`2<string, string> context);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Channels.ContextMessageProperty : object {
    internal static string InstanceIdKey;
    public static string Name { get; }
    public IDictionary`2<string, string> Context { get; }
    internal static ContextMessageProperty Empty { get; }
    public ContextMessageProperty(IDictionary`2<string, string> context);
    public static string get_Name();
    public IDictionary`2<string, string> get_Context();
    internal static ContextMessageProperty get_Empty();
    public static bool TryCreateFromHttpCookieHeader(string httpCookieHeader, ContextMessageProperty& context);
    public static bool TryGet(Message message, ContextMessageProperty& contextMessageProperty);
    public static bool TryGet(MessageProperties properties, ContextMessageProperty& contextMessageProperty);
    public void AddOrReplaceInMessage(Message message);
    public void AddOrReplaceInMessageProperties(MessageProperties properties);
    public sealed virtual IMessageProperty CreateCopy();
}
internal class System.ServiceModel.Channels.ContextOutputChannel : ContextOutputChannelBase`1<IOutputChannel> {
    protected ContextProtocol ContextProtocol { get; }
    protected bool IsClient { get; }
    public ContextOutputChannel(ChannelManagerBase channelManager, IOutputChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
    protected virtual ContextProtocol get_ContextProtocol();
    protected virtual bool get_IsClient();
}
internal abstract class System.ServiceModel.Channels.ContextOutputChannelBase`1 : LayeredChannel`1<TChannel> {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected ContextProtocol ContextProtocol { get; }
    protected bool IsClient { get; }
    protected ContextOutputChannelBase`1(ChannelManagerBase channelManager, TChannel innerChannel);
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected abstract virtual ContextProtocol get_ContextProtocol();
    protected abstract virtual bool get_IsClient();
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message);
}
internal class System.ServiceModel.Channels.ContextOutputSessionChannel : ContextOutputChannelBase`1<IOutputSessionChannel> {
    public IOutputSession Session { get; }
    protected ContextProtocol ContextProtocol { get; }
    protected bool IsClient { get; }
    public ContextOutputSessionChannel(ChannelManagerBase channelManager, IOutputSessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
    public sealed virtual IOutputSession get_Session();
    protected virtual ContextProtocol get_ContextProtocol();
    protected virtual bool get_IsClient();
}
internal abstract class System.ServiceModel.Channels.ContextProtocol : object {
    protected ContextExchangeMechanism ContextExchangeMechanism { get; }
    protected ContextProtocol(ContextExchangeMechanism contextExchangeMechanism);
    protected ContextExchangeMechanism get_ContextExchangeMechanism();
    public abstract virtual void OnIncomingMessage(Message message);
    public abstract virtual void OnOutgoingMessage(Message message, RequestContext requestContext);
    protected void OnSendSoapContextHeader(Message message, ContextMessageProperty context);
}
internal class System.ServiceModel.Channels.ContextReplyChannel : LayeredChannel`1<IReplyChannel> {
    public EndpointAddress LocalAddress { get; }
    public ContextReplyChannel(ChannelManagerBase channelManager, IReplyChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ContextReplySessionChannel : LayeredChannel`1<IReplySessionChannel> {
    public EndpointAddress LocalAddress { get; }
    public IInputSession Session { get; }
    public ContextReplySessionChannel(ChannelManagerBase channelManager, IReplySessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual IInputSession get_Session();
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ContextRequestChannel : ContextRequestChannelBase`1<IRequestChannel> {
    public ContextRequestChannel(ChannelManagerBase channelManager, IRequestChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
}
internal abstract class System.ServiceModel.Channels.ContextRequestChannelBase`1 : LayeredChannel`1<TChannel> {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected ContextRequestChannelBase`1(ChannelManagerBase channelManager, TChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public virtual T GetProperty();
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual Message Request(Message message);
}
internal class System.ServiceModel.Channels.ContextRequestSessionChannel : ContextRequestChannelBase`1<IRequestSessionChannel> {
    public IOutputSession Session { get; }
    public ContextRequestSessionChannel(ChannelManagerBase channelManager, IRequestSessionChannel innerChannel, ContextExchangeMechanism contextExchangeMechanism, Uri callbackAddress, bool contextManagementEnabled);
    public sealed virtual IOutputSession get_Session();
}
public abstract class System.ServiceModel.Channels.CorrelationCallbackMessageProperty : object {
    public static string Name { get; }
    public bool IsFullyDefined { get; }
    public IEnumerable`1<string> NeededData { get; }
    protected CorrelationCallbackMessageProperty(ICollection`1<string> neededData);
    protected CorrelationCallbackMessageProperty(CorrelationCallbackMessageProperty callback);
    private static CorrelationCallbackMessageProperty();
    public static string get_Name();
    public bool get_IsFullyDefined();
    public IEnumerable`1<string> get_NeededData();
    public static bool TryGet(Message message, CorrelationCallbackMessageProperty& property);
    public static bool TryGet(MessageProperties properties, CorrelationCallbackMessageProperty& property);
    public void AddData(string name, Func`1<string> value);
    public IAsyncResult BeginFinalizeCorrelation(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IMessageProperty CreateCopy();
    public Message EndFinalizeCorrelation(IAsyncResult result);
    public Message FinalizeCorrelation(Message message, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginFinalizeCorrelation(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual Message OnEndFinalizeCorrelation(IAsyncResult result);
    protected abstract virtual Message OnFinalizeCorrelation(Message message, TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.CorrelationDataDescription : object {
    public bool IsOptional { get; }
    public bool IsDefault { get; }
    public bool KnownBeforeSend { get; }
    public string Name { get; }
    public bool ReceiveValue { get; }
    public bool SendValue { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_KnownBeforeSend();
    public abstract virtual string get_Name();
    public abstract virtual bool get_ReceiveValue();
    public abstract virtual bool get_SendValue();
}
public class System.ServiceModel.Channels.CorrelationDataMessageProperty : object {
    public static string Name { get; }
    public static string get_Name();
    public void Add(string name, Func`1<string> dataProvider);
    public bool Remove(string name);
    public bool TryGetValue(string name, String& value);
    public static bool TryGet(Message message, CorrelationDataMessageProperty& property);
    public static bool TryGet(MessageProperties properties, CorrelationDataMessageProperty& property);
    public static void AddData(Message message, string name, Func`1<string> dataProvider);
    public sealed virtual IMessageProperty CreateCopy();
}
internal class System.ServiceModel.Channels.CorrelationDataSourceHelper : object {
    private ICollection`1<CorrelationDataDescription> System.ServiceModel.Channels.ICorrelationDataSource.DataSources { get; }
    public CorrelationDataSourceHelper(ICollection`1<CorrelationDataDescription> dataSources);
    public static ICorrelationDataSource Combine(ICorrelationDataSource dataSource1, ICorrelationDataSource dataSource2);
    private sealed virtual override ICollection`1<CorrelationDataDescription> System.ServiceModel.Channels.ICorrelationDataSource.get_DataSources();
}
public class System.ServiceModel.Channels.CorrelationKey : InstanceKey {
    public IDictionary`2<string, string> KeyData { get; private set; }
    public XName ScopeName { get; private set; }
    public XNamespace Provider { get; private set; }
    public string KeyString { get; private set; }
    public string Name { get; public set; }
    public CorrelationKey(IDictionary`2<string, string> keyData, XName scopeName, XNamespace provider);
    private static CorrelationKey();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_KeyData();
    [CompilerGeneratedAttribute]
private void set_KeyData(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public XName get_ScopeName();
    [CompilerGeneratedAttribute]
private void set_ScopeName(XName value);
    [CompilerGeneratedAttribute]
public XNamespace get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(XNamespace value);
    [CompilerGeneratedAttribute]
public string get_KeyString();
    [CompilerGeneratedAttribute]
private void set_KeyString(string value);
    public string get_Name();
    public void set_Name(string value);
}
[DataContractAttribute]
public class System.ServiceModel.Channels.CorrelationMessageProperty : object {
    public static string Name { get; }
    public InstanceKey CorrelationKey { get; }
    public ReadOnlyCollection`1<InstanceKey> AdditionalKeys { get; }
    public ReadOnlyCollection`1<InstanceKey> TransientCorrelations { get; }
    [DataMemberAttribute]
internal InstanceKey SerializedCorrelationKey { get; internal set; }
    [DataMemberAttribute]
internal List`1<InstanceKey> SerializedAdditionalKeys { get; internal set; }
    [DataMemberAttribute]
internal List`1<InstanceKey> SerializedTransientCorrelations { get; internal set; }
    public CorrelationMessageProperty(InstanceKey correlationKey, IEnumerable`1<InstanceKey> additionalKeys);
    public CorrelationMessageProperty(InstanceKey correlationKey, IEnumerable`1<InstanceKey> additionalKeys, IEnumerable`1<InstanceKey> transientCorrelations);
    private static CorrelationMessageProperty();
    public static string get_Name();
    public InstanceKey get_CorrelationKey();
    public ReadOnlyCollection`1<InstanceKey> get_AdditionalKeys();
    public ReadOnlyCollection`1<InstanceKey> get_TransientCorrelations();
    public static bool TryGet(Message message, CorrelationMessageProperty& property);
    public static bool TryGet(MessageProperties properties, CorrelationMessageProperty& property);
    internal InstanceKey get_SerializedCorrelationKey();
    internal void set_SerializedCorrelationKey(InstanceKey value);
    internal List`1<InstanceKey> get_SerializedAdditionalKeys();
    internal void set_SerializedAdditionalKeys(List`1<InstanceKey> value);
    internal List`1<InstanceKey> get_SerializedTransientCorrelations();
    internal void set_SerializedTransientCorrelations(List`1<InstanceKey> value);
}
internal class System.ServiceModel.Channels.CreateSequence : BodyWriter {
    public CreateSequence(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion, bool ordered, IClientReliableChannelBinder binder, UniqueId offerIdentifier);
    public static CreateSequenceInfo Create(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, ISecureConversationSession securitySession, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CreateSequenceInfo : WsrmRequestInfo {
    public EndpointAddress AcksTo { get; public set; }
    public Nullable`1<TimeSpan> Expires { get; public set; }
    public Nullable`1<TimeSpan> OfferExpires { get; public set; }
    public UniqueId OfferIdentifier { get; public set; }
    public string RequestName { get; }
    public Uri To { get; }
    public EndpointAddress get_AcksTo();
    public void set_AcksTo(EndpointAddress value);
    public Nullable`1<TimeSpan> get_Expires();
    public void set_Expires(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_OfferExpires();
    public void set_OfferExpires(Nullable`1<TimeSpan> value);
    public UniqueId get_OfferIdentifier();
    public void set_OfferIdentifier(UniqueId value);
    public virtual string get_RequestName();
    public Uri get_To();
    public static CreateSequenceInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, ISecureConversationSession securitySession, Message message, MessageHeaders headers);
    public static void ValidateCreateSequenceHeaders(MessageVersion messageVersion, ISecureConversationSession securitySession, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.CreateSequenceResponse : BodyWriter {
    public EndpointAddress AcceptAcksTo { get; public set; }
    public Nullable`1<TimeSpan> Expires { get; public set; }
    public UniqueId Identifier { get; public set; }
    public bool Ordered { get; public set; }
    public CreateSequenceResponse(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    public EndpointAddress get_AcceptAcksTo();
    public void set_AcceptAcksTo(EndpointAddress value);
    public Nullable`1<TimeSpan> get_Expires();
    public void set_Expires(Nullable`1<TimeSpan> value);
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public static CreateSequenceResponseInfo Create(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CreateSequenceResponseInfo : object {
    public EndpointAddress AcceptAcksTo { get; public set; }
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    public EndpointAddress get_AcceptAcksTo();
    public void set_AcceptAcksTo(EndpointAddress value);
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public static CreateSequenceResponseInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, Message message, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.CriticalAllocHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static IntPtr op_Implicit(CriticalAllocHandle safeHandle);
    protected virtual bool ReleaseHandle();
    public static CriticalAllocHandle FromSize(int size);
}
internal class System.ServiceModel.Channels.CriticalAllocHandleBlob : CriticalAllocHandle {
    [SecuritySafeCriticalAttribute]
public static CriticalAllocHandle FromBlob(T id);
}
internal class System.ServiceModel.Channels.CriticalAllocHandleGuid : CriticalAllocHandle {
    public static CriticalAllocHandle FromGuid(Guid input);
}
internal class System.ServiceModel.Channels.CriticalAllocHandleSocketAddress : CriticalAllocHandle {
    public int Size { get; }
    public int get_Size();
    public static CriticalAllocHandleSocketAddress FromIPAddress(IPAddress input);
    public static CriticalAllocHandleSocketAddress FromSize(int size);
}
internal class System.ServiceModel.Channels.CriticalAllocHandleSocketAddressList : CriticalAllocHandle {
    public int Count { get; }
    public int Size { get; }
    public int get_Count();
    public int get_Size();
    public static CriticalAllocHandleSocketAddressList FromAddressList(ICollection`1<IPAddress> addresses);
    public static CriticalAllocHandleSocketAddressList FromAddressCount(int count);
    public ReadOnlyCollection`1<IPAddress> ToAddresses();
}
internal class System.ServiceModel.Channels.CryptoApiBlob : object {
    public int DataSize { get; }
    public CryptoApiBlob(Byte[] bytes);
    public int get_DataSize();
    public void AllocateBlob(int size);
    public InteropHelper GetMemoryForPinning();
    public Byte[] GetBytes();
    public sealed virtual void Dispose();
}
[ContentPropertyAttribute("Elements")]
public class System.ServiceModel.Channels.CustomBinding : Binding {
    public BindingElementCollection Elements { get; }
    public string Scheme { get; }
    public CustomBinding(string configurationName);
    public CustomBinding(BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(string name, string ns, BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(IEnumerable`1<BindingElement> bindingElementsInTopDownChannelStackOrder);
    internal CustomBinding(BindingElementCollection bindingElements);
    public CustomBinding(Binding binding);
    internal CustomBinding(Binding binding, BindingElementCollection elements);
    public BindingElementCollection get_Elements();
    public virtual BindingElementCollection CreateBindingElements();
    public virtual string get_Scheme();
}
internal class System.ServiceModel.Channels.DatagramAdapter : object {
    internal static IOutputChannel GetOutputChannel(Source`1<IOutputSessionChannel> channelSource, IDefaultCommunicationTimeouts timeouts);
    internal static IRequestChannel GetRequestChannel(Source`1<IRequestSessionChannel> channelSource, IDefaultCommunicationTimeouts timeouts);
    internal static IChannelListener`1<IInputChannel> GetInputListener(IChannelListener`1<IInputSessionChannel> inner, ServiceThrottle throttle, IDefaultCommunicationTimeouts timeouts);
    internal static IChannelListener`1<IReplyChannel> GetReplyListener(IChannelListener`1<IReplySessionChannel> inner, ServiceThrottle throttle, IDefaultCommunicationTimeouts timeouts);
}
internal abstract class System.ServiceModel.Channels.DatagramChannelDemuxer`2 : TypedChannelDemuxer {
    protected TInnerChannel InnerChannel { get; }
    protected IChannelListener`1<TInnerChannel> InnerListener { get; }
    protected object ThisLock { get; }
    protected IChannelDemuxFailureHandler DemuxFailureHandler { get; }
    public DatagramChannelDemuxer`2(BindingContext context);
    private static DatagramChannelDemuxer`2();
    protected TInnerChannel get_InnerChannel();
    protected IChannelListener`1<TInnerChannel> get_InnerListener();
    protected object get_ThisLock();
    protected IChannelDemuxFailureHandler get_DemuxFailureHandler();
    protected abstract virtual void AbortItem(TInnerItem item);
    protected abstract virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual LayeredChannelListener`1<TChannel> CreateListener(ChannelDemuxerFilter filter);
    protected abstract virtual void Dispatch(IChannelListener listener);
    protected abstract virtual void EndpointNotFound(TInnerItem item);
    protected abstract virtual TInnerItem EndReceive(IAsyncResult result);
    protected abstract virtual void EnqueueAndDispatch(IChannelListener listener, TInnerItem item, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected abstract virtual void EnqueueAndDispatch(IChannelListener listener, Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected abstract virtual Message GetMessage(TInnerItem item);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(ChannelDemuxerFilter filter);
    protected void HandleUnknownException(Exception exception);
    public sealed virtual void OnOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout);
    public sealed virtual IAsyncResult OnBeginOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnEndOuterListenerClose(IAsyncResult result);
    public sealed virtual void OnOuterListenerAbort(ChannelDemuxerFilter filter);
    public sealed virtual void OnOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout);
    public sealed virtual IAsyncResult OnBeginOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnEndOuterListenerOpen(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.DecoderHelper : object {
    public static void ValidateSize(int size);
}
internal class System.ServiceModel.Channels.DefaultMessageBuffer : MessageBuffer {
    public int BufferSize { get; }
    public DefaultMessageBuffer(Message message, XmlBuffer msgBuffer);
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal class System.ServiceModel.Channels.DefaultWebSocketConnectionHandler : WebSocketConnectionHandler {
    public DefaultWebSocketConnectionHandler(string subProtocol, string currentVersion, MessageVersion messageVersion, MessageEncoderFactory encoderFactory, TransferMode transferMode);
    protected internal virtual HttpResponseMessage AcceptWebSocket(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal abstract class System.ServiceModel.Channels.DelegatingChannelListener`1 : LayeredChannelListener`1<TChannel> {
    public IChannelAcceptor`1<TChannel> Acceptor { get; public set; }
    protected DelegatingChannelListener`1(IDefaultCommunicationTimeouts timeouts, IChannelListener innerChannelListener);
    protected DelegatingChannelListener`1(bool sharedInnerListener);
    protected DelegatingChannelListener`1(bool sharedInnerListener, IDefaultCommunicationTimeouts timeouts);
    protected DelegatingChannelListener`1(bool sharedInnerListener, IDefaultCommunicationTimeouts timeouts, IChannelListener innerChannelListener);
    public IChannelAcceptor`1<TChannel> get_Acceptor();
    public void set_Acceptor(IChannelAcceptor`1<TChannel> value);
    protected virtual TChannel OnAcceptChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual TChannel OnEndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.DelegatingConnection : object {
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    public TraceEventType ExceptionEventType { get; public set; }
    protected IConnection Connection { get; }
    public IPEndPoint RemoteIPEndPoint { get; }
    protected DelegatingConnection(IConnection connection);
    public virtual Byte[] get_AsyncReadBuffer();
    public virtual int get_AsyncReadBufferSize();
    public sealed virtual TraceEventType get_ExceptionEventType();
    public sealed virtual void set_ExceptionEventType(TraceEventType value);
    protected IConnection get_Connection();
    public sealed virtual IPEndPoint get_RemoteIPEndPoint();
    public virtual void Abort();
    public virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public virtual void Shutdown(TimeSpan timeout);
    public virtual object DuplicateAndClose(int targetProcessId);
    public virtual object GetCoreTransport();
    public virtual IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public virtual bool EndValidate(IAsyncResult result);
    public virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public virtual void EndWrite();
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public virtual int EndRead();
}
internal abstract class System.ServiceModel.Channels.DelegatingMessage : Message {
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    protected Message InnerMessage { get; }
    protected DelegatingMessage(Message innerMessage);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected Message get_InnerMessage();
    protected virtual void OnClose();
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Channels.DelegatingStream : Stream {
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult result);
    public virtual void EndWrite(IAsyncResult result);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public enum System.ServiceModel.Channels.DeliveryFailure : Enum {
    public int value__;
    public static DeliveryFailure Unknown;
    public static DeliveryFailure AccessDenied;
    public static DeliveryFailure BadDestinationQueue;
    public static DeliveryFailure BadEncryption;
    public static DeliveryFailure BadSignature;
    public static DeliveryFailure CouldNotEncrypt;
    public static DeliveryFailure HopCountExceeded;
    public static DeliveryFailure NotTransactionalQueue;
    public static DeliveryFailure NotTransactionalMessage;
    public static DeliveryFailure Purged;
    public static DeliveryFailure QueueDeleted;
    public static DeliveryFailure QueueExceedMaximumSize;
    public static DeliveryFailure QueuePurged;
    public static DeliveryFailure ReachQueueTimeout;
    public static DeliveryFailure ReceiveTimeout;
}
public enum System.ServiceModel.Channels.DeliveryStatus : Enum {
    public int value__;
    public static DeliveryStatus InDoubt;
    public static DeliveryStatus NotDelivered;
}
internal abstract class System.ServiceModel.Channels.DeliveryStrategy`1 : object {
    protected InputQueueChannel`1<ItemType> Channel { get; }
    public Action DequeueCallback { get; public set; }
    public int EnqueuedCount { get; }
    protected int Quota { get; }
    public DeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota);
    protected InputQueueChannel`1<ItemType> get_Channel();
    public Action get_DequeueCallback();
    public void set_DequeueCallback(Action value);
    public abstract virtual int get_EnqueuedCount();
    protected int get_Quota();
    public abstract virtual bool CanEnqueue(long sequenceNumber);
    public virtual void Dispose();
    public abstract virtual bool Enqueue(ItemType item, long sequenceNumber);
}
internal abstract class System.ServiceModel.Channels.DetectEofStream : DelegatingStream {
    protected bool IsAtEof { get; }
    protected DetectEofStream(Stream stream);
    protected bool get_IsAtEof();
    public virtual int EndRead(IAsyncResult result);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    protected virtual void OnReceivedEof();
}
internal abstract class System.ServiceModel.Channels.DictionaryHeader : MessageHeader {
    public string Name { get; }
    public string Namespace { get; }
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public virtual string get_Name();
    public virtual string get_Namespace();
    public abstract virtual XmlDictionaryString get_DictionaryName();
    public abstract virtual XmlDictionaryString get_DictionaryNamespace();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.DirectionalAction : object {
    public MessageDirection Direction { get; }
    public string Action { get; }
    internal DirectionalAction(MessageDirection direction, string action);
    public MessageDirection get_Direction();
    public string get_Action();
    public virtual bool Equals(object other);
    public bool Equals(DirectionalAction other);
    public sealed virtual int CompareTo(DirectionalAction other);
    public virtual int GetHashCode();
}
[MessageContractAttribute]
internal class System.ServiceModel.Channels.DisconnectInfo : object {
    public DisconnectReason Reason { get; }
    public IList`1<Referral> Referrals { get; }
    public DisconnectInfo(DisconnectReason reason, Referral[] referrals);
    public DisconnectReason get_Reason();
    public IList`1<Referral> get_Referrals();
    public bool HasBody();
}
internal enum System.ServiceModel.Channels.DisconnectReason : Enum {
    public int value__;
    public static DisconnectReason LeavingMesh;
    public static DisconnectReason NotUsefulNeighbor;
    public static DisconnectReason DuplicateNeighbor;
    public static DisconnectReason DuplicateNodeId;
    public static DisconnectReason NodeBusy;
    public static DisconnectReason InternalFailure;
}
internal static class System.ServiceModel.Channels.DnsCache : object {
    public static string MachineName { get; }
    private static DnsCache();
    public static string get_MachineName();
    public static IPHostEntry Resolve(Uri uri);
}
internal class System.ServiceModel.Channels.DoneReceivingAsyncResult : CompletedAsyncResult {
    internal DoneReceivingAsyncResult(AsyncCallback callback, object state);
    internal static bool End(DoneReceivingAsyncResult result, Message& message);
    internal static bool End(DoneReceivingAsyncResult result, RequestContext& requestContext);
    internal static bool End(DoneReceivingAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.DuplexChannel : InputQueueChannel`1<Message> {
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected DuplexChannel(ChannelManagerBase channelManager, EndpointAddress localAddress);
    public virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    protected abstract virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    protected virtual void AddHeadersTo(Message message);
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.DuplexChannelDemuxer : DatagramChannelDemuxer`2<IDuplexChannel, Message> {
    public DuplexChannelDemuxer(BindingContext context);
    protected virtual void AbortItem(Message message);
    protected virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual LayeredChannelListener`1<IDuplexChannel> CreateListener(ChannelDemuxerFilter filter);
    protected virtual void Dispatch(IChannelListener listener);
    protected virtual void EndpointNotFound(Message message);
    protected virtual Message EndReceive(IAsyncResult result);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, Message message, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual Message GetMessage(Message message);
}
internal class System.ServiceModel.Channels.DuplexOneWayChannelFactory : LayeredChannelFactory`1<IOutputChannel> {
    public DuplexOneWayChannelFactory(OneWayBindingElement bindingElement, BindingContext context);
    protected virtual IOutputChannel OnCreateChannel(EndpointAddress address, Uri via);
}
internal class System.ServiceModel.Channels.DuplexOneWayChannelListener : LayeredChannelListener`1<IInputChannel> {
    public DuplexOneWayChannelListener(OneWayBindingElement bindingElement, BindingContext context);
    protected virtual void OnOpening();
    protected virtual IInputChannel OnAcceptChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IInputChannel OnEndAcceptChannel(IAsyncResult result);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.DuplexSessionChannelDemuxer : SessionChannelDemuxer`2<IDuplexSessionChannel, Message> {
    public DuplexSessionChannelDemuxer(BindingContext context, TimeSpan peekTimeout, int maxPendingSessions);
    protected virtual void AbortItem(Message message);
    protected virtual IAsyncResult BeginReceive(IDuplexSessionChannel channel, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginReceive(IDuplexSessionChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IDuplexSessionChannel CreateChannel(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel, Message firstMessage);
    protected virtual void EndpointNotFound(IDuplexSessionChannel channel, Message message);
    protected virtual Message EndReceive(IDuplexSessionChannel channel, IAsyncResult result);
    protected virtual Message GetMessage(Message message);
}
internal class System.ServiceModel.Channels.DuplexSessionChannelWrapper : InputChannelWrapper {
    public IDuplexSession Session { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public DuplexSessionChannelWrapper(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel, Message firstMessage);
    public sealed virtual IDuplexSession get_Session();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
}
internal class System.ServiceModel.Channels.DuplexSessionDemuxFailureAsyncResult : AsyncResult {
    public DuplexSessionDemuxFailureAsyncResult(IChannelDemuxFailureHandler demuxFailureHandler, IDuplexSessionChannel channel, Message message, AsyncCallback callback, object state);
    private static DuplexSessionDemuxFailureAsyncResult();
    public void Start();
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.DuplexSessionOneWayChannelFactory : LayeredChannelFactory`1<IOutputChannel> {
    public DuplexSessionOneWayChannelFactory(OneWayBindingElement bindingElement, BindingContext context);
    internal ChannelPool`1<IDuplexSessionChannel> GetChannelPool(Boolean& cleanupChannelPool);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IOutputChannel OnCreateChannel(EndpointAddress address, Uri via);
}
internal class System.ServiceModel.Channels.DuplexSessionOneWayChannelListener : DelegatingChannelListener`1<IInputChannel> {
    public DuplexSessionOneWayChannelListener(OneWayBindingElement bindingElement, BindingContext context);
    private static DuplexSessionOneWayChannelListener();
    protected virtual void OnOpening();
    protected virtual void OnOpened();
    protected virtual void OnAbort();
}
internal class System.ServiceModel.Channels.EmptyBodyWriter : BodyWriter {
    public static EmptyBodyWriter Value { get; }
    internal bool IsEmpty { get; }
    public static EmptyBodyWriter get_Value();
    internal virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.EncodedContentType : EncodedFramingRecord {
    public static EncodedContentType Create(string contentType);
}
internal class System.ServiceModel.Channels.EncodedFault : EncodedFramingRecord {
    public EncodedFault(string fault);
}
internal abstract class System.ServiceModel.Channels.EncodedFramingRecord : object {
    public Byte[] EncodedBytes { get; }
    protected EncodedFramingRecord(Byte[] encodedBytes);
    internal EncodedFramingRecord(FramingRecordType recordType, string value);
    public Byte[] get_EncodedBytes();
    protected void SetEncodedBytes(Byte[] encodedBytes);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public bool Equals(EncodedFramingRecord other);
}
internal class System.ServiceModel.Channels.EncodedUpgrade : EncodedFramingRecord {
    public EncodedUpgrade(string contentType);
}
internal class System.ServiceModel.Channels.EncodedVia : EncodedFramingRecord {
    public EncodedVia(string via);
}
internal static class System.ServiceModel.Channels.EncoderDefaults : object {
    internal static int MaxReadPoolSize;
    internal static int MaxWritePoolSize;
    internal static int MaxDepth;
    internal static int MaxStringContentLength;
    internal static int MaxArrayLength;
    internal static int MaxBytesPerRead;
    internal static int MaxNameTableCharCount;
    internal static int BufferedReadDefaultMaxDepth;
    internal static int BufferedReadDefaultMaxStringContentLength;
    internal static int BufferedReadDefaultMaxArrayLength;
    internal static int BufferedReadDefaultMaxBytesPerRead;
    internal static int BufferedReadDefaultMaxNameTableCharCount;
    internal static CompressionFormat DefaultCompressionFormat;
    internal static XmlDictionaryReaderQuotas ReaderQuotas;
    private static EncoderDefaults();
    internal static bool IsDefaultReaderQuotas(XmlDictionaryReaderQuotas quotas);
}
internal static class System.ServiceModel.Channels.EncoderHelpers : object {
    internal static XmlDictionaryReaderQuotas GetBufferedReadQuotas(XmlDictionaryReaderQuotas encoderQuotas);
}
internal static class System.ServiceModel.Channels.EndpointSettings : object {
    internal static string ValidateOptionalClientCertificates;
    internal static T GetValue(BindingContext context, string name, T defaultValue);
    internal static T GetValue(BindingParameterCollection bindingParameters, string name, T defaultValue);
}
internal class System.ServiceModel.Channels.EndSendHandler : MulticastDelegate {
    public EndSendHandler(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult result);
    public virtual IAsyncResult BeginInvoke(IAsyncResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ErrorCallback : MulticastDelegate {
    public ErrorCallback(object object, IntPtr method);
    public virtual void Invoke(Exception exception);
    public virtual IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ExclusiveNamedPipeTransportManager : NamedPipeTransportManager {
    public ExclusiveNamedPipeTransportManager(Uri listenUri, NamedPipeChannelListener channelListener);
    internal virtual void OnOpen();
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
}
internal class System.ServiceModel.Channels.ExclusiveTcpTransportManager : TcpTransportManager {
    public IPAddress IPAddress { get; }
    public int ListenBacklog { get; }
    private int System.ServiceModel.Channels.ISocketListenerSettings.BufferSize { get; }
    private bool System.ServiceModel.Channels.ISocketListenerSettings.TeredoEnabled { get; }
    private int System.ServiceModel.Channels.ISocketListenerSettings.ListenBacklog { get; }
    public ExclusiveTcpTransportManager(ExclusiveTcpTransportManagerRegistration registration, TcpChannelListener channelListener, IPAddress ipAddressAny, UriHostNameType ipHostNameType);
    public IPAddress get_IPAddress();
    public int get_ListenBacklog();
    private sealed virtual override int System.ServiceModel.Channels.ISocketListenerSettings.get_BufferSize();
    private sealed virtual override bool System.ServiceModel.Channels.ISocketListenerSettings.get_TeredoEnabled();
    private sealed virtual override int System.ServiceModel.Channels.ISocketListenerSettings.get_ListenBacklog();
    internal virtual void OnOpen();
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
}
internal class System.ServiceModel.Channels.ExclusiveTcpTransportManagerRegistration : TransportManagerRegistration {
    public bool TeredoEnabled { get; }
    public ExclusiveTcpTransportManagerRegistration(Uri listenUri, TcpChannelListener channelListener);
    public bool get_TeredoEnabled();
    public void OnClose(TcpTransportManager manager);
    public virtual IList`1<TransportManager> Select(TransportChannelListener channelListener);
}
internal class System.ServiceModel.Channels.FaultBodyWriter : BodyWriter {
    internal bool IsFault { get; }
    public FaultBodyWriter(MessageFault fault, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.FaultConverter : object {
    public static FaultConverter GetDefaultFaultConverter(MessageVersion version);
    protected abstract virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected abstract virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
    public bool TryCreateException(Message message, MessageFault fault, Exception& exception);
    public bool TryCreateFaultMessage(Exception exception, Message& message);
}
internal abstract class System.ServiceModel.Channels.FaultHelper : object {
    protected object ThisLock { get; }
    protected object get_ThisLock();
    public abstract virtual void Abort();
    public static bool AddressReply(Message message, Message faultMessage);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void SendFaultAsync(IReliableChannelBinder binder, RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.FaultState : ValueType {
    private Message faultMessage;
    private RequestContext requestContext;
    public Message FaultMessage { get; }
    public RequestContext RequestContext { get; }
    public FaultState(RequestContext requestContext, Message faultMessage);
    public Message get_FaultMessage();
    public RequestContext get_RequestContext();
}
internal class System.ServiceModel.Channels.FaultStringDecoder : StringDecoder {
    internal static int FaultSizeQuota;
    protected virtual Exception OnSizeQuotaExceeded(int size);
    public static Exception GetFaultException(string faultString, string via, string contentType);
}
internal class System.ServiceModel.Channels.FaultToHeader : AddressingHeader {
    public EndpointAddress FaultTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public EndpointAddress get_FaultTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FaultToHeader Create(EndpointAddress faultTo, AddressingVersion addressingVersion);
    public static FaultToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
internal class System.ServiceModel.Channels.FloodAsyncResult : AsyncResult {
    private object ThisLock { get; }
    public FloodAsyncResult(PeerNeighborManager owner, TimeSpan timeout, AsyncCallback callback, object state);
    [CompilerGeneratedAttribute]
public void add_OnMessageSent(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnMessageSent(EventHandler value);
    private object get_ThisLock();
    public void AddResult(IAsyncResult result, IPeerNeighbor neighbor);
    public void End();
    public void MarkEnd(bool success);
    internal void OnSendComplete(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.FramingDecoder : object {
    protected string CurrentStateAsString { get; }
    public long StreamPosition { get; public set; }
    protected FramingDecoder(long streamPosition);
    protected abstract virtual string get_CurrentStateAsString();
    public long get_StreamPosition();
    public void set_StreamPosition(long value);
    protected void ValidateFramingMode(FramingMode mode);
    protected void ValidateRecordType(FramingRecordType expectedType, FramingRecordType foundType);
    protected void ValidatePreambleAck(FramingRecordType foundType);
    protected void ValidateMajorVersion(int majorVersion);
    public Exception CreatePrematureEOFException();
    protected Exception CreateException(InvalidDataException innerException, string framingFault);
    protected Exception CreateException(InvalidDataException innerException);
}
internal abstract class System.ServiceModel.Channels.FramingDuplexSessionChannel : TransportDuplexSessionChannel {
    protected IConnection Connection { get; protected set; }
    protected bool IsStreamedOutput { get; }
    protected FramingDuplexSessionChannel(ChannelManagerBase factory, IConnectionOrientedTransportFactorySettings settings, EndpointAddress remoteAddresss, Uri via, bool exposeConnectionProperty);
    protected FramingDuplexSessionChannel(ConnectionOrientedTransportChannelListener channelListener, EndpointAddress localAddress, Uri localVia, bool exposeConnectionProperty);
    protected IConnection get_Connection();
    protected void set_Connection(IConnection value);
    protected virtual bool get_IsStreamedOutput();
    protected virtual void CloseOutputSessionCore(TimeSpan timeout);
    protected virtual void CompleteClose(TimeSpan timeout);
    protected virtual void PrepareMessage(Message message);
    protected virtual void OnSendCore(Message message, TimeSpan timeout);
    protected virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, WaitCallback callback, object state);
    protected virtual void FinishWritingMessage();
    protected virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, WaitCallback callback, object state);
    protected virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, WaitCallback callback, object state);
    protected virtual ArraySegment`1<byte> EncodeMessage(Message message);
}
internal static class System.ServiceModel.Channels.FramingEncodingString : object {
    public static string Soap11Utf8;
    public static string Soap11Utf16;
    public static string Soap11Utf16FFFE;
    public static string Soap12Utf8;
    public static string Soap12Utf16;
    public static string Soap12Utf16FFFE;
    public static string MTOM;
    public static string Binary;
    public static string BinarySession;
    public static string ExtendedBinaryGZip;
    public static string ExtendedBinarySessionGZip;
    public static string ExtendedBinaryDeflate;
    public static string ExtendedBinarySessionDeflate;
    public static string NamespaceUri;
    public static string ContentTypeInvalidFault;
    public static string ContentTypeTooLongFault;
    public static string ConnectionDispatchFailedFault;
    public static string EndpointNotFoundFault;
    public static string EndpointUnavailableFault;
    public static string MaxMessageSizeExceededFault;
    public static string ServerTooBusyFault;
    public static string ServiceActivationFailedFault;
    public static string UnsupportedModeFault;
    public static string UnsupportedVersionFault;
    public static string UpgradeInvalidFault;
    public static string ViaTooLongFault;
    public static bool TryGetFaultString(Exception exception, String& framingFault);
    public static void AddFaultString(Exception exception, string framingFault);
}
internal enum System.ServiceModel.Channels.FramingEncodingType : Enum {
    public int value__;
    public static FramingEncodingType Soap11Utf8;
    public static FramingEncodingType Soap11Utf16;
    public static FramingEncodingType Soap11Utf16FFFE;
    public static FramingEncodingType Soap12Utf8;
    public static FramingEncodingType Soap12Utf16;
    public static FramingEncodingType Soap12Utf16FFFE;
    public static FramingEncodingType MTOM;
    public static FramingEncodingType Binary;
    public static FramingEncodingType BinarySession;
}
internal enum System.ServiceModel.Channels.FramingMode : Enum {
    public int value__;
    public static FramingMode Singleton;
    public static FramingMode Duplex;
    public static FramingMode Simplex;
    public static FramingMode SingletonSized;
}
internal enum System.ServiceModel.Channels.FramingRecordType : Enum {
    public int value__;
    public static FramingRecordType Version;
    public static FramingRecordType Mode;
    public static FramingRecordType Via;
    public static FramingRecordType KnownEncoding;
    public static FramingRecordType ExtensibleEncoding;
    public static FramingRecordType UnsizedEnvelope;
    public static FramingRecordType SizedEnvelope;
    public static FramingRecordType End;
    public static FramingRecordType Fault;
    public static FramingRecordType UpgradeRequest;
    public static FramingRecordType UpgradeResponse;
    public static FramingRecordType PreambleAck;
    public static FramingRecordType PreambleEnd;
}
internal static class System.ServiceModel.Channels.FramingUpgradeString : object {
    public static string SslOrTls;
    public static string Negotiate;
}
internal static class System.ServiceModel.Channels.FramingVersion : object {
    public static int Major;
    public static int Minor;
}
internal class System.ServiceModel.Channels.FromHeader : AddressingHeader {
    public EndpointAddress From { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public EndpointAddress get_From();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static FromHeader Create(EndpointAddress from, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FromHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
}
internal class System.ServiceModel.Channels.Guard : object {
    public Guard(int maxCount);
    public void Abort();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void Close(TimeSpan timeout);
    public void EndClose(IAsyncResult result);
    public bool Enter();
    public void Exit();
}
internal class System.ServiceModel.Channels.HeaderInfoCache : object {
    public MessageHeaderInfo TakeHeaderInfo(XmlDictionaryReader reader, string actor, bool mustUnderstand, bool relay, bool isRefParam);
    public void ReturnHeaderInfo(MessageHeaderInfo headerInfo);
}
internal enum System.ServiceModel.Channels.HttpAbortReason : Enum {
    public int value__;
    public static HttpAbortReason None;
    public static HttpAbortReason Aborted;
    public static HttpAbortReason TimedOut;
}
internal class System.ServiceModel.Channels.HttpAnonymousUriPrefixMatcher : object {
    internal HttpAnonymousUriPrefixMatcher(HttpAnonymousUriPrefixMatcher objectToClone);
    public sealed virtual void Register(Uri anonymousUriPrefix);
    internal bool IsAnonymousUri(Uri to);
}
internal class System.ServiceModel.Channels.HttpChannelFactory`1 : TransportChannelFactory`1<TChannel> {
    public bool AllowCookies { get; }
    public AuthenticationSchemes AuthenticationScheme { get; }
    public bool DecompressionEnabled { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    public bool KeepAliveEnabled { get; }
    public SecurityTokenManager SecurityTokenManager { get; }
    public int MaxBufferSize { get; }
    public IWebProxy Proxy { get; }
    public TransferMode TransferMode { get; }
    public string Scheme { get; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    internal string WebSocketSoapContentType { get; }
    protected ConnectionBufferPool WebSocketBufferPool { get; }
    private int System.ServiceModel.Channels.IHttpTransportFactorySettings.MaxBufferSize { get; }
    private TransferMode System.ServiceModel.Channels.IHttpTransportFactorySettings.TransferMode { get; }
    protected ClientWebSocketFactory ClientWebSocketFactory { get; }
    internal HttpChannelFactory`1(HttpTransportBindingElement bindingElement, BindingContext context);
    private static HttpChannelFactory`1();
    public bool get_AllowCookies();
    public AuthenticationSchemes get_AuthenticationScheme();
    public bool get_DecompressionEnabled();
    public virtual bool get_IsChannelBindingSupportEnabled();
    public bool get_KeepAliveEnabled();
    public SecurityTokenManager get_SecurityTokenManager();
    public int get_MaxBufferSize();
    public IWebProxy get_Proxy();
    public TransferMode get_TransferMode();
    public virtual string get_Scheme();
    public WebSocketTransportSettings get_WebSocketSettings();
    internal string get_WebSocketSoapContentType();
    protected ConnectionBufferPool get_WebSocketBufferPool();
    private sealed virtual override int System.ServiceModel.Channels.IHttpTransportFactorySettings.get_MaxBufferSize();
    private sealed virtual override TransferMode System.ServiceModel.Channels.IHttpTransportFactorySettings.get_TransferMode();
    protected ClientWebSocketFactory get_ClientWebSocketFactory();
    public virtual T GetProperty();
    internal virtual SecurityMessageProperty CreateReplySecurityProperty(HttpWebRequest request, HttpWebResponse response);
    internal Exception CreateToMustEqualViaException(Uri to, Uri via);
    internal virtual int GetMaxBufferSize();
    protected virtual void ValidateCreateChannelParameters(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannelCore(EndpointAddress remoteAddress, Uri via);
    protected void ValidateWebSocketTransportUsage();
    protected virtual bool IsSecurityTokenManagerRequired();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnClosed();
    internal static void TraceResponseReceived(HttpWebResponse response, Message message, object receiver);
    protected virtual string OnGetConnectionGroupPrefix(HttpWebRequest httpWebRequest, SecurityTokenContainer clientCertificateToken);
    internal static bool IsWindowsAuth(AuthenticationSchemes authScheme);
    internal void CreateAndOpenTokenProviders(EndpointAddress to, Uri via, ChannelParameterCollection channelParameters, TimeSpan timeout, SecurityTokenProviderContainer& tokenProvider, SecurityTokenProviderContainer& proxyTokenProvider);
    internal HttpWebRequest GetWebRequest(EndpointAddress to, Uri via, SecurityTokenProviderContainer tokenProvider, SecurityTokenProviderContainer proxyTokenProvider, SecurityTokenContainer clientCertificateToken, TimeSpan timeout, bool isWebSocketRequest);
    internal static bool MapIdentity(EndpointAddress target, AuthenticationSchemes authenticationScheme);
}
internal abstract class System.ServiceModel.Channels.HttpChannelListener : TransportChannelListener {
    public TimeSpan RequestInitializationTimeout { get; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    public HttpMessageSettings HttpMessageSettings { get; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    public bool UseWebSocketTransport { get; }
    internal HttpAnonymousUriPrefixMatcher AnonymousUriPrefixMatcher { get; }
    protected SecurityTokenAuthenticator UserNameTokenAuthenticator { get; }
    public AuthenticationSchemes AuthenticationScheme { get; }
    public bool KeepAliveEnabled { get; }
    public bool ExtractGroupsForWindowsAccounts { get; }
    public HostNameComparisonMode HostNameComparisonMode { get; }
    protected bool IsAuthenticationSupported { get; }
    public int MaxBufferSize { get; }
    public int MaxPendingAccepts { get; }
    public string Method { get; }
    public TransferMode TransferMode { get; }
    public string Realm { get; }
    private int System.ServiceModel.Channels.IHttpTransportFactorySettings.MaxBufferSize { get; }
    private TransferMode System.ServiceModel.Channels.IHttpTransportFactorySettings.TransferMode { get; }
    public string Scheme { get; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    public HttpChannelListener(HttpTransportBindingElement bindingElement, BindingContext context);
    private static HttpChannelListener();
    public TimeSpan get_RequestInitializationTimeout();
    public WebSocketTransportSettings get_WebSocketSettings();
    public HttpMessageSettings get_HttpMessageSettings();
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public virtual bool get_IsChannelBindingSupportEnabled();
    public abstract virtual bool get_UseWebSocketTransport();
    internal HttpAnonymousUriPrefixMatcher get_AnonymousUriPrefixMatcher();
    protected SecurityTokenAuthenticator get_UserNameTokenAuthenticator();
    internal virtual void ApplyHostedContext(string virtualPath, bool isMetadataListener);
    public AuthenticationSchemes get_AuthenticationScheme();
    public bool get_KeepAliveEnabled();
    public bool get_ExtractGroupsForWindowsAccounts();
    public HostNameComparisonMode get_HostNameComparisonMode();
    protected bool get_IsAuthenticationSupported();
    public int get_MaxBufferSize();
    public int get_MaxPendingAccepts();
    public virtual string get_Method();
    public TransferMode get_TransferMode();
    public string get_Realm();
    private sealed virtual override int System.ServiceModel.Channels.IHttpTransportFactorySettings.get_MaxBufferSize();
    private sealed virtual override TransferMode System.ServiceModel.Channels.IHttpTransportFactorySettings.get_TransferMode();
    public virtual string get_Scheme();
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    public bool get_UnsafeConnectionNtlmAuthentication();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    protected string GetAuthType(IHttpAuthenticationContext authenticationContext);
    internal virtual int GetMaxBufferSize();
    public virtual T GetProperty();
    internal abstract virtual IAsyncResult BeginHttpContextReceived(HttpRequestContext context, Action acceptorCallback, AsyncCallback callback, object state);
    internal abstract virtual bool EndHttpContextReceived(IAsyncResult result);
    protected virtual void OnOpened();
    protected void CloseUserNameTokenAuthenticator(TimeSpan timeout);
    protected void AbortUserNameTokenAuthenticator();
    public virtual SecurityMessageProperty ProcessAuthentication(IHttpAuthenticationContext authenticationContext);
    public virtual SecurityMessageProperty ProcessAuthentication(HttpListenerContext listenerContext);
    protected virtual bool TryGetTransportManagerRegistration(HostNameComparisonMode hostNameComparisonMode, ITransportManagerRegistration& registration);
    protected void WriteAuditEvent(AuditLevel auditLevel, string primaryIdentity, Exception exception);
    public virtual HttpStatusCode ValidateAuthentication(IHttpAuthenticationContext authenticationContext);
    public virtual HttpStatusCode ValidateAuthentication(HttpListenerContext listenerContext);
    public abstract virtual bool CreateWebSocketChannelAndEnqueue(HttpRequestContext httpRequestContext, HttpPipeline httpPipeline, HttpResponseMessage httpResponseMessage, string subProtocol, Action dequeuedCallback);
    public abstract virtual Byte[] TakeWebSocketInternalBuffer();
    public abstract virtual void ReturnWebSocketInternalBuffer(Byte[] buffer);
}
internal class System.ServiceModel.Channels.HttpChannelListener`1 : HttpChannelListener {
    public bool UseWebSocketTransport { get; }
    public InputQueueChannelAcceptor`1<TChannel> Acceptor { get; }
    public string Method { get; }
    public HttpChannelListener`1(HttpTransportBindingElement bindingElement, BindingContext context);
    public virtual bool get_UseWebSocketTransport();
    public InputQueueChannelAcceptor`1<TChannel> get_Acceptor();
    public virtual string get_Method();
    public sealed virtual TChannel AcceptChannel();
    public sealed virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public sealed virtual TChannel AcceptChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual TChannel EndAcceptChannel(IAsyncResult result);
    public virtual bool CreateWebSocketChannelAndEnqueue(HttpRequestContext httpRequestContext, HttpPipeline pipeline, HttpResponseMessage httpResponseMessage, string subProtocol, Action dequeuedCallback);
    public virtual Byte[] TakeWebSocketInternalBuffer();
    public virtual void ReturnWebSocketInternalBuffer(Byte[] buffer);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnAbort();
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    internal virtual IAsyncResult BeginHttpContextReceived(HttpRequestContext context, Action acceptorCallback, AsyncCallback callback, object state);
    internal virtual bool EndHttpContextReceived(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.HttpChannelUtilities : object {
    internal static string HttpStatusCodeKey;
    internal static string HttpStatusCodeExceptionKey;
    internal static string HttpStatusDescriptionExceptionKey;
    internal static int ResponseStreamExcerptSize;
    internal static string MIMEVersionHeader;
    internal static string ContentEncodingHeader;
    internal static string AcceptEncodingHeader;
    private static HttpChannelUtilities();
    public static Exception CreateCommunicationException(HttpListenerException listenerException);
    public static void EnsureHttpRequestMessageContentNotNull(HttpRequestMessage httpRequestMessage);
    public static void EnsureHttpResponseMessageContentNotNull(HttpResponseMessage httpResponseMessage);
    public static bool IsEmpty(HttpResponseMessage httpResponseMessage);
    internal static void HandleContinueWithTask(Task task);
    internal static void HandleContinueWithTask(Task task, Action`1<Exception> exceptionHandler);
    public static void AbortRequest(HttpWebRequest request);
    public static void SetRequestTimeout(HttpWebRequest request, TimeSpan timeout);
    public static void AddReplySecurityProperty(HttpChannelFactory`1<IRequestChannel> factory, HttpWebRequest webRequest, HttpWebResponse webResponse, Message replyMessage);
    public static void CopyHeaders(HttpRequestMessage request, AddHeaderDelegate addHeader);
    public static void CopyHeaders(HttpResponseMessage response, AddHeaderDelegate addHeader);
    public static void CopyHeaders(NameValueCollection headers, AddHeaderDelegate addHeader);
    public static void CopyHeadersToNameValueCollection(NameValueCollection headers, NameValueCollection destination);
    internal static Type GetTypeFromAssembliesInCurrentDomain(string typeString);
    public static NetworkCredential GetCredential(AuthenticationSchemes authenticationScheme, SecurityTokenProviderContainer credentialProvider, TimeSpan timeout, TokenImpersonationLevel& impersonationLevel, AuthenticationLevel& authenticationLevel);
    public static HttpWebResponse ProcessGetResponseWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason);
    public static Exception ConvertWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason);
    public static Exception CreateResponseIOException(IOException ioException, TimeSpan receiveTimeout);
    public static Exception CreateResponseWebException(WebException webException, HttpWebResponse response);
    public static Exception CreateRequestCanceledException(Exception webException, HttpWebRequest request, HttpAbortReason abortReason);
    public static Exception CreateRequestIOException(IOException ioException, HttpWebRequest request);
    public static Exception CreateRequestIOException(IOException ioException, HttpWebRequest request, Exception originalException);
    public static Exception CreateRequestWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason);
    public static Exception CreateNullReferenceResponseException(NullReferenceException nullReferenceException);
    public static void ValidateDigestCredential(NetworkCredential& credential, TokenImpersonationLevel impersonationLevel);
    public static HttpInput ValidateRequestReplyResponse(HttpWebRequest request, HttpWebResponse response, HttpChannelFactory`1<IRequestChannel> factory, WebException responseException, ChannelBinding channelBinding);
    public static bool GetHttpResponseTypeAndEncodingForCompression(String& contentType, String& contentEncoding);
}
[ObsoleteAttribute("This type is obsolete. To enable the Http CookieContainer, use the AllowCookies property on the http binding or on the HttpTransportBindingElement.", "False")]
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Channels.HttpCookieContainerBindingElement : BindingElement {
    [ObsoleteAttribute("This type is obsolete. To enable the Http CookieContainer, use the AllowCookies property on the http binding or on the HttpTransportBindingElement.", "False")]
[EditorBrowsableAttribute("1")]
protected HttpCookieContainerBindingElement(HttpCookieContainerBindingElement elementToBeCloned);
    [EditorBrowsableAttribute("1")]
public virtual BindingElement Clone();
    [EditorBrowsableAttribute("1")]
public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    [EditorBrowsableAttribute("1")]
public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.Channels.HttpCookieContainerManager : object {
    public bool IsInitialized { get; private set; }
    public CookieContainer CookieContainer { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual CookieContainer get_CookieContainer();
    public sealed virtual void set_CookieContainer(CookieContainer value);
}
internal abstract class System.ServiceModel.Channels.HttpDelayedAcceptStream : DetectEofStream {
    protected HttpDelayedAcceptStream(Stream stream);
    public bool EnableDelayedAccept(HttpOutput output, bool closeHttpOutput);
    protected virtual void OnReceivedEof();
    public virtual void Close();
}
internal class System.ServiceModel.Channels.HttpHeaderInfo : object {
    public string Name { get; private set; }
    public bool IsRequestHeader { get; private set; }
    public bool IsResponseHeader { get; private set; }
    public bool IsContentHeader { get; private set; }
    private static HttpHeaderInfo();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRequestHeader();
    [CompilerGeneratedAttribute]
private void set_IsRequestHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsResponseHeader();
    [CompilerGeneratedAttribute]
private void set_IsResponseHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsContentHeader();
    [CompilerGeneratedAttribute]
private void set_IsContentHeader(bool value);
    public static HttpHeaderInfo Create(string headerName);
    public bool TryAddHeader(HttpHeaders headers, string value);
    public bool TryRemoveHeader(HttpHeaders headers);
    public IEnumerable`1<string> TryGetHeader(HttpHeaders headers);
}
internal class System.ServiceModel.Channels.HttpHeadersWebHeaderCollection : WebHeaderCollection {
    public String[] AllKeys { get; }
    public int Count { get; }
    public KeysCollection Keys { get; }
    public HttpHeadersWebHeaderCollection(HttpRequestMessage httpRequestMessage);
    public HttpHeadersWebHeaderCollection(HttpResponseMessage httpResponseMessage);
    private static HttpHeadersWebHeaderCollection();
    public virtual String[] get_AllKeys();
    public virtual int get_Count();
    public virtual KeysCollection get_Keys();
    public virtual void Add(string name, string value);
    public virtual void Clear();
    public virtual void Remove(string name);
    public virtual void Set(string name, string value);
    public virtual IEnumerator GetEnumerator();
    public virtual string Get(int index);
    public virtual string GetKey(int index);
    public virtual String[] GetValues(int index);
    public virtual string Get(string name);
    public virtual string ToString();
    public virtual String[] GetValues(string header);
    private static string CheckBadChars(string name, bool isHeaderValue);
    private static bool ContainsNonAsciiChars(string token);
}
internal abstract class System.ServiceModel.Channels.HttpInput : object {
    internal WebException WebException { get; internal set; }
    public long ContentLength { get; }
    protected string ContentTypeCore { get; }
    protected bool HasContent { get; }
    protected string SoapActionHeader { get; }
    protected ChannelBinding ChannelBinding { get; }
    protected string ContentType { get; }
    protected HttpInput(IHttpTransportFactorySettings settings, bool isRequest, bool enableChannelBinding);
    internal static HttpInput CreateHttpInput(HttpWebResponse httpWebResponse, IHttpTransportFactorySettings settings, ChannelBinding channelBinding);
    internal WebException get_WebException();
    internal void set_WebException(WebException value);
    public Stream GetInputStream(bool throwOnError);
    public abstract virtual long get_ContentLength();
    protected abstract virtual string get_ContentTypeCore();
    protected abstract virtual bool get_HasContent();
    protected abstract virtual string get_SoapActionHeader();
    protected abstract virtual Stream GetInputStream();
    protected virtual ChannelBinding get_ChannelBinding();
    protected string get_ContentType();
    protected abstract virtual void AddProperties(Message message);
    public IAsyncResult BeginParseIncomingMessage(AsyncCallback callback, object state);
    public IAsyncResult BeginParseIncomingMessage(HttpRequestMessage httpRequestMessage, AsyncCallback callback, object state);
    public Message EndParseIncomingMessage(IAsyncResult result, Exception& requestException);
    public HttpRequestMessageHttpInput CreateHttpRequestMessageInput();
    public abstract virtual void ConfigureHttpRequestMessage(HttpRequestMessage message);
    public Message ParseIncomingMessage(Exception& requestException);
    public Message ParseIncomingMessage(HttpRequestMessage httpRequestMessage, Exception& requestException);
    internal static ProtocolException CreateHttpProtocolException(string message, HttpStatusCode statusCode, string statusDescription, Exception innerException);
    protected virtual void Close();
}
public class System.ServiceModel.Channels.HttpMessageHandlerFactory : object {
    [SecuritySafeCriticalAttribute]
public HttpMessageHandlerFactory(Type[] handlers);
    [SecuritySafeCriticalAttribute]
public HttpMessageHandlerFactory(Func`1<IEnumerable`1<DelegatingHandler>> handlers);
    private static HttpMessageHandlerFactory();
    [SecuritySafeCriticalAttribute]
public HttpMessageHandler Create(HttpMessageHandler innerChannel);
    internal static HttpMessageHandlerFactory CreateFromConfigurationElement(HttpMessageHandlerFactoryElement configElement);
    internal HttpMessageHandlerFactoryElement GenerateConfigurationElement();
    protected virtual HttpMessageHandler OnCreate(HttpMessageHandler innerChannel);
}
public class System.ServiceModel.Channels.HttpMessageSettings : object {
    public bool HttpMessagesSupported { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HttpMessagesSupported();
    [CompilerGeneratedAttribute]
public void set_HttpMessagesSupported(bool value);
    public sealed virtual bool Equals(HttpMessageSettings other);
}
internal abstract class System.ServiceModel.Channels.HttpOutput : object {
    protected bool IsChannelBindingSupportEnabled { get; }
    protected ChannelBinding ChannelBinding { get; }
    protected bool CleanupChannelBinding { get; }
    protected string HttpMethod { get; }
    protected bool WillGetOutputStreamCompleteSynchronously { get; }
    protected bool CanSendCompressedResponses { get; }
    protected HttpOutput(IHttpTransportFactorySettings settings, Message message, bool isRequest, bool supportsConcurrentIO);
    protected virtual bool get_IsChannelBindingSupportEnabled();
    protected virtual ChannelBinding get_ChannelBinding();
    protected void Abort();
    public virtual void Abort(HttpAbortReason reason);
    public void Close();
    protected abstract virtual void AddMimeVersion(string version);
    protected abstract virtual void AddHeader(string name, string value);
    protected abstract virtual void SetContentType(string contentType);
    protected abstract virtual void SetContentEncoding(string contentEncoding);
    protected abstract virtual void SetStatusCode(HttpStatusCode statusCode);
    protected abstract virtual void SetStatusDescription(string statusDescription);
    protected virtual bool get_CleanupChannelBinding();
    protected virtual void SetContentLength(int contentLength);
    protected virtual string get_HttpMethod();
    public virtual ChannelBinding TakeChannelBinding();
    protected abstract virtual Stream GetOutputStream();
    protected virtual bool get_WillGetOutputStreamCompleteSynchronously();
    protected bool get_CanSendCompressedResponses();
    protected virtual IAsyncResult BeginGetOutputStream(AsyncCallback callback, object state);
    protected virtual Stream EndGetOutputStream(IAsyncResult result);
    public void ConfigureHttpResponseMessage(Message message, HttpResponseMessage httpResponseMessage, HttpResponseMessageProperty responseProperty);
    protected virtual bool PrepareHttpSend(Message message);
    protected bool PrepareHttpSend(HttpResponseMessage httpResponseMessage);
    protected abstract virtual void PrepareHttpSendCore(HttpResponseMessage message);
    public IAsyncResult BeginSend(HttpResponseMessage httpResponseMessage, TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndSend(IAsyncResult result);
    public void Send(HttpResponseMessage httpResponseMessage, TimeSpan timeout);
    public void Send(TimeSpan timeout);
    internal static HttpOutput CreateHttpOutput(HttpWebRequest httpWebRequest, IHttpTransportFactorySettings settings, Message message, bool enableChannelBindingSupport);
    internal static HttpOutput CreateHttpOutput(HttpListenerResponse httpListenerResponse, IHttpTransportFactorySettings settings, Message message, string httpMethod);
}
internal abstract class System.ServiceModel.Channels.HttpPipeline : object {
    public HttpInput HttpInput { get; }
    internal bool IsHttpInputInitialized { get; }
    internal EventTraceActivity EventTraceActivity { get; }
    protected HttpRequestContext HttpRequestContext { get; }
    public HttpPipeline(HttpRequestContext httpRequestContext);
    public HttpInput get_HttpInput();
    internal bool get_IsHttpInputInitialized();
    internal EventTraceActivity get_EventTraceActivity();
    protected HttpRequestContext get_HttpRequestContext();
    public static HttpPipeline CreateHttpPipeline(HttpRequestContext httpRequestContext, TransportIntegrationHandler transportIntegrationHandler, bool isWebSocketTransport);
    public static HttpPipeline GetHttpPipeline(HttpRequestMessage httpRequestMessage);
    public static void RemoveHttpPipeline(HttpRequestMessage httpRequestMessage);
    public abstract virtual Task`1<HttpResponseMessage> Dispatch(HttpRequestMessage httpRequestMessage);
    public abstract virtual void SendReply(Message message, TimeSpan timeout);
    public virtual AsyncCompletionResult SendAsyncReply(Message message, Action`2<object, HttpResponseMessage> asyncSendCallback, object state);
    public void Close();
    public virtual void Cancel();
    internal abstract virtual IAsyncResult BeginProcessInboundRequest(ReplyChannelAcceptor replyChannelAcceptor, Action dequeuedCallback, AsyncCallback callback, object state);
    internal abstract virtual void EndProcessInboundRequest(IAsyncResult result);
    protected abstract virtual IAsyncResult BeginParseIncomingMessage(AsyncCallback asynCallback, object state);
    protected abstract virtual Message EndParseIncomingMesssage(IAsyncResult result, Exception& requestException);
    protected abstract virtual void OnParseComplete(Message message, Exception requestException);
    protected virtual void OnClose();
    protected void TraceProcessInboundRequestStart();
    protected void TraceBeginProcessInboundRequestStart();
    protected void TraceProcessInboundRequestStop();
    protected void TraceProcessResponseStart();
    protected void TraceBeginProcessResponseStart();
    protected void TraceProcessResponseStop();
    protected virtual HttpInput GetHttpInput();
    protected HttpOutput GetHttpOutput(Message message);
}
internal class System.ServiceModel.Channels.HttpPipelineCancellationTokenSource : CancellationTokenSource {
    public HttpPipelineCancellationTokenSource(HttpRequestContext httpRequestContext);
    private static HttpPipelineCancellationTokenSource();
}
internal abstract class System.ServiceModel.Channels.HttpRequestContext : RequestContextBase {
    public bool KeepAliveEnabled { get; }
    public bool HttpMessagesSupported { get; }
    public string HttpMethod { get; }
    public bool IsWebSocketRequest { get; }
    internal ServerWebSocketTransportDuplexSessionChannel WebSocketChannel { get; internal set; }
    internal HttpChannelListener Listener { get; }
    internal EventTraceActivity EventTraceActivity { get; }
    protected HttpRequestContext(HttpChannelListener listener, Message requestMessage, EventTraceActivity eventTraceActivity);
    public bool get_KeepAliveEnabled();
    public bool get_HttpMessagesSupported();
    public abstract virtual string get_HttpMethod();
    public abstract virtual bool get_IsWebSocketRequest();
    internal ServerWebSocketTransportDuplexSessionChannel get_WebSocketChannel();
    internal void set_WebSocketChannel(ServerWebSocketTransportDuplexSessionChannel value);
    internal HttpChannelListener get_Listener();
    internal EventTraceActivity get_EventTraceActivity();
    public HttpInput GetHttpInput(bool throwOnError);
    internal static HttpRequestContext CreateContext(HttpChannelListener listener, HttpListenerContext listenerContext, EventTraceActivity eventTraceActivity);
    protected abstract virtual SecurityMessageProperty OnProcessAuthentication();
    public abstract virtual HttpOutput GetHttpOutput(Message message);
    protected abstract virtual HttpInput GetHttpInput();
    public HttpOutput GetHttpOutputCore(Message message);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void Cleanup();
    public void InitializeHttpPipeline(TransportIntegrationHandler transportIntegrationHandler);
    internal void SetMessage(Message message, Exception requestException);
    protected abstract virtual HttpStatusCode ValidateAuthentication();
    protected virtual void OnReply(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndReply(IAsyncResult result);
    public bool ProcessAuthentication();
    internal void SendResponseAndClose(HttpStatusCode statusCode);
    internal void SendResponseAndClose(HttpStatusCode statusCode, string statusDescription);
    internal void SendResponseAndClose(HttpResponseMessage httpResponseMessage);
    public void AcceptWebSocket(HttpResponseMessage response, string protocol, TimeSpan timeout);
    protected abstract virtual Task`1<WebSocketContext> AcceptWebSocketCore(HttpResponseMessage response, string protocol);
    protected virtual void OnAcceptWebSocketError();
    protected abstract virtual void OnAcceptWebSocketSuccess(WebSocketContext context, HttpRequestMessage requestMessage);
    protected void OnAcceptWebSocketSuccess(WebSocketContext context, RemoteEndpointMessageProperty remoteEndpointMessageProperty, Byte[] webSocketInternalBuffer, bool shouldDisposeWebSocketAfterClose, HttpRequestMessage requestMessage);
    public IAsyncResult BeginAcceptWebSocket(HttpResponseMessage response, string protocol, AsyncCallback callback, object state);
    public void EndAcceptWebSocket(IAsyncResult result);
    internal IAsyncResult BeginProcessInboundRequest(ReplyChannelAcceptor replyChannelAcceptor, Action acceptorCallback, AsyncCallback callback, object state);
    internal void EndProcessInboundRequest(IAsyncResult result);
}
[ExtensionAttribute]
public static class System.ServiceModel.Channels.HttpRequestMessageExtensionMethods : object {
    [ExtensionAttribute]
public static void SetUserPrincipal(HttpRequestMessage httpRequestMessage, IPrincipal user);
    [ExtensionAttribute]
public static IPrincipal GetUserPrincipal(HttpRequestMessage httpRequestMessage);
    [ExtensionAttribute]
internal static void AddHeader(HttpRequestMessage httpRequestMessage, string header, string value);
    [ExtensionAttribute]
internal static void SetHeader(HttpRequestMessage httpRequestMessage, string header, string value);
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetHeader(HttpRequestMessage httpRequestMessage, string header);
    [ExtensionAttribute]
internal static void RemoveHeader(HttpRequestMessage httpRequestMessage, string header);
    [ExtensionAttribute]
internal static HttpRequestMessage CreateBufferedCopy(HttpRequestMessage httpRequestMessage);
    internal static HttpContent CreateBufferedCopyOfContent(HttpContent content);
    [ExtensionAttribute]
internal static void CopyPropertiesFromMessage(HttpRequestMessage httpRequestMessage, Message message);
    [ExtensionAttribute]
internal static void AddHeaderWithoutValidation(HttpHeaders httpHeaders, KeyValuePair`2<string, IEnumerable`1<string>> header);
}
internal class System.ServiceModel.Channels.HttpRequestMessageHttpInput : HttpInput {
    public long ContentLength { get; }
    protected ChannelBinding ChannelBinding { get; }
    public HttpRequestMessage HttpRequestMessage { get; }
    protected bool HasContent { get; }
    protected string ContentTypeCore { get; }
    protected string SoapActionHeader { get; }
    public HttpRequestMessageHttpInput(HttpRequestMessage httpRequestMessage, IHttpTransportFactorySettings settings, bool enableChannelBinding, ChannelBinding channelBinding);
    public virtual long get_ContentLength();
    protected virtual ChannelBinding get_ChannelBinding();
    public HttpRequestMessage get_HttpRequestMessage();
    protected virtual bool get_HasContent();
    protected virtual string get_ContentTypeCore();
    public virtual void ConfigureHttpRequestMessage(HttpRequestMessage message);
    protected virtual Stream GetInputStream();
    protected virtual void AddProperties(Message message);
    protected virtual string get_SoapActionHeader();
    public sealed virtual void CopyHeaders(WebHeaderCollection headers);
    internal void SetHttpRequestMessage(HttpRequestMessage httpRequestMessage);
}
public class System.ServiceModel.Channels.HttpRequestMessageProperty : object {
    public static string Name { get; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public string QueryString { get; public set; }
    public bool SuppressEntityBody { get; public set; }
    internal HttpRequestMessageProperty(IHttpHeaderProvider httpHeaderProvider);
    internal HttpRequestMessageProperty(HttpRequestMessage httpRequestMessage);
    public static string get_Name();
    public WebHeaderCollection get_Headers();
    public string get_Method();
    public void set_Method(string value);
    public string get_QueryString();
    public void set_QueryString(string value);
    public bool get_SuppressEntityBody();
    public void set_SuppressEntityBody(bool value);
    internal static HttpRequestMessage GetHttpRequestMessageFromMessage(Message message);
    private sealed virtual override IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
    private sealed virtual override bool System.ServiceModel.Channels.IMergeEnabledMessageProperty.TryMergeWithProperty(object propertyToMerge);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.HttpResponseMessageExtensionMethods : object {
    [ExtensionAttribute]
internal static void AddHeader(HttpResponseMessage httpResponseMessage, string header, string value);
    [ExtensionAttribute]
internal static void SetHeader(HttpResponseMessage httpResponseMessage, string header, string value);
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetHeader(HttpResponseMessage httpResponseMessage, string header);
    [ExtensionAttribute]
internal static void RemoveHeader(HttpResponseMessage httpResponseMessage, string header);
    [ExtensionAttribute]
internal static HttpResponseMessage CreateBufferedCopy(HttpResponseMessage httpResponseMessage);
    [ExtensionAttribute]
internal static void CopyPropertiesFromMessage(HttpResponseMessage httpResponseMessage, Message message);
}
public class System.ServiceModel.Channels.HttpResponseMessageProperty : object {
    public static string Name { get; }
    public WebHeaderCollection Headers { get; }
    public HttpStatusCode StatusCode { get; public set; }
    internal bool HasStatusCodeBeenSet { get; }
    public string StatusDescription { get; public set; }
    public bool SuppressEntityBody { get; public set; }
    public bool SuppressPreamble { get; public set; }
    internal HttpResponseMessageProperty(WebHeaderCollection originalHeaders);
    internal HttpResponseMessageProperty(HttpResponseMessage httpResponseMessage);
    public static string get_Name();
    public WebHeaderCollection get_Headers();
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    internal bool get_HasStatusCodeBeenSet();
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public bool get_SuppressEntityBody();
    public void set_SuppressEntityBody(bool value);
    public bool get_SuppressPreamble();
    public void set_SuppressPreamble(bool value);
    internal static HttpResponseMessage GetHttpResponseMessageFromMessage(Message message);
    private sealed virtual override IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
    private sealed virtual override bool System.ServiceModel.Channels.IMergeEnabledMessageProperty.TryMergeWithProperty(object propertyToMerge);
}
internal class System.ServiceModel.Channels.HttpsChannelFactory`1 : HttpChannelFactory`1<TChannel> {
    public string Scheme { get; }
    public bool RequireClientCertificate { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    internal HttpsChannelFactory`1(HttpsTransportBindingElement httpsBindingElement, BindingContext context);
    public virtual string get_Scheme();
    public bool get_RequireClientCertificate();
    public virtual bool get_IsChannelBindingSupportEnabled();
    public virtual T GetProperty();
    internal virtual SecurityMessageProperty CreateReplySecurityProperty(HttpWebRequest request, HttpWebResponse response);
    protected virtual void ValidateCreateChannelParameters(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannelCore(EndpointAddress address, Uri via);
    protected virtual bool IsSecurityTokenManagerRequired();
    protected virtual string OnGetConnectionGroupPrefix(HttpWebRequest httpWebRequest, SecurityTokenContainer clientCertificateToken);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    internal SecurityTokenProvider CreateAndOpenCertificateTokenProvider(EndpointAddress target, Uri via, ChannelParameterCollection channelParameters, TimeSpan timeout);
    internal SecurityTokenContainer GetCertificateSecurityToken(SecurityTokenProvider certificateProvider, EndpointAddress to, Uri via, ChannelParameterCollection channelParameters, TimeoutHelper& timeoutHelper);
}
internal class System.ServiceModel.Channels.HttpsChannelListener`1 : HttpChannelListener`1<TChannel> {
    public bool RequireClientCertificate { get; }
    public string Scheme { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    public HttpsChannelListener`1(HttpsTransportBindingElement httpsBindingElement, BindingContext context);
    public bool get_RequireClientCertificate();
    public virtual string get_Scheme();
    public virtual bool get_IsChannelBindingSupportEnabled();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    public virtual T GetProperty();
    internal virtual void ApplyHostedContext(string virtualPath, bool isMetadataListener);
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    public virtual SecurityMessageProperty ProcessAuthentication(IHttpAuthenticationContext authenticationContext);
    public virtual SecurityMessageProperty ProcessAuthentication(HttpListenerContext listenerContext);
    public virtual HttpStatusCode ValidateAuthentication(IHttpAuthenticationContext authenticationContext);
    public virtual HttpStatusCode ValidateAuthentication(HttpListenerContext listenerContext);
}
public class System.ServiceModel.Channels.HttpsTransportBindingElement : HttpTransportBindingElement {
    [DefaultValueAttribute("False")]
public bool RequireClientCertificate { get; public set; }
    public string Scheme { get; }
    internal MessageSecurityVersion MessageSecurityVersion { get; internal set; }
    protected HttpsTransportBindingElement(HttpsTransportBindingElement elementToBeCloned);
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    public virtual string get_Scheme();
    public virtual BindingElement Clone();
    internal virtual bool GetSupportsClientAuthenticationImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal virtual bool GetSupportsClientWindowsIdentityImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal MessageSecurityVersion get_MessageSecurityVersion();
    internal void set_MessageSecurityVersion(MessageSecurityVersion value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    internal static HttpsTransportBindingElement CreateFromHttpBindingElement(HttpTransportBindingElement elementToBeCloned);
    public virtual T GetProperty(BindingContext context);
    internal virtual void OnExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual void OnImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    public sealed virtual XmlElement GetTransportTokenAssertion();
}
public class System.ServiceModel.Channels.HttpTransportBindingElement : TransportBindingElement {
    [DefaultValueAttribute("False")]
public bool AllowCookies { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AuthenticationSchemes AuthenticationScheme { get; public set; }
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("True")]
public bool DecompressionEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    public HttpMessageHandlerFactory MessageHandlerFactory { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    internal bool InheritBaseAddressSettings { get; internal set; }
    [DefaultValueAttribute("True")]
public bool KeepAliveEnabled { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxPendingAccepts { get; public set; }
    internal string Method { get; internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri ProxyAddress { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AuthenticationSchemes ProxyAuthenticationScheme { get; public set; }
    internal IWebProxy Proxy { get; internal set; }
    [DefaultValueAttribute("")]
public string Realm { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan RequestInitializationTimeout { get; public set; }
    public string Scheme { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    public WebSocketTransportSettings WebSocketSettings { get; public set; }
    internal HttpAnonymousUriPrefixMatcher AnonymousUriPrefixMatcher { get; }
    [DefaultValueAttribute("False")]
public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    protected HttpTransportBindingElement(HttpTransportBindingElement elementToBeCloned);
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public AuthenticationSchemes get_AuthenticationScheme();
    public void set_AuthenticationScheme(AuthenticationSchemes value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public bool get_DecompressionEnabled();
    public void set_DecompressionEnabled(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public HttpMessageHandlerFactory get_MessageHandlerFactory();
    public void set_MessageHandlerFactory(HttpMessageHandlerFactory value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal bool get_InheritBaseAddressSettings();
    internal void set_InheritBaseAddressSettings(bool value);
    public bool get_KeepAliveEnabled();
    public void set_KeepAliveEnabled(bool value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    internal string get_Method();
    internal void set_Method(string value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public AuthenticationSchemes get_ProxyAuthenticationScheme();
    public void set_ProxyAuthenticationScheme(AuthenticationSchemes value);
    internal void set_Proxy(IWebProxy value);
    internal IWebProxy get_Proxy();
    public string get_Realm();
    public void set_Realm(string value);
    public TimeSpan get_RequestInitializationTimeout();
    public void set_RequestInitializationTimeout(TimeSpan value);
    public virtual string get_Scheme();
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public WebSocketTransportSettings get_WebSocketSettings();
    public void set_WebSocketSettings(WebSocketTransportSettings value);
    internal virtual bool GetSupportsClientAuthenticationImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal virtual bool GetSupportsClientWindowsIdentityImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal HttpAnonymousUriPrefixMatcher get_AnonymousUriPrefixMatcher();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    internal string GetWsdlTransportUri(bool useWebSocketTransport);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    internal static AuthenticationSchemes GetEffectiveAuthenticationSchemes(AuthenticationSchemes currentAuthenticationSchemes, BindingParameterCollection bindingParameters);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    protected void UpdateAuthenticationSchemes(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual void OnExportPolicy(MetadataExporter exporter, PolicyConversionContext policyContext);
    internal virtual void OnImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    private sealed virtual override void System.ServiceModel.Channels.ITransportPolicyImport.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeExtendedProtectionPolicy();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessageHandlerFactory();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWebSocketSettings();
}
internal static class System.ServiceModel.Channels.HttpTransportDefaults : object {
    internal static bool AllowCookies;
    internal static AuthenticationSchemes AuthenticationScheme;
    internal static bool BypassProxyOnLocal;
    internal static bool DecompressionEnabled;
    internal static HostNameComparisonMode HostNameComparisonMode;
    internal static bool KeepAliveEnabled;
    internal static Uri ProxyAddress;
    internal static AuthenticationSchemes ProxyAuthenticationScheme;
    internal static string Realm;
    internal static TransferMode TransferMode;
    internal static bool UnsafeConnectionNtlmAuthentication;
    internal static bool UseDefaultWebProxy;
    internal static string UpgradeHeader;
    internal static string ConnectionHeader;
    internal static HttpMessageHandlerFactory MessageHandlerFactory;
    internal static string RequestInitializationTimeoutString;
    internal static int DefaultMaxPendingAccepts;
    internal static int MaxPendingAcceptsUpperLimit;
    internal static TimeSpan RequestInitializationTimeout { get; }
    internal static SecurityAlgorithmSuite MessageSecurityAlgorithmSuite { get; }
    internal static TimeSpan get_RequestInitializationTimeout();
    internal static int GetEffectiveMaxPendingAccepts(int maxPendingAccepts);
    internal static WebSocketTransportSettings GetDefaultWebSocketTransportSettings();
    internal static MessageEncoderFactory GetDefaultMessageEncoderFactory();
    internal static SecurityAlgorithmSuite get_MessageSecurityAlgorithmSuite();
}
internal abstract class System.ServiceModel.Channels.HttpTransportManager : TransportManager {
    internal string Realm { get; }
    public HostNameComparisonMode HostNameComparisonMode { get; }
    internal bool IsHosted { get; internal set; }
    internal string Scheme { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    public Uri ListenUri { get; }
    internal HttpTransportManager(Uri listenUri, HostNameComparisonMode hostNameComparisonMode);
    internal HttpTransportManager(Uri listenUri, HostNameComparisonMode hostNameComparisonMode, string realm);
    internal string get_Realm();
    public sealed virtual HostNameComparisonMode get_HostNameComparisonMode();
    [CompilerGeneratedAttribute]
internal bool get_IsHosted();
    [CompilerGeneratedAttribute]
internal void set_IsHosted(bool value);
    internal virtual string get_Scheme();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    public sealed virtual Uri get_ListenUri();
    protected void Fault(Exception exception);
    internal virtual bool IsCompatible(HttpChannelListener listener);
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
    protected void StartReceiveBytesActivity(ServiceModelActivity activity, Uri requestUri);
    protected void TraceMessageReceived(EventTraceActivity eventTraceActivity, Uri listenUri);
    protected bool TryLookupUri(Uri requestUri, string requestMethod, HostNameComparisonMode hostNameComparisonMode, bool isWebSocketRequest, HttpChannelListener& listener);
    internal virtual void Register(TransportChannelListener channelListener);
    private sealed virtual override IList`1<TransportManager> System.ServiceModel.Channels.ITransportManagerRegistration.Select(TransportChannelListener channelListener);
    internal virtual void Unregister(TransportChannelListener channelListener);
}
internal static class System.ServiceModel.Channels.HttpTransportSecurityHelpers : object {
    private static HttpTransportSecurityHelpers();
    public static bool AddIdentityMapping(Uri via, EndpointAddress target);
    public static void RemoveIdentityMapping(Uri via, EndpointAddress target, bool validateState);
    public static void AddServerCertMapping(HttpWebRequest request, EndpointAddress to);
    public static void RemoveServerCertMapping(HttpWebRequest request);
}
public interface System.ServiceModel.Channels.IAnonymousUriPrefixMatcher {
    public abstract virtual void Register(Uri anonymousUriPrefix);
}
internal interface System.ServiceModel.Channels.IAsyncRequest {
    public abstract virtual void BeginSendRequest(Message message, TimeSpan timeout);
    public abstract virtual Message End();
}
public interface System.ServiceModel.Channels.IBindingDeliveryCapabilities {
    public bool AssuresOrderedDelivery { get; }
    public bool QueuedDelivery { get; }
    public abstract virtual bool get_AssuresOrderedDelivery();
    public abstract virtual bool get_QueuedDelivery();
}
public interface System.ServiceModel.Channels.IBindingMulticastCapabilities {
    public bool IsMulticast { get; }
    public abstract virtual bool get_IsMulticast();
}
public interface System.ServiceModel.Channels.IBindingRuntimePreferences {
    public bool ReceiveSynchronously { get; }
    public abstract virtual bool get_ReceiveSynchronously();
}
internal interface System.ServiceModel.Channels.IBufferedMessageData {
    public MessageEncoder MessageEncoder { get; }
    public ArraySegment`1<byte> Buffer { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public abstract virtual MessageEncoder get_MessageEncoder();
    public abstract virtual ArraySegment`1<byte> get_Buffer();
    public abstract virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual void Close();
    public abstract virtual void EnableMultipleUsers();
    public abstract virtual XmlDictionaryReader GetMessageReader();
    public abstract virtual void Open();
    public abstract virtual void ReturnMessageState(RecycledMessageState messageState);
    public abstract virtual RecycledMessageState TakeMessageState();
}
public interface System.ServiceModel.Channels.IChannel {
    public abstract virtual T GetProperty();
}
internal interface System.ServiceModel.Channels.IChannelAcceptor`1 {
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IChannelBindingProvider {
    public bool IsChannelBindingSupportEnabled { get; }
    public abstract virtual void EnableChannelBindingSupport();
    public abstract virtual bool get_IsChannelBindingSupportEnabled();
}
internal interface System.ServiceModel.Channels.IChannelDemuxer {
    public abstract virtual void OnOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout);
    public abstract virtual IAsyncResult OnBeginOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void OnEndOuterListenerOpen(IAsyncResult result);
    public abstract virtual void OnOuterListenerAbort(ChannelDemuxerFilter filter);
    public abstract virtual void OnOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout);
    public abstract virtual IAsyncResult OnBeginOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void OnEndOuterListenerClose(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IChannelDemuxerFilter {
    public ChannelDemuxerFilter Filter { get; }
    public abstract virtual ChannelDemuxerFilter get_Filter();
}
internal interface System.ServiceModel.Channels.IChannelDemuxFailureHandler {
    public abstract virtual void HandleDemuxFailure(Message message);
    public abstract virtual IAsyncResult BeginHandleDemuxFailure(Message message, RequestContext faultContext, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginHandleDemuxFailure(Message message, IOutputChannel faultContext, AsyncCallback callback, object state);
    public abstract virtual void EndHandleDemuxFailure(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IChannelFactory {
    public abstract virtual T GetProperty();
}
public interface System.ServiceModel.Channels.IChannelFactory`1 {
    public abstract virtual TChannel CreateChannel(EndpointAddress to);
    public abstract virtual TChannel CreateChannel(EndpointAddress to, Uri via);
}
public interface System.ServiceModel.Channels.IChannelListener {
    public Uri Uri { get; }
    public abstract virtual Uri get_Uri();
    public abstract virtual T GetProperty();
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IChannelListener`1 {
    public abstract virtual TChannel AcceptChannel();
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IClientReliableChannelBinder {
    public Uri Via { get; }
    public abstract virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionLost(EventHandler value);
    public abstract virtual bool EnsureChannelForRequest();
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual Message Request(Message message, TimeSpan timeout, MaskingMode maskingMode);
}
internal interface System.ServiceModel.Channels.ICommunicationWaiter {
    public abstract virtual void Signal();
    public abstract virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal interface System.ServiceModel.Channels.ICompressedMessageEncoder {
    public bool CompressionEnabled { get; }
    public abstract virtual bool get_CompressionEnabled();
    public abstract virtual void SetSessionContentType(string contentType);
    public abstract virtual void AddCompressedMessageProperties(Message message, string supportedCompressionTypes);
}
internal interface System.ServiceModel.Channels.IConnectAlgorithms {
    public abstract virtual void Connect(TimeSpan timeout);
    public abstract virtual void Initialize(IPeerMaintainer maintainer, PeerNodeConfig config, int wantedConnectedNeighbors, Dictionary`2<EndpointAddress, Referral> referralCache);
    public abstract virtual void PruneConnections();
    public abstract virtual void UpdateEndpointsCollection(ICollection`1<PeerNodeAddress> src);
}
internal interface System.ServiceModel.Channels.IConnection {
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    public TraceEventType ExceptionEventType { get; public set; }
    public IPEndPoint RemoteIPEndPoint { get; }
    public abstract virtual Byte[] get_AsyncReadBuffer();
    public abstract virtual int get_AsyncReadBufferSize();
    public abstract virtual TraceEventType get_ExceptionEventType();
    public abstract virtual void set_ExceptionEventType(TraceEventType value);
    public abstract virtual IPEndPoint get_RemoteIPEndPoint();
    public abstract virtual void Abort();
    public abstract virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public abstract virtual void Shutdown(TimeSpan timeout);
    public abstract virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public abstract virtual void EndWrite();
    public abstract virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public abstract virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public abstract virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public abstract virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public abstract virtual int EndRead();
    public abstract virtual object DuplicateAndClose(int targetProcessId);
    public abstract virtual object GetCoreTransport();
    public abstract virtual IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public abstract virtual bool EndValidate(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IConnectionInitiator {
    public abstract virtual IConnection Connect(Uri uri, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginConnect(Uri uri, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IConnection EndConnect(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IConnectionListener {
    public abstract virtual void Listen();
    public abstract virtual IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public abstract virtual IConnection EndAccept(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IConnectionOrientedConnectionSettings {
    public int ConnectionBufferSize { get; }
    public TimeSpan MaxOutputDelay { get; }
    public TimeSpan IdleTimeout { get; }
    public abstract virtual int get_ConnectionBufferSize();
    public abstract virtual TimeSpan get_MaxOutputDelay();
    public abstract virtual TimeSpan get_IdleTimeout();
}
internal interface System.ServiceModel.Channels.IConnectionOrientedListenerSettings {
    public TimeSpan ChannelInitializationTimeout { get; }
    public int MaxPendingConnections { get; }
    public int MaxPendingAccepts { get; }
    public int MaxPooledConnections { get; }
    public abstract virtual TimeSpan get_ChannelInitializationTimeout();
    public abstract virtual int get_MaxPendingConnections();
    public abstract virtual int get_MaxPendingAccepts();
    public abstract virtual int get_MaxPooledConnections();
}
internal interface System.ServiceModel.Channels.IConnectionOrientedTransportChannelFactorySettings {
    public string ConnectionPoolGroupName { get; }
    public int MaxOutboundConnectionsPerEndpoint { get; }
    public abstract virtual string get_ConnectionPoolGroupName();
    public abstract virtual int get_MaxOutboundConnectionsPerEndpoint();
}
internal interface System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings {
    public int MaxBufferSize { get; }
    public StreamUpgradeProvider Upgrade { get; }
    public TransferMode TransferMode { get; }
    public ServiceSecurityAuditBehavior AuditBehavior { get; }
    public abstract virtual int get_MaxBufferSize();
    public abstract virtual StreamUpgradeProvider get_Upgrade();
    public abstract virtual TransferMode get_TransferMode();
    public abstract virtual ServiceSecurityAuditBehavior get_AuditBehavior();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.ServiceModel.Channels.IContextBindingElement {
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.ServiceModel.Channels.IContextManager {
    public bool Enabled { get; public set; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual IDictionary`2<string, string> GetContext();
    public abstract virtual void SetContext(IDictionary`2<string, string> context);
}
public interface System.ServiceModel.Channels.ICorrelationDataSource {
    public ICollection`1<CorrelationDataDescription> DataSources { get; }
    public abstract virtual ICollection`1<CorrelationDataDescription> get_DataSources();
}
internal interface System.ServiceModel.Channels.ICorrelatorKey {
    public Key RequestCorrelatorKey { get; public set; }
    public abstract virtual Key get_RequestCorrelatorKey();
    public abstract virtual void set_RequestCorrelatorKey(Key value);
}
internal abstract class System.ServiceModel.Channels.IdlingCommunicationPool`2 : CommunicationPool`2<TKey, TItem> {
    public TimeSpan IdleTimeout { get; }
    protected TimeSpan LeaseTimeout { get; }
    protected IdlingCommunicationPool`2(int maxCount, TimeSpan idleTimeout, TimeSpan leaseTimeout);
    public TimeSpan get_IdleTimeout();
    protected TimeSpan get_LeaseTimeout();
    protected virtual void CloseItemAsync(TItem item, TimeSpan timeout);
    protected virtual EndpointConnectionPool<TKey, TItem> CreateEndpointConnectionPool(TKey key);
}
public interface System.ServiceModel.Channels.IDuplexChannel {
}
public interface System.ServiceModel.Channels.IDuplexSession {
    public abstract virtual void CloseOutputSession();
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginCloseOutputSession(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IDuplexSessionChannel {
}
internal interface System.ServiceModel.Channels.IFlooderForThrottle {
    public abstract virtual void OnThrottleReached();
    public abstract virtual void OnThrottleReleased();
}
public interface System.ServiceModel.Channels.IHttpCookieContainerManager {
    public CookieContainer CookieContainer { get; public set; }
    public abstract virtual CookieContainer get_CookieContainer();
    public abstract virtual void set_CookieContainer(CookieContainer value);
}
internal interface System.ServiceModel.Channels.IHttpTransportFactorySettings {
    public int MaxBufferSize { get; }
    public TransferMode TransferMode { get; }
    public abstract virtual int get_MaxBufferSize();
    public abstract virtual TransferMode get_TransferMode();
}
public interface System.ServiceModel.Channels.IInputChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual Message Receive();
    public abstract virtual Message Receive(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndReceive(IAsyncResult result);
    public abstract virtual bool TryReceive(TimeSpan timeout, Message& message);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IInputSession {
}
public interface System.ServiceModel.Channels.IInputSessionChannel {
}
internal interface System.ServiceModel.Channels.ILockingQueue {
    public abstract virtual void DeleteMessage(long lookupId, TimeSpan timeout);
    public abstract virtual void UnlockMessage(long lookupId, TimeSpan timeout);
}
internal interface System.ServiceModel.Channels.IMergeEnabledMessageProperty {
    public abstract virtual bool TryMergeWithProperty(object propertyToMerge);
}
internal interface System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace {
    public XmlDictionaryString SharedNamespace { get; }
    public XmlDictionaryString SharedPrefix { get; }
    public abstract virtual XmlDictionaryString get_SharedNamespace();
    public abstract virtual XmlDictionaryString get_SharedPrefix();
}
public interface System.ServiceModel.Channels.IMessageProperty {
    public abstract virtual IMessageProperty CreateCopy();
}
internal interface System.ServiceModel.Channels.IMessageSource {
    public abstract virtual AsyncReceiveResult BeginReceive(TimeSpan timeout, WaitCallback callback, object state);
    public abstract virtual Message EndReceive();
    public abstract virtual Message Receive(TimeSpan timeout);
    public abstract virtual AsyncReceiveResult BeginWaitForMessage(TimeSpan timeout, WaitCallback callback, object state);
    public abstract virtual bool EndWaitForMessage();
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
}
internal interface System.ServiceModel.Channels.IMsmqMessagePool {
    public abstract virtual MsmqInputMessage TakeMessage();
    public abstract virtual void ReturnMessage(MsmqInputMessage message);
}
internal abstract class System.ServiceModel.Channels.InitialServerConnectionReader : object {
    public IConnection Connection { get; }
    public Action ConnectionDequeuedCallback { get; public set; }
    protected bool IsClosed { get; }
    protected int MaxContentTypeSize { get; }
    protected int MaxViaSize { get; }
    protected InitialServerConnectionReader(IConnection connection, ConnectionClosedCallback closedCallback);
    protected InitialServerConnectionReader(IConnection connection, ConnectionClosedCallback closedCallback, int maxViaSize, int maxContentTypeSize);
    public IConnection get_Connection();
    public Action get_ConnectionDequeuedCallback();
    public void set_ConnectionDequeuedCallback(Action value);
    public Action GetConnectionDequeuedCallback();
    protected bool get_IsClosed();
    protected int get_MaxContentTypeSize();
    protected int get_MaxViaSize();
    public void ReleaseConnection();
    public void CloseFromPool(TimeSpan timeout);
    public sealed virtual void Dispose();
    protected void Abort();
    internal void Abort(Exception e);
    protected void Close(TimeSpan timeout);
    internal static void SendFault(IConnection connection, string faultString, Byte[] drainBuffer, TimeSpan sendTimeout, int maxRead);
    public static IAsyncResult BeginUpgradeConnection(IConnection connection, StreamUpgradeAcceptor upgradeAcceptor, IDefaultCommunicationTimeouts defaultTimeouts, AsyncCallback callback, object state);
    public static IConnection EndUpgradeConnection(IAsyncResult result);
    public static IConnection UpgradeConnection(IConnection connection, StreamUpgradeAcceptor upgradeAcceptor, IDefaultCommunicationTimeouts defaultTimeouts);
}
internal class System.ServiceModel.Channels.InputChannel : InputQueueChannel`1<Message> {
    public EndpointAddress LocalAddress { get; }
    public InputChannel(ChannelManagerBase channelManager, EndpointAddress localAddress);
    public sealed virtual EndpointAddress get_LocalAddress();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    public virtual Message Receive();
    public virtual Message Receive(TimeSpan timeout);
    public virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public virtual bool TryReceive(TimeSpan timeout, Message& message);
    public virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    internal static Message HelpReceive(IInputChannel channel, TimeSpan timeout);
    internal static IAsyncResult HelpBeginReceive(IInputChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    internal static Message HelpEndReceive(IAsyncResult result);
}
internal class System.ServiceModel.Channels.InputChannelAcceptor : SingletonChannelAcceptor`3<IInputChannel, InputChannel, Message> {
    public InputChannelAcceptor(ChannelManagerBase channelManager);
    protected virtual InputChannel OnCreateChannel();
    protected virtual void OnTraceMessageReceived(Message message);
}
internal class System.ServiceModel.Channels.InputChannelDemuxer : DatagramChannelDemuxer`2<IInputChannel, Message> {
    public InputChannelDemuxer(BindingContext context);
    protected virtual void AbortItem(Message message);
    protected virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual LayeredChannelListener`1<IInputChannel> CreateListener(ChannelDemuxerFilter filter);
    protected virtual void Dispatch(IChannelListener listener);
    protected virtual void EndpointNotFound(Message message);
    protected virtual Message EndReceive(IAsyncResult result);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, Message message, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual Message GetMessage(Message message);
}
internal class System.ServiceModel.Channels.InputChannelWrapper : ChannelWrapper`2<IInputChannel, Message> {
    public EndpointAddress LocalAddress { get; }
    public InputChannelWrapper(ChannelManagerBase channelManager, IInputChannel innerChannel, Message firstMessage);
    public sealed virtual EndpointAddress get_LocalAddress();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void CloseFirstItem(TimeSpan timeout);
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.InputQueueChannel`1 : ChannelBase {
    public int InternalPendingItems { get; }
    public int PendingItems { get; }
    protected InputQueueChannel`1(ChannelManagerBase channelManager);
    public int get_InternalPendingItems();
    public int get_PendingItems();
    public void EnqueueAndDispatch(TDisposable item);
    public void EnqueueAndDispatch(TDisposable item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(TDisposable item, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(TDisposable item, Action dequeuedCallback);
    public void Dispatch();
    public void Shutdown();
    protected virtual void OnFaulted();
    protected virtual void OnEnqueueItem(TDisposable item);
    protected IAsyncResult BeginDequeue(TimeSpan timeout, AsyncCallback callback, object state);
    protected bool EndDequeue(IAsyncResult result, TDisposable& item);
    protected bool Dequeue(TimeSpan timeout, TDisposable& item);
    protected bool WaitForItem(TimeSpan timeout);
    protected IAsyncResult BeginWaitForItem(TimeSpan timeout, AsyncCallback callback, object state);
    protected bool EndWaitForItem(IAsyncResult result);
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.InputQueueChannelAcceptor`1 : ChannelAcceptor`1<TChannel> {
    public int PendingCount { get; }
    public InputQueueChannelAcceptor`1(ChannelManagerBase channelManager);
    public int get_PendingCount();
    public virtual TChannel AcceptChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public void Dispatch();
    public virtual TChannel EndAcceptChannel(IAsyncResult result);
    public void EnqueueAndDispatch(TChannel channel);
    public void EnqueueAndDispatch(TChannel channel, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(TChannel channel, Action dequeuedCallback);
    public virtual bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public void EnqueueAndDispatch(TChannel channel, Action dequeuedCallback, bool canDispatchOnThisThread);
    public virtual void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void FaultQueue();
    protected virtual void OnClosed();
    protected virtual void OnFaulted();
    public virtual bool WaitForChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool EndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Channels.InputQueueChannelListener`1 : DelegatingChannelListener`1<TChannel> {
    public ChannelDemuxerFilter Filter { get; }
    public InputQueueChannelAcceptor`1<TChannel> InputQueueAcceptor { get; }
    public InputQueueChannelListener`1(ChannelDemuxerFilter filter, IChannelDemuxer channelDemuxer);
    public ChannelDemuxerFilter get_Filter();
    public InputQueueChannelAcceptor`1<TChannel> get_InputQueueAcceptor();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.InputSessionChannelDemuxer : SessionChannelDemuxer`2<IInputSessionChannel, Message> {
    public InputSessionChannelDemuxer(BindingContext context, TimeSpan peekTimeout, int maxPendingSessions);
    protected virtual void AbortItem(Message message);
    protected virtual IAsyncResult BeginReceive(IInputSessionChannel channel, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginReceive(IInputSessionChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IInputSessionChannel CreateChannel(ChannelManagerBase channelManager, IInputSessionChannel innerChannel, Message firstMessage);
    protected virtual void EndpointNotFound(IInputSessionChannel channel, Message message);
    protected virtual Message EndReceive(IInputSessionChannel channel, IAsyncResult result);
    protected virtual Message GetMessage(Message message);
}
internal class System.ServiceModel.Channels.InputSessionChannelWrapper : InputChannelWrapper {
    public IInputSession Session { get; }
    public InputSessionChannelWrapper(ChannelManagerBase channelManager, IInputSessionChannel innerChannel, Message firstMessage);
    public sealed virtual IInputSession get_Session();
}
internal class System.ServiceModel.Channels.IntDecoder : ValueType {
    private int value;
    private short index;
    private bool isValueDecoded;
    private static int LastIndex;
    public int Value { get; }
    public bool IsValueDecoded { get; }
    public int get_Value();
    public bool get_IsValueDecoded();
    public void Reset();
    public int Decode(Byte[] buffer, int offset, int size);
}
internal static class System.ServiceModel.Channels.IntEncoder : object {
    public static int MaxEncodedSize;
    public static int Encode(int value, Byte[] bytes, int offset);
    public static int GetEncodedSize(int value);
}
internal class System.ServiceModel.Channels.InternalDuplexBindingElement : BindingElement {
    internal InputChannelDemuxer ClientChannelDemuxer { get; }
    internal bool ProvidesCorrelation { get; }
    internal InternalDuplexBindingElement(bool providesCorrelation);
    internal InputChannelDemuxer get_ClientChannelDemuxer();
    internal bool get_ProvidesCorrelation();
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    internal static T GetSecurityCapabilities(ISecurityCapabilities lowerCapabilities);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    public static void AddDuplexFactorySupport(BindingContext context, InternalDuplexBindingElement& internalDuplexBindingElement);
    public static void AddDuplexListenerSupport(BindingContext context, InternalDuplexBindingElement& internalDuplexBindingElement);
    public static void AddDuplexListenerSupport(CustomBinding binding, InternalDuplexBindingElement& internalDuplexBindingElement);
}
internal class System.ServiceModel.Channels.InternalDuplexChannelFactory : LayeredChannelFactory`1<IDuplexChannel> {
    internal InternalDuplexChannelFactory(InternalDuplexBindingElement bindingElement, BindingContext context, InputChannelDemuxer channelDemuxer, IChannelFactory`1<IOutputChannel> innerChannelFactory, LocalAddressProvider localAddressProvider);
    private static InternalDuplexChannelFactory();
    protected virtual IDuplexChannel OnCreateChannel(EndpointAddress address, Uri via);
    public IDuplexChannel CreateChannel(EndpointAddress address, Uri via, MessageFilter filter, int priority, bool usesUniqueHeader);
    public IDuplexChannel CreateChannel(EndpointAddress remoteAddress, Uri via, EndpointAddress localAddress, MessageFilter filter, int priority, bool usesUniqueHeader);
    protected virtual void OnAbort();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    public virtual T GetProperty();
}
internal class System.ServiceModel.Channels.InternalDuplexChannelListener : DelegatingChannelListener`1<IDuplexChannel> {
    internal InternalDuplexChannelListener(InternalDuplexBindingElement bindingElement, BindingContext context);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpening();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    public virtual T GetProperty();
}
internal class System.ServiceModel.Channels.InterruptibleTimer : object {
    public InterruptibleTimer(TimeSpan defaultInterval, WaitCallback callback, object state);
    private static InterruptibleTimer();
    public void Abort();
    public bool Cancel();
    public void Set();
    public void Set(TimeSpan interval);
    public void SetIfNotSet();
}
internal class System.ServiceModel.Channels.InterruptibleWaitObject : object {
    public InterruptibleWaitObject(bool signaled);
    public InterruptibleWaitObject(bool signaled, bool throwTimeoutByDefault);
    public void Abort(CommunicationObject communicationObject);
    public void Fault(CommunicationObject communicationObject);
    public IAsyncResult BeginWait(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginWait(TimeSpan timeout, bool throwTimeoutException, AsyncCallback callback, object state);
    public IAsyncResult BeginTryWait(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndWait(IAsyncResult result);
    public bool EndTryWait(IAsyncResult result);
    public void Reset();
    public void Set();
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, bool throwTimeoutException);
}
internal class System.ServiceModel.Channels.InvalidAcknowledgementFault : WsrmHeaderFault {
    public InvalidAcknowledgementFault(UniqueId sequenceID, SequenceRangeCollection ranges);
    public InvalidAcknowledgementFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.InvalidChannelBindingException : Exception {
    public InvalidChannelBindingException(string message);
    public InvalidChannelBindingException(string message, Exception innerException);
    protected InvalidChannelBindingException(SerializationInfo info, StreamingContext context);
}
public interface System.ServiceModel.Channels.IOutputChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual void Send(Message message);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IOutputSession {
}
public interface System.ServiceModel.Channels.IOutputSessionChannel {
}
internal interface System.ServiceModel.Channels.IPeerConnectorContract {
    public abstract virtual void Connect(IPeerNeighbor neighbor, ConnectInfo connectInfo);
    public abstract virtual void Disconnect(IPeerNeighbor neighbor, DisconnectInfo disconnectInfo);
    public abstract virtual void Refuse(IPeerNeighbor neighbor, RefuseInfo refuseInfo);
    public abstract virtual void Welcome(IPeerNeighbor neighbor, WelcomeInfo welcomeInfo);
}
internal interface System.ServiceModel.Channels.IPeerFactory {
    public IPAddress ListenIPAddress { get; }
    public int Port { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public PeerResolver Resolver { get; }
    public PeerSecurityManager SecurityManager { get; }
    public PeerNodeImplementation PrivatePeerNode { get; public set; }
    public long MaxBufferPoolSize { get; }
    public abstract virtual IPAddress get_ListenIPAddress();
    public abstract virtual int get_Port();
    public abstract virtual XmlDictionaryReaderQuotas get_ReaderQuotas();
    public abstract virtual PeerResolver get_Resolver();
    public abstract virtual PeerSecurityManager get_SecurityManager();
    public abstract virtual PeerNodeImplementation get_PrivatePeerNode();
    public abstract virtual void set_PrivatePeerNode(PeerNodeImplementation value);
    public abstract virtual long get_MaxBufferPoolSize();
}
internal interface System.ServiceModel.Channels.IPeerFlooderContract`2 {
    public abstract virtual IAsyncResult OnFloodedMessage(IPeerNeighbor neighbor, TFloodContract floodedInfo, AsyncCallback callback, object state);
    public abstract virtual void EndFloodMessage(IAsyncResult result);
    public abstract virtual void ProcessLinkUtility(IPeerNeighbor neighbor, TLinkContract utilityInfo);
}
internal interface System.ServiceModel.Channels.IPeerMaintainer {
    public int ConnectedNeighborCount { get; }
    public int NonClosingNeighborCount { get; }
    public bool IsOpen { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_NeighborClosed(NeighborClosedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NeighborClosed(NeighborClosedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NeighborConnected(NeighborConnectedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NeighborConnected(NeighborConnectedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MaintainerClosed(MaintainerClosedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MaintainerClosed(MaintainerClosedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReferralsAdded(ReferralsAddedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReferralsAdded(ReferralsAddedHandler value);
    public abstract virtual int get_ConnectedNeighborCount();
    public abstract virtual int get_NonClosingNeighborCount();
    public abstract virtual bool get_IsOpen();
    public abstract virtual IAsyncResult BeginOpenNeighbor(PeerNodeAddress to, TimeSpan timeout, AsyncCallback callback, object asyncState);
    public abstract virtual IPeerNeighbor EndOpenNeighbor(IAsyncResult result);
    public abstract virtual void CloseNeighbor(IPeerNeighbor neighbor, PeerCloseReason closeReason);
    public abstract virtual IPeerNeighbor FindDuplicateNeighbor(PeerNodeAddress address);
    public abstract virtual PeerNodeAddress GetListenAddress();
    public abstract virtual IPeerNeighbor GetLeastUsefulNeighbor();
}
internal interface System.ServiceModel.Channels.IPeerNeighbor {
    public bool IsConnected { get; }
    public PeerNodeAddress ListenAddress { get; public set; }
    public bool IsInitiator { get; }
    public ulong NodeId { get; public set; }
    public PeerNeighborState State { get; public set; }
    public bool IsClosing { get; }
    public UtilityExtension Utility { get; }
    public abstract virtual bool get_IsConnected();
    public abstract virtual PeerNodeAddress get_ListenAddress();
    public abstract virtual void set_ListenAddress(PeerNodeAddress value);
    public abstract virtual bool get_IsInitiator();
    public abstract virtual ulong get_NodeId();
    public abstract virtual void set_NodeId(ulong value);
    public abstract virtual PeerNeighborState get_State();
    public abstract virtual void set_State(PeerNeighborState value);
    public abstract virtual bool get_IsClosing();
    public abstract virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual void Send(Message message);
    public abstract virtual bool TrySetState(PeerNeighborState state);
    public abstract virtual void Abort(PeerCloseReason reason, PeerCloseInitiator initiator);
    public abstract virtual Message RequestSecurityToken(Message request);
    public abstract virtual void Ping(Message request);
    public abstract virtual UtilityExtension get_Utility();
}
internal interface System.ServiceModel.Channels.IPeerNodeMessageHandling {
    public bool HasMessagePropagation { get; }
    public MessageEncodingBindingElement EncodingBindingElement { get; }
    public abstract virtual void HandleIncomingMessage(MessageBuffer messageBuffer, PeerMessagePropagation propagateFlags, int index, MessageHeader header, Uri via, Uri to);
    public abstract virtual PeerMessagePropagation DetermineMessagePropagation(Message message, PeerMessageOrigination origination);
    public abstract virtual bool get_HasMessagePropagation();
    public abstract virtual bool ValidateIncomingMessage(Message& data, Uri via);
    public abstract virtual bool IsKnownVia(Uri via);
    public abstract virtual bool IsNotSeenBefore(Message message, Byte[]& id, Int32& cacheMiss);
    public abstract virtual MessageEncodingBindingElement get_EncodingBindingElement();
}
[ServiceContractAttribute]
internal interface System.ServiceModel.Channels.IPeerProxy {
}
[ServiceContractAttribute]
internal interface System.ServiceModel.Channels.IPeerService {
}
[ServiceContractAttribute]
internal interface System.ServiceModel.Channels.IPeerServiceContract {
    [OperationContractAttribute]
public abstract virtual void Connect(ConnectInfo connectInfo);
    [OperationContractAttribute]
public abstract virtual void Disconnect(DisconnectInfo disconnectInfo);
    [OperationContractAttribute]
public abstract virtual void Refuse(RefuseInfo refuseInfo);
    [OperationContractAttribute]
public abstract virtual void Welcome(WelcomeInfo welcomeInfo);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginFloodMessage(Message floodedInfo, AsyncCallback callback, object state);
    public abstract virtual void EndFloodMessage(IAsyncResult result);
    [OperationContractAttribute]
public abstract virtual void LinkUtility(UtilityInfo utilityInfo);
    [OperationContractAttribute]
public abstract virtual Message ProcessRequestSecurityToken(Message message);
    [OperationContractAttribute]
public abstract virtual void Ping(Message message);
    [OperationContractAttribute]
public abstract virtual void Fault(Message message);
}
internal interface System.ServiceModel.Channels.IPipeTransportFactorySettings {
    public NamedPipeSettings PipeSettings { get; }
    public abstract virtual NamedPipeSettings get_PipeSettings();
}
internal interface System.ServiceModel.Channels.IPoisonHandlingStrategy {
    public abstract virtual bool CheckAndHandlePoisonMessage(MsmqMessageProperty messageProperty);
    public abstract virtual void FinalDisposition(MsmqMessageProperty messageProperty);
    public abstract virtual void Open();
}
internal interface System.ServiceModel.Channels.IPostRollbackErrorStrategy {
    public abstract virtual bool AnotherTryNeeded();
}
public interface System.ServiceModel.Channels.IReceiveContextSettings {
    public bool Enabled { get; public set; }
    public TimeSpan ValidityDuration { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual TimeSpan get_ValidityDuration();
}
internal interface System.ServiceModel.Channels.IReliableChannelBinder {
    public bool CanSendAsynchronously { get; }
    public IChannel Channel { get; }
    public bool Connected { get; }
    public TimeSpan DefaultSendTimeout { get; }
    public bool HasSession { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public CommunicationState State { get; }
    public abstract virtual bool get_CanSendAsynchronously();
    public abstract virtual IChannel get_Channel();
    public abstract virtual bool get_Connected();
    public abstract virtual TimeSpan get_DefaultSendTimeout();
    public abstract virtual bool get_HasSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnException(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnException(BinderExceptionHandler value);
    public abstract virtual void Abort();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void Close(TimeSpan timeout, MaskingMode maskingMode);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void Open(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOpen(IAsyncResult result);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual void Send(Message message, TimeSpan timeout, MaskingMode maskingMode);
    public abstract virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public abstract virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext, MaskingMode maskingMode);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public abstract virtual ISession GetInnerSession();
    public abstract virtual void HandleException(Exception e);
    public abstract virtual bool IsHandleable(Exception e);
    public abstract virtual void SetMaskingMode(RequestContext context, MaskingMode maskingMode);
    public abstract virtual RequestContext WrapRequestContext(RequestContext context);
}
internal interface System.ServiceModel.Channels.IReliableFactorySettings {
    public TimeSpan AcknowledgementInterval { get; }
    public bool FlowControlEnabled { get; }
    public TimeSpan InactivityTimeout { get; }
    public int MaxPendingChannels { get; }
    public int MaxRetryCount { get; }
    public int MaxTransferWindowSize { get; }
    public MessageVersion MessageVersion { get; }
    public bool Ordered { get; }
    public ReliableMessagingVersion ReliableMessagingVersion { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_AcknowledgementInterval();
    public abstract virtual bool get_FlowControlEnabled();
    public abstract virtual TimeSpan get_InactivityTimeout();
    public abstract virtual int get_MaxPendingChannels();
    public abstract virtual int get_MaxRetryCount();
    public abstract virtual int get_MaxTransferWindowSize();
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual bool get_Ordered();
    public abstract virtual ReliableMessagingVersion get_ReliableMessagingVersion();
    public abstract virtual TimeSpan get_SendTimeout();
}
public interface System.ServiceModel.Channels.IReplyChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual RequestContext ReceiveRequest();
    public abstract virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public abstract virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public abstract virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public abstract virtual bool WaitForRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForRequest(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IReplySessionChannel {
}
internal interface System.ServiceModel.Channels.IRequest {
    public abstract virtual void SendRequest(Message message, TimeSpan timeout);
    public abstract virtual Message WaitForReply(TimeSpan timeout);
}
internal interface System.ServiceModel.Channels.IRequestBase {
    public abstract virtual void Abort(RequestChannel requestChannel);
    public abstract virtual void Fault(RequestChannel requestChannel);
    public abstract virtual void OnReleaseRequest();
}
public interface System.ServiceModel.Channels.IRequestChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual Message Request(Message message);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IRequestReplyCorrelator {
    public abstract virtual void Add(Message request, T state);
    public abstract virtual T Find(Message reply, bool remove);
}
public interface System.ServiceModel.Channels.IRequestSessionChannel {
}
public interface System.ServiceModel.Channels.ISecurityCapabilities {
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public abstract virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public abstract virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public abstract virtual bool get_SupportsClientAuthentication();
    public abstract virtual bool get_SupportsClientWindowsIdentity();
    public abstract virtual bool get_SupportsServerAuthentication();
}
internal interface System.ServiceModel.Channels.IServerReliableChannelBinder {
    public abstract virtual bool AddressResponse(Message request, Message response);
    public abstract virtual bool UseNewChannel(IChannel channel);
    public abstract virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForRequest(IAsyncResult result);
    public abstract virtual bool WaitForRequest(TimeSpan timeout);
}
public interface System.ServiceModel.Channels.ISession {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.ServiceModel.Channels.ISessionChannel`1 {
    public TSession Session { get; }
    public abstract virtual TSession get_Session();
}
internal interface System.ServiceModel.Channels.ISessionPreambleHandler {
    public abstract virtual void HandleServerSessionPreamble(ServerSessionPreambleConnectionReader serverSessionPreambleReader, ConnectionDemuxer connectionDemuxer);
}
internal interface System.ServiceModel.Channels.ISingletonChannelListener {
    public TimeSpan ReceiveTimeout { get; }
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual void ReceiveRequest(RequestContext requestContext, Action callback, bool canDispatchOnThisThread);
}
internal interface System.ServiceModel.Channels.ISocketListenerSettings {
    public int BufferSize { get; }
    public bool TeredoEnabled { get; }
    public int ListenBacklog { get; }
    public abstract virtual int get_BufferSize();
    public abstract virtual bool get_TeredoEnabled();
    public abstract virtual int get_ListenBacklog();
}
internal interface System.ServiceModel.Channels.IStreamedMessageEncoder {
    public abstract virtual Stream GetResponseMessageStream(Message message);
}
internal interface System.ServiceModel.Channels.IStreamUpgradeChannelBindingProvider {
    public abstract virtual ChannelBinding GetChannelBinding(StreamUpgradeInitiator upgradeInitiator, ChannelBindingKind kind);
    public abstract virtual ChannelBinding GetChannelBinding(StreamUpgradeAcceptor upgradeAcceptor, ChannelBindingKind kind);
}
internal interface System.ServiceModel.Channels.ITcpChannelFactorySettings {
    public TimeSpan LeaseTimeout { get; }
    public abstract virtual TimeSpan get_LeaseTimeout();
}
public interface System.ServiceModel.Channels.ITransactedBindingElement {
    public bool TransactedReceiveEnabled { get; }
    public abstract virtual bool get_TransactedReceiveEnabled();
}
internal interface System.ServiceModel.Channels.ITransactionChannel {
    public abstract virtual void WriteTransactionDataToMessage(Message message, MessageDirection direction);
    public abstract virtual void ReadTransactionDataFromMessage(Message message, MessageDirection direction);
    public abstract virtual void ReadIssuedTokens(Message message, MessageDirection direction);
    public abstract virtual void WriteIssuedTokens(Message message, MessageDirection direction);
}
internal interface System.ServiceModel.Channels.ITransactionChannelManager {
    public TransactionProtocol TransactionProtocol { get; public set; }
    public TransactionFlowOption FlowIssuedTokens { get; public set; }
    public IDictionary`2<DirectionalAction, TransactionFlowOption> Dictionary { get; }
    public SecurityStandardsManager StandardsManager { get; }
    public abstract virtual TransactionProtocol get_TransactionProtocol();
    public abstract virtual void set_TransactionProtocol(TransactionProtocol value);
    public abstract virtual TransactionFlowOption get_FlowIssuedTokens();
    public abstract virtual void set_FlowIssuedTokens(TransactionFlowOption value);
    public abstract virtual IDictionary`2<DirectionalAction, TransactionFlowOption> get_Dictionary();
    public abstract virtual TransactionFlowOption GetTransaction(MessageDirection direction, string action);
    public abstract virtual SecurityStandardsManager get_StandardsManager();
}
internal interface System.ServiceModel.Channels.ITransportCompressionSupport {
    public abstract virtual bool IsCompressionFormatSupported(CompressionFormat compressionFormat);
}
internal interface System.ServiceModel.Channels.ITransportFactorySettings {
    public bool ManualAddressing { get; }
    public BufferManager BufferManager { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual bool get_ManualAddressing();
    public abstract virtual BufferManager get_BufferManager();
    public abstract virtual long get_MaxReceivedMessageSize();
    public abstract virtual MessageEncoderFactory get_MessageEncoderFactory();
    public abstract virtual MessageVersion get_MessageVersion();
}
internal interface System.ServiceModel.Channels.ITransportManagerRegistration {
    public HostNameComparisonMode HostNameComparisonMode { get; }
    public Uri ListenUri { get; }
    public abstract virtual HostNameComparisonMode get_HostNameComparisonMode();
    public abstract virtual Uri get_ListenUri();
    public abstract virtual IList`1<TransportManager> Select(TransportChannelListener factory);
}
internal interface System.ServiceModel.Channels.ITransportPolicyImport {
    public abstract virtual void ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
}
public interface System.ServiceModel.Channels.ITransportTokenAssertionProvider {
    public abstract virtual XmlElement GetTransportTokenAssertion();
}
internal interface System.ServiceModel.Channels.IWebMessageEncoderHelper {
    public abstract virtual void EnableBodyReaderMoveToContent();
}
public interface System.ServiceModel.Channels.IWebSocketCloseDetails {
    public Nullable`1<WebSocketCloseStatus> InputCloseStatus { get; }
    public string InputCloseStatusDescription { get; }
    public abstract virtual Nullable`1<WebSocketCloseStatus> get_InputCloseStatus();
    public abstract virtual string get_InputCloseStatusDescription();
    public abstract virtual void SetOutputCloseStatus(WebSocketCloseStatus closeStatus, string closeStatusDescription);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.KeyContainerHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.KeyHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.LastMessageNumberExceededFault : WsrmHeaderFault {
    public LastMessageNumberExceededFault(UniqueId sequenceID);
    public LastMessageNumberExceededFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
}
internal class System.ServiceModel.Channels.LateBoundChannelParameterCollection : ChannelParameterCollection {
    protected IChannel Channel { get; }
    protected virtual IChannel get_Channel();
    internal void SetChannel(IChannel channel);
}
internal abstract class System.ServiceModel.Channels.LayeredChannel`1 : ChannelBase {
    protected TInnerChannel InnerChannel { get; }
    protected LayeredChannel`1(ChannelManagerBase channelManager, TInnerChannel innerChannel);
    protected TInnerChannel get_InnerChannel();
    public virtual T GetProperty();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.LayeredChannelAcceptor`2 : ChannelAcceptor`1<TChannel> {
    protected LayeredChannelAcceptor`2(ChannelManagerBase channelManager, IChannelListener`1<TInnerChannel> innerListener);
    protected abstract virtual TChannel OnAcceptChannel(TInnerChannel innerChannel);
    public virtual TChannel AcceptChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual TChannel EndAcceptChannel(IAsyncResult result);
    public virtual bool WaitForChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool EndWaitForChannel(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.LayeredChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    protected IChannelFactory InnerChannelFactory { get; }
    public LayeredChannelFactory`1(IDefaultCommunicationTimeouts timeouts, IChannelFactory innerChannelFactory);
    protected IChannelFactory get_InnerChannelFactory();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnAbort();
}
internal abstract class System.ServiceModel.Channels.LayeredChannelListener`1 : ChannelListenerBase`1<TChannel> {
    internal IChannelListener InnerChannelListener { get; internal set; }
    internal bool SharedInnerListener { get; }
    public Uri Uri { get; }
    protected LayeredChannelListener`1(IDefaultCommunicationTimeouts timeouts, IChannelListener innerChannelListener);
    protected LayeredChannelListener`1(bool sharedInnerListener);
    protected LayeredChannelListener`1(bool sharedInnerListener, IDefaultCommunicationTimeouts timeouts);
    protected LayeredChannelListener`1(bool sharedInnerListener, IDefaultCommunicationTimeouts timeouts, IChannelListener innerChannelListener);
    internal virtual IChannelListener get_InnerChannelListener();
    internal virtual void set_InnerChannelListener(IChannelListener value);
    internal bool get_SharedInnerListener();
    public virtual Uri get_Uri();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpening();
    internal void ThrowIfInnerListenerNotSet();
    internal IChannelListener GetInnerListenerSnapshot();
}
internal class System.ServiceModel.Channels.LayeredDuplexChannel : LayeredInputChannel {
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public LayeredDuplexChannel(ChannelManagerBase channelManager, IInputChannel innerInputChannel, EndpointAddress localAddress, IOutputChannel innerOutputChannel);
    public virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
}
internal class System.ServiceModel.Channels.LayeredInputChannel : LayeredChannel`1<IInputChannel> {
    public EndpointAddress LocalAddress { get; }
    public LayeredInputChannel(ChannelManagerBase channelManager, IInputChannel innerChannel);
    public virtual EndpointAddress get_LocalAddress();
    protected virtual void OnReceive(Message message);
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.LifetimeManager : object {
    public int BusyCount { get; }
    protected LifetimeState State { get; }
    protected object ThisLock { get; }
    public LifetimeManager(object mutex);
    public int get_BusyCount();
    protected LifetimeState get_State();
    protected object get_ThisLock();
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void Close(TimeSpan timeout);
    protected void DecrementBusyCount();
    public sealed virtual void EndClose(IAsyncResult result);
    protected virtual void IncrementBusyCount();
    protected virtual void IncrementBusyCountWithoutLock();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEmpty();
    protected virtual void OnEndClose(IAsyncResult result);
}
internal enum System.ServiceModel.Channels.LifetimeState : Enum {
    public int value__;
    public static LifetimeState Opened;
    public static LifetimeState Closing;
    public static LifetimeState Closed;
}
internal class System.ServiceModel.Channels.LocalAddressProvider : object {
    public EndpointAddress LocalAddress { get; }
    public MessageFilter Filter { get; }
    public int Priority { get; }
    public LocalAddressProvider(EndpointAddress localAddress, MessageFilter filter);
    public EndpointAddress get_LocalAddress();
    public MessageFilter get_Filter();
    public int get_Priority();
}
public class System.ServiceModel.Channels.LocalClientSecuritySettings : object {
    public bool DetectReplays { get; public set; }
    public int ReplayCacheSize { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    public bool CacheCookies { get; public set; }
    public TimeSpan MaxCookieCachingTime { get; public set; }
    public int CookieRenewalThresholdPercentage { get; public set; }
    public TimeSpan SessionKeyRenewalInterval { get; public set; }
    public TimeSpan SessionKeyRolloverInterval { get; public set; }
    public bool ReconnectTransportOnFailure { get; public set; }
    public IdentityVerifier IdentityVerifier { get; public set; }
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public NonceCache get_NonceCache();
    public void set_NonceCache(NonceCache value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    public bool get_CacheCookies();
    public void set_CacheCookies(bool value);
    public TimeSpan get_MaxCookieCachingTime();
    public void set_MaxCookieCachingTime(TimeSpan value);
    public int get_CookieRenewalThresholdPercentage();
    public void set_CookieRenewalThresholdPercentage(int value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    public bool get_ReconnectTransportOnFailure();
    public void set_ReconnectTransportOnFailure(bool value);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public LocalClientSecuritySettings Clone();
}
public class System.ServiceModel.Channels.LocalServiceSecuritySettings : object {
    public bool DetectReplays { get; public set; }
    public int ReplayCacheSize { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public TimeSpan IssuedCookieLifetime { get; public set; }
    public int MaxStatefulNegotiations { get; public set; }
    public TimeSpan NegotiationTimeout { get; public set; }
    public int MaxPendingSessions { get; public set; }
    public TimeSpan InactivityTimeout { get; public set; }
    public TimeSpan SessionKeyRenewalInterval { get; public set; }
    public TimeSpan SessionKeyRolloverInterval { get; public set; }
    public bool ReconnectTransportOnFailure { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    public int MaxCachedCookies { get; public set; }
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public NonceCache get_NonceCache();
    public void set_NonceCache(NonceCache value);
    public TimeSpan get_IssuedCookieLifetime();
    public void set_IssuedCookieLifetime(TimeSpan value);
    public int get_MaxStatefulNegotiations();
    public void set_MaxStatefulNegotiations(int value);
    public TimeSpan get_NegotiationTimeout();
    public void set_NegotiationTimeout(TimeSpan value);
    public int get_MaxPendingSessions();
    public void set_MaxPendingSessions(int value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    public bool get_ReconnectTransportOnFailure();
    public void set_ReconnectTransportOnFailure(bool value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    public int get_MaxCachedCookies();
    public void set_MaxCachedCookies(int value);
    public LocalServiceSecuritySettings Clone();
}
internal class System.ServiceModel.Channels.LockHelper : ValueType {
    private ReaderWriterLockSlim readerWriterLock;
    private bool isReaderLock;
    private bool isLockHeld;
    public sealed virtual void Dispose();
    internal static IDisposable TakeWriterLock(ReaderWriterLockSlim readerWriterLock);
    internal static IDisposable TakeReaderLock(ReaderWriterLockSlim readerWriterLock);
}
internal class System.ServiceModel.Channels.MaintainerClosedHandler : MulticastDelegate {
    public MaintainerClosedHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.ServiceModel.Channels.MaskingMode : Enum {
    public int value__;
    public static MaskingMode None;
    public static MaskingMode Handled;
    public static MaskingMode Unhandled;
    public static MaskingMode All;
}
internal class System.ServiceModel.Channels.MaxMessageSizeStream : DelegatingStream {
    public MaxMessageSizeStream(Stream stream, long maxMessageSize);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult result);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    internal static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
    internal static Exception CreateMaxSentMessageSizeExceededException(long maxMessageSize);
}
public abstract class System.ServiceModel.Channels.Message : object {
    internal static int InitialBufferSize;
    public MessageHeaders Headers { get; }
    protected bool IsDisposed { get; }
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageState State { get; }
    public abstract virtual MessageHeaders get_Headers();
    protected bool get_IsDisposed();
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public abstract virtual MessageProperties get_Properties();
    public abstract virtual MessageVersion get_Version();
    internal virtual RecycledMessageState get_RecycledMessageState();
    public MessageState get_State();
    internal void BodyToString(XmlDictionaryWriter writer);
    public void Close();
    public MessageBuffer CreateBufferedCopy(int maxBufferSize);
    public static Message CreateMessage(MessageVersion version, string action, object body);
    public static Message CreateMessage(MessageVersion version, string action, object body, XmlObjectSerializer serializer);
    public static Message CreateMessage(MessageVersion version, string action, XmlReader body);
    public static Message CreateMessage(MessageVersion version, string action, XmlDictionaryReader body);
    public static Message CreateMessage(MessageVersion version, string action, BodyWriter body);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter body);
    public static Message CreateMessage(MessageVersion version, string action);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader);
    public static Message CreateMessage(XmlReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(XmlDictionaryReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, string action);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, object detail, string action);
    public static Message CreateMessage(MessageVersion version, MessageFault fault, string action);
    internal Exception CreateMessageDisposedException();
    private sealed virtual override void System.IDisposable.Dispose();
    public T GetBody();
    protected virtual T OnGetBody(XmlDictionaryReader reader);
    public T GetBody(XmlObjectSerializer serializer);
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetReaderAtBodyContents();
    internal void EnsureReadMessageState();
    internal SeekableMessageNavigator GetNavigator(bool navigateBody, int maxNodes);
    internal void InitializeReply(Message request);
    internal static bool IsFaultStartElement(XmlDictionaryReader reader, EnvelopeVersion version);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    internal MessageBuffer OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    public void WriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    public virtual string ToString();
    internal void ToString(XmlDictionaryWriter writer);
    public string GetBodyAttribute(string localName, string ns);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    internal void ReadFromBodyContentsToEnd(XmlDictionaryReader reader);
    internal static bool ReadStartBody(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion, Boolean& isFault, Boolean& isEmpty);
    public void WriteBody(XmlWriter writer);
    public void WriteBody(XmlDictionaryWriter writer);
    public void WriteStartBody(XmlWriter writer);
    public void WriteStartBody(XmlDictionaryWriter writer);
    internal void WriteStartHeaders(XmlDictionaryWriter writer);
    public void WriteMessage(XmlWriter writer);
    public void WriteMessage(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteMessage(IAsyncResult result);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    internal void WriteMessagePreamble(XmlDictionaryWriter writer);
    internal void WriteMessagePostamble(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.MessageAttemptInfo : ValueType {
    private Message message;
    private int retryCount;
    private long sequenceNumber;
    private object state;
    public Message Message { get; }
    public int RetryCount { get; }
    public object State { get; }
    public MessageAttemptInfo(Message message, long sequenceNumber, int retryCount, object state);
    public Message get_Message();
    public int get_RetryCount();
    public object get_State();
    public long GetSequenceNumber();
}
public abstract class System.ServiceModel.Channels.MessageBuffer : object {
    public int BufferSize { get; }
    public string MessageContentType { get; }
    public abstract virtual int get_BufferSize();
    private sealed virtual override void System.IDisposable.Dispose();
    public abstract virtual void Close();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    public abstract virtual Message CreateMessage();
    internal Exception CreateBufferDisposedException();
    public sealed virtual XPathNavigator CreateNavigator();
    public XPathNavigator CreateNavigator(int nodeQuota);
    public XPathNavigator CreateNavigator(XmlSpace space);
    public XPathNavigator CreateNavigator(int nodeQuota, XmlSpace space);
}
public abstract class System.ServiceModel.Channels.MessageEncoder : object {
    public string ContentType { get; }
    public string MediaType { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual string get_MediaType();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual T GetProperty();
    public Message ReadMessage(Stream stream, int maxSizeOfHeaders);
    public abstract virtual Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
    public Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    public abstract virtual Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    internal ArraySegment`1<byte> BufferMessageStream(Stream stream, BufferManager bufferManager, int maxBufferSize);
    internal virtual Message ReadMessage(Stream stream, BufferManager bufferManager, int maxBufferSize, string contentType);
    public virtual string ToString();
    public abstract virtual void WriteMessage(Message message, Stream stream);
    public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
    public virtual void EndWriteMessage(IAsyncResult result);
    public ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager);
    public abstract virtual ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual bool IsContentTypeSupported(string contentType);
    internal bool IsContentTypeSupported(string contentType, string supportedContentType, string supportedMediaType);
    internal virtual bool IsCharSetSupported(string charset);
    internal void ThrowIfMismatchedMessageVersion(Message message);
    internal string GetTraceSourceString();
}
internal static class System.ServiceModel.Channels.MessageEncoderCompressionHandler : object {
    internal static string GZipContentEncoding;
    internal static string DeflateContentEncoding;
    internal static void DecompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat, long maxReceivedMessageSize);
    internal static void CompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat);
    internal static Stream GetDecompressStream(Stream compressedStream, CompressionFormat compressionFormat);
    internal static Stream GetCompressStream(Stream uncompressedStream, CompressionFormat compressionFormat);
}
public abstract class System.ServiceModel.Channels.MessageEncoderFactory : object {
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual MessageEncoder get_Encoder();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual MessageEncoder CreateSessionEncoder();
}
public abstract class System.ServiceModel.Channels.MessageEncodingBindingElement : BindingElement {
    public MessageVersion MessageVersion { get; public set; }
    internal bool IsWsdlExportable { get; }
    protected MessageEncodingBindingElement(MessageEncodingBindingElement elementToBeCloned);
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual void set_MessageVersion(MessageVersion value);
    internal virtual bool get_IsWsdlExportable();
    internal IChannelFactory`1<TChannel> InternalBuildChannelFactory(BindingContext context);
    internal bool InternalCanBuildChannelFactory(BindingContext context);
    internal IChannelListener`1<TChannel> InternalBuildChannelListener(BindingContext context);
    internal bool InternalCanBuildChannelListener(BindingContext context);
    public abstract virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.MessageEncodingBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportContract(WsdlImporter importer, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
internal static class System.ServiceModel.Channels.MessageEncodingPolicyConstants : object {
    public static string BinaryEncodingName;
    public static string BinaryEncodingNamespace;
    public static string BinaryEncodingPrefix;
    public static string OptimizedMimeSerializationNamespace;
    public static string OptimizedMimeSerializationPrefix;
    public static string MtomEncodingName;
}
public abstract class System.ServiceModel.Channels.MessageFault : object {
    internal static MessageFault Default { get; }
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool IsMustUnderstandFault { get; }
    public string Node { get; }
    public bool HasDetail { get; }
    public FaultReason Reason { get; }
    public static MessageFault CreateFault(FaultCode code, string reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public static MessageFault CreateFault(Message message, int maxBufferSize);
    internal static MessageFault get_Default();
    public virtual string get_Actor();
    public abstract virtual FaultCode get_Code();
    public bool get_IsMustUnderstandFault();
    public virtual string get_Node();
    public abstract virtual bool get_HasDetail();
    public abstract virtual FaultReason get_Reason();
    public T GetDetail();
    public T GetDetail(XmlObjectSerializer serializer);
    public XmlDictionaryReader GetReaderAtDetailContents();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected abstract virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    public static bool WasHeaderNotUnderstood(MessageHeaders headers, string name, string ns);
    public void WriteTo(XmlWriter writer, EnvelopeVersion version);
    public void WriteTo(XmlDictionaryWriter writer, EnvelopeVersion version);
}
public abstract class System.ServiceModel.Channels.MessageHeader : MessageHeaderInfo {
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string ToString();
    public void WriteHeader(XmlWriter writer, MessageVersion messageVersion);
    public void WriteHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected abstract virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected void WriteHeaderAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static MessageHeader CreateHeader(string name, string ns, object value);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor, bool relay);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    internal static void GetHeaderAttributes(XmlDictionaryReader reader, MessageVersion version, String& actor, Boolean& mustUnderstand, Boolean& relay, Boolean& isReferenceParameter);
}
public abstract class System.ServiceModel.Channels.MessageHeaderInfo : object {
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public abstract virtual string get_Actor();
    public abstract virtual bool get_IsReferenceParameter();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual bool get_MustUnderstand();
    public abstract virtual bool get_Relay();
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageHeaders : object {
    internal static string WildcardAction;
    public string Action { get; public set; }
    internal bool CanRecycle { get; }
    internal bool ContainsOnlyBufferedMessageHeaders { get; }
    internal int CollectionVersion { get; }
    public int Count { get; }
    public EndpointAddress FaultTo { get; public set; }
    public EndpointAddress From { get; public set; }
    internal bool HasMustUnderstandBeenModified { get; }
    public UniqueId MessageId { get; public set; }
    public MessageVersion MessageVersion { get; }
    public UniqueId RelatesTo { get; public set; }
    public EndpointAddress ReplyTo { get; public set; }
    public Uri To { get; public set; }
    public UnderstoodHeaders UnderstoodHeaders { get; }
    public MessageHeaderInfo Item { get; }
    public MessageHeaders(MessageVersion version, int initialSize);
    public MessageHeaders(MessageVersion version);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes, Int32& maxSizeOfHeaders);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    internal MessageHeaders(MessageVersion version, MessageHeaders headers, IBufferedMessageData bufferedMessageData);
    public MessageHeaders(MessageHeaders collection);
    public string get_Action();
    public void set_Action(string value);
    internal bool get_CanRecycle();
    internal bool get_ContainsOnlyBufferedMessageHeaders();
    internal int get_CollectionVersion();
    public int get_Count();
    public EndpointAddress get_FaultTo();
    public void set_FaultTo(EndpointAddress value);
    public EndpointAddress get_From();
    public void set_From(EndpointAddress value);
    internal bool get_HasMustUnderstandBeenModified();
    public UniqueId get_MessageId();
    public void set_MessageId(UniqueId value);
    public MessageVersion get_MessageVersion();
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public EndpointAddress get_ReplyTo();
    public void set_ReplyTo(EndpointAddress value);
    public Uri get_To();
    public void set_To(Uri value);
    public UnderstoodHeaders get_UnderstoodHeaders();
    public MessageHeaderInfo get_Item(int index);
    public void Add(MessageHeader header);
    internal void AddActionHeader(ActionHeader actionHeader);
    internal void AddMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void AddRelatesToHeader(RelatesToHeader relatesToHeader);
    internal void AddReplyToHeader(ReplyToHeader replyToHeader);
    internal void AddToHeader(ToHeader toHeader);
    internal void AddUnderstood(int i);
    internal void AddUnderstood(MessageHeaderInfo headerInfo);
    public void Clear();
    public void CopyHeaderFrom(Message message, int headerIndex);
    public void CopyHeaderFrom(MessageHeaders collection, int headerIndex);
    public void CopyHeadersFrom(Message message);
    public void CopyHeadersFrom(MessageHeaders collection);
    public void CopyTo(MessageHeaderInfo[] array, int index);
    public int FindHeader(string name, string ns);
    public int FindHeader(string name, string ns, String[] actors);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    internal IEnumerator`1<MessageHeaderInfo> GetUnderstoodEnumerator();
    public T GetHeader(string name, string ns);
    public T GetHeader(string name, string ns, String[] actors);
    public T GetHeader(string name, string ns, XmlObjectSerializer serializer);
    public T GetHeader(int index);
    public T GetHeader(int index, XmlObjectSerializer serializer);
    public XmlDictionaryReader GetReaderAtHeader(int headerIndex);
    internal UniqueId GetRelatesTo(Uri relationshipType);
    internal String[] GetHeaderAttributes(string localName, string ns);
    internal MessageHeader GetMessageHeader(int index);
    internal Collection`1<MessageHeaderInfo> GetHeadersNotUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood(String[] actors);
    internal void Init(MessageVersion version, int initialSize);
    internal void Init(MessageVersion version);
    internal void Init(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public void Insert(int headerIndex, MessageHeader header);
    internal bool IsUnderstood(int i);
    internal bool IsUnderstood(MessageHeaderInfo headerInfo);
    internal void Recycle(HeaderInfoCache headerInfoCache);
    internal void RemoveUnderstood(MessageHeaderInfo headerInfo);
    public void RemoveAll(string name, string ns);
    public void RemoveAt(int headerIndex);
    internal void ReplaceAt(int headerIndex, MessageHeader header);
    public void SetAction(XmlDictionaryString action);
    internal void SetActionHeader(ActionHeader actionHeader);
    internal void SetFaultToHeader(FaultToHeader faultToHeader);
    internal void SetFromHeader(FromHeader fromHeader);
    internal void SetMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void SetRelatesTo(Uri relationshipType, UniqueId messageId);
    internal void SetReplyToHeader(ReplyToHeader replyToHeader);
    internal void SetToHeader(ToHeader toHeader);
    public void WriteHeader(int headerIndex, XmlWriter writer);
    public void WriteHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteStartHeader(int headerIndex, XmlWriter writer);
    public void WriteStartHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.MessageIDHeader : AddressingHeader {
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId MessageId { get; }
    public bool MustUnderstand { get; }
    public virtual XmlDictionaryString get_DictionaryName();
    public UniqueId get_MessageId();
    public virtual bool get_MustUnderstand();
    public static MessageIDHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static UniqueId ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static MessageIDHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.MessageNumberRolloverFault : WsrmHeaderFault {
    public MessageNumberRolloverFault(UniqueId sequenceID);
    public MessageNumberRolloverFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.MessagePatterns : object {
    private static MessagePatterns();
    public MessagePatterns(IXmlDictionary dictionary, XmlBinaryReaderSession readerSession, MessageVersion messageVersion);
    public Message TryCreateMessage(Byte[] buffer, int offset, int size, BufferManager bufferManager, BufferedMessageData messageData);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageProperties : object {
    public object Item { get; public set; }
    internal bool CanRecycle { get; }
    public int Count { get; }
    public MessageEncoder Encoder { get; public set; }
    public bool AllowOutputBatching { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public SecurityMessageProperty Security { get; public set; }
    public ICollection`1<object> Values { get; }
    public Uri Via { get; public set; }
    public MessageProperties(MessageProperties properties);
    internal MessageProperties(KeyValuePair`2[] array);
    private static MessageProperties();
    public sealed virtual object get_Item(string name);
    public sealed virtual void set_Item(string name, object value);
    internal bool get_CanRecycle();
    public sealed virtual int get_Count();
    public MessageEncoder get_Encoder();
    public void set_Encoder(MessageEncoder value);
    public bool get_AllowOutputBatching();
    public void set_AllowOutputBatching(bool value);
    public bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public SecurityMessageProperty get_Security();
    public void set_Security(SecurityMessageProperty value);
    public sealed virtual ICollection`1<object> get_Values();
    public Uri get_Via();
    public void set_Via(Uri value);
    public sealed virtual void Add(string name, object property);
    public sealed virtual void Clear();
    public void CopyProperties(MessageProperties properties);
    internal void MergeProperties(MessageProperties properties);
    internal void CopyProperties(KeyValuePair`2[] array);
    public sealed virtual bool ContainsKey(string name);
    public sealed virtual void Dispose();
    internal void Recycle();
    public sealed virtual bool Remove(string name);
    public sealed virtual bool TryGetValue(string name, Object& value);
    internal bool TryGetValue(string name, TProperty& property);
    internal TProperty GetValue(string name);
    internal TProperty GetValue(string name, bool ensureTypeMatch);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> pair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> pair);
}
public enum System.ServiceModel.Channels.MessageState : Enum {
    public int value__;
    public static MessageState Created;
    public static MessageState Read;
    public static MessageState Written;
    public static MessageState Copied;
    public static MessageState Closed;
}
[TypeConverterAttribute("System.ServiceModel.Configuration.MessageVersionConverter")]
public class System.ServiceModel.Channels.MessageVersion : object {
    public AddressingVersion Addressing { get; }
    public static MessageVersion Default { get; }
    public EnvelopeVersion Envelope { get; }
    public static MessageVersion None { get; }
    public static MessageVersion Soap12WSAddressing10 { get; }
    public static MessageVersion Soap11WSAddressing10 { get; }
    public static MessageVersion Soap12WSAddressingAugust2004 { get; }
    public static MessageVersion Soap11WSAddressingAugust2004 { get; }
    public static MessageVersion Soap11 { get; }
    public static MessageVersion Soap12 { get; }
    private static MessageVersion();
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion);
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
    public AddressingVersion get_Addressing();
    public static MessageVersion get_Default();
    public EnvelopeVersion get_Envelope();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MessageVersion get_None();
    public static MessageVersion get_Soap12WSAddressing10();
    public static MessageVersion get_Soap11WSAddressing10();
    public static MessageVersion get_Soap12WSAddressingAugust2004();
    public static MessageVersion get_Soap11WSAddressingAugust2004();
    public static MessageVersion get_Soap11();
    public static MessageVersion get_Soap12();
    public virtual string ToString();
    internal bool IsMatch(MessageVersion messageVersion);
}
internal static class System.ServiceModel.Channels.Msmq : object {
    internal static bool ActiveDirectoryEnabled { get; }
    internal static Version Version { get; }
    internal static bool IsPerAppDeadLetterQueueSupported { get; }
    internal static bool IsAdvancedPoisonHandlingSupported { get; }
    internal static bool IsRejectMessageSupported { get; }
    internal static bool IsRemoteReceiveContextSupported { get; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    internal static SafeLibraryHandle ErrorStrings { get; }
    private static Msmq();
    internal static bool get_ActiveDirectoryEnabled();
    internal static Version get_Version();
    internal static bool get_IsPerAppDeadLetterQueueSupported();
    internal static bool get_IsAdvancedPoisonHandlingSupported();
    internal static bool get_IsRejectMessageSupported();
    internal static bool get_IsRemoteReceiveContextSupported();
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    internal static IPoisonHandlingStrategy CreatePoisonHandler(MsmqReceiveHelper receiver);
    internal static MsmqQueue CreateMsmqQueue(MsmqReceiveHelper receiver);
    internal static SafeLibraryHandle get_ErrorStrings();
    internal static void EnterXPSendLock(Boolean& lockHeld, ProtectionLevel protectionLevel);
    internal static void LeaveXPSendLock();
}
internal class System.ServiceModel.Channels.Msmq3PoisonHandler : object {
    internal Msmq3PoisonHandler(MsmqReceiveHelper receiver);
    public sealed virtual bool CheckAndHandlePoisonMessage(MsmqMessageProperty messageProperty);
    public sealed virtual void FinalDisposition(MsmqMessageProperty messageProperty);
    public sealed virtual void Open();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.Msmq4PoisonHandler : object {
    public Msmq4PoisonHandler(MsmqReceiveHelper receiver);
    private static Msmq4PoisonHandler();
    public sealed virtual void Open();
    public sealed virtual bool CheckAndHandlePoisonMessage(MsmqMessageProperty messageProperty);
    public bool ReceiveContextPoisonHandling(MsmqMessageProperty messageProperty);
    public bool NonReceiveContextPoisonHandling(MsmqMessageProperty messageProperty);
    public sealed virtual void FinalDisposition(MsmqMessageProperty messageProperty);
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.Msmq4SubqueuePoisonHandler : object {
    public Msmq4SubqueuePoisonHandler(MsmqReceiveHelper receiver);
    public sealed virtual void Open();
    public sealed virtual bool CheckAndHandlePoisonMessage(MsmqMessageProperty messageProperty);
    public sealed virtual void FinalDisposition(MsmqMessageProperty messageProperty);
    public sealed virtual void Dispose();
}
public abstract class System.ServiceModel.Channels.MsmqBindingElementBase : TransportBindingElement {
    internal IReceiveContextSettings ReceiveContextSettings { get; internal set; }
    internal IAddressTranslator AddressTranslator { get; }
    public Uri CustomDeadLetterQueue { get; public set; }
    public DeadLetterQueue DeadLetterQueue { get; public set; }
    public bool Durable { get; public set; }
    public bool TransactedReceiveEnabled { get; }
    public bool ExactlyOnce { get; public set; }
    public int ReceiveRetryCount { get; public set; }
    public int MaxRetryCycles { get; public set; }
    public MsmqTransportSecurity MsmqTransportSecurity { get; internal set; }
    public bool ReceiveContextEnabled { get; public set; }
    public ReceiveErrorHandling ReceiveErrorHandling { get; public set; }
    public TimeSpan RetryCycleDelay { get; public set; }
    public TimeSpan TimeToLive { get; public set; }
    public bool UseMsmqTracing { get; public set; }
    public bool UseSourceJournal { get; public set; }
    public TimeSpan ValidityDuration { get; public set; }
    internal string WsdlTransportUri { get; }
    internal MsmqBindingElementBase(MsmqBindingElementBase elementToBeCloned);
    [CompilerGeneratedAttribute]
internal IReceiveContextSettings get_ReceiveContextSettings();
    [CompilerGeneratedAttribute]
internal void set_ReceiveContextSettings(IReceiveContextSettings value);
    internal abstract virtual IAddressTranslator get_AddressTranslator();
    public Uri get_CustomDeadLetterQueue();
    public void set_CustomDeadLetterQueue(Uri value);
    public DeadLetterQueue get_DeadLetterQueue();
    public void set_DeadLetterQueue(DeadLetterQueue value);
    public bool get_Durable();
    public void set_Durable(bool value);
    public sealed virtual bool get_TransactedReceiveEnabled();
    public bool get_ExactlyOnce();
    public void set_ExactlyOnce(bool value);
    public int get_ReceiveRetryCount();
    public void set_ReceiveRetryCount(int value);
    public int get_MaxRetryCycles();
    public void set_MaxRetryCycles(int value);
    public MsmqTransportSecurity get_MsmqTransportSecurity();
    internal void set_MsmqTransportSecurity(MsmqTransportSecurity value);
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    public ReceiveErrorHandling get_ReceiveErrorHandling();
    public void set_ReceiveErrorHandling(ReceiveErrorHandling value);
    public TimeSpan get_RetryCycleDelay();
    public void set_RetryCycleDelay(TimeSpan value);
    public TimeSpan get_TimeToLive();
    public void set_TimeToLive(TimeSpan value);
    public bool get_UseMsmqTracing();
    public void set_UseMsmqTracing(bool value);
    public bool get_UseSourceJournal();
    public void set_UseSourceJournal(bool value);
    public TimeSpan get_ValidityDuration();
    public void set_ValidityDuration(TimeSpan value);
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    private sealed virtual override void System.ServiceModel.Channels.ITransportPolicyImport.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    internal virtual string get_WsdlTransportUri();
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
}
internal abstract class System.ServiceModel.Channels.MsmqBindingFilter : object {
    public string CanonicalPrefix { get; }
    public MsmqBindingFilter(string path, IAddressTranslator addressing);
    public string get_CanonicalPrefix();
    public int Match(string name);
    public Uri CreateServiceUri(string host, string name, bool isPrivate);
    public abstract virtual object MatchFound(string host, string name, bool isPrivate);
    public abstract virtual void MatchLost(string host, string name, bool isPrivate, object callbackState);
}
internal class System.ServiceModel.Channels.MsmqBindingMonitor : object {
    public MsmqBindingMonitor(string host);
    public MsmqBindingMonitor(string host, TimeSpan updateInterval, bool retryMatchedFilters);
    private static MsmqBindingMonitor();
    public void AddFilter(MsmqBindingFilter filter);
    public bool ContainsFilter(MsmqBindingFilter filter);
    public void Open();
    public void Close();
    public void RemoveFilter(MsmqBindingFilter filter);
    public void WaitForFirstRoundComplete();
}
internal abstract class System.ServiceModel.Channels.MsmqChannelFactory`1 : MsmqChannelFactoryBase`1<TChannel> {
    public int MaxPoolSize { get; }
    public QueueTransferProtocol QueueTransferProtocol { get; }
    public bool UseActiveDirectory { get; }
    protected MsmqChannelFactory`1(MsmqTransportBindingElement bindingElement, BindingContext context);
    public int get_MaxPoolSize();
    public QueueTransferProtocol get_QueueTransferProtocol();
    public bool get_UseActiveDirectory();
}
internal abstract class System.ServiceModel.Channels.MsmqChannelFactoryBase`1 : TransportChannelFactory`1<TChannel> {
    internal IAddressTranslator AddressTranslator { get; }
    public Uri CustomDeadLetterQueue { get; }
    public DeadLetterQueue DeadLetterQueue { get; }
    internal string DeadLetterQueuePathName { get; }
    public bool Durable { get; }
    public bool ExactlyOnce { get; }
    public MsmqTransportSecurity MsmqTransportSecurity { get; }
    public string Scheme { get; }
    public TimeSpan TimeToLive { get; }
    public SecurityTokenManager SecurityTokenManager { get; }
    public bool UseSourceJournal { get; }
    public bool UseMsmqTracing { get; }
    internal bool IsMsmqX509SecurityConfigured { get; }
    protected MsmqChannelFactoryBase`1(MsmqBindingElementBase bindingElement, BindingContext context);
    protected MsmqChannelFactoryBase`1(MsmqBindingElementBase bindingElement, BindingContext context, MessageEncoderFactory encoderFactory);
    internal IAddressTranslator get_AddressTranslator();
    public Uri get_CustomDeadLetterQueue();
    public DeadLetterQueue get_DeadLetterQueue();
    internal string get_DeadLetterQueuePathName();
    public bool get_Durable();
    public bool get_ExactlyOnce();
    public MsmqTransportSecurity get_MsmqTransportSecurity();
    public virtual string get_Scheme();
    public TimeSpan get_TimeToLive();
    public SecurityTokenManager get_SecurityTokenManager();
    public bool get_UseSourceJournal();
    public bool get_UseMsmqTracing();
    internal bool get_IsMsmqX509SecurityConfigured();
    internal SecurityTokenProvider CreateTokenProvider(EndpointAddress to, Uri via);
    internal SecurityTokenProviderContainer CreateX509TokenProvider(EndpointAddress to, Uri via);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.MsmqChannelListenerBase : TransportChannelListener {
    internal MsmqReceiveParameters ReceiveParameters { get; }
    protected MsmqChannelListenerBase(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters, MessageEncoderFactory messageEncoderFactory);
    internal MsmqReceiveParameters get_ReceiveParameters();
    internal Exception NormalizePoisonException(long lookupId, Exception innerException);
    internal void FaultListener();
}
internal abstract class System.ServiceModel.Channels.MsmqChannelListenerBase`1 : MsmqChannelListenerBase {
    public string Scheme { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    protected MsmqChannelListenerBase`1(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters, MessageEncoderFactory messageEncoderFactory);
    public virtual string get_Scheme();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    protected virtual void OnCloseCore(bool isAborting);
    protected virtual void OnOpenCore(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnOpen(TimeSpan timeout);
    internal virtual IList`1<TransportManager> SelectTransportManagers();
    protected void SetSecurityTokenAuthenticator(string scheme, BindingContext context);
    internal SecurityMessageProperty ValidateSecurity(MsmqInputMessage msmqMessage);
    public abstract virtual TChannel AcceptChannel();
    public abstract virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.MsmqDateTime : object {
    public static DateTime ToDateTime(int seconds);
}
internal static class System.ServiceModel.Channels.MsmqDecodeHelper : object {
    internal static Message DecodeTransportDatagram(MsmqInputChannelListener listener, MsmqReceiveHelper receiver, MsmqInputMessage msmqMessage, MsmqMessageProperty messageProperty);
    internal static IInputSessionChannel DecodeTransportSessiongram(MsmqInputSessionChannelListener listener, MsmqInputMessage msmqMessage, MsmqMessageProperty messageProperty, MsmqReceiveContextLockManager receiveContextManager);
    internal static Message DecodeIntegrationDatagram(MsmqIntegrationChannelListener listener, MsmqReceiveHelper receiver, MsmqIntegrationInputMessage msmqMessage, MsmqMessageProperty messageProperty);
}
internal class System.ServiceModel.Channels.MsmqDefaultLockingQueue : MsmqQueue {
    public MsmqDefaultLockingQueue(string formatName, int accessMode);
    public virtual ReceiveResult TryReceive(NativeMsmqMessage message, TimeSpan timeout, MsmqTransactionMode transactionMode);
    public sealed virtual void DeleteMessage(long lookupId, TimeSpan timeout);
    public sealed virtual void UnlockMessage(long lookupId, TimeSpan timeout);
    public virtual void CloseQueue();
}
internal static class System.ServiceModel.Channels.MsmqDefaults : object {
    internal static MessageCredentialType DefaultClientCredentialType;
    internal static Uri CustomDeadLetterQueue;
    internal static DeadLetterQueue DeadLetterQueue;
    internal static bool Durable;
    internal static bool ExactlyOnce;
    internal static bool ReceiveContextEnabled;
    internal static int MaxRetryCycles;
    internal static int MaxPoolSize;
    internal static MsmqAuthenticationMode MsmqAuthenticationMode;
    internal static MsmqEncryptionAlgorithm MsmqEncryptionAlgorithm;
    internal static MsmqSecureHashAlgorithm MsmqSecureHashAlgorithm;
    internal static ProtectionLevel MsmqProtectionLevel;
    internal static ReceiveErrorHandling ReceiveErrorHandling;
    internal static int ReceiveRetryCount;
    internal static QueueTransferProtocol QueueTransferProtocol;
    internal static string RetryCycleDelayString;
    internal static string TimeToLiveString;
    internal static bool UseActiveDirectory;
    internal static bool UseSourceJournal;
    internal static bool UseMsmqTracing;
    internal static string ValidityDurationString;
    internal static TimeSpan RetryCycleDelay { get; }
    internal static TimeSpan TimeToLive { get; }
    internal static TimeSpan ValidityDuration { get; }
    internal static SecurityAlgorithmSuite MessageSecurityAlgorithmSuite { get; }
    internal static TimeSpan get_RetryCycleDelay();
    internal static TimeSpan get_TimeToLive();
    internal static TimeSpan get_ValidityDuration();
    internal static SecurityAlgorithmSuite get_MessageSecurityAlgorithmSuite();
}
internal static class System.ServiceModel.Channels.MsmqDiagnostics : object {
    private static MsmqDiagnostics();
    public static void CannotPeekOnQueue(string formatName, Exception ex);
    public static void CannotReadQueues(string host, bool publicQueues, Exception ex);
    public static ServiceModelActivity StartListenAtActivity(MsmqReceiveHelper receiver);
    public static Activity BoundOpenOperation(MsmqReceiveHelper receiver);
    public static Activity BoundReceiveOperation(MsmqReceiveHelper receiver);
    public static ServiceModelActivity BoundDecodeOperation();
    public static ServiceModelActivity BoundReceiveBytesOperation();
    public static void TransferFromTransport(Message message);
    public static void ExpectedException(Exception ex);
    public static void ScanStarted();
    public static void MatchedApplicationFound(string host, string queueName, bool isPrivate, string canonicalPath);
    public static void StartingApplication(string application);
    public static void StartingService(string host, string name, bool isPrivate, string processedVirtualPath);
    public static void FoundBaseAddress(Uri uri, string virtualPath);
    public static void DatagramReceived(BufferProperty messageId, Message message);
    public static void DatagramSent(BufferProperty messageId, Message message);
    public static void MessageConsumed(string uri, string messageId, bool rejected);
    public static void MessageLockedUnderTheTransaction(long lookupId);
    public static void MoveOrDeleteAttemptFailed(long lookupId);
    public static void MsmqDetected(Version version);
    public static void PoisonMessageMoved(string messageId, bool poisonQueue, string uri);
    public static void PoisonMessageRejected(string messageId, string uri);
    public static void PoolFull(int poolSize);
    public static void PotentiallyPoisonMessageDetected(string messageId);
    public static void QueueClosed(string formatName);
    public static void QueueOpened(string formatName);
    public static void QueueTransactionalStatusUnknown(string formatName);
    public static void SessiongramSent(string sessionId, BufferProperty messageId, int numberOfMessages);
    public static void SessiongramReceived(string sessionId, BufferProperty messageId, int numberOfMessages);
    public static void UnexpectedAcknowledgment(string messageId, int acknowledgment);
}
internal static class System.ServiceModel.Channels.MsmqDuration : object {
    public static int FromTimeSpan(TimeSpan timeSpan);
    public static TimeSpan ToTimeSpan(int seconds);
}
internal class System.ServiceModel.Channels.MsmqEmptyMessage : NativeMsmqMessage {
}
internal static class System.ServiceModel.Channels.MsmqFormatName : object {
    public static string ToSystemMessagingQueueName(string formatName);
    public static string FromQueuePath(string queuePath);
}
internal class System.ServiceModel.Channels.MsmqInputChannel : MsmqInputChannelBase {
    public MsmqInputChannel(MsmqInputChannelListener listener);
    protected virtual Message DecodeMsmqMessage(MsmqInputMessage msmqMessage, MsmqMessageProperty messageProperty);
}
internal abstract class System.ServiceModel.Channels.MsmqInputChannelBase : ChannelBase {
    public EndpointAddress LocalAddress { get; }
    protected MsmqReceiveHelper MsmqReceiveHelper { get; }
    protected MsmqReceiveParameters ReceiveParameters { get; }
    public MsmqInputChannelBase(MsmqInputChannelListenerBase listener, IMsmqMessagePool messagePool);
    public sealed virtual EndpointAddress get_LocalAddress();
    protected MsmqReceiveHelper get_MsmqReceiveHelper();
    protected MsmqReceiveParameters get_ReceiveParameters();
    protected virtual void OnCloseCore(bool isAborting);
    protected virtual void OnOpenCore();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnFaulted();
    protected abstract virtual Message DecodeMsmqMessage(MsmqInputMessage msmqMessage, MsmqMessageProperty property);
    internal void FaultChannel();
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.MsmqInputChannelListener : MsmqInputChannelListenerBase {
    internal MsmqInputChannelListener(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters);
    protected virtual IInputChannel CreateInputChannel(MsmqInputChannelListenerBase listener);
}
internal abstract class System.ServiceModel.Channels.MsmqInputChannelListenerBase : MsmqChannelListenerBase`1<IInputChannel> {
    internal MsmqInputChannelListenerBase(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters);
    internal MsmqInputChannelListenerBase(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters, MessageEncoderFactory encoderFactory);
    protected virtual void OnOpenCore(TimeSpan timeout);
    protected virtual void OnCloseCore(bool aborting);
    protected abstract virtual IInputChannel CreateInputChannel(MsmqInputChannelListenerBase listener);
    public virtual IInputChannel AcceptChannel();
    public virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public virtual IInputChannel AcceptChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IInputChannel EndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Channels.MsmqInputMessage : NativeMsmqMessage {
    public BufferProperty SenderId { get; }
    public IntProperty SenderIdLength { get; }
    public LongProperty LookupId { get; }
    public IntProperty AbortCount { get; }
    public IntProperty MoveCount { get; }
    public BufferProperty SenderCertificate { get; }
    public IntProperty SenderCertificateLength { get; }
    public IntProperty LastMovedTime { get; }
    public BufferProperty Body { get; }
    public IntProperty BodyLength { get; }
    public BufferProperty MessageId { get; }
    public ShortProperty Class { get; }
    public MsmqInputMessage(int maxBufferSize);
    protected MsmqInputMessage(int additionalPropertyCount, int maxBufferSize);
    protected MsmqInputMessage(int additionalPropertyCount, SizeQuota bufferSizeQuota);
    public virtual void GrowBuffers();
    protected virtual void OnGrowBuffers(SizeQuota bufferSizeQuota);
    public BufferProperty get_SenderId();
    public IntProperty get_SenderIdLength();
    public LongProperty get_LookupId();
    public IntProperty get_AbortCount();
    public IntProperty get_MoveCount();
    public BufferProperty get_SenderCertificate();
    public IntProperty get_SenderCertificateLength();
    public IntProperty get_LastMovedTime();
    public BufferProperty get_Body();
    public IntProperty get_BodyLength();
    public BufferProperty get_MessageId();
    public ShortProperty get_Class();
}
internal class System.ServiceModel.Channels.MsmqInputMessagePool : SynchronizedDisposablePool`1<MsmqInputMessage> {
    internal MsmqInputMessagePool(int maxPoolSize);
    private sealed virtual override MsmqInputMessage System.ServiceModel.Channels.IMsmqMessagePool.TakeMessage();
    private sealed virtual override void System.ServiceModel.Channels.IMsmqMessagePool.ReturnMessage(MsmqInputMessage message);
}
internal class System.ServiceModel.Channels.MsmqInputSessionChannel : InputChannel {
    public IInputSession Session { get; }
    public MsmqInputSessionChannel(MsmqInputSessionChannelListener listener, Transaction associatedTx, ReceiveContext sessiongramReceiveContext);
    public sealed virtual IInputSession get_Session();
    public virtual Message Receive();
    public virtual Message Receive(TimeSpan timeout);
    public virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool TryReceive(TimeSpan timeout, Message& message);
    public virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public void FaultChannel();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
}
internal class System.ServiceModel.Channels.MsmqInputSessionChannelListener : MsmqChannelListenerBase`1<IInputSessionChannel> {
    internal MsmqReceiveHelper MsmqReceiveHelper { get; }
    internal MsmqInputSessionChannelListener(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters);
    internal MsmqReceiveHelper get_MsmqReceiveHelper();
    protected virtual void OnCloseCore(bool aborting);
    protected virtual void OnOpenCore(TimeSpan timeout);
    public virtual IInputSessionChannel AcceptChannel();
    public virtual IInputSessionChannel AcceptChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IInputSessionChannel EndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected virtual void OnFaulted();
}
internal static class System.ServiceModel.Channels.MsmqIntegrationDefaults : object {
    internal static MsmqMessageSerializationFormat SerializationFormat;
}
internal static class System.ServiceModel.Channels.MsmqMessageId : object {
    public static string ToString(Byte[] messageId);
    public static Byte[] FromString(string messageId);
}
public class System.ServiceModel.Channels.MsmqMessageProperty : object {
    public static string Name;
    public Nullable`1<DeliveryFailure> DeliveryFailure { get; }
    public Nullable`1<DeliveryStatus> DeliveryStatus { get; }
    public int AbortCount { get; internal set; }
    internal long LookupId { get; }
    internal string MessageId { get; }
    public int MoveCount { get; internal set; }
    internal MsmqMessageProperty(MsmqInputMessage msmqMessage);
    public Nullable`1<DeliveryFailure> get_DeliveryFailure();
    public Nullable`1<DeliveryStatus> get_DeliveryStatus();
    public int get_AbortCount();
    internal void set_AbortCount(int value);
    internal long get_LookupId();
    internal string get_MessageId();
    public int get_MoveCount();
    internal void set_MoveCount(int value);
    public static MsmqMessageProperty Get(Message message);
}
internal class System.ServiceModel.Channels.MsmqNonTransactedPoisonHandler : object {
    internal MsmqNonTransactedPoisonHandler(MsmqReceiveHelper receiver);
    public sealed virtual void Open();
    public sealed virtual bool CheckAndHandlePoisonMessage(MsmqMessageProperty messageProperty);
    public sealed virtual void FinalDisposition(MsmqMessageProperty messageProperty);
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.MsmqOutputChannel : TransportOutputChannel {
    public MsmqOutputChannel(MsmqChannelFactory`1<IOutputChannel> factory, EndpointAddress to, Uri via, bool manualAddressing);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void OnSend(Message message, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.MsmqOutputChannelFactory : MsmqChannelFactory`1<IOutputChannel> {
    internal MsmqOutputChannelFactory(MsmqTransportBindingElement bindingElement, BindingContext context);
    protected virtual IOutputChannel OnCreateChannel(EndpointAddress to, Uri via);
}
internal class System.ServiceModel.Channels.MsmqOutputMessage`1 : NativeMsmqMessage {
    public BufferProperty Body { get; }
    public BufferProperty MessageId { get; }
    public MsmqOutputMessage`1(MsmqChannelFactoryBase`1<TChannel> factory, int bodySize, EndpointAddress remoteAddress);
    protected MsmqOutputMessage`1(MsmqChannelFactoryBase`1<TChannel> factory, int bodySize, EndpointAddress remoteAddress, int additionalPropertyCount);
    public BufferProperty get_Body();
    public BufferProperty get_MessageId();
    internal void ApplyCertificateIfNeeded(SecurityTokenProviderContainer certificateTokenProvider, MsmqAuthenticationMode authenticationMode, TimeSpan timeout);
    protected void EnsureBodyTypeProperty(int value);
    protected void EnsureDeadLetterQueueProperty(string value);
    protected void EnsureSenderIdTypeProperty(int value);
    protected void EnsureTimeToReachQueueProperty(int value);
    protected void EnsureJournalProperty(byte flag, bool isFlagSet);
}
internal class System.ServiceModel.Channels.MsmqOutputSessionChannel : TransportOutputChannel {
    public IOutputSession Session { get; }
    public MsmqOutputSessionChannel(MsmqChannelFactory`1<IOutputSessionChannel> factory, EndpointAddress to, Uri via, bool manualAddressing);
    public sealed virtual IOutputSession get_Session();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void OnSend(Message message, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.MsmqOutputSessionChannelFactory : MsmqChannelFactory`1<IOutputSessionChannel> {
    internal MsmqOutputSessionChannelFactory(MsmqTransportBindingElement bindingElement, BindingContext context);
    protected virtual IOutputSessionChannel OnCreateChannel(EndpointAddress to, Uri via);
}
internal class System.ServiceModel.Channels.MsmqQueue : object {
    protected int shareMode;
    protected string formatName;
    protected int accessMode;
    protected object ThisLock { get; }
    public string FormatName { get; }
    public MsmqQueue(string formatName, int accessMode);
    public MsmqQueue(string formatName, int accessMode, int shareMode);
    protected object get_ThisLock();
    public string get_FormatName();
    public virtual string ToString();
    public sealed virtual void Dispose();
    internal void EnsureOpen();
    protected MsmqQueueHandle GetHandle();
    internal virtual MsmqQueueHandle OpenQueue();
    public virtual void CloseQueue();
    protected void HandleIsStale(MsmqQueueHandle handle);
    public static void GetMsmqInformation(Version& version, Boolean& activeDirectoryEnabled);
    public static bool IsReadable(string formatName, MsmqException& ex);
    public static bool IsWriteable(string formatName);
    public static bool IsMoveable(string formatName);
    internal static bool IsQueueOpenable(string formatName, int accessMode, int shareMode, Int32& error);
    public static bool TryGetIsTransactional(string formatName, Boolean& isTransactional);
    protected static bool IsErrorDueToStaleHandle(int error);
    protected static bool IsReceiveErrorDueToInsufficientBuffer(int error);
    public void MarkMessageRejected(long lookupId);
    public MoveReceiveResult TryMoveMessage(long lookupId, MsmqQueue destinationQueue, MsmqTransactionMode transactionMode);
    public virtual ReceiveResult TryReceive(NativeMsmqMessage message, TimeSpan timeout, MsmqTransactionMode transactionMode);
    public MoveReceiveResult TryReceiveByLookupId(long lookupId, NativeMsmqMessage message, MsmqTransactionMode transactionMode);
    public MoveReceiveResult TryReceiveByLookupId(long lookupId, NativeMsmqMessage message, MsmqTransactionMode transactionMode, int action);
    [SecuritySafeCriticalAttribute]
protected int ReceiveByLookupIdCoreDtcTransacted(MsmqQueueHandle handle, long lookupId, NativeMsmqMessage message, MsmqTransactionMode transactionMode, int action);
    protected IDtcTransaction GetNativeTransaction(MsmqTransactionMode transactionMode);
    public ReceiveResult TryPeek(NativeMsmqMessage message, TimeSpan timeout);
    public void Send(NativeMsmqMessage message, MsmqTransactionMode transactionMode);
    public IAsyncResult BeginTryReceive(NativeMsmqMessage message, TimeSpan timeout, AsyncCallback callback, object state);
    public ReceiveResult EndTryReceive(IAsyncResult result);
    public IAsyncResult BeginPeek(NativeMsmqMessage message, TimeSpan timeout, AsyncCallback callback, object state);
    public ReceiveResult EndPeek(IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.MsmqQueueHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.MsmqReceiveContext : ReceiveContext {
    public long LookupId { get; }
    public DateTime ExpiryTime { get; }
    public MsmqReceiveContextLockManager Manager { get; }
    public MsmqReceiveContext(long lookupId, DateTime expiryTime, MsmqReceiveContextLockManager manager);
    public long get_LookupId();
    public DateTime get_ExpiryTime();
    public MsmqReceiveContextLockManager get_Manager();
    public void MarkContextExpired();
    protected virtual void OnComplete(TimeSpan timeout);
    protected virtual void OnAbandon(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginComplete(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndComplete(IAsyncResult result);
    protected virtual IAsyncResult OnBeginAbandon(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndAbandon(IAsyncResult result);
}
internal class System.ServiceModel.Channels.MsmqReceiveContextLockManager : object {
    public MsmqQueue Queue { get; }
    public MsmqReceiveContextLockManager(MsmqReceiveContextSettings receiveContextSettings, MsmqQueue queue);
    public MsmqQueue get_Queue();
    public MsmqReceiveContext CreateMsmqReceiveContext(long lookupId);
    public void DeleteMessage(MsmqReceiveContext receiveContext, TimeSpan timeout);
    public void UnlockMessage(MsmqReceiveContext receiveContext, TimeSpan timeout);
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.MsmqReceiveContextSettings : object {
    public TimeSpan ValidityDuration { get; private set; }
    public bool Enabled { get; public set; }
    public MsmqReceiveContextSettings(IReceiveContextSettings toBeCloned);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ValidityDuration();
    [CompilerGeneratedAttribute]
private void set_ValidityDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Enabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Enabled(bool value);
    internal void SetValidityDuration(TimeSpan validityDuration);
}
internal class System.ServiceModel.Channels.MsmqReceiveHelper : object {
    internal ServiceModelActivity Activity { get; }
    internal MsmqReceiveParameters MsmqReceiveParameters { get; }
    internal MsmqInputChannelBase Channel { get; }
    internal MsmqChannelListenerBase ChannelListener { get; }
    internal Uri ListenUri { get; }
    internal string InstanceId { get; }
    internal MsmqQueue Queue { get; }
    internal bool Transactional { get; }
    internal string MsmqRuntimeNativeLibrary { get; }
    internal MsmqReceiveHelper(MsmqReceiveParameters receiveParameters, Uri uri, IMsmqMessagePool messagePool, MsmqInputChannelBase channel, MsmqChannelListenerBase listener);
    internal ServiceModelActivity get_Activity();
    internal MsmqReceiveParameters get_MsmqReceiveParameters();
    internal MsmqInputChannelBase get_Channel();
    internal MsmqChannelListenerBase get_ChannelListener();
    internal Uri get_ListenUri();
    internal string get_InstanceId();
    internal MsmqQueue get_Queue();
    internal bool get_Transactional();
    internal string get_MsmqRuntimeNativeLibrary();
    internal void Open();
    internal void Close();
    internal MsmqInputMessage TakeMessage();
    internal void ReturnMessage(MsmqInputMessage message);
    internal static void TryAbortTransactionCurrent();
    internal void DropOrRejectReceivedMessage(MsmqMessageProperty messageProperty, bool reject);
    internal void DropOrRejectReceivedMessage(MsmqQueue queue, MsmqMessageProperty messageProperty, bool reject);
    internal static void MoveReceivedMessage(MsmqQueue queueFrom, MsmqQueue queueTo, long lookupId);
    internal void FinalDisposition(MsmqMessageProperty messageProperty);
    internal bool WaitForMessage(TimeSpan timeout);
    internal IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public bool EndWaitForMessage(IAsyncResult result);
    internal bool TryReceive(MsmqInputMessage msmqMessage, TimeSpan timeout, MsmqTransactionMode transactionMode, MsmqMessageProperty& property);
    internal IAsyncResult BeginTryReceive(MsmqInputMessage msmqMessage, TimeSpan timeout, MsmqTransactionMode transactionMode, AsyncCallback callback, object state);
    internal bool EndTryReceive(IAsyncResult result, MsmqInputMessage& msmqMessage, MsmqMessageProperty& msmqProperty);
}
internal abstract class System.ServiceModel.Channels.MsmqReceiveParameters : object {
    internal MsmqReceiveContextSettings ReceiveContextSettings { get; }
    internal IAddressTranslator AddressTranslator { get; }
    internal bool Durable { get; }
    internal bool ExactlyOnce { get; }
    internal int ReceiveRetryCount { get; }
    internal int MaxRetryCycles { get; }
    internal ReceiveErrorHandling ReceiveErrorHandling { get; }
    internal TimeSpan RetryCycleDelay { get; }
    internal MsmqTransportSecurity TransportSecurity { get; }
    internal bool UseMsmqTracing { get; }
    internal bool UseSourceJournal { get; }
    internal MsmqReceiveParameters(MsmqBindingElementBase bindingElement);
    internal MsmqReceiveParameters(MsmqBindingElementBase bindingElement, IAddressTranslator addressTranslator);
    internal MsmqReceiveContextSettings get_ReceiveContextSettings();
    internal IAddressTranslator get_AddressTranslator();
    internal bool get_Durable();
    internal bool get_ExactlyOnce();
    internal int get_ReceiveRetryCount();
    internal int get_MaxRetryCycles();
    internal ReceiveErrorHandling get_ReceiveErrorHandling();
    internal TimeSpan get_RetryCycleDelay();
    internal MsmqTransportSecurity get_TransportSecurity();
    internal bool get_UseMsmqTracing();
    internal bool get_UseSourceJournal();
}
internal class System.ServiceModel.Channels.MsmqSubqueueLockingQueue : MsmqQueue {
    public MsmqQueue LockQueueForReceive { get; }
    public MsmqSubqueueLockingQueue(string formatName, string hostname, int accessMode);
    public MsmqQueue get_LockQueueForReceive();
    internal virtual MsmqQueueHandle OpenQueue();
    internal void EnsureLockQueuesOpen();
    public virtual ReceiveResult TryReceive(NativeMsmqMessage message, TimeSpan timeout, MsmqTransactionMode transactionMode);
    public sealed virtual void DeleteMessage(long lookupId, TimeSpan timeout);
    public sealed virtual void UnlockMessage(long lookupId, TimeSpan timeout);
    public virtual void CloseQueue();
}
internal enum System.ServiceModel.Channels.MsmqTransactionMode : Enum {
    public int value__;
    public static MsmqTransactionMode None;
    public static MsmqTransactionMode Single;
    public static MsmqTransactionMode CurrentOrSingle;
    public static MsmqTransactionMode CurrentOrNone;
    public static MsmqTransactionMode CurrentOrThrow;
}
public class System.ServiceModel.Channels.MsmqTransportBindingElement : MsmqBindingElementBase {
    internal IAddressTranslator AddressTranslator { get; }
    public int MaxPoolSize { get; public set; }
    public QueueTransferProtocol QueueTransferProtocol { get; public set; }
    public string Scheme { get; }
    public bool UseActiveDirectory { get; public set; }
    internal string WsdlTransportUri { get; }
    internal virtual IAddressTranslator get_AddressTranslator();
    public int get_MaxPoolSize();
    public void set_MaxPoolSize(int value);
    public QueueTransferProtocol get_QueueTransferProtocol();
    public void set_QueueTransferProtocol(QueueTransferProtocol value);
    public virtual string get_Scheme();
    public bool get_UseActiveDirectory();
    public void set_UseActiveDirectory(bool value);
    internal virtual string get_WsdlTransportUri();
    public virtual BindingElement Clone();
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
}
internal class System.ServiceModel.Channels.MsmqTransportReceiveParameters : MsmqReceiveParameters {
    internal int MaxPoolSize { get; }
    internal bool UseActiveDirectory { get; }
    internal QueueTransferProtocol QueueTransferProtocol { get; }
    internal MsmqTransportReceiveParameters(MsmqTransportBindingElement bindingElement, IAddressTranslator addressTranslator);
    internal int get_MaxPoolSize();
    internal bool get_UseActiveDirectory();
    internal QueueTransferProtocol get_QueueTransferProtocol();
}
internal static class System.ServiceModel.Channels.MsmqUri : object {
    public static IAddressTranslator NetMsmqAddressTranslator { get; }
    public static IAddressTranslator ActiveDirectoryAddressTranslator { get; }
    public static IAddressTranslator DeadLetterQueueAddressTranslator { get; }
    public static IAddressTranslator SrmpAddressTranslator { get; }
    public static IAddressTranslator SrmpsAddressTranslator { get; }
    public static IAddressTranslator FormatNameAddressTranslator { get; }
    public static IAddressTranslator get_NetMsmqAddressTranslator();
    public static IAddressTranslator get_ActiveDirectoryAddressTranslator();
    public static IAddressTranslator get_DeadLetterQueueAddressTranslator();
    public static IAddressTranslator get_SrmpAddressTranslator();
    public static IAddressTranslator get_SrmpsAddressTranslator();
    public static IAddressTranslator get_FormatNameAddressTranslator();
    public static string UriToFormatNameByScheme(Uri uri);
}
internal static class System.ServiceModel.Channels.MsmqVerifier : object {
    internal static void VerifySender(MsmqChannelFactoryBase`1<TChannel> factory);
    internal static void VerifyReceiver(MsmqReceiveParameters receiveParameters, Uri listenUri);
}
internal static class System.ServiceModel.Channels.MtomEncoderDefaults : object {
    internal static int MaxBufferSize;
}
internal class System.ServiceModel.Channels.MtomMessageEncoder : MessageEncoder {
    internal ContentEncoding[] contentEncodingMap;
    public string ContentType { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxBufferSize { get; }
    public string MediaType { get; }
    public MessageVersion MessageVersion { get; }
    public MtomMessageEncoder(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    public virtual string get_ContentType();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxBufferSize();
    public virtual string get_MediaType();
    public virtual MessageVersion get_MessageVersion();
    internal bool IsMTOMContentType(string contentType);
    internal bool IsTextContentType(string contentType);
    public virtual bool IsContentTypeSupported(string contentType);
    internal virtual bool IsCharSetSupported(string charSet);
    public virtual Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    public virtual Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
    public virtual ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    internal string GetContentType(String& boundary);
    internal string FormatContentType(string boundary, string startInfo);
    internal ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset, string boundary);
    public virtual void WriteMessage(Message message, Stream stream);
    internal void WriteMessage(Message message, Stream stream, string boundary);
    public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteMessage(Message message, Stream stream, string boundary, AsyncCallback callback, object state);
    public virtual void EndWriteMessage(IAsyncResult result);
    private sealed virtual override string System.Runtime.Diagnostics.ITraceSourceStringProvider.GetSourceString();
}
internal class System.ServiceModel.Channels.MtomMessageEncoderFactory : MessageEncoderFactory {
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxBufferSize { get; }
    public MtomMessageEncoderFactory(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxBufferSize();
    public static Encoding[] GetSupportedEncodings();
}
public class System.ServiceModel.Channels.MtomMessageEncodingBindingElement : MessageEncodingBindingElement {
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding WriteEncoding { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    public MtomMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext policyContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessageVersion();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWriteEncoding();
}
internal class System.ServiceModel.Channels.NamedPipeChannelFactory`1 : ConnectionOrientedTransportChannelFactory`1<TChannel> {
    public string Scheme { get; }
    public NamedPipeSettings PipeSettings { get; private set; }
    public NamedPipeChannelFactory`1(NamedPipeTransportBindingElement bindingElement, BindingContext context);
    private static NamedPipeChannelFactory`1();
    public virtual string get_Scheme();
    [CompilerGeneratedAttribute]
public sealed virtual NamedPipeSettings get_PipeSettings();
    [CompilerGeneratedAttribute]
private void set_PipeSettings(NamedPipeSettings value);
    internal virtual IConnectionInitiator GetConnectionInitiator();
    internal virtual ConnectionPool GetConnectionPool();
    internal virtual void ReleaseConnectionPool(ConnectionPool pool, TimeSpan timeout);
    protected virtual bool SupportsUpgrade(StreamUpgradeBindingElement upgradeBindingElement);
}
internal abstract class System.ServiceModel.Channels.NamedPipeChannelListener : ConnectionOrientedTransportChannelListener {
    public string Scheme { get; }
    internal List`1<SecurityIdentifier> AllowedUsers { get; internal set; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    protected NamedPipeChannelListener(NamedPipeTransportBindingElement bindingElement, BindingContext context);
    private static NamedPipeChannelListener();
    public virtual string get_Scheme();
    internal List`1<SecurityIdentifier> get_AllowedUsers();
    internal void set_AllowedUsers(List`1<SecurityIdentifier> value);
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    protected virtual bool SupportsUpgrade(StreamUpgradeBindingElement upgradeBindingElement);
}
internal abstract class System.ServiceModel.Channels.NamedPipeChannelListener`2 : NamedPipeChannelListener {
    protected TChannelAcceptor ChannelAcceptor { get; }
    protected NamedPipeChannelListener`2(NamedPipeTransportBindingElement bindingElement, BindingContext context);
    protected abstract virtual TChannelAcceptor get_ChannelAcceptor();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    public sealed virtual TChannel AcceptChannel();
    public sealed virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public sealed virtual TChannel AcceptChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual TChannel EndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Channels.NamedPipeConnectionPoolRegistry : ConnectionPoolRegistry {
    protected virtual ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
}
public class System.ServiceModel.Channels.NamedPipeConnectionPoolSettings : object {
    public string GroupName { get; public set; }
    public TimeSpan IdleTimeout { get; public set; }
    public int MaxOutboundConnectionsPerEndpoint { get; public set; }
    internal NamedPipeConnectionPoolSettings(NamedPipeConnectionPoolSettings namedPipe);
    public string get_GroupName();
    public void set_GroupName(string value);
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public int get_MaxOutboundConnectionsPerEndpoint();
    public void set_MaxOutboundConnectionsPerEndpoint(int value);
    internal NamedPipeConnectionPoolSettings Clone();
    internal bool IsMatch(NamedPipeConnectionPoolSettings namedPipe);
}
internal class System.ServiceModel.Channels.NamedPipeDuplexChannelListener : NamedPipeChannelListener`2<IDuplexSessionChannel, InputQueueChannelAcceptor`1<IDuplexSessionChannel>> {
    protected InputQueueChannelAcceptor`1<IDuplexSessionChannel> ChannelAcceptor { get; }
    public NamedPipeDuplexChannelListener(NamedPipeTransportBindingElement bindingElement, BindingContext context);
    protected virtual InputQueueChannelAcceptor`1<IDuplexSessionChannel> get_ChannelAcceptor();
    private sealed virtual override void System.ServiceModel.Channels.ISessionPreambleHandler.HandleServerSessionPreamble(ServerSessionPreambleConnectionReader preambleReader, ConnectionDemuxer connectionDemuxer);
}
internal class System.ServiceModel.Channels.NamedPipeReplyChannelListener : NamedPipeChannelListener`2<IReplyChannel, ReplyChannelAcceptor> {
    protected ReplyChannelAcceptor ChannelAcceptor { get; }
    private TimeSpan System.ServiceModel.Channels.ISingletonChannelListener.ReceiveTimeout { get; }
    public NamedPipeReplyChannelListener(NamedPipeTransportBindingElement bindingElement, BindingContext context);
    protected virtual ReplyChannelAcceptor get_ChannelAcceptor();
    private sealed virtual override TimeSpan System.ServiceModel.Channels.ISingletonChannelListener.get_ReceiveTimeout();
    private sealed virtual override void System.ServiceModel.Channels.ISingletonChannelListener.ReceiveRequest(RequestContext requestContext, Action callback, bool canDispatchOnThisThread);
}
public class System.ServiceModel.Channels.NamedPipeSettings : object {
    public ApplicationContainerSettings ApplicationContainerSettings { get; private set; }
    [CompilerGeneratedAttribute]
public ApplicationContainerSettings get_ApplicationContainerSettings();
    [CompilerGeneratedAttribute]
private void set_ApplicationContainerSettings(ApplicationContainerSettings value);
    internal NamedPipeSettings Clone();
    internal bool IsMatch(NamedPipeSettings pipeSettings);
}
public class System.ServiceModel.Channels.NamedPipeTransportBindingElement : ConnectionOrientedTransportBindingElement {
    internal List`1<SecurityIdentifier> AllowedUsers { get; internal set; }
    public NamedPipeConnectionPoolSettings ConnectionPoolSettings { get; }
    public NamedPipeSettings PipeSettings { get; }
    public string Scheme { get; }
    internal string WsdlTransportUri { get; }
    protected NamedPipeTransportBindingElement(NamedPipeTransportBindingElement elementToBeCloned);
    internal List`1<SecurityIdentifier> get_AllowedUsers();
    internal void set_AllowedUsers(List`1<SecurityIdentifier> value);
    public NamedPipeConnectionPoolSettings get_ConnectionPoolSettings();
    public NamedPipeSettings get_PipeSettings();
    public virtual string get_Scheme();
    internal virtual string get_WsdlTransportUri();
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
internal abstract class System.ServiceModel.Channels.NamedPipeTransportManager : ConnectionOrientedTransportManager`1<NamedPipeChannelListener> {
    internal List`1<SecurityIdentifier> AllowedUsers { get; }
    public HostNameComparisonMode HostNameComparisonMode { get; protected set; }
    public Uri ListenUri { get; }
    internal string Scheme { get; }
    protected NamedPipeTransportManager(Uri listenUri);
    protected void SetAllowedUsers(List`1<SecurityIdentifier> allowedUsers);
    protected void SetHostNameComparisonMode(HostNameComparisonMode hostNameComparisonMode);
    internal List`1<SecurityIdentifier> get_AllowedUsers();
    public sealed virtual HostNameComparisonMode get_HostNameComparisonMode();
    protected void set_HostNameComparisonMode(HostNameComparisonMode value);
    public sealed virtual Uri get_ListenUri();
    internal virtual string get_Scheme();
    protected virtual bool IsCompatible(NamedPipeChannelListener channelListener);
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
    protected virtual void OnSelecting(NamedPipeChannelListener channelListener);
    private sealed virtual override IList`1<TransportManager> System.ServiceModel.Channels.ITransportManagerRegistration.Select(TransportChannelListener channelListener);
}
internal abstract class System.ServiceModel.Channels.NativeMsmqMessage : object {
    protected NativeMsmqMessage(int propertyCount);
    protected virtual override void Finalize();
    public virtual void GrowBuffers();
    public Object[] GetBuffersForAsync();
    public IntPtr Pin();
    public void Unpin();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.NeighborClosedHandler : MulticastDelegate {
    public NeighborClosedHandler(object object, IntPtr method);
    public virtual void Invoke(IPeerNeighbor neighbor);
    public virtual IAsyncResult BeginInvoke(IPeerNeighbor neighbor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.NeighborConnectedHandler : MulticastDelegate {
    public NeighborConnectedHandler(object object, IntPtr method);
    public virtual void Invoke(IPeerNeighbor neighbor);
    public virtual IAsyncResult BeginInvoke(IPeerNeighbor neighbor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.NetHttpBindingDefaults : object {
    internal static NetHttpMessageEncoding MessageEncoding;
    internal static WebSocketTransportUsage TransportUsage;
}
internal static class System.ServiceModel.Channels.NetHttpDefaults : object {
    internal static TransactionProtocol TransactionProtocol { get; }
    internal static TransactionProtocol get_TransactionProtocol();
}
internal static class System.ServiceModel.Channels.NetTcpDefaults : object {
    internal static MessageCredentialType MessageSecurityClientCredentialType;
    internal static bool TransactionsEnabled;
    internal static TransactionProtocol TransactionProtocol { get; }
    internal static SecurityAlgorithmSuite MessageSecurityAlgorithmSuite { get; }
    internal static TransactionProtocol get_TransactionProtocol();
    internal static SecurityAlgorithmSuite get_MessageSecurityAlgorithmSuite();
}
internal class System.ServiceModel.Channels.NullMessage : StringMessage {
}
public class System.ServiceModel.Channels.OneWayBindingElement : BindingElement {
    public ChannelPoolSettings ChannelPoolSettings { get; public set; }
    [DefaultValueAttribute("10")]
public int MaxAcceptedChannels { get; public set; }
    [DefaultValueAttribute("False")]
public bool PacketRoutable { get; public set; }
    public ChannelPoolSettings get_ChannelPoolSettings();
    public void set_ChannelPoolSettings(ChannelPoolSettings value);
    public int get_MaxAcceptedChannels();
    public void set_MaxAcceptedChannels(int value);
    public bool get_PacketRoutable();
    public void set_PacketRoutable(bool value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeChannelPoolSettings();
}
public class System.ServiceModel.Channels.OneWayBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
internal static class System.ServiceModel.Channels.OneWayDefaults : object {
    internal static string IdleTimeoutString;
    internal static int MaxOutboundChannelsPerEndpoint;
    internal static string LeaseTimeoutString;
    internal static int MaxAcceptedChannels;
    internal static bool PacketRoutable;
    internal static TimeSpan IdleTimeout { get; }
    internal static TimeSpan LeaseTimeout { get; }
    internal static TimeSpan get_IdleTimeout();
    internal static TimeSpan get_LeaseTimeout();
}
internal static class System.ServiceModel.Channels.OneWayPolicyConstants : object {
    public static string OneWay;
    public static string PacketRoutable;
    public static string Namespace;
    public static string Prefix;
}
internal class System.ServiceModel.Channels.OpaqueContent : HttpContent {
    public bool IsEmpty { get; }
    public OpaqueContent(MessageEncoder encoder, Message message, string mtomBoundary);
    public bool get_IsEmpty();
    public void WriteToStream(Stream stream);
    public IAsyncResult BeginWriteToStream(Stream stream, AsyncCallback callback, object state);
    public void EndWriteToStream(IAsyncResult result);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
internal class System.ServiceModel.Channels.OperationEndCallback : MulticastDelegate {
    public OperationEndCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult result);
    public virtual IAsyncResult BeginInvoke(IAsyncResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.OperationSelector : object {
    public OperationSelector(IPeerNodeMessageHandling messageHandler);
    public static void TurnOffSecurityHeader(Message message);
    public sealed virtual string SelectOperation(Message& message);
}
internal class System.ServiceModel.Channels.OperationWithTimeoutBeginCallback : MulticastDelegate {
    public OperationWithTimeoutBeginCallback(object object, IntPtr method);
    public virtual IAsyncResult Invoke(TimeSpan timeout, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginInvoke(TimeSpan timeout, AsyncCallback asyncCallback, object asyncState, AsyncCallback callback, object object);
    public virtual IAsyncResult EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.OperationWithTimeoutCallback : MulticastDelegate {
    public OperationWithTimeoutCallback(object object, IntPtr method);
    public virtual void Invoke(TimeSpan timeout);
    public virtual IAsyncResult BeginInvoke(TimeSpan timeout, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.ServiceModel.Channels.OperationWithTimeoutComposer : object {
    public static IAsyncResult BeginComposeAsyncOperations(TimeSpan timeout, OperationWithTimeoutBeginCallback[] beginOperations, OperationEndCallback[] endOperations, AsyncCallback callback, object state);
    public static void EndComposeAsyncOperations(IAsyncResult result);
    public static TimeSpan RemainingTime(IAsyncResult result);
}
internal class System.ServiceModel.Channels.OrderedDeliveryStrategy`1 : DeliveryStrategy`1<ItemType> {
    public int EnqueuedCount { get; }
    public OrderedDeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota, bool isEnqueueInOrder);
    public virtual int get_EnqueuedCount();
    public virtual bool CanEnqueue(long sequenceNumber);
    public virtual bool Enqueue(ItemType item, long sequenceNumber);
    public virtual void Dispose();
}
internal abstract class System.ServiceModel.Channels.OutputChannel : ChannelBase {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected OutputChannel(ChannelManagerBase manager);
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    protected abstract virtual void OnSend(Message message, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndSend(IAsyncResult result);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    protected virtual TraceRecord CreateSendTrace(Message message);
    protected virtual void AddHeadersTo(Message message);
}
internal class System.ServiceModel.Channels.OverlappedContext : object {
    public Object[] Holder { get; }
    public Byte* BufferPtr { get; }
    public NativeOverlapped* NativeOverlapped { get; }
    private static OverlappedContext();
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
    [SecuritySafeCriticalAttribute]
public void Free();
    [SecuritySafeCriticalAttribute]
public bool FreeOrDefer();
    [SecuritySafeCriticalAttribute]
public bool FreeIfDeferred();
    [SecuritySafeCriticalAttribute]
public void StartAsyncOperation(Byte[] buffer, OverlappedIOCompleteCallback callback, bool bound);
    [SecuritySafeCriticalAttribute]
public void CancelAsyncOperation();
    [SecuritySafeCriticalAttribute]
public void StartSyncOperation(Byte[] buffer, Object& holder);
    [SecuritySafeCriticalAttribute]
public bool WaitForSyncOperation(TimeSpan timeout);
    [SecurityCriticalAttribute]
public bool WaitForSyncOperation(TimeSpan timeout, Object& holder);
    [SecuritySafeCriticalAttribute]
public void CancelSyncOperation(Object& holder);
    [SecuritySafeCriticalAttribute]
public Object[] get_Holder();
    [SecuritySafeCriticalAttribute]
public Byte* get_BufferPtr();
    [SecuritySafeCriticalAttribute]
public NativeOverlapped* get_NativeOverlapped();
}
internal class System.ServiceModel.Channels.OverlappedIOCompleteCallback : MulticastDelegate {
    public OverlappedIOCompleteCallback(object object, IntPtr method);
    public virtual void Invoke(bool haveResult, int error, int bytesRead);
    public virtual IAsyncResult BeginInvoke(bool haveResult, int error, int bytesRead, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.PacketRoutableHeader : DictionaryHeader {
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public static void AddHeadersTo(Message message, MessageHeader header);
    public static void ValidateMessage(Message message);
    public static bool TryValidateMessage(Message message);
    public static PacketRoutableHeader Create();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal enum System.ServiceModel.Channels.PeerAuthenticationMode : Enum {
    public int value__;
    public static PeerAuthenticationMode None;
    public static PeerAuthenticationMode Password;
    public static PeerAuthenticationMode MutualCertificate;
}
internal class System.ServiceModel.Channels.PeerBindingPropertyNames : object {
    public static string ListenUri;
    public static string Port;
    public static string MaxReceivedMessageSize;
    public static string Resolver;
    public static string Security;
    public static string SecurityDotMode;
    public static string ListenIPAddress;
    public static string Credentials;
    public static string ResolverSettings;
    public static string Password;
    public static string Certificate;
    public static string MaxBufferPoolSize;
    public static string ReaderQuotasDotArrayLength;
    public static string ReaderQuotasDotStringLength;
    public static string ReaderQuotasDotMaxDepth;
    public static string ReaderQuotasDotMaxCharCount;
    public static string ReaderQuotasDotMaxBytesPerRead;
    private static PeerBindingPropertyNames();
}
internal class System.ServiceModel.Channels.PeerCertificateClientCredentials : SecurityCredentialsManager {
    public PeerCertificateClientCredentials(X509Certificate2 selfCertificate, X509CertificateValidator validator);
    public virtual SecurityTokenManager CreateSecurityTokenManager();
}
internal class System.ServiceModel.Channels.PeerChannelAuthenticatorExtension : object {
    public PeerChannelAuthenticatorExtension(PeerSecurityManager securityManager, EventHandler onSucceeded, EventArgs args, string meshId);
    private static PeerChannelAuthenticatorExtension();
    public sealed virtual void Attach(IPeerNeighbor host);
    public static void OnNeighborClosed(IPeerNeighbor neighbor);
    public sealed virtual void Detach(IPeerNeighbor host);
    public void InitiateHandShake();
    public Message ProcessRst(Message message, Claim claim);
    public void ProcessRstr(IPeerNeighbor neighbor, Message message, Claim claim);
    public void OnAuthenticated();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal class System.ServiceModel.Channels.PeerChannelFactory`1 : TransportChannelFactory`1<TChannel> {
    public IPAddress ListenIPAddress { get; }
    public int Port { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public PeerResolver Resolver { get; }
    public string Scheme { get; }
    public PeerNodeImplementation PrivatePeerNode { get; public set; }
    public PeerSecurityManager SecurityManager { get; public set; }
    internal PeerChannelFactory`1(PeerTransportBindingElement bindingElement, BindingContext context, PeerResolver peerResolver);
    public sealed virtual IPAddress get_ListenIPAddress();
    public sealed virtual int get_Port();
    public sealed virtual XmlDictionaryReaderQuotas get_ReaderQuotas();
    public sealed virtual PeerResolver get_Resolver();
    public virtual string get_Scheme();
    public sealed virtual PeerNodeImplementation get_PrivatePeerNode();
    public sealed virtual void set_PrivatePeerNode(PeerNodeImplementation value);
    public sealed virtual PeerSecurityManager get_SecurityManager();
    public void set_SecurityManager(PeerSecurityManager value);
    public virtual T GetProperty();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual TChannel OnCreateChannel(EndpointAddress to, Uri via);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal abstract class System.ServiceModel.Channels.PeerChannelListener`2 : PeerChannelListenerBase {
    protected TChannelAcceptor ChannelAcceptor { get; }
    public PeerChannelListener`2(PeerTransportBindingElement bindingElement, BindingContext context, PeerResolver peerResolver);
    protected abstract virtual TChannelAcceptor get_ChannelAcceptor();
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    public sealed virtual TChannel AcceptChannel();
    public sealed virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public sealed virtual TChannel AcceptChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual TChannel EndAcceptChannel(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected abstract virtual void CreateAcceptor();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal abstract class System.ServiceModel.Channels.PeerChannelListenerBase : TransportChannelListener {
    public IPAddress ListenIPAddress { get; }
    internal PeerNodeImplementation InnerNode { get; }
    internal Registration Registration { get; }
    public PeerNodeImplementation PrivatePeerNode { get; public set; }
    public int Port { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public PeerResolver Resolver { get; }
    public PeerSecurityManager SecurityManager { get; public set; }
    protected SecurityProtocol SecurityProtocol { get; protected set; }
    public string Scheme { get; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    internal PeerChannelListenerBase(PeerTransportBindingElement bindingElement, BindingContext context, PeerResolver peerResolver);
    private static PeerChannelListenerBase();
    public sealed virtual IPAddress get_ListenIPAddress();
    internal PeerNodeImplementation get_InnerNode();
    internal Registration get_Registration();
    public sealed virtual PeerNodeImplementation get_PrivatePeerNode();
    public sealed virtual void set_PrivatePeerNode(PeerNodeImplementation value);
    public sealed virtual int get_Port();
    public sealed virtual XmlDictionaryReaderQuotas get_ReaderQuotas();
    public sealed virtual PeerResolver get_Resolver();
    public sealed virtual PeerSecurityManager get_SecurityManager();
    public void set_SecurityManager(PeerSecurityManager value);
    protected SecurityProtocol get_SecurityProtocol();
    protected void set_SecurityProtocol(SecurityProtocol value);
    public virtual string get_Scheme();
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    internal virtual IList`1<TransportManager> SelectTransportManagers();
}
internal enum System.ServiceModel.Channels.PeerCloseInitiator : Enum {
    public int value__;
    public static PeerCloseInitiator LocalNode;
    public static PeerCloseInitiator RemoteNode;
}
internal enum System.ServiceModel.Channels.PeerCloseReason : Enum {
    public int value__;
    public static PeerCloseReason None;
    public static PeerCloseReason InvalidNeighbor;
    public static PeerCloseReason LeavingMesh;
    public static PeerCloseReason NotUsefulNeighbor;
    public static PeerCloseReason DuplicateNeighbor;
    public static PeerCloseReason DuplicateNodeId;
    public static PeerCloseReason NodeBusy;
    public static PeerCloseReason ConnectTimedOut;
    public static PeerCloseReason Faulted;
    public static PeerCloseReason Closed;
    public static PeerCloseReason InternalFailure;
    public static PeerCloseReason AuthenticationFailure;
    public static PeerCloseReason NodeTooSlow;
}
internal class System.ServiceModel.Channels.PeerConnector : object {
    internal TypedMessageConverter ConnectInfoMessageConverter { get; }
    internal TypedMessageConverter DisconnectInfoMessageConverter { get; }
    internal TypedMessageConverter RefuseInfoMessageConverter { get; }
    internal TypedMessageConverter WelcomeInfoMessageConverter { get; }
    public PeerConnector(PeerNodeConfig config, PeerNeighborManager neighborManager, PeerMaintainer maintainer);
    internal TypedMessageConverter get_ConnectInfoMessageConverter();
    internal TypedMessageConverter get_DisconnectInfoMessageConverter();
    internal TypedMessageConverter get_RefuseInfoMessageConverter();
    internal TypedMessageConverter get_WelcomeInfoMessageConverter();
    public void Close();
    public void Closing();
    public void OnNeighborClosed(IPeerNeighbor neighbor);
    public void OnNeighborClosing(IPeerNeighbor neighbor, PeerCloseReason closeReason);
    public void OnNeighborAuthenticated(IPeerNeighbor neighbor);
    public void Open();
    public sealed virtual void Connect(IPeerNeighbor neighbor, ConnectInfo connectInfo);
    public sealed virtual void Disconnect(IPeerNeighbor neighbor, DisconnectInfo disconnectInfo);
    public sealed virtual void Refuse(IPeerNeighbor neighbor, RefuseInfo refuseInfo);
    public sealed virtual void Welcome(IPeerNeighbor neighbor, WelcomeInfo welcomeInfo);
}
internal static class System.ServiceModel.Channels.PeerConnectorHelper : object {
    public static bool IsDefined(DisconnectReason value);
    public static bool IsDefined(RefuseReason value);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.Channels.PeerCustomResolverBindingElement : PeerResolverBindingElement {
    public EndpointAddress Address { get; public set; }
    public Binding Binding { get; public set; }
    public PeerReferralPolicy ReferralPolicy { get; public set; }
    public PeerCustomResolverBindingElement(PeerCustomResolverBindingElement other);
    public PeerCustomResolverBindingElement(PeerCustomResolverSettings settings);
    public PeerCustomResolverBindingElement(BindingContext context, PeerCustomResolverSettings settings);
    public virtual T GetProperty(BindingContext context);
    public EndpointAddress get_Address();
    public void set_Address(EndpointAddress value);
    public Binding get_Binding();
    public void set_Binding(Binding value);
    public virtual PeerReferralPolicy get_ReferralPolicy();
    public virtual void set_ReferralPolicy(PeerReferralPolicy value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual PeerResolver CreatePeerResolver();
}
internal class System.ServiceModel.Channels.PeerDictionaryHeader : DictionaryHeader {
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public PeerDictionaryHeader(XmlDictionaryString name, XmlDictionaryString nameSpace, string value);
    public PeerDictionaryHeader(XmlDictionaryString name, XmlDictionaryString nameSpace, XmlDictionaryString value);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal static PeerDictionaryHeader CreateHopCountHeader(ulong hopcount);
    internal static PeerDictionaryHeader CreateViaHeader(Uri via);
    internal static PeerDictionaryHeader CreateFloodRole();
    internal static PeerDictionaryHeader CreateToHeader(Uri to);
    internal static PeerDictionaryHeader CreateMessageIdHeader(UniqueId messageId);
}
internal class System.ServiceModel.Channels.PeerDoNothingSecurityProtocol : SecurityProtocol {
    public PeerDoNothingSecurityProtocol(SecurityProtocolFactory factory);
    public virtual void SecureOutgoingMessage(Message& message, TimeSpan timeout);
    public virtual void VerifyIncomingMessage(Message& request, TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.PeerDoNothingSecurityProtocolFactory : SecurityProtocolFactory {
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnClose(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.PeerDuplexChannel : DuplexChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public PeerNodeImplementation InnerNode { get; }
    internal PeerMessageDispatcher`2<IDuplexChannel, PeerDuplexChannel> Dispatcher { get; internal set; }
    public PeerDuplexChannel(PeerNodeImplementation peerNode, Registration registration, ChannelManagerBase channelManager, EndpointAddress localAddress, Uri via);
    public virtual EndpointAddress get_RemoteAddress();
    public virtual Uri get_Via();
    public PeerNodeImplementation get_InnerNode();
    internal PeerMessageDispatcher`2<IDuplexChannel, PeerDuplexChannel> get_Dispatcher();
    internal void set_Dispatcher(PeerMessageDispatcher`2<IDuplexChannel, PeerDuplexChannel> value);
    protected virtual void AddHeadersTo(Message message);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnEnqueueItem(Message message);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnFaulted();
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal class System.ServiceModel.Channels.PeerDuplexChannelAcceptor : SingletonChannelAcceptor`3<IDuplexChannel, PeerDuplexChannel, Message> {
    public PeerDuplexChannelAcceptor(PeerNodeImplementation peerNode, Registration registration, ChannelManagerBase channelManager, EndpointAddress localAddress, Uri via);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnFaulted();
    protected virtual PeerDuplexChannel OnCreateChannel();
    protected virtual void OnTraceMessageReceived(Message message);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal class System.ServiceModel.Channels.PeerDuplexChannelListener : PeerChannelListener`2<IDuplexChannel, PeerDuplexChannelAcceptor> {
    protected PeerDuplexChannelAcceptor ChannelAcceptor { get; }
    public PeerDuplexChannelListener(PeerTransportBindingElement bindingElement, BindingContext context, PeerResolver peerResolver);
    protected virtual PeerDuplexChannelAcceptor get_ChannelAcceptor();
    protected virtual void CreateAcceptor();
}
internal class System.ServiceModel.Channels.PeerEndpointIdentity : EndpointIdentity {
}
internal class System.ServiceModel.Channels.PeerExceptionHelper : object {
    internal static void ThrowInvalidOperation_InsufficientCryptoSupport(Exception innerException);
    internal static void ThrowArgument_InsufficientCredentials(string property);
    internal static void ThrowArgumentOutOfRange_InvalidTransportCredentialType(int value);
    internal static void ThrowArgumentOutOfRange_InvalidSecurityMode(int value);
    internal static void ThrowInvalidOperation_UnexpectedSecurityTokensDuringHandshake();
    internal static void ThrowArgument_PnrpAddressesExceedLimit();
    internal static void ThrowInvalidOperation_PnrpNoClouds();
    internal static void ThrowInvalidOperation_PnrpAddressesUnsupported();
    internal static void ThrowArgument_InsufficientResolverSettings();
    internal static void ThrowArgument_MustOverrideInitialize();
    internal static void ThrowArgument_InvalidResolverMode(PeerResolverMode mode);
    internal static void ThrowInvalidOperation_NotValidWhenOpen(string operation);
    internal static void ThrowInvalidOperation_NotValidWhenClosed(string operation);
    internal static void ThrowInvalidOperation_DuplicatePeerRegistration(string servicepath);
    internal static void ThrowPnrpError(int errorCode, string cloud);
    internal static void ThrowPnrpError(int errorCode, string cloud, bool trace);
    internal static void ThrowInvalidOperation_PeerConflictingPeerNodeSettings(string propertyName);
    internal static void ThrowInvalidOperation_PeerCertGenFailure(Exception innerException);
    internal static void ThrowInvalidOperation_ConflictingHeader(string headerName);
    public static Exception GetLastException();
}
internal class System.ServiceModel.Channels.PeerFlooder : PeerFlooderSimple {
    public static PeerFlooder CreateFlooder(PeerNodeConfig config, PeerNeighborManager neighborManager, IPeerNodeMessageHandling messageHandler);
}
internal abstract class System.ServiceModel.Channels.PeerFlooderBase`2 : object {
    protected PeerNodeConfig config;
    protected PeerNeighborManager neighborManager;
    protected List`1<IPeerNeighbor> neighbors;
    internal IPeerNodeMessageHandling messageHandler;
    internal PeerThrottleHelper<TFloodContract, TLinkContract> quotaHelper;
    public EventHandler OnMessageSentHandler;
    protected long MaxReceivedMessageSize { get; }
    protected MessageEncoder MessageEncoder { get; }
    protected object ThisLock { get; }
    protected List`1<IPeerNeighbor> Neighbors { get; }
    public PeerFlooderBase`2(PeerNodeConfig config, PeerNeighborManager neighborManager);
    [CompilerGeneratedAttribute]
public void add_ThrottleReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ThrottleReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SlowNeighborKilled(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SlowNeighborKilled(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ThrottleReleased(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ThrottleReleased(EventHandler value);
    private sealed virtual override void System.ServiceModel.Channels.IFlooderForThrottle.OnThrottleReached();
    private sealed virtual override void System.ServiceModel.Channels.IFlooderForThrottle.OnThrottleReleased();
    public void FireDequeuedEvent();
    public void FireReachedEvent();
    public void FireKilledEvent();
    [SecuritySafeCriticalAttribute]
public virtual IAsyncResult BeginFloodEncodedMessage(Byte[] id, MessageBuffer encodedMessage, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginFloodReceivedMessage(IPeerNeighbor sender, MessageBuffer messageBuffer, TimeSpan timeout, AsyncCallback callback, object state, int index, MessageHeader hopHeader);
    protected IAsyncResult BeginSendHelper(IPeerNeighbor neighbor, TimeSpan timeout, Message message, FloodAsyncResult fresult);
    public void OnMessageSent(object sender, EventArgs args);
    protected virtual IAsyncResult FloodMessageToNeighbors(MessageBuffer messageBuffer, TimeSpan timeout, AsyncCallback callback, object state, int index, MessageHeader hopHeader, IPeerNeighbor except, EventHandler OnMessageSentCallback);
    public void Open();
    public void Close();
    public abstract virtual void OnOpen();
    public abstract virtual void OnClose();
    public virtual void OnNeighborConnected(IPeerNeighbor neighbor);
    public virtual void OnNeighborClosed(IPeerNeighbor neighbor);
    public abstract virtual void ProcessLinkUtility(IPeerNeighbor neighbor, TLinkContract utilityInfo);
    public abstract virtual bool ShouldProcess(TFloodContract floodInfo);
    public abstract virtual void RecordOutgoingMessage(Byte[] id);
    public virtual IAsyncResult OnFloodedMessage(IPeerNeighbor neighbor, TFloodContract floodInfo, AsyncCallback callback, object state);
    public virtual void EndFloodMessage(IAsyncResult result);
    protected long get_MaxReceivedMessageSize();
    protected MessageEncoder get_MessageEncoder();
    protected object get_ThisLock();
    protected List`1<IPeerNeighbor> get_Neighbors();
    internal static Exception CloseNeighborIfKnownException(PeerNeighborManager neighborManager, Exception exception, IPeerNeighbor peer);
    public static void EndFloodEncodedMessage(IAsyncResult result);
    public void EndFloodReceivedMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.PeerFlooderSimple : PeerFlooderBase`2<Message, UtilityInfo> {
    internal PeerFlooderSimple(PeerNodeConfig config, PeerNeighborManager neighborManager);
    public virtual bool ShouldProcess(Message message);
    public bool IsNotSeenBefore(Message message, Byte[]& id, Int32& cacheHit);
    public virtual void RecordOutgoingMessage(Byte[] id);
    public virtual void OnOpen();
    public virtual void OnClose();
    public virtual IAsyncResult OnFloodedMessage(IPeerNeighbor neighbor, Message floodInfo, AsyncCallback callback, object state);
    public virtual void EndFloodMessage(IAsyncResult result);
    public virtual void ProcessLinkUtility(IPeerNeighbor neighbor, UtilityInfo utilityInfo);
}
internal class System.ServiceModel.Channels.PeerHashToken : SecurityToken {
    internal static string TokenTypeString;
    internal static string RequestTypeString;
    internal static string Action;
    public static string PeerNamespace;
    public static string PeerTokenElementName;
    public static string PeerAuthenticatorElementName;
    public static string PeerPrefix;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public static PeerHashToken Invalid { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public Uri Status { get; }
    public bool IsValid { get; }
    public PeerHashToken(Byte[] authenticator);
    public PeerHashToken(X509Certificate2 certificate, string password);
    public PeerHashToken(Claim claim, string password);
    private static PeerHashToken();
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public static PeerHashToken get_Invalid();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Uri get_Status();
    public bool get_IsValid();
    public bool Validate(Claim claim, string password);
    public void Write(XmlWriter writer);
    internal static PeerHashToken CreateFrom(XmlElement child);
    public virtual bool Equals(object token);
    public virtual int GetHashCode();
}
internal class System.ServiceModel.Channels.PeerIdentityClaim : object {
    public static string PeerClaimType;
    internal static Claim Claim();
    internal static bool IsMatch(EndpointIdentity identity);
}
internal class System.ServiceModel.Channels.PeerIdentityVerifier : IdentityVerifier {
    public virtual bool CheckAccess(EndpointIdentity identity, AuthorizationContext authContext);
    public virtual bool TryGetIdentity(EndpointAddress reference, EndpointIdentity& identity);
}
internal class System.ServiceModel.Channels.PeerInputChannel : InputChannel {
    public PeerInputChannel(PeerNodeImplementation peerNode, Registration registration, ChannelManagerBase channelManager, EndpointAddress localAddress, Uri via);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnEnqueueItem(Message message);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnFaulted();
}
internal class System.ServiceModel.Channels.PeerInputChannelAcceptor : SingletonChannelAcceptor`3<IInputChannel, PeerInputChannel, Message> {
    public PeerInputChannelAcceptor(PeerNodeImplementation peerNode, Registration registration, ChannelManagerBase channelManager, EndpointAddress localAddress, Uri via);
    protected virtual PeerInputChannel OnCreateChannel();
    protected virtual void OnTraceMessageReceived(Message message);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnFaulted();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal class System.ServiceModel.Channels.PeerInputChannelListener : PeerChannelListener`2<IInputChannel, PeerInputChannelAcceptor> {
    protected PeerInputChannelAcceptor ChannelAcceptor { get; }
    public PeerInputChannelListener(PeerTransportBindingElement bindingElement, BindingContext context, PeerResolver peerResolver);
    protected virtual PeerInputChannelAcceptor get_ChannelAcceptor();
    protected virtual void CreateAcceptor();
}
internal class System.ServiceModel.Channels.PeerIPHelper : object {
    unknown int AddressChangeWaitTimeout {internal set; }
    public PeerIPHelper(IPAddress listenAddress);
    [CompilerGeneratedAttribute]
public void add_AddressChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AddressChanged(EventHandler value);
    internal void set_AddressChangeWaitTimeout(int value);
    public bool AddressesChanged(ReadOnlyCollection`1<IPAddress> addresses);
    public static IPAddress CloneAddress(IPAddress source, bool maskScopeId);
    public static ReadOnlyCollection`1<IPAddress> CloneAddresses(ReadOnlyCollection`1<IPAddress> sourceCollection, bool maskScopeId);
    public void Close();
    internal static IPAddress[] ReorderAddresses(IEnumerable`1<IPAddress> sourceAddresses);
    public static EndpointAddress GetIPEndpointAddress(EndpointAddress epr, IPAddress address);
    public static Uri GetIPUri(Uri uri, IPAddress ipAddress);
    public ReadOnlyCollection`1<IPAddress> GetLocalAddresses();
    public static bool V4Address(IPAddress address);
    public static bool V6Address(IPAddress address);
    public static bool ValidAddress(IPAddress address);
    public void Open();
    public ReadOnlyCollection`1<IPAddress> SortAddresses(ReadOnlyCollection`1<IPAddress> addresses);
}
internal class System.ServiceModel.Channels.PeerMaintainer : PeerMaintainerBase`1<ConnectAlgorithms> {
    public PeerMaintainer(PeerNodeConfig config, PeerNeighborManager neighborManager, PeerFlooder flooder);
}
internal class System.ServiceModel.Channels.PeerMaintainerBase`1 : object {
    private int System.ServiceModel.Channels.IPeerMaintainer.ConnectedNeighborCount { get; }
    private int System.ServiceModel.Channels.IPeerMaintainer.NonClosingNeighborCount { get; }
    private bool System.ServiceModel.Channels.IPeerMaintainer.IsOpen { get; }
    public PeerMaintainerBase`1(PeerNodeConfig config, PeerNeighborManager neighborManager, PeerFlooder flooder);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ReferralsAdded(ReferralsAddedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ReferralsAdded(ReferralsAddedHandler value);
    public bool AddReferrals(IList`1<Referral> referrals, IPeerNeighbor neighbor);
    [SecuritySafeCriticalAttribute]
public void Close();
    public void RefreshConnection();
    public void ScheduleConnect(ConnectCallback<TConnectAlgorithms> connectCallback);
    public Referral[] GetReferrals();
    public virtual void OnNeighborClosed(IPeerNeighbor neighbor);
    public virtual void OnNeighborConnected(IPeerNeighbor neighbor);
    [SecuritySafeCriticalAttribute]
public void Open();
    [CompilerGeneratedAttribute]
public sealed virtual void add_NeighborClosed(NeighborClosedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NeighborClosed(NeighborClosedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_NeighborConnected(NeighborConnectedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NeighborConnected(NeighborConnectedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MaintainerClosed(MaintainerClosedHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MaintainerClosed(MaintainerClosedHandler value);
    private sealed virtual override void System.ServiceModel.Channels.IPeerMaintainer.CloseNeighbor(IPeerNeighbor neighbor, PeerCloseReason closeReason);
    private sealed virtual override IPeerNeighbor System.ServiceModel.Channels.IPeerMaintainer.FindDuplicateNeighbor(PeerNodeAddress address);
    private sealed virtual override PeerNodeAddress System.ServiceModel.Channels.IPeerMaintainer.GetListenAddress();
    private sealed virtual override IPeerNeighbor System.ServiceModel.Channels.IPeerMaintainer.GetLeastUsefulNeighbor();
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IPeerMaintainer.BeginOpenNeighbor(PeerNodeAddress address, TimeSpan timeout, AsyncCallback callback, object asyncState);
    private sealed virtual override IPeerNeighbor System.ServiceModel.Channels.IPeerMaintainer.EndOpenNeighbor(IAsyncResult result);
    private sealed virtual override int System.ServiceModel.Channels.IPeerMaintainer.get_ConnectedNeighborCount();
    private sealed virtual override int System.ServiceModel.Channels.IPeerMaintainer.get_NonClosingNeighborCount();
    private sealed virtual override bool System.ServiceModel.Channels.IPeerMaintainer.get_IsOpen();
    public void PingConnections();
    public void PingAndRefresh(object state);
}
internal class System.ServiceModel.Channels.PeerMessageDispatcher`2 : CommunicationObject {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public SecurityProtocol SecurityProtocol { get; }
    public PeerMessageDispatcher`2(PeerMessageQueueAdapter<ChannelInterfaceType, TChannel> queueHandler, PeerNodeImplementation peerNode, ChannelManagerBase channelManager, EndpointAddress to, Uri via);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public SecurityProtocol get_SecurityProtocol();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    internal void Unregister();
    internal void Unregister(bool release);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    public void OnMessageAvailable(Message message);
}
internal class System.ServiceModel.Channels.PeerMessageFilter : object {
    public PeerMessageFilter(Uri via);
    public PeerMessageFilter(Uri via, EndpointAddress to);
    public bool Match(Uri peerVia, Uri toCond);
}
internal static class System.ServiceModel.Channels.PeerMessageHelpers : object {
    public static string GetHeaderString(MessageHeaders headers, string name, string ns);
    public static Uri GetHeaderUri(MessageHeaders headers, string name, string ns);
    public static ulong GetHeaderULong(MessageHeaders headers, int index);
    public static UniqueId GetHeaderUniqueId(MessageHeaders headers, string name, string ns);
}
internal class System.ServiceModel.Channels.PeerMessageProperty : object {
    public bool MessageVerified;
    public bool SkipLocalChannels;
    public Uri PeerVia;
    public Uri PeerTo;
    public int CacheMiss;
}
internal class System.ServiceModel.Channels.PeerNeighborCloseEventArgs : EventArgs {
    public PeerCloseInitiator CloseInitiator { get; }
    public Exception Exception { get; }
    public PeerCloseReason Reason { get; }
    public PeerNeighborCloseEventArgs(PeerCloseReason reason, PeerCloseInitiator closeInitiator, Exception exception);
    public PeerCloseInitiator get_CloseInitiator();
    public Exception get_Exception();
    public PeerCloseReason get_Reason();
}
internal class System.ServiceModel.Channels.PeerNeighborManager : object {
    public int ConnectedNeighborCount { get; }
    public int NonClosingNeighborCount { get; }
    public bool IsOnline { get; }
    public int NeighborCount { get; }
    public PeerNeighborManager(PeerIPHelper ipHelper, PeerNodeConfig config);
    public PeerNeighborManager(PeerIPHelper ipHelper, PeerNodeConfig config, IPeerNodeMessageHandling messageHandler);
    [CompilerGeneratedAttribute]
public void add_NeighborClosed(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_NeighborClosed(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_NeighborClosing(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_NeighborClosing(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_NeighborConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NeighborConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_NeighborOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NeighborOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Online(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Online(EventHandler value);
    public int get_ConnectedNeighborCount();
    public int get_NonClosingNeighborCount();
    public bool get_IsOnline();
    public int get_NeighborCount();
    public IAsyncResult BeginOpenNeighbor(PeerNodeAddress remoteAddress, TimeSpan timeout, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginOpenNeighborInternal(PeerNodeAddress remoteAddress, TimeSpan timeout, AsyncCallback callback, object asyncState);
    public void Close();
    public void CloseNeighbor(IPeerNeighbor neighbor, PeerCloseReason closeReason, PeerCloseInitiator closeInitiator);
    public void CloseNeighbor(IPeerNeighbor neighbor, PeerCloseReason closeReason, PeerCloseInitiator closeInitiator, Exception closeException);
    public IPeerNeighbor EndOpenNeighbor(IAsyncResult result);
    public IPeerNeighbor FindDuplicateNeighbor(ulong nodeId);
    public IPeerNeighbor FindDuplicateNeighbor(ulong nodeId, IPeerNeighbor skipNeighbor);
    public bool PingNeighbor(IPeerNeighbor peer);
    public void PingNeighbors();
    public IPeerNeighbor FindDuplicateNeighbor(PeerNodeAddress address);
    public IPeerNeighbor FindDuplicateNeighbor(PeerNodeAddress address, IPeerNeighbor skipNeighbor);
    public List`1<IPeerNeighbor> GetConnectedNeighbors();
    public IPeerNeighbor GetNeighborFromProxy(IPeerProxy proxy);
    public void Open(Binding serviceBinding, PeerService service);
    public bool ProcessIncomingChannel(IClientChannel channel);
    public void Shutdown(bool graceful, TimeSpan timeout);
    public IPeerNeighbor SlowestNeighbor();
}
internal enum System.ServiceModel.Channels.PeerNeighborState : Enum {
    public int value__;
    public static PeerNeighborState Created;
    public static PeerNeighborState Opened;
    public static PeerNeighborState Authenticated;
    public static PeerNeighborState Connecting;
    public static PeerNeighborState Connected;
    public static PeerNeighborState Disconnecting;
    public static PeerNeighborState Disconnected;
    public static PeerNeighborState Faulted;
    public static PeerNeighborState Closed;
}
internal static class System.ServiceModel.Channels.PeerNeighborStateHelper : object {
    public static bool IsSettable(PeerNeighborState state);
    public static bool IsConnected(PeerNeighborState state);
    public static bool IsAuthenticatedOrClosed(PeerNeighborState state);
}
internal class System.ServiceModel.Channels.PeerNodeConfig : object {
    internal PeerSecurityManager SecurityManager { get; }
    public int ConnectTimeout { get; }
    public IPAddress ListenIPAddress { get; }
    public int ListenerPort { get; }
    public Uri ListenUri { get; }
    public int IdealNeighbors { get; }
    public int MaintainerInterval { get; }
    public TimeSpan MaintainerRetryInterval { get; }
    public TimeSpan MaintainerTimeout { get; }
    public long MaxBufferPoolSize { get; }
    public long MaxReceivedMessageSize { get; }
    public int MaxNeighbors { get; }
    public int MaxReferrals { get; }
    public int MaxReferralCacheSize { get; }
    public int MaxResolveAddresses { get; }
    public int MaxPendingIncomingCalls { get; }
    public int MaxPendingOutgoingCalls { get; }
    public int MaxConcurrentSessions { get; }
    public int MinNeighbors { get; }
    public string MeshId { get; }
    public MessageEncoder MessageEncoder { get; }
    public PeerMessagePropagationFilter MessagePropagationFilter { get; }
    public ulong NodeId { get; }
    public int Port { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public PeerResolver Resolver { get; }
    public TimeSpan UnregisterTimeout { get; }
    public PeerNodeConfig(string meshId, ulong nodeId, PeerResolver resolver, PeerMessagePropagationFilter messagePropagationFilter, MessageEncoder encoder, Uri listenUri, IPAddress listenIPAddress, int port, long maxReceivedMessageSize, int minNeighbors, int idealNeighbors, int maxNeighbors, int maxReferrals, int connectTimeout, int maintainerInterval, PeerSecurityManager securityManager, XmlDictionaryReaderQuotas readerQuotas, long maxBufferPool, int maxSendQueueSize, int maxReceiveQueueSize);
    internal PeerSecurityManager get_SecurityManager();
    public int get_ConnectTimeout();
    public IPAddress get_ListenIPAddress();
    public int get_ListenerPort();
    public Uri get_ListenUri();
    public int get_IdealNeighbors();
    public int get_MaintainerInterval();
    public TimeSpan get_MaintainerRetryInterval();
    public TimeSpan get_MaintainerTimeout();
    public long get_MaxBufferPoolSize();
    public long get_MaxReceivedMessageSize();
    public int get_MaxNeighbors();
    public int get_MaxReferrals();
    public int get_MaxReferralCacheSize();
    public int get_MaxResolveAddresses();
    public int get_MaxPendingIncomingCalls();
    public int get_MaxPendingOutgoingCalls();
    public int get_MaxConcurrentSessions();
    public int get_MinNeighbors();
    public string get_MeshId();
    public MessageEncoder get_MessageEncoder();
    public PeerMessagePropagationFilter get_MessagePropagationFilter();
    public ulong get_NodeId();
    public int get_Port();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public PeerResolver get_Resolver();
    public TimeSpan get_UnregisterTimeout();
    public PeerNodeAddress GetListenAddress(bool maskScopeId);
    public void SetListenAddress(PeerNodeAddress address);
    public Uri GetSelfUri();
    public Uri GetMeshUri();
}
internal class System.ServiceModel.Channels.PeerNodeImplementation : object {
    internal MessageEncodingBindingElement EncodingElement;
    internal PeerConnector connector;
    internal PeerFlooder flooder;
    internal static Byte[] DefaultId;
    internal int MaxSendQueue;
    internal int MaxReceiveQueue;
    internal static Dictionary`2<Uri, PeerNodeImplementation> peerNodes;
    public PeerNodeConfig Config { get; private set; }
    public bool IsOnline { get; }
    internal bool IsOpen { get; }
    public IPAddress ListenIPAddress { get; public set; }
    public Uri ListenUri { get; public set; }
    public long MaxBufferPoolSize { get; public set; }
    public long MaxReceivedMessageSize { get; public set; }
    public string MeshId { get; }
    public PeerMessagePropagationFilter MessagePropagationFilter { get; public set; }
    public PeerNeighborManager NeighborManager { get; }
    public ulong NodeId { get; }
    public int Port { get; public set; }
    public int ListenerPort { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public PeerResolver Resolver { get; public set; }
    public PeerSecurityManager SecurityManager { get; public set; }
    internal PeerService Service { get; internal set; }
    private bool System.ServiceModel.Channels.IPeerNodeMessageHandling.HasMessagePropagation { get; }
    public MessageEncodingBindingElement EncodingBindingElement { get; }
    private static PeerNodeImplementation();
    [CompilerGeneratedAttribute]
public void add_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Online(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Online(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_NeighborClosed(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_NeighborClosed(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_NeighborClosing(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_NeighborClosing(EventHandler`1<PeerNeighborCloseEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_NeighborConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NeighborConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_NeighborOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NeighborOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Aborted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Aborted(EventHandler value);
    public PeerNodeConfig get_Config();
    private void set_Config(PeerNodeConfig value);
    public bool get_IsOnline();
    internal bool get_IsOpen();
    public IPAddress get_ListenIPAddress();
    public void set_ListenIPAddress(IPAddress value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public string get_MeshId();
    public PeerMessagePropagationFilter get_MessagePropagationFilter();
    public void set_MessagePropagationFilter(PeerMessagePropagationFilter value);
    public PeerNeighborManager get_NeighborManager();
    public ulong get_NodeId();
    public int get_Port();
    public void set_Port(int value);
    public int get_ListenerPort();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public PeerResolver get_Resolver();
    public void set_Resolver(PeerResolver value);
    public PeerSecurityManager get_SecurityManager();
    public void set_SecurityManager(PeerSecurityManager value);
    internal PeerService get_Service();
    internal void set_Service(PeerService value);
    public void Abort();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state, bool waitForOnline);
    public Guid ProcessOutgoingMessage(Message message, Uri via);
    public void SecureOutgoingMessage(Message& message, Uri via, TimeSpan timeout, SecurityProtocol securityProtocol);
    public IAsyncResult BeginSend(object registrant, Message message, Uri via, ITransportFactorySettings settings, TimeSpan timeout, AsyncCallback callback, object state, SecurityProtocol securityProtocol);
    public void Close(TimeSpan timeout);
    public static void EndClose(IAsyncResult result);
    public static void EndOpen(IAsyncResult result);
    public static void EndSend(IAsyncResult result);
    internal static PeerNodeImplementation Get(Uri listenUri);
    protected internal static bool TryGet(Uri listenUri, PeerNodeImplementation& result);
    public static bool TryGet(string meshId, PeerNodeImplementation& result);
    public static PeerNodeImplementation Get(Uri listenUri, Registration registration);
    protected void OnAbort();
    protected void OnClose(TimeSpan timeout);
    private sealed virtual override bool System.ServiceModel.Channels.IPeerNodeMessageHandling.ValidateIncomingMessage(Message& message, Uri via);
    internal bool TryGetSecurityProtocol(Uri via, SecurityProtocol& protocol);
    private sealed virtual override void System.ServiceModel.Channels.IPeerNodeMessageHandling.HandleIncomingMessage(MessageBuffer messageBuffer, PeerMessagePropagation propagateFlags, int index, MessageHeader hopHeader, Uri via, Uri to);
    private sealed virtual override PeerMessagePropagation System.ServiceModel.Channels.IPeerNodeMessageHandling.DetermineMessagePropagation(Message message, PeerMessageOrigination origination);
    internal void Open(TimeSpan timeout, bool waitForOnline);
    public void RefreshConnection();
    public void PingConnections();
    internal void RegisterMessageFilter(object registrant, Uri via, PeerMessageFilter[] filters, ITransportFactorySettings settings, MessageAvailableCallback callback, SecurityProtocol securityProtocol);
    internal void Release();
    public void SetServiceHandlers(Dictionary`2<Type, object> services);
    public virtual string ToString();
    internal void UnregisterMessageFilter(object registrant, Uri via);
    internal static void ValidateVia(Uri uri);
    private sealed virtual override bool System.ServiceModel.Channels.IPeerNodeMessageHandling.get_HasMessagePropagation();
    private sealed virtual override bool System.ServiceModel.Channels.IPeerNodeMessageHandling.IsKnownVia(Uri via);
    private sealed virtual override bool System.ServiceModel.Channels.IPeerNodeMessageHandling.IsNotSeenBefore(Message message, Byte[]& id, Int32& cacheMiss);
    public sealed virtual MessageEncodingBindingElement get_EncodingBindingElement();
}
internal class System.ServiceModel.Channels.PeerOperationNames : object {
    public static string Connect;
    public static string Disconnect;
    public static string Refuse;
    public static string Welcome;
    public static string LinkUtility;
    public static string ProcessRequestSecurityToken;
    public static string RequestSecurityTokenResponse;
    public static string Flood;
    public static string Demuxer;
    public static string PeerVia;
    public static string Fault;
    public static string PeerTo;
    public static string Ping;
}
internal class System.ServiceModel.Channels.PeerOperationSelectorBehavior : object {
    internal PeerOperationSelectorBehavior(IPeerNodeMessageHandling messageHandler);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
internal class System.ServiceModel.Channels.PeerOutputChannel : TransportOutputChannel {
    public PeerOutputChannel(PeerNodeImplementation peerNode, Registration registration, ChannelManagerBase channelManager, EndpointAddress localAddress, Uri via, MessageVersion messageVersion);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnFaulted();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void AddHeadersTo(Message message);
}
internal class System.ServiceModel.Channels.PeerPropertyNames : object {
    public static string MessageSenderAuthentication;
    public static string Credentials;
    public static string Password;
    public static string Certificate;
    public static string PeerAuthentication;
    private static PeerPropertyNames();
}
internal class System.ServiceModel.Channels.PeerQuotaHelper : object {
    public PeerQuotaHelper(int limit);
    public void ReadyToEnqueueItem();
    public void ItemDequeued();
}
internal class System.ServiceModel.Channels.PeerRequestSecurityToken : RequestSecurityToken {
    public static string TrustNamespace;
    public static string PeerNamespace;
    public static string RequestElementName;
    public static string RequestedSecurityTokenElementName;
    public static string PeerHashTokenElementName;
    public PeerHashToken Token { get; }
    public PeerRequestSecurityToken(PeerHashToken token);
    public PeerHashToken get_Token();
    public static PeerHashToken CreateHashTokenFrom(Message message);
    public PeerRequestSecurityToken CreateFrom(X509Certificate2 credential, string password);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected internal virtual void OnMakeReadOnly();
    internal static bool CompareWithNS(string first, string firstNS, string second, string secondNS);
}
internal class System.ServiceModel.Channels.PeerRequestSecurityTokenResponse : RequestSecurityTokenResponse {
    public static string Action;
    public static string ValidString;
    public static string InvalidString;
    public static string StatusString;
    public static string CodeString;
    public PeerHashToken Token { get; }
    public bool IsValid { get; }
    public PeerRequestSecurityTokenResponse(PeerHashToken token);
    public PeerHashToken get_Token();
    public bool get_IsValid();
    public static PeerHashToken CreateHashTokenFrom(Message message);
    public static RequestSecurityTokenResponse CreateFrom(X509Certificate2 credential, string password);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
}
public abstract class System.ServiceModel.Channels.PeerResolverBindingElement : BindingElement {
    public PeerReferralPolicy ReferralPolicy { get; public set; }
    protected PeerResolverBindingElement(PeerResolverBindingElement other);
    public abstract virtual PeerReferralPolicy get_ReferralPolicy();
    public abstract virtual void set_ReferralPolicy(PeerReferralPolicy value);
    public abstract virtual PeerResolver CreatePeerResolver();
}
internal class System.ServiceModel.Channels.PeerResolverStrings : object {
    public static string Namespace;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string UnregisterAction;
    public static string ResolveAction;
    public static string ResolveResponseAction;
    public static string UpdateAction;
    public static string UpdateResponseAction;
    public static string RefreshAction;
    public static string RefreshResponseAction;
    public static string GetServiceSettingsAction;
    public static string GetServiceSettingsResponseAction;
}
internal class System.ServiceModel.Channels.PeerSecurityCredentialsManager : SecurityCredentialsManager {
    public PeerSecurityManager Parent { get; public set; }
    internal PeerCredential Credential { get; }
    internal string Password { get; }
    internal X509Certificate2 Certificate { get; }
    public PeerSecurityCredentialsManager(SecurityTokenManager manager, PeerAuthenticationMode mode, bool messageAuth);
    public PeerSecurityCredentialsManager(PeerCredential credential, PeerAuthenticationMode mode, bool messageAuth);
    public PeerSecurityManager get_Parent();
    public void set_Parent(PeerSecurityManager value);
    public virtual SecurityTokenManager CreateSecurityTokenManager();
    public PeerSecurityCredentialsManager CloneForTransport();
    internal PeerCredential get_Credential();
    internal string get_Password();
    internal X509Certificate2 get_Certificate();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    public virtual bool Equals(object other);
    public void CheckIfCompatible(PeerSecurityCredentialsManager that);
    public virtual int GetHashCode();
}
internal class System.ServiceModel.Channels.PeerSecurityHelpers : object {
    public static Byte[] ComputeHash(X509Certificate2 cert, string pwd);
    public static Byte[] ComputeHash(Claim claim, string pwd);
    public static Byte[] ComputeHash(Byte[] message, string pwd);
    public static bool Authenticate(Claim claim, string password, Byte[] authenticator);
    public static bool AuthenticateRequest(Claim claim, string password, Message message);
    public static bool AuthenticateResponse(Claim claim, string password, Message message);
}
internal class System.ServiceModel.Channels.PeerSecurityManager : object {
    internal string password;
    public EventHandler OnNeighborAuthenticated;
    public PeerAuthenticationMode AuthenticationMode { get; }
    public string Password { get; }
    public X509Certificate2 SelfCert { get; }
    public bool MessageAuthentication { get; }
    internal string MeshId { get; internal set; }
    public PeerAuthenticationMode get_AuthenticationMode();
    public string get_Password();
    public X509Certificate2 get_SelfCert();
    public bool get_MessageAuthentication();
    internal string get_MeshId();
    internal void set_MeshId(string value);
    internal SelfSignedCertificate GetCertificate();
    public static PeerSecurityManager Create(PeerSecuritySettings security, BindingContext context, XmlDictionaryReaderQuotas readerQuotas);
    public static PeerSecurityManager Create(PeerAuthenticationMode authenticationMode, bool signMessages, BindingContext context, XmlDictionaryReaderQuotas readerQuotas);
    public void ApplyServiceSecurity(ServiceDescription description);
    internal static PeerSecurityManager CreateDummy();
    public static PeerSecurityManager Create(PeerAuthenticationMode authenticationMode, bool messageAuthentication, PeerSecurityCredentialsManager credman, ChannelProtectionRequirements reqs, XmlDictionaryReaderQuotas readerQuotas);
    public void Open();
    public SecurityProtocolFactory GetProtocolFactory();
    public SecurityProtocol CreateSecurityProtocol(EndpointAddress target, TimeSpan timespan);
    public void CheckIfCompatibleNodeSettings(object other);
    public bool HasCompatibleMessageSecurity(PeerSecurityManager that);
    public Byte[] GetAuthenticator();
    public bool Authenticate(ServiceSecurityContext context, Byte[] message);
    public static Claim FindClaim(ServiceSecurityContext context);
    public void ApplyClientSecurity(ChannelFactory`1<IPeerProxy> factory);
    public BindingElement GetSecurityBindingElement();
    public PeerHashToken GetSelfToken();
    public PeerHashToken GetExpectedTokenForClaim(Claim claim);
    public void OnNeighborOpened(object sender, EventArgs args);
    public Message ProcessRequest(IPeerNeighbor neighbor, Message request);
}
internal class System.ServiceModel.Channels.PeerSecurityTokenSerializer : WSSecurityTokenSerializer {
    public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
}
[ServiceBehaviorAttribute]
internal class System.ServiceModel.Channels.PeerService : object {
    public Binding Binding { get; }
    public PeerService(PeerNodeConfig config, ChannelCallback channelCallback, GetNeighborCallback getNeighborCallback, Dictionary`2<Type, object> services);
    public PeerService(PeerNodeConfig config, ChannelCallback channelCallback, GetNeighborCallback getNeighborCallback, Dictionary`2<Type, object> services, IPeerNodeMessageHandling messageHandler);
    public void Abort();
    public Binding get_Binding();
    public EndpointAddress GetListenAddress();
    public void Open(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHost);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHost, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHost);
    private sealed virtual override void System.ServiceModel.Dispatcher.IChannelInitializer.Initialize(IClientChannel channel);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Connect(ConnectInfo connectInfo);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Disconnect(DisconnectInfo disconnectInfo);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Refuse(RefuseInfo refuseInfo);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Welcome(WelcomeInfo welcomeInfo);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IPeerServiceContract.BeginFloodMessage(Message floodedInfo, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.EndFloodMessage(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.LinkUtility(UtilityInfo utilityInfo);
    private sealed virtual override Message System.ServiceModel.Channels.IPeerServiceContract.ProcessRequestSecurityToken(Message message);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Fault(Message message);
    private sealed virtual override void System.ServiceModel.Channels.IPeerServiceContract.Ping(Message message);
}
internal static class System.ServiceModel.Channels.PeerStrings : object {
    public static Dictionary`2<string, string> protocolActions;
    public static string Namespace;
    public static string ServiceContractName;
    public static string ConnectAction;
    public static string WelcomeAction;
    public static string RefuseAction;
    public static string DisconnectAction;
    public static string FloodAction;
    public static string InternalFloodAction;
    public static string LinkUtilityAction;
    public static string RequestSecurityTokenAction;
    public static string RequestSecurityTokenResponseAction;
    public static string HopCountElementName;
    public static string HopCountElementNamespace;
    public static string PingAction;
    public static string Scheme;
    public static string KnownServiceUriPrefix;
    public static string PeerCustomResolver;
    public static string SkipLocalChannels;
    public static string Via;
    public static string MessageVerified;
    public static string CacheMiss;
    public static string PeerProperty;
    public static string MessageId;
    private static PeerStrings();
    public static string FindAction(string action);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.Channels.PeerTransportBindingElement : TransportBindingElement {
    public IPAddress ListenIPAddress { get; public set; }
    public long MaxReceivedMessageSize { get; public set; }
    public int Port { get; public set; }
    internal PeerResolver Resolver { get; internal set; }
    public string Scheme { get; }
    public PeerSecuritySettings Security { get; }
    public IPAddress get_ListenIPAddress();
    public void set_ListenIPAddress(IPAddress value);
    public virtual long get_MaxReceivedMessageSize();
    public virtual void set_MaxReceivedMessageSize(long value);
    public int get_Port();
    public void set_Port(int value);
    internal PeerResolver get_Resolver();
    internal void set_Resolver(PeerResolver value);
    public virtual string get_Scheme();
    public PeerSecuritySettings get_Security();
    private sealed virtual override void System.ServiceModel.Channels.ITransportPolicyImport.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
    internal void CreateDefaultResolver(PeerResolverSettings settings);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
}
internal static class System.ServiceModel.Channels.PeerTransportConstants : object {
    public static int ConnectTimeout;
    public static ulong InvalidNodeId;
    public static int MinNeighbors;
    public static int IdealNeighbors;
    public static int MaxResolveAddresses;
    public static int MaxNeighbors;
    public static int MaxReferrals;
    public static int MaxReferralCacheSize;
    public static int MaintainerInterval;
    public static int MaintainerRetryInterval;
    public static int MaintainerTimeout;
    public static int UnregisterTimeout;
    public static int AckTimeout;
    public static UInt32 AckWindow;
    public static long MinMessageSize;
    public static int MinPort;
    public static int MaxPort;
    public static ulong MaxHopCount;
    public static TimeSpan ForwardInterval;
    public static TimeSpan ForwardTimeout;
    public static int MaxOutgoingMessages;
    public static int MessageThreshold;
    private static PeerTransportConstants();
}
internal static class System.ServiceModel.Channels.PeerTransportDefaults : object {
    internal static IPAddress ListenIPAddress;
    internal static int Port;
    internal static string ResolverTypeString;
    internal static PeerAuthenticationMode PeerNodeAuthenticationMode;
    internal static bool MessageAuthentication;
    internal static bool ResolverAvailable { get; }
    internal static bool ResolverInstalled { get; }
    internal static Type ResolverType { get; }
    internal static Type ResolverBindingElementType { get; }
    internal static bool get_ResolverAvailable();
    internal static bool get_ResolverInstalled();
    internal static Type get_ResolverType();
    internal static Type get_ResolverBindingElementType();
    internal static PeerResolver CreateResolver();
}
internal static class System.ServiceModel.Channels.PeerTransportPolicyConstants : object {
    public static string PeerTransportSecurityMode;
    public static string PeerTransportCredentialType;
    public static string PeerTransportCredentialTypePassword;
    public static string PeerTransportCredentialTypeCertificate;
    public static string PeerTransportSecurityModeNone;
    public static string PeerTransportSecurityModeTransport;
    public static string PeerTransportSecurityModeMessage;
    public static string PeerTransportSecurityModeTransportWithMessageCredential;
    public static string PeerTransportPrefix;
}
internal static class System.ServiceModel.Channels.PeerValidateHelper : object {
    public static void ValidateListenIPAddress(IPAddress address);
    public static void ValidateMaxMessageSize(long value);
    public static void ValidatePort(int value);
    public static bool ValidNodeAddress(PeerNodeAddress address);
    public static bool ValidReferralNodeAddress(PeerNodeAddress address);
}
internal static class System.ServiceModel.Channels.PeerWinsock : object {
    internal static int WSAIoctl(IntPtr socketHandle, int ioControlCode, IntPtr inBuffer, int inBufferSize, IntPtr outBuffer, int outBufferSize, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine);
}
internal class System.ServiceModel.Channels.PeerX509TokenProvider : X509SecurityTokenProvider {
    public PeerX509TokenProvider(X509CertificateValidator validator, X509Certificate2 credential);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.PipeConnection : object {
    public int AsyncReadBufferSize { get; }
    public Byte[] AsyncReadBuffer { get; }
    public TraceEventType ExceptionEventType { get; public set; }
    public IPEndPoint RemoteIPEndPoint { get; }
    public PipeConnection(PipeHandle pipe, int connectionBufferSize, bool isBoundToCompletionPort, bool autoBindToCompletionPort);
    public sealed virtual int get_AsyncReadBufferSize();
    public sealed virtual Byte[] get_AsyncReadBuffer();
    public sealed virtual TraceEventType get_ExceptionEventType();
    public sealed virtual void set_ExceptionEventType(TraceEventType value);
    public sealed virtual IPEndPoint get_RemoteIPEndPoint();
    public sealed virtual void Abort();
    [SecuritySafeCriticalAttribute]
public sealed virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    [SecuritySafeCriticalAttribute]
public sealed virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public sealed virtual object DuplicateAndClose(int targetProcessId);
    public sealed virtual object GetCoreTransport();
    public sealed virtual int EndRead();
    public sealed virtual void EndWrite();
    [SecuritySafeCriticalAttribute]
public sealed virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public sealed virtual void Shutdown(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public sealed virtual bool EndValidate(IAsyncResult result);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
}
internal class System.ServiceModel.Channels.PipeConnectionInitiator : object {
    public PipeConnectionInitiator(int bufferSize, IPipeTransportFactorySettings pipeSettings);
    public sealed virtual IConnection Connect(Uri remoteUri, TimeSpan timeout);
    internal static string GetPipeName(Uri uri, IPipeTransportFactorySettings transportFactorySettings);
    public sealed virtual IAsyncResult BeginConnect(Uri uri, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IConnection EndConnect(IAsyncResult result);
}
internal class System.ServiceModel.Channels.PipeConnectionListener : object {
    public string PipeName { get; }
    public PipeConnectionListener(Uri pipeUri, HostNameComparisonMode hostNameComparisonMode, int bufferSize, List`1<SecurityIdentifier> allowedSids, bool useCompletionPort, int maxConnections);
    public string get_PipeName();
    public sealed virtual IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public sealed virtual IConnection EndAccept(IAsyncResult result);
    public sealed virtual void Dispose();
    public sealed virtual void Listen();
}
internal static class System.ServiceModel.Channels.PipeError : object {
    public static string GetErrorString(int error);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.PipeHandle : SafeHandleMinusOneIsInvalid {
    internal PipeHandle(IntPtr handle);
    internal int GetClientPid();
    protected virtual bool ReleaseHandle();
}
internal class System.ServiceModel.Channels.PipeSharedMemory : object {
    internal static string PipePrefix;
    internal static string PipeLocalPrefix;
    public string PipeName { get; }
    public static PipeSharedMemory Create(List`1<SecurityIdentifier> allowedSids, Uri pipeUri, string sharedMemoryName);
    [SecuritySafeCriticalAttribute]
public static bool TryCreate(List`1<SecurityIdentifier> allowedSids, Uri pipeUri, string sharedMemoryName, PipeSharedMemory& result);
    public static PipeSharedMemory Open(string sharedMemoryName, Uri pipeUri);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public string get_PipeName();
    internal string GetPipeName(AppContainerInfo appInfo);
    public static Exception CreatePipeNameInUseException(int error, Uri pipeUri);
}
internal static class System.ServiceModel.Channels.PipeUri : object {
    public static string BuildSharedMemoryName(Uri uri, HostNameComparisonMode hostNameComparisonMode, bool global);
    internal static string BuildSharedMemoryName(string hostName, string path, bool global, AppContainerInfo appContainerInfo);
    public static string GetPath(Uri uri);
    public static string GetParentPath(string path);
    public static void Validate(Uri uri);
}
internal class System.ServiceModel.Channels.PnrpPeerResolver : PeerResolver {
    public static int PNRPINFO_HINT;
    internal static int CommentLength;
    internal static byte TcpTransport;
    internal static byte PayloadVersion;
    internal static char PathSeparator;
    internal static int MinGuids;
    internal static int MaxGuids;
    internal static byte GuidEscape;
    internal static int MaxAddressEntries;
    internal static int MaxAddressEntriesV1;
    internal static int MaxPathLength;
    internal static string GlobalCloudName;
    public static bool IsPnrpAvailable { get; }
    public static bool IsPnrpInstalled { get; }
    public bool CanShareReferrals { get; }
    private static PnrpPeerResolver();
    internal PnrpPeerResolver(PeerReferralPolicy referralPolicy);
    public static bool get_IsPnrpAvailable();
    public static bool get_IsPnrpInstalled();
    public static IPEndPoint GetHint();
    public static bool HasPeerNodeForMesh(string meshId);
    internal void SetMeshExtensions(string local, string remote);
    internal PnrpResolveScope EnumerateClouds(bool forResolve, Dictionary`2<UInt32, string> LinkCloudNames, Dictionary`2<UInt32, string> SiteCloudNames);
    public virtual bool get_CanShareReferrals();
    public virtual object Register(string meshId, PeerNodeAddress nodeAddress, TimeSpan timeout);
    public virtual void Unregister(object registrationId, TimeSpan timeout);
    public virtual void Update(object registrationId, PeerNodeAddress updatedNodeAddress, TimeSpan timeout);
    public virtual ReadOnlyCollection`1<PeerNodeAddress> Resolve(string meshId, int maxAddresses, TimeSpan timeout);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class System.ServiceModel.Channels.PnrpPeerResolverBindingElement : PeerResolverBindingElement {
    public PeerReferralPolicy ReferralPolicy { get; public set; }
    public PnrpPeerResolverBindingElement(PeerReferralPolicy referralPolicy);
    public virtual PeerReferralPolicy get_ReferralPolicy();
    public virtual void set_ReferralPolicy(PeerReferralPolicy value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual PeerResolver CreatePeerResolver();
    public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.Channels.PreReadConnection : DelegatingConnection {
    public PreReadConnection(IConnection innerConnection, Byte[] initialData);
    public PreReadConnection(IConnection innerConnection, Byte[] initialData, int initialOffset, int initialSize);
    public void AddPreReadData(Byte[] initialData, int initialOffset, int initialSize);
    public virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public virtual int EndRead();
}
internal class System.ServiceModel.Channels.PreReadStream : DelegatingStream {
    public PreReadStream(Stream stream, Byte[] preReadBuffer);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult result);
}
public class System.ServiceModel.Channels.PrivacyNoticeBindingElement : BindingElement {
    public Uri Url { get; public set; }
    public int Version { get; public set; }
    public PrivacyNoticeBindingElement(PrivacyNoticeBindingElement elementToBeCloned);
    public Uri get_Url();
    public void set_Url(Uri value);
    public int get_Version();
    public void set_Version(int value);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.PrivacyNoticeBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
}
internal static class System.ServiceModel.Channels.PrivacyNoticePolicyStrings : object {
    public static string PrivacyNoticeName;
    public static string PrivacyNoticeVersionAttributeName;
    public static string PrivacyNoticeNamespace;
    public static string PrivacyNoticePrefix;
}
internal abstract class System.ServiceModel.Channels.QueuedObjectPool`1 : object {
    protected void Initialize(int batchAllocCount, int maxFreeCount);
    public virtual bool Return(T value);
    public T Take();
    public void Close();
    protected virtual void CleanupItem(T item);
    protected abstract virtual T Create();
}
internal abstract class System.ServiceModel.Channels.ReadableMessageHeader : MessageHeader {
    public abstract virtual XmlDictionaryReader GetHeaderReader();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
public abstract class System.ServiceModel.Channels.ReceiveContext : object {
    public static string Name;
    public ReceiveContextState State { get; protected set; }
    protected object ThisLock { get; }
    private static ReceiveContext();
    [CompilerGeneratedAttribute]
public ReceiveContextState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(ReceiveContextState value);
    protected object get_ThisLock();
    [CompilerGeneratedAttribute]
public void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Faulted(EventHandler value);
    public static bool TryGet(Message message, ReceiveContext& property);
    public static bool TryGet(MessageProperties properties, ReceiveContext& property);
    public virtual void Abandon(TimeSpan timeout);
    public virtual void Abandon(Exception exception, TimeSpan timeout);
    public virtual IAsyncResult BeginAbandon(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginAbandon(Exception exception, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginComplete(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void Complete(TimeSpan timeout);
    public virtual void EndAbandon(IAsyncResult result);
    public virtual void EndComplete(IAsyncResult result);
    protected internal virtual void Fault();
    protected abstract virtual void OnAbandon(TimeSpan timeout);
    protected virtual void OnAbandon(Exception exception, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginAbandon(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginAbandon(Exception exception, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult OnBeginComplete(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnComplete(TimeSpan timeout);
    protected abstract virtual void OnEndAbandon(IAsyncResult result);
    protected abstract virtual void OnEndComplete(IAsyncResult result);
    protected virtual void OnFaulted();
}
public enum System.ServiceModel.Channels.ReceiveContextState : Enum {
    public int value__;
    public static ReceiveContextState Received;
    public static ReceiveContextState Completing;
    public static ReceiveContextState Completed;
    public static ReceiveContextState Abandoning;
    public static ReceiveContextState Abandoned;
    public static ReceiveContextState Faulted;
}
internal class System.ServiceModel.Channels.ReceivedFault : MessageFault {
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    public static ReceivedFault CreateFaultNone(XmlDictionaryReader reader, int maxBufferSize);
    public static ReceivedFault CreateFault12(XmlDictionaryReader reader, int maxBufferSize);
    public static ReceivedFault CreateFault11(XmlDictionaryReader reader, int maxBufferSize);
}
internal abstract class System.ServiceModel.Channels.ReceivedMessage : Message {
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    protected static bool HasHeaderElement(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected bool ReadStartBody(XmlDictionaryReader reader);
    protected static EnvelopeVersion ReadStartEnvelope(XmlDictionaryReader reader);
    protected static void VerifyStartBody(XmlDictionaryReader reader, EnvelopeVersion version);
}
internal class System.ServiceModel.Channels.ReceiveTimeoutAsyncResult : AsyncResult {
    internal TimeoutHelper TimeoutHelper { get; }
    internal AsyncCallback InnerCallback { get; }
    internal IAsyncResult InnerResult { get; internal set; }
    internal object InnerState { get; }
    internal ReceiveTimeoutAsyncResult(TimeSpan timeout, AsyncCallback callback, object state);
    private static ReceiveTimeoutAsyncResult();
    internal TimeoutHelper get_TimeoutHelper();
    internal AsyncCallback get_InnerCallback();
    internal IAsyncResult get_InnerResult();
    internal void set_InnerResult(IAsyncResult value);
    internal object get_InnerState();
}
internal class System.ServiceModel.Channels.RecycledMessageState : object {
    public HeaderInfoCache HeaderInfoCache { get; }
    public UriCache UriCache { get; }
    public HeaderInfoCache get_HeaderInfoCache();
    public UriCache get_UriCache();
    public MessageProperties TakeProperties();
    public void ReturnProperties(MessageProperties properties);
    public MessageHeaders TakeHeaders();
    public void ReturnHeaders(MessageHeaders headers);
}
internal static class System.ServiceModel.Channels.RedirectionConstants : object {
    public static string AddressElementName;
    public static string LocationElementName;
    public static string Namespace;
    public static string Prefix;
    public static string RedirectionElementName;
}
public class System.ServiceModel.Channels.RedirectionDuration : object {
    public static RedirectionDuration Permanent { get; }
    public static RedirectionDuration Temporary { get; }
    public string Namespace { get; private set; }
    public string Value { get; private set; }
    internal InternalRedirectionDuration InternalDuration { get; }
    private static RedirectionDuration();
    public static RedirectionDuration get_Permanent();
    public static RedirectionDuration get_Temporary();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    internal InternalRedirectionDuration get_InternalDuration();
    public static bool op_Inequality(RedirectionDuration left, RedirectionDuration right);
    public static bool op_Equality(RedirectionDuration left, RedirectionDuration right);
    public static RedirectionDuration Create(string duration, string ns);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.ServiceModel.Channels.RedirectionException : CommunicationException {
    public RedirectionDuration Duration { get; private set; }
    public IEnumerable`1<RedirectionLocation> Locations { get; private set; }
    public RedirectionScope Scope { get; private set; }
    public RedirectionType Type { get; private set; }
    public RedirectionException(RedirectionType type, RedirectionDuration duration, RedirectionScope scope, RedirectionLocation[] locations);
    public RedirectionException(RedirectionType type, RedirectionDuration duration, RedirectionScope scope, Exception innerException, RedirectionLocation[] locations);
    public RedirectionException(string message, RedirectionType type, RedirectionDuration duration, RedirectionScope scope, RedirectionLocation[] locations);
    public RedirectionException(string message, RedirectionType type, RedirectionDuration duration, RedirectionScope scope, Exception innerException, RedirectionLocation[] locations);
    protected RedirectionException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public RedirectionDuration get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(RedirectionDuration value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RedirectionLocation> get_Locations();
    [CompilerGeneratedAttribute]
private void set_Locations(IEnumerable`1<RedirectionLocation> value);
    [CompilerGeneratedAttribute]
public RedirectionScope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(RedirectionScope value);
    [CompilerGeneratedAttribute]
public RedirectionType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(RedirectionType value);
}
public class System.ServiceModel.Channels.RedirectionLocation : object {
    public Uri Address { get; private set; }
    public RedirectionLocation(Uri address);
    [CompilerGeneratedAttribute]
public Uri get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(Uri value);
}
public class System.ServiceModel.Channels.RedirectionScope : object {
    public static RedirectionScope Endpoint { get; }
    public static RedirectionScope Message { get; }
    public static RedirectionScope Session { get; }
    public string Namespace { get; private set; }
    public string Value { get; private set; }
    internal InternalRedirectionScope InternalScope { get; }
    private static RedirectionScope();
    public static RedirectionScope get_Endpoint();
    public static RedirectionScope get_Message();
    public static RedirectionScope get_Session();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    internal InternalRedirectionScope get_InternalScope();
    public static bool op_Inequality(RedirectionScope left, RedirectionScope right);
    public static bool op_Equality(RedirectionScope left, RedirectionScope right);
    public static RedirectionScope Create(string scope, string ns);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.ServiceModel.Channels.RedirectionType : object {
    public static RedirectionType Cache { get; }
    public static RedirectionType Resource { get; }
    public static RedirectionType UseIntermediary { get; }
    public string Namespace { get; private set; }
    public string Value { get; private set; }
    internal InternalRedirectionType InternalType { get; }
    private static RedirectionType();
    public static RedirectionType get_Cache();
    public static RedirectionType get_Resource();
    public static RedirectionType get_UseIntermediary();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    internal InternalRedirectionType get_InternalType();
    public static bool op_Inequality(RedirectionType left, RedirectionType right);
    public static bool op_Equality(RedirectionType left, RedirectionType right);
    public static RedirectionType Create(string type, string ns);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class System.ServiceModel.Channels.RedirectionUtility : object {
    public static bool IsNamespaceAndValueMatch(string value1, string namespace1, string value2, string namespace2);
    public static bool IsNamespaceMatch(string namespace1, string namespace2);
    public static int ComputeHashCode(string value, string ns);
}
[DataContractAttribute]
internal class System.ServiceModel.Channels.Referral : object {
    public PeerNodeAddress Address { get; public set; }
    public ulong NodeId { get; public set; }
    public Referral(ulong nodeId, PeerNodeAddress address);
    public PeerNodeAddress get_Address();
    public void set_Address(PeerNodeAddress value);
    public ulong get_NodeId();
    public void set_NodeId(ulong value);
}
internal class System.ServiceModel.Channels.ReferralsAddedHandler : MulticastDelegate {
    public ReferralsAddedHandler(object object, IntPtr method);
    public virtual void Invoke(IList`1<Referral> referrals, IPeerNeighbor neighbor);
    public virtual IAsyncResult BeginInvoke(IList`1<Referral> referrals, IPeerNeighbor neighbor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MessageContractAttribute]
internal class System.ServiceModel.Channels.RefuseInfo : object {
    public RefuseReason Reason { get; }
    public IList`1<Referral> Referrals { get; }
    public RefuseInfo(RefuseReason reason, Referral[] referrals);
    public RefuseReason get_Reason();
    public IList`1<Referral> get_Referrals();
    public bool HasBody();
}
internal enum System.ServiceModel.Channels.RefuseReason : Enum {
    public int value__;
    public static RefuseReason DuplicateNeighbor;
    public static RefuseReason DuplicateNodeId;
    public static RefuseReason NodeBusy;
}
internal class System.ServiceModel.Channels.RelatesToHeader : AddressingHeader {
    internal static Uri ReplyRelationshipType;
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId UniqueId { get; }
    public bool MustUnderstand { get; }
    public Uri RelationshipType { get; }
    private static RelatesToHeader();
    public virtual XmlDictionaryString get_DictionaryName();
    public UniqueId get_UniqueId();
    public virtual bool get_MustUnderstand();
    public virtual Uri get_RelationshipType();
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion, Uri relationshipType);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static void ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, Uri& relationshipType, UniqueId& messageId);
    public static RelatesToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.ReliableBinderRequestAsyncResult : ReliableOutputAsyncResult {
    protected IClientReliableChannelBinder ClientBinder { get; }
    protected Message Reply { get; }
    public ReliableBinderRequestAsyncResult(AsyncCallback callback, object state);
    protected IClientReliableChannelBinder get_ClientBinder();
    protected Message get_Reply();
    public static Message End(IAsyncResult result);
    public static Message End(IAsyncResult result, Exception& handledException);
    protected virtual IAsyncResult BeginOperation(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndOperation(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReliableBinderSendAsyncResult : ReliableOutputAsyncResult {
    public ReliableBinderSendAsyncResult(AsyncCallback callback, object state);
    public static void End(IAsyncResult result);
    public static void End(IAsyncResult result, Exception& handledException);
    protected virtual IAsyncResult BeginOperation(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndOperation(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.ReliableChannelBinder`1 : object {
    protected bool CanGetChannelForReceive { get; }
    public bool CanSendAsynchronously { get; }
    public ChannelParameterCollection ChannelParameters { get; }
    public IChannel Channel { get; }
    public bool Connected { get; }
    public MaskingMode DefaultMaskingMode { get; }
    public TimeSpan DefaultSendTimeout { get; }
    public bool HasSession { get; }
    public EndpointAddress LocalAddress { get; }
    protected bool MustCloseChannel { get; }
    protected bool MustOpenChannel { get; }
    public EndpointAddress RemoteAddress { get; }
    public CommunicationState State { get; }
    protected ChannelSynchronizer<TChannel> Synchronizer { get; }
    protected object ThisLock { get; }
    protected ReliableChannelBinder`1(TChannel channel, MaskingMode maskingMode, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected abstract virtual bool get_CanGetChannelForReceive();
    public abstract virtual bool get_CanSendAsynchronously();
    public virtual ChannelParameterCollection get_ChannelParameters();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_Connected();
    public MaskingMode get_DefaultMaskingMode();
    public sealed virtual TimeSpan get_DefaultSendTimeout();
    public abstract virtual bool get_HasSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    protected abstract virtual bool get_MustCloseChannel();
    protected abstract virtual bool get_MustOpenChannel();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public sealed virtual CommunicationState get_State();
    protected ChannelSynchronizer<TChannel> get_Synchronizer();
    protected object get_ThisLock();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnException(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnException(BinderExceptionHandler value);
    public sealed virtual void Abort();
    protected virtual void AddOutputHeaders(Message message);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginCloseChannel(TChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult BeginTryGetChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginTryReceive(TimeSpan timeout, MaskingMode maskingMode, AsyncCallback callback, object state);
    internal IAsyncResult BeginWaitForPendingOperations(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual void Close(TimeSpan timeout, MaskingMode maskingMode);
    protected virtual void CloseChannel(TChannel channel, TimeSpan timeout);
    public sealed virtual void EndClose(IAsyncResult result);
    protected virtual void EndCloseChannel(TChannel channel, IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    public sealed virtual void EndSend(IAsyncResult result);
    protected abstract virtual bool EndTryGetChannel(IAsyncResult result);
    public virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public void EndWaitForPendingOperations(IAsyncResult result);
    protected void Fault(Exception e);
    public abstract virtual ISession GetInnerSession();
    public sealed virtual void HandleException(Exception e);
    protected bool HandleException(Exception e, MaskingMode maskingMode);
    protected bool HandleException(Exception e, MaskingMode maskingMode, bool autoAborted);
    protected abstract virtual bool HasSecuritySession(TChannel channel);
    public sealed virtual bool IsHandleable(Exception e);
    protected abstract virtual void OnAbort();
    protected abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginSend(TChannel channel, Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginTryReceive(TChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual void OnEndClose(IAsyncResult result);
    protected abstract virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnEndSend(TChannel channel, IAsyncResult result);
    protected virtual bool OnEndTryReceive(TChannel channel, IAsyncResult result, RequestContext& requestContext);
    protected abstract virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnShutdown();
    protected virtual void OnSend(TChannel channel, Message message, TimeSpan timeout);
    protected virtual bool OnTryReceive(TChannel channel, TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message, TimeSpan timeout, MaskingMode maskingMode);
    public sealed virtual void SetMaskingMode(RequestContext context, MaskingMode maskingMode);
    protected abstract virtual bool TryGetChannel(TimeSpan timeout);
    public virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext, MaskingMode maskingMode);
    protected bool ValidateInputOperation(TimeSpan timeout);
    protected bool ValidateOutputOperation(Message message, TimeSpan timeout, MaskingMode maskingMode);
    internal void WaitForPendingOperations(TimeSpan timeout);
    protected RequestContext WrapMessage(Message message);
    public sealed virtual RequestContext WrapRequestContext(RequestContext context);
}
internal static class System.ServiceModel.Channels.ReliableChannelBinderHelper : object {
    internal static IAsyncResult BeginCloseDuplexSessionChannel(ReliableChannelBinder`1<IDuplexSessionChannel> binder, IDuplexSessionChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    internal static IAsyncResult BeginCloseReplySessionChannel(ReliableChannelBinder`1<IReplySessionChannel> binder, IReplySessionChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    internal static void CloseDuplexSessionChannel(ReliableChannelBinder`1<IDuplexSessionChannel> binder, IDuplexSessionChannel channel, TimeSpan timeout);
    internal static void CloseReplySessionChannel(ReliableChannelBinder`1<IReplySessionChannel> binder, IReplySessionChannel channel, TimeSpan timeout);
    internal static void EndCloseDuplexSessionChannel(IDuplexSessionChannel channel, IAsyncResult result);
    internal static void EndCloseReplySessionChannel(IReplySessionChannel channel, IAsyncResult result);
    internal static bool MaskHandled(MaskingMode maskingMode);
    internal static bool MaskUnhandled(MaskingMode maskingMode);
}
internal class System.ServiceModel.Channels.ReliableChannelCloseAsyncResult : AsyncResult {
    public ReliableChannelCloseAsyncResult(OperationWithTimeoutBeginCallback[] beginCallbacks, OperationEndCallback[] endCallbacks, IReliableChannelBinder binder, TimeSpan timeout, AsyncCallback callback, object state);
    private static ReliableChannelCloseAsyncResult();
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReliableChannelFactory`2 : ChannelFactoryBase`1<TChannel> {
    public TimeSpan AcknowledgementInterval { get; }
    public FaultHelper FaultHelper { get; }
    public bool FlowControlEnabled { get; }
    public TimeSpan InactivityTimeout { get; }
    protected IChannelFactory`1<InnerChannel> InnerChannelFactory { get; }
    public int MaxPendingChannels { get; }
    public int MaxRetryCount { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxTransferWindowSize { get; }
    public bool Ordered { get; }
    public ReliableMessagingVersion ReliableMessagingVersion { get; }
    public TimeSpan SendTimeout { get; }
    public ReliableChannelFactory`2(ReliableSessionBindingElement settings, IChannelFactory`1<InnerChannel> innerChannelFactory, Binding binding);
    public sealed virtual TimeSpan get_AcknowledgementInterval();
    public FaultHelper get_FaultHelper();
    public sealed virtual bool get_FlowControlEnabled();
    public sealed virtual TimeSpan get_InactivityTimeout();
    protected IChannelFactory`1<InnerChannel> get_InnerChannelFactory();
    public sealed virtual int get_MaxPendingChannels();
    public sealed virtual int get_MaxRetryCount();
    public sealed virtual MessageVersion get_MessageVersion();
    public sealed virtual int get_MaxTransferWindowSize();
    public sealed virtual bool get_Ordered();
    public sealed virtual ReliableMessagingVersion get_ReliableMessagingVersion();
    public virtual T GetProperty();
    public sealed virtual TimeSpan get_SendTimeout();
    protected virtual void OnAbort();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
}
internal abstract class System.ServiceModel.Channels.ReliableChannelListener`3 : ReliableChannelListenerBase`1<TChannel> {
    internal IChannelListener InnerChannelListener { get; internal set; }
    protected ReliableChannelListener`3(ReliableSessionBindingElement binding, BindingContext context);
    private static ReliableChannelListener`3();
    internal virtual IChannelListener get_InnerChannelListener();
    internal virtual void set_InnerChannelListener(IChannelListener value);
    protected abstract virtual TReliableChannel CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected void Dispatch();
    protected virtual void OnInnerChannelAccepted(TInnerChannel channel);
    protected bool EnqueueWithoutDispatch(TChannel channel);
    protected TReliableChannel GetChannel(WsrmMessageInfo info, UniqueId& id);
    protected bool HandleException(Exception e, ICommunicationObject o);
    protected virtual bool HasChannels();
    protected virtual bool IsLastChannel(UniqueId inputId);
    protected virtual void OnFaulted();
    protected virtual void OnOpened();
    protected TReliableChannel ProcessCreateSequence(WsrmMessageInfo info, TInnerChannel channel, Boolean& dispatch, Boolean& newChannel);
    protected abstract virtual void ProcessChannel(TInnerChannel channel);
    protected virtual void RemoveChannel(UniqueId inputId, UniqueId outputId);
}
internal abstract class System.ServiceModel.Channels.ReliableChannelListenerBase`1 : DelegatingChannelListener`1<TChannel> {
    public TimeSpan AcknowledgementInterval { get; }
    protected FaultHelper FaultHelper { get; protected set; }
    public bool FlowControlEnabled { get; }
    public TimeSpan InactivityTimeout { get; }
    protected bool IsAccepting { get; }
    public IMessageFilterTable`1<EndpointAddress> LocalAddresses { get; public set; }
    public int MaxPendingChannels { get; }
    public int MaxRetryCount { get; }
    public int MaxTransferWindowSize { get; }
    public MessageVersion MessageVersion { get; }
    public bool Ordered { get; }
    public ReliableMessagingVersion ReliableMessagingVersion { get; }
    public TimeSpan SendTimeout { get; }
    protected bool Duplex { get; }
    protected ReliableChannelListenerBase`1(ReliableSessionBindingElement settings, Binding binding);
    public sealed virtual TimeSpan get_AcknowledgementInterval();
    protected FaultHelper get_FaultHelper();
    protected void set_FaultHelper(FaultHelper value);
    public sealed virtual bool get_FlowControlEnabled();
    public sealed virtual TimeSpan get_InactivityTimeout();
    protected bool get_IsAccepting();
    public IMessageFilterTable`1<EndpointAddress> get_LocalAddresses();
    public void set_LocalAddresses(IMessageFilterTable`1<EndpointAddress> value);
    public sealed virtual int get_MaxPendingChannels();
    public sealed virtual int get_MaxRetryCount();
    public sealed virtual int get_MaxTransferWindowSize();
    public sealed virtual MessageVersion get_MessageVersion();
    public sealed virtual bool get_Ordered();
    public sealed virtual ReliableMessagingVersion get_ReliableMessagingVersion();
    public sealed virtual TimeSpan get_SendTimeout();
    protected abstract virtual bool get_Duplex();
    protected abstract virtual bool HasChannels();
    protected abstract virtual bool IsLastChannel(UniqueId inputId);
    protected virtual void OnAbort();
    protected virtual void AbortInnerListener();
    protected virtual void CloseInnerListener(TimeSpan timeout);
    protected virtual IAsyncResult BeginCloseInnerListener(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndCloseInnerListener(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    public void OnReliableChannelAbort(UniqueId inputId, UniqueId outputId);
    public void OnReliableChannelClose(UniqueId inputId, UniqueId outputId, TimeSpan timeout);
    public IAsyncResult OnReliableChannelBeginClose(UniqueId inputId, UniqueId outputId, TimeSpan timeout, AsyncCallback callback, object state);
    public void OnReliableChannelEndClose(IAsyncResult result);
    protected abstract virtual void RemoveChannel(UniqueId inputId, UniqueId outputId);
}
internal class System.ServiceModel.Channels.ReliableChannelOpenAsyncResult : AsyncResult {
    public ReliableChannelOpenAsyncResult(IReliableChannelBinder binder, ChannelReliableSession session, TimeSpan timeout, AsyncCallback callback, object state);
    private static ReliableChannelOpenAsyncResult();
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReliableDuplexListenerOverDuplex : ReliableListenerOverDuplex`2<IDuplexSessionChannel, ServerReliableDuplexSessionChannel> {
    protected bool Duplex { get; }
    public ReliableDuplexListenerOverDuplex(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ServerReliableDuplexSessionChannel CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(ServerReliableDuplexSessionChannel channel, Message message, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableDuplexListenerOverDuplexSession : ReliableListenerOverDuplexSession`2<IDuplexSessionChannel, ServerReliableDuplexSessionChannel> {
    protected bool Duplex { get; }
    public ReliableDuplexListenerOverDuplexSession(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ServerReliableDuplexSessionChannel CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(IDuplexSessionChannel channel, Message message, ServerReliableDuplexSessionChannel reliableChannel, WsrmMessageInfo info, bool newChannel);
}
internal abstract class System.ServiceModel.Channels.ReliableDuplexSessionChannel : DuplexChannel {
    public IReliableChannelBinder Binder { get; }
    public EndpointAddress LocalAddress { get; }
    protected ReliableOutputConnection OutputConnection { get; }
    protected UniqueId OutputID { get; }
    protected ChannelReliableSession ReliableSession { get; }
    public EndpointAddress RemoteAddress { get; }
    protected IReliableFactorySettings Settings { get; }
    public Uri Via { get; }
    public IDuplexSession Session { get; }
    protected ReliableDuplexSessionChannel(ChannelManagerBase manager, IReliableFactorySettings settings, IReliableChannelBinder binder);
    private static ReliableDuplexSessionChannel();
    public IReliableChannelBinder get_Binder();
    public virtual EndpointAddress get_LocalAddress();
    protected ReliableOutputConnection get_OutputConnection();
    protected UniqueId get_OutputID();
    protected ChannelReliableSession get_ReliableSession();
    public virtual EndpointAddress get_RemoteAddress();
    protected IReliableFactorySettings get_Settings();
    public virtual Uri get_Via();
    public sealed virtual IDuplexSession get_Session();
    public virtual T GetProperty();
    protected virtual void OnRemoteActivity();
    protected void ProcessDuplexMessage(WsrmMessageInfo info);
    protected abstract virtual void ProcessMessage(WsrmMessageInfo info);
    protected virtual void OnAbort();
    protected IAsyncResult OnBeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected void OnCloseOutputSession(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected void OnEndCloseOutputSession(IAsyncResult result);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnMessageDropped();
    protected void SetConnections();
    protected void SetSession(ChannelReliableSession session);
    protected void StartReceiving(bool canBlock);
}
internal class System.ServiceModel.Channels.ReliableInputConnection : object {
    public bool AllAdded { get; }
    public bool IsLastKnown { get; }
    public bool IsSequenceClosed { get; }
    public long Last { get; }
    public SequenceRangeCollection Ranges { get; }
    unknown ReliableMessagingVersion ReliableMessagingVersion {public set; }
    public bool get_AllAdded();
    public bool get_IsLastKnown();
    public bool get_IsSequenceClosed();
    public long get_Last();
    public SequenceRangeCollection get_Ranges();
    public void set_ReliableMessagingVersion(ReliableMessagingVersion value);
    public void Abort(ChannelBase channel);
    public bool CanMerge(long sequenceNumber);
    public static bool CanMerge(long sequenceNumber, SequenceRangeCollection ranges);
    public void Fault(ChannelBase channel);
    public bool IsValid(long sequenceNumber, bool isLast);
    public void Merge(long sequenceNumber, bool isLast);
    public bool SetCloseSequenceLast(long last);
    public bool SetTerminateSequenceLast(long last, Boolean& isLastLargeEnough);
    public bool Terminate();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void Close(TimeSpan timeout);
    public void EndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReliableInputListenerOverDuplex : ReliableListenerOverDuplex`2<IInputSessionChannel, ReliableInputSessionChannelOverDuplex> {
    protected bool Duplex { get; }
    public ReliableInputListenerOverDuplex(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableInputSessionChannelOverDuplex CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(ReliableInputSessionChannelOverDuplex channel, Message message, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableInputListenerOverDuplexSession : ReliableListenerOverDuplexSession`2<IInputSessionChannel, ReliableInputSessionChannelOverDuplex> {
    protected bool Duplex { get; }
    public ReliableInputListenerOverDuplexSession(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableInputSessionChannelOverDuplex CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(IDuplexSessionChannel channel, Message message, ReliableInputSessionChannelOverDuplex reliableChannel, WsrmMessageInfo info, bool newChannel);
}
internal class System.ServiceModel.Channels.ReliableInputListenerOverReply : ReliableListenerOverReply`2<IInputSessionChannel, ReliableInputSessionChannelOverReply> {
    protected bool Duplex { get; }
    public ReliableInputListenerOverReply(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableInputSessionChannelOverReply CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(ReliableInputSessionChannelOverReply reliableChannel, RequestContext context, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableInputListenerOverReplySession : ReliableListenerOverReplySession`2<IInputSessionChannel, ReliableInputSessionChannelOverReply> {
    protected bool Duplex { get; }
    public ReliableInputListenerOverReplySession(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableInputSessionChannelOverReply CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(IReplySessionChannel channel, RequestContext context, ReliableInputSessionChannelOverReply reliableChannel, WsrmMessageInfo info, bool newChannel);
}
internal abstract class System.ServiceModel.Channels.ReliableInputSessionChannel : InputChannel {
    protected string perfCounterId;
    protected bool AdvertisedZero { get; protected set; }
    public IServerReliableChannelBinder Binder { get; }
    protected ReliableInputConnection Connection { get; }
    protected DeliveryStrategy`1<Message> DeliveryStrategy { get; }
    protected ReliableChannelListenerBase`1<IInputSessionChannel> Listener { get; }
    protected ChannelReliableSession ReliableSession { get; }
    public IInputSession Session { get; }
    protected ReliableInputSessionChannel(ReliableChannelListenerBase`1<IInputSessionChannel> listener, IServerReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID);
    private static ReliableInputSessionChannel();
    protected bool get_AdvertisedZero();
    protected void set_AdvertisedZero(bool value);
    public IServerReliableChannelBinder get_Binder();
    protected ReliableInputConnection get_Connection();
    protected DeliveryStrategy`1<Message> get_DeliveryStrategy();
    protected ReliableChannelListenerBase`1<IInputSessionChannel> get_Listener();
    protected ChannelReliableSession get_ReliableSession();
    public sealed virtual IInputSession get_Session();
    protected virtual void AggregateAsyncCloseOperations(List`1<OperationWithTimeoutBeginCallback> beginOperations, List`1<OperationEndCallback> endOperations);
    protected abstract virtual bool HandleReceiveComplete(IAsyncResult result);
    protected virtual void AbortGuards();
    protected void AddAcknowledgementHeader(Message message);
    protected virtual IAsyncResult BeginCloseGuards(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClosed();
    protected virtual void CloseGuards(TimeSpan timeout);
    protected Message CreateAcknowledgmentMessage();
    protected virtual void EndCloseGuards(IAsyncResult result);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnQuotaAvailable();
    protected void ShutdownCallback(object state);
    protected void StartReceiving(bool canBlock);
}
internal class System.ServiceModel.Channels.ReliableInputSessionChannelOverDuplex : ReliableInputSessionChannel {
    public ReliableInputSessionChannelOverDuplex(ReliableChannelListenerBase`1<IInputSessionChannel> listener, IServerReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID);
    protected virtual void AbortGuards();
    protected virtual IAsyncResult BeginCloseGuards(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void CloseGuards(TimeSpan timeout);
    protected virtual void EndCloseGuards(IAsyncResult result);
    protected virtual bool HandleReceiveComplete(IAsyncResult result);
    protected virtual void OnClosing();
    protected virtual void OnQuotaAvailable();
    public void ProcessDemuxedMessage(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableInputSessionChannelOverReply : ReliableInputSessionChannel {
    public ReliableInputSessionChannelOverReply(ReliableChannelListenerBase`1<IInputSessionChannel> listener, IServerReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID);
    protected virtual bool HandleReceiveComplete(IAsyncResult result);
    public void ProcessDemuxedRequest(RequestContext context, WsrmMessageInfo info);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverDatagram`4 : ReliableChannelListener`3<TChannel, TReliableChannel, TInnerChannel> {
    protected ReliableListenerOverDatagram`4(ReliableSessionBindingElement binding, BindingContext context);
    protected abstract virtual IAsyncResult BeginTryReceiveItem(TInnerChannel channel, AsyncCallback callback, object state);
    protected abstract virtual void DisposeItem(TItem item);
    protected abstract virtual void EndTryReceiveItem(TInnerChannel channel, IAsyncResult result, TItem& item);
    protected abstract virtual Message GetMessage(TItem item);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnInnerChannelAccepted(TInnerChannel channel);
    protected virtual void ProcessChannel(TInnerChannel channel);
    protected virtual void AbortInnerListener();
    protected virtual void CloseInnerListener(TimeSpan timeout);
    protected virtual IAsyncResult BeginCloseInnerListener(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndCloseInnerListener(IAsyncResult result);
    protected abstract virtual void ProcessSequencedItem(TReliableChannel reliableChannel, TItem item, WsrmMessageInfo info);
    protected abstract virtual void SendReply(Message reply, TInnerChannel channel, TItem item);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverDuplex`2 : ReliableListenerOverDatagram`4<TChannel, TReliableChannel, IDuplexChannel, Message> {
    protected ReliableListenerOverDuplex`2(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual IAsyncResult BeginTryReceiveItem(IDuplexChannel channel, AsyncCallback callback, object state);
    protected virtual void DisposeItem(Message item);
    protected virtual void EndTryReceiveItem(IDuplexChannel channel, IAsyncResult result, Message& item);
    protected virtual Message GetMessage(Message item);
    protected virtual void SendReply(Message reply, IDuplexChannel channel, Message item);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverDuplexSession`2 : ReliableListenerOverSession`5<TChannel, TReliableChannel, IDuplexSessionChannel, IDuplexSession, Message> {
    protected ReliableListenerOverDuplexSession`2(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual IAsyncResult BeginTryReceiveItem(IDuplexSessionChannel channel, AsyncCallback callback, object state);
    protected virtual void DisposeItem(Message item);
    protected virtual void EndTryReceiveItem(IDuplexSessionChannel channel, IAsyncResult result, Message& item);
    protected virtual Message GetMessage(Message item);
    protected virtual void SendReply(Message reply, IDuplexSessionChannel channel, Message item);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverReply`2 : ReliableListenerOverDatagram`4<TChannel, TReliableChannel, IReplyChannel, RequestContext> {
    protected ReliableListenerOverReply`2(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual IAsyncResult BeginTryReceiveItem(IReplyChannel channel, AsyncCallback callback, object state);
    protected virtual void DisposeItem(RequestContext item);
    protected virtual void EndTryReceiveItem(IReplyChannel channel, IAsyncResult result, RequestContext& item);
    protected virtual Message GetMessage(RequestContext item);
    protected virtual void SendReply(Message reply, IReplyChannel channel, RequestContext item);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverReplySession`2 : ReliableListenerOverSession`5<TChannel, TReliableChannel, IReplySessionChannel, IInputSession, RequestContext> {
    protected ReliableListenerOverReplySession`2(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual IAsyncResult BeginTryReceiveItem(IReplySessionChannel channel, AsyncCallback callback, object state);
    protected virtual void DisposeItem(RequestContext item);
    protected virtual void EndTryReceiveItem(IReplySessionChannel channel, IAsyncResult result, RequestContext& item);
    protected virtual Message GetMessage(RequestContext item);
    protected virtual void SendReply(Message reply, IReplySessionChannel channel, RequestContext item);
}
internal abstract class System.ServiceModel.Channels.ReliableListenerOverSession`5 : ReliableChannelListener`3<TChannel, TReliableChannel, TInnerChannel> {
    protected ReliableListenerOverSession`5(ReliableSessionBindingElement binding, BindingContext context);
    protected abstract virtual IAsyncResult BeginTryReceiveItem(TInnerChannel channel, AsyncCallback callback, object state);
    protected abstract virtual void DisposeItem(TItem item);
    protected abstract virtual void EndTryReceiveItem(TInnerChannel channel, IAsyncResult result, TItem& item);
    protected abstract virtual Message GetMessage(TItem item);
    protected virtual void ProcessChannel(TInnerChannel channel);
    protected abstract virtual void ProcessSequencedItem(TInnerChannel channel, TItem item, TReliableChannel reliableChannel, WsrmMessageInfo info, bool newChannel);
    protected abstract virtual void SendReply(Message reply, TInnerChannel channel, TItem item);
}
internal static class System.ServiceModel.Channels.ReliableMessagingConstants : object {
    public static TimeSpan UnknownInitiationTime;
    public static TimeSpan RequestorIterationTime;
    public static TimeSpan RequestorReceiveTime;
    public static int MaxSequenceRanges;
    private static ReliableMessagingConstants();
}
internal abstract class System.ServiceModel.Channels.ReliableOutputAsyncResult : AsyncResult {
    protected IReliableChannelBinder Binder { get; public set; }
    protected Exception HandledException { get; }
    public MaskingMode MaskingMode { get; public set; }
    public MessageAttemptInfo MessageAttemptInfo { get; public set; }
    protected Message Message { get; public set; }
    unknown bool SaveHandledException {public set; }
    protected ReliableOutputAsyncResult(AsyncCallback callback, object state);
    private static ReliableOutputAsyncResult();
    protected IReliableChannelBinder get_Binder();
    public void set_Binder(IReliableChannelBinder value);
    protected Exception get_HandledException();
    public MaskingMode get_MaskingMode();
    public void set_MaskingMode(MaskingMode value);
    public MessageAttemptInfo get_MessageAttemptInfo();
    public void set_MessageAttemptInfo(MessageAttemptInfo value);
    protected Message get_Message();
    public void set_Message(Message value);
    public void set_SaveHandledException(bool value);
    public void Begin(TimeSpan timeout);
    protected abstract virtual IAsyncResult BeginOperation(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void EndOperation(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReliableOutputConnection : object {
    public ComponentFaultedHandler Faulted;
    public ComponentExceptionHandler OnException;
    unknown BeginSendHandler BeginSendHandler {public set; }
    unknown OperationWithTimeoutBeginCallback BeginSendAckRequestedHandler {public set; }
    public bool Closed { get; }
    unknown EndSendHandler EndSendHandler {public set; }
    unknown OperationEndCallback EndSendAckRequestedHandler {public set; }
    public long Last { get; }
    unknown SendHandler SendHandler {public set; }
    unknown OperationWithTimeoutCallback SendAckRequestedHandler {public set; }
    public TransmissionStrategy Strategy { get; }
    public ReliableOutputConnection(UniqueId id, int maxTransferWindowSize, MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, TimeSpan initialRtt, bool requestAcks, TimeSpan sendTimeout);
    private static ReliableOutputConnection();
    public void set_BeginSendHandler(BeginSendHandler value);
    public void set_BeginSendAckRequestedHandler(OperationWithTimeoutBeginCallback value);
    public bool get_Closed();
    public void set_EndSendHandler(EndSendHandler value);
    public void set_EndSendAckRequestedHandler(OperationEndCallback value);
    public long get_Last();
    public void set_SendHandler(SendHandler value);
    public void set_SendAckRequestedHandler(OperationWithTimeoutCallback value);
    public TransmissionStrategy get_Strategy();
    public void Abort(ChannelBase channel);
    public bool AddMessage(Message message, TimeSpan timeout, object state);
    public IAsyncResult BeginAddMessage(Message message, TimeSpan timeout, object state, AsyncCallback callback, object asyncState);
    public bool EndAddMessage(IAsyncResult result);
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public bool CheckForTermination();
    public void Close(TimeSpan timeout);
    public void EndClose(IAsyncResult result);
    public void Fault(ChannelBase channel);
    public bool IsFinalAckConsistent(SequenceRangeCollection ranges);
    public void ProcessTransferred(long transferred, SequenceRangeCollection ranges, int quotaRemaining);
    public void ProcessTransferred(SequenceRangeCollection ranges, int quotaRemaining);
    public void Terminate();
}
internal abstract class System.ServiceModel.Channels.ReliableOutputSessionChannel : OutputChannel {
    protected IReliableChannelBinder Binder { get; }
    protected ReliableOutputConnection Connection { get; }
    unknown Exception MaxRetryCountException {protected set; }
    protected ChannelReliableSession ReliableSession { get; }
    public EndpointAddress RemoteAddress { get; }
    protected bool RequestAcks { get; }
    public IOutputSession Session { get; }
    public Uri Via { get; }
    protected IReliableFactorySettings Settings { get; }
    protected ReliableOutputSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    protected IReliableChannelBinder get_Binder();
    protected ReliableOutputConnection get_Connection();
    protected void set_MaxRetryCountException(Exception value);
    protected ChannelReliableSession get_ReliableSession();
    public virtual EndpointAddress get_RemoteAddress();
    protected abstract virtual bool get_RequestAcks();
    public sealed virtual IOutputSession get_Session();
    public virtual Uri get_Via();
    protected IReliableFactorySettings get_Settings();
    protected abstract virtual ReliableRequestor CreateRequestor();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected abstract virtual void OnConnectionSend(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    protected abstract virtual IAsyncResult OnConnectionBeginSend(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback callback, object state);
    protected abstract virtual void OnConnectionEndSend(IAsyncResult result);
    protected abstract virtual void OnConnectionSendMessage(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected abstract virtual IAsyncResult OnConnectionBeginSendMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnConnectionEndSendMessage(IAsyncResult result);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual void OnOpened();
    protected void ProcessMessage(Message message);
    protected abstract virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableOutputSessionChannelOverDuplex : ReliableOutputSessionChannel {
    protected bool RequestAcks { get; }
    public ReliableOutputSessionChannelOverDuplex(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    private static ReliableOutputSessionChannelOverDuplex();
    protected virtual bool get_RequestAcks();
    protected virtual ReliableRequestor CreateRequestor();
    protected virtual void OnConnectionSend(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    protected virtual IAsyncResult OnConnectionBeginSend(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback callback, object state);
    protected virtual void OnConnectionEndSend(IAsyncResult result);
    protected virtual void OnConnectionSendMessage(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual IAsyncResult OnConnectionBeginSendMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnConnectionEndSendMessage(IAsyncResult result);
    protected virtual void OnOpened();
    protected virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableOutputSessionChannelOverRequest : ReliableOutputSessionChannel {
    protected bool RequestAcks { get; }
    public ReliableOutputSessionChannelOverRequest(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    protected virtual bool get_RequestAcks();
    protected virtual ReliableRequestor CreateRequestor();
    protected virtual void OnConnectionSend(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    protected virtual IAsyncResult OnConnectionBeginSend(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback callback, object state);
    protected virtual void OnConnectionEndSend(IAsyncResult result);
    protected virtual void OnConnectionSendMessage(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual IAsyncResult OnConnectionBeginSendMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnConnectionEndSendMessage(IAsyncResult result);
    protected virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableReplyListenerOverReply : ReliableListenerOverReply`2<IReplySessionChannel, ReliableReplySessionChannel> {
    protected bool Duplex { get; }
    public ReliableReplyListenerOverReply(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableReplySessionChannel CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(ReliableReplySessionChannel reliableChannel, RequestContext context, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ReliableReplyListenerOverReplySession : ReliableListenerOverReplySession`2<IReplySessionChannel, ReliableReplySessionChannel> {
    protected bool Duplex { get; }
    public ReliableReplyListenerOverReplySession(ReliableSessionBindingElement binding, BindingContext context);
    protected virtual bool get_Duplex();
    protected virtual ReliableReplySessionChannel CreateChannel(UniqueId id, CreateSequenceInfo createSequenceInfo, IServerReliableChannelBinder binder);
    protected virtual void ProcessSequencedItem(IReplySessionChannel channel, RequestContext context, ReliableReplySessionChannel reliableChannel, WsrmMessageInfo info, bool newChannel);
}
internal class System.ServiceModel.Channels.ReliableReplySessionChannel : ReplyChannel {
    public IServerReliableChannelBinder Binder { get; }
    public IInputSession Session { get; }
    public ReliableReplySessionChannel(ReliableChannelListenerBase`1<IReplySessionChannel> listener, IServerReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID, UniqueId outputID);
    private static ReliableReplySessionChannel();
    public IServerReliableChannelBinder get_Binder();
    public sealed virtual IInputSession get_Session();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnFaulted();
    public void ProcessDemuxedRequest(RequestContext context, WsrmMessageInfo info);
}
internal abstract class System.ServiceModel.Channels.ReliableRequestor : object {
    protected IReliableChannelBinder Binder { get; public set; }
    protected bool IsCreateSequence { get; public set; }
    unknown ActionHeader MessageAction {public set; }
    unknown BodyWriter MessageBody {public set; }
    public UniqueId MessageId { get; }
    public WsrmMessageHeader MessageHeader { get; public set; }
    unknown MessageVersion MessageVersion {public set; }
    unknown string TimeoutString1Index {public set; }
    protected IReliableChannelBinder get_Binder();
    public void set_Binder(IReliableChannelBinder value);
    protected bool get_IsCreateSequence();
    public void set_IsCreateSequence(bool value);
    public void set_MessageAction(ActionHeader value);
    public void set_MessageBody(BodyWriter value);
    public UniqueId get_MessageId();
    public WsrmMessageHeader get_MessageHeader();
    public void set_MessageHeader(WsrmMessageHeader value);
    public void set_MessageVersion(MessageVersion value);
    public void set_TimeoutString1Index(string value);
    public void Abort(CommunicationObject communicationObject);
    public virtual void Fault(CommunicationObject communicationObject);
    public abstract virtual WsrmMessageInfo GetInfo();
    protected abstract virtual Message OnRequest(Message request, TimeSpan timeout, bool last);
    protected abstract virtual IAsyncResult OnBeginRequest(Message request, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual Message OnEndRequest(bool last, IAsyncResult result);
    public Message Request(TimeSpan timeout);
    public IAsyncResult BeginRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public Message EndRequest(IAsyncResult result);
    public abstract virtual void SetInfo(WsrmMessageInfo info);
    public void SetRequestResponsePattern();
}
internal class System.ServiceModel.Channels.ReliableRequestSessionChannel : RequestChannel {
    public IOutputSession Session { get; }
    public ReliableRequestSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters, UniqueId inputID);
    private static ReliableRequestSessionChannel();
    public sealed virtual IOutputSession get_Session();
    protected virtual IAsyncRequest CreateAsyncRequest(Message message, AsyncCallback callback, object state);
    protected virtual IRequest CreateRequest(Message message);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
}
public class System.ServiceModel.Channels.ReliableSessionBindingElement : BindingElement {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00.2")]
public TimeSpan AcknowledgementInterval { get; public set; }
    [DefaultValueAttribute("True")]
public bool FlowControlEnabled { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:10:00")]
public TimeSpan InactivityTimeout { get; public set; }
    [DefaultValueAttribute("4")]
public int MaxPendingChannels { get; public set; }
    [DefaultValueAttribute("8")]
public int MaxRetryCount { get; public set; }
    [DefaultValueAttribute("8")]
public int MaxTransferWindowSize { get; public set; }
    [DefaultValueAttribute("True")]
public bool Ordered { get; public set; }
    [DefaultValueAttribute("System.ServiceModel.ReliableMessagingVersion", "WSReliableMessagingFebruary2005")]
public ReliableMessagingVersion ReliableMessagingVersion { get; public set; }
    internal ReliableSessionBindingElement(ReliableSessionBindingElement elementToBeCloned);
    public ReliableSessionBindingElement(bool ordered);
    public TimeSpan get_AcknowledgementInterval();
    public void set_AcknowledgementInterval(TimeSpan value);
    public bool get_FlowControlEnabled();
    public void set_FlowControlEnabled(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public int get_MaxPendingChannels();
    public void set_MaxPendingChannels(int value);
    public int get_MaxRetryCount();
    public void set_MaxRetryCount(int value);
    public int get_MaxTransferWindowSize();
    public void set_MaxTransferWindowSize(int value);
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public ReliableMessagingVersion get_ReliableMessagingVersion();
    public void set_ReliableMessagingVersion(ReliableMessagingVersion value);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
public class System.ServiceModel.Channels.ReliableSessionBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
internal static class System.ServiceModel.Channels.ReliableSessionDefaults : object {
    internal static string AcknowledgementIntervalString;
    internal static bool Enabled;
    internal static bool FlowControlEnabled;
    internal static string InactivityTimeoutString;
    internal static int MaxPendingChannels;
    internal static int MaxRetryCount;
    internal static int MaxTransferWindowSize;
    internal static bool Ordered;
    internal static string ReliableMessagingVersionString;
    internal static TimeSpan AcknowledgementInterval { get; }
    internal static TimeSpan InactivityTimeout { get; }
    internal static ReliableMessagingVersion ReliableMessagingVersion { get; }
    internal static TimeSpan get_AcknowledgementInterval();
    internal static TimeSpan get_InactivityTimeout();
    internal static ReliableMessagingVersion get_ReliableMessagingVersion();
}
internal static class System.ServiceModel.Channels.ReliableSessionPolicyStrings : object {
    public static string AcknowledgementInterval;
    public static string AtLeastOnce;
    public static string AtMostOnce;
    public static string BaseRetransmissionInterval;
    public static string DeliveryAssurance;
    public static string ExactlyOnce;
    public static string ExponentialBackoff;
    public static string InactivityTimeout;
    public static string InOrder;
    public static string Milliseconds;
    public static string NET11Namespace;
    public static string NET11Prefix;
    public static string ReliableSessionName;
    public static string ReliableSessionFebruary2005Namespace;
    public static string ReliableSessionFebruary2005Prefix;
    public static string ReliableSession11Namespace;
    public static string ReliableSession11Prefix;
    public static string SequenceSTR;
    public static string SequenceTransportSecurity;
}
public class System.ServiceModel.Channels.RemoteEndpointMessageProperty : object {
    public static string Name { get; }
    public string Address { get; }
    public int Port { get; }
    public RemoteEndpointMessageProperty(string address, int port);
    internal RemoteEndpointMessageProperty(IRemoteEndpointProvider remoteEndpointProvider);
    internal RemoteEndpointMessageProperty(IPEndPoint remoteEndPoint);
    public static string get_Name();
    public string get_Address();
    public int get_Port();
}
internal class System.ServiceModel.Channels.ReplyAdapterBindingElement : BindingElement {
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.Channels.ReplyChannel : InputQueueChannel`1<RequestContext> {
    public EndpointAddress LocalAddress { get; }
    public ReplyChannel(ChannelManagerBase channelManager, EndpointAddress localAddress);
    public sealed virtual EndpointAddress get_LocalAddress();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    internal static RequestContext HelpReceiveRequest(IReplyChannel channel, TimeSpan timeout);
    internal static IAsyncResult HelpBeginReceiveRequest(IReplyChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    internal static RequestContext HelpEndReceiveRequest(IAsyncResult result);
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplyChannelAcceptor : SingletonChannelAcceptor`3<IReplyChannel, ReplyChannel, RequestContext> {
    public ReplyChannelAcceptor(ChannelManagerBase channelManager);
    protected virtual ReplyChannel OnCreateChannel();
    protected virtual void OnTraceMessageReceived(RequestContext requestContext);
}
internal class System.ServiceModel.Channels.ReplyChannelDemuxer : DatagramChannelDemuxer`2<IReplyChannel, RequestContext> {
    public ReplyChannelDemuxer(BindingContext context);
    protected virtual void AbortItem(RequestContext request);
    protected virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual LayeredChannelListener`1<TChannel> CreateListener(ChannelDemuxerFilter filter);
    protected virtual void Dispatch(IChannelListener listener);
    protected virtual void EndpointNotFound(RequestContext request);
    protected virtual RequestContext EndReceive(IAsyncResult result);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, RequestContext request, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual void EnqueueAndDispatch(IChannelListener listener, Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected virtual Message GetMessage(RequestContext request);
}
internal class System.ServiceModel.Channels.ReplyChannelDemuxFailureAsyncResult : AsyncResult {
    public ReplyChannelDemuxFailureAsyncResult(IChannelDemuxFailureHandler demuxFailureHandler, RequestContext requestContext, AsyncCallback callback, object state);
    private static ReplyChannelDemuxFailureAsyncResult();
    public void Start();
    protected virtual bool OnDemuxFailureHandled();
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplyChannelWrapper : ChannelWrapper`2<IReplyChannel, RequestContext> {
    public EndpointAddress LocalAddress { get; }
    public ReplyChannelWrapper(ChannelManagerBase channelManager, IReplyChannel innerChannel, RequestContext firstRequest);
    public sealed virtual EndpointAddress get_LocalAddress();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void CloseFirstItem(TimeSpan timeout);
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& request);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& request);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplyFaultHelper : TypedFaultHelper`1<FaultState> {
    public ReplyFaultHelper(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    protected virtual void AbortState(FaultState faultState, bool isOnAbortThread);
    protected virtual IAsyncResult BeginSendFault(IReliableChannelBinder binder, FaultState faultState, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndSendFault(IReliableChannelBinder binder, FaultState faultState, IAsyncResult result);
    protected virtual FaultState GetState(RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.ReplyOneWayChannelListener : LayeredChannelListener`1<IInputChannel> {
    public ReplyOneWayChannelListener(OneWayBindingElement bindingElement, BindingContext context);
    protected virtual void OnOpening();
    protected virtual IInputChannel OnAcceptChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IInputChannel OnEndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplyOverDuplexChannel : ReplyOverDuplexChannelBase`1<IDuplexChannel> {
    public ReplyOverDuplexChannel(ChannelManagerBase channelManager, IDuplexChannel innerChannel);
}
internal abstract class System.ServiceModel.Channels.ReplyOverDuplexChannelBase`1 : LayeredChannel`1<TInnerChannel> {
    public EndpointAddress LocalAddress { get; }
    public ReplyOverDuplexChannelBase`1(ChannelManagerBase channelManager, TInnerChannel innerChannel);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplyOverDuplexChannelListener : ReplyOverDuplexChannelListenerBase`2<IReplyChannel, IDuplexChannel> {
    public ReplyOverDuplexChannelListener(BindingContext context);
    protected virtual IReplyChannel CreateWrappedChannel(ChannelManagerBase channelManager, IDuplexChannel innerChannel);
}
internal abstract class System.ServiceModel.Channels.ReplyOverDuplexChannelListenerBase`2 : LayeredChannelListener`1<TOuterChannel> {
    public ReplyOverDuplexChannelListenerBase`2(BindingContext context);
    protected virtual void OnOpening();
    protected virtual TOuterChannel OnAcceptChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual TOuterChannel OnEndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
    protected abstract virtual TOuterChannel CreateWrappedChannel(ChannelManagerBase channelManager, TInnerChannel innerChannel);
}
internal class System.ServiceModel.Channels.ReplySessionChannelDemuxer : SessionChannelDemuxer`2<IReplySessionChannel, RequestContext> {
    public ReplySessionChannelDemuxer(BindingContext context, TimeSpan peekTimeout, int maxPendingSessions);
    protected virtual void AbortItem(RequestContext request);
    protected virtual IAsyncResult BeginReceive(IReplySessionChannel channel, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginReceive(IReplySessionChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IReplySessionChannel CreateChannel(ChannelManagerBase channelManager, IReplySessionChannel innerChannel, RequestContext firstRequest);
    protected virtual void EndpointNotFound(IReplySessionChannel channel, RequestContext request);
    protected virtual RequestContext EndReceive(IReplySessionChannel channel, IAsyncResult result);
    protected virtual Message GetMessage(RequestContext request);
}
internal class System.ServiceModel.Channels.ReplySessionChannelWrapper : ReplyChannelWrapper {
    public IInputSession Session { get; }
    public ReplySessionChannelWrapper(ChannelManagerBase channelManager, IReplySessionChannel innerChannel, RequestContext firstRequest);
    public sealed virtual IInputSession get_Session();
}
internal class System.ServiceModel.Channels.ReplySessionDemuxFailureAsyncResult : ReplyChannelDemuxFailureAsyncResult {
    public ReplySessionDemuxFailureAsyncResult(IChannelDemuxFailureHandler demuxFailureHandler, RequestContext requestContext, IReplySessionChannel channel, AsyncCallback callback, object state);
    private static ReplySessionDemuxFailureAsyncResult();
    protected virtual bool OnDemuxFailureHandled();
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ReplySessionOverDuplexSessionChannel : ReplyOverDuplexChannelBase`1<IDuplexSessionChannel> {
    public IInputSession Session { get; }
    public ReplySessionOverDuplexSessionChannel(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel);
    public sealed virtual IInputSession get_Session();
}
internal class System.ServiceModel.Channels.ReplySessionOverDuplexSessionChannelListener : ReplyOverDuplexChannelListenerBase`2<IReplySessionChannel, IDuplexSessionChannel> {
    public ReplySessionOverDuplexSessionChannelListener(BindingContext context);
    protected virtual IReplySessionChannel CreateWrappedChannel(ChannelManagerBase channelManager, IDuplexSessionChannel innerChannel);
}
internal class System.ServiceModel.Channels.ReplyToHeader : AddressingHeader {
    public EndpointAddress ReplyTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public static ReplyToHeader AnonymousReplyTo10 { get; }
    public static ReplyToHeader AnonymousReplyTo200408 { get; }
    public EndpointAddress get_ReplyTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static ReplyToHeader get_AnonymousReplyTo10();
    public static ReplyToHeader get_AnonymousReplyTo200408();
    public static ReplyToHeader Create(EndpointAddress replyTo, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static ReplyToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
internal abstract class System.ServiceModel.Channels.RequestChannel : ChannelBase {
    protected bool ManualAddressing { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected RequestChannel(ChannelManagerBase channelFactory, EndpointAddress to, Uri via, bool manualAddressing);
    protected bool get_ManualAddressing();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected void AbortPendingRequests();
    protected IAsyncResult BeginWaitForPendingRequests(TimeSpan timeout, AsyncCallback callback, object state);
    protected void EndWaitForPendingRequests(IAsyncResult result);
    protected void WaitForPendingRequests(TimeSpan timeout);
    protected void FaultPendingRequests();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IRequest CreateRequest(Message message);
    protected abstract virtual IAsyncRequest CreateAsyncRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    protected virtual void AddHeadersTo(Message message);
}
public abstract class System.ServiceModel.Channels.RequestContext : object {
    public Message RequestMessage { get; }
    public abstract virtual Message get_RequestMessage();
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void Reply(Message message);
    public abstract virtual void Reply(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndReply(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Channels.RequestContextBase : RequestContext {
    public Message RequestMessage { get; }
    protected bool ReplyInitiated { get; }
    protected object ThisLock { get; }
    public bool Aborted { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public TimeSpan DefaultSendTimeout { get; }
    protected RequestContextBase(Message requestMessage, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public void ReInitialize(Message requestMessage);
    public virtual Message get_RequestMessage();
    protected void SetRequestMessage(Message requestMessage);
    protected void SetRequestMessage(Exception requestMessageException);
    protected bool get_ReplyInitiated();
    protected object get_ThisLock();
    public bool get_Aborted();
    public TimeSpan get_DefaultCloseTimeout();
    public TimeSpan get_DefaultSendTimeout();
    public virtual void Abort();
    public virtual void Close();
    public virtual void Close(TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual void OnReply(Message message, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndReply(IAsyncResult result);
    protected void ThrowIfInvalidReply();
    protected bool TryInitiateReply();
    public virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndReply(IAsyncResult result);
    public virtual void Reply(Message message);
    public virtual void Reply(Message message, TimeSpan timeout);
    protected void SetReplySent();
}
internal class System.ServiceModel.Channels.RequestContextMessageProperty : object {
    public static string Name { get; }
    public RequestContextMessageProperty(RequestContext context);
    public static string get_Name();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ServiceModel.Channels.RequestOneWayChannelFactory : LayeredChannelFactory`1<IOutputChannel> {
    public RequestOneWayChannelFactory(OneWayBindingElement bindingElement, BindingContext context);
    protected virtual IOutputChannel OnCreateChannel(EndpointAddress to, Uri via);
}
internal class System.ServiceModel.Channels.RequestReliableRequestor : ReliableRequestor {
    public virtual WsrmMessageInfo GetInfo();
    protected virtual Message OnRequest(Message request, TimeSpan timeout, bool last);
    protected virtual IAsyncResult OnBeginRequest(Message request, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual Message OnEndRequest(bool last, IAsyncResult result);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.RequestReplyCorrelator : object {
    private sealed virtual override void System.ServiceModel.Channels.IRequestReplyCorrelator.Add(Message request, T state);
    private sealed virtual override T System.ServiceModel.Channels.IRequestReplyCorrelator.Find(Message reply, bool remove);
    internal void RemoveRequest(ICorrelatorKey request);
    internal static bool AddressReply(Message reply, Message request);
    internal static bool AddressReply(Message reply, ReplyToInfo info);
    internal static ReplyToInfo ExtractReplyToInfo(Message message);
    internal static void PrepareRequest(Message request);
    internal static void PrepareReply(Message reply, UniqueId messageId);
    internal static void PrepareReply(Message reply, Message request);
}
public class System.ServiceModel.Channels.RetryException : CommunicationException {
    public RetryException(string message);
    public RetryException(string message, Exception innerException);
    [SecurityCriticalAttribute]
protected RetryException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Channels.RetryHandler : MulticastDelegate {
    public RetryHandler(object object, IntPtr method);
    public virtual void Invoke(MessageAttemptInfo attemptInfo);
    public virtual IAsyncResult BeginInvoke(MessageAttemptInfo attemptInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.SafeFileMappingHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public void DoNotFreeLibraryOnRelease();
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.ServiceModel.Channels.SafeNativeMethods : object {
    public static string KERNEL32;
    public static void GetSystemTimeAsFileTime(Int64& time);
    [SecuritySafeCriticalAttribute]
internal static long GetSystemTimeResolution();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.SafeViewOfFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal static class System.ServiceModel.Channels.SecurityAttributeGenerationHelper : object {
    public static CodeAttributeDeclaration FindOrCreateAttributeDeclaration(CodeAttributeDeclarationCollection attributes);
    public static void CreateOrOverridePropertyDeclaration(CodeAttributeDeclaration attribute, string propertyName, V value);
    public static CodeAttributeArgument TryGetAttributeProperty(CodeAttributeDeclaration attribute, string propertyName);
}
public abstract class System.ServiceModel.Channels.SecurityBindingElement : BindingElement {
    internal static string defaultAlgorithmSuiteString;
    internal static SecurityAlgorithmSuite defaultDefaultAlgorithmSuite;
    internal static bool defaultIncludeTimestamp;
    internal static bool defaultAllowInsecureTransport;
    internal static MessageProtectionOrder defaultMessageProtectionOrder;
    internal static bool defaultRequireSignatureConfirmation;
    internal static bool defaultEnableUnsecuredResponse;
    internal static bool defaultProtectTokens;
    internal bool SupportsExtendedProtectionPolicy { get; internal set; }
    public SupportingTokenParameters EndpointSupportingTokenParameters { get; }
    public SupportingTokenParameters OptionalEndpointSupportingTokenParameters { get; }
    public IDictionary`2<string, SupportingTokenParameters> OperationSupportingTokenParameters { get; }
    public IDictionary`2<string, SupportingTokenParameters> OptionalOperationSupportingTokenParameters { get; }
    public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    public MessageSecurityVersion MessageSecurityVersion { get; public set; }
    public bool EnableUnsecuredResponse { get; public set; }
    public bool IncludeTimestamp { get; public set; }
    public bool AllowInsecureTransport { get; public set; }
    public SecurityAlgorithmSuite DefaultAlgorithmSuite { get; public set; }
    public bool ProtectTokens { get; public set; }
    public LocalClientSecuritySettings LocalClientSettings { get; }
    public LocalServiceSecuritySettings LocalServiceSettings { get; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    internal long MaxReceivedMessageSize { get; internal set; }
    internal bool DoNotEmitTrust { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; internal set; }
    internal SecurityBindingElement(SecurityBindingElement elementToBeCloned);
    private static SecurityBindingElement();
    internal bool get_SupportsExtendedProtectionPolicy();
    internal void set_SupportsExtendedProtectionPolicy(bool value);
    public SupportingTokenParameters get_EndpointSupportingTokenParameters();
    public SupportingTokenParameters get_OptionalEndpointSupportingTokenParameters();
    public IDictionary`2<string, SupportingTokenParameters> get_OperationSupportingTokenParameters();
    public IDictionary`2<string, SupportingTokenParameters> get_OptionalOperationSupportingTokenParameters();
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public MessageSecurityVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(MessageSecurityVersion value);
    public bool get_EnableUnsecuredResponse();
    public void set_EnableUnsecuredResponse(bool value);
    public bool get_IncludeTimestamp();
    public void set_IncludeTimestamp(bool value);
    public bool get_AllowInsecureTransport();
    public void set_AllowInsecureTransport(bool value);
    public SecurityAlgorithmSuite get_DefaultAlgorithmSuite();
    public void set_DefaultAlgorithmSuite(SecurityAlgorithmSuite value);
    public bool get_ProtectTokens();
    public void set_ProtectTokens(bool value);
    public LocalClientSecuritySettings get_LocalClientSettings();
    public LocalServiceSecuritySettings get_LocalServiceSettings();
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    internal long get_MaxReceivedMessageSize();
    internal void set_MaxReceivedMessageSize(long value);
    internal bool get_DoNotEmitTrust();
    internal void set_DoNotEmitTrust(bool value);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    internal void GetSupportingTokensCapabilities(Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    internal void AddDemuxerForSecureConversation(ChannelBuilder builder, BindingContext secureConversationBindingContext);
    internal void ApplyPropertiesOnDemuxer(ChannelBuilder builder, BindingContext context);
    protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext);
    internal bool RequiresChannelDemuxer(SecurityTokenParameters parameters);
    internal virtual bool RequiresChannelDemuxer();
    internal bool IsUnderlyingListenerDuplex(BindingContext context);
    internal void ConfigureProtocolFactory(SecurityProtocolFactory factory, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext, Binding binding);
    internal abstract virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuanceBindingContext);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    protected abstract virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    protected abstract virtual IChannelListener`1<TChannel> BuildChannelListenerCore(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual void SetKeyDerivation(bool requireDerivedKeys);
    internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys);
    internal ChannelProtectionRequirements GetProtectionRequirements(AddressingVersion addressing, ProtectionLevel defaultProtectionLevel);
    public virtual T GetProperty(BindingContext context);
    internal abstract virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    public static SecurityBindingElement CreateMutualCertificateBindingElement();
    internal static bool IsMutualCertificateBinding(SecurityBindingElement sbe);
    public static AsymmetricSecurityBindingElement CreateCertificateSignatureBindingElement();
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version);
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);
    internal static bool IsMutualCertificateDuplexBinding(SecurityBindingElement sbe);
    internal static bool IsMutualCertificateBinding(SecurityBindingElement sbe, bool allowSerializedSigningTokenOnReply);
    public static SymmetricSecurityBindingElement CreateAnonymousForCertificateBindingElement();
    internal static bool IsAnonymousForCertificateBinding(SecurityBindingElement sbe);
    public static AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement();
    public static AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement(MessageSecurityVersion version);
    public static SymmetricSecurityBindingElement CreateUserNameForCertificateBindingElement();
    internal static bool IsUserNameForCertificateBinding(SecurityBindingElement sbe);
    public static SymmetricSecurityBindingElement CreateKerberosBindingElement();
    internal static bool IsKerberosBinding(SecurityBindingElement sbe);
    public static SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement();
    public static SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement(bool requireCancellation);
    internal static bool IsSspiNegotiationBinding(SecurityBindingElement sbe, bool requireCancellation);
    public static SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate);
    public static SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate, bool requireCancellation);
    internal static bool IsSslNegotiationBinding(SecurityBindingElement sbe, bool requireClientCertificate, bool requireCancellation);
    public static SymmetricSecurityBindingElement CreateIssuedTokenBindingElement(IssuedSecurityTokenParameters issuedTokenParameters);
    public static SymmetricSecurityBindingElement CreateIssuedTokenForCertificateBindingElement(IssuedSecurityTokenParameters issuedTokenParameters);
    internal static bool IsIssuedTokenForCertificateBinding(SecurityBindingElement sbe, IssuedSecurityTokenParameters& issuedTokenParameters);
    public static SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(IssuedSecurityTokenParameters issuedTokenParameters);
    internal static bool IsIssuedTokenForSslBinding(SecurityBindingElement sbe, IssuedSecurityTokenParameters& issuedTokenParameters);
    public static SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(IssuedSecurityTokenParameters issuedTokenParameters, bool requireCancellation);
    internal static bool IsIssuedTokenForSslBinding(SecurityBindingElement sbe, bool requireCancellation, IssuedSecurityTokenParameters& issuedTokenParameters);
    public static SymmetricSecurityBindingElement CreateUserNameForSslBindingElement();
    public static SymmetricSecurityBindingElement CreateUserNameForSslBindingElement(bool requireCancellation);
    internal static bool IsUserNameForSslBinding(SecurityBindingElement sbe, bool requireCancellation);
    public static TransportSecurityBindingElement CreateUserNameOverTransportBindingElement();
    internal static bool IsUserNameOverTransportBinding(SecurityBindingElement sbe);
    public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement();
    public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(MessageSecurityVersion version);
    internal static bool IsCertificateOverTransportBinding(SecurityBindingElement sbe);
    public static TransportSecurityBindingElement CreateKerberosOverTransportBindingElement();
    public static TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement();
    public static TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement(bool requireCancellation);
    internal static bool IsSspiNegotiationOverTransportBinding(SecurityBindingElement sbe, bool requireCancellation);
    public static TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement(IssuedSecurityTokenParameters issuedTokenParameters);
    internal static bool IsIssuedTokenOverTransportBinding(SecurityBindingElement sbe, IssuedSecurityTokenParameters& issuedTokenParameters);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity);
    internal static bool IsSecureConversationBinding(SecurityBindingElement sbe, SecurityBindingElement& bootstrapSecurity);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements);
    internal static bool IsSecureConversationBinding(SecurityBindingElement sbe, bool requireCancellation, SecurityBindingElement& bootstrapSecurity);
    public virtual string ToString();
    internal static ChannelProtectionRequirements ComputeProtectionRequirements(SecurityBindingElement security, BindingParameterCollection parameterCollection, BindingElementCollection bindingElements, bool isForService);
    internal void ApplyAuditBehaviorSettings(BindingContext context, SecurityProtocolFactory factory);
    internal virtual bool IsMatch(BindingElement b);
    internal static void ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal static void ExportPolicyForTransportTokenAssertionProviders(MetadataExporter exporter, PolicyConversionContext context);
}
public class System.ServiceModel.Channels.SecurityBindingElementImporter : object {
    internal static string MaxPolicyRedirectionsKey;
    internal static string SecureConversationBootstrapEncryptionRequirements;
    internal static string SecureConversationBootstrapSignatureRequirements;
    internal static string InSecureConversationBootstrapBindingImportMode;
    internal static string ContractProtectionLevelKey;
    public int MaxPolicyRedirections { get; }
    public int get_MaxPolicyRedirections();
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
}
internal class System.ServiceModel.Channels.SecurityCapabilities : object {
    internal bool supportsServerAuth;
    internal bool supportsClientAuth;
    internal bool supportsClientWindowsIdentity;
    internal ProtectionLevel requestProtectionLevel;
    internal ProtectionLevel responseProtectionLevel;
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public SecurityCapabilities(bool supportsClientAuth, bool supportsServerAuth, bool supportsClientWindowsIdentity, ProtectionLevel requestProtectionLevel, ProtectionLevel responseProtectionLevel);
    public sealed virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public sealed virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public sealed virtual bool get_SupportsClientAuthentication();
    public sealed virtual bool get_SupportsClientWindowsIdentity();
    public sealed virtual bool get_SupportsServerAuthentication();
    internal static bool IsEqual(ISecurityCapabilities capabilities1, ISecurityCapabilities capabilities2);
}
internal class System.ServiceModel.Channels.SecurityChannelFactory`1 : LayeredChannelFactory`1<TChannel> {
    public ChannelBuilder ChannelBuilder { get; }
    public SecurityProtocolFactory SecurityProtocolFactory { get; }
    public SecuritySessionClientSettings`1<TChannel> SessionClientSettings { get; }
    public bool SessionMode { get; }
    public MessageVersion MessageVersion { get; }
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, SecuritySessionClientSettings`1<TChannel> sessionClientSettings);
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, ChannelBuilder channelBuilder, SecurityProtocolFactory protocolFactory);
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, ChannelBuilder channelBuilder, SecurityProtocolFactory protocolFactory, IChannelFactory innerChannelFactory);
    internal SecurityChannelFactory`1(Binding binding, SecurityProtocolFactory protocolFactory, IChannelFactory innerChannelFactory);
    public ChannelBuilder get_ChannelBuilder();
    public SecurityProtocolFactory get_SecurityProtocolFactory();
    public SecuritySessionClientSettings`1<TChannel> get_SessionClientSettings();
    public bool get_SessionMode();
    public MessageVersion get_MessageVersion();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
}
internal class System.ServiceModel.Channels.SecurityChannelFaultConverter : FaultConverter {
    internal SecurityChannelFaultConverter(IChannel innerChannel);
    protected virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
}
internal class System.ServiceModel.Channels.SecurityChannelListener`1 : DelegatingChannelListener`1<TChannel> {
    public ChannelBuilder ChannelBuilder { get; }
    public SecurityProtocolFactory SecurityProtocolFactory { get; public set; }
    public bool SessionMode { get; public set; }
    public SecuritySessionServerSettings SessionServerSettings { get; }
    public bool SendUnsecuredFaults { get; public set; }
    public SecurityChannelListener`1(SecurityBindingElement bindingElement, BindingContext context);
    internal SecurityChannelListener`1(SecurityProtocolFactory protocolFactory, IChannelListener innerChannelListener);
    public ChannelBuilder get_ChannelBuilder();
    public SecurityProtocolFactory get_SecurityProtocolFactory();
    public void set_SecurityProtocolFactory(SecurityProtocolFactory value);
    public bool get_SessionMode();
    public void set_SessionMode(bool value);
    public SecuritySessionServerSettings get_SessionServerSettings();
    public bool get_SendUnsecuredFaults();
    public void set_SendUnsecuredFaults(bool value);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    internal IAsyncResult OnBeginOpenListenerState(TimeSpan timeout, AsyncCallback callback, object state);
    internal void OnEndOpenListenerState(IAsyncResult result);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
    protected virtual void OnClose(TimeSpan timeout);
    internal void InitializeListener(ChannelBuilder channelBuilder);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnFaulted();
}
internal static class System.ServiceModel.Channels.SecurityDescriptorHelper : object {
    private static SecurityDescriptorHelper();
    internal static Byte[] FromSecurityIdentifiers(List`1<SecurityIdentifier> allowedSids, int accessRights);
}
public enum System.ServiceModel.Channels.SecurityHeaderLayout : Enum {
    public int value__;
    public static SecurityHeaderLayout Strict;
    public static SecurityHeaderLayout Lax;
    public static SecurityHeaderLayout LaxTimestampFirst;
    public static SecurityHeaderLayout LaxTimestampLast;
}
internal static class System.ServiceModel.Channels.SecurityHeaderLayoutHelper : object {
    public static bool IsDefined(SecurityHeaderLayout value);
    public static void Validate(SecurityHeaderLayout value);
}
internal static class System.ServiceModel.Channels.SecurityStandardsHelper : object {
    private static SecurityStandardsHelper();
    public static SecurityStandardsManager CreateStandardsManager(TransactionProtocol transactionProtocol);
}
internal class System.ServiceModel.Channels.SegmentHierarchyNode`1 : object {
    public TData Data { get; }
    public SegmentHierarchyNode`1(string name, bool useWeakReferences);
    public TData get_Data();
    public void SetData(TData data, BaseUriWithWildcard path);
    public void SetChildNode(string name, SegmentHierarchyNode`1<TData> node);
    public void Collect(List`1<KeyValuePair`2<BaseUriWithWildcard, TData>> result);
    public bool TryGetChild(string segment, SegmentHierarchyNode`1& value);
    public void RemoveData();
    public bool RemovePath(String[] path, int seg);
}
internal class System.ServiceModel.Channels.SelectTransportManagersCallback : MulticastDelegate {
    public SelectTransportManagersCallback(object object, IntPtr method);
    public virtual IList`1<TransportManager> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IList`1<TransportManager> EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.SelfSignedCertificate : object {
    public static SelfSignedCertificate Create(string name, string password);
    public static SelfSignedCertificate Create(string name, string password, DateTime start, DateTime expire, string containerName);
    public X509Certificate2 GetX509Certificate();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Channels.SendFaultHelper : TypedFaultHelper`1<Message> {
    public SendFaultHelper(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    protected virtual void AbortState(Message message, bool isOnAbortThread);
    protected virtual IAsyncResult BeginSendFault(IReliableChannelBinder binder, Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndSendFault(IReliableChannelBinder binder, Message message, IAsyncResult result);
    protected virtual Message GetState(RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.SendHandler : MulticastDelegate {
    public SendHandler(object object, IntPtr method);
    public virtual void Invoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException);
    public virtual IAsyncResult BeginInvoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.SendReceiveReliableRequestor : ReliableRequestor {
    unknown bool TimeoutIsSafe {public set; }
    public void set_TimeoutIsSafe(bool value);
    public virtual WsrmMessageInfo GetInfo();
    protected virtual Message OnRequest(Message request, TimeSpan timeout, bool last);
    protected virtual IAsyncResult OnBeginRequest(Message request, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual Message OnEndRequest(bool last, IAsyncResult result);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.SendWaitReliableRequestor : ReliableRequestor {
    public virtual void Fault(CommunicationObject communicationObject);
    public virtual WsrmMessageInfo GetInfo();
    protected virtual Message OnRequest(Message request, TimeSpan timeout, bool last);
    protected virtual IAsyncResult OnBeginRequest(Message request, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual Message OnEndRequest(bool last, IAsyncResult result);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.SequenceClosedFault : WsrmHeaderFault {
    public SequenceClosedFault(UniqueId sequenceID);
    public SequenceClosedFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
}
internal class System.ServiceModel.Channels.SequenceRange : ValueType {
    private long lower;
    private long upper;
    public long Lower { get; }
    public long Upper { get; }
    public SequenceRange(long number);
    public SequenceRange(long lower, long upper);
    public long get_Lower();
    public long get_Upper();
    public static bool op_Equality(SequenceRange a, SequenceRange b);
    public static bool op_Inequality(SequenceRange a, SequenceRange b);
    public bool Contains(long number);
    public bool Contains(SequenceRange range);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.Channels.SequenceRangeCollection : object {
    public SequenceRange Item { get; }
    public int Count { get; }
    public static SequenceRangeCollection Empty { get; }
    private static SequenceRangeCollection();
    public abstract virtual SequenceRange get_Item(int index);
    public abstract virtual int get_Count();
    public static SequenceRangeCollection get_Empty();
    public abstract virtual bool Contains(long number);
    public abstract virtual SequenceRangeCollection MergeWith(long number);
    public abstract virtual SequenceRangeCollection MergeWith(SequenceRange range);
    public virtual string ToString();
}
internal class System.ServiceModel.Channels.SequenceTerminatedFault : WsrmHeaderFault {
    public SequenceTerminatedFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    public static WsrmFault CreateCommunicationFault(UniqueId sequenceID, string faultReason, string exceptionMessage);
    public static WsrmFault CreateMaxRetryCountExceededFault(UniqueId sequenceId);
    public static WsrmFault CreateProtocolFault(UniqueId sequenceID, string faultReason, string exceptionMessage);
    public static WsrmFault CreateQuotaExceededFault(UniqueId sequenceID);
}
internal class System.ServiceModel.Channels.ServerModeDecoder : FramingDecoder {
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public FramingMode Mode { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int Decode(Byte[] bytes, int offset, int size);
    public void Reset();
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public FramingMode get_Mode();
    public int get_MajorVersion();
    public int get_MinorVersion();
}
internal abstract class System.ServiceModel.Channels.ServerReliableChannelBinder`1 : ReliableChannelBinder`1<TChannel> {
    protected bool CanGetChannelForReceive { get; }
    public EndpointAddress LocalAddress { get; }
    protected bool MustCloseChannel { get; }
    protected bool MustOpenChannel { get; }
    public EndpointAddress RemoteAddress { get; }
    protected ServerReliableChannelBinder`1(ChannelBuilder builder, EndpointAddress remoteAddress, MessageFilter filter, int priority, MaskingMode maskingMode, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected ServerReliableChannelBinder`1(TChannel channel, EndpointAddress cachedLocalAddress, EndpointAddress remoteAddress, MaskingMode maskingMode, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    private static ServerReliableChannelBinder`1();
    protected virtual bool get_CanGetChannelForReceive();
    public virtual EndpointAddress get_LocalAddress();
    protected virtual bool get_MustCloseChannel();
    protected virtual bool get_MustOpenChannel();
    public virtual EndpointAddress get_RemoteAddress();
    protected virtual void AddOutputHeaders(Message message);
    public sealed virtual bool AddressResponse(Message request, Message response);
    protected virtual IAsyncResult BeginTryGetChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public static IServerReliableChannelBinder CreateBinder(ChannelBuilder builder, EndpointAddress remoteAddress, MessageFilter filter, int priority, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public static IServerReliableChannelBinder CreateBinder(TChannel channel, EndpointAddress cachedLocalAddress, EndpointAddress remoteAddress, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected virtual bool EndTryGetChannel(IAsyncResult result);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
    protected abstract virtual EndpointAddress GetInnerChannelLocalAddress();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult OnBeginWaitForRequest(TChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnShutdown();
    protected abstract virtual bool OnWaitForRequest(TChannel channel, TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected abstract virtual bool OnEndWaitForRequest(TChannel channel, IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual bool TryGetChannel(TimeSpan timeout);
    public sealed virtual bool UseNewChannel(IChannel channel);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ServerReliableDuplexSessionChannel : ReliableDuplexSessionChannel {
    public ServerReliableDuplexSessionChannel(ReliableChannelListenerBase`1<IDuplexSessionChannel> listener, IReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID, UniqueId outputID);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnMessageDropped();
    public void ProcessDemuxedMessage(WsrmMessageInfo info);
    protected virtual void ProcessMessage(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ServerReliableSession : ChannelReliableSession {
    public UniqueId SequenceID { get; }
    public ServerReliableSession(ChannelBase channel, IReliableFactorySettings listener, IServerReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID, UniqueId outputID);
    public virtual UniqueId get_SequenceID();
    public virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndOpen(IAsyncResult result);
    public virtual void OnLocalActivity();
    public virtual void Open(TimeSpan timeout);
    protected virtual WsrmFault VerifyDuplexProtocolElements(WsrmMessageInfo info);
    protected virtual WsrmFault VerifySimplexProtocolElements(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ServerSessionDecoder : FramingDecoder {
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public string ContentType { get; }
    public Uri Via { get; }
    public string Upgrade { get; }
    public int EnvelopeSize { get; }
    public ServerSessionDecoder(long streamPosition, int maxViaLength, int maxContentTypeLength);
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public string get_ContentType();
    public Uri get_Via();
    public void Reset(long streamPosition);
    public string get_Upgrade();
    public int get_EnvelopeSize();
    public int Decode(Byte[] bytes, int offset, int size);
}
internal abstract class System.ServiceModel.Channels.ServerSessionEncoder : SessionEncoder {
    public static Byte[] AckResponseBytes;
    public static Byte[] UpgradeResponseBytes;
    private static ServerSessionEncoder();
}
internal class System.ServiceModel.Channels.ServerSessionPreambleCallback : MulticastDelegate {
    public ServerSessionPreambleCallback(object object, IntPtr method);
    public virtual void Invoke(ServerSessionPreambleConnectionReader serverSessionPreambleReader);
    public virtual IAsyncResult BeginInvoke(ServerSessionPreambleConnectionReader serverSessionPreambleReader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ServerSessionPreambleConnectionReader : InitialServerConnectionReader {
    public int BufferOffset { get; }
    public int BufferSize { get; }
    public ServerSessionDecoder Decoder { get; }
    public IConnection RawConnection { get; }
    public Uri Via { get; }
    public ServerSessionPreambleConnectionReader(IConnection connection, Action connectionDequeuedCallback, long streamPosition, int offset, int size, TransportSettingsCallback transportSettingsCallback, ConnectionClosedCallback closedCallback, ServerSessionPreambleCallback callback);
    public int get_BufferOffset();
    public int get_BufferSize();
    public ServerSessionDecoder get_Decoder();
    public IConnection get_RawConnection();
    public Uri get_Via();
    public void SendFault(string faultString);
    public void StartReading(Action`1<Uri> viaDelegate, TimeSpan receiveTimeout);
    public IDuplexSessionChannel CreateDuplexSessionChannel(ConnectionOrientedTransportChannelListener channelListener, EndpointAddress localAddress, bool exposeConnectionProperty, ConnectionDemuxer connectionDemuxer);
}
internal class System.ServiceModel.Channels.ServerSessionPreambleDemuxCallback : MulticastDelegate {
    public ServerSessionPreambleDemuxCallback(object object, IntPtr method);
    public virtual void Invoke(ServerSessionPreambleConnectionReader serverSessionPreambleReader, ConnectionDemuxer connectionDemuxer);
    public virtual IAsyncResult BeginInvoke(ServerSessionPreambleConnectionReader serverSessionPreambleReader, ConnectionDemuxer connectionDemuxer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ServerSingletonConnectionReader : SingletonConnectionReader {
    protected string ContentType { get; }
    protected long StreamPosition { get; }
    public ServerSingletonConnectionReader(ServerSingletonPreambleConnectionReader preambleReader, IConnection upgradedConnection, ConnectionDemuxer connectionDemuxer);
    protected virtual string get_ContentType();
    protected virtual long get_StreamPosition();
    protected virtual bool DecodeBytes(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEof);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void PrepareMessage(Message message);
}
internal class System.ServiceModel.Channels.ServerSingletonDecoder : FramingDecoder {
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public Uri Via { get; }
    public string ContentType { get; }
    public string Upgrade { get; }
    public ServerSingletonDecoder(long streamPosition, int maxViaLength, int maxContentTypeLength);
    public void Reset();
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public Uri get_Via();
    public string get_ContentType();
    public string get_Upgrade();
    public int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.ServerSingletonEncoder : SingletonEncoder {
    public static Byte[] AckResponseBytes;
    public static Byte[] UpgradeResponseBytes;
    private static ServerSingletonEncoder();
}
internal class System.ServiceModel.Channels.ServerSingletonPreambleCallback : MulticastDelegate {
    public ServerSingletonPreambleCallback(object object, IntPtr method);
    public virtual void Invoke(ServerSingletonPreambleConnectionReader serverSingletonPreambleReader);
    public virtual IAsyncResult BeginInvoke(ServerSingletonPreambleConnectionReader serverSingletonPreambleReader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ServerSingletonPreambleConnectionReader : InitialServerConnectionReader {
    public ChannelBinding ChannelBinding { get; }
    public int BufferOffset { get; }
    public int BufferSize { get; }
    public ServerSingletonDecoder Decoder { get; }
    public IConnection RawConnection { get; }
    public Uri Via { get; }
    public IConnectionOrientedTransportFactorySettings TransportSettings { get; }
    public SecurityMessageProperty Security { get; }
    public ServerSingletonPreambleConnectionReader(IConnection connection, Action connectionDequeuedCallback, long streamPosition, int offset, int size, TransportSettingsCallback transportSettingsCallback, ConnectionClosedCallback closedCallback, ServerSingletonPreambleCallback callback);
    public ChannelBinding get_ChannelBinding();
    public int get_BufferOffset();
    public int get_BufferSize();
    public ServerSingletonDecoder get_Decoder();
    public IConnection get_RawConnection();
    public Uri get_Via();
    public IConnectionOrientedTransportFactorySettings get_TransportSettings();
    public SecurityMessageProperty get_Security();
    public void SendFault(string faultString);
    public IAsyncResult BeginCompletePreamble(TimeSpan timeout, AsyncCallback callback, object state);
    public IConnection EndCompletePreamble(IAsyncResult result);
    public void StartReading(Action`1<Uri> viaDelegate, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ServerSingletonSizedDecoder : FramingDecoder {
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public Uri Via { get; }
    public string ContentType { get; }
    public ServerSingletonSizedDecoder(long streamPosition, int maxViaLength, int maxContentTypeLength);
    public int Decode(Byte[] bytes, int offset, int size);
    public void Reset(long streamPosition);
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public Uri get_Via();
    public string get_ContentType();
}
internal class System.ServiceModel.Channels.ServerWebSocketTransportDuplexSessionChannel : WebSocketTransportDuplexSessionChannel {
    protected bool IsStreamedOutput { get; }
    public ServerWebSocketTransportDuplexSessionChannel(HttpChannelListener channelListener, EndpointAddress localAddress, Uri localVia, ConnectionBufferPool bufferPool, HttpRequestContext httpRequestContext, HttpPipeline httpPipeline, HttpResponseMessage httpResponseMessage, string subProtocol);
    protected virtual bool get_IsStreamedOutput();
    public virtual T GetProperty();
    internal void SetWebSocketInfo(WebSocketContext webSocketContext, RemoteEndpointMessageProperty remoteEndpointMessageProperty, SecurityMessageProperty handshakeSecurityMessageProperty, Byte[] innerBuffer, bool shouldDisposeWebSocketAfterClosed, HttpRequestMessage requestMessage);
    protected virtual void OnClosed();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
}
internal class System.ServiceModel.Channels.ServiceChannel : CommunicationObject {
    internal EventTraceActivity EventActivity { get; }
    internal bool CloseFactory { get; internal set; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal DispatchRuntime DispatchRuntime { get; }
    internal MessageVersion MessageVersion { get; }
    internal IChannelBinder Binder { get; }
    internal TimeSpan CloseTimeout { get; }
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal EndpointDispatcher EndpointDispatcher { get; internal set; }
    internal ServiceChannelFactory Factory { get; }
    internal IChannel InnerChannel { get; }
    internal bool IsPending { get; internal set; }
    internal bool HasSession { get; }
    internal bool IsClient { get; }
    internal bool IsReplyChannel { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    internal TimeSpan OpenTimeout { get; }
    public TimeSpan OperationTimeout { get; public set; }
    internal object Proxy { get; internal set; }
    internal ClientRuntime ClientRuntime { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    internal InstanceContext InstanceContext { get; internal set; }
    internal ServiceThrottle InstanceContextServiceThrottle { get; internal set; }
    internal ServiceThrottle ServiceThrottle { get; internal set; }
    internal InstanceContext WmiInstanceContext { get; internal set; }
    private bool System.ServiceModel.IDuplexContextChannel.AutomaticInputSessionShutdown { get; private set; }
    private bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; private set; }
    private bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; private set; }
    private bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
    private IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
    private InstanceContext System.ServiceModel.IDuplexContextChannel.CallbackInstance { get; private set; }
    private IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
    private IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
    private string System.ServiceModel.IContextChannel.SessionId { get; }
    internal ServiceChannel(ServiceChannelFactory factory, IChannelBinder binder);
    internal ServiceChannel(IChannelBinder binder, EndpointDispatcher endpointDispatcher, ChannelDispatcher channelDispatcher, SessionIdleManager idleManager);
    internal EventTraceActivity get_EventActivity();
    internal bool get_CloseFactory();
    internal void set_CloseFactory(bool value);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal DispatchRuntime get_DispatchRuntime();
    internal MessageVersion get_MessageVersion();
    internal IChannelBinder get_Binder();
    internal TimeSpan get_CloseTimeout();
    internal ChannelDispatcher get_ChannelDispatcher();
    internal EndpointDispatcher get_EndpointDispatcher();
    internal void set_EndpointDispatcher(EndpointDispatcher value);
    internal ServiceChannelFactory get_Factory();
    internal IChannel get_InnerChannel();
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_HasSession();
    internal bool get_IsClient();
    internal bool get_IsReplyChannel();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    internal TimeSpan get_OpenTimeout();
    public sealed virtual TimeSpan get_OperationTimeout();
    public sealed virtual void set_OperationTimeout(TimeSpan value);
    internal object get_Proxy();
    internal void set_Proxy(object value);
    internal ClientRuntime get_ClientRuntime();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    internal InstanceContext get_InstanceContext();
    internal void set_InstanceContext(InstanceContext value);
    internal ServiceThrottle get_InstanceContextServiceThrottle();
    internal void set_InstanceContextServiceThrottle(ServiceThrottle value);
    internal ServiceThrottle get_ServiceThrottle();
    internal void set_ServiceThrottle(ServiceThrottle value);
    internal InstanceContext get_WmiInstanceContext();
    internal void set_WmiInstanceContext(InstanceContext value);
    internal bool CanCastTo(Type t);
    internal void CompletedIOOperation();
    public sealed virtual T GetProperty();
    internal static IAsyncResult BeginCall(ServiceChannel channel, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, TimeSpan timeout, AsyncCallback callback, object asyncState);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs, TimeSpan timeout);
    internal object EndCall(string action, Object[] outs, IAsyncResult result);
    internal void DecrementActivity();
    internal void FireUnknownMessageReceived(Message message);
    internal void HandleReceiveComplete(RequestContext context);
    internal void IncrementActivity();
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    private sealed virtual override bool System.ServiceModel.IDuplexContextChannel.get_AutomaticInputSessionShutdown();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_AutomaticInputSessionShutdown(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_AllowInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.set_AllowInitializationUI(bool value);
    private sealed virtual override bool System.ServiceModel.IContextChannel.get_AllowOutputBatching();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_AllowOutputBatching(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_DidInteractiveInitialization();
    private sealed virtual override IAsyncResult System.ServiceModel.IDuplexContextChannel.BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.EndCloseOutputSession(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.CloseOutputSession(TimeSpan timeout);
    private sealed virtual override IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.get_Extensions();
    private sealed virtual override InstanceContext System.ServiceModel.IDuplexContextChannel.get_CallbackInstance();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_CallbackInstance(InstanceContext value);
    private sealed virtual override IInputSession System.ServiceModel.IContextChannel.get_InputSession();
    private sealed virtual override IOutputSession System.ServiceModel.IContextChannel.get_OutputSession();
    private sealed virtual override string System.ServiceModel.IContextChannel.get_SessionId();
    private sealed virtual override void System.ServiceModel.IClientChannel.add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override void System.ServiceModel.IClientChannel.remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public sealed virtual void DisplayInitializationUI();
    public sealed virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public sealed virtual void EndDisplayInitializationUI(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal abstract class System.ServiceModel.Channels.ServiceChannelFactory : ChannelFactoryBase {
    public ClientRuntime ClientRuntime { get; }
    internal RequestReplyCorrelator RequestReplyCorrelator { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    public MessageVersion MessageVersion { get; }
    public ServiceChannelFactory(ClientRuntime clientRuntime, Binding binding);
    public ClientRuntime get_ClientRuntime();
    internal RequestReplyCorrelator get_RequestReplyCorrelator();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public MessageVersion get_MessageVersion();
    public static ServiceChannelFactory BuildChannelFactory(ChannelBuilder channelBuilder, ClientRuntime clientRuntime);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint, bool useActiveAutoClose);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpened();
    public void ChannelCreated(IChannel channel);
    public void ChannelDisposed(IChannel channel);
    public virtual ServiceChannel CreateServiceChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel(EndpointAddress address);
    public TChannel CreateChannel(EndpointAddress address, Uri via);
    public abstract virtual bool CanCreateChannel();
    public object CreateChannel(Type channelType, EndpointAddress address);
    public object CreateChannel(Type channelType, EndpointAddress address, Uri via);
    [SecuritySafeCriticalAttribute]
internal static object CreateProxy(Type interfaceType, Type proxiedType, MessageDirection direction, ServiceChannel serviceChannel);
    [SecuritySafeCriticalAttribute]
internal static ServiceChannel GetServiceChannel(object transparentProxy);
    protected abstract virtual IChannelBinder CreateInnerChannelBinder(EndpointAddress address, Uri via);
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Channels.ServiceChannelProxy : RealProxy {
    private string System.Runtime.Remoting.IRemotingTypeInfo.TypeName { get; private set; }
    internal ServiceChannelProxy(Type interfaceType, Type proxiedType, MessageDirection direction, ServiceChannel serviceChannel);
    internal ServiceChannel GetServiceChannel();
    public virtual IMessage Invoke(IMessage message);
    private sealed virtual override bool System.Runtime.Remoting.IRemotingTypeInfo.CanCastTo(Type toType, object o);
    private sealed virtual override string System.Runtime.Remoting.IRemotingTypeInfo.get_TypeName();
    private sealed virtual override void System.Runtime.Remoting.IRemotingTypeInfo.set_TypeName(string value);
}
internal class System.ServiceModel.Channels.ServiceContextProtocol : ContextProtocol {
    public ServiceContextProtocol(ContextExchangeMechanism contextExchangeMechanism);
    public virtual void OnIncomingMessage(Message message);
    public virtual void OnOutgoingMessage(Message message, RequestContext requestContext);
}
internal class System.ServiceModel.Channels.ServiceWebSocketContext : WebSocketContext {
    public CookieCollection CookieCollection { get; }
    public NameValueCollection Headers { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public Uri RequestUri { get; }
    public string SecWebSocketKey { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public IPrincipal User { get; }
    public WebSocket WebSocket { get; }
    public ServiceWebSocketContext(WebSocketContext context, IPrincipal user);
    public virtual CookieCollection get_CookieCollection();
    public virtual NameValueCollection get_Headers();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual Uri get_RequestUri();
    public virtual string get_SecWebSocketKey();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual IPrincipal get_User();
    public virtual WebSocket get_WebSocket();
}
internal abstract class System.ServiceModel.Channels.SessionChannelDemuxer`2 : TypedChannelDemuxer {
    protected object ThisLock { get; }
    protected IChannelDemuxFailureHandler DemuxFailureHandler { get; }
    public SessionChannelDemuxer`2(BindingContext context, TimeSpan peekTimeout, int maxPendingSessions);
    private static SessionChannelDemuxer`2();
    protected object get_ThisLock();
    protected IChannelDemuxFailureHandler get_DemuxFailureHandler();
    protected abstract virtual void AbortItem(TInnerItem item);
    protected abstract virtual IAsyncResult BeginReceive(TInnerChannel channel, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult BeginReceive(TInnerChannel channel, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual TInnerChannel CreateChannel(ChannelManagerBase channelManager, TInnerChannel innerChannel, TInnerItem firstItem);
    protected abstract virtual void EndpointNotFound(TInnerChannel channel, TInnerItem item);
    protected abstract virtual TInnerItem EndReceive(TInnerChannel channel, IAsyncResult result);
    protected abstract virtual Message GetMessage(TInnerItem item);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(ChannelDemuxerFilter filter);
    public sealed virtual void OnOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout);
    public sealed virtual IAsyncResult OnBeginOuterListenerOpen(ChannelDemuxerFilter filter, IChannelListener listener, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnEndOuterListenerOpen(IAsyncResult result);
    public sealed virtual void OnOuterListenerAbort(ChannelDemuxerFilter filter);
    public sealed virtual void OnOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout);
    public sealed virtual IAsyncResult OnBeginOuterListenerClose(ChannelDemuxerFilter filter, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnEndOuterListenerClose(IAsyncResult result);
    protected void HandleUnknownException(Exception exception);
}
internal abstract class System.ServiceModel.Channels.SessionConnectionReader : object {
    protected Byte[] EnvelopeBuffer { get; protected set; }
    protected int EnvelopeOffset { get; protected set; }
    protected int EnvelopeSize { get; protected set; }
    protected SessionConnectionReader(IConnection connection, IConnection rawConnection, int offset, int size, SecurityMessageProperty security);
    protected abstract virtual Message DecodeMessage(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEof, TimeSpan timeout);
    protected Byte[] get_EnvelopeBuffer();
    protected void set_EnvelopeBuffer(Byte[] value);
    protected int get_EnvelopeOffset();
    protected void set_EnvelopeOffset(int value);
    protected int get_EnvelopeSize();
    protected void set_EnvelopeSize(int value);
    public IConnection GetRawConnection();
    public sealed virtual AsyncReceiveResult BeginReceive(TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual Message EndReceive();
    public sealed virtual AsyncReceiveResult BeginWaitForMessage(TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual bool EndWaitForMessage();
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    protected abstract virtual void EnsureDecoderAtEof();
    protected virtual void PrepareMessage(Message message);
    protected void SendFault(string faultString, TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.SessionEncoder : object {
    public static int MaxMessageFrameSize;
    public static Byte[] PreambleEndBytes;
    public static Byte[] EndBytes;
    private static SessionEncoder();
    public static int CalcStartSize(EncodedVia via, EncodedContentType contentType);
    public static void EncodeStart(Byte[] buffer, int offset, EncodedVia via, EncodedContentType contentType);
    public static ArraySegment`1<byte> EncodeMessageFrame(ArraySegment`1<byte> messageFrame);
}
public abstract class System.ServiceModel.Channels.SessionOpenNotification : object {
    public bool IsEnabled { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual void UpdateMessageProperties(MessageProperties inboundMessageProperties);
}
internal class System.ServiceModel.Channels.SharedConnectionListener : object {
    internal SharedConnectionListener(BaseUriWithWildcard baseAddress, int queueId, Guid token, Func`2<Uri, int> onDuplicatedViaCallback);
    private static SharedConnectionListener();
    private sealed virtual override void System.ServiceModel.Channels.IConnectionListener.Listen();
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IConnectionListener.BeginAccept(AsyncCallback callback, object state);
    public void Stop(TimeSpan timeout);
    public void Stop(bool aborting, TimeSpan timeout);
    public void Abort();
    private sealed virtual override IConnection System.ServiceModel.Channels.IConnectionListener.EndAccept(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ServiceModel.Channels.SharedHttpsTransportManager : SharedHttpTransportManager {
    internal string Scheme { get; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    public SharedHttpsTransportManager(Uri listenUri, HttpChannelListener factory);
    private static SharedHttpsTransportManager();
    internal virtual string get_Scheme();
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
}
internal class System.ServiceModel.Channels.SharedHttpTransportManager : HttpTransportManager {
    internal SharedHttpTransportManager(Uri listenUri, HttpChannelListener channelListener);
    internal virtual bool IsCompatible(HttpChannelListener channelListener);
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
    internal virtual void OnOpen();
}
internal class System.ServiceModel.Channels.SharedTcpTransportManager : TcpTransportManager {
    public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    public Uri ListenUri { get; }
    public SharedTcpTransportManager(Uri listenUri, TcpChannelListener channelListener);
    protected SharedTcpTransportManager(Uri listenUri);
    protected virtual bool IsCompatible(TcpChannelListener channelListener);
    public sealed virtual HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public sealed virtual Uri get_ListenUri();
    internal virtual void OnOpen();
    protected virtual Action`1<Uri> GetOnViaCallback();
    internal void OnOpenInternal(int queueId, Guid token);
    protected void CleanUp(bool aborting, TimeSpan timeout);
    internal virtual void OnAbort();
    internal virtual void OnClose(TimeSpan timeout);
    protected virtual void OnSelecting(TcpChannelListener channelListener);
    private sealed virtual override IList`1<TransportManager> System.ServiceModel.Channels.ITransportManagerRegistration.Select(TransportChannelListener channelListener);
}
internal class System.ServiceModel.Channels.SimplePostRollbackErrorStrategy : object {
    internal SimplePostRollbackErrorStrategy(long lookupId);
    public sealed virtual bool AnotherTryNeeded();
}
internal abstract class System.ServiceModel.Channels.SingletonChannelAcceptor`3 : InputQueueChannelAcceptor`1<ChannelInterfaceType> {
    public SingletonChannelAcceptor`3(ChannelManagerBase channelManager);
    public virtual ChannelInterfaceType AcceptChannel(TimeSpan timeout);
    public virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected TChannel GetCurrentChannel();
    protected abstract virtual TChannel OnCreateChannel();
    protected abstract virtual void OnTraceMessageReceived(QueueItemType item);
    public void DispatchItems();
    public void Enqueue(QueueItemType item);
    public void Enqueue(QueueItemType item, Action dequeuedCallback);
    public void Enqueue(QueueItemType item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void Enqueue(Exception exception, Action dequeuedCallback);
    public void Enqueue(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public bool EnqueueWithoutDispatch(QueueItemType item, Action dequeuedCallback);
    public virtual bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public void EnqueueAndDispatch(QueueItemType item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public virtual void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    protected void OnChannelClosed(object sender, EventArgs args);
}
internal class System.ServiceModel.Channels.SingletonChannelListener`3 : DelegatingChannelListener`1<TChannel> {
    public ChannelDemuxerFilter Filter { get; }
    public SingletonChannelListener`3(ChannelDemuxerFilter filter, IChannelDemuxer channelDemuxer);
    public sealed virtual ChannelDemuxerFilter get_Filter();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    public void Dispatch();
    public void EnqueueAndDispatch(TQueuedItem item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
}
internal abstract class System.ServiceModel.Channels.SingletonConnectionReader : object {
    protected IConnection Connection { get; }
    protected object ThisLock { get; }
    protected string ContentType { get; }
    protected long StreamPosition { get; }
    protected SingletonConnectionReader(IConnection connection, int offset, int size, SecurityMessageProperty security, IConnectionOrientedTransportFactorySettings transportSettings, Uri via);
    protected IConnection get_Connection();
    protected object get_ThisLock();
    protected virtual string get_ContentType();
    protected abstract virtual long get_StreamPosition();
    public void Abort();
    public void DoneReceiving(bool atEof);
    public void Close(TimeSpan timeout);
    protected abstract virtual void OnClose(TimeSpan timeout);
    public void DoneSending(TimeSpan timeout);
    protected abstract virtual bool DecodeBytes(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEof);
    protected virtual void PrepareMessage(Message message);
    public RequestContext ReceiveRequest(TimeSpan timeout);
    public IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual Message EndReceive(IAsyncResult result);
    public Message Receive(TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.SingletonEncoder : object {
    public static Byte[] EnvelopeStartBytes;
    public static Byte[] EnvelopeEndBytes;
    public static Byte[] EnvelopeEndFramingEndBytes;
    public static Byte[] EndBytes;
    private static SingletonEncoder();
    public static ArraySegment`1<byte> EncodeMessageFrame(ArraySegment`1<byte> messageFrame);
}
internal class System.ServiceModel.Channels.SingletonMessageDecoder : FramingDecoder {
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public int ChunkSize { get; }
    public SingletonMessageDecoder(long streamPosition);
    public void Reset();
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public int get_ChunkSize();
    public int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.SingletonPreambleDemuxCallback : MulticastDelegate {
    public SingletonPreambleDemuxCallback(object object, IntPtr method);
    public virtual ISingletonChannelListener Invoke(ServerSingletonPreambleConnectionReader serverSingletonPreambleReader);
    public virtual IAsyncResult BeginInvoke(ServerSingletonPreambleConnectionReader serverSingletonPreambleReader, AsyncCallback callback, object object);
    public virtual ISingletonChannelListener EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.sockaddr_in6 : ValueType {
    private short sin6_family;
    private ushort sin6_port;
    private UInt32 sin6_flowinfo;
    private Byte[] sin6_addr;
    private UInt32 sin6_scope_id;
    private static int addrByteCount;
    private static int v4MapIndex;
    private static int v4Index;
    public short Family { get; }
    public UInt32 FlowInfo { get; }
    public ushort Port { get; }
    public sockaddr_in6(IPAddress address);
    public short get_Family();
    public UInt32 get_FlowInfo();
    public ushort get_Port();
    public IPAddress ToIPAddress();
}
internal class System.ServiceModel.Channels.SocketAddress : ValueType {
    private IntPtr sockAddr;
    private int sockAddrLength;
    public IntPtr SockAddr { get; }
    public int SockAddrLength { get; }
    public IntPtr get_SockAddr();
    public int get_SockAddrLength();
    public void InitializeFromCriticalAllocHandleSocketAddress(CriticalAllocHandleSocketAddress sockAddr);
}
internal class System.ServiceModel.Channels.SocketAddressList : ValueType {
    private int count;
    internal static int maxAddresses;
    private SocketAddress[] addresses;
    public SocketAddress[] Addresses { get; }
    public int Count { get; }
    public SocketAddressList(SocketAddress[] addresses, int count);
    public SocketAddress[] get_Addresses();
    public int get_Count();
    public static ReadOnlyCollection`1<IPAddress> SortAddresses(Socket socket, IPAddress listenAddress, ReadOnlyCollection`1<IPAddress> addresses);
}
internal class System.ServiceModel.Channels.SocketAsyncEventArgsPool : QueuedObjectPool`1<SocketAsyncEventArgs> {
    public SocketAsyncEventArgsPool(int acceptBufferSize);
    public virtual bool Return(SocketAsyncEventArgs socketAsyncEventArgs);
    internal static void CleanupAcceptSocket(SocketAsyncEventArgs socketAsyncEventArgs);
    protected virtual void CleanupItem(SocketAsyncEventArgs item);
    protected virtual SocketAsyncEventArgs Create();
}
internal class System.ServiceModel.Channels.SocketConnection : object {
    public int AsyncReadBufferSize { get; }
    public Byte[] AsyncReadBuffer { get; }
    public TraceEventType ExceptionEventType { get; public set; }
    public IPEndPoint RemoteIPEndPoint { get; }
    public SocketConnection(Socket socket, ConnectionBufferPool connectionBufferPool, bool autoBindToCompletionPort);
    private static SocketConnection();
    public sealed virtual int get_AsyncReadBufferSize();
    public sealed virtual Byte[] get_AsyncReadBuffer();
    public sealed virtual TraceEventType get_ExceptionEventType();
    public sealed virtual void set_ExceptionEventType(TraceEventType value);
    public sealed virtual IPEndPoint get_RemoteIPEndPoint();
    public sealed virtual void Abort();
    public sealed virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public void ContinueClose(TimeSpan timeout);
    public sealed virtual void Shutdown(TimeSpan timeout);
    public sealed virtual object DuplicateAndClose(int targetProcessId);
    public sealed virtual object GetCoreTransport();
    public sealed virtual IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public sealed virtual bool EndValidate(IAsyncResult result);
    internal static Exception ConvertTransferException(SocketException socketException, TimeSpan timeout, Exception originalException);
    public sealed virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual void EndWrite();
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public sealed virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual int EndRead();
}
internal class System.ServiceModel.Channels.SocketConnectionInitiator : object {
    public SocketConnectionInitiator(int bufferSize);
    public static Exception ConvertConnectException(SocketException socketException, Uri remoteUri, TimeSpan timeSpent, Exception innerException);
    public sealed virtual IConnection Connect(Uri uri, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginConnect(Uri uri, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IConnection EndConnect(IAsyncResult result);
    public static void TraceConnectFailure(Socket socket, SocketException socketException, Uri remoteUri, TimeSpan timeSpentInConnect);
}
internal class System.ServiceModel.Channels.SocketConnectionListener : object {
    public SocketConnectionListener(Socket listenSocket, ISocketListenerSettings settings, bool useOnlyOverlappedIO);
    public SocketConnectionListener(IPEndPoint localEndpoint, ISocketListenerSettings settings, bool useOnlyOverlappedIO);
    public sealed virtual IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public sealed virtual IConnection EndAccept(IAsyncResult result);
    public sealed virtual void Dispose();
    public sealed virtual void Listen();
    public static Exception ConvertListenException(SocketException socketException, IPEndPoint localEndpoint);
}
public class System.ServiceModel.Channels.SslStreamSecurityBindingElement : StreamUpgradeBindingElement {
    public IdentityVerifier IdentityVerifier { get; public set; }
    [DefaultValueAttribute("False")]
public bool RequireClientCertificate { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SslProtocols SslProtocols { get; public set; }
    protected SslStreamSecurityBindingElement(SslStreamSecurityBindingElement elementToBeCloned);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    public virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
    public virtual StreamUpgradeProvider BuildServerStreamUpgradeProvider(BindingContext context);
    internal static void ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    public sealed virtual XmlElement GetTransportTokenAssertion();
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeIdentityVerifier();
}
internal class System.ServiceModel.Channels.SslStreamSecurityUpgradeAcceptor : StreamSecurityUpgradeAcceptorBase {
    internal ChannelBinding ChannelBinding { get; }
    internal bool IsChannelBindingSupportEnabled { get; }
    public SslStreamSecurityUpgradeAcceptor(SslStreamSecurityUpgradeProvider parent);
    internal ChannelBinding get_ChannelBinding();
    internal bool get_IsChannelBindingSupportEnabled();
    protected virtual Stream OnAcceptUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
    protected virtual IAsyncResult OnBeginAcceptUpgrade(Stream stream, AsyncCallback callback, object state);
    protected virtual Stream OnEndAcceptUpgrade(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
    public virtual SecurityMessageProperty GetRemoteSecurity();
}
internal class System.ServiceModel.Channels.SslStreamSecurityUpgradeInitiator : StreamSecurityUpgradeInitiatorBase {
    internal ChannelBinding ChannelBinding { get; }
    internal bool IsChannelBindingSupportEnabled { get; }
    public SslStreamSecurityUpgradeInitiator(SslStreamSecurityUpgradeProvider parent, EndpointAddress remoteAddress, Uri via);
    internal ChannelBinding get_ChannelBinding();
    internal bool get_IsChannelBindingSupportEnabled();
    internal virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal virtual void EndOpen(IAsyncResult result);
    internal virtual void Open(TimeSpan timeout);
    internal virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal virtual void EndClose(IAsyncResult result);
    internal virtual void Close(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginInitiateUpgrade(Stream stream, AsyncCallback callback, object state);
    protected virtual Stream OnEndInitiateUpgrade(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
    protected virtual Stream OnInitiateUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
}
internal class System.ServiceModel.Channels.SslStreamSecurityUpgradeProvider : StreamSecurityUpgradeProvider {
    public EndpointIdentity Identity { get; }
    public IdentityVerifier IdentityVerifier { get; }
    public bool RequireClientCertificate { get; }
    public X509Certificate2 ServerCertificate { get; }
    public SecurityTokenAuthenticator ClientCertificateAuthenticator { get; }
    public SecurityTokenManager ClientSecurityTokenManager { get; }
    public string Scheme { get; }
    public SslProtocols SslProtocols { get; }
    private bool System.ServiceModel.Channels.IChannelBindingProvider.IsChannelBindingSupportEnabled { get; }
    public static SslStreamSecurityUpgradeProvider CreateClientProvider(SslStreamSecurityBindingElement bindingElement, BindingContext context);
    public static SslStreamSecurityUpgradeProvider CreateServerProvider(SslStreamSecurityBindingElement bindingElement, BindingContext context);
    public virtual EndpointIdentity get_Identity();
    public IdentityVerifier get_IdentityVerifier();
    public bool get_RequireClientCertificate();
    public X509Certificate2 get_ServerCertificate();
    public SecurityTokenAuthenticator get_ClientCertificateAuthenticator();
    public SecurityTokenManager get_ClientSecurityTokenManager();
    public string get_Scheme();
    public SslProtocols get_SslProtocols();
    public virtual T GetProperty();
    private sealed virtual override ChannelBinding System.ServiceModel.Channels.IStreamUpgradeChannelBindingProvider.GetChannelBinding(StreamUpgradeInitiator upgradeInitiator, ChannelBindingKind kind);
    private sealed virtual override ChannelBinding System.ServiceModel.Channels.IStreamUpgradeChannelBindingProvider.GetChannelBinding(StreamUpgradeAcceptor upgradeAcceptor, ChannelBindingKind kind);
    private sealed virtual override void System.ServiceModel.Channels.IChannelBindingProvider.EnableChannelBindingSupport();
    private sealed virtual override bool System.ServiceModel.Channels.IChannelBindingProvider.get_IsChannelBindingSupportEnabled();
    public virtual StreamUpgradeAcceptor CreateUpgradeAcceptor();
    public virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
}
public class System.ServiceModel.Channels.StandardBindingImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportContract(WsdlImporter importer, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext endpointContext);
}
internal static class System.ServiceModel.Channels.StateHelper : object {
    private static StateHelper();
    internal static void RegisterTransportBindingElement(MetadataImporter importer, XmlQualifiedName wsdlBindingQName);
    internal static void RegisterTransportBindingElement(MetadataImporter importer, WsdlEndpointConversionContext context);
    internal static bool IsRegisteredTransportBindingElement(WsdlImporter importer, WsdlEndpointConversionContext context);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.ServiceModel.Channels.StoreCertificateHandle : CertificateHandle {
}
internal class System.ServiceModel.Channels.StreamConnection : object {
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    public Stream Stream { get; }
    public object ThisLock { get; }
    public TraceEventType ExceptionEventType { get; public set; }
    public IPEndPoint RemoteIPEndPoint { get; }
    public StreamConnection(Stream stream, ConnectionStream innerStream);
    public sealed virtual Byte[] get_AsyncReadBuffer();
    public sealed virtual int get_AsyncReadBufferSize();
    public Stream get_Stream();
    public object get_ThisLock();
    public sealed virtual TraceEventType get_ExceptionEventType();
    public sealed virtual void set_ExceptionEventType(TraceEventType value);
    public sealed virtual IPEndPoint get_RemoteIPEndPoint();
    public sealed virtual void Abort();
    public sealed virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public sealed virtual void Shutdown(TimeSpan timeout);
    public sealed virtual object DuplicateAndClose(int targetProcessId);
    public virtual object GetCoreTransport();
    public sealed virtual IAsyncResult BeginValidate(Uri uri, AsyncCallback callback, object state);
    public sealed virtual bool EndValidate(IAsyncResult result);
    public sealed virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual void EndWrite();
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public sealed virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public sealed virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public sealed virtual int EndRead();
}
internal class System.ServiceModel.Channels.StreamedFramingRequestChannel : RequestChannel {
    public StreamedFramingRequestChannel(ChannelManagerBase factory, IConnectionOrientedTransportChannelFactorySettings settings, EndpointAddress remoteAddresss, Uri via, IConnectionInitiator connectionInitiator, ConnectionPool connectionPool);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual IAsyncRequest CreateAsyncRequest(Message message, AsyncCallback callback, object state);
    protected virtual IRequest CreateRequest(Message message);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.StreamedMessage : ReceivedMessage {
    public MessageHeaders Headers { get; }
    public MessageVersion Version { get; }
    public MessageProperties Properties { get; }
    public StreamedMessage(XmlDictionaryReader reader, int maxSizeOfHeaders, MessageVersion desiredVersion);
    public virtual MessageHeaders get_Headers();
    public virtual MessageVersion get_Version();
    public virtual MessageProperties get_Properties();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal static class System.ServiceModel.Channels.StreamingConnectionHelper : object {
    public static void WriteMessage(Message message, IConnection connection, bool isRequest, IConnectionOrientedTransportFactorySettings settings, TimeoutHelper& timeoutHelper);
    public static IAsyncResult BeginWriteMessage(Message message, IConnection connection, bool isRequest, IConnectionOrientedTransportFactorySettings settings, TimeoutHelper& timeoutHelper, AsyncCallback callback, object state);
    public static void EndWriteMessage(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.StreamSecurityUpgradeAcceptor : StreamUpgradeAcceptor {
    public abstract virtual SecurityMessageProperty GetRemoteSecurity();
}
internal abstract class System.ServiceModel.Channels.StreamSecurityUpgradeAcceptorAsyncResult : TraceAsyncResult {
    protected StreamSecurityUpgradeAcceptorAsyncResult(AsyncCallback callback, object state);
    private static StreamSecurityUpgradeAcceptorAsyncResult();
    public void Begin(Stream stream);
    public static Stream End(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
    protected abstract virtual IAsyncResult OnBegin(Stream stream, AsyncCallback callback);
    protected abstract virtual Stream OnCompleteAuthenticateAsServer(IAsyncResult result);
    protected abstract virtual SecurityMessageProperty ValidateCreateSecurity();
}
internal abstract class System.ServiceModel.Channels.StreamSecurityUpgradeAcceptorBase : StreamSecurityUpgradeAcceptor {
    internal EventTraceActivity EventTraceActivity { get; }
    protected StreamSecurityUpgradeAcceptorBase(string upgradeString);
    internal EventTraceActivity get_EventTraceActivity();
    public virtual Stream AcceptUpgrade(Stream stream);
    public virtual IAsyncResult BeginAcceptUpgrade(Stream stream, AsyncCallback callback, object state);
    public virtual bool CanUpgrade(string contentType);
    public virtual Stream EndAcceptUpgrade(IAsyncResult result);
    public virtual SecurityMessageProperty GetRemoteSecurity();
    protected abstract virtual Stream OnAcceptUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
    protected abstract virtual IAsyncResult OnBeginAcceptUpgrade(Stream stream, AsyncCallback callback, object state);
    protected abstract virtual Stream OnEndAcceptUpgrade(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
}
public abstract class System.ServiceModel.Channels.StreamSecurityUpgradeInitiator : StreamUpgradeInitiator {
    public abstract virtual SecurityMessageProperty GetRemoteSecurity();
    internal static SecurityMessageProperty GetRemoteSecurity(StreamUpgradeInitiator upgradeInitiator);
}
internal abstract class System.ServiceModel.Channels.StreamSecurityUpgradeInitiatorAsyncResult : AsyncResult {
    public StreamSecurityUpgradeInitiatorAsyncResult(AsyncCallback callback, object state);
    private static StreamSecurityUpgradeInitiatorAsyncResult();
    public void Begin(Stream stream);
    public static Stream End(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
    protected abstract virtual IAsyncResult OnBeginAuthenticateAsClient(Stream stream, AsyncCallback callback);
    protected abstract virtual Stream OnCompleteAuthenticateAsClient(IAsyncResult result);
    protected abstract virtual SecurityMessageProperty ValidateCreateSecurity();
}
internal abstract class System.ServiceModel.Channels.StreamSecurityUpgradeInitiatorBase : StreamSecurityUpgradeInitiator {
    protected EndpointAddress RemoteAddress { get; }
    protected Uri Via { get; }
    protected StreamSecurityUpgradeInitiatorBase(string upgradeString, EndpointAddress remoteAddress, Uri via);
    protected EndpointAddress get_RemoteAddress();
    protected Uri get_Via();
    public virtual IAsyncResult BeginInitiateUpgrade(Stream stream, AsyncCallback callback, object state);
    public virtual Stream EndInitiateUpgrade(IAsyncResult result);
    public virtual string GetNextUpgrade();
    public virtual SecurityMessageProperty GetRemoteSecurity();
    public virtual Stream InitiateUpgrade(Stream stream);
    internal virtual void EndOpen(IAsyncResult result);
    internal virtual void Open(TimeSpan timeout);
    internal virtual void EndClose(IAsyncResult result);
    internal virtual void Close(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginInitiateUpgrade(Stream stream, AsyncCallback callback, object state);
    protected abstract virtual Stream OnEndInitiateUpgrade(IAsyncResult result, SecurityMessageProperty& remoteSecurity);
    protected abstract virtual Stream OnInitiateUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
}
public abstract class System.ServiceModel.Channels.StreamSecurityUpgradeProvider : StreamUpgradeProvider {
    public EndpointIdentity Identity { get; }
    protected StreamSecurityUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
    public abstract virtual EndpointIdentity get_Identity();
}
public abstract class System.ServiceModel.Channels.StreamUpgradeAcceptor : object {
    public abstract virtual bool CanUpgrade(string contentType);
    public virtual Stream AcceptUpgrade(Stream stream);
    public abstract virtual IAsyncResult BeginAcceptUpgrade(Stream stream, AsyncCallback callback, object state);
    public abstract virtual Stream EndAcceptUpgrade(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.StreamUpgradeBindingElement : BindingElement {
    protected StreamUpgradeBindingElement(StreamUpgradeBindingElement elementToBeCloned);
    public abstract virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
    public abstract virtual StreamUpgradeProvider BuildServerStreamUpgradeProvider(BindingContext context);
}
public abstract class System.ServiceModel.Channels.StreamUpgradeInitiator : object {
    public abstract virtual string GetNextUpgrade();
    public abstract virtual Stream InitiateUpgrade(Stream stream);
    public abstract virtual IAsyncResult BeginInitiateUpgrade(Stream stream, AsyncCallback callback, object state);
    public abstract virtual Stream EndInitiateUpgrade(IAsyncResult result);
    internal virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal virtual void EndOpen(IAsyncResult result);
    internal virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal virtual void EndClose(IAsyncResult result);
    internal virtual void Open(TimeSpan timeout);
    internal virtual void Close(TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.StreamUpgradeProvider : CommunicationObject {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected StreamUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public virtual T GetProperty();
    public abstract virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
    public abstract virtual StreamUpgradeAcceptor CreateUpgradeAcceptor();
}
internal abstract class System.ServiceModel.Channels.StringDecoder : object {
    public bool IsValueDecoded { get; }
    public string Value { get; }
    public StringDecoder(int sizeQuota);
    public bool get_IsValueDecoded();
    public string get_Value();
    public int Decode(Byte[] buffer, int offset, int size);
    protected virtual void OnComplete(string value);
    protected abstract virtual Exception OnSizeQuotaExceeded(int size);
    public void Reset();
}
internal class System.ServiceModel.Channels.StringMessage : ContentOnlyMessage {
    public bool IsEmpty { get; }
    public StringMessage(string data);
    public virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public enum System.ServiceModel.Channels.SupportedAddressingMode : Enum {
    public int value__;
    public static SupportedAddressingMode Anonymous;
    public static SupportedAddressingMode NonAnonymous;
    public static SupportedAddressingMode Mixed;
}
internal static class System.ServiceModel.Channels.SupportedAddressingModeHelper : object {
    internal static bool IsDefined(SupportedAddressingMode value);
}
public class System.ServiceModel.Channels.SymmetricSecurityBindingElement : SecurityBindingElement {
    public bool RequireSignatureConfirmation { get; public set; }
    public MessageProtectionOrder MessageProtectionOrder { get; public set; }
    public SecurityTokenParameters ProtectionTokenParameters { get; public set; }
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    public SymmetricSecurityBindingElement(SecurityTokenParameters protectionTokenParameters);
    public bool get_RequireSignatureConfirmation();
    public void set_RequireSignatureConfirmation(bool value);
    public MessageProtectionOrder get_MessageProtectionOrder();
    public void set_MessageProtectionOrder(MessageProtectionOrder value);
    public SecurityTokenParameters get_ProtectionTokenParameters();
    public void set_ProtectionTokenParameters(SecurityTokenParameters value);
    internal virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    public virtual void SetKeyDerivation(bool requireDerivedKeys);
    internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys);
    internal virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext);
    internal virtual bool RequiresChannelDemuxer();
    protected virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    protected virtual IChannelListener`1<TChannel> BuildChannelListenerCore(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    public virtual string ToString();
    public virtual BindingElement Clone();
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
internal class System.ServiceModel.Channels.SyncCommunicationWaiter : object {
    public SyncCommunicationWaiter(object mutex);
    public sealed virtual void Dispose();
    public sealed virtual void Signal();
    public sealed virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal class System.ServiceModel.Channels.SynchronizedMessageSource : object {
    public SynchronizedMessageSource(IMessageSource source);
    public IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public bool EndWaitForMessage(IAsyncResult result);
    public bool WaitForMessage(TimeSpan timeout);
    public IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public Message EndReceive(IAsyncResult result);
    public Message Receive(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.SystemTime : ValueType {
    public short wYear;
    public short wMonth;
    public short wDayOfWeek;
    public short wDay;
    public short wHour;
    public short wMinute;
    public short wSecond;
    public short wMilliseconds;
    public SystemTime(DateTime date);
}
internal class System.ServiceModel.Channels.TcpChannelFactory`1 : ConnectionOrientedTransportChannelFactory`1<TChannel> {
    public TimeSpan LeaseTimeout { get; }
    public string Scheme { get; }
    public TcpChannelFactory`1(TcpTransportBindingElement bindingElement, BindingContext context);
    private static TcpChannelFactory`1();
    public sealed virtual TimeSpan get_LeaseTimeout();
    public virtual string get_Scheme();
    internal virtual IConnectionInitiator GetConnectionInitiator();
    internal virtual ConnectionPool GetConnectionPool();
    internal virtual void ReleaseConnectionPool(ConnectionPool pool, TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.TcpChannelListener : ConnectionOrientedTransportChannelListener {
    public bool PortSharingEnabled { get; }
    public bool TeredoEnabled { get; }
    public int ListenBacklog { get; }
    public string Scheme { get; }
    internal static UriPrefixTable`1<ITransportManagerRegistration> StaticTransportManagerTable { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    protected TcpChannelListener(TcpTransportBindingElement bindingElement, BindingContext context);
    private static TcpChannelListener();
    public bool get_PortSharingEnabled();
    public bool get_TeredoEnabled();
    public int get_ListenBacklog();
    public virtual T GetProperty();
    internal Socket GetListenSocket(UriHostNameType ipHostNameType);
    public virtual string get_Scheme();
    internal static UriPrefixTable`1<ITransportManagerRegistration> get_StaticTransportManagerTable();
    internal virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    internal static void FixIpv6Hostname(UriBuilder uriBuilder, Uri originalUri);
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration();
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
}
internal abstract class System.ServiceModel.Channels.TcpChannelListener`2 : TcpChannelListener {
    protected TChannelAcceptor ChannelAcceptor { get; }
    protected TcpChannelListener`2(TcpTransportBindingElement bindingElement, BindingContext context);
    protected abstract virtual TChannelAcceptor get_ChannelAcceptor();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnAbort();
    public sealed virtual TChannel AcceptChannel();
    public sealed virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public sealed virtual TChannel AcceptChannel(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual TChannel EndAcceptChannel(IAsyncResult result);
    protected virtual bool OnWaitForChannel(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual bool OnEndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Channels.TcpConnectionPoolRegistry : ConnectionPoolRegistry {
    protected virtual ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
}
public class System.ServiceModel.Channels.TcpConnectionPoolSettings : object {
    public string GroupName { get; public set; }
    public TimeSpan IdleTimeout { get; public set; }
    public TimeSpan LeaseTimeout { get; public set; }
    public int MaxOutboundConnectionsPerEndpoint { get; public set; }
    internal TcpConnectionPoolSettings(TcpConnectionPoolSettings tcp);
    public string get_GroupName();
    public void set_GroupName(string value);
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public TimeSpan get_LeaseTimeout();
    public void set_LeaseTimeout(TimeSpan value);
    public int get_MaxOutboundConnectionsPerEndpoint();
    public void set_MaxOutboundConnectionsPerEndpoint(int value);
    internal TcpConnectionPoolSettings Clone();
    internal bool IsMatch(TcpConnectionPoolSettings tcp);
}
internal class System.ServiceModel.Channels.TcpDuplexChannelListener : TcpChannelListener`2<IDuplexSessionChannel, InputQueueChannelAcceptor`1<IDuplexSessionChannel>> {
    protected InputQueueChannelAcceptor`1<IDuplexSessionChannel> ChannelAcceptor { get; }
    public TcpDuplexChannelListener(TcpTransportBindingElement bindingElement, BindingContext context);
    protected virtual InputQueueChannelAcceptor`1<IDuplexSessionChannel> get_ChannelAcceptor();
    private sealed virtual override void System.ServiceModel.Channels.ISessionPreambleHandler.HandleServerSessionPreamble(ServerSessionPreambleConnectionReader preambleReader, ConnectionDemuxer connectionDemuxer);
}
internal class System.ServiceModel.Channels.TcpReplyChannelListener : TcpChannelListener`2<IReplyChannel, ReplyChannelAcceptor> {
    protected ReplyChannelAcceptor ChannelAcceptor { get; }
    private TimeSpan System.ServiceModel.Channels.ISingletonChannelListener.ReceiveTimeout { get; }
    public TcpReplyChannelListener(TcpTransportBindingElement bindingElement, BindingContext context);
    protected virtual ReplyChannelAcceptor get_ChannelAcceptor();
    private sealed virtual override TimeSpan System.ServiceModel.Channels.ISingletonChannelListener.get_ReceiveTimeout();
    private sealed virtual override void System.ServiceModel.Channels.ISingletonChannelListener.ReceiveRequest(RequestContext requestContext, Action callback, bool canDispatchOnThisThread);
}
public class System.ServiceModel.Channels.TcpTransportBindingElement : ConnectionOrientedTransportBindingElement {
    public TcpConnectionPoolSettings ConnectionPoolSettings { get; }
    public int ListenBacklog { get; public set; }
    internal bool IsListenBacklogSet { get; }
    [DefaultValueAttribute("False")]
public bool PortSharingEnabled { get; public set; }
    public string Scheme { get; }
    [DefaultValueAttribute("False")]
public bool TeredoEnabled { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    internal string WsdlTransportUri { get; }
    protected TcpTransportBindingElement(TcpTransportBindingElement elementToBeCloned);
    public TcpConnectionPoolSettings get_ConnectionPoolSettings();
    public int get_ListenBacklog();
    public void set_ListenBacklog(int value);
    internal bool get_IsListenBacklogSet();
    public bool get_PortSharingEnabled();
    public void set_PortSharingEnabled(bool value);
    public virtual string get_Scheme();
    public bool get_TeredoEnabled();
    public void set_TeredoEnabled(bool value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal virtual string get_WsdlTransportUri();
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeExtendedProtectionPolicy();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeListenBacklog();
}
internal static class System.ServiceModel.Channels.TcpTransportDefaults : object {
    internal static int ListenBacklogConst;
    internal static string ConnectionLeaseTimeoutString;
    internal static bool PortSharingEnabled;
    internal static bool TeredoEnabled;
    internal static TimeSpan ConnectionLeaseTimeout { get; }
    internal static TimeSpan get_ConnectionLeaseTimeout();
    internal static int GetListenBacklog();
}
internal abstract class System.ServiceModel.Channels.TcpTransportManager : ConnectionOrientedTransportManager`1<TcpChannelListener> {
    internal string Scheme { get; }
    internal virtual string get_Scheme();
    protected virtual bool IsCompatible(TcpChannelListener channelListener);
}
internal static class System.ServiceModel.Channels.TcpUri : object {
    public static int DefaultPort;
}
internal class System.ServiceModel.Channels.TerminateSequence : BodyWriter {
    public TerminateSequence(ReliableMessagingVersion reliableMessagingVersion, UniqueId identifier, long last);
    public static TerminateSequenceInfo Create(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.TerminateSequenceInfo : WsrmRequestInfo {
    public UniqueId Identifier { get; public set; }
    public long LastMsgNumber { get; public set; }
    public string RequestName { get; }
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public long get_LastMsgNumber();
    public void set_LastMsgNumber(long value);
    public virtual string get_RequestName();
    public static TerminateSequenceInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, Message message, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.TerminateSequenceResponse : BodyWriter {
    public UniqueId Identifier { get; public set; }
    public TerminateSequenceResponse(UniqueId identifier);
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public static TerminateSequenceResponseInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.TerminateSequenceResponseInfo : object {
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    public UniqueId get_Identifier();
    public void set_Identifier(UniqueId value);
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public static TerminateSequenceResponseInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
internal static class System.ServiceModel.Channels.TextEncoderDefaults : object {
    internal static Encoding Encoding;
    internal static string EncodingString;
    internal static Encoding[] SupportedEncodings;
    internal static string MessageVersionString;
    internal static CharSetEncoding[] CharSetEncodings;
    private static TextEncoderDefaults();
    internal static void ValidateEncoding(Encoding encoding);
    internal static string EncodingToCharSet(Encoding encoding);
    internal static bool TryGetEncoding(string charSet, Encoding& encoding);
}
internal class System.ServiceModel.Channels.TextMessageEncoderFactory : MessageEncoderFactory {
    internal static ContentEncoding[] Soap11Content;
    internal static ContentEncoding[] Soap12Content;
    internal static ContentEncoding[] SoapNoneContent;
    internal static string Soap11MediaType;
    internal static string Soap12MediaType;
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public TextMessageEncoderFactory(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, XmlDictionaryReaderQuotas quotas);
    private static TextMessageEncoderFactory();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public static Encoding[] GetSupportedEncodings();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal static string GetMediaType(MessageVersion version);
    internal static string GetContentType(string mediaType, Encoding encoding);
    internal static Encoding GetEncodingFromContentType(string contentType, ContentEncoding[] contentMap);
    internal static bool TryGetEncodingFromCharSet(string charSet, Encoding& encoding);
}
public class System.ServiceModel.Channels.TextMessageEncodingBindingElement : MessageEncodingBindingElement {
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    [TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding WriteEncoding { get; public set; }
    public TextMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWriteEncoding();
}
internal class System.ServiceModel.Channels.TimeoutStream : DelegatingStream {
    public TimeoutStream(Stream stream, TimeoutHelper& timeoutHelper);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class System.ServiceModel.Channels.ToHeader : AddressingHeader {
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public Uri To { get; }
    protected ToHeader(Uri to, AddressingVersion version);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public Uri get_To();
    public static ToHeader Create(Uri toUri, XmlDictionaryString dictionaryTo, AddressingVersion addressingVersion);
    public static ToHeader Create(Uri to, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache);
    public static ToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache, string actor, bool mustUnderstand, bool relay);
}
internal enum System.ServiceModel.Channels.TolerateFaultsMode : Enum {
    public int value__;
    public static TolerateFaultsMode Never;
    public static TolerateFaultsMode IfNotSecuritySession;
    public static TolerateFaultsMode Always;
}
internal class System.ServiceModel.Channels.TracingConnection : DelegatingConnection {
    public TracingConnection(IConnection connection, ServiceModelActivity activity);
    public TracingConnection(IConnection connection, bool inheritCurrentActivity);
    public virtual void Abort();
    public virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public virtual void Shutdown(TimeSpan timeout);
    internal void ActivityStart(string name);
    internal void ActivityStart(Uri uri);
    public virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, WaitCallback callback, object state);
    public virtual void EndWrite();
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, WaitCallback callback, object state);
    public virtual int EndRead();
    public virtual object DuplicateAndClose(int targetProcessId);
}
internal class System.ServiceModel.Channels.TracingConnectionInitiator : object {
    internal TracingConnectionInitiator(IConnectionInitiator connectionInitiator, bool isClient);
    public sealed virtual IConnection Connect(Uri uri, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginConnect(Uri uri, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IConnection EndConnect(IAsyncResult result);
}
internal class System.ServiceModel.Channels.TracingConnectionListener : object {
    internal TracingConnectionListener(IConnectionListener listener, string traceStartInfo);
    internal TracingConnectionListener(IConnectionListener listener, Uri uri);
    internal TracingConnectionListener(IConnectionListener listener);
    internal TracingConnectionListener(IConnectionListener listener, string traceStartInfo, bool newActivity);
    public sealed virtual void Listen();
    public sealed virtual IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public sealed virtual IConnection EndAccept(IAsyncResult result);
    public sealed virtual void Dispose();
}
internal abstract class System.ServiceModel.Channels.TransactionChannel`1 : LayeredChannel`1<TChannel> {
    internal TransactionFormatter Formatter { get; }
    internal TransactionProtocol Protocol { get; }
    protected TransactionChannel`1(ChannelManagerBase channelManager, TChannel innerChannel);
    internal TransactionFormatter get_Formatter();
    internal TransactionProtocol get_Protocol();
    public virtual T GetProperty();
    public T GetInnerProperty();
    public sealed virtual void ReadIssuedTokens(Message message, MessageDirection direction);
    public virtual void ReadTransactionDataFromMessage(Message message, MessageDirection direction);
    public sealed virtual void WriteTransactionDataToMessage(Message message, MessageDirection direction);
    public sealed virtual void WriteIssuedTokens(Message message, MessageDirection direction);
}
internal class System.ServiceModel.Channels.TransactionChannelFactory`1 : LayeredChannelFactory`1<TChannel> {
    public TransactionProtocol TransactionProtocol { get; public set; }
    public TransactionFlowOption FlowIssuedTokens { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public IDictionary`2<DirectionalAction, TransactionFlowOption> Dictionary { get; }
    public TransactionChannelFactory`1(TransactionProtocol transactionProtocol, BindingContext context, Dictionary`2<DirectionalAction, TransactionFlowOption> dictionary, bool allowWildcardAction);
    public sealed virtual TransactionProtocol get_TransactionProtocol();
    public sealed virtual void set_TransactionProtocol(TransactionProtocol value);
    public sealed virtual TransactionFlowOption get_FlowIssuedTokens();
    public sealed virtual void set_FlowIssuedTokens(TransactionFlowOption value);
    public sealed virtual SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public sealed virtual IDictionary`2<DirectionalAction, TransactionFlowOption> get_Dictionary();
    public sealed virtual TransactionFlowOption GetTransaction(MessageDirection direction, string action);
    protected virtual TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via);
}
internal class System.ServiceModel.Channels.TransactionChannelFaultConverter`1 : FaultConverter {
    internal TransactionChannelFaultConverter`1(TransactionChannel`1<TChannel> channel);
    protected virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
}
internal class System.ServiceModel.Channels.TransactionChannelListener`1 : DelegatingChannelListener`1<TChannel> {
    public TransactionProtocol TransactionProtocol { get; public set; }
    public TransactionFlowOption FlowIssuedTokens { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public IDictionary`2<DirectionalAction, TransactionFlowOption> Dictionary { get; }
    public TransactionChannelListener`1(TransactionProtocol transactionProtocol, IDefaultCommunicationTimeouts timeouts, Dictionary`2<DirectionalAction, TransactionFlowOption> dictionary, IChannelListener`1<TChannel> innerListener);
    public sealed virtual TransactionProtocol get_TransactionProtocol();
    public sealed virtual void set_TransactionProtocol(TransactionProtocol value);
    public sealed virtual TransactionFlowOption get_FlowIssuedTokens();
    public sealed virtual void set_FlowIssuedTokens(TransactionFlowOption value);
    public sealed virtual SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public sealed virtual IDictionary`2<DirectionalAction, TransactionFlowOption> get_Dictionary();
    public sealed virtual TransactionFlowOption GetTransaction(MessageDirection direction, string action);
}
internal class System.ServiceModel.Channels.TransactionDuplexChannelGeneric`1 : TransactionReceiveChannelGeneric`1<TChannel> {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public TransactionDuplexChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel, MessageDirection direction);
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    public virtual void ReadTransactionDataFromMessage(Message message, MessageDirection direction);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback asyncCallback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message);
    public virtual void Send(Message message, TimeSpan timeout);
}
public class System.ServiceModel.Channels.TransactionFlowBindingElement : BindingElement {
    internal bool Transactions { get; internal set; }
    internal TransactionFlowOption IssuedTokens { get; internal set; }
    public TransactionProtocol TransactionProtocol { get; public set; }
    [DefaultValueAttribute("False")]
public bool AllowWildcardAction { get; public set; }
    public TransactionFlowBindingElement(TransactionProtocol transactionProtocol);
    internal TransactionFlowBindingElement(bool transactions);
    internal TransactionFlowBindingElement(bool transactions, TransactionProtocol transactionProtocol);
    internal bool get_Transactions();
    internal void set_Transactions(bool value);
    internal TransactionFlowOption get_IssuedTokens();
    internal void set_IssuedTokens(TransactionFlowOption value);
    public virtual BindingElement Clone();
    internal bool IsFlowEnabled(ContractDescription contract);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    [CompilerGeneratedAttribute]
public bool get_AllowWildcardAction();
    [CompilerGeneratedAttribute]
public void set_AllowWildcardAction(bool value);
    internal static void ValidateOption(TransactionFlowOption opt);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransactionProtocol();
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    internal static MessagePartSpecification GetIssuedTokenHeaderSpecification(SecurityStandardsManager standardsManager);
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.TransactionFlowBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
internal static class System.ServiceModel.Channels.TransactionFlowDefaults : object {
    internal static TransactionFlowOption IssuedTokens;
    internal static bool Transactions;
    internal static TransactionProtocol TransactionProtocol;
    internal static string TransactionProtocolString;
    private static TransactionFlowDefaults();
}
internal class System.ServiceModel.Channels.TransactionFlowProperty : object {
    internal ICollection`1<RequestSecurityTokenResponse> IssuedTokens { get; }
    internal Transaction Transaction { get; }
    internal ICollection`1<RequestSecurityTokenResponse> get_IssuedTokens();
    internal Transaction get_Transaction();
    internal static TransactionFlowProperty Ensure(Message message);
    internal static TransactionFlowProperty TryGet(Message message);
    internal static ICollection`1<RequestSecurityTokenResponse> TryGetIssuedTokens(Message message);
    internal static Transaction TryGetTransaction(Message message);
    internal static void Set(Transaction transaction, Message message);
}
internal class System.ServiceModel.Channels.TransactionInputDuplexChannelGeneric`1 : TransactionDuplexChannelGeneric`1<TChannel> {
    public TransactionInputDuplexChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel);
}
public class System.ServiceModel.Channels.TransactionMessageProperty : object {
    public Transaction Transaction { get; }
    public Transaction get_Transaction();
    internal static TransactionMessageProperty TryGet(Message message);
    internal static Transaction TryGetTransaction(Message message);
    public static void Set(Transaction transaction, Message message);
    internal static void Set(TransactionInfo transactionInfo, Message message);
}
internal class System.ServiceModel.Channels.TransactionOutputChannelGeneric`1 : TransactionChannel`1<TChannel> {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public TransactionOutputChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel);
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback asyncCallback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.TransactionOutputDuplexChannelGeneric`1 : TransactionDuplexChannelGeneric`1<TChannel> {
    public TransactionOutputDuplexChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel);
}
internal static class System.ServiceModel.Channels.TransactionPolicyStrings : object {
    public static string OptionalLocal;
    public static string OptionalPrefix10;
    public static string OptionalPrefix11;
    public static string OptionalNamespaceLegacy;
    public static string WsatTransactionsPrefix;
    public static string WsatTransactionsNamespace10;
    public static string WsatTransactionsNamespace11;
    public static string WsatTransactionsLocal;
    public static string OleTxTransactionsPrefix;
    public static string OleTxTransactionsNamespace;
    public static string OleTxTransactionsLocal;
    public static string TrueValue;
}
internal class System.ServiceModel.Channels.TransactionReceiveChannelGeneric`1 : TransactionChannel`1<TChannel> {
    public EndpointAddress LocalAddress { get; }
    public TransactionReceiveChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel, MessageDirection direction);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual bool EndTryReceive(IAsyncResult asyncResult, Message& message);
    public virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.TransactionReplyChannelGeneric`1 : TransactionChannel`1<TChannel> {
    public EndpointAddress LocalAddress { get; }
    public TransactionReplyChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel);
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual RequestContext ReceiveRequest();
    public sealed virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceiveRequest(IAsyncResult asyncResult, RequestContext& requestContext);
    public sealed virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual bool WaitForRequest(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForRequest(IAsyncResult result);
}
internal class System.ServiceModel.Channels.TransactionRequestChannelGeneric`1 : TransactionChannel`1<TChannel> {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public TransactionRequestChannelGeneric`1(ChannelManagerBase channelManager, TChannel innerChannel);
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback asyncCallback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.TransactionRequestContext : RequestContextBase {
    public TransactionRequestContext(ITransactionChannel transactionChannel, ChannelBase channel, RequestContext innerContext, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndReply(IAsyncResult result);
    protected virtual void OnReply(Message message, TimeSpan timeout);
}
public enum System.ServiceModel.Channels.TransferSession : Enum {
    public int value__;
    public static TransferSession None;
    public static TransferSession Ordered;
    public static TransferSession Unordered;
}
internal class System.ServiceModel.Channels.TransmissionStrategy : object {
    public bool DoneTransmitting { get; }
    public bool HasPending { get; }
    public long Last { get; }
    unknown ComponentExceptionHandler OnException {public set; }
    unknown RetryHandler RetryTimeoutElapsed {public set; }
    public int QuotaRemaining { get; }
    public int Timeout { get; }
    public TransmissionStrategy(ReliableMessagingVersion reliableMessagingVersion, TimeSpan initRtt, int maxWindowSize, bool requestAcks, UniqueId id);
    public bool get_DoneTransmitting();
    public bool get_HasPending();
    public long get_Last();
    public void set_OnException(ComponentExceptionHandler value);
    public void set_RetryTimeoutElapsed(RetryHandler value);
    public int get_QuotaRemaining();
    public int get_Timeout();
    public void Abort(ChannelBase channel);
    public bool Add(Message message, TimeSpan timeout, object state, MessageAttemptInfo& attemptInfo);
    public MessageAttemptInfo AddLast(Message message, TimeSpan timeout, object state);
    public IAsyncResult BeginAdd(Message message, TimeSpan timeout, object state, AsyncCallback callback, object asyncState);
    public IAsyncResult BeginAddLast(Message message, TimeSpan timeout, object state, AsyncCallback callback, object asyncState);
    public void Close();
    public void DequeuePending();
    public bool EndAdd(IAsyncResult result, MessageAttemptInfo& attemptInfo);
    public MessageAttemptInfo EndAddLast(IAsyncResult result);
    public void OnRetryElapsed(object state);
    public void Fault(ChannelBase channel);
    public MessageAttemptInfo GetMessageInfoForRetry(bool remove);
    public bool SetLast();
    public bool IsFinalAckConsistent(SequenceRangeCollection ranges);
    public void ProcessAcknowledgement(SequenceRangeCollection ranges, Boolean& invalidAck, Boolean& inconsistentAck);
    public bool ProcessTransferred(long transferred, int quotaRemaining);
    public bool ProcessTransferred(SequenceRangeCollection ranges, int quotaRemaining);
}
public abstract class System.ServiceModel.Channels.TransportBindingElement : BindingElement {
    [DefaultValueAttribute("False")]
public bool ManualAddressing { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    public string Scheme { get; }
    protected TransportBindingElement(TransportBindingElement elementToBeCloned);
    public virtual bool get_ManualAddressing();
    public virtual void set_ManualAddressing(bool value);
    public virtual long get_MaxBufferPoolSize();
    public virtual void set_MaxBufferPoolSize(long value);
    public virtual long get_MaxReceivedMessageSize();
    public virtual void set_MaxReceivedMessageSize(long value);
    public abstract virtual string get_Scheme();
    internal static IChannelFactory`1<TChannel> CreateChannelFactory(TransportBindingElement transport);
    internal static IChannelListener CreateChannelListener(TransportBindingElement transport);
    public virtual T GetProperty(BindingContext context);
    internal ChannelProtectionRequirements GetProtectionRequirements(BindingContext context);
    internal static void ExportWsdlEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext, string wsdlTransportUri, AddressingVersion addressingVersion);
    internal static void ExportWsdlEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext, string wsdlTransportUri, EndpointAddress address, AddressingVersion addressingVersion);
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.TransportBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportContract(WsdlImporter importer, WsdlContractConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
}
internal abstract class System.ServiceModel.Channels.TransportChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    public BufferManager BufferManager { get; }
    public long MaxBufferPoolSize { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public bool ManualAddressing { get; }
    public string Scheme { get; }
    private long System.ServiceModel.Channels.ITransportFactorySettings.MaxReceivedMessageSize { get; }
    private BufferManager System.ServiceModel.Channels.ITransportFactorySettings.BufferManager { get; }
    private bool System.ServiceModel.Channels.ITransportFactorySettings.ManualAddressing { get; }
    private MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.MessageEncoderFactory { get; }
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context);
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory);
    public BufferManager get_BufferManager();
    public sealed virtual long get_MaxBufferPoolSize();
    public long get_MaxReceivedMessageSize();
    public MessageEncoderFactory get_MessageEncoderFactory();
    public sealed virtual MessageVersion get_MessageVersion();
    public bool get_ManualAddressing();
    public abstract virtual string get_Scheme();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    internal virtual int GetMaxBufferSize();
    protected virtual void OnOpening();
    internal void ValidateScheme(Uri via);
    private sealed virtual override long System.ServiceModel.Channels.ITransportFactorySettings.get_MaxReceivedMessageSize();
    private sealed virtual override BufferManager System.ServiceModel.Channels.ITransportFactorySettings.get_BufferManager();
    private sealed virtual override bool System.ServiceModel.Channels.ITransportFactorySettings.get_ManualAddressing();
    private sealed virtual override MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.get_MessageEncoderFactory();
}
internal abstract class System.ServiceModel.Channels.TransportChannelListener : ChannelListenerBase {
    internal ServiceModelActivity Activity { get; internal set; }
    internal Uri BaseUri { get; }
    internal string HostedVirtualPath { get; }
    internal bool InheritBaseAddressSettings { get; internal set; }
    internal ServiceSecurityAuditBehavior AuditBehavior { get; }
    public BufferManager BufferManager { get; }
    internal HostNameComparisonMode HostNameComparisonModeInternal { get; }
    public bool ManualAddressing { get; }
    public long MaxBufferPoolSize { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    internal UriPrefixTable`1<ITransportManagerRegistration> TransportManagerTable { get; }
    public string Scheme { get; }
    public Uri Uri { get; }
    private long System.ServiceModel.Channels.ITransportFactorySettings.MaxReceivedMessageSize { get; }
    private BufferManager System.ServiceModel.Channels.ITransportFactorySettings.BufferManager { get; }
    private bool System.ServiceModel.Channels.ITransportFactorySettings.ManualAddressing { get; }
    private MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.MessageEncoderFactory { get; }
    protected TransportChannelListener(TransportBindingElement bindingElement, BindingContext context);
    protected TransportChannelListener(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory);
    protected TransportChannelListener(TransportBindingElement bindingElement, BindingContext context, HostNameComparisonMode hostNameComparisonMode);
    protected TransportChannelListener(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory, HostNameComparisonMode hostNameComparisonMode);
    private static TransportChannelListener();
    internal ServiceModelActivity get_Activity();
    internal void set_Activity(ServiceModelActivity value);
    internal Uri get_BaseUri();
    internal string get_HostedVirtualPath();
    internal bool get_InheritBaseAddressSettings();
    internal void set_InheritBaseAddressSettings(bool value);
    internal ServiceSecurityAuditBehavior get_AuditBehavior();
    public BufferManager get_BufferManager();
    internal HostNameComparisonMode get_HostNameComparisonModeInternal();
    public bool get_ManualAddressing();
    public sealed virtual long get_MaxBufferPoolSize();
    public virtual long get_MaxReceivedMessageSize();
    public MessageEncoderFactory get_MessageEncoderFactory();
    public sealed virtual MessageVersion get_MessageVersion();
    internal abstract virtual UriPrefixTable`1<ITransportManagerRegistration> get_TransportManagerTable();
    public abstract virtual string get_Scheme();
    public virtual Uri get_Uri();
    public virtual T GetProperty();
    internal bool IsScopeIdCompatible(HostNameComparisonMode hostNameComparisonMode, Uri uri);
    internal virtual void ApplyHostedContext(string virtualPath, bool isMetadataListener);
    internal virtual ITransportManagerRegistration CreateTransportManagerRegistration();
    internal abstract virtual ITransportManagerRegistration CreateTransportManagerRegistration(Uri listenUri);
    internal virtual int GetMaxBufferSize();
    protected virtual void OnOpening();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    internal TransportManagerContainer GetTransportManagers();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual bool TryGetTransportManagerRegistration(HostNameComparisonMode hostNameComparisonMode, ITransportManagerRegistration& registration);
    internal virtual IList`1<TransportManager> SelectTransportManagers();
    protected void SetUri(Uri baseAddress, string relativeAddress);
    protected virtual void ValidateUri(Uri uri);
    private sealed virtual override long System.ServiceModel.Channels.ITransportFactorySettings.get_MaxReceivedMessageSize();
    private sealed virtual override BufferManager System.ServiceModel.Channels.ITransportFactorySettings.get_BufferManager();
    private sealed virtual override bool System.ServiceModel.Channels.ITransportFactorySettings.get_ManualAddressing();
    private sealed virtual override MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.get_MessageEncoderFactory();
    internal void SetMessageReceivedCallback(Action messageReceivedCallback);
    internal void RaiseMessageReceived();
}
internal static class System.ServiceModel.Channels.TransportDefaults : object {
    internal static bool ExtractGroupsForWindowsAccounts;
    internal static HostNameComparisonMode HostNameComparisonMode;
    internal static TokenImpersonationLevel ImpersonationLevel;
    internal static bool ManualAddressing;
    internal static long MaxReceivedMessageSize;
    internal static int MaxDrainSize;
    internal static long MaxBufferPoolSize;
    internal static int MaxBufferSize;
    internal static bool RequireClientCertificate;
    internal static int MaxFaultSize;
    internal static int MaxSecurityFaultSize;
    internal static SslProtocols SslProtocols;
    internal static int MaxRMFaultSize;
    internal static MessageEncoderFactory GetDefaultMessageEncoderFactory();
}
internal abstract class System.ServiceModel.Channels.TransportDuplexSessionChannel : TransportOutputChannel {
    public EndpointAddress LocalAddress { get; }
    public SecurityMessageProperty RemoteSecurity { get; protected set; }
    public IDuplexSession Session { get; protected set; }
    public ThreadNeutralSemaphore SendLock { get; }
    protected ChannelBinding ChannelBinding { get; }
    protected BufferManager BufferManager { get; }
    protected Uri LocalVia { get; }
    protected MessageEncoder MessageEncoder { get; protected set; }
    protected SynchronizedMessageSource MessageSource { get; }
    protected bool IsStreamedOutput { get; }
    protected TransportDuplexSessionChannel(ChannelManagerBase manager, ITransportFactorySettings settings, EndpointAddress localAddress, Uri localVia, EndpointAddress remoteAddresss, Uri via);
    public sealed virtual EndpointAddress get_LocalAddress();
    public SecurityMessageProperty get_RemoteSecurity();
    protected void set_RemoteSecurity(SecurityMessageProperty value);
    public sealed virtual IDuplexSession get_Session();
    protected void set_Session(IDuplexSession value);
    public ThreadNeutralSemaphore get_SendLock();
    protected ChannelBinding get_ChannelBinding();
    protected BufferManager get_BufferManager();
    protected Uri get_LocalVia();
    protected MessageEncoder get_MessageEncoder();
    protected void set_MessageEncoder(MessageEncoder value);
    protected SynchronizedMessageSource get_MessageSource();
    protected abstract virtual bool get_IsStreamedOutput();
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    protected void SetChannelBinding(ChannelBinding channelBinding);
    protected void SetMessageSource(IMessageSource messageSource);
    protected IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    protected void EndCloseOutputSession(IAsyncResult result);
    protected abstract virtual void CloseOutputSessionCore(TimeSpan timeout);
    protected void CloseOutputSession(TimeSpan timeout);
    protected abstract virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual void OnFaulted();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnReceiveMessage(Message message);
    protected void ApplyChannelBinding(Message message);
    protected virtual void PrepareMessage(Message message);
    protected abstract virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, WaitCallback callback, object state);
    protected abstract virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, WaitCallback callback, object state);
    protected virtual void FinishWritingMessage();
    protected abstract virtual ArraySegment`1<byte> EncodeMessage(Message message);
    protected abstract virtual void OnSendCore(Message message, TimeSpan timeout);
    protected abstract virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, WaitCallback callback, object state);
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    protected abstract virtual void CompleteClose(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.TransportIntegrationHandler : DelegatingHandler {
    public TransportIntegrationHandler(HttpMessageHandler innerChannel);
    public Task`1<HttpResponseMessage> ProcessPipelineAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal abstract class System.ServiceModel.Channels.TransportManager : object {
    protected ServiceModelActivity Activity { get; }
    internal string Scheme { get; }
    internal object ThisLock { get; }
    protected ServiceModelActivity get_Activity();
    internal abstract virtual string get_Scheme();
    internal object get_ThisLock();
    internal void Close(TransportChannelListener channelListener, TimeSpan timeout);
    internal static void EnsureRegistered(UriPrefixTable`1<TChannelListener> addressTable, TChannelListener channelListener, HostNameComparisonMode registeredComparisonMode);
    protected void Fault(UriPrefixTable`1<TChannelListener> addressTable, Exception exception);
    internal abstract virtual void OnClose(TimeSpan timeout);
    internal abstract virtual void OnOpen();
    internal virtual void OnAbort();
    internal void Open(TransportChannelListener channelListener);
    internal void Abort(TransportChannelListener channelListener);
    internal abstract virtual void Register(TransportChannelListener channelListener);
    protected void ThrowIfOpen();
    internal abstract virtual void Unregister(TransportChannelListener channelListener);
}
internal class System.ServiceModel.Channels.TransportManagerContainer : object {
    public TransportManagerContainer(TransportChannelListener listener);
    public static TransportManagerContainer TransferTransportManagers(TransportManagerContainer source);
    public void Abort();
    public IAsyncResult BeginOpen(SelectTransportManagersCallback selectTransportManagerCallback, AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult result);
    public void Open(SelectTransportManagersCallback selectTransportManagerCallback);
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndClose(IAsyncResult result);
    public void Close(TimeSpan timeout);
    public void Close(bool aborting, TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.TransportManagerRegistration : object {
    public HostNameComparisonMode HostNameComparisonMode { get; }
    public Uri ListenUri { get; }
    protected TransportManagerRegistration(Uri listenUri, HostNameComparisonMode hostNameComparisonMode);
    public sealed virtual HostNameComparisonMode get_HostNameComparisonMode();
    public sealed virtual Uri get_ListenUri();
    public abstract virtual IList`1<TransportManager> Select(TransportChannelListener factory);
}
internal abstract class System.ServiceModel.Channels.TransportOutputChannel : OutputChannel {
    protected bool ManualAddressing { get; }
    public MessageVersion MessageVersion { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public EventTraceActivity EventTraceActivity { get; }
    protected TransportOutputChannel(ChannelManagerBase channelManager, EndpointAddress to, Uri via, bool manualAddressing, MessageVersion messageVersion);
    protected bool get_ManualAddressing();
    public MessageVersion get_MessageVersion();
    public virtual EndpointAddress get_RemoteAddress();
    public virtual Uri get_Via();
    public EventTraceActivity get_EventTraceActivity();
    protected virtual void AddHeadersTo(Message message);
}
internal static class System.ServiceModel.Channels.TransportPolicyConstants : object {
    public static string BasicHttpAuthenticationName;
    public static string CompositeDuplex;
    public static string CompositeDuplexNamespace;
    public static string CompositeDuplexPrefix;
    public static string DigestHttpAuthenticationName;
    public static string DotNetFramingNamespace;
    public static string DotNetFramingPrefix;
    public static string HttpTransportNamespace;
    public static string HttpTransportPrefix;
    public static string HttpTransportUri;
    public static string MsmqBestEffort;
    public static string MsmqSession;
    public static string MsmqTransportNamespace;
    public static string MsmqTransportPrefix;
    public static string MsmqTransportUri;
    public static string MsmqVolatile;
    public static string MsmqAuthenticated;
    public static string MsmqWindowsDomain;
    public static string NamedPipeTransportUri;
    public static string NegotiateHttpAuthenticationName;
    public static string NtlmHttpAuthenticationName;
    public static string PeerTransportUri;
    public static string ProtectionLevelName;
    public static string RequireClientCertificateName;
    public static string SslTransportSecurityName;
    public static string StreamedName;
    public static string TcpTransportUri;
    public static string WebSocketPolicyPrefix;
    public static string WebSocketPolicyNamespace;
    public static string WebSocketTransportUri;
    public static string WebSocketEnabled;
    public static string WindowsTransportSecurityName;
}
internal class System.ServiceModel.Channels.TransportReplyChannelAcceptor : ReplyChannelAcceptor {
    public TransportReplyChannelAcceptor(TransportChannelListener listener);
    protected virtual ReplyChannel OnCreateChannel();
    protected virtual void OnOpening();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
}
public class System.ServiceModel.Channels.TransportSecurityBindingElement : SecurityBindingElement {
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    internal virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    internal virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext);
    protected virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    protected virtual IChannelListener`1<TChannel> BuildChannelListenerCore(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    public virtual BindingElement Clone();
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext policyContext);
}
internal static class System.ServiceModel.Channels.TransportSecurityHelpers : object {
    public static IAsyncResult BeginGetSspiCredential(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout, AsyncCallback callback, object state);
    public static IAsyncResult BeginGetSspiCredential(SecurityTokenProvider tokenProvider, TimeSpan timeout, AsyncCallback callback, object state);
    public static NetworkCredential EndGetSspiCredential(IAsyncResult result, TokenImpersonationLevel& impersonationLevel, AuthenticationLevel& authenticationLevel);
    public static NetworkCredential EndGetSspiCredential(IAsyncResult result, TokenImpersonationLevel& impersonationLevel, Boolean& allowNtlm);
    public static NetworkCredential GetSspiCredential(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout, TokenImpersonationLevel& impersonationLevel, AuthenticationLevel& authenticationLevel);
    public static NetworkCredential GetSspiCredential(SspiSecurityTokenProvider tokenProvider, TimeSpan timeout, TokenImpersonationLevel& impersonationLevel, Boolean& allowNtlm);
    public static NetworkCredential GetSspiCredential(SecurityTokenManager credentialProvider, SecurityTokenRequirement sspiTokenRequirement, TimeSpan timeout, Boolean& extractGroupsForWindowsAccounts);
    public static SecurityTokenRequirement CreateSspiTokenRequirement(string transportScheme, Uri listenUri);
    public static SspiSecurityTokenProvider GetSspiTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SspiSecurityTokenProvider GetSspiTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, IdentityVerifier& identityVerifier);
    public static SecurityTokenProvider GetDigestTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SecurityTokenAuthenticator GetCertificateTokenAuthenticator(SecurityTokenManager tokenManager, string transportScheme, Uri listenUri);
    public static SecurityTokenProvider GetCertificateTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, ChannelParameterCollection channelParameters);
    public static IAsyncResult BeginGetUserNameCredential(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout, AsyncCallback callback, object state);
    public static NetworkCredential EndGetUserNameCredential(IAsyncResult result);
    public static NetworkCredential GetUserNameCredential(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout);
    public static SecurityTokenProvider GetUserNameTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static Uri GetListenUri(Uri baseAddress, string relativeAddress);
}
internal class System.ServiceModel.Channels.TransportSettingsCallback : MulticastDelegate {
    public TransportSettingsCallback(object object, IntPtr method);
    public virtual IConnectionOrientedTransportFactorySettings Invoke(Uri via);
    public virtual IAsyncResult BeginInvoke(Uri via, AsyncCallback callback, object object);
    public virtual IConnectionOrientedTransportFactorySettings EndInvoke(IAsyncResult result);
}
internal abstract class System.ServiceModel.Channels.TypedChannelDemuxer : object {
    internal static void AbortMessage(RequestContext request);
    internal static void AbortMessage(Message message);
    public abstract virtual IChannelListener`1<TChannel> BuildChannelListener(ChannelDemuxerFilter filter);
}
internal abstract class System.ServiceModel.Channels.TypedFaultHelper`1 : FaultHelper {
    protected TypedFaultHelper`1(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    public virtual void Abort();
    protected abstract virtual void AbortState(TState state, bool isOnAbortThread);
    public virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult BeginSendFault(IReliableChannelBinder binder, TState state, TimeSpan timeout, AsyncCallback callback, object asyncState);
    public virtual void Close(TimeSpan timeout);
    public virtual void EndClose(IAsyncResult result);
    protected abstract virtual void EndSendFault(IReliableChannelBinder binder, TState state, IAsyncResult result);
    protected abstract virtual TState GetState(RequestContext requestContext, Message faultMessage);
    protected void RemoveBinder(IReliableChannelBinder binder);
    protected void SendFault(IReliableChannelBinder binder, TState state);
    public virtual void SendFaultAsync(IReliableChannelBinder binder, RequestContext requestContext, Message faultMessage);
}
public class System.ServiceModel.Channels.UnderstoodHeaders : object {
    internal bool Modified { get; internal set; }
    internal UnderstoodHeaders(MessageHeaders messageHeaders, bool modified);
    internal bool get_Modified();
    internal void set_Modified(bool value);
    public void Add(MessageHeaderInfo headerInfo);
    public bool Contains(MessageHeaderInfo headerInfo);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    public void Remove(MessageHeaderInfo headerInfo);
}
internal class System.ServiceModel.Channels.UniqueTransportManagerRegistration : TransportManagerRegistration {
    public UniqueTransportManagerRegistration(TransportManager uniqueManager, Uri listenUri, HostNameComparisonMode hostNameComparisonMode);
    public virtual IList`1<TransportManager> Select(TransportChannelListener channelListener);
}
internal class System.ServiceModel.Channels.UnknownSequenceFault : WsrmHeaderFault {
    public UnknownSequenceFault(UniqueId sequenceID);
    public UnknownSequenceFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    public virtual CommunicationException CreateException();
}
internal class System.ServiceModel.Channels.UnorderedDeliveryStrategy`1 : DeliveryStrategy`1<ItemType> {
    public int EnqueuedCount { get; }
    public UnorderedDeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota);
    public virtual int get_EnqueuedCount();
    public virtual bool CanEnqueue(long sequenceNumber);
    public virtual bool Enqueue(ItemType item, long sequenceNumber);
}
internal class System.ServiceModel.Channels.UnrecognizedAssertionsBindingElement : BindingElement {
    internal XmlQualifiedName WsdlBinding { get; }
    internal ICollection`1<XmlElement> BindingAsserions { get; }
    internal IDictionary`2<OperationDescription, ICollection`1<XmlElement>> OperationAssertions { get; }
    internal IDictionary`2<MessageDescription, ICollection`1<XmlElement>> MessageAssertions { get; }
    protected internal UnrecognizedAssertionsBindingElement(XmlQualifiedName wsdlBinding, ICollection`1<XmlElement> bindingAsserions);
    protected UnrecognizedAssertionsBindingElement(UnrecognizedAssertionsBindingElement elementToBeCloned);
    internal XmlQualifiedName get_WsdlBinding();
    internal ICollection`1<XmlElement> get_BindingAsserions();
    internal IDictionary`2<OperationDescription, ICollection`1<XmlElement>> get_OperationAssertions();
    internal IDictionary`2<MessageDescription, ICollection`1<XmlElement>> get_MessageAssertions();
    internal void Add(OperationDescription operation, ICollection`1<XmlElement> assertions);
    internal void Add(MessageDescription message, ICollection`1<XmlElement> assertions);
    public virtual T GetProperty(BindingContext context);
    public virtual BindingElement Clone();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.ServiceModel.Channels.UnsafeNativeMethods : object {
    public static string KERNEL32;
    public static string ADVAPI32;
    public static string BCRYPT;
    public static string MQRT;
    public static string SECUR32;
    public static string USERENV;
    public static string WS2_32;
    public static int ERROR_SUCCESS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_HANDLE;
    public static int ERROR_NOT_ENOUGH_MEMORY;
    public static int ERROR_OUTOFMEMORY;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_NETNAME_DELETED;
    public static int ERROR_INVALID_PARAMETER;
    public static int ERROR_BROKEN_PIPE;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_PIPE_BUSY;
    public static int ERROR_NO_DATA;
    public static int ERROR_MORE_DATA;
    public static int WAIT_TIMEOUT;
    public static int ERROR_PIPE_CONNECTED;
    public static int ERROR_OPERATION_ABORTED;
    public static int ERROR_IO_PENDING;
    public static int ERROR_SERVICE_ALREADY_RUNNING;
    public static int ERROR_SERVICE_DISABLED;
    public static int ERROR_NO_TRACKING_SERVICE;
    public static int ERROR_ALLOTTED_SPACE_EXCEEDED;
    public static int ERROR_NO_SYSTEM_RESOURCES;
    public static int STATUS_PENDING;
    public static int WSAACCESS;
    public static int WSAEMFILE;
    public static int WSAEMSGSIZE;
    public static int WSAEADDRINUSE;
    public static int WSAEADDRNOTAVAIL;
    public static int WSAENETDOWN;
    public static int WSAENETUNREACH;
    public static int WSAENETRESET;
    public static int WSAECONNABORTED;
    public static int WSAECONNRESET;
    public static int WSAENOBUFS;
    public static int WSAESHUTDOWN;
    public static int WSAETIMEDOUT;
    public static int WSAECONNREFUSED;
    public static int WSAEHOSTDOWN;
    public static int WSAEHOSTUNREACH;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int FILE_FLAG_OVERLAPPED;
    public static int FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static int GENERIC_ALL;
    public static int GENERIC_READ;
    public static int GENERIC_WRITE;
    public static int FILE_CREATE_PIPE_INSTANCE;
    public static int FILE_WRITE_ATTRIBUTES;
    public static int FILE_WRITE_DATA;
    public static int FILE_WRITE_EA;
    public static int OPEN_EXISTING;
    public static int PIPE_ACCESS_DUPLEX;
    public static int PIPE_UNLIMITED_INSTANCES;
    public static int PIPE_TYPE_BYTE;
    public static int PIPE_TYPE_MESSAGE;
    public static int PIPE_READMODE_BYTE;
    public static int PIPE_READMODE_MESSAGE;
    public static UInt32 MEM_COMMIT;
    public static UInt32 MEM_DECOMMIT;
    public static int PAGE_READWRITE;
    public static int FILE_MAP_WRITE;
    public static int FILE_MAP_READ;
    public static int SDDL_REVISION_1;
    public static int SECURITY_ANONYMOUS;
    public static int SECURITY_QOS_PRESENT;
    public static int SECURITY_IDENTIFICATION;
    public static int FORMAT_MESSAGE_ALLOCATE_BUFFER;
    public static int FORMAT_MESSAGE_IGNORE_INSERTS;
    public static int FORMAT_MESSAGE_FROM_STRING;
    public static int FORMAT_MESSAGE_FROM_SYSTEM;
    public static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    public static int FORMAT_MESSAGE_FROM_HMODULE;
    public static int MQ_RECEIVE_ACCESS;
    public static int MQ_SEND_ACCESS;
    public static int MQ_MOVE_ACCESS;
    public static int MQ_DENY_NONE;
    public static int MQ_DENY_RECEIVE_SHARE;
    public static int MQ_ACTION_RECEIVE;
    public static int MQ_ACTION_PEEK_CURRENT;
    public static int MQ_ACTION_PEEK_NEXT;
    public static int MQ_LOOKUP_RECEIVE_CURRENT;
    public static int MQ_LOOKUP_PEEK_CURRENT;
    public static int MQ_NO_TRANSACTION;
    public static int MQ_MTS_TRANSACTION;
    public static int MQ_SINGLE_MESSAGE;
    public static int MQ_INFORMATION_PROPERTY;
    public static int MQ_INFORMATION_ILLEGAL_PROPERTY;
    public static int MQ_INFORMATION_PROPERTY_IGNORED;
    public static int MQ_INFORMATION_UNSUPPORTED_PROPERTY;
    public static int MQ_INFORMATION_DUPLICATE_PROPERTY;
    public static int MQ_INFORMATION_OPERATION_PENDING;
    public static int MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL;
    public static int MQ_INFORMATION_INTERNAL_USER_CERT_EXIST;
    public static int MQ_INFORMATION_OWNER_IGNORED;
    public static int MQ_ERROR;
    public static int MQ_ERROR_PROPERTY;
    public static int MQ_ERROR_QUEUE_NOT_FOUND;
    public static int MQ_ERROR_QUEUE_NOT_ACTIVE;
    public static int MQ_ERROR_QUEUE_EXISTS;
    public static int MQ_ERROR_INVALID_PARAMETER;
    public static int MQ_ERROR_INVALID_HANDLE;
    public static int MQ_ERROR_OPERATION_CANCELLED;
    public static int MQ_ERROR_SHARING_VIOLATION;
    public static int MQ_ERROR_SERVICE_NOT_AVAILABLE;
    public static int MQ_ERROR_MACHINE_NOT_FOUND;
    public static int MQ_ERROR_ILLEGAL_SORT;
    public static int MQ_ERROR_ILLEGAL_USER;
    public static int MQ_ERROR_NO_DS;
    public static int MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
    public static int MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    public static int MQ_ERROR_ILLEGAL_PROPERTY_VT;
    public static int MQ_ERROR_BUFFER_OVERFLOW;
    public static int MQ_ERROR_IO_TIMEOUT;
    public static int MQ_ERROR_ILLEGAL_CURSOR_ACTION;
    public static int MQ_ERROR_MESSAGE_ALREADY_RECEIVED;
    public static int MQ_ERROR_ILLEGAL_FORMATNAME;
    public static int MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    public static int MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR;
    public static int MQ_ERROR_SENDERID_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
    public static int MQ_ERROR_CANNOT_IMPERSONATE_CLIENT;
    public static int MQ_ERROR_ACCESS_DENIED;
    public static int MQ_ERROR_PRIVILEGE_NOT_HELD;
    public static int MQ_ERROR_INSUFFICIENT_RESOURCES;
    public static int MQ_ERROR_USER_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_MESSAGE_STORAGE_FAILED;
    public static int MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_INVALID_CERTIFICATE;
    public static int MQ_ERROR_CORRUPTED_INTERNAL_CERTIFICATE;
    public static int MQ_ERROR_INTERNAL_USER_CERT_EXIST;
    public static int MQ_ERROR_NO_INTERNAL_USER_CERT;
    public static int MQ_ERROR_CORRUPTED_SECURITY_DATA;
    public static int MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE;
    public static int MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    public static int MQ_ERROR_BAD_SECURITY_CONTEXT;
    public static int MQ_ERROR_COULD_NOT_GET_USER_SID;
    public static int MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO;
    public static int MQ_ERROR_ILLEGAL_MQCOLUMNS;
    public static int MQ_ERROR_ILLEGAL_PROPID;
    public static int MQ_ERROR_ILLEGAL_RELATION;
    public static int MQ_ERROR_ILLEGAL_PROPERTY_SIZE;
    public static int MQ_ERROR_ILLEGAL_RESTRICTION_PROPID;
    public static int MQ_ERROR_ILLEGAL_MQQUEUEPROPS;
    public static int MQ_ERROR_PROPERTY_NOTALLOWED;
    public static int MQ_ERROR_INSUFFICIENT_PROPERTIES;
    public static int MQ_ERROR_MACHINE_EXISTS;
    public static int MQ_ERROR_ILLEGAL_MQQMPROPS;
    public static int MQ_ERROR_DS_IS_FULL;
    public static int MQ_ERROR_DS_ERROR;
    public static int MQ_ERROR_INVALID_OWNER;
    public static int MQ_ERROR_UNSUPPORTED_ACCESS_MODE;
    public static int MQ_ERROR_RESULT_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_DELETE_CN_IN_USE;
    public static int MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER;
    public static int MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE;
    public static int MQ_ERROR_QUEUE_NOT_AVAILABLE;
    public static int MQ_ERROR_DTC_CONNECT;
    public static int MQ_ERROR_TRANSACTION_IMPORT;
    public static int MQ_ERROR_TRANSACTION_USAGE;
    public static int MQ_ERROR_TRANSACTION_SEQUENCE;
    public static int MQ_ERROR_MISSING_CONNECTOR_TYPE;
    public static int MQ_ERROR_STALE_HANDLE;
    public static int MQ_ERROR_TRANSACTION_ENLIST;
    public static int MQ_ERROR_QUEUE_DELETED;
    public static int MQ_ERROR_ILLEGAL_CONTEXT;
    public static int MQ_ERROR_ILLEGAL_SORT_PROPID;
    public static int MQ_ERROR_LABEL_TOO_LONG;
    public static int MQ_ERROR_LABEL_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_MQIS_SERVER_EMPTY;
    public static int MQ_ERROR_MQIS_READONLY_MODE;
    public static int MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL;
    public static int MQ_ERROR_ILLEGAL_OPERATION;
    public static int MQ_ERROR_WRITE_NOT_ALLOWED;
    public static int MQ_ERROR_WKS_CANT_SERVE_CLIENT;
    public static int MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW;
    public static int MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE;
    public static int MQ_ERROR_UNSUPPORTED_OPERATION;
    public static int MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED;
    public static int MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR;
    public static int MQ_ERROR_CERTIFICATE_NOT_PROVIDED;
    public static int MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED;
    public static int MQ_ERROR_CANNOT_CREATE_CERT_STORE;
    public static int MQ_ERROR_CANNOT_OPEN_CERT_STORE;
    public static int MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION;
    public static int MQ_ERROR_CANNOT_GRANT_ADD_GUID;
    public static int MQ_ERROR_CANNOT_LOAD_MSMQOCM;
    public static int MQ_ERROR_NO_ENTRY_POINT_MSMQOCM;
    public static int MQ_ERROR_NO_MSMQ_SERVERS_ON_DC;
    public static int MQ_ERROR_CANNOT_JOIN_DOMAIN;
    public static int MQ_ERROR_CANNOT_CREATE_ON_GC;
    public static int MQ_ERROR_GUID_NOT_MATCHING;
    public static int MQ_ERROR_PUBLIC_KEY_NOT_FOUND;
    public static int MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST;
    public static int MQ_ERROR_ILLEGAL_MQPRIVATEPROPS;
    public static int MQ_ERROR_NO_GC_IN_DOMAIN;
    public static int MQ_ERROR_NO_MSMQ_SERVERS_ON_GC;
    public static int MQ_ERROR_CANNOT_GET_DN;
    public static int MQ_ERROR_CANNOT_HASH_DATA_EX;
    public static int MQ_ERROR_CANNOT_SIGN_DATA_EX;
    public static int MQ_ERROR_CANNOT_CREATE_HASH_EX;
    public static int MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX;
    public static int MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS;
    public static int MQ_ERROR_NO_MQUSER_OU;
    public static int MQ_ERROR_CANNOT_LOAD_MQAD;
    public static int MQ_ERROR_CANNOT_LOAD_MQDSSRV;
    public static int MQ_ERROR_PROPERTIES_CONFLICT;
    public static int MQ_ERROR_MESSAGE_NOT_FOUND;
    public static int MQ_ERROR_CANT_RESOLVE_SITES;
    public static int MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS;
    public static int MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER;
    public static int MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS;
    public static int MQ_ERROR_MULTI_SORT_KEYS;
    public static int MQ_ERROR_GC_NEEDED;
    public static int MQ_ERROR_DS_BIND_ROOT_FOREST;
    public static int MQ_ERROR_DS_LOCAL_USER;
    public static int MQ_ERROR_Q_ADS_PROPERTY_NOT_SUPPORTED;
    public static int MQ_ERROR_BAD_XML_FORMAT;
    public static int MQ_ERROR_UNSUPPORTED_CLASS;
    public static int MQ_ERROR_UNINITIALIZED_OBJECT;
    public static int MQ_ERROR_CANNOT_CREATE_PSC_OBJECTS;
    public static int MQ_ERROR_CANNOT_UPDATE_PSC_OBJECTS;
    public static int MQ_ERROR_MESSAGE_LOCKED_UNDER_TRANSACTION;
    public static int MQMSG_DELIVERY_EXPRESS;
    public static int MQMSG_DELIVERY_RECOVERABLE;
    public static int PROPID_M_MSGID_SIZE;
    public static int PROPID_M_CORRELATIONID_SIZE;
    public static int MQ_MAX_MSG_LABEL_LEN;
    public static int MQMSG_JOURNAL_NONE;
    public static int MQMSG_DEADLETTER;
    public static int MQMSG_JOURNAL;
    public static int MQMSG_ACKNOWLEDGMENT_NONE;
    public static int MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
    public static int MQMSG_ACKNOWLEDGMENT_POS_RECEIVE;
    public static int MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL;
    public static int MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE;
    public static int MQMSG_CLASS_NORMAL;
    public static int MQMSG_CLASS_REPORT;
    public static int MQMSG_SENDERID_TYPE_NONE;
    public static int MQMSG_SENDERID_TYPE_SID;
    public static int MQMSG_AUTH_LEVEL_NONE;
    public static int MQMSG_AUTH_LEVEL_ALWAYS;
    public static int MQMSG_PRIV_LEVEL_NONE;
    public static int MQMSG_PRIV_LEVEL_BODY_BASE;
    public static int MQMSG_PRIV_LEVEL_BODY_ENHANCED;
    public static int MQMSG_TRACE_NONE;
    public static int MQMSG_SEND_ROUTE_TO_REPORT_QUEUE;
    public static int PROPID_M_BASE;
    public static int PROPID_M_CLASS;
    public static int PROPID_M_MSGID;
    public static int PROPID_M_CORRELATIONID;
    public static int PROPID_M_PRIORITY;
    public static int PROPID_M_DELIVERY;
    public static int PROPID_M_ACKNOWLEDGE;
    public static int PROPID_M_JOURNAL;
    public static int PROPID_M_APPSPECIFIC;
    public static int PROPID_M_BODY;
    public static int PROPID_M_BODY_SIZE;
    public static int PROPID_M_LABEL;
    public static int PROPID_M_LABEL_LEN;
    public static int PROPID_M_TIME_TO_REACH_QUEUE;
    public static int PROPID_M_TIME_TO_BE_RECEIVED;
    public static int PROPID_M_RESP_QUEUE;
    public static int PROPID_M_RESP_QUEUE_LEN;
    public static int PROPID_M_ADMIN_QUEUE;
    public static int PROPID_M_ADMIN_QUEUE_LEN;
    public static int PROPID_M_VERSION;
    public static int PROPID_M_SENDERID;
    public static int PROPID_M_SENDERID_LEN;
    public static int PROPID_M_SENDERID_TYPE;
    public static int PROPID_M_PRIV_LEVEL;
    public static int PROPID_M_AUTH_LEVEL;
    public static int PROPID_M_AUTHENTICATED;
    public static int PROPID_M_HASH_ALG;
    public static int PROPID_M_ENCRYPTION_ALG;
    public static int PROPID_M_SENDER_CERT;
    public static int PROPID_M_SENDER_CERT_LEN;
    public static int PROPID_M_SRC_MACHINE_ID;
    public static int PROPID_M_SENTTIME;
    public static int PROPID_M_ARRIVEDTIME;
    public static int PROPID_M_DEST_QUEUE;
    public static int PROPID_M_DEST_QUEUE_LEN;
    public static int PROPID_M_EXTENSION;
    public static int PROPID_M_EXTENSION_LEN;
    public static int PROPID_M_SECURITY_CONTEXT;
    public static int PROPID_M_CONNECTOR_TYPE;
    public static int PROPID_M_XACT_STATUS_QUEUE;
    public static int PROPID_M_XACT_STATUS_QUEUE_LEN;
    public static int PROPID_M_TRACE;
    public static int PROPID_M_BODY_TYPE;
    public static int PROPID_M_DEST_SYMM_KEY;
    public static int PROPID_M_DEST_SYMM_KEY_LEN;
    public static int PROPID_M_SIGNATURE;
    public static int PROPID_M_SIGNATURE_LEN;
    public static int PROPID_M_PROV_TYPE;
    public static int PROPID_M_PROV_NAME;
    public static int PROPID_M_PROV_NAME_LEN;
    public static int PROPID_M_FIRST_IN_XACT;
    public static int PROPID_M_LAST_IN_XACT;
    public static int PROPID_M_XACTID;
    public static int PROPID_M_AUTHENTICATED_EX;
    public static int PROPID_M_RESP_FORMAT_NAME;
    public static int PROPID_M_RESP_FORMAT_NAME_LEN;
    public static int PROPID_M_DEST_FORMAT_NAME;
    public static int PROPID_M_DEST_FORMAT_NAME_LEN;
    public static int PROPID_M_LOOKUPID;
    public static int PROPID_M_SOAP_ENVELOPE;
    public static int PROPID_M_SOAP_ENVELOPE_LEN;
    public static int PROPID_M_COMPOUND_MESSAGE;
    public static int PROPID_M_COMPOUND_MESSAGE_SIZE;
    public static int PROPID_M_SOAP_HEADER;
    public static int PROPID_M_SOAP_BODY;
    public static int PROPID_M_DEADLETTER_QUEUE;
    public static int PROPID_M_DEADLETTER_QUEUE_LEN;
    public static int PROPID_M_ABORT_COUNT;
    public static int PROPID_M_MOVE_COUNT;
    public static int PROPID_M_GROUP_ID;
    public static int PROPID_M_GROUP_ID_LEN;
    public static int PROPID_M_FIRST_IN_GROUP;
    public static int PROPID_M_LAST_IN_GROUP;
    public static int PROPID_M_LAST_MOVE_TIME;
    public static int PROPID_Q_BASE;
    public static int PROPID_Q_INSTANCE;
    public static int PROPID_Q_TYPE;
    public static int PROPID_Q_PATHNAME;
    public static int PROPID_Q_JOURNAL;
    public static int PROPID_Q_QUOTA;
    public static int PROPID_Q_BASEPRIORITY;
    public static int PROPID_Q_JOURNAL_QUOTA;
    public static int PROPID_Q_LABEL;
    public static int PROPID_Q_CREATE_TIME;
    public static int PROPID_Q_MODIFY_TIME;
    public static int PROPID_Q_AUTHENTICATE;
    public static int PROPID_Q_PRIV_LEVEL;
    public static int PROPID_Q_TRANSACTION;
    public static int PROPID_Q_PATHNAME_DNS;
    public static int PROPID_Q_MULTICAST_ADDRESS;
    public static int PROPID_Q_ADS_PATH;
    public static int PROPID_PC_BASE;
    public static int PROPID_PC_VERSION;
    public static int PROPID_PC_DS_ENABLED;
    public static int PROPID_MGMT_QUEUE_BASE;
    public static int PROPID_MGMT_QUEUE_SUBQUEUE_NAMES;
    public static int MQ_TRANSACTIONAL_NONE;
    public static int MQ_TRANSACTIONAL;
    public static int ALG_CLASS_HASH;
    public static int ALG_CLASS_DATA_ENCRYPT;
    public static int ALG_TYPE_ANY;
    public static int ALG_TYPE_STREAM;
    public static int ALG_TYPE_BLOCK;
    public static int ALG_SID_MD5;
    public static int ALG_SID_SHA1;
    public static int ALG_SID_SHA_256;
    public static int ALG_SID_SHA_512;
    public static int ALG_SID_RC4;
    public static int ALG_SID_AES;
    public static int CALG_MD5;
    public static int CALG_SHA1;
    public static int CALG_SHA_256;
    public static int CALG_SHA_512;
    public static int CALG_RC4;
    public static int CALG_AES;
    public static int PROV_RSA_AES;
    public static string MS_ENH_RSA_AES_PROV;
    public static ushort VT_NULL;
    public static ushort VT_BOOL;
    public static ushort VT_UI1;
    public static ushort VT_UI2;
    public static ushort VT_UI4;
    public static ushort VT_UI8;
    public static ushort VT_LPWSTR;
    public static ushort VT_VECTOR;
    public static UInt32 MAX_PATH;
    internal static Lazy`1<bool> IsTailoredApplication;
    private static UnsafeNativeMethods();
    [ReliabilityContractAttribute("3", "2")]
internal static int CloseHandle(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static int SspiFreeAuthIdentity(IntPtr ppAuthIdentity);
    [ReliabilityContractAttribute("3", "2")]
internal static UInt32 SspiExcludePackage(IntPtr AuthIdentity, string pszPackageName, IntPtr& ppNewAuthIdentity);
    internal static int ConnectNamedPipe(PipeHandle handle, NativeOverlapped* lpOverlapped);
    internal static PipeHandle CreateFile(string lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr lpSECURITY_ATTRIBUTES, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static SafeFileMappingHandle CreateFileMapping(IntPtr fileHandle, SECURITY_ATTRIBUTES securityAttributes, int protect, int sizeHigh, int sizeLow, string name);
    internal static PipeHandle CreateNamedPipe(string name, int openMode, int pipeMode, int maxInstances, int outBufSize, int inBufSize, int timeout, SECURITY_ATTRIBUTES securityAttributes);
    internal static int DisconnectNamedPipe(PipeHandle handle);
    internal static bool DuplicateHandle(IntPtr hSourceProcessHandle, PipeHandle hSourceHandle, SafeCloseHandle hTargetProcessHandle, IntPtr& lpTargetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions);
    internal static int FormatMessage(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr arguments);
    internal static int FormatMessage(int dwFlags, SafeLibraryHandle lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr arguments);
    internal static int GetOverlappedResult(PipeHandle handle, NativeOverlapped* overlapped, Int32& bytesTransferred, int wait);
    internal static int GetOverlappedResult(IntPtr handle, NativeOverlapped* overlapped, Int32& bytesTransferred, int wait);
    [SecuritySafeCriticalAttribute]
internal static bool HasOverlappedIoCompleted(NativeOverlapped* overlapped);
    internal static SafeFileMappingHandle OpenFileMapping(int access, bool inheritHandle, string name);
    internal static SafeViewOfFileHandle MapViewOfFile(SafeFileMappingHandle handle, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    [SuppressUnmanagedCodeSecurityAttribute]
public static int QueryPerformanceCounter(Int64& time);
    internal static int ReadFile(IntPtr handle, Byte* bytes, int numBytesToRead, IntPtr numBytesRead_mustBeZero, NativeOverlapped* overlapped);
    internal static int SetNamedPipeHandleState(PipeHandle handle, Int32& mode, IntPtr collectionCount, IntPtr collectionDataTimeout);
    internal static int WriteFile(IntPtr handle, Byte* bytes, int numBytesToWrite, IntPtr numBytesWritten_mustBeZero, NativeOverlapped* lpOverlapped);
    internal static bool GetNamedPipeClientProcessId(PipeHandle handle, Int32& id);
    internal static bool GetNamedPipeServerProcessId(PipeHandle handle, Int32& id);
    [ReliabilityContractAttribute("3", "2")]
internal static int UnmapViewOfFile(IntPtr lpBaseAddress);
    public static bool SetWaitableTimer(SafeWaitHandle handle, Int64& dueTime, int period, IntPtr mustBeZero, IntPtr mustBeZeroAlso, bool resume);
    public static SafeWaitHandle CreateWaitableTimer(IntPtr mustBeZero, bool manualReset, string timerName);
    internal static int WSARecv(IntPtr handle, WSABuffer* buffers, int bufferCount, Int32& bytesTransferred, Int32& socketFlags, NativeOverlapped* nativeOverlapped, IntPtr completionRoutine);
    internal static bool WSAGetOverlappedResult(IntPtr socketHandle, NativeOverlapped* overlapped, Int32& bytesTransferred, bool wait, UInt32& flags);
    internal static string GetComputerName(ComputerNameFormat nameType);
    internal static int DeriveAppContainerSidFromAppContainerName(string appContainerName, IntPtr& appContainerSid);
    internal static IntPtr FreeSid(IntPtr pSid);
    internal static int PackageFamilyNameFromFullName(string packageFullName, UInt32& packageFamilyNameLength, StringBuilder packageFamilyName);
    internal static bool GetAppContainerNamedObjectPath(IntPtr token, IntPtr appContainerSid, UInt32 objectPathLength, StringBuilder objectPath, UInt32& returnLength);
    internal static IntPtr GetCurrentProcess();
    internal static bool OpenProcessToken(IntPtr ProcessHandle, TokenAccessLevels DesiredAccess, SafeCloseHandle& TokenHandle);
    internal static SecurityIdentifier GetAppContainerSid(SafeCloseHandle tokenHandle);
    internal static int GetSessionId(SafeCloseHandle tokenHandle);
    internal static bool RunningInAppContainer(SafeCloseHandle tokenHandle);
    public static int MQOpenQueue(string formatName, int access, int shareMode, MsmqQueueHandle& handle);
    public static int MQBeginTransaction(ITransaction& refTransaction);
    [ReliabilityContractAttribute("3", "2")]
public static int MQCloseQueue(IntPtr handle);
    public static int MQSendMessage(MsmqQueueHandle handle, IntPtr properties, IntPtr transaction);
    public static int MQSendMessage(MsmqQueueHandle handle, IntPtr properties, IDtcTransaction transaction);
    public static int MQReceiveMessage(MsmqQueueHandle handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr cursorHandle, IntPtr transaction);
    public static int MQReceiveMessage(IntPtr handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr cursorHandle, IntPtr transaction);
    public static int MQReceiveMessage(MsmqQueueHandle handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr cursorHandle, IDtcTransaction transaction);
    public static int MQReceiveMessage(IntPtr handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr cursorHandle, IDtcTransaction transaction);
    public static int MQReceiveMessage(MsmqQueueHandle handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, MQReceiveCallback receiveCallback, IntPtr cursorHandle, IntPtr transaction);
    public static int MQReceiveMessage(IntPtr handle, int timeout, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr cursorHandle, ITransaction transaction);
    public static int MQReceiveMessageByLookupId(MsmqQueueHandle handle, long lookupId, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IDtcTransaction transaction);
    public static int MQReceiveMessageByLookupId(MsmqQueueHandle handle, long lookupId, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, IntPtr transaction);
    public static int MQReceiveMessageByLookupId(MsmqQueueHandle handle, long lookupId, int action, IntPtr properties, NativeOverlapped* nativeOverlapped, IntPtr receiveCallback, ITransaction transaction);
    public static int MQGetPrivateComputerInformation(string computerName, IntPtr properties);
    public static int MQMarkMessageRejected(MsmqQueueHandle handle, long lookupId);
    public static int MQMoveMessage(MsmqQueueHandle sourceQueueHandle, MsmqQueueHandle destinationQueueHandle, long lookupId, IntPtr transaction);
    public static int MQMoveMessage(MsmqQueueHandle sourceQueueHandle, MsmqQueueHandle destinationQueueHandle, long lookupId, IDtcTransaction transaction);
    public static int MQGetOverlappedResult(NativeOverlapped* nativeOverlapped);
    public static int MQGetQueueProperties(string formatName, IntPtr properties);
    public static int MQPathNameToFormatName(string pathName, StringBuilder formatName, Int32& count);
    public static int MQMgmtGetInfo(string computerName, string objectName, IntPtr properties);
    public static void MQFreeMemory(IntPtr nativeBuffer);
    public static int GetHandleInformation(MsmqQueueHandle handle, Int32& flags);
    public static bool GlobalMemoryStatusEx(MEMORYSTATUSEX& lpBuffer);
    [ReliabilityContractAttribute("3", "2")]
internal static IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, UInt32 flAllocationType, UInt32 flProtect);
    [ReliabilityContractAttribute("3", "2")]
internal static bool VirtualFree(IntPtr lpAddress, UIntPtr dwSize, UInt32 dwFreeType);
    internal static IntPtr GetProcAddress(SafeLibraryHandle hModule, string lpProcName);
    internal static SafeLibraryHandle LoadLibrary(string libFilename);
    internal static int BCryptGetFipsAlgorithmMode(Boolean& pfEnabled);
}
internal class System.ServiceModel.Channels.UriCache : object {
    public Uri CreateUri(string uriString);
}
internal class System.ServiceModel.Channels.UriGenerator : object {
    public UriGenerator(string scheme);
    public UriGenerator(string scheme, string delimiter);
    public string Next();
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.UriHelper : object {
    [ExtensionAttribute]
internal static string NormalizedHost(Uri uri);
    [ExtensionAttribute]
internal static string NormalizedAbsoluteUri(Uri uri);
}
internal class System.ServiceModel.Channels.UriPrefixTable`1 : object {
    public int Count { get; }
    public UriPrefixTable`1(bool includePortInComparison);
    public UriPrefixTable`1(bool includePortInComparison, bool useWeakReferences);
    internal UriPrefixTable`1(UriPrefixTable`1<TItem> objectToClone);
    public int get_Count();
    public bool IsRegistered(BaseUriWithWildcard key);
    public IEnumerable`1<KeyValuePair`2<BaseUriWithWildcard, TItem>> GetAll();
    public bool TryLookupUri(Uri uri, HostNameComparisonMode hostNameComparisonMode, TItem& item);
    public void RegisterUri(Uri uri, HostNameComparisonMode hostNameComparisonMode, TItem item);
    public void UnregisterUri(Uri uri, HostNameComparisonMode hostNameComparisonMode);
}
internal class System.ServiceModel.Channels.UriTraceRecord : TraceRecord {
    public UriTraceRecord(Uri uri);
    internal virtual void WriteTo(XmlWriter xml);
}
public class System.ServiceModel.Channels.UseManagedPresentationBindingElement : BindingElement {
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
public class System.ServiceModel.Channels.UseManagedPresentationBindingElementImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IPolicyImportExtension.ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
}
internal static class System.ServiceModel.Channels.UseManagedPresentationPolicyStrings : object {
    public static string UseManagedPresentationName;
    public static string RequireFederatedIdentityProvisioningName;
    public static string UseManagedPresentationNamespace;
    public static string UseManagedPresentationPrefix;
}
internal class System.ServiceModel.Channels.UtilityExtension : object {
    public static int AcceptableMissDistance;
    public bool IsAccurate { get; }
    public UInt32 LinkUtility { get; }
    internal TypedMessageConverter MessageConverter { get; }
    public object ThisLock { get; }
    public int PendingMessages { get; }
    [CompilerGeneratedAttribute]
public void add_UtilityInfoReceived(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UtilityInfoReceived(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UtilityInfoSent(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UtilityInfoSent(EventHandler value);
    public bool get_IsAccurate();
    public UInt32 get_LinkUtility();
    internal TypedMessageConverter get_MessageConverter();
    public sealed virtual void Attach(IPeerNeighbor host);
    public static void OnNeighborConnected(IPeerNeighbor neighbor);
    public static void OnNeighborClosed(IPeerNeighbor neighbor);
    public sealed virtual void Detach(IPeerNeighbor host);
    public object get_ThisLock();
    public static void OnMessageSent(IPeerNeighbor neighbor);
    public static void OnEndSend(IPeerNeighbor neighbor, FloodAsyncResult fresult);
    public void OnEndSend(FloodAsyncResult fresult);
    public static void ProcessLinkUtility(IPeerNeighbor neighbor, UtilityInfo umessage);
    public static UInt32 UpdateLinkUtility(IPeerNeighbor neighbor, bool useful);
    public UInt32 UpdateLinkUtility(bool useful);
    public void FlushAcknowledge();
    internal static void ReportCacheMiss(IPeerNeighbor neighbor, int missedBy);
    public int get_PendingMessages();
    public void BeginCheckPoint(PruneNeighborCallback pruneCallback);
}
[MessageContractAttribute]
internal class System.ServiceModel.Channels.UtilityInfo : object {
    public UInt32 Useful { get; }
    public UInt32 Total { get; }
    public UtilityInfo(UInt32 useful, UInt32 total);
    public UInt32 get_Useful();
    public UInt32 get_Total();
    public bool HasBody();
}
internal class System.ServiceModel.Channels.ViaStringDecoder : StringDecoder {
    public Uri ValueAsUri { get; }
    public ViaStringDecoder(int sizeQuota);
    protected virtual Exception OnSizeQuotaExceeded(int size);
    protected virtual void OnComplete(string value);
    public Uri get_ValueAsUri();
}
internal class System.ServiceModel.Channels.WaitAsyncResult : AsyncResult {
    public WaitAsyncResult(TimeSpan timeout, bool throwTimeoutException, AsyncCallback callback, object state);
    public void Begin();
    public static bool End(IAsyncResult result);
    protected virtual string GetTimeoutString(TimeSpan timeout);
    public void OnAborted(CommunicationObject communicationObject);
    public void OnFaulted(CommunicationObject communicationObject);
    public void OnSignaled();
    protected virtual void OnTimerElapsed(object state);
}
internal abstract class System.ServiceModel.Channels.WebSocketConnectionHandler : HttpMessageHandler {
    protected internal virtual HttpResponseMessage AcceptWebSocket(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal virtual bool AcceptWebSocket(HttpRequestMessage request);
    protected static HttpResponseMessage GetUpgradeRequiredResponseMessage(HttpRequestMessage request);
    protected static HttpResponseMessage GetBadRequestResponseMessage(HttpRequestMessage request);
    protected static HttpResponseMessage GetWebSocketAcceptedResponseMessage(HttpRequestMessage request);
    protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal static class System.ServiceModel.Channels.WebSocketDefaults : object {
    internal static WebSocketTransportUsage TransportUsage;
    internal static bool CreateNotificationOnConnection;
    internal static string DefaultKeepAliveIntervalString;
    internal static TimeSpan DefaultKeepAliveInterval;
    internal static int BufferSize;
    internal static int MinReceiveBufferSize;
    internal static int MinSendBufferSize;
    internal static bool DisablePayloadMasking;
    internal static WebSocketMessageType DefaultWebSocketMessageType;
    internal static string SubProtocol;
    internal static int DefaultMaxPendingConnections;
    internal static int MaxPendingConnectionsCpuCount;
    internal static string WebSocketConnectionHeaderValue;
    internal static string WebSocketUpgradeHeaderValue;
    private static WebSocketDefaults();
}
internal static class System.ServiceModel.Channels.WebSocketHelper : object {
    internal static int OperationNotStarted;
    internal static int OperationFinished;
    internal static string SecWebSocketKey;
    internal static string SecWebSocketVersion;
    internal static string SecWebSocketProtocol;
    internal static string SecWebSocketAccept;
    internal static string MaxPendingConnectionsString;
    internal static string WebSocketTransportSettingsString;
    internal static string CloseOperation;
    internal static string SendOperation;
    internal static string ReceiveOperation;
    internal static Char[] ProtocolSeparators;
    private static WebSocketHelper();
    internal static string ComputeAcceptHeader(string webSocketKey);
    internal static int ComputeClientBufferSize(long maxReceivedMessageSize);
    internal static int ComputeServerBufferSize(long maxReceivedMessageSize);
    internal static int GetReceiveBufferSize(long maxReceivedMessageSize);
    internal static bool UseWebSocketTransport(WebSocketTransportUsage transportUsage, bool isContractDuplex);
    internal static Uri GetWebSocketUri(Uri httpUri);
    internal static bool IsWebSocketUri(Uri uri);
    internal static Uri NormalizeWsSchemeWithHttpScheme(Uri uri);
    internal static bool TryParseSubProtocol(string subProtocolValue, List`1& subProtocolList);
    internal static bool IsSubProtocolInvalid(string protocol, String& invalidChar);
    internal static string GetCurrentVersion();
    internal static WebSocketTransportSettings GetRuntimeWebSocketSettings(WebSocketTransportSettings settings);
    internal static bool OSSupportsWebSockets();
    internal static void ThrowCorrectException(Exception ex);
    internal static void ThrowCorrectException(Exception ex, TimeSpan timeout, string operation);
    internal static Exception ConvertAndTraceException(Exception ex);
    internal static Exception ConvertAndTraceException(Exception ex, TimeSpan timeout, string operation);
    internal static Exception ConvertAggregateExceptionToCommunicationException(AggregateException ex);
    internal static void ThrowExceptionOnTaskFailure(Task task, TimeSpan timeout, string operation);
    internal static TimeoutException GetTimeoutException(Exception innerException, TimeSpan timeout, string operation);
}
public class System.ServiceModel.Channels.WebSocketMessageProperty : object {
    public static string Name;
    public WebSocketContext WebSocketContext { get; }
    public string SubProtocol { get; }
    public WebSocketMessageType MessageType { get; public set; }
    public ReadOnlyDictionary`2<string, object> OpeningHandshakeProperties { get; }
    internal WebSocketMessageProperty(WebSocketContext context, string subProtocol, WebSocketMessageType incomingMessageType, ReadOnlyDictionary`2<string, object> properties);
    public WebSocketContext get_WebSocketContext();
    public string get_SubProtocol();
    public WebSocketMessageType get_MessageType();
    public void set_MessageType(WebSocketMessageType value);
    public ReadOnlyDictionary`2<string, object> get_OpeningHandshakeProperties();
}
internal abstract class System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel : TransportDuplexSessionChannel {
    protected WebSocket WebSocket { get; protected set; }
    protected WebSocketTransportSettings WebSocketSettings { get; }
    protected TransferMode TransferMode { get; }
    protected int MaxBufferSize { get; }
    protected ITransportFactorySettings TransportFactorySettings { get; }
    protected Byte[] InternalBuffer { get; protected set; }
    unknown bool ShouldDisposeWebSocketAfterClosed {protected set; }
    public WebSocketTransportDuplexSessionChannel(HttpChannelListener channelListener, EndpointAddress localAddress, Uri localVia, ConnectionBufferPool bufferPool);
    public WebSocketTransportDuplexSessionChannel(HttpChannelFactory`1<IDuplexSessionChannel> channelFactory, EndpointAddress remoteAddresss, Uri via, ConnectionBufferPool bufferPool);
    private static WebSocketTransportDuplexSessionChannel();
    protected WebSocket get_WebSocket();
    protected void set_WebSocket(WebSocket value);
    protected WebSocketTransportSettings get_WebSocketSettings();
    protected TransferMode get_TransferMode();
    protected int get_MaxBufferSize();
    protected ITransportFactorySettings get_TransportFactorySettings();
    protected Byte[] get_InternalBuffer();
    protected void set_InternalBuffer(Byte[] value);
    protected void set_ShouldDisposeWebSocketAfterClosed(bool value);
    protected virtual void OnAbort();
    public virtual T GetProperty();
    protected virtual void CompleteClose(TimeSpan timeout);
    protected Byte[] TakeBuffer();
    protected virtual void CloseOutputSessionCore(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    protected virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, WaitCallback callback, object state);
    protected virtual void FinishWritingMessage();
    protected virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, WaitCallback callback, object state);
    protected virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, WaitCallback callback, object state);
    protected virtual void OnSendCore(Message message, TimeSpan timeout);
    protected virtual ArraySegment`1<byte> EncodeMessage(Message message);
    protected void Cleanup();
    protected virtual void OnCleanup();
}
public class System.ServiceModel.Channels.WebSocketTransportSettings : object {
    public static string ConnectionOpenedAction;
    public static string BinaryMessageReceivedAction;
    public static string TextMessageReceivedAction;
    public static string SoapContentTypeHeader;
    public static string BinaryEncoderTransferModeHeader;
    internal static string WebSocketMethod;
    internal static string SoapSubProtocol;
    internal static string TransportUsageMethodName;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WebSocketTransportUsage TransportUsage { get; public set; }
    [DefaultValueAttribute("False")]
public bool CreateNotificationOnConnection { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan KeepAliveInterval { get; public set; }
    [DefaultValueAttribute("")]
public string SubProtocol { get; public set; }
    [DefaultValueAttribute("False")]
public bool DisablePayloadMasking { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxPendingConnections { get; public set; }
    public WebSocketTransportUsage get_TransportUsage();
    public void set_TransportUsage(WebSocketTransportUsage value);
    public bool get_CreateNotificationOnConnection();
    public void set_CreateNotificationOnConnection(bool value);
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    public string get_SubProtocol();
    public void set_SubProtocol(string value);
    public bool get_DisablePayloadMasking();
    public void set_DisablePayloadMasking(bool value);
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    public sealed virtual bool Equals(WebSocketTransportSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal WebSocketTransportSettings Clone();
    internal TimeSpan GetEffectiveKeepAliveInterval();
}
public enum System.ServiceModel.Channels.WebSocketTransportUsage : Enum {
    public int value__;
    public static WebSocketTransportUsage WhenDuplex;
    public static WebSocketTransportUsage Always;
    public static WebSocketTransportUsage Never;
}
internal static class System.ServiceModel.Channels.WebSocketTransportUsageHelper : object {
    internal static bool IsDefined(WebSocketTransportUsage value);
    internal static void Validate(WebSocketTransportUsage value);
}
[MessageContractAttribute]
internal class System.ServiceModel.Channels.WelcomeInfo : object {
    public ulong NodeId { get; }
    public IList`1<Referral> Referrals { get; }
    public WelcomeInfo(ulong nodeId, Referral[] referrals);
    public ulong get_NodeId();
    public IList`1<Referral> get_Referrals();
    public bool HasBody();
}
public class System.ServiceModel.Channels.WindowsStreamSecurityBindingElement : StreamUpgradeBindingElement {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ProtectionLevel { get; public set; }
    protected WindowsStreamSecurityBindingElement(WindowsStreamSecurityBindingElement elementToBeCloned);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
    public virtual StreamUpgradeProvider BuildServerStreamUpgradeProvider(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal static void ImportPolicy(MetadataImporter importer, PolicyConversionContext policyContext);
    public sealed virtual XmlElement GetTransportTokenAssertion();
    private sealed virtual override void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.WindowsStreamSecurityUpgradeProvider : StreamSecurityUpgradeProvider {
    public string Scheme { get; }
    internal bool ExtractGroupsForWindowsAccounts { get; }
    public EndpointIdentity Identity { get; }
    internal IdentityVerifier IdentityVerifier { get; }
    public ProtectionLevel ProtectionLevel { get; }
    public WindowsStreamSecurityUpgradeProvider(WindowsStreamSecurityBindingElement bindingElement, BindingContext context, bool isClient);
    public string get_Scheme();
    internal bool get_ExtractGroupsForWindowsAccounts();
    public virtual EndpointIdentity get_Identity();
    internal IdentityVerifier get_IdentityVerifier();
    public ProtectionLevel get_ProtectionLevel();
    public virtual StreamUpgradeAcceptor CreateUpgradeAcceptor();
    public virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
}
public class System.ServiceModel.Channels.WrappedOptions : object {
    public bool WrappedFlag { get; public set; }
    public bool get_WrappedFlag();
    public void set_WrappedFlag(bool value);
}
internal static class System.ServiceModel.Channels.WSDualHttpBindingDefaults : object {
    internal static WSMessageEncoding MessageEncoding;
}
internal static class System.ServiceModel.Channels.WSHttpBindingDefaults : object {
    internal static WSMessageEncoding MessageEncoding;
}
internal class System.ServiceModel.Channels.Wsrm11Index : WsrmIndex {
    internal static MessagePartSpecification SignedReliabilityMessageParts { get; }
    internal Wsrm11Index(AddressingVersion addressingVersion);
    internal static MessagePartSpecification get_SignedReliabilityMessageParts();
    protected virtual ActionHeader GetActionHeader(string element);
}
internal class System.ServiceModel.Channels.WsrmAcknowledgmentHeader : WsrmMessageHeader {
    public XmlDictionaryString DictionaryName { get; }
    public WsrmAcknowledgmentHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal static void WriteAckRanges(XmlDictionaryWriter writer, ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceId, SequenceRangeCollection ranges);
}
internal class System.ServiceModel.Channels.WsrmAcknowledgmentInfo : WsrmHeaderInfo {
    public int BufferRemaining { get; }
    public bool Final { get; }
    public SequenceRangeCollection Ranges { get; }
    public UniqueId SequenceID { get; }
    public int get_BufferRemaining();
    public bool get_Final();
    public SequenceRangeCollection get_Ranges();
    public UniqueId get_SequenceID();
    internal static void ReadAck(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, UniqueId& sequenceId, SequenceRangeCollection& rangeCollection, Boolean& final);
    public static WsrmAcknowledgmentInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmAckRequestedHeader : WsrmMessageHeader {
    public XmlDictionaryString DictionaryName { get; }
    public WsrmAckRequestedHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID);
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmAckRequestedInfo : WsrmHeaderInfo {
    public UniqueId SequenceID { get; }
    public WsrmAckRequestedInfo(UniqueId sequenceID, MessageHeaderInfo header);
    public UniqueId get_SequenceID();
    public static WsrmAckRequestedInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal abstract class System.ServiceModel.Channels.WsrmFault : MessageFault {
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public bool IsRemote { get; }
    public FaultReason Reason { get; }
    public string Subcode { get; }
    protected WsrmFault(bool isSenderFault, string subcode, string faultReason, string exceptionMessage);
    protected WsrmFault(FaultCode code, string subcode, FaultReason reason);
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public bool get_IsRemote();
    public virtual FaultReason get_Reason();
    public string get_Subcode();
    public virtual CommunicationException CreateException();
    public static CommunicationException CreateException(WsrmFault fault);
    public Message CreateMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion);
    protected abstract virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected abstract virtual bool Get12HasDetail();
    protected string GetExceptionMessage();
    protected ReliableMessagingVersion GetReliableMessagingVersion();
    protected abstract virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected void SetReliableMessagingVersion(ReliableMessagingVersion reliableMessagingVersion);
    internal void WriteDetail(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.WsrmFeb2005Index : WsrmIndex {
    internal static MessagePartSpecification SignedReliabilityMessageParts { get; }
    internal WsrmFeb2005Index(AddressingVersion addressingVersion);
    internal static MessagePartSpecification get_SignedReliabilityMessageParts();
    protected virtual ActionHeader GetActionHeader(string element);
}
internal abstract class System.ServiceModel.Channels.WsrmHeaderFault : WsrmFault {
    public bool FaultsInput { get; }
    public bool FaultsOutput { get; }
    public UniqueId SequenceID { get; protected set; }
    protected WsrmHeaderFault(bool isSenderFault, string subcode, string faultReason, string exceptionMessage, UniqueId sequenceID, bool faultsInput, bool faultsOutput);
    protected WsrmHeaderFault(FaultCode code, string subcode, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion, bool faultsInput, bool faultsOutput);
    protected WsrmHeaderFault(FaultCode code, string subcode, FaultReason reason, bool faultsInput, bool faultsOutput);
    public bool get_FaultsInput();
    public bool get_FaultsOutput();
    public UniqueId get_SequenceID();
    protected void set_SequenceID(UniqueId value);
    protected virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected virtual bool Get12HasDetail();
    protected virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    public static bool TryCreateFault11(ReliableMessagingVersion reliableMessagingVersion, Message message, MessageFault fault, int index, WsrmHeaderFault& wsrmFault);
    public static bool TryCreateFault12(ReliableMessagingVersion reliableMessagingVersion, Message message, MessageFault fault, WsrmHeaderFault& wsrmFault);
}
internal abstract class System.ServiceModel.Channels.WsrmHeaderInfo : object {
    public MessageHeaderInfo MessageHeader { get; }
    protected WsrmHeaderInfo(MessageHeaderInfo messageHeader);
    public MessageHeaderInfo get_MessageHeader();
}
internal abstract class System.ServiceModel.Channels.WsrmIndex : object {
    internal static ActionHeader GetAckRequestedActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    protected abstract virtual ActionHeader GetActionHeader(string element);
    internal static ActionHeader GetCloseSequenceActionHeader(AddressingVersion addressingVersion);
    internal static ActionHeader GetCloseSequenceResponseActionHeader(AddressingVersion addressingVersion);
    internal static ActionHeader GetCreateSequenceActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetCreateSequenceActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static XmlDictionaryString GetCreateSequenceResponseAction(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetCreateSequenceResponseActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetFaultActionString(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static XmlDictionaryString GetNamespace(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetNamespaceString(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetSequenceAcknowledgementActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetSequenceAcknowledgementActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static MessagePartSpecification GetSignedReliabilityMessageParts(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetTerminateSequenceActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetTerminateSequenceActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetTerminateSequenceResponseActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetTerminateSequenceResponseActionHeader(AddressingVersion addressingVersion);
}
internal abstract class System.ServiceModel.Channels.WsrmMessageHeader : DictionaryHeader {
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public string Namespace { get; }
    protected ReliableMessagingVersion ReliableMessagingVersion { get; }
    protected WsrmMessageHeader(ReliableMessagingVersion reliableMessagingVersion);
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    public virtual string get_Namespace();
    protected ReliableMessagingVersion get_ReliableMessagingVersion();
}
internal class System.ServiceModel.Channels.WsrmMessageInfo : object {
    public WsrmAcknowledgmentInfo AcknowledgementInfo { get; }
    public WsrmAckRequestedInfo AckRequestedInfo { get; }
    public string Action { get; }
    public CloseSequenceInfo CloseSequenceInfo { get; }
    public CloseSequenceResponseInfo CloseSequenceResponseInfo { get; }
    public CreateSequenceInfo CreateSequenceInfo { get; }
    public CreateSequenceResponseInfo CreateSequenceResponseInfo { get; }
    public Exception FaultException { get; public set; }
    public MessageFault FaultInfo { get; }
    public Message FaultReply { get; public set; }
    public Message Message { get; }
    public MessageFault MessageFault { get; }
    public Exception ParsingException { get; }
    public WsrmSequencedMessageInfo SequencedMessageInfo { get; }
    public TerminateSequenceInfo TerminateSequenceInfo { get; }
    public TerminateSequenceResponseInfo TerminateSequenceResponseInfo { get; }
    public WsrmUsesSequenceSSLInfo UsesSequenceSSLInfo { get; }
    public WsrmUsesSequenceSTRInfo UsesSequenceSTRInfo { get; }
    public WsrmHeaderFault WsrmHeaderFault { get; }
    public WsrmAcknowledgmentInfo get_AcknowledgementInfo();
    public WsrmAckRequestedInfo get_AckRequestedInfo();
    public string get_Action();
    public CloseSequenceInfo get_CloseSequenceInfo();
    public CloseSequenceResponseInfo get_CloseSequenceResponseInfo();
    public CreateSequenceInfo get_CreateSequenceInfo();
    public CreateSequenceResponseInfo get_CreateSequenceResponseInfo();
    public Exception get_FaultException();
    public void set_FaultException(Exception value);
    public MessageFault get_FaultInfo();
    public Message get_FaultReply();
    public void set_FaultReply(Message value);
    public Message get_Message();
    public MessageFault get_MessageFault();
    public Exception get_ParsingException();
    public WsrmSequencedMessageInfo get_SequencedMessageInfo();
    public TerminateSequenceInfo get_TerminateSequenceInfo();
    public TerminateSequenceResponseInfo get_TerminateSequenceResponseInfo();
    public WsrmUsesSequenceSSLInfo get_UsesSequenceSSLInfo();
    public WsrmUsesSequenceSTRInfo get_UsesSequenceSTRInfo();
    public WsrmHeaderFault get_WsrmHeaderFault();
    public static Exception CreateInternalFaultException(Message faultReply, string message, Exception inner);
    public static WsrmMessageInfo Get(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, IChannel channel, ISession session, Message message);
    public static WsrmMessageInfo Get(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, IChannel channel, ISession session, Message message, bool csrOnly);
}
internal abstract class System.ServiceModel.Channels.WsrmRequestInfo : object {
    public UniqueId MessageId { get; }
    public EndpointAddress ReplyTo { get; }
    public string RequestName { get; }
    public UniqueId get_MessageId();
    public EndpointAddress get_ReplyTo();
    public abstract virtual string get_RequestName();
    protected void SetMessageId(MessageVersion messageVersion, MessageHeaders headers);
    protected void SetReplyTo(MessageVersion messageVersion, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.WsrmRequiredFault : WsrmFault {
    public WsrmRequiredFault(string faultReason);
    protected virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected virtual bool Get12HasDetail();
    protected virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.WsrmSequencedMessageHeader : WsrmMessageHeader {
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public WsrmSequencedMessageHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID, long sequenceNumber, bool lastMessage);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmSequencedMessageInfo : WsrmHeaderInfo {
    public UniqueId SequenceID { get; }
    public long SequenceNumber { get; }
    public bool LastMessage { get; }
    public UniqueId get_SequenceID();
    public long get_SequenceNumber();
    public bool get_LastMessage();
    public static WsrmSequencedMessageInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmSequenceFaultHeader : WsrmMessageHeader {
    public WsrmFault Fault { get; }
    public XmlDictionaryString DictionaryName { get; }
    public string Subcode { get; }
    public WsrmSequenceFaultHeader(ReliableMessagingVersion reliableMessagingVersion, WsrmFault fault);
    public WsrmFault get_Fault();
    public virtual XmlDictionaryString get_DictionaryName();
    public string get_Subcode();
    public static XmlDictionaryReader GetReaderAtDetailContents(string detailName, string detailNamespace, XmlDictionaryReader headerReader, ReliableMessagingVersion reliableMessagingVersion);
    public static XmlDictionaryReader GetReaderAtDetailContents11(string detailName, string detailNamespace, XmlDictionaryReader headerReader);
    public static XmlDictionaryReader GetReaderAtDetailContentsFeb2005(string detailName, string detailNamespace, XmlDictionaryReader headerReader);
    public static string GetSubcode(XmlDictionaryReader headerReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSSLInfo : WsrmHeaderInfo {
    public static WsrmUsesSequenceSSLInfo ReadHeader(XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSTRHeader : WsrmMessageHeader {
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public virtual bool get_MustUnderstand();
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSTRInfo : WsrmHeaderInfo {
    public static WsrmUsesSequenceSTRInfo ReadHeader(XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal static class System.ServiceModel.Channels.WsrmUtilities : object {
    public static TimeSpan CalculateKeepAliveInterval(TimeSpan inactivityTimeout, int maxRetryCount);
    internal static UniqueId NextSequenceId();
    internal static void AddAcknowledgementHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, SequenceRangeCollection ranges, bool final);
    internal static void AddAcknowledgementHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    internal static void AddAckRequestedHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id);
    internal static void AddSequenceHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, long sequenceNumber, bool isLast);
    internal static void AssertWsrm11(ReliableMessagingVersion reliableMessagingVersion);
    internal static Message CreateAcknowledgmentMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    internal static Message CreateAckRequestedMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, UniqueId id);
    internal static Message CreateCloseSequenceResponse(MessageVersion messageVersion, UniqueId messageId, UniqueId inputId);
    internal static Message CreateCreateSequenceResponse(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, bool duplex, CreateSequenceInfo createSequenceInfo, bool ordered, UniqueId inputId, EndpointAddress acceptAcksTo);
    internal static Message CreateCSRefusedCommunicationFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    internal static Message CreateCSRefusedProtocolFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    internal static Message CreateCSRefusedServerTooBusyFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    public static Exception CreateCSFaultException(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, Message message, IChannel innerChannel);
    internal static Message CreateEndpointNotFoundFault(MessageVersion version, string reason);
    internal static Message CreateTerminateMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id);
    internal static Message CreateTerminateMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id, long last);
    internal static Message CreateTerminateResponseMessage(MessageVersion version, UniqueId messageId, UniqueId sequenceId);
    internal static UniqueId GetInputId(WsrmMessageInfo info);
    internal static UniqueId GetOutputId(ReliableMessagingVersion reliableMessagingVersion, WsrmMessageInfo info);
    internal static bool IsWsrmAction(ReliableMessagingVersion reliableMessagingVersion, string action);
    public static void ReadEmptyElement(XmlDictionaryReader reader);
    public static UniqueId ReadIdentifier(XmlDictionaryReader reader, ReliableMessagingVersion reliableMessagingVersion);
    public static long ReadSequenceNumber(XmlDictionaryReader reader);
    public static long ReadSequenceNumber(XmlDictionaryReader reader, bool allowZero);
    public static WsrmFault ValidateCloseSequenceResponse(ChannelReliableSession session, UniqueId messageId, WsrmMessageInfo info, long last);
    public static bool ValidateCreateSequence(WsrmMessageInfo info, ReliableChannelListenerBase`1<TChannel> listener, IChannel channel, EndpointAddress& acksTo);
    public static WsrmFault ValidateFinalAck(ChannelReliableSession session, WsrmMessageInfo info, long last);
    public static WsrmFault ValidateFinalAckExists(ChannelReliableSession session, WsrmAcknowledgmentInfo ackInfo);
    public static WsrmFault ValidateTerminateSequenceResponse(ChannelReliableSession session, UniqueId messageId, WsrmMessageInfo info, long last);
    public static bool ValidateWsrmRequest(ChannelReliableSession session, WsrmRequestInfo info, IReliableChannelBinder binder, RequestContext context);
    public static void WriteIdentifier(XmlDictionaryWriter writer, ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceId);
    public static string UseStrings();
}
internal class System.ServiceModel.Channels.XmlAttributeHolder : ValueType {
    private string prefix;
    private string ns;
    private string localName;
    private string value;
    public static XmlAttributeHolder[] emptyArray;
    public string Prefix { get; }
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    public XmlAttributeHolder(string prefix, string localName, string ns, string value);
    private static XmlAttributeHolder();
    public string get_Prefix();
    public string get_NamespaceUri();
    public string get_LocalName();
    public string get_Value();
    public void WriteTo(XmlWriter writer);
    public static void WriteAttributes(XmlAttributeHolder[] attributes, XmlWriter writer);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader, Int32& maxSizeOfHeaders);
    public static string GetAttribute(XmlAttributeHolder[] attributes, string localName, string ns);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerBodyWriter : BodyWriter {
    public XmlObjectSerializerBodyWriter(object body, XmlObjectSerializer serializer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerFault : MessageFault {
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    public XmlObjectSerializerFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerHeader : MessageHeader {
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    public XmlObjectSerializerHeader(string name, string ns, object objectToSerialize, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual string get_Actor();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.XmlReaderBodyWriter : BodyWriter {
    internal bool IsFault { get; }
    public XmlReaderBodyWriter(XmlDictionaryReader reader, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.XmlSerializerImportOptions : object {
    public CodeCompileUnit CodeCompileUnit { get; }
    public CodeDomProvider CodeProvider { get; public set; }
    public string ClrNamespace { get; public set; }
    public WebReferenceOptions WebReferenceOptions { get; public set; }
    public XmlSerializerImportOptions(CodeCompileUnit codeCompileUnit);
    private static XmlSerializerImportOptions();
    public CodeCompileUnit get_CodeCompileUnit();
    public CodeDomProvider get_CodeProvider();
    public void set_CodeProvider(CodeDomProvider value);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    public WebReferenceOptions get_WebReferenceOptions();
    public void set_WebReferenceOptions(WebReferenceOptions value);
}
public class System.ServiceModel.ChannelTerminatedException : CommunicationException {
    public ChannelTerminatedException(string message);
    public ChannelTerminatedException(string message, Exception innerException);
    protected ChannelTerminatedException(SerializationInfo info, StreamingContext context);
}
public abstract class System.ServiceModel.ClientBase`1 : object {
    protected TChannel Channel { get; }
    public static CacheSetting CacheSetting { get; public set; }
    public ChannelFactory`1<TChannel> ChannelFactory { get; }
    public ClientCredentials ClientCredentials { get; }
    public CommunicationState State { get; }
    public IClientChannel InnerChannel { get; }
    public ServiceEndpoint Endpoint { get; }
    protected ClientBase`1(string endpointConfigurationName);
    protected ClientBase`1(string endpointConfigurationName, string remoteAddress);
    protected ClientBase`1(string endpointConfigurationName, EndpointAddress remoteAddress);
    protected ClientBase`1(Binding binding, EndpointAddress remoteAddress);
    protected ClientBase`1(ServiceEndpoint endpoint);
    protected ClientBase`1(InstanceContext callbackInstance);
    protected ClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName);
    protected ClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, string remoteAddress);
    protected ClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    protected ClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    protected ClientBase`1(InstanceContext callbackInstance, ServiceEndpoint endpoint);
    private static ClientBase`1();
    protected T GetDefaultValueForInitialization();
    protected TChannel get_Channel();
    public static CacheSetting get_CacheSetting();
    public static void set_CacheSetting(CacheSetting value);
    public ChannelFactory`1<TChannel> get_ChannelFactory();
    public ClientCredentials get_ClientCredentials();
    public sealed virtual CommunicationState get_State();
    public IClientChannel get_InnerChannel();
    public ServiceEndpoint get_Endpoint();
    public sealed virtual void Open();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public void DisplayInitializationUI();
    protected virtual TChannel CreateChannel();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opening(EventHandler value);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
    internal IAsyncResult BeginFactoryOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndFactoryOpen(IAsyncResult result);
    internal IAsyncResult BeginChannelOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndChannelOpen(IAsyncResult result);
    internal IAsyncResult BeginFactoryClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndFactoryClose(IAsyncResult result);
    internal IAsyncResult BeginChannelClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndChannelClose(IAsyncResult result);
    protected void InvokeAsync(BeginOperationDelegate<TChannel> beginOperationDelegate, Object[] inValues, EndOperationDelegate<TChannel> endOperationDelegate, SendOrPostCallback operationCompletedCallback, object userState);
}
public class System.ServiceModel.ClientCredentialsSecurityTokenManager : SecurityTokenManager {
    public ClientCredentials ClientCredentials { get; }
    public ClientCredentialsSecurityTokenManager(ClientCredentials clientCredentials);
    public ClientCredentials get_ClientCredentials();
    protected internal bool IsIssuedSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    internal SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement, bool disableInfoCard);
    protected SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityVersion version);
    public virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
    internal FederatedClientCredentialsParameters FindFederatedChannelParameters(SecurityTokenRequirement tokenRequirement);
}
internal class System.ServiceModel.CloseCollectionAsyncResult : AsyncResult {
    public CloseCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static CloseCollectionAsyncResult();
    public static void End(IAsyncResult result);
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.BindingOption : Enum {
    public int value__;
    public static BindingOption NoBinding;
    public static BindingOption BindingToPoolThread;
}
internal enum System.ServiceModel.ComIntegration.Bitness : Enum {
    public int value__;
    public static Bitness Bitness32;
    public static Bitness Bitness64;
}
internal static class System.ServiceModel.ComIntegration.CatalogUtil : object {
    internal static String[] GetRoleMembers(ComCatalogObject application, ComCatalogCollection rolesCollection);
    internal static ComCatalogObject FindApplication(Guid applicationId);
}
internal class System.ServiceModel.ComIntegration.ChannelCredentials : object {
    protected IProvideChannelBuilderSettings channelBuilderSettings;
    internal ChannelCredentials(IProvideChannelBuilderSettings channelBuilderSettings);
    internal static ComProxy Create(IntPtr outer, IProvideChannelBuilderSettings channelBuilderSettings);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetWindowsCredential(string domain, string userName, string password, int impersonationLevel, bool allowNtlm);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetUserNameCredential(string userName, string password);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetServiceCertificateAuthentication(string storeLocation, string revocationMode, string certificationValidationMode);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetClientCertificateFromStore(string storeLocation, string storeName, string findType, object findValue);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetClientCertificateFromStoreByName(string subjectName, string storeLocation, string storeName);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetClientCertificateFromFile(string fileName, string password, string keyStorageFlags);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetDefaultServiceCertificateFromStore(string storeLocation, string storeName, string findType, object findValue);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetDefaultServiceCertificateFromStoreByName(string subjectName, string storeLocation, string storeName);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetDefaultServiceCertificateFromFile(string fileName, string password, string keyStorageFlags);
    private sealed virtual override void System.ServiceModel.ComIntegration.IChannelCredentials.SetIssuedToken(string localIssuerAddres, string localIssuerBindingType, string localIssuerBinding);
}
internal class System.ServiceModel.ComIntegration.ChannelOptions : object {
    protected IProvideChannelBuilderSettings channelBuilderSettings;
    internal ChannelOptions(IProvideChannelBuilderSettings channelBuilderSettings);
    internal static ComProxy Create(IntPtr outer, IProvideChannelBuilderSettings channelBuilderSettings);
    private sealed virtual override void System.IDisposable.Dispose();
}
[FlagsAttribute]
internal enum System.ServiceModel.ComIntegration.CLSCTX : Enum {
    public int value__;
    public static CLSCTX INPROC_SERVER;
    public static CLSCTX INPROC_HANDLER;
    public static CLSCTX LOCAL_SERVER;
    public static CLSCTX INPROC_SERVER16;
    public static CLSCTX REMOTE_SERVER;
    public static CLSCTX INPROC_HANDLER16;
    public static CLSCTX RESERVED1;
    public static CLSCTX RESERVED2;
    public static CLSCTX RESERVED3;
    public static CLSCTX RESERVED4;
    public static CLSCTX NO_CODE_DOWNLOAD;
    public static CLSCTX RESERVED5;
    public static CLSCTX NO_CUSTOM_MARSHAL;
    public static CLSCTX ENABLE_CODE_DOWNLOAD;
    public static CLSCTX NO_FAILURE_LOG;
    public static CLSCTX DISABLE_AAA;
    public static CLSCTX ENABLE_AAA;
    public static CLSCTX FROM_DEFAULT_CONTEXT;
    public static CLSCTX ACTIVATE_32_BIT_SERVER;
    public static CLSCTX ACTIVATE_64_BIT_SERVER;
    public static CLSCTX INPROC;
    public static CLSCTX SERVER;
    public static CLSCTX ALL;
}
internal enum System.ServiceModel.ComIntegration.COMAdminIsolationLevel : Enum {
    public int value__;
    public static COMAdminIsolationLevel Any;
    public static COMAdminIsolationLevel ReadUncommitted;
    public static COMAdminIsolationLevel ReadCommitted;
    public static COMAdminIsolationLevel RepeatableRead;
    public static COMAdminIsolationLevel Serializable;
}
internal enum System.ServiceModel.ComIntegration.COMAdminThreadingModel : Enum {
    public int value__;
    public static COMAdminThreadingModel Apartment;
    public static COMAdminThreadingModel Free;
    public static COMAdminThreadingModel Main;
    public static COMAdminThreadingModel Both;
    public static COMAdminThreadingModel Neutral;
    public static COMAdminThreadingModel NotSpecified;
}
internal class System.ServiceModel.ComIntegration.ComCatalogCollection : object {
    public int Count { get; }
    public ComCatalogCollection(ICatalogCollection catalogCollection);
    public int get_Count();
    public ComCatalogObject Item(int index);
    public Enumerator GetEnumerator();
}
internal class System.ServiceModel.ComIntegration.ComCatalogObject : object {
    public string Name { get; }
    public ComCatalogObject(ICatalogObject catalogObject, ICatalogCollection catalogCollection);
    public object GetValue(string key);
    public string get_Name();
    public ComCatalogCollection GetCollection(string collectionName);
}
internal class System.ServiceModel.ComIntegration.ComIntegrationManifestGenerator : MarshalByRefObject {
    internal static void GenerateManifestCollectionFile(Guid[] manifests, string strAssemblyManifestFileName, string assemblyName);
    internal static void GenerateWin32ManifestFile(Type[] aTypes, string strAssemblyManifestFileName, string assemblyName);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusActivitySchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusActivitySchema(Guid activityID, Guid logicalThreadID, int managedThreadID, int unmanagedThreadID);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusActivityTrace : object {
    internal static Guid IID_IComThreadingInfo;
    internal static Guid IID_IObjectContextInfo;
    private static ComPlusActivityTrace();
    public static void Trace(TraceEventType type, int traceCode, string description);
}
internal class System.ServiceModel.ComIntegration.ComPlusAuthorization : object {
    public String[] ServiceRoleMembers { get; }
    public String[] ContractRoleMembers { get; }
    public String[] OperationRoleMembers { get; }
    public CommonSecurityDescriptor SecurityDescriptor { get; }
    public ComPlusAuthorization(String[] serviceRoleMembers, String[] contractRoleMembers, String[] operationRoleMembers);
    private static ComPlusAuthorization();
    public String[] get_ServiceRoleMembers();
    public String[] get_ContractRoleMembers();
    public String[] get_OperationRoleMembers();
    public CommonSecurityDescriptor get_SecurityDescriptor();
    public bool IsAuthorizedForOperation(WindowsIdentity clientIdentity);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusChannelCreatedSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusChannelCreatedSchema(Uri address, string contract);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusChannelCreatedTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Uri address, Type contractType);
}
internal class System.ServiceModel.ComIntegration.ComPlusContractBehavior : object {
    public ComPlusContractBehavior(ServiceInfo info);
    public sealed virtual void Validate(ContractDescription description, ServiceEndpoint endpoint);
    public sealed virtual void AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    public sealed virtual void ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    public sealed virtual void ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusDispatchMethodSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusDispatchMethodSchema(string name, List`1<ParamInfo> paramList, ParamInfo returnValue);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusDispatchMethodTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Dictionary`2<UInt32, MethodInfo> dispToOperationDescription);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusDllHostInitializerAddingHostSchema : ComPlusDllHostInitializerSchema {
    internal string EventId { get; }
    public ComPlusDllHostInitializerAddingHostSchema(Guid appid, Guid clsid, string behaviorConfiguration, string serviceType, string address, string bindingConfiguration, string bindingName, string bindingNamespace, string bindingSectionName, string contractType);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusDllHostInitializerSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusDllHostInitializerSchema(Guid appid);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
    public virtual string ToString();
}
internal static class System.ServiceModel.ComIntegration.ComPlusDllHostInitializerTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Guid appid);
    public static void Trace(TraceEventType type, int traceCode, string description, Guid appid, Guid clsid, ServiceElement service);
}
internal class System.ServiceModel.ComIntegration.ComPlusInstanceContextInitializer : object {
    private static ComPlusInstanceContextInitializer();
    public ComPlusInstanceContextInitializer(ServiceInfo info);
    public sealed virtual void Initialize(InstanceContext instanceContext, Message message);
    public void OnInstanceContextClosing(object sender, EventArgs args);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusInstanceCreationRequestSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusInstanceCreationRequestSchema(Guid appid, Guid clsid, Uri from, Guid incomingTransactionID, string requestingIdentity);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
    public virtual string ToString();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusInstanceCreationSuccessSchema : ComPlusInstanceCreationRequestSchema {
    internal string EventId { get; }
    public ComPlusInstanceCreationSuccessSchema(Guid appid, Guid clsid, Uri from, Guid incomingTransactionID, string requestingIdentity, int instanceID);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusInstanceCreationTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, Message message, Guid incomingTransactionID);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, Message message, int instanceID, Guid incomingTransactionID);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, InstanceContext instanceContext, int instanceID);
}
internal class System.ServiceModel.ComIntegration.ComPlusInstanceProvider : object {
    public ComPlusInstanceProvider(ServiceInfo info);
    private static ComPlusInstanceProvider();
    public sealed virtual object GetInstance(InstanceContext instanceContext);
    public sealed virtual object GetInstance(InstanceContext instanceContext, Message message);
    public sealed virtual void ReleaseInstance(InstanceContext instanceContext, object instance);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusInstanceReleasedSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusInstanceReleasedSchema(Guid appid, Guid clsid, int instanceID);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal class System.ServiceModel.ComIntegration.ComPlusListenerInitializationException : Exception {
    public ComPlusListenerInitializationException(string message);
    public ComPlusListenerInitializationException(string message, Exception inner);
    protected ComPlusListenerInitializationException(SerializationInfo info, StreamingContext context);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMethodCallContextTxSchema : ComPlusMethodCallSchema {
    internal string EventId { get; }
    public ComPlusMethodCallContextTxSchema(Uri from, Guid appid, Guid clsid, Guid iid, string action, int instanceID, int managedThreadID, int unmanagedThreadID, string requestingIdentity, Guid contextTransactionID);
    internal virtual string get_EventId();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMethodCallNewTxSchema : ComPlusMethodCallSchema {
    internal string EventId { get; }
    public ComPlusMethodCallNewTxSchema(Uri from, Guid appid, Guid clsid, Guid iid, string action, int instanceID, int managedThreadID, int unmanagedThreadID, string requestingIdentity, Guid newTransactionID);
    internal virtual string get_EventId();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMethodCallSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusMethodCallSchema(Uri from, Guid appid, Guid clsid, Guid iid, string action, int instanceID, int managedThreadID, int unmanagedThreadID, string requestingIdentity);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
    public virtual string ToString();
}
internal static class System.ServiceModel.ComIntegration.ComPlusMethodCallTrace : object {
    private static ComPlusMethodCallTrace();
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, Uri from, string action, string callerIdentity, Guid iid, int instanceID, bool traceContextTransaction);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, Uri from, string action, string callerIdentity, Guid iid, int instanceID, Guid incomingTransactionID, Guid currentTransactionID);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, Uri from, string action, string callerIdentity, Guid iid, int instanceID, Guid guidIncomingTransactionID);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMethodCallTxMismatchSchema : ComPlusMethodCallSchema {
    internal string EventId { get; }
    public ComPlusMethodCallTxMismatchSchema(Uri from, Guid appid, Guid clsid, Guid iid, string action, int instanceID, int managedThreadID, int unmanagedThreadID, string requestingIdentity, Guid incomingTransactionID, Guid currentTransactionID);
    internal virtual string get_EventId();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMexBuilderMetadataRetrievedEndpoint : TraceRecord {
    internal string EventId { get; }
    public ComPlusMexBuilderMetadataRetrievedEndpoint(ServiceEndpoint endpoint);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMexBuilderMetadataRetrievedSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusMexBuilderMetadataRetrievedSchema(ComPlusMexBuilderMetadataRetrievedEndpoint[] endpoints);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusMexChannelBuilderMexCompleteTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceEndpointCollection serviceEndpointsRetrieved);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusMexChannelBuilderSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusMexChannelBuilderSchema(string contract, string contractNamespace, string binding, string bindingNamespace, string address);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusMexChannelBuilderTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, ContractDescription contract, Binding binding, string address);
}
internal class System.ServiceModel.ComIntegration.ComPlusProxyProviderException : Exception {
    public ComPlusProxyProviderException(string message, Exception inner);
}
internal class System.ServiceModel.ComIntegration.ComPlusServerSecurity : object {
    public ComPlusServerSecurity(WindowsIdentity clientIdentity, bool shouldUseCallContext);
    protected virtual override void Finalize();
    public sealed virtual bool GetPerimeterFlag();
    public sealed virtual void SetPerimeterFlag(bool flag);
    public sealed virtual void QueryBlanket(IntPtr authnSvc, IntPtr authzSvc, IntPtr serverPrincipalName, IntPtr authnLevel, IntPtr impLevel, IntPtr clientPrincipalName, IntPtr Capabilities);
    public sealed virtual int ImpersonateClient();
    public sealed virtual int RevertToSelf();
    public sealed virtual bool IsImpersonating();
    private sealed virtual override void System.IDisposable.Dispose();
    public void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.ComIntegration.ComPlusServiceHost : ServiceHostBase {
    protected void Initialize(Guid clsid, ServiceElement service, ComCatalogObject applicationObject, ComCatalogObject classObject, HostingMode hostingMode);
    protected virtual void ApplyConfiguration();
    protected virtual ServiceDescription CreateDescription(IDictionary`2& implementedContracts);
    protected virtual void InitializeRuntime();
    protected virtual void OnClose(TimeSpan timeout);
    protected void VerifyFunctionality();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusServiceHostCreatedServiceContractSchema : ComPlusServiceHostSchema {
    internal string EventId { get; }
    public ComPlusServiceHostCreatedServiceContractSchema(Guid appid, Guid clsid, XmlQualifiedName contractQname, string contract);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusServiceHostCreatedServiceEndpointSchema : ComPlusServiceHostSchema {
    internal string EventId { get; }
    public ComPlusServiceHostCreatedServiceEndpointSchema(Guid appid, Guid clsid, string contract, Uri address, string binding);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusServiceHostSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusServiceHostSchema(Guid appid, Guid clsid);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
    public virtual string ToString();
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusServiceHostStartedServiceDetailsSchema : ComPlusServiceHostSchema {
    internal string EventId { get; }
    public ComPlusServiceHostStartedServiceDetailsSchema(Guid appid, Guid clsid, ServiceDescription wsdl);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusServiceHostTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, ContractDescription contract);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, ServiceDescription service);
    public static void Trace(TraceEventType type, int traceCode, string description, ServiceInfo info, ServiceEndpointCollection endpointCollection);
}
internal class System.ServiceModel.ComIntegration.ComPlusServiceLoader : object {
    public ComPlusServiceLoader(ServiceInfo info);
    public ServiceDescription Load(ServiceHostBase host);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusServiceMonikerSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusServiceMonikerSchema(string address, string contract, string contractNamespace, ServiceDescription wsdl, string spnIdentity, string upnIdentity, string dnsIdentity, string binding, string bindingConfiguration, string bindingNamespace, string mexAddress, string mexBinding, string mexBindingConfiguration, string mexSpnIdentity, string mexUpnIdentity, string mexDnsIdentity);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusServiceMonikerTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Dictionary`2<MonikerAttribute, string> propertyTable);
}
internal class System.ServiceModel.ComIntegration.ComPlusSynchronizationContext : SynchronizationContext {
    public ComPlusSynchronizationContext(IServiceActivity activity, bool postSynchronous);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public void Dispose();
}
internal class System.ServiceModel.ComIntegration.ComPlusThreadInitializer : object {
    public ComPlusThreadInitializer(ContractDescription contract, DispatchOperation operation, ServiceInfo info);
    public sealed virtual object BeforeInvoke(InstanceContext instanceContext, IClientChannel channel, Message message);
    public sealed virtual void AfterInvoke(object correlationState);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusTLBImportConverterEventSchema : ComPlusTLBImportSchema {
    internal string EventId { get; }
    public ComPlusTLBImportConverterEventSchema(Guid iid, Guid typeLibraryID, ImporterEventKind eventKind, int eventCode, string eventMessage);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusTLBImportFromAssemblySchema : ComPlusTLBImportSchema {
    internal string EventId { get; }
    public ComPlusTLBImportFromAssemblySchema(Guid iid, Guid typeLibraryID, string assembly);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusTLBImportSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusTLBImportSchema(Guid iid, Guid typeLibraryID);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
    public virtual string ToString();
}
internal static class System.ServiceModel.ComIntegration.ComPlusTLBImportTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Guid iid, Guid typeLibraryID);
    public static void Trace(TraceEventType type, int traceCode, string description, Guid iid, Guid typeLibraryID, string assembly);
    public static void Trace(TraceEventType type, int traceCode, string description, Guid iid, Guid typeLibraryID, ImporterEventKind eventKind, int eventCode, string eventMsg);
}
internal static class System.ServiceModel.ComIntegration.ComPlusTraceRecord : object {
    public static void SerializeRecord(XmlWriter xmlWriter, object o);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusTxProxySchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusTxProxySchema(Guid appid, Guid clsid, Guid transactionID, int instanceID);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusTxProxyTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, Guid appid, Guid clsid, Guid transactionID, int instanceID);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusTypedChannelBuilderSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusTypedChannelBuilderSchema(string contract, string binding);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusTypedChannelBuilderTrace : object {
    public static void Trace(TraceEventType type, int v, string description, Type contractType, Binding binding);
}
internal class System.ServiceModel.ComIntegration.ComPlusTypeLoader : object {
    public ComPlusTypeLoader(ServiceInfo info);
    public sealed virtual ContractDescription ResolveContract(string contractTypeString);
}
internal static class System.ServiceModel.ComIntegration.ComPlusTypeValidator : object {
    private static ComPlusTypeValidator();
    public static bool IsValidInterface(Guid iid);
    public static bool IsValidParameter(Type type, ICustomAttributeProvider attributeProvider, bool allowReferences);
}
[DataContractAttribute]
internal class System.ServiceModel.ComIntegration.ComPlusWsdlChannelBuilderSchema : TraceRecord {
    internal string EventId { get; }
    public ComPlusWsdlChannelBuilderSchema(XmlQualifiedName bindingQname, XmlQualifiedName contractQname, XmlQualifiedName serviceQname, string importedContract, string importedBinding, XmlSchema schema);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xmlWriter);
}
internal static class System.ServiceModel.ComIntegration.ComPlusWsdlChannelBuilderTrace : object {
    public static void Trace(TraceEventType type, int traceCode, string description, XmlQualifiedName bindingQname, XmlQualifiedName contractQname, ServiceDescription wsdl, ContractDescription contract, Binding binding, XmlSchemas schemas);
}
internal class System.ServiceModel.ComIntegration.ComProxy : object {
    internal ComProxy(IntPtr inner, IDisposable disp);
    internal static ComProxy Create(IntPtr outer, object obj, IDisposable disp);
    internal void QueryInterface(Guid& riid, IntPtr& tearoff);
    private sealed virtual override void System.IDisposable.Dispose();
    public ComProxy Clone();
}
[FlagsAttribute]
internal enum System.ServiceModel.ComIntegration.ComRights : Enum {
    public int value__;
    public static ComRights EXECUTE;
    public static ComRights EXECUTE_LOCAL;
    public static ComRights EXECUTE_REMOTE;
    public static ComRights ACTIVATE_LOCAL;
    public static ComRights ACTIVATE_REMOTE;
}
internal class System.ServiceModel.ComIntegration.ContractInfo : object {
    public string Name { get; }
    public Guid IID { get; }
    public String[] InterfaceRoleMembers { get; }
    public List`1<OperationInfo> Operations { get; }
    public ContractInfo(Guid iid, ServiceEndpointElement endpoint, ComCatalogObject interfaceObject, ComCatalogObject application);
    public string get_Name();
    public Guid get_IID();
    public String[] get_InterfaceRoleMembers();
    public List`1<OperationInfo> get_Operations();
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.CSC_SxsConfig : Enum {
    public int value__;
    public static CSC_SxsConfig CSC_NoSxs;
    public static CSC_SxsConfig CSC_InheritSxs;
    public static CSC_SxsConfig CSC_NewSxs;
}
[GuidAttribute("ecabb0c8-7f19-11d2-978e-0000f8757e2a")]
internal class System.ServiceModel.ComIntegration.CServiceConfig : object {
}
internal class System.ServiceModel.ComIntegration.DataContractSurrogateForPersistWrapper : object {
    public DataContractSurrogateForPersistWrapper(Guid[] allowedClasses);
    public sealed virtual Type GetDataContractType(Type type);
    public sealed virtual object GetObjectToSerialize(object obj, Type targetType);
    public sealed virtual object GetDeserializedObject(object obj, Type targetType);
    public sealed virtual object GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType);
    public sealed virtual object GetCustomDataToExport(Type clrType, Type dataContractType);
    public sealed virtual void GetKnownCustomDataTypes(Collection`1<Type> customDataTypes);
    public sealed virtual Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData);
    public sealed virtual CodeTypeDeclaration ProcessImportedType(CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit);
}
internal class System.ServiceModel.ComIntegration.DispatchProxy : object {
    internal static ComProxy Create(IntPtr outer, ContractDescription contract, IProvideChannelBuilderSettings channelBuilderSettings);
    private sealed virtual override void System.ServiceModel.ComIntegration.IPseudoDispatch.GetIDsOfNames(UInt32 cNames, String[] rgszNames, IntPtr pDispID);
    private sealed virtual override int System.ServiceModel.ComIntegration.IPseudoDispatch.Invoke(UInt32 dispIdMember, UInt32 cArgs, UInt32 cNamedArgs, IntPtr rgvarg, UInt32[] rgdispidNamedArgs, IntPtr pVarResult, IntPtr pExcepInfo, UInt32& pArgErr);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ServiceModel.ComIntegration.DllHostedComPlusServiceHost : ComPlusServiceHost {
    public DllHostedComPlusServiceHost(Guid clsid, ServiceElement service, ComCatalogObject applicationObject, ComCatalogObject classObject);
}
[ComVisibleAttribute("True")]
[GuidAttribute("59856830-3ECB-4D29-9CFE-DDD0F74B96A2")]
public class System.ServiceModel.ComIntegration.DllHostInitializer : object {
    public sealed virtual void Startup(object punkProcessControl);
    public sealed virtual void Shutdown();
}
internal class System.ServiceModel.ComIntegration.DllHostInitializeWorker : object {
    public static void PingProc(object o);
    public void Startup(IProcessInitControl control);
    public void Shutdown();
}
[FlagsAttribute]
internal enum System.ServiceModel.ComIntegration.DSFlags : Enum {
    public UInt32 value__;
    public static DSFlags DS_FORCE_REDISCOVERY;
    public static DSFlags DS_DIRECTORY_SERVICE_REQUIRED;
    public static DSFlags DS_DIRECTORY_SERVICE_PREFERRED;
    public static DSFlags DS_GC_SERVER_REQUIRED;
    public static DSFlags DS_PDC_REQUIRED;
    public static DSFlags DS_BACKGROUND_ONLY;
    public static DSFlags DS_IP_REQUIRED;
    public static DSFlags DS_KDC_REQUIRED;
    public static DSFlags DS_TIMESERV_REQUIRED;
    public static DSFlags DS_WRITABLE_REQUIRED;
    public static DSFlags DS_GOOD_TIMESERV_PREFERRED;
    public static DSFlags DS_AVOID_SELF;
    public static DSFlags DS_ONLY_LDAP_NEEDED;
    public static DSFlags DS_IS_FLAT_NAME;
    public static DSFlags DS_IS_DNS_NAME;
    public static DSFlags DS_TRY_NEXTCLOSEST_SITE;
    public static DSFlags DS_DIRECTORY_SERVICE_6_REQUIRED;
    public static DSFlags DS_WEB_SERVICE_REQUIRED;
    public static DSFlags DS_DIRECTORY_SERVICE_8_REQUIRED;
    public static DSFlags DS_RETURN_DNS_NAME;
    public static DSFlags DS_RETURN_FLAT_NAME;
}
internal enum System.ServiceModel.ComIntegration.DtcIsolationLevel : Enum {
    public int value__;
    public static DtcIsolationLevel ISOLATIONLEVEL_UNSPECIFIED;
    public static DtcIsolationLevel ISOLATIONLEVEL_CHAOS;
    public static DtcIsolationLevel ISOLATIONLEVEL_READUNCOMMITTED;
    public static DtcIsolationLevel ISOLATIONLEVEL_BROWSE;
    public static DtcIsolationLevel ISOLATIONLEVEL_CURSORSTABILITY;
    public static DtcIsolationLevel ISOLATIONLEVEL_READCOMMITTED;
    public static DtcIsolationLevel ISOLATIONLEVEL_REPEATABLEREAD;
    public static DtcIsolationLevel ISOLATIONLEVEL_SERIALIZABLE;
    public static DtcIsolationLevel ISOLATIONLEVEL_ISOLATED;
}
internal class System.ServiceModel.ComIntegration.EmitterCache : object {
    internal static EmitterCache TypeEmitter { get; }
    private static EmitterCache();
    internal static EmitterCache get_TypeEmitter();
    internal Type FindOrCreateType(Type interfaceType);
}
internal static class System.ServiceModel.ComIntegration.Error : object {
    public static Exception ActivationAccessDenied();
    public static Exception QFENotPresent();
    public static Exception DirectoryNotFound(string directory);
    public static Exception CannotAccessDirectory(string directory);
    public static Exception ManifestCreationFailed(string file, string error);
    public static Exception ActivationFailure();
    public static Exception UnexpectedThreadingModel();
    public static Exception DllHostInitializerFoundNoServices();
    public static Exception ServiceMonikerSupportLoadFailed(string dllname);
    public static Exception CallAccessDenied();
    public static Exception RequiresWindowsSecurity();
    public static Exception NoAsyncOperationsAllowed();
    public static Exception DuplicateOperation();
    public static Exception InconsistentSessionRequirements();
    public static Exception TransactionMismatch();
    public static Exception ListenerInitFailed(string message);
    public static Exception ListenerInitFailed(string message, Exception inner);
}
internal enum System.ServiceModel.ComIntegration.EXTENDED_NAME_FORMAT : Enum {
    public int value__;
    public static EXTENDED_NAME_FORMAT NameUnknown;
    public static EXTENDED_NAME_FORMAT NameFullyQualifiedDN;
    public static EXTENDED_NAME_FORMAT NameSamCompatible;
    public static EXTENDED_NAME_FORMAT NameDisplay;
    public static EXTENDED_NAME_FORMAT NameUniqueId;
    public static EXTENDED_NAME_FORMAT NameCanonical;
    public static EXTENDED_NAME_FORMAT NameUserPrincipalName;
    public static EXTENDED_NAME_FORMAT NameCanonicalEx;
    public static EXTENDED_NAME_FORMAT NameServicePrincipalName;
    public static EXTENDED_NAME_FORMAT NameDnsDomainName;
}
internal class System.ServiceModel.ComIntegration.GENERIC_MAPPING : object {
    internal UInt32 genericRead;
    internal UInt32 genericWrite;
    internal UInt32 genericExecute;
    internal UInt32 genericAll;
}
internal enum System.ServiceModel.ComIntegration.HostingMode : Enum {
    public int value__;
    public static HostingMode ComPlus;
    public static HostingMode WebHostOutOfProcess;
    public static HostingMode WebHostInProcess;
}
internal static class System.ServiceModel.ComIntegration.HR : object {
    internal static int S_OK;
    internal static int S_FALSE;
    internal static int MK_E_SYNTAX;
    internal static int E_INVALIDARG;
    internal static int E_UNEXPECTED;
    internal static int DISP_E_UNKNOWNINTERFACE;
    internal static int DISP_E_MEMBERNOTFOUND;
    internal static int DISP_E_PARAMNOTFOUND;
    internal static int DISP_E_TYPEMISMATCH;
    internal static int DISP_E_UNKNOWNNAME;
    internal static int DISP_E_NONAMEDARGS;
    internal static int DISP_E_BADVARTYPE;
    internal static int DISP_E_EXCEPTION;
    internal static int DISP_E_OVERFLOW;
    internal static int DISP_E_BADINDEX;
    internal static int DISP_E_UNKNOWNLCID;
    internal static int DISP_E_ARRAYISLOCKED;
    internal static int DISP_E_BADPARAMCOUNT;
    internal static int DISP_E_PARAMNOTOPTIONAL;
    internal static int DISP_E_BADCALLEE;
    internal static int DISP_E_NOTACOLLECTION;
    internal static int DISP_E_DIVBYZERO;
    internal static int DISP_E_BUFFERTOOSMALL;
    internal static int RPC_E_TOO_LATE;
    internal static int RPC_NT_BINDING_HAS_NO_AUTH;
    internal static int E_FAIL;
    internal static int COMADMIN_E_PARTITIONS_DISABLED;
    internal static int CONTEXT_E_NOTRANSACTION;
    internal static int ERROR_BAD_IMPERSONATION_LEVEL;
    private static HR();
}
[GuidAttribute("790C6E0B-9194-4cc9-9426-A48A63185696")]
[InterfaceTypeAttribute("0")]
internal interface System.ServiceModel.ComIntegration.ICatalog2 {
    [DispIdAttribute("1")]
public abstract virtual object GetCollection(string bstrCollName);
    [DispIdAttribute("2")]
public abstract virtual object Connect(string connectStr);
    [DispIdAttribute("3")]
public abstract virtual int MajorVersion();
    [DispIdAttribute("4")]
public abstract virtual int MinorVersion();
    [DispIdAttribute("5")]
public abstract virtual object GetCollectionByQuery(string collName, Object[]& aQuery);
    [DispIdAttribute("6")]
public abstract virtual void ImportComponent(string bstrApplIdOrName, string bstrCLSIDOrProgId);
    [DispIdAttribute("7")]
public abstract virtual void InstallComponent(string bstrApplIdOrName, string bstrDLL, string bstrTLB, string bstrPSDLL);
    [DispIdAttribute("8")]
public abstract virtual void ShutdownApplication(string bstrApplIdOrName);
    [DispIdAttribute("9")]
public abstract virtual void ExportApplication(string bstrApplIdOrName, string bstrApplicationFile, int lOptions);
    [DispIdAttribute("10")]
public abstract virtual void InstallApplication(string bstrApplicationFile, string bstrDestinationDirectory, int lOptions, string bstrUserId, string bstrPassword, string bstrRSN);
    [DispIdAttribute("11")]
public abstract virtual void StopRouter();
    [DispIdAttribute("12")]
public abstract virtual void RefreshRouter();
    [DispIdAttribute("13")]
public abstract virtual void StartRouter();
    [DispIdAttribute("14")]
public abstract virtual void Reserved1();
    [DispIdAttribute("15")]
public abstract virtual void Reserved2();
    [DispIdAttribute("16")]
public abstract virtual void InstallMultipleComponents(string bstrApplIdOrName, Object[]& fileNames, Object[]& CLSIDS);
    [DispIdAttribute("17")]
public abstract virtual void GetMultipleComponentsInfo(string bstrApplIdOrName, object varFileNames, Object[]& varCLSIDS, Object[]& varClassNames, Object[]& varFileFlags, Object[]& varComponentFlags);
    [DispIdAttribute("18")]
public abstract virtual void RefreshComponents();
    [DispIdAttribute("19")]
public abstract virtual void BackupREGDB(string bstrBackupFilePath);
    [DispIdAttribute("20")]
public abstract virtual void RestoreREGDB(string bstrBackupFilePath);
    [DispIdAttribute("21")]
public abstract virtual void QueryApplicationFile(string bstrApplicationFile, String& bstrApplicationName, String& bstrApplicationDescription, Boolean& bHasUsers, Boolean& bIsProxy, Object[]& varFileNames);
    [DispIdAttribute("22")]
public abstract virtual void StartApplication(string bstrApplIdOrName);
    [DispIdAttribute("23")]
public abstract virtual int ServiceCheck(int lService);
    [DispIdAttribute("24")]
public abstract virtual void InstallMultipleEventClasses(string bstrApplIdOrName, Object[]& fileNames, Object[]& CLSIDS);
    [DispIdAttribute("25")]
public abstract virtual void InstallEventClass(string bstrApplIdOrName, string bstrDLL, string bstrTLB, string bstrPSDLL);
    [DispIdAttribute("26")]
public abstract virtual void GetEventClassesForIID(string bstrIID, Object[]& varCLSIDS, Object[]& varProgIDs, Object[]& varDescriptions);
    [DispIdAttribute("27")]
public abstract virtual object GetCollectionByQuery2(string bstrCollectionName, object pVarQueryStrings);
    [DispIdAttribute("28")]
public abstract virtual string GetApplicationInstanceIDFromProcessID(int lProcessID);
    [DispIdAttribute("29")]
public abstract virtual void ShutdownApplicationInstances(object pVarApplicationInstanceID);
    [DispIdAttribute("30")]
public abstract virtual void PauseApplicationInstances(object pVarApplicationInstanceID);
    [DispIdAttribute("31")]
public abstract virtual void ResumeApplicationInstances(object pVarApplicationInstanceID);
    [DispIdAttribute("32")]
public abstract virtual void RecycleApplicationInstances(object pVarApplicationInstanceID, int lReasonCode);
    [DispIdAttribute("33")]
public abstract virtual bool AreApplicationInstancesPaused(object pVarApplicationInstanceID);
    [DispIdAttribute("34")]
public abstract virtual string DumpApplicationInstance(string bstrApplicationInstanceID, string bstrDirectory, int lMaxImages);
    [DispIdAttribute("35")]
public abstract virtual bool IsApplicationInstanceDumpSupported();
    [DispIdAttribute("36")]
public abstract virtual void CreateServiceForApplication(string bstrApplicationIDOrName, string bstrServiceName, string bstrStartType, string bstrErrorControl, string bstrDependencies, string bstrRunAs, string bstrPassword, bool bDesktopOk);
    [DispIdAttribute("37")]
public abstract virtual void DeleteServiceForApplication(string bstrApplicationIDOrName);
    [DispIdAttribute("38")]
public abstract virtual string GetPartitionID(string bstrApplicationIDOrName);
    [DispIdAttribute("39")]
public abstract virtual string GetPartitionName(string bstrApplicationIDOrName);
    [DispIdAttribute("40")]
public abstract virtual void CurrentPartition(string bstrPartitionIDOrName);
    [DispIdAttribute("41")]
public abstract virtual string CurrentPartitionID();
    [DispIdAttribute("42")]
public abstract virtual string CurrentPartitionName();
    [DispIdAttribute("43")]
public abstract virtual string GlobalPartitionID();
    [DispIdAttribute("44")]
public abstract virtual void FlushPartitionCache();
    [DispIdAttribute("45")]
public abstract virtual void CopyApplications(string bstrSourcePartitionIDOrName, object pVarApplicationID, string bstrDestinationPartitionIDOrName);
    [DispIdAttribute("46")]
public abstract virtual void CopyComponents(string bstrSourceApplicationIDOrName, object pVarCLSIDOrProgID, string bstrDestinationApplicationIDOrName);
    [DispIdAttribute("47")]
public abstract virtual void MoveComponents(string bstrSourceApplicationIDOrName, object pVarCLSIDOrProgID, string bstrDestinationApplicationIDOrName);
    [DispIdAttribute("48")]
public abstract virtual void AliasComponent(string bstrSrcApplicationIDOrName, string bstrCLSIDOrProgID, string bstrDestApplicationIDOrName, string bstrNewProgId, string bstrNewClsid);
    [DispIdAttribute("49")]
public abstract virtual object IsSafeToDelete(string bstrDllName);
    [DispIdAttribute("50")]
public abstract virtual void ImportUnconfiguredComponents(string bstrApplicationIDOrName, object pVarCLSIDOrProgID, object pVarComponentType);
    [DispIdAttribute("51")]
public abstract virtual void PromoteUnconfiguredComponents(string bstrApplicationIDOrName, object pVarCLSIDOrProgID, object pVarComponentType);
    [DispIdAttribute("52")]
public abstract virtual void ImportComponents(string bstrApplicationIDOrName, object pVarCLSIDOrProgID, object pVarComponentType);
    [DispIdAttribute("53")]
public abstract virtual bool Is64BitCatalogServer();
    [DispIdAttribute("54")]
public abstract virtual void ExportPartition(string bstrPartitionIDOrName, string bstrPartitionFileName, int lOptions);
    [DispIdAttribute("55")]
public abstract virtual void InstallPartition(string bstrFileName, string bstrDestDirectory, int lOptions, string bstrUserID, string bstrPassword, string bstrRSN);
    [DispIdAttribute("56")]
public abstract virtual object QueryApplicationFile2(string bstrApplicationFile);
    [DispIdAttribute("57")]
public abstract virtual int GetComponentVersionCount(string bstrCLSIDOrProgID);
}
[GuidAttribute("6EB22872-8A19-11D0-81B6-00A0C9231C29")]
[InterfaceTypeAttribute("0")]
internal interface System.ServiceModel.ComIntegration.ICatalogCollection {
    public bool IsAddEnabled { get; }
    public bool IsRemoveEnabled { get; }
    public int DataStoreMajorVersion { get; }
    public int DataStoreMinorVersion { get; }
    [DispIdAttribute("-4")]
public abstract virtual void GetEnumerator(IEnumerator& pEnum);
    [DispIdAttribute("1")]
public abstract virtual object Item(int lIndex);
    [DispIdAttribute("1610743810")]
public abstract virtual int Count();
    [DispIdAttribute("1610743811")]
public abstract virtual void Remove(int lIndex);
    [DispIdAttribute("1610743812")]
public abstract virtual object Add();
    [DispIdAttribute("2")]
public abstract virtual void Populate();
    [DispIdAttribute("3")]
public abstract virtual int SaveChanges();
    [DispIdAttribute("4")]
public abstract virtual object GetCollection(string bstrCollName, object varObjectKey);
    [DispIdAttribute("6")]
public abstract virtual object Name();
    [DispIdAttribute("7")]
public abstract virtual bool get_IsAddEnabled();
    [DispIdAttribute("8")]
public abstract virtual bool get_IsRemoveEnabled();
    [DispIdAttribute("9")]
public abstract virtual object GetUtilInterface();
    [DispIdAttribute("10")]
public abstract virtual int get_DataStoreMajorVersion();
    [DispIdAttribute("11")]
public abstract virtual int get_DataStoreMinorVersion();
    public abstract virtual void PopulateByKey(Object[] aKeys);
    [DispIdAttribute("13")]
public abstract virtual void PopulateByQuery(string bstrQueryString, int lQueryType);
}
[GuidAttribute("6EB22871-8A19-11D0-81B6-00A0C9231C29")]
internal interface System.ServiceModel.ComIntegration.ICatalogObject {
    public bool Valid { get; }
    [DispIdAttribute("1")]
public abstract virtual object GetValue(string propName);
    [DispIdAttribute("1")]
public abstract virtual void SetValue(string propName, object value);
    [DispIdAttribute("2")]
public abstract virtual object Key();
    [DispIdAttribute("3")]
public abstract virtual object Name();
    [DispIdAttribute("4")]
public abstract virtual bool IsPropertyReadOnly(string bstrPropName);
    [DispIdAttribute("5")]
public abstract virtual bool get_Valid();
    [DispIdAttribute("6")]
public abstract virtual bool IsPropertyWriteOnly(string bstrPropName);
}
[GuidAttribute("181b448c-c17c-4b17-ac6d-06699b93198f")]
[InterfaceTypeAttribute("2")]
public interface System.ServiceModel.ComIntegration.IChannelCredentials {
    public abstract virtual void SetWindowsCredential(string domain, string userName, string password, int impersonationLevel, bool allowNtlm);
    public abstract virtual void SetUserNameCredential(string userName, string password);
    public abstract virtual void SetClientCertificateFromStore(string storeLocation, string storeName, string findType, object findValue);
    public abstract virtual void SetClientCertificateFromStoreByName(string subjectName, string storeLocation, string storeName);
    public abstract virtual void SetClientCertificateFromFile(string fileName, string password, string keyStorageFlags);
    public abstract virtual void SetDefaultServiceCertificateFromStore(string storeLocation, string storeName, string findType, object findValue);
    public abstract virtual void SetDefaultServiceCertificateFromStoreByName(string subjectName, string storeLocation, string storeName);
    public abstract virtual void SetDefaultServiceCertificateFromFile(string fileName, string password, string keyStorageFlags);
    public abstract virtual void SetServiceCertificateAuthentication(string storeLocation, string revocationMode, string certificationValidationMode);
    public abstract virtual void SetIssuedToken(string localIssuerAddres, string localIssuerBindingType, string localIssuerBinding);
}
[GuidAttribute("d1bc6624-f145-4904-ac39-1ee483c8ca9c")]
[InterfaceTypeAttribute("2")]
internal interface System.ServiceModel.ComIntegration.IChannelOptions {
}
[GuidAttribute("000001ce-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IComThreadingInfo {
    public abstract virtual void GetCurrentApartmentType(UInt32& aptType);
    public abstract virtual void GetCurrentThreadType(UInt32& threadType);
    public abstract virtual void GetCurrentLogicalThreadId(Guid& guidLogicalThreadID);
    public abstract virtual void SetCurrentLogicalThreadId(Guid guidLogicalThreadID);
}
[GuidAttribute("A7549A29-A7C4-42e1-8DC1-7E3D748DC24A")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IContextSecurityPerimeter {
    public abstract virtual bool GetPerimeterFlag();
    public abstract virtual void SetPerimeterFlag(bool flag);
}
internal interface System.ServiceModel.ComIntegration.ICreateServiceChannel {
    public abstract virtual RealProxy CreateChannel();
}
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, IntPtr ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(IntPtr pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(IntPtr pdwMksys);
}
internal static class System.ServiceModel.ComIntegration.InterfaceHelper : object {
    internal static IntPtr GetInterfacePtrForObject(Guid iid, object obj);
}
internal static class System.ServiceModel.ComIntegration.InterfaceID : object {
    public static Guid idISupportErrorInfo;
    public static Guid idIDispatch;
    private static InterfaceID();
}
[GuidAttribute("75B52DDB-E8ED-11D1-93AD-00AA00BA3258")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IObjectContextInfo {
    public abstract virtual bool IsInTransaction();
    public abstract virtual object GetTransaction();
    public abstract virtual void GetTransactionId(Guid& guid);
    public abstract virtual void GetActivityId(Guid& guid);
    public abstract virtual void GetContextId(Guid& guid);
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("0000011a-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IParseDisplayName {
    public abstract virtual void ParseDisplayName(IBindCtx pbc, string pszDisplayName, IntPtr pchEaten, IntPtr ppmkOut);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000010c-0000-0000-C000-000000000046")]
internal interface System.ServiceModel.ComIntegration.IPersist {
    public abstract virtual void GetClassID(Guid& pClassID);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000109-0000-0000-C000-000000000046")]
internal interface System.ServiceModel.ComIntegration.IPersistStream {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
}
internal interface System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings {
    public ServiceChannelFactory ServiceChannelFactoryReadWrite { get; }
    public ServiceChannelFactory ServiceChannelFactoryReadOnly { get; }
    public KeyedByTypeCollection`1<IEndpointBehavior> Behaviors { get; }
    public ServiceChannel ServiceChannel { get; }
    public abstract virtual ServiceChannelFactory get_ServiceChannelFactoryReadWrite();
    public abstract virtual ServiceChannelFactory get_ServiceChannelFactoryReadOnly();
    public abstract virtual KeyedByTypeCollection`1<IEndpointBehavior> get_Behaviors();
    public abstract virtual ServiceChannel get_ServiceChannel();
}
internal interface System.ServiceModel.ComIntegration.IProxyCreator {
    public abstract virtual ComProxy CreateProxy(IntPtr outer, Guid& riid);
    public abstract virtual bool SupportsErrorInfo(Guid& riid);
    public abstract virtual bool SupportsDispatch();
    public abstract virtual bool SupportsIntrinsics();
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("C05307A7-70CE-4670-92C9-52A757744A02")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IProxyManager {
    public abstract virtual void GetIDsOfNames(string name, IntPtr dispid);
    public abstract virtual int Invoke(UInt32 dispIdMember, IntPtr outerProxy, IntPtr pVarResult, IntPtr pExcepInfo);
    public abstract virtual int FindOrCreateProxy(IntPtr outerProxy, Guid& riid, IntPtr& tearOff);
    public abstract virtual void TearDownChannels();
    public abstract virtual int InterfaceSupportsErrorInfo(Guid& riid);
    public abstract virtual int SupportsDispatch();
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("11281BB7-1253-45ef-B98F-D551F79499FD")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IProxyProvider {
    public abstract virtual int CreateOuterProxyInstance(IProxyManager proxyManager, Guid& riid, IntPtr& ppv);
    public abstract virtual int CreateDispatchProxyInstance(IntPtr outer, IPseudoDispatch proxy, IntPtr& ppvInner);
}
[GuidAttribute("16BFA998-CA5B-4f29-B64F-123293EB159D")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IPseudoDispatch {
    public abstract virtual void GetIDsOfNames(UInt32 cNames, String[] rgszNames, IntPtr pDispID);
    public abstract virtual int Invoke(UInt32 dispIdMember, UInt32 cArgs, UInt32 cNamedArgs, IntPtr rgvarg, UInt32[] rgdispidNamedArgs, IntPtr pVarResult, IntPtr pExcepInfo, UInt32& pArgErr);
}
[GuidAttribute("0000013E-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServerSecurity {
    public abstract virtual void QueryBlanket(IntPtr authnSvc, IntPtr authzSvc, IntPtr serverPrincipalName, IntPtr authnLevel, IntPtr impLevel, IntPtr clientPrincipalName, IntPtr Capabilities);
    public abstract virtual int ImpersonateClient();
    public abstract virtual int RevertToSelf();
    public abstract virtual bool IsImpersonating();
}
[GuidAttribute("67532E0C-9E2F-4450-A354-035633944E17")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceActivity {
    public abstract virtual void SynchronousCall(IServiceCall pIServiceCall);
    public abstract virtual void AsynchronousCall(IServiceCall pIServiceCall);
    public abstract virtual void BindToCurrentThread();
    public abstract virtual void UnbindFromThread();
}
[GuidAttribute("BD3E2E12-42DD-40f4-A09A-95A50C58304B")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceCall {
    public abstract virtual void OnCall();
}
[GuidAttribute("80182d03-5ea4-4831-ae97-55beffc2e590")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServicePartitionConfig {
    public abstract virtual void PartitionConfig(PartitionOption partitionConfig);
    public abstract virtual void PartitionID(Guid guidPartitionID);
}
[GuidAttribute("C7CD7379-F3F2-4634-811B-703281D73E08")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceSxsConfig {
    public abstract virtual void SxsConfig(CSC_SxsConfig sxsConfig);
    public abstract virtual void SxsName(string szSxsName);
    public abstract virtual void SxsDirectory(string szSxsDirectory);
}
[GuidAttribute("33CAF1A1-FCB8-472b-B45E-967448DED6D8")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceSysTxnConfig {
    public abstract virtual void ConfigureTransaction(TransactionConfig transactionConfig);
    public abstract virtual void IsolationLevel(int option);
    public abstract virtual void TransactionTimeout(UInt32 ulTimeoutSec);
    public abstract virtual void BringYourOwnTransaction(string szTipURL);
    public abstract virtual void NewTransactionDescription(string szTxDesc);
    public abstract virtual void ConfigureBYOT(IntPtr pITxByot);
    public abstract virtual void ConfigureBYOTSysTxn(IntPtr pITxByot);
}
[GuidAttribute("186d89bc-f277-4bcc-80d5-4df7b836ef4a")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceThreadPoolConfig {
    public abstract virtual void SelectThreadPool(ThreadPoolOption threadPool);
    public abstract virtual void SetBindingInfo(BindingOption binding);
}
[GuidAttribute("59f4c2a3-d3d7-4a31-b6e4-6ab3177c50b9")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.IServiceTransactionConfig {
    public abstract virtual void ConfigureTransaction(TransactionConfig transactionConfig);
    public abstract virtual void IsolationLevel(int option);
    public abstract virtual void TransactionTimeout(UInt32 ulTimeoutSec);
    public abstract virtual void BringYourOwnTransaction(string szTipURL);
    public abstract virtual void NewTransactionDescription(string szTxDesc);
    public abstract virtual void ConfigureBYOT(IntPtr pITxByot);
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.ITransactionOutcomeEvents {
    public abstract virtual void Committed(bool retaining, int newUow, int hr);
    public abstract virtual void Aborted(int reason, bool retaining, int newUow, int hr);
    public abstract virtual void HeuristicDecision(int decision, int reason, int hr);
    public abstract virtual void InDoubt();
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("02558374-DF2E-4dae-BD6B-1D5C994F9BDC")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.ITransactionProxy {
    public abstract virtual void Commit(Guid guid);
    public abstract virtual void Abort();
    public abstract virtual IDtcTransaction Promote();
    public abstract virtual void CreateVoter(ITransactionVoterNotifyAsync2 voterNotification, IntPtr voterBallot);
    public abstract virtual DtcIsolationLevel GetIsolationLevel();
    public abstract virtual Guid GetIdentifier();
    public abstract virtual bool IsReusable();
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("5433376C-414D-11d3-B206-00C04FC2F3EF")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.ITransactionVoterBallotAsync2 {
    public abstract virtual void VoteRequestDone(int hr, int reason);
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("5433376B-414D-11d3-B206-00C04FC2F3EF")]
[InterfaceTypeAttribute("1")]
internal interface System.ServiceModel.ComIntegration.ITransactionVoterNotifyAsync2 {
    public abstract virtual void Committed(bool retaining, int newUow, int hr);
    public abstract virtual void Aborted(int reason, bool retaining, int newUow, int hr);
    public abstract virtual void HeuristicDecision(int decision, int reason, int hr);
    public abstract virtual void InDoubt();
    public abstract virtual void VoteRequest();
}
internal interface System.ServiceModel.ComIntegration.ITypeCacheManager {
    public abstract virtual void FindOrCreateType(Guid riid, Type& interfaceType, bool noAssemblyGeneration, bool isServer);
    public abstract virtual void FindOrCreateType(Type serverType, Guid riid, Type& interfaceType, bool noAssemblyGeneration, bool isServer);
    public abstract virtual void FindOrCreateType(Guid typeLibId, string typeLibVersion, Guid typeDefId, Type& userDefinedType, bool noAssemblyGeneration);
    public abstract virtual Assembly ResolveAssembly(Guid assembly);
}
internal class System.ServiceModel.ComIntegration.LUID : ValueType {
    internal UInt32 LowPart;
    internal int HighPart;
}
internal class System.ServiceModel.ComIntegration.LUID_AND_ATTRIBUTES : ValueType {
    internal LUID Luid;
    internal PrivilegeAttribute Attributes;
}
internal static class System.ServiceModel.ComIntegration.MessageUtil : object {
    public static WindowsIdentity GetMessageIdentity(Message message);
    public static Transaction GetMessageTransaction(Message message);
}
internal class System.ServiceModel.ComIntegration.MexServiceChannelBuilder : object {
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadWrite { get; }
    private ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannel { get; }
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadOnly { get; }
    private KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.Behaviors { get; }
    internal MexServiceChannelBuilder(Dictionary`2<MonikerAttribute, string> propertyTable);
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadWrite();
    private sealed virtual override ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannel();
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadOnly();
    private sealed virtual override KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_Behaviors();
    private sealed virtual override void System.IDisposable.Dispose();
    public WsdlImporter CreateDataContractSerializerImporter(MetadataSet metaData);
    public WsdlImporter CreateXmlSerializerImporter(MetadataSet metaData);
    private sealed virtual override ComProxy System.ServiceModel.ComIntegration.IProxyCreator.CreateProxy(IntPtr outer, Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsErrorInfo(Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsDispatch();
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsIntrinsics();
}
internal class System.ServiceModel.ComIntegration.MonikerBuilder : object {
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override ComProxy System.ServiceModel.ComIntegration.IProxyCreator.CreateProxy(IntPtr outer, Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsErrorInfo(Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsDispatch();
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsIntrinsics();
    public static MarshalByRefObject CreateMonikerInstance();
}
internal static class System.ServiceModel.ComIntegration.MonikerHelper : object {
}
[AttributeUsageAttribute("4")]
internal class System.ServiceModel.ComIntegration.MonikerProxyAttribute : ProxyAttribute {
    public virtual MarshalByRefObject CreateInstance(Type serverType);
    private sealed virtual override MarshalByRefObject System.Runtime.InteropServices.ICustomFactory.CreateInstance(Type serverType);
}
internal class System.ServiceModel.ComIntegration.MonikerSyntaxException : COMException {
    internal MonikerSyntaxException(string message);
}
internal static class System.ServiceModel.ComIntegration.MonikerUtility : object {
    internal static string Getkeyword(string moniker, MonikerAttribute& keyword);
    internal static string GetValue(string moniker, String& val);
    internal static void Parse(string displayName, Dictionary`2& propertyTable);
}
internal class System.ServiceModel.ComIntegration.OperationInfo : object {
    public string Name { get; }
    public String[] MethodRoleMembers { get; }
    public OperationInfo(ComCatalogObject methodObject, ComCatalogObject application);
    public string get_Name();
    public String[] get_MethodRoleMembers();
}
internal static class System.ServiceModel.ComIntegration.OuterProxyWrapper : object {
    private static OuterProxyWrapper();
    public static IntPtr CreateOuterProxyInstance(IProxyManager proxyManager, Guid& riid);
    public static IntPtr CreateDispatchProxy(IntPtr pOuter, IPseudoDispatch proxy);
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.PartitionOption : Enum {
    public int value__;
    public static PartitionOption Ignore;
    public static PartitionOption Inherit;
    public static PartitionOption New;
}
internal class System.ServiceModel.ComIntegration.PersistHelper : object {
    [SecuritySafeCriticalAttribute]
internal static Byte[] ConvertHGlobalToByteArray(SafeHGlobalHandle hGlobal);
    [SecuritySafeCriticalAttribute]
internal static Byte[] PersistIPersistStreamToByteArray(IPersistStream persistableObject);
    [SecuritySafeCriticalAttribute]
internal static void LoadIntoObjectFromByteArray(IPersistStream persistableObject, Byte[] byteStream);
    internal static object ActivateAndLoadFromByteStream(Guid clsid, Byte[] byteStream);
}
[DataContractAttribute]
public class System.ServiceModel.ComIntegration.PersistStreamTypeWrapper : object {
    [DataMemberAttribute]
internal Guid clsid;
    [DataMemberAttribute]
internal Byte[] dataStream;
    public ExtensionDataObject ExtensionData { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ExtensionDataObject get_ExtensionData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtensionData(ExtensionDataObject value);
    [SecuritySafeCriticalAttribute]
public void SetObject(T obj);
    [SecuritySafeCriticalAttribute]
public void GetObject(T& obj);
}
internal class System.ServiceModel.ComIntegration.PRIVILEGE_SET : object {
    internal UInt32 PrivilegeCount;
    internal UInt32 Control;
    internal LUID_AND_ATTRIBUTES Privilege;
}
[FlagsAttribute]
internal enum System.ServiceModel.ComIntegration.PrivilegeAttribute : Enum {
    public UInt32 value__;
    public static PrivilegeAttribute SE_PRIVILEGE_DISABLED;
    public static PrivilegeAttribute SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    public static PrivilegeAttribute SE_PRIVILEGE_ENABLED;
    public static PrivilegeAttribute SE_PRIVILEGE_REMOVED;
    public static PrivilegeAttribute SE_PRIVILEGE_USED_FOR_ACCESS;
}
internal static class System.ServiceModel.ComIntegration.ProxyBuilder : object {
    internal static void Build(Dictionary`2<MonikerAttribute, string> propertyTable, Guid& riid, IntPtr ppv);
}
internal class System.ServiceModel.ComIntegration.ProxyManager : object {
    internal ProxyManager(IProxyCreator proxyCreator);
    private sealed virtual override void System.ServiceModel.ComIntegration.IProxyManager.TearDownChannels();
    private sealed virtual override int System.ServiceModel.ComIntegration.IProxyManager.FindOrCreateProxy(IntPtr outerProxy, Guid& riid, IntPtr& tearOff);
    private sealed virtual override int System.ServiceModel.ComIntegration.IProxyManager.InterfaceSupportsErrorInfo(Guid& riid);
    private sealed virtual override void System.ServiceModel.ComIntegration.IProxyManager.GetIDsOfNames(string name, IntPtr pDispID);
    private sealed virtual override int System.ServiceModel.ComIntegration.IProxyManager.Invoke(UInt32 dispIdMember, IntPtr outerProxy, IntPtr pVarResult, IntPtr pExcepInfo);
    private sealed virtual override int System.ServiceModel.ComIntegration.IProxyManager.SupportsDispatch();
}
internal class System.ServiceModel.ComIntegration.ProxySupportWrapper : object {
    private static ProxySupportWrapper();
    protected virtual override void Finalize();
    internal IProxyProvider GetProxyProvider();
}
internal class System.ServiceModel.ComIntegration.RegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static RegistryHandle HKEY_CLASSES_ROOT;
    internal static RegistryHandle HKEY_CURRENT_USER;
    internal static RegistryHandle HKEY_LOCAL_MACHINE;
    internal static RegistryHandle HKEY_USERS;
    internal static RegistryHandle HKEY_PERFORMANCE_DATA;
    internal static RegistryHandle HKEY_CURRENT_CONFIG;
    internal static RegistryHandle HKEY_DYN_DATA;
    public RegistryHandle(IntPtr hKey, bool ownHandle);
    private static RegistryHandle();
    public static RegistryHandle GetBitnessHKCR(bool is64bit);
    public static RegistryHandle GetCorrectBitnessHKLMSubkey(bool is64bit, string key);
    internal static RegistryHandle GetNativeHKLMSubkey(string subKey, bool writeable);
    public bool DeleteKey(string key);
    public void SetValue(string valName, string value);
    public RegistryHandle OpenSubKey(string subkey);
    public string GetStringValue(string valName);
    public StringCollection GetSubKeyNames();
    [SecuritySafeCriticalAttribute]
internal object GetValue(string valName);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.ServiceModel.ComIntegration.SafeNativeMethods : object {
    internal static string KERNEL32;
    internal static string ADVAPI32;
    internal static string OLE32;
    internal static string OLEAUT32;
    internal static string COMSVCS;
    internal static string SECUR32;
    internal static string NETAPI32;
    internal static int ERROR_MORE_DATA;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_INVALID_HANDLE;
    internal static int ERROR_NOT_SUPPORTED;
    internal static int READ_CONTROL;
    internal static int SYNCHRONIZE;
    internal static int STANDARD_RIGHTS_READ;
    internal static int STANDARD_RIGHTS_WRITE;
    internal static int KEY_QUERY_VALUE;
    internal static int KEY_SET_VALUE;
    internal static int KEY_CREATE_SUB_KEY;
    internal static int KEY_ENUMERATE_SUB_KEYS;
    internal static int KEY_NOTIFY;
    internal static int KEY_CREATE_LINK;
    internal static int KEY_READ;
    internal static int KEY_WRITE;
    internal static int REG_NONE;
    internal static int REG_SZ;
    internal static int REG_EXPAND_SZ;
    internal static int KEY_WOW64_32KEY;
    internal static int KEY_WOW64_64KEY;
    internal static int REG_BINARY;
    internal static int REG_DWORD;
    internal static int REG_DWORD_LITTLE_ENDIAN;
    internal static int REG_DWORD_BIG_ENDIAN;
    internal static int REG_LINK;
    internal static int REG_MULTI_SZ;
    internal static int REG_RESOURCE_LIST;
    internal static int REG_FULL_RESOURCE_DESCRIPTOR;
    internal static int REG_RESOURCE_REQUIREMENTS_LIST;
    internal static int REG_QWORD;
    internal static int HWND_BROADCAST;
    internal static int WM_SETTINGCHANGE;
    internal static int RegOpenKeyEx(RegistryHandle hKey, string lpSubKey, int ulOptions, int samDesired, RegistryHandle& hkResult);
    internal static int RegSetValueEx(RegistryHandle hKey, string lpValueName, int Reserved, int dwType, string val, int cbData);
    internal static int RegCloseKey(IntPtr handle);
    internal static int RegQueryValueEx(RegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Byte[] lpData, Int32& lpcbData);
    internal static int RegEnumKey(RegistryHandle hKey, int index, StringBuilder lpName, Int32& len);
    internal static int RegDeleteKey(RegistryHandle hKey, string lpValueName);
    internal static bool DuplicateTokenEx(SafeCloseHandle ExistingToken, TokenAccessLevels DesiredAccess, IntPtr TokenAttributes, SecurityImpersonationLevel ImpersonationLevel, TokenType TokenType, SafeCloseHandle& NewToken);
    internal static bool AccessCheck(Byte[] SecurityDescriptor, SafeCloseHandle ClientToken, int DesiredAccess, GENERIC_MAPPING GenericMapping, PRIVILEGE_SET& PrivilegeSet, UInt32& PrivilegeSetLength, UInt32& GrantedAccess, Boolean& AccessStatus);
    internal static bool ImpersonateAnonymousUserOnCurrentThread(IntPtr CurrentThread);
    internal static bool OpenCurrentThreadToken(IntPtr ThreadHandle, TokenAccessLevels DesiredAccess, bool OpenAsSelf, SafeCloseHandle& TokenHandle);
    internal static bool SetCurrentThreadToken(IntPtr ThreadHandle, SafeCloseHandle TokenHandle);
    internal static IntPtr GetCurrentThread();
    internal static int GetCurrentThreadId();
    internal static bool RevertToSelf();
    internal static bool GetTokenInformation(SafeCloseHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, SafeHandle TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    internal static IntPtr GetCurrentProcess();
    internal static bool GetCurrentProcessToken(IntPtr ProcessHandle, TokenAccessLevels DesiredAccess, SafeCloseHandle& TokenHandle);
    public static object CoCreateInstance(Guid rclsid, object pUnkOuter, CLSCTX dwClsContext, Guid riid);
    public static IStream CreateStreamOnHGlobal(SafeHGlobalHandle hGlobal, bool fDeleteOnRelease);
    public static SafeHGlobalHandle GetHGlobalFromStream(IStream stream);
    public static object CoGetObjectContext(Guid riid);
    public static object CoCreateActivity(object pIUnknown, Guid riid);
    internal static IntPtr CoSwitchCallContext(IntPtr newSecurityObject);
    internal static IntPtr GlobalLock(SafeHGlobalHandle hGlobal);
    internal static bool GlobalUnlock(SafeHGlobalHandle hGlobal);
    internal static IntPtr GlobalSize(SafeHGlobalHandle hGlobal);
    internal static int LoadRegTypeLib(Guid& rguid, ushort major, ushort minor, int lcid, Object& typeLib);
    internal static int SafeArrayGetDim(IntPtr pSafeArray);
    internal static int SafeArrayGetElemsize(IntPtr pSafeArray);
    internal static int SafeArrayGetLBound(IntPtr pSafeArray, int cDims);
    internal static int SafeArrayGetUBound(IntPtr pSafeArray, int cDims);
    internal static IntPtr SafeArrayAccessData(IntPtr pSafeArray);
    internal static void SafeArrayUnaccessData(IntPtr pSafeArray);
    internal static bool TranslateName(string input, EXTENDED_NAME_FORMAT inputFormat, EXTENDED_NAME_FORMAT outputFormat, StringBuilder outputString, UInt32& size);
    internal static int DsGetDcName(string computerName, string domainName, IntPtr domainGuid, string siteName, UInt32 flags, IntPtr& domainControllerInfo);
    internal static int NetApiBufferFree(IntPtr buffer);
}
internal class System.ServiceModel.ComIntegration.SecurityCookieModeValidator : object {
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription service, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription service, ServiceHostBase serviceHostBase);
}
internal enum System.ServiceModel.ComIntegration.SecurityImpersonationLevel : Enum {
    public int value__;
    public static SecurityImpersonationLevel Anonymous;
    public static SecurityImpersonationLevel Identification;
    public static SecurityImpersonationLevel Impersonation;
    public static SecurityImpersonationLevel Delegation;
}
internal static class System.ServiceModel.ComIntegration.SecurityUtils : object {
    private static SecurityUtils();
    [SecuritySafeCriticalAttribute]
public static SafeHandle GetTokenInformation(SafeCloseHandle token, TOKEN_INFORMATION_CLASS infoClass);
    internal static bool IsAtleastImpersonationToken(SafeCloseHandle token);
    internal static bool IsPrimaryToken(SafeCloseHandle token);
    internal static LUID GetModifiedIDLUID(SafeCloseHandle token);
    public static WindowsIdentity GetAnonymousIdentity();
    public static WindowsIdentity GetProcessIdentity();
}
internal class System.ServiceModel.ComIntegration.ServiceInfo : object {
    public string ServiceName { get; }
    public Type ServiceType { get; }
    public ServiceElement ServiceElement { get; }
    public Guid Clsid { get; }
    public Guid AppID { get; }
    public Guid PartitionId { get; }
    public Bitness Bitness { get; }
    public bool CheckRoles { get; }
    public ThreadingModel ThreadingModel { get; }
    public TransactionOption TransactionOption { get; }
    public IsolationLevel IsolationLevel { get; }
    public String[] ComponentRoleMembers { get; }
    public List`1<ContractInfo> Contracts { get; }
    public HostingMode HostingMode { get; }
    public bool Pooled { get; }
    public int MaxPoolSize { get; }
    internal Guid[] Assemblies { get; }
    public ServiceInfo(Guid clsid, ServiceElement service, ComCatalogObject application, ComCatalogObject classObject, HostingMode hostingMode);
    public string get_ServiceName();
    public Type get_ServiceType();
    public ServiceElement get_ServiceElement();
    public Guid get_Clsid();
    public Guid get_AppID();
    public Guid get_PartitionId();
    public Bitness get_Bitness();
    public bool get_CheckRoles();
    public ThreadingModel get_ThreadingModel();
    public TransactionOption get_TransactionOption();
    public IsolationLevel get_IsolationLevel();
    public String[] get_ComponentRoleMembers();
    public List`1<ContractInfo> get_Contracts();
    public HostingMode get_HostingMode();
    public bool get_Pooled();
    public int get_MaxPoolSize();
    internal Guid[] get_Assemblies();
    internal bool HasUdts();
    internal Type[] GetTypes(Guid assemblyId);
    internal void AddUdt(Type udt, Guid assemblyId);
}
internal static class System.ServiceModel.ComIntegration.ServiceModelInstallStrings : object {
    internal static string WinFXRegistryKey;
    internal static string RuntimeInstallPathName;
}
[ComVisibleAttribute("True")]
[GuidAttribute("CE39D6F3-DAB7-41b3-9F7D-BD1CC4E92399")]
[MonikerProxyAttribute]
public class System.ServiceModel.ComIntegration.ServiceMoniker : ContextBoundObject {
}
internal class System.ServiceModel.ComIntegration.ServiceMonikerInternal : ContextBoundObject {
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.GetClassID(Guid& clsid);
    private sealed virtual override int System.ServiceModel.ComIntegration.IMoniker.IsDirty();
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Load(IStream stream);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Save(IStream stream, bool isDirty);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.GetSizeMax(Int64& size);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, IntPtr ppvResult);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Hash(IntPtr pdwHash);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Inverse(IMoniker& ppmk);
    private sealed virtual override int System.ServiceModel.ComIntegration.IMoniker.IsEqual(IMoniker pmkOtherMoniker);
    private sealed virtual override int System.ServiceModel.ComIntegration.IMoniker.IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    private sealed virtual override int System.ServiceModel.ComIntegration.IMoniker.IsSystemMoniker(IntPtr pdwMksys);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    private sealed virtual override void System.ServiceModel.ComIntegration.IMoniker.RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    private sealed virtual override void System.ServiceModel.ComIntegration.IParseDisplayName.ParseDisplayName(IBindCtx pbc, string pszDisplayName, IntPtr pchEaten, IntPtr ppmkOut);
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.SxsOption : Enum {
    public int value__;
    public static SxsOption Ignore;
    public static SxsOption Inherit;
    public static SxsOption New;
}
internal class System.ServiceModel.ComIntegration.TagVariant : ValueType {
    public ushort vt;
    public ushort reserved1;
    public ushort reserved2;
    public ushort reserved3;
    public IntPtr ptr;
    public IntPtr pRecInfo;
}
internal class System.ServiceModel.ComIntegration.TearOffProxy : RealProxy {
    internal TearOffProxy(ICreateServiceChannel serviceChannelCreator, Type proxiedType);
    public virtual IMessage Invoke(IMessage message);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal enum System.ServiceModel.ComIntegration.ThreadingModel : Enum {
    public int value__;
    public static ThreadingModel MTA;
    public static ThreadingModel STA;
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.ThreadPoolOption : Enum {
    public int value__;
    public static ThreadPoolOption None;
    public static ThreadPoolOption Inherit;
    public static ThreadPoolOption STA;
    public static ThreadPoolOption MTA;
}
internal enum System.ServiceModel.ComIntegration.TOKEN_INFORMATION_CLASS : Enum {
    public int value__;
    public static TOKEN_INFORMATION_CLASS TokenUser;
    public static TOKEN_INFORMATION_CLASS TokenGroups;
    public static TOKEN_INFORMATION_CLASS TokenPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenOwner;
    public static TOKEN_INFORMATION_CLASS TokenPrimaryGroup;
    public static TOKEN_INFORMATION_CLASS TokenDefaultDacl;
    public static TOKEN_INFORMATION_CLASS TokenSource;
    public static TOKEN_INFORMATION_CLASS TokenType;
    public static TOKEN_INFORMATION_CLASS TokenImpersonationLevel;
    public static TOKEN_INFORMATION_CLASS TokenStatistics;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedSids;
    public static TOKEN_INFORMATION_CLASS TokenSessionId;
    public static TOKEN_INFORMATION_CLASS TokenGroupsAndPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenSessionReference;
    public static TOKEN_INFORMATION_CLASS TokenSandBoxInert;
}
internal class System.ServiceModel.ComIntegration.TOKEN_STATISTICS : ValueType {
    internal LUID TokenId;
    internal LUID AuthenticationId;
    internal long ExpirationTime;
    internal UInt32 TokenType;
    internal SecurityImpersonationLevel ImpersonationLevel;
    internal UInt32 DynamicCharged;
    internal UInt32 DynamicAvailable;
    internal UInt32 GroupCount;
    internal UInt32 PrivilegeCount;
    internal LUID ModifiedId;
}
internal enum System.ServiceModel.ComIntegration.TokenType : Enum {
    public int value__;
    public static TokenType TokenPrimary;
    public static TokenType TokenImpersonation;
}
[ComVisibleAttribute("False")]
internal enum System.ServiceModel.ComIntegration.TransactionConfig : Enum {
    public int value__;
    public static TransactionConfig NoTransaction;
    public static TransactionConfig IfContainerIsTransactional;
    public static TransactionConfig CreateTransactionIfNecessary;
    public static TransactionConfig NewTransaction;
}
internal class System.ServiceModel.ComIntegration.TransactionProxy : object {
    public Transaction CurrentTransaction { get; }
    public Guid AppId { get; }
    public Guid Clsid { get; }
    public int InstanceID { get; public set; }
    public TransactionProxy(Guid appid, Guid clsid);
    public Transaction get_CurrentTransaction();
    public Guid get_AppId();
    public Guid get_Clsid();
    public int get_InstanceID();
    public void set_InstanceID(int value);
    public void SetTransaction(Transaction transaction);
    public sealed virtual void Attach(InstanceContext owner);
    public sealed virtual void Detach(InstanceContext owner);
    public sealed virtual void Commit(Guid guid);
    public sealed virtual void Abort();
    public sealed virtual IDtcTransaction Promote();
    public sealed virtual void CreateVoter(ITransactionVoterNotifyAsync2 voterNotification, IntPtr voterBallot);
    public sealed virtual DtcIsolationLevel GetIsolationLevel();
    public sealed virtual Guid GetIdentifier();
    public sealed virtual bool IsReusable();
}
internal class System.ServiceModel.ComIntegration.TransactionProxyBuilder : object {
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override ComProxy System.ServiceModel.ComIntegration.IProxyCreator.CreateProxy(IntPtr outer, Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsErrorInfo(Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsDispatch();
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsIntrinsics();
    public static IntPtr CreateTransactionProxyTearOff(TransactionProxy txProxy);
}
internal class System.ServiceModel.ComIntegration.TypeCacheManager : object {
    internal static ITypeCacheManager instance;
    public static ITypeCacheManager Provider { get; }
    private static TypeCacheManager();
    public static ITypeCacheManager get_Provider();
    private sealed virtual override Assembly System.ServiceModel.ComIntegration.ITypeCacheManager.ResolveAssembly(Guid assembly);
    private sealed virtual override void System.ServiceModel.ComIntegration.ITypeCacheManager.FindOrCreateType(Guid typeLibId, string typeLibVersion, Guid typeDefId, Type& userDefinedType, bool noAssemblyGeneration);
    public sealed virtual void FindOrCreateType(Guid iid, Type& interfaceType, bool noAssemblyGeneration, bool isServer);
    private sealed virtual override void System.ServiceModel.ComIntegration.ITypeCacheManager.FindOrCreateType(Type serverType, Guid iid, Type& interfaceType, bool noAssemblyGeneration, bool isServer);
    public static Type ResolveClsidToType(Guid clsid);
    internal Type VerifyType(Guid iid);
}
internal class System.ServiceModel.ComIntegration.TypedServiceChannelBuilder : object {
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadWrite { get; }
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadOnly { get; }
    private KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.Behaviors { get; }
    private ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannel { get; }
    internal TypedServiceChannelBuilder(Dictionary`2<MonikerAttribute, string> propertyTable);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadWrite();
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadOnly();
    private sealed virtual override KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_Behaviors();
    private sealed virtual override ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannel();
    private sealed virtual override RealProxy System.ServiceModel.ComIntegration.ICreateServiceChannel.CreateChannel();
    internal void ResolveTypeIfPossible(Dictionary`2<MonikerAttribute, string> propertyTable);
    private sealed virtual override ComProxy System.ServiceModel.ComIntegration.IProxyCreator.CreateProxy(IntPtr outer, Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsErrorInfo(Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsDispatch();
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsIntrinsics();
}
internal class System.ServiceModel.ComIntegration.TypeLibraryHelper : object {
    private static TypeLibraryHelper();
    internal static Assembly GenerateAssemblyFromNativeTypeLibrary(Guid iid, Guid typeLibraryID, ITypeLib typeLibrary);
}
public class System.ServiceModel.ComIntegration.WasHostedComPlusFactory : ServiceHostFactoryBase {
    public virtual ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses);
}
internal class System.ServiceModel.ComIntegration.WebHostedComPlusServiceHost : ComPlusServiceHost {
    public WebHostedComPlusServiceHost(string webhostParams, Uri[] baseAddresses);
}
internal enum System.ServiceModel.ComIntegration.Win32Error : Enum {
    public int value__;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NO_TOKEN;
    public static Win32Error ERROR_NONE_MAPPED;
    public static Win32Error ERROR_NO_SUCH_DOMAIN;
}
internal class System.ServiceModel.ComIntegration.WsdlServiceChannelBuilder : object {
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadWrite { get; }
    private ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannel { get; }
    private ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.ServiceChannelFactoryReadOnly { get; }
    private KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.Behaviors { get; }
    internal WsdlServiceChannelBuilder(Dictionary`2<MonikerAttribute, string> propertyTable);
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadWrite();
    private sealed virtual override ServiceChannel System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannel();
    private sealed virtual override ServiceChannelFactory System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_ServiceChannelFactoryReadOnly();
    private sealed virtual override KeyedByTypeCollection`1<IEndpointBehavior> System.ServiceModel.ComIntegration.IProvideChannelBuilderSettings.get_Behaviors();
    private sealed virtual override void System.IDisposable.Dispose();
    public WsdlImporter CreateDataContractSerializerImporter(MetadataSet metaData);
    public WsdlImporter CreateXmlSerializerImporter(MetadataSet metaData);
    private sealed virtual override ComProxy System.ServiceModel.ComIntegration.IProxyCreator.CreateProxy(IntPtr outer, Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsErrorInfo(Guid& riid);
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsDispatch();
    private sealed virtual override bool System.ServiceModel.ComIntegration.IProxyCreator.SupportsIntrinsics();
}
internal class System.ServiceModel.ComIntegration.WsdlWrapper : object {
    public WsdlWrapper(ServiceDescription wsdl);
    public sealed virtual void WriteXml(XmlWriter xmlWriter);
    public sealed virtual void ReadXml(XmlReader xmlReader);
    public sealed virtual XmlSchema GetSchema();
}
[GuidAttribute("F618C514-DFB8-11D1-A2CF-00805FC79235")]
internal class System.ServiceModel.ComIntegration.xCatalog : object {
}
public class System.ServiceModel.CommunicationException : SystemException {
    public CommunicationException(string message);
    public CommunicationException(string message, Exception innerException);
    protected CommunicationException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectAbortedException : CommunicationException {
    public CommunicationObjectAbortedException(string message);
    public CommunicationObjectAbortedException(string message, Exception innerException);
    protected CommunicationObjectAbortedException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectFaultedException : CommunicationException {
    public CommunicationObjectFaultedException(string message);
    public CommunicationObjectFaultedException(string message, Exception innerException);
    protected CommunicationObjectFaultedException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.CommunicationState : Enum {
    public int value__;
    public static CommunicationState Created;
    public static CommunicationState Opening;
    public static CommunicationState Opened;
    public static CommunicationState Closing;
    public static CommunicationState Closed;
    public static CommunicationState Faulted;
}
public enum System.ServiceModel.ConcurrencyMode : Enum {
    public int value__;
    public static ConcurrencyMode Single;
    public static ConcurrencyMode Reentrant;
    public static ConcurrencyMode Multiple;
}
internal static class System.ServiceModel.ConcurrencyModeHelper : object {
    public static bool IsDefined(ConcurrencyMode x);
}
public class System.ServiceModel.Configuration.AddressHeaderCollectionElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("headers")]
public AddressHeaderCollection Headers { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal void Copy(AddressHeaderCollectionElement source);
    public AddressHeaderCollection get_Headers();
    public void set_Headers(AddressHeaderCollection value);
    [SecuritySafeCriticalAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    internal void InitializeFrom(AddressHeaderCollection headers);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.AllowedAudienceUriElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("allowedAudienceUri")]
[StringValidatorAttribute]
public string AllowedAudienceUri { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_AllowedAudienceUri();
    public void set_AllowedAudienceUri(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.AllowedAudienceUriElement")]
public class System.ServiceModel.Configuration.AllowedAudienceUriElementCollection : ServiceModelConfigurationElementCollection`1<AllowedAudienceUriElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
public class System.ServiceModel.Configuration.ApplicationContainerSettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("packageFullName")]
[StringValidatorAttribute]
public string PackageFullName { get; public set; }
    [ConfigurationPropertyAttribute("sessionId")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SessionIdTypeConvertor")]
[SessionIdTypeValidatorAttribute]
public int SessionId { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_PackageFullName();
    public void set_PackageFullName(string value);
    public int get_SessionId();
    public void set_SessionId(int value);
    internal void ApplyConfiguration(ApplicationContainerSettings settings);
    internal void InitializeFrom(ApplicationContainerSettings settings);
    internal void CopyFrom(ApplicationContainerSettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public enum System.ServiceModel.Configuration.AuthenticationMode : Enum {
    public int value__;
    public static AuthenticationMode AnonymousForCertificate;
    public static AuthenticationMode AnonymousForSslNegotiated;
    public static AuthenticationMode CertificateOverTransport;
    public static AuthenticationMode IssuedToken;
    public static AuthenticationMode IssuedTokenForCertificate;
    public static AuthenticationMode IssuedTokenForSslNegotiated;
    public static AuthenticationMode IssuedTokenOverTransport;
    public static AuthenticationMode Kerberos;
    public static AuthenticationMode KerberosOverTransport;
    public static AuthenticationMode MutualCertificate;
    public static AuthenticationMode MutualCertificateDuplex;
    public static AuthenticationMode MutualSslNegotiated;
    public static AuthenticationMode SecureConversation;
    public static AuthenticationMode SspiNegotiated;
    public static AuthenticationMode UserNameForCertificate;
    public static AuthenticationMode UserNameForSslNegotiated;
    public static AuthenticationMode UserNameOverTransport;
    public static AuthenticationMode SspiNegotiatedOverTransport;
}
internal static class System.ServiceModel.Configuration.AuthenticationModeHelper : object {
    public static bool IsDefined(AuthenticationMode value);
}
public class System.ServiceModel.Configuration.AuthorizationPolicyTypeElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("policyType")]
[StringValidatorAttribute]
public string PolicyType { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public AuthorizationPolicyTypeElement(string policyType);
    public string get_PolicyType();
    public void set_PolicyType(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.AuthorizationPolicyTypeElement")]
public class System.ServiceModel.Configuration.AuthorizationPolicyTypeElementCollection : ServiceModelConfigurationElementCollection`1<AuthorizationPolicyTypeElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.BaseAddressElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("baseAddress")]
[StringValidatorAttribute]
public string BaseAddress { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_BaseAddress();
    public void set_BaseAddress(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.BaseAddressElement")]
public class System.ServiceModel.Configuration.BaseAddressElementCollection : ServiceModelConfigurationElementCollection`1<BaseAddressElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
public class System.ServiceModel.Configuration.BaseAddressPrefixFilterElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("prefix")]
public Uri Prefix { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BaseAddressPrefixFilterElement(Uri prefix);
    public Uri get_Prefix();
    public void set_Prefix(Uri value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.BaseAddressPrefixFilterElement")]
public class System.ServiceModel.Configuration.BaseAddressPrefixFilterElementCollection : ServiceModelConfigurationElementCollection`1<BaseAddressPrefixFilterElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
public class System.ServiceModel.Configuration.BasicHttpBindingCollectionElement : StandardBindingCollectionElement`2<BasicHttpBinding, BasicHttpBindingElement> {
    internal static BasicHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.BasicHttpBindingElement : HttpBindingBaseElement {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSMessageEncodingHelper")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public BasicHttpSecurityElement Security { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.BasicHttpContextBindingCollectionElement : StandardBindingCollectionElement`2<BasicHttpContextBinding, BasicHttpContextBindingElement> {
    internal static string basicHttpContextBindingName;
    internal static BasicHttpContextBindingCollectionElement GetBindingCollectionElement();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.BasicHttpContextBindingElement : BasicHttpBindingElement {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("contextManagementEnabled")]
public bool ContextManagementEnabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpContextBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    protected internal virtual void InitializeFrom(Binding binding);
    internal virtual void InitializeAllowCookies(HttpBindingBase binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.BasicHttpMessageSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.BasicHttpMessageCredentialTypeHelper")]
public BasicHttpMessageCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("algorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpMessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(BasicHttpMessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal void ApplyConfiguration(BasicHttpMessageSecurity security);
    internal void InitializeFrom(BasicHttpMessageSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.BasicHttpsBindingCollectionElement : StandardBindingCollectionElement`2<BasicHttpsBinding, BasicHttpsBindingElement> {
    internal static BasicHttpsBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.BasicHttpsBindingElement : HttpBindingBaseElement {
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSMessageEncodingHelper")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public BasicHttpsSecurityElement Security { get; }
    protected Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpsBindingElement(string name);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpsSecurityElement get_Security();
    protected virtual Type get_BindingElementType();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.BasicHttpSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.BasicHttpSecurityModeHelper")]
public BasicHttpSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public HttpTransportSecurityElement Transport { get; }
    [ConfigurationPropertyAttribute("message")]
public BasicHttpMessageSecurityElement Message { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpSecurityMode get_Mode();
    public void set_Mode(BasicHttpSecurityMode value);
    public HttpTransportSecurityElement get_Transport();
    public BasicHttpMessageSecurityElement get_Message();
    internal void ApplyConfiguration(BasicHttpSecurity security);
    internal void InitializeFrom(BasicHttpSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.BasicHttpsSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.BasicHttpsSecurityModeHelper")]
public BasicHttpsSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public HttpTransportSecurityElement Transport { get; }
    [ConfigurationPropertyAttribute("message")]
public BasicHttpMessageSecurityElement Message { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BasicHttpsSecurityMode get_Mode();
    public void set_Mode(BasicHttpsSecurityMode value);
    public HttpTransportSecurityElement get_Transport();
    public BasicHttpMessageSecurityElement get_Message();
    internal void ApplyConfiguration(BasicHttpsSecurity security);
    internal void InitializeFrom(BasicHttpsSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.BehaviorExtensionElement : ServiceModelExtensionElement {
    public Type BehaviorType { get; }
    protected internal abstract virtual object CreateBehavior();
    public abstract virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.BehaviorsSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("endpointBehaviors")]
public EndpointBehaviorElementCollection EndpointBehaviors { get; }
    [ConfigurationPropertyAttribute("serviceBehaviors")]
public ServiceBehaviorElementCollection ServiceBehaviors { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public EndpointBehaviorElementCollection get_EndpointBehaviors();
    public ServiceBehaviorElementCollection get_ServiceBehaviors();
    internal static BehaviorsSection GetSection();
    [SecurityCriticalAttribute]
internal static BehaviorsSection UnsafeGetSection();
    [SecurityCriticalAttribute]
internal static BehaviorsSection UnsafeGetAssociatedSection(ContextInformation evalContext);
    [SecuritySafeCriticalAttribute]
internal static void ValidateEndpointBehaviorReference(string behaviorConfiguration, ContextInformation evaluationContext, ConfigurationElement configurationElement);
    [SecuritySafeCriticalAttribute]
internal static void ValidateServiceBehaviorReference(string behaviorConfiguration, ContextInformation evaluationContext, ConfigurationElement configurationElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.BinaryMessageEncodingElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("maxReadPoolSize")]
[IntegerValidatorAttribute]
public int MaxReadPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxWritePoolSize")]
[IntegerValidatorAttribute]
public int MaxWritePoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxSessionSize")]
[IntegerValidatorAttribute]
public int MaxSessionSize { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("compressionFormat")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Channels.CompressionFormatHelper")]
public CompressionFormat CompressionFormat { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public int get_MaxSessionSize();
    public void set_MaxSessionSize(int value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public CompressionFormat get_CompressionFormat();
    public void set_CompressionFormat(CompressionFormat value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected internal virtual BindingElement CreateBindingElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.BindingCollectionElement : ConfigurationElement {
    public string BindingName { get; }
    public Type BindingType { get; }
    public ReadOnlyCollection`1<IBindingConfigurationElement> ConfiguredBindings { get; }
    protected internal abstract virtual Binding GetDefault();
    public string get_BindingName();
    public abstract virtual Type get_BindingType();
    public abstract virtual ReadOnlyCollection`1<IBindingConfigurationElement> get_ConfiguredBindings();
    public abstract virtual bool ContainsKey(string name);
    protected internal abstract virtual bool TryAdd(string name, Binding binding, Configuration config);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public abstract class System.ServiceModel.Configuration.BindingElementExtensionElement : ServiceModelExtensionElement {
    public Type BindingElementType { get; }
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public abstract virtual Type get_BindingElementType();
    protected internal abstract virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Configuration.BindingsSection : ConfigurationSection {
    public BindingCollectionElement Item { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("basicHttpBinding")]
public BasicHttpBindingCollectionElement BasicHttpBinding { get; }
    [ConfigurationPropertyAttribute("basicHttpsBinding")]
public BasicHttpsBindingCollectionElement BasicHttpsBinding { get; }
    [ConfigurationPropertyAttribute("customBinding")]
public CustomBindingCollectionElement CustomBinding { get; }
    [ConfigurationPropertyAttribute("msmqIntegrationBinding")]
public MsmqIntegrationBindingCollectionElement MsmqIntegrationBinding { get; }
    [ConfigurationPropertyAttribute("netHttpBinding")]
public NetHttpBindingCollectionElement NetHttpBinding { get; }
    [ConfigurationPropertyAttribute("netHttpsBinding")]
public NetHttpsBindingCollectionElement NetHttpsBinding { get; }
    [ConfigurationPropertyAttribute("netPeerTcpBinding")]
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public NetPeerTcpBindingCollectionElement NetPeerTcpBinding { get; }
    [ConfigurationPropertyAttribute("netMsmqBinding")]
public NetMsmqBindingCollectionElement NetMsmqBinding { get; }
    [ConfigurationPropertyAttribute("netNamedPipeBinding")]
public NetNamedPipeBindingCollectionElement NetNamedPipeBinding { get; }
    [ConfigurationPropertyAttribute("netTcpBinding")]
public NetTcpBindingCollectionElement NetTcpBinding { get; }
    [ConfigurationPropertyAttribute("wsFederationHttpBinding")]
public WSFederationHttpBindingCollectionElement WSFederationHttpBinding { get; }
    [ConfigurationPropertyAttribute("ws2007FederationHttpBinding")]
public WS2007FederationHttpBindingCollectionElement WS2007FederationHttpBinding { get; }
    [ConfigurationPropertyAttribute("wsHttpBinding")]
public WSHttpBindingCollectionElement WSHttpBinding { get; }
    [ConfigurationPropertyAttribute("ws2007HttpBinding")]
public WS2007HttpBindingCollectionElement WS2007HttpBinding { get; }
    [ConfigurationPropertyAttribute("wsDualHttpBinding")]
public WSDualHttpBindingCollectionElement WSDualHttpBinding { get; }
    public List`1<BindingCollectionElement> BindingCollections { get; }
    public BindingCollectionElement get_Item(string binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public BasicHttpBindingCollectionElement get_BasicHttpBinding();
    public BasicHttpsBindingCollectionElement get_BasicHttpsBinding();
    public CustomBindingCollectionElement get_CustomBinding();
    public MsmqIntegrationBindingCollectionElement get_MsmqIntegrationBinding();
    public NetHttpBindingCollectionElement get_NetHttpBinding();
    public NetHttpsBindingCollectionElement get_NetHttpsBinding();
    public NetPeerTcpBindingCollectionElement get_NetPeerTcpBinding();
    public NetMsmqBindingCollectionElement get_NetMsmqBinding();
    public NetNamedPipeBindingCollectionElement get_NetNamedPipeBinding();
    public NetTcpBindingCollectionElement get_NetTcpBinding();
    public WSFederationHttpBindingCollectionElement get_WSFederationHttpBinding();
    public WS2007FederationHttpBindingCollectionElement get_WS2007FederationHttpBinding();
    public WSHttpBindingCollectionElement get_WSHttpBinding();
    public WS2007HttpBindingCollectionElement get_WS2007HttpBinding();
    public WSDualHttpBindingCollectionElement get_WSDualHttpBinding();
    public static BindingsSection GetSection(Configuration config);
    public List`1<BindingCollectionElement> get_BindingCollections();
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    internal static bool TryAdd(string name, Binding binding, Configuration config, String& bindingSectionName);
    internal static bool TryAdd(string name, Binding binding, String& bindingSectionName);
    [SecuritySafeCriticalAttribute]
internal void UpdateBindingSections(ContextInformation evaluationContext);
    [SecuritySafeCriticalAttribute]
internal static void ValidateBindingReference(string binding, string bindingConfiguration, ContextInformation evaluationContext, ConfigurationElement configurationElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.CallbackDebugElement : BehaviorExtensionElement {
    [ConfigurationPropertyAttribute("includeExceptionDetailInFaults")]
public bool IncludeExceptionDetailInFaults { get; public set; }
    public Type BehaviorType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CallbackTimeoutsElement : BehaviorExtensionElement {
    [ConfigurationPropertyAttribute("transactionTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TransactionTimeout { get; public set; }
    public Type BehaviorType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public TimeSpan get_TransactionTimeout();
    public void set_TransactionTimeout(TimeSpan value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CertificateElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("encodedValue")]
[StringValidatorAttribute]
public string EncodedValue { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_EncodedValue();
    public void set_EncodedValue(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CertificateReferenceElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("isChainIncluded")]
public bool IsChainIncluded { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public string get_FindValue();
    public void set_FindValue(string value);
    public bool get_IsChainIncluded();
    public void set_IsChainIncluded(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ChannelEndpointElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("address")]
public Uri Address { get; public set; }
    [ConfigurationPropertyAttribute("behaviorConfiguration")]
[StringValidatorAttribute]
public string BehaviorConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("binding")]
[StringValidatorAttribute]
public string Binding { get; public set; }
    [ConfigurationPropertyAttribute("bindingConfiguration")]
[StringValidatorAttribute]
public string BindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("contract")]
[StringValidatorAttribute]
public string Contract { get; public set; }
    [ConfigurationPropertyAttribute("headers")]
public AddressHeaderCollectionElement Headers { get; }
    [ConfigurationPropertyAttribute("identity")]
public IdentityElement Identity { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("kind")]
[StringValidatorAttribute]
public string Kind { get; public set; }
    [ConfigurationPropertyAttribute("endpointConfiguration")]
[StringValidatorAttribute]
public string EndpointConfiguration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ChannelEndpointElement(EndpointAddress address, string contractType);
    internal void Copy(ChannelEndpointElement source);
    public Uri get_Address();
    public void set_Address(Uri value);
    public string get_BehaviorConfiguration();
    public void set_BehaviorConfiguration(string value);
    public string get_Binding();
    public void set_Binding(string value);
    public string get_BindingConfiguration();
    public void set_BindingConfiguration(string value);
    public string get_Contract();
    public void set_Contract(string value);
    public AddressHeaderCollectionElement get_Headers();
    public IdentityElement get_Identity();
    public string get_Name();
    public void set_Name(string value);
    public string get_Kind();
    public void set_Kind(string value);
    public string get_EndpointConfiguration();
    public void set_EndpointConfiguration(string value);
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ChannelEndpointElement")]
public class System.ServiceModel.Configuration.ChannelEndpointElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ChannelEndpointElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ChannelPoolSettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("idleTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan IdleTimeout { get; public set; }
    [ConfigurationPropertyAttribute("leaseTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan LeaseTimeout { get; public set; }
    [ConfigurationPropertyAttribute("maxOutboundChannelsPerEndpoint")]
[IntegerValidatorAttribute]
public int MaxOutboundChannelsPerEndpoint { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public TimeSpan get_LeaseTimeout();
    public void set_LeaseTimeout(TimeSpan value);
    public int get_MaxOutboundChannelsPerEndpoint();
    public void set_MaxOutboundChannelsPerEndpoint(int value);
    internal void ApplyConfiguration(ChannelPoolSettings settings);
    internal void InitializeFrom(ChannelPoolSettings settings);
    internal void CopyFrom(ChannelPoolSettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ClaimTypeElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("claimType")]
[StringValidatorAttribute]
public string ClaimType { get; public set; }
    [ConfigurationPropertyAttribute("isOptional")]
public bool IsOptional { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ClaimTypeElement(string claimType, bool isOptional);
    public string get_ClaimType();
    public void set_ClaimType(string value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ClaimTypeElement")]
public class System.ServiceModel.Configuration.ClaimTypeElementCollection : ServiceModelConfigurationElementCollection`1<ClaimTypeElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ClearBehaviorElement : BehaviorExtensionElement {
    public Type BehaviorType { get; }
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ClientCredentialsElement : BehaviorExtensionElement {
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    [ConfigurationPropertyAttribute("useIdentityConfiguration")]
public bool UseIdentityConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("clientCertificate")]
public X509InitiatorCertificateClientElement ClientCertificate { get; }
    [ConfigurationPropertyAttribute("serviceCertificate")]
public X509RecipientCertificateClientElement ServiceCertificate { get; }
    [ConfigurationPropertyAttribute("windows")]
public WindowsClientElement Windows { get; }
    [ConfigurationPropertyAttribute("issuedToken")]
public IssuedTokenClientElement IssuedToken { get; }
    [ConfigurationPropertyAttribute("httpDigest")]
public HttpDigestClientElement HttpDigest { get; }
    [ConfigurationPropertyAttribute("peer")]
public PeerCredentialElement Peer { get; }
    [ConfigurationPropertyAttribute("supportInteractive")]
public bool SupportInteractive { get; public set; }
    public Type BehaviorType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_Type();
    public void set_Type(string value);
    public bool get_UseIdentityConfiguration();
    public void set_UseIdentityConfiguration(bool value);
    public X509InitiatorCertificateClientElement get_ClientCertificate();
    public X509RecipientCertificateClientElement get_ServiceCertificate();
    public WindowsClientElement get_Windows();
    public IssuedTokenClientElement get_IssuedToken();
    public HttpDigestClientElement get_HttpDigest();
    public PeerCredentialElement get_Peer();
    public bool get_SupportInteractive();
    public void set_SupportInteractive(bool value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    protected internal void ApplyConfiguration(ClientCredentials behavior);
    public virtual Type get_BehaviorType();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ClientSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public ChannelEndpointElementCollection Endpoints { get; }
    [ConfigurationPropertyAttribute("metadata")]
public MetadataElement Metadata { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ChannelEndpointElementCollection get_Endpoints();
    public MetadataElement get_Metadata();
    internal static ClientSection GetSection();
    [SecurityCriticalAttribute]
internal static ClientSection UnsafeGetSection();
    [SecurityCriticalAttribute]
internal static ClientSection UnsafeGetSection(ContextInformation contextInformation);
    protected virtual void InitializeDefault();
    protected virtual void PostDeserialize();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ClientViaElement : BehaviorExtensionElement {
    [ConfigurationPropertyAttribute("viaUri")]
public Uri ViaUri { get; public set; }
    public Type BehaviorType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Uri get_ViaUri();
    public void set_ViaUri(Uri value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ComContractElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("contract")]
[StringValidatorAttribute]
public string Contract { get; public set; }
    [ConfigurationPropertyAttribute("exposedMethods")]
public ComMethodElementCollection ExposedMethods { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("namespace")]
[StringValidatorAttribute]
public string Namespace { get; public set; }
    [ConfigurationPropertyAttribute("persistableTypes")]
public ComPersistableTypeElementCollection PersistableTypes { get; }
    [ConfigurationPropertyAttribute("requiresSession")]
public bool RequiresSession { get; public set; }
    [ConfigurationPropertyAttribute("userDefinedTypes")]
public ComUdtElementCollection UserDefinedTypes { get; }
    public ComContractElement(string contractType);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Contract();
    public void set_Contract(string value);
    public ComMethodElementCollection get_ExposedMethods();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ComPersistableTypeElementCollection get_PersistableTypes();
    public bool get_RequiresSession();
    public void set_RequiresSession(bool value);
    public ComUdtElementCollection get_UserDefinedTypes();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ComContractElement")]
public class System.ServiceModel.Configuration.ComContractElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ComContractElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ComContractsSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public ComContractElementCollection ComContracts { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ComContractElementCollection get_ComContracts();
    internal static ComContractsSection GetSection();
}
public class System.ServiceModel.Configuration.ComMethodElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("exposedMethod")]
[StringValidatorAttribute]
public string ExposedMethod { get; public set; }
    public ComMethodElement(string method);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_ExposedMethod();
    public void set_ExposedMethod(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ComMethodElement")]
public class System.ServiceModel.Configuration.ComMethodElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ComMethodElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.CommonBehaviorsSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("endpointBehaviors")]
public CommonEndpointBehaviorElement EndpointBehaviors { get; }
    [ConfigurationPropertyAttribute("serviceBehaviors")]
public CommonServiceBehaviorElement ServiceBehaviors { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public CommonEndpointBehaviorElement get_EndpointBehaviors();
    public CommonServiceBehaviorElement get_ServiceBehaviors();
    internal static CommonBehaviorsSection GetSection();
    [SecurityCriticalAttribute]
internal static CommonBehaviorsSection UnsafeGetSection();
    [SecurityCriticalAttribute]
internal static CommonBehaviorsSection UnsafeGetAssociatedSection(ContextInformation contextEval);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CommonEndpointBehaviorElement : ServiceModelExtensionCollectionElement`1<BehaviorExtensionElement> {
    public virtual void Add(BehaviorExtensionElement element);
    public virtual bool CanAdd(BehaviorExtensionElement element);
}
public class System.ServiceModel.Configuration.CommonServiceBehaviorElement : ServiceModelExtensionCollectionElement`1<BehaviorExtensionElement> {
    public virtual void Add(BehaviorExtensionElement element);
    public virtual bool CanAdd(BehaviorExtensionElement element);
}
public class System.ServiceModel.Configuration.ComPersistableTypeElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("ID")]
[StringValidatorAttribute]
public string ID { get; public set; }
    public ComPersistableTypeElement(string ID);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public string get_ID();
    public void set_ID(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ComPersistableTypeElement")]
public class System.ServiceModel.Configuration.ComPersistableTypeElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ComPersistableTypeElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.CompositeDuplexElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("clientBaseAddress")]
public Uri ClientBaseAddress { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    public Uri get_ClientBaseAddress();
    public void set_ClientBaseAddress(Uri value);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ComUdtElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("typeLibID")]
[StringValidatorAttribute]
public string TypeLibID { get; public set; }
    [ConfigurationPropertyAttribute("typeLibVersion")]
[StringValidatorAttribute]
public string TypeLibVersion { get; public set; }
    [ConfigurationPropertyAttribute("typeDefID")]
[StringValidatorAttribute]
public string TypeDefID { get; public set; }
    public ComUdtElement(string typeDefID);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public string get_TypeLibID();
    public void set_TypeLibID(string value);
    public string get_TypeLibVersion();
    public void set_TypeLibVersion(string value);
    public string get_TypeDefID();
    public void set_TypeDefID(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ComUdtElement")]
public class System.ServiceModel.Configuration.ComUdtElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ComUdtElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ConfigurationChannelFactory`1 : ChannelFactory`1<TChannel> {
    public ConfigurationChannelFactory`1(string endpointConfigurationName, Configuration configuration, EndpointAddress remoteAddress);
}
public class System.ServiceModel.Configuration.ConfigurationDuplexChannelFactory`1 : DuplexChannelFactory`1<TChannel> {
    public ConfigurationDuplexChannelFactory`1(object callbackObject, string endpointConfigurationName, EndpointAddress remoteAddress, Configuration configuration);
}
internal static class System.ServiceModel.Configuration.ConfigurationHelpers : object {
    internal static BindingCollectionElement GetAssociatedBindingCollectionElement(ContextInformation evaluationContext, string bindingCollectionName);
    [SecurityCriticalAttribute]
internal static BindingCollectionElement UnsafeGetAssociatedBindingCollectionElement(ContextInformation evaluationContext, string bindingCollectionName);
    internal static EndpointCollectionElement GetAssociatedEndpointCollectionElement(ContextInformation evaluationContext, string endpointCollectionName);
    [SecurityCriticalAttribute]
internal static EndpointCollectionElement UnsafeGetAssociatedEndpointCollectionElement(ContextInformation evaluationContext, string endpointCollectionName);
    internal static object GetAssociatedSection(ContextInformation evalContext, string sectionPath);
    [SecurityCriticalAttribute]
internal static object UnsafeGetAssociatedSection(ContextInformation evalContext, string sectionPath);
    internal static BindingCollectionElement GetBindingCollectionElement(string bindingCollectionName);
    [SecurityCriticalAttribute]
internal static BindingCollectionElement UnsafeGetBindingCollectionElement(string bindingCollectionName);
    internal static string GetBindingsSectionPath(string sectionName);
    internal static string GetEndpointsSectionPath(string sectionName);
    internal static EndpointCollectionElement GetEndpointCollectionElement(string endpointCollectionName);
    [SecurityCriticalAttribute]
internal static EndpointCollectionElement UnsafeGetEndpointCollectionElement(string endpointCollectionName);
    internal static object GetSection(string sectionPath);
    [SecurityCriticalAttribute]
internal static object UnsafeGetSection(string sectionPath);
    [SecurityCriticalAttribute]
internal static object UnsafeGetSectionNoTrace(string sectionPath);
    [SecurityCriticalAttribute]
internal static object UnsafeGetSectionFromContext(ContextInformation evalContext, string sectionPath);
    internal static string GetSectionPath(string sectionName);
    [SecurityCriticalAttribute]
internal static void SetIsPresent(ConfigurationElement element);
    internal static ContextInformation GetEvaluationContext(IConfigurationContextProviderInternal provider);
    internal static ContextInformation GetOriginalEvaluationContext(IConfigurationContextProviderInternal provider);
    internal static void TraceExtensionTypeNotFound(ExtensionElement extensionElement);
}
internal static class System.ServiceModel.Configuration.ConfigurationStrings : object {
    internal static string AcknowledgementInterval;
    internal static string ActivityTracing;
    internal static string Add;
    internal static string AdditionalRequestParameters;
    internal static string Address;
    internal static string AlgorithmSuite;
    internal static string AllowAnonymousLogons;
    internal static string AllowCookies;
    internal static string AllowedAudienceUris;
    internal static string AllowedAudienceUri;
    internal static string AllowedImpersonationLevel;
    internal static string AllowInsecureTransport;
    internal static string AllowNtlm;
    internal static string AllowSerializedSigningTokenOnReply;
    internal static string AllowUntrustedRsaIssuers;
    internal static string AlternativeIssuedTokenParameters;
    internal static string ApplicationContainerSettings;
    internal static string AspNetCompatibilityEnabled;
    internal static string AsynchronousSendEnabled;
    internal static string AudienceUriMode;
    internal static string AuditLogLocation;
    internal static string Authentication;
    internal static string AuthenticationMode;
    internal static string AuthenticationScheme;
    internal static string AuthenticationSchemes;
    internal static string AuthorizationPolicies;
    internal static string BaseAddress;
    internal static string BaseAddresses;
    internal static string BaseAddressPrefixFilters;
    internal static string Basic128;
    internal static string Basic192;
    internal static string Basic256;
    internal static string Basic128Rsa15;
    internal static string Basic192Rsa15;
    internal static string Basic256Rsa15;
    internal static string Basic128Sha256;
    internal static string Basic192Sha256;
    internal static string Basic256Sha256;
    internal static string Basic128Sha256Rsa15;
    internal static string Basic192Sha256Rsa15;
    internal static string Basic256Sha256Rsa15;
    internal static string BasicHttpBindingCollectionElementName;
    internal static string BasicHttpsBindingCollectionElementName;
    internal static string Behavior;
    internal static string BehaviorConfiguration;
    internal static string BehaviorExtensions;
    internal static string BehaviorsSectionName;
    internal static string BinaryMessageEncodingSectionName;
    internal static string Binding;
    internal static string BindingConfiguration;
    internal static string BindingElementExtensions;
    internal static string BindingExtensions;
    internal static string BindingName;
    internal static string BindingNamespace;
    internal static string BindingsSectionGroupName;
    internal static string BypassProxyOnLocal;
    internal static string CacheCookies;
    internal static string CachedLogonTokenLifetime;
    internal static string CacheIssuedTokens;
    internal static string CacheLogonTokens;
    internal static string CallbackDebugSectionName;
    internal static string CallbackTimeouts;
    internal static string CanRenewSecurityContextToken;
    internal static string Certificate;
    internal static string CertificateReference;
    internal static string CertificateValidationMode;
    internal static string Channel;
    internal static string ChannelInitializationTimeout;
    internal static string ChannelPoolSettings;
    internal static string ClaimType;
    internal static string ClaimTypeRequirements;
    internal static string Clear;
    internal static string ClientBaseAddress;
    internal static string ClientCallbackAddressName;
    internal static string ClientCertificate;
    internal static string ClientCredentials;
    internal static string ClientCredentialType;
    internal static string ClientSectionName;
    internal static string ClientViaSectionName;
    internal static string CloseIdleServicesAtLowMemory;
    internal static string CloseTimeout;
    internal static string ComContract;
    internal static string ComContractName;
    internal static string ComContractNamespace;
    internal static string ComContractsSectionName;
    internal static string ComMethod;
    internal static string ComMethodCollection;
    internal static string CommonBehaviorsSectionName;
    internal static string ComPersistableTypes;
    internal static string CompositeDuplexSectionName;
    internal static string CompressionFormat;
    internal static string ComSessionRequired;
    internal static string ComUdt;
    internal static string ComUdtCollection;
    internal static string ConnectionBufferSize;
    internal static string ConnectionPoolSettings;
    internal static string Contract;
    internal static string Cookie;
    internal static string CookieRenewalThresholdPercentage;
    internal static string CreateNotificationOnConnection;
    internal static string Custom;
    internal static string CustomBindingCollectionElementName;
    internal static string CustomCertificateValidatorType;
    internal static string CustomDeadLetterQueue;
    internal static string CustomUserNamePasswordValidatorType;
    internal static string DataContractSerializerSectionName;
    internal static string DeadLetterQueue;
    internal static string DecompressionEnabled;
    internal static string Default;
    internal static string DefaultAlgorithmSuite;
    internal static string DefaultCertificate;
    internal static string DefaultCollectionName;
    internal static string DefaultKeyEntropyMode;
    internal static string DefaultMessageSecurityVersion;
    internal static string DefaultName;
    internal static string DefaultPorts;
    internal static string DetectReplays;
    internal static string DiagnosticSectionName;
    internal static string DisablePayloadMasking;
    internal static string Dns;
    internal static string Durable;
    internal static string Enabled;
    internal static string EnableUnsecuredResponse;
    internal static string EncodedValue;
    internal static string Endpoint;
    internal static string EndpointBehaviors;
    internal static string EndpointConfiguration;
    internal static string EndpointExtensions;
    internal static string EndToEndTracing;
    internal static string EstablishSecurityContext;
    internal static string EtwProviderId;
    internal static string ExactlyOnce;
    internal static string ExposedMethod;
    internal static string ExtendedProtectionPolicy;
    internal static string Extension;
    internal static string Extensions;
    internal static string ExternalMetadataLocation;
    internal static string Factory;
    internal static string Filter;
    internal static string Filters;
    internal static string FindValue;
    internal static string FlowControlEnabled;
    internal static string GroupName;
    internal static string Handler;
    internal static string Handlers;
    internal static string Header;
    internal static string Headers;
    internal static string Host;
    internal static string HostNameComparisonMode;
    internal static string HttpDigest;
    internal static string HttpGetEnabled;
    internal static string HttpGetUrl;
    internal static string HttpsGetEnabled;
    internal static string HttpsGetUrl;
    internal static string HttpHelpPageEnabled;
    internal static string HttpHelpPageUrl;
    internal static string HttpsHelpPageEnabled;
    internal static string HttpsHelpPageUrl;
    internal static string HttpHelpPageBinding;
    internal static string HttpHelpPageBindingConfiguration;
    internal static string HttpsHelpPageBinding;
    internal static string HttpsHelpPageBindingConfiguration;
    internal static string HttpGetBinding;
    internal static string HttpGetBindingConfiguration;
    internal static string HttpsGetBinding;
    internal static string HttpsGetBindingConfiguration;
    internal static string MexHttpBindingCollectionElementName;
    internal static string HttpsTransportSectionName;
    internal static string HttpTransportSectionName;
    internal static string MexHttpsBindingCollectionElementName;
    internal static string ID;
    internal static string Identity;
    internal static string IdentityConfiguration;
    internal static string IdleTimeout;
    internal static string IgnoreExtensionDataObject;
    internal static string ImpersonateCallerForAllOperations;
    internal static string ImpersonateOnSerializingReply;
    internal static string ImpersonationLevel;
    internal static string InactivityTimeout;
    internal static string IncludeExceptionDetailInFaults;
    internal static string IncludeTimestamp;
    internal static string IncludeWindowsGroups;
    internal static string IsChainIncluded;
    internal static string IsOptional;
    internal static string IssuedCookieLifetime;
    internal static string IssuedKeyType;
    internal static string IssuedToken;
    internal static string IssuedTokenAuthentication;
    internal static string IssuedTokenParameters;
    internal static string IssuedTokenRenewalThresholdPercentage;
    internal static string IssuedTokenType;
    internal static string Issuer;
    internal static string IssuerAddress;
    internal static string IssuerChannelBehaviors;
    internal static string IssuerMetadata;
    internal static string IsSystemEndpoint;
    internal static string KeepAliveEnabled;
    internal static string KeepAliveInterval;
    internal static string KeyEntropyMode;
    internal static string KeySize;
    internal static string KeyType;
    internal static string Kind;
    internal static string KnownCertificates;
    internal static string LeaseTimeout;
    internal static string ListenBacklog;
    internal static string ListenIPAddress;
    internal static string ListenUri;
    internal static string ListenUriMode;
    internal static string LocalClientSettings;
    internal static string LocalIssuer;
    internal static string LocalIssuerChannelBehaviors;
    internal static string LocalServiceSettings;
    internal static string LogEntireMessage;
    internal static string LogKnownPii;
    internal static string LogMalformedMessages;
    internal static string LogMessagesAtServiceLevel;
    internal static string LogMessagesAtTransportLevel;
    internal static string ManualAddressing;
    internal static string MapClientCertificateToWindowsAccount;
    internal static string MaxAcceptedChannels;
    internal static string MaxArrayLength;
    internal static string MaxBatchSize;
    internal static string MaxBufferPoolSize;
    internal static string MaxBufferSize;
    internal static string MaxBytesPerRead;
    internal static string MaxCachedCookies;
    internal static string MaxCachedLogonTokens;
    internal static string MaxClockSkew;
    internal static string MaxConcurrentCalls;
    internal static string MaxConcurrentInstances;
    internal static string MaxConcurrentSessions;
    internal static string MaxConnections;
    internal static string MaxCookieCachingTime;
    internal static string MaxDepth;
    internal static string MaxIssuedTokenCachingTime;
    internal static string MaxItemsInObjectGraph;
    internal static string MaxMessagesToLog;
    internal static string MaxNameTableCharCount;
    internal static string MaxOutboundChannelsPerEndpoint;
    internal static string MaxOutboundConnectionsPerEndpoint;
    internal static string MaxOutputDelay;
    internal static string MaxPendingAccepts;
    internal static string MaxPendingChannels;
    internal static string MaxPendingConnections;
    internal static string MaxPendingReceives;
    internal static string MaxPendingSessions;
    internal static string MaxPoolSize;
    internal static string MaxReadPoolSize;
    internal static string MaxReceivedMessageSize;
    internal static string MaxRetryCount;
    internal static string MaxRetryCycles;
    internal static string MaxSessionSize;
    internal static string MaxSizeOfMessageToLog;
    internal static string MaxStatefulNegotiations;
    internal static string MaxStringContentLength;
    internal static string MaxTransferWindowSize;
    internal static string MaxWritePoolSize;
    internal static string MembershipProviderName;
    internal static string Message;
    internal static string MessageAuthenticationAuditLevel;
    internal static string MessageEncoding;
    internal static string MessageFlowTracing;
    internal static string MessageHandlerFactory;
    internal static string MessageLogging;
    internal static string MessageProtectionOrder;
    internal static string MessageSecurityVersion;
    internal static string MessageSenderAuthentication;
    internal static string MessageVersion;
    internal static string Metadata;
    internal static string MinFreeMemoryPercentageToActivateService;
    internal static string Mode;
    internal static string MsmqAuthenticationMode;
    internal static string MsmqEncryptionAlgorithm;
    internal static string MsmqIntegrationBindingCollectionElementName;
    internal static string MsmqIntegrationSectionName;
    internal static string MsmqProtectionLevel;
    internal static string MsmqSecureHashAlgorithm;
    internal static string MsmqTransportSectionName;
    internal static string MsmqTransportSecurity;
    internal static string MtomMessageEncodingSectionName;
    internal static string MultipleSiteBindingsEnabled;
    internal static string Name;
    internal static string NamedPipeTransportSectionName;
    internal static string NegotiateServiceCredential;
    internal static string NegotiationTimeout;
    internal static string NetMsmqBindingCollectionElementName;
    internal static string NetNamedPipeBindingCollectionElementName;
    internal static string MexNamedPipeBindingCollectionElementName;
    internal static string NetPeerTcpBindingCollectionElementName;
    internal static string NetTcpBindingCollectionElementName;
    internal static string NetHttpBindingCollectionElementName;
    internal static string NetHttpsBindingCollectionElementName;
    internal static string NodeQuota;
    internal static string None;
    internal static string OleTransactions;
    internal static string OneWaySectionName;
    internal static string MexTcpBindingCollectionElementName;
    internal static string MexStandardEndpointCollectionElementName;
    internal static string OpenTimeout;
    internal static string Ordered;
    internal static string PackageFullName;
    internal static string PacketRoutable;
    internal static string Peer;
    internal static string PeerAuthentication;
    internal static string PeerResolver;
    internal static string PeerResolverType;
    internal static string PeerTransportCredentialType;
    internal static string PeerTransportSectionName;
    internal static string PerformanceCounters;
    internal static string PipeSettings;
    internal static string PnrpPeerResolverSectionName;
    internal static string Policy12;
    internal static string Policy15;
    internal static string PolicyImporters;
    internal static string PolicyType;
    internal static string PolicyVersion;
    internal static string Port;
    internal static string PortSharingEnabled;
    internal static string Prefix;
    internal static string PrincipalPermissionMode;
    internal static string PrivacyNoticeAt;
    internal static string PrivacyNoticeSectionName;
    internal static string PrivacyNoticeVersion;
    internal static string PropagateActivity;
    internal static string ProtectionLevel;
    internal static string ProtectTokens;
    internal static string ProtocolMappingSectionName;
    internal static string ProxyAddress;
    internal static string ProxyAuthenticationScheme;
    internal static string ProxyCredentialType;
    internal static string QueueTransferProtocol;
    internal static string ReaderQuotas;
    internal static string Realm;
    internal static string ReceiveContextEnabled;
    internal static string ReceiveErrorHandling;
    internal static string ReceiveRetryCount;
    internal static string ReceiveTimeout;
    internal static string ReconnectTransportOnFailure;
    internal static string ReferralPolicy;
    internal static string ReliableMessagingVersion;
    internal static string RelativeAddress;
    internal static string ReliableSession;
    internal static string ReliableSessionSectionName;
    internal static string Remove;
    internal static string ReplayCacheSize;
    internal static string ReplayWindow;
    internal static string RequestInitializationTimeout;
    internal static string RequireClientCertificate;
    internal static string RequireDerivedKeys;
    internal static string RequireSecurityContextCancellation;
    internal static string RequireSignatureConfirmation;
    internal static string RetryCycleDelay;
    internal static string RevocationMode;
    internal static string RoleProviderName;
    internal static string Rsa;
    internal static string SamlSerializerType;
    internal static string Scheme;
    internal static string ScopedCertificates;
    internal static string SectionGroupName;
    internal static string SecureConversationAuthentication;
    internal static string SecureConversationBootstrap;
    internal static string Security;
    internal static string SecurityHeaderLayout;
    internal static string SecuritySectionName;
    internal static string SecurityStateEncoderType;
    internal static string SendTimeout;
    internal static string SerializationFormat;
    internal static string Service;
    internal static string ServiceActivations;
    internal static string ServiceAuthenticationManagerSectionName;
    internal static string ServiceAuthenticationManagerType;
    internal static string ServiceAuthorizationAuditLevel;
    internal static string ServiceAuthorizationManagerType;
    internal static string ServiceAuthorizationSectionName;
    internal static string ServiceBehaviors;
    internal static string ServiceCertificate;
    internal static string ServiceCredentials;
    internal static string ServiceDebugSectionName;
    internal static string ServiceHostingEnvironmentSectionName;
    internal static string ServiceMetadataPublishingSectionName;
    internal static string ServicePrincipalName;
    internal static string ServiceSecurityAuditSectionName;
    internal static string ServicesSectionName;
    internal static string ServiceThrottlingSectionName;
    internal static string ServiceTimeouts;
    internal static string Session;
    internal static string SessionIdAttribute;
    internal static string SessionKeyRenewalInterval;
    internal static string SessionKeyRolloverInterval;
    internal static string Soap11;
    internal static string Soap11WSAddressing10;
    internal static string Soap11WSAddressingAugust2004;
    internal static string Soap12;
    internal static string Soap12WSAddressing10;
    internal static string Soap12WSAddressingAugust2004;
    internal static string SslCertificateAuthentication;
    internal static string SslProtocols;
    internal static string SslStreamSecuritySectionName;
    internal static string StandardEndpoint;
    internal static string StandardEndpointsSectionName;
    internal static string StoreLocation;
    internal static string StoreName;
    internal static string SubProtocol;
    internal static string SupportInteractive;
    internal static string SuppressAuditFailure;
    internal static string SynchronousReceiveSectionName;
    internal static string DispatcherSynchronizationSectionName;
    internal static string TargetUri;
    internal static string TcpTransportSectionName;
    internal static string TeredoEnabled;
    internal static string TextEncoding;
    internal static string TextMessageEncodingSectionName;
    internal static string Timeouts;
    internal static string TimeSpanInfinite;
    internal static string TimeSpanOneTick;
    internal static string TimeSpanZero;
    internal static string TimestampValidityDuration;
    internal static string TimeToLive;
    internal static string TokenRequestParameters;
    internal static string TokenType;
    internal static string TransactedBatchingSectionName;
    internal static string TransactionFlow;
    internal static string TransactionFlowSectionName;
    internal static string TransactionProtocol;
    internal static string TransactionTimeout;
    internal static string TransactionAllowWildcardAction;
    internal static string TransferMode;
    internal static string Transport;
    internal static string TransportConfigurationType;
    internal static string TransportUsage;
    internal static string TripleDes;
    internal static string TripleDesRsa15;
    internal static string TripleDesSha256;
    internal static string TripleDesSha256Rsa15;
    internal static string TrustedStoreLocation;
    internal static string Type;
    internal static string TypeDefID;
    internal static string TypeLibID;
    internal static string TypeLibVersion;
    internal static string UdpBindingCollectionElementName;
    internal static string UdpBindingCollectionElementType;
    internal static string UdpTransportElementType;
    internal static string UdpTransportImporterType;
    internal static string UdpTransportSectionName;
    internal static string UnrecognizedPolicyAssertionSectionName;
    internal static string UnsafeConnectionNtlmAuthentication;
    internal static string Url;
    internal static string UseActiveDirectory;
    internal static string UseDefaultWebProxy;
    internal static string UseIdentityConfiguration;
    internal static string UseManagedPresentationSectionName;
    internal static string UseMsmqTracing;
    internal static string UserNameAuthentication;
    internal static string UserNamePasswordValidationMode;
    internal static string UserPrincipalName;
    internal static string UseRequestHeadersForMetadataAddress;
    internal static string UseSourceJournal;
    internal static string UseStrTransform;
    internal static string ValidityDuration;
    internal static string Value;
    internal static string Version;
    internal static string ViaUri;
    internal static string WebSocketSettingsSectionName;
    internal static string Windows;
    internal static string WindowsAuthentication;
    internal static string WindowsStreamSecuritySectionName;
    internal static string WmiProviderEnabled;
    internal static string WriteEncoding;
    internal static string WSAtomicTransactionOctober2004;
    internal static string WSAtomicTransaction11;
    internal static string WsdlImporters;
    internal static string WSDualHttpBindingCollectionElementName;
    internal static string WSFederationHttpBindingCollectionElementName;
    internal static string WS2007FederationHttpBindingCollectionElementName;
    internal static string WS2007HttpBindingCollectionElementName;
    internal static string WSHttpBindingCollectionElementName;
    internal static string WSReliableMessaging11;
    internal static string WSReliableMessagingFebruary2005;
    internal static string WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10;
    internal static string WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11;
    internal static string WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10;
    internal static string WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10;
    internal static string WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12;
    internal static string WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10;
    internal static string X509FindType;
    internal static string XmlElement;
    internal static string BehaviorsSectionPath { get; }
    internal static string BindingsSectionGroupPath { get; }
    internal static string ClientSectionPath { get; }
    internal static string ComContractsSectionPath { get; }
    internal static string CommonBehaviorsSectionPath { get; }
    internal static string DiagnosticSectionPath { get; }
    internal static string ExtensionsSectionPath { get; }
    internal static string ProtocolMappingSectionPath { get; }
    internal static string ServiceHostingEnvironmentSectionPath { get; }
    internal static string ServicesSectionPath { get; }
    internal static string StandardEndpointsSectionPath { get; }
    internal static string get_BehaviorsSectionPath();
    internal static string get_BindingsSectionGroupPath();
    internal static string get_ClientSectionPath();
    internal static string get_ComContractsSectionPath();
    internal static string get_CommonBehaviorsSectionPath();
    internal static string get_DiagnosticSectionPath();
    internal static string get_ExtensionsSectionPath();
    internal static string get_ProtocolMappingSectionPath();
    internal static string get_ServiceHostingEnvironmentSectionPath();
    internal static string get_ServicesSectionPath();
    internal static string get_StandardEndpointsSectionPath();
}
public abstract class System.ServiceModel.Configuration.ConnectionOrientedTransportElement : TransportElement {
    [ConfigurationPropertyAttribute("connectionBufferSize")]
[IntegerValidatorAttribute]
public int ConnectionBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("channelInitializationTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ChannelInitializationTimeout { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingConnections")]
[IntegerValidatorAttribute]
public int MaxPendingConnections { get; public set; }
    [ConfigurationPropertyAttribute("maxOutputDelay")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan MaxOutputDelay { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingAccepts")]
[IntegerValidatorAttribute]
public int MaxPendingAccepts { get; public set; }
    [ConfigurationPropertyAttribute("transferMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TransferModeHelper")]
public TransferMode TransferMode { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public int get_ConnectionBufferSize();
    public void set_ConnectionBufferSize(int value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public TimeSpan get_ChannelInitializationTimeout();
    public void set_ChannelInitializationTimeout(TimeSpan value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    public TimeSpan get_MaxOutputDelay();
    public void set_MaxOutputDelay(TimeSpan value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.ContextBindingElementExtensionElement : BindingElementExtensionElement {
    internal static string ContextExchangeMechanismName;
    internal static string ContextManagementEnabledName;
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("clientCallbackAddress")]
public Uri ClientCallbackAddress { get; public set; }
    [ConfigurationPropertyAttribute("contextExchangeMechanism")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Channels.ContextExchangeMechanismHelper")]
public ContextExchangeMechanism ContextExchangeMechanism { get; public set; }
    [ConfigurationPropertyAttribute("protectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel ProtectionLevel { get; public set; }
    [ConfigurationPropertyAttribute("contextManagementEnabled")]
public bool ContextManagementEnabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public Uri get_ClientCallbackAddress();
    public void set_ClientCallbackAddress(Uri value);
    public ContextExchangeMechanism get_ContextExchangeMechanism();
    public void set_ContextExchangeMechanism(ContextExchangeMechanism value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    protected internal virtual BindingElement CreateBindingElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CustomBindingCollectionElement : BindingCollectionElement {
    [ConfigurationPropertyAttribute("")]
public CustomBindingElementCollection Bindings { get; }
    public Type BindingType { get; }
    public ReadOnlyCollection`1<IBindingConfigurationElement> ConfiguredBindings { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public CustomBindingElementCollection get_Bindings();
    public virtual Type get_BindingType();
    public virtual ReadOnlyCollection`1<IBindingConfigurationElement> get_ConfiguredBindings();
    public virtual bool ContainsKey(string name);
    protected internal virtual Binding GetDefault();
    internal static CustomBindingCollectionElement GetBindingCollectionElement();
    protected internal virtual bool TryAdd(string name, Binding binding, Configuration config);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.CustomBindingElement : NamedServiceModelExtensionCollectionElement`1<BindingElementExtensionElement> {
    [ConfigurationPropertyAttribute("closeTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan CloseTimeout { get; public set; }
    [ConfigurationPropertyAttribute("openTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan OpenTimeout { get; public set; }
    [ConfigurationPropertyAttribute("receiveTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReceiveTimeout { get; public set; }
    [ConfigurationPropertyAttribute("sendTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SendTimeout { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public CustomBindingElement(string name);
    public sealed virtual TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_SendTimeout();
    public void set_SendTimeout(TimeSpan value);
    public virtual void Add(BindingElementExtensionElement element);
    public sealed virtual void ApplyConfiguration(Binding binding);
    public virtual bool CanAdd(BindingElementExtensionElement element);
    protected void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.CustomBindingElement")]
public class System.ServiceModel.Configuration.CustomBindingElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<CustomBindingElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.DataContractSerializerElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("ignoreExtensionDataObject")]
public bool IgnoreExtensionDataObject { get; public set; }
    [ConfigurationPropertyAttribute("maxItemsInObjectGraph")]
[IntegerValidatorAttribute]
public int MaxItemsInObjectGraph { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.DefaultPortElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("scheme")]
[StringValidatorAttribute]
public string Scheme { get; public set; }
    [ConfigurationPropertyAttribute("port")]
[IntegerValidatorAttribute]
public int Port { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public DefaultPortElement(DefaultPortElement other);
    public string get_Scheme();
    public void set_Scheme(string value);
    public int get_Port();
    public void set_Port(int value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.DefaultPortElement")]
public class System.ServiceModel.Configuration.DefaultPortElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<DefaultPortElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.DelegatingHandlerElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    internal Guid Id { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal DelegatingHandlerElement(Type handlerType);
    public string get_Type();
    public void set_Type(string value);
    internal Guid get_Id();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.DelegatingHandlerElement")]
public class System.ServiceModel.Configuration.DelegatingHandlerElementCollection : ServiceModelConfigurationElementCollection`1<DelegatingHandlerElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.DiagnosticSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("wmiProviderEnabled")]
public bool WmiProviderEnabled { get; public set; }
    [ConfigurationPropertyAttribute("messageLogging")]
public MessageLoggingElement MessageLogging { get; }
    [ConfigurationPropertyAttribute("endToEndTracing")]
public EndToEndTracingElement EndToEndTracing { get; }
    [ConfigurationPropertyAttribute("performanceCounters")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Diagnostics.PerformanceCounterScopeHelper")]
public PerformanceCounterScope PerformanceCounters { get; public set; }
    [ConfigurationPropertyAttribute("etwProviderId")]
[StringValidatorAttribute]
public string EtwProviderId { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_WmiProviderEnabled();
    public void set_WmiProviderEnabled(bool value);
    public MessageLoggingElement get_MessageLogging();
    public EndToEndTracingElement get_EndToEndTracing();
    public PerformanceCounterScope get_PerformanceCounters();
    public void set_PerformanceCounters(PerformanceCounterScope value);
    public string get_EtwProviderId();
    public void set_EtwProviderId(string value);
    internal static DiagnosticSection GetSection();
    [SecurityCriticalAttribute]
internal static DiagnosticSection UnsafeGetSection();
    [SecurityCriticalAttribute]
internal static DiagnosticSection UnsafeGetSectionNoTrace();
    internal bool IsEtwProviderIdFromConfigFile();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.DispatcherSynchronizationElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("asynchronousSendEnabled")]
public bool AsynchronousSendEnabled { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingReceives")]
[IntegerValidatorAttribute]
public int MaxPendingReceives { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_AsynchronousSendEnabled();
    public void set_AsynchronousSendEnabled(bool value);
    public int get_MaxPendingReceives();
    public void set_MaxPendingReceives(int value);
    public virtual Type get_BehaviorType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
}
public class System.ServiceModel.Configuration.DnsElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("value")]
[StringValidatorAttribute]
public string Value { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_Value();
    public void set_Value(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.ServiceModel.Configuration.EncodingConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.EndpointAddressElementBase : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("address")]
public Uri Address { get; public set; }
    [ConfigurationPropertyAttribute("headers")]
public AddressHeaderCollectionElement Headers { get; }
    [ConfigurationPropertyAttribute("identity")]
public IdentityElement Identity { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Uri get_Address();
    public void set_Address(Uri value);
    public AddressHeaderCollectionElement get_Headers();
    public IdentityElement get_Identity();
    protected internal void Copy(EndpointAddressElementBase source);
    public void InitializeFrom(EndpointAddress endpointAddress);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.EndpointBehaviorElement : NamedServiceModelExtensionCollectionElement`1<BehaviorExtensionElement> {
    public EndpointBehaviorElement(string name);
    public virtual void Add(BehaviorExtensionElement element);
    public virtual bool CanAdd(BehaviorExtensionElement element);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.EndpointBehaviorElement")]
public class System.ServiceModel.Configuration.EndpointBehaviorElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<EndpointBehaviorElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
}
public abstract class System.ServiceModel.Configuration.EndpointCollectionElement : ConfigurationElement {
    public string EndpointName { get; }
    public Type EndpointType { get; }
    public ReadOnlyCollection`1<StandardEndpointElement> ConfiguredEndpoints { get; }
    protected internal abstract virtual StandardEndpointElement GetDefaultStandardEndpointElement();
    public string get_EndpointName();
    public abstract virtual Type get_EndpointType();
    public abstract virtual ReadOnlyCollection`1<StandardEndpointElement> get_ConfiguredEndpoints();
    public abstract virtual bool ContainsKey(string name);
    protected internal abstract virtual bool TryAdd(string name, ServiceEndpoint endpoint, Configuration config);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.EndToEndTracingElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("propagateActivity")]
public bool PropagateActivity { get; public set; }
    [ConfigurationPropertyAttribute("activityTracing")]
public bool ActivityTracing { get; public set; }
    [ConfigurationPropertyAttribute("messageFlowTracing")]
public bool MessageFlowTracing { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_PropagateActivity();
    public void set_PropagateActivity(bool value);
    public bool get_ActivityTracing();
    public void set_ActivityTracing(bool value);
    public bool get_MessageFlowTracing();
    public void set_MessageFlowTracing(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Configuration.EvaluationContextHelper : ValueType {
    private bool reset;
    private ContextInformation inheritedContext;
    internal void OnReset(ConfigurationElement parent);
    internal ContextInformation GetOriginalContext(IConfigurationContextProviderInternal owner);
}
public class System.ServiceModel.Configuration.ExtensionElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    internal string TypeName { get; }
    public ExtensionElement(string name);
    public ExtensionElement(string name, string type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public string get_Type();
    public void set_Type(string value);
    internal string get_TypeName();
    internal static string GetTypeName(string fullyQualifiedName);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ExtensionElement")]
public class System.ServiceModel.Configuration.ExtensionElementCollection : ServiceModelConfigurationElementCollection`1<ExtensionElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual void BaseAdd(ConfigurationElement element);
    protected virtual void BaseAdd(int index, ConfigurationElement element);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
public class System.ServiceModel.Configuration.ExtensionsSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("behaviorExtensions")]
public ExtensionElementCollection BehaviorExtensions { get; }
    [ConfigurationPropertyAttribute("bindingElementExtensions")]
public ExtensionElementCollection BindingElementExtensions { get; }
    [ConfigurationPropertyAttribute("bindingExtensions")]
public ExtensionElementCollection BindingExtensions { get; }
    [ConfigurationPropertyAttribute("endpointExtensions")]
public ExtensionElementCollection EndpointExtensions { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ExtensionElementCollection get_BehaviorExtensions();
    public ExtensionElementCollection get_BindingElementExtensions();
    public ExtensionElementCollection get_BindingExtensions();
    public ExtensionElementCollection get_EndpointExtensions();
    protected virtual void InitializeDefault();
    internal static ExtensionElementCollection LookupAssociatedCollection(Type extensionType, ContextInformation evaluationContext, String& collectionName);
    [SecurityCriticalAttribute]
internal static ExtensionElementCollection UnsafeLookupAssociatedCollection(Type extensionType, ContextInformation evaluationContext, String& collectionName);
    internal static ExtensionElementCollection LookupCollection(string collectionName, ContextInformation evaluationContext);
    [SecurityCriticalAttribute]
internal static ExtensionElementCollection UnsafeLookupCollection(string collectionName, ContextInformation evaluationContext);
}
public class System.ServiceModel.Configuration.FederatedMessageSecurityOverHttpElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("algorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    [ConfigurationPropertyAttribute("claimTypeRequirements")]
public ClaimTypeElementCollection ClaimTypeRequirements { get; }
    [ConfigurationPropertyAttribute("establishSecurityContext")]
public bool EstablishSecurityContext { get; public set; }
    [ConfigurationPropertyAttribute("issuedKeyType")]
[ServiceModelEnumValidatorAttribute("System.IdentityModel.Tokens.SecurityKeyTypeHelper")]
public SecurityKeyType IssuedKeyType { get; public set; }
    [ConfigurationPropertyAttribute("issuedTokenType")]
[StringValidatorAttribute]
public string IssuedTokenType { get; public set; }
    [ConfigurationPropertyAttribute("issuer")]
public IssuedTokenParametersEndpointAddressElement Issuer { get; }
    [ConfigurationPropertyAttribute("issuerMetadata")]
public EndpointAddressElementBase IssuerMetadata { get; }
    [ConfigurationPropertyAttribute("negotiateServiceCredential")]
public bool NegotiateServiceCredential { get; public set; }
    [ConfigurationPropertyAttribute("tokenRequestParameters")]
public XmlElementElementCollection TokenRequestParameters { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    public ClaimTypeElementCollection get_ClaimTypeRequirements();
    public bool get_EstablishSecurityContext();
    public void set_EstablishSecurityContext(bool value);
    public SecurityKeyType get_IssuedKeyType();
    public void set_IssuedKeyType(SecurityKeyType value);
    public string get_IssuedTokenType();
    public void set_IssuedTokenType(string value);
    public IssuedTokenParametersEndpointAddressElement get_Issuer();
    public EndpointAddressElementBase get_IssuerMetadata();
    public bool get_NegotiateServiceCredential();
    public void set_NegotiateServiceCredential(bool value);
    public XmlElementElementCollection get_TokenRequestParameters();
    internal void ApplyConfiguration(FederatedMessageSecurityOverHttp security);
    internal void InitializeFrom(FederatedMessageSecurityOverHttp security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HostElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("baseAddresses")]
public BaseAddressElementCollection BaseAddresses { get; }
    [ConfigurationPropertyAttribute("timeouts")]
public HostTimeoutsElement Timeouts { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public BaseAddressElementCollection get_BaseAddresses();
    public HostTimeoutsElement get_Timeouts();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HostTimeoutsElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("closeTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan CloseTimeout { get; public set; }
    [ConfigurationPropertyAttribute("openTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan OpenTimeout { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.HttpBindingBaseElement : StandardBindingElement {
    [ConfigurationPropertyAttribute("allowCookies")]
public bool AllowCookies { get; public set; }
    [ConfigurationPropertyAttribute("bypassProxyOnLocal")]
public bool BypassProxyOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("proxyAddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("textEncoding")]
[TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [ConfigurationPropertyAttribute("transferMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TransferModeHelper")]
public TransferMode TransferMode { get; public set; }
    [ConfigurationPropertyAttribute("useDefaultWebProxy")]
public bool UseDefaultWebProxy { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected HttpBindingBaseElement(string name);
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    internal virtual void InitializeAllowCookies(HttpBindingBase binding);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HttpDigestClientElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("impersonationLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.TokenImpersonationLevelHelper")]
public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public TokenImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(TokenImpersonationLevel value);
    public void Copy(HttpDigestClientElement from);
    internal void ApplyConfiguration(HttpDigestClientCredential digest);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HttpMessageHandlerFactoryElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("handlers")]
public DelegatingHandlerElementCollection Handlers { get; internal set; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public DelegatingHandlerElementCollection get_Handlers();
    internal void set_Handlers(DelegatingHandlerElementCollection value);
    public string get_Type();
    public void set_Type(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.ServiceModel.Configuration.HttpMessageHandlerFactoryValidator : ConfigurationValidatorBase {
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.HttpMessageHandlerFactoryValidatorAttribute : ConfigurationValidatorAttribute {
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.ServiceModel.Configuration.HttpsTransportElement : HttpTransportElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("requireClientCertificate")]
public bool RequireClientCertificate { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HttpTransportElement : TransportElement {
    [ConfigurationPropertyAttribute("allowCookies")]
public bool AllowCookies { get; public set; }
    [ConfigurationPropertyAttribute("requestInitializationTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan RequestInitializationTimeout { get; public set; }
    [ConfigurationPropertyAttribute("authenticationScheme")]
[StandardRuntimeFlagEnumValidatorAttribute("System.Net.AuthenticationSchemes")]
public AuthenticationSchemes AuthenticationScheme { get; public set; }
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("bypassProxyOnLocal")]
public bool BypassProxyOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("decompressionEnabled")]
public bool DecompressionEnabled { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("keepAliveEnabled")]
public bool KeepAliveEnabled { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingAccepts")]
[IntegerValidatorAttribute]
public int MaxPendingAccepts { get; public set; }
    [ConfigurationPropertyAttribute("messageHandlerFactory")]
[HttpMessageHandlerFactoryValidatorAttribute]
public HttpMessageHandlerFactoryElement MessageHandlerFactory { get; public set; }
    [ConfigurationPropertyAttribute("proxyAddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("proxyAuthenticationScheme")]
[StandardRuntimeEnumValidatorAttribute("System.Net.AuthenticationSchemes")]
public AuthenticationSchemes ProxyAuthenticationScheme { get; public set; }
    [ConfigurationPropertyAttribute("realm")]
[StringValidatorAttribute]
public string Realm { get; public set; }
    [ConfigurationPropertyAttribute("transferMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TransferModeHelper")]
public TransferMode TransferMode { get; public set; }
    [ConfigurationPropertyAttribute("unsafeConnectionNtlmAuthentication")]
public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    [ConfigurationPropertyAttribute("useDefaultWebProxy")]
public bool UseDefaultWebProxy { get; public set; }
    [ConfigurationPropertyAttribute("extendedProtectionPolicy")]
public ExtendedProtectionPolicyElement ExtendedProtectionPolicy { get; private set; }
    [ConfigurationPropertyAttribute("webSocketSettings")]
public WebSocketTransportSettingsElement WebSocketSettings { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public TimeSpan get_RequestInitializationTimeout();
    public void set_RequestInitializationTimeout(TimeSpan value);
    public AuthenticationSchemes get_AuthenticationScheme();
    public void set_AuthenticationScheme(AuthenticationSchemes value);
    public virtual Type get_BindingElementType();
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public bool get_DecompressionEnabled();
    public void set_DecompressionEnabled(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public bool get_KeepAliveEnabled();
    public void set_KeepAliveEnabled(bool value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    public HttpMessageHandlerFactoryElement get_MessageHandlerFactory();
    public void set_MessageHandlerFactory(HttpMessageHandlerFactoryElement value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public AuthenticationSchemes get_ProxyAuthenticationScheme();
    public void set_ProxyAuthenticationScheme(AuthenticationSchemes value);
    public string get_Realm();
    public void set_Realm(string value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    public ExtendedProtectionPolicyElement get_ExtendedProtectionPolicy();
    private void set_ExtendedProtectionPolicy(ExtendedProtectionPolicyElement value);
    public WebSocketTransportSettingsElement get_WebSocketSettings();
    public void set_WebSocketSettings(WebSocketTransportSettingsElement value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.HttpTransportSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HttpClientCredentialTypeHelper")]
public HttpClientCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("proxyCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HttpProxyCredentialTypeHelper")]
public HttpProxyCredentialType ProxyCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("extendedProtectionPolicy")]
public ExtendedProtectionPolicyElement ExtendedProtectionPolicy { get; private set; }
    [ConfigurationPropertyAttribute("realm")]
[StringValidatorAttribute]
public string Realm { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public HttpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(HttpClientCredentialType value);
    public HttpProxyCredentialType get_ProxyCredentialType();
    public void set_ProxyCredentialType(HttpProxyCredentialType value);
    public ExtendedProtectionPolicyElement get_ExtendedProtectionPolicy();
    private void set_ExtendedProtectionPolicy(ExtendedProtectionPolicyElement value);
    public string get_Realm();
    public void set_Realm(string value);
    internal void ApplyConfiguration(HttpTransportSecurity security);
    internal void InitializeFrom(HttpTransportSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public interface System.ServiceModel.Configuration.IBindingConfigurationElement {
    public TimeSpan CloseTimeout { get; }
    public string Name { get; }
    public TimeSpan OpenTimeout { get; }
    public TimeSpan ReceiveTimeout { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_CloseTimeout();
    public abstract virtual string get_Name();
    public abstract virtual TimeSpan get_OpenTimeout();
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual TimeSpan get_SendTimeout();
    public abstract virtual void ApplyConfiguration(Binding binding);
}
internal interface System.ServiceModel.Configuration.IConfigurationContextProviderInternal {
    public abstract virtual ContextInformation GetEvaluationContext();
    public abstract virtual ContextInformation GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.IdentityElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("userPrincipalName")]
public UserPrincipalNameElement UserPrincipalName { get; }
    [ConfigurationPropertyAttribute("servicePrincipalName")]
public ServicePrincipalNameElement ServicePrincipalName { get; }
    [ConfigurationPropertyAttribute("dns")]
public DnsElement Dns { get; }
    [ConfigurationPropertyAttribute("rsa")]
public RsaElement Rsa { get; }
    [ConfigurationPropertyAttribute("certificate")]
public CertificateElement Certificate { get; }
    [ConfigurationPropertyAttribute("certificateReference")]
public CertificateReferenceElement CertificateReference { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public UserPrincipalNameElement get_UserPrincipalName();
    public ServicePrincipalNameElement get_ServicePrincipalName();
    public DnsElement get_Dns();
    public RsaElement get_Rsa();
    public CertificateElement get_Certificate();
    public CertificateReferenceElement get_CertificateReference();
    internal void Copy(IdentityElement source);
    public void InitializeFrom(EndpointIdentity identity);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.IssuedTokenClientBehaviorsElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("issuerAddress")]
[StringValidatorAttribute]
public string IssuerAddress { get; public set; }
    [ConfigurationPropertyAttribute("behaviorConfiguration")]
[StringValidatorAttribute]
public string BehaviorConfiguration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_IssuerAddress();
    public void set_IssuerAddress(string value);
    public string get_BehaviorConfiguration();
    public void set_BehaviorConfiguration(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.IssuedTokenClientBehaviorsElement")]
public class System.ServiceModel.Configuration.IssuedTokenClientBehaviorsElementCollection : ServiceModelConfigurationElementCollection`1<IssuedTokenClientBehaviorsElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.IssuedTokenClientElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("localIssuer")]
public IssuedTokenParametersEndpointAddressElement LocalIssuer { get; }
    [ConfigurationPropertyAttribute("localIssuerChannelBehaviors")]
[StringValidatorAttribute]
public string LocalIssuerChannelBehaviors { get; public set; }
    [ConfigurationPropertyAttribute("issuerChannelBehaviors")]
public IssuedTokenClientBehaviorsElementCollection IssuerChannelBehaviors { get; }
    [ConfigurationPropertyAttribute("cacheIssuedTokens")]
public bool CacheIssuedTokens { get; public set; }
    [ConfigurationPropertyAttribute("maxIssuedTokenCachingTime")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan MaxIssuedTokenCachingTime { get; public set; }
    [ConfigurationPropertyAttribute("defaultKeyEntropyMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.SecurityKeyEntropyModeHelper")]
public SecurityKeyEntropyMode DefaultKeyEntropyMode { get; public set; }
    [ConfigurationPropertyAttribute("issuedTokenRenewalThresholdPercentage")]
[IntegerValidatorAttribute]
public int IssuedTokenRenewalThresholdPercentage { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public IssuedTokenParametersEndpointAddressElement get_LocalIssuer();
    public string get_LocalIssuerChannelBehaviors();
    public void set_LocalIssuerChannelBehaviors(string value);
    public IssuedTokenClientBehaviorsElementCollection get_IssuerChannelBehaviors();
    public bool get_CacheIssuedTokens();
    public void set_CacheIssuedTokens(bool value);
    public TimeSpan get_MaxIssuedTokenCachingTime();
    public void set_MaxIssuedTokenCachingTime(TimeSpan value);
    public SecurityKeyEntropyMode get_DefaultKeyEntropyMode();
    public void set_DefaultKeyEntropyMode(SecurityKeyEntropyMode value);
    public int get_IssuedTokenRenewalThresholdPercentage();
    public void set_IssuedTokenRenewalThresholdPercentage(int value);
    public void Copy(IssuedTokenClientElement from);
    internal void ApplyConfiguration(IssuedTokenClientCredential issuedToken);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.IssuedTokenParametersElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("defaultMessageSecurityVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.MessageSecurityVersionConverter")]
public MessageSecurityVersion DefaultMessageSecurityVersion { get; public set; }
    [ConfigurationPropertyAttribute("additionalRequestParameters")]
public XmlElementElementCollection AdditionalRequestParameters { get; }
    [ConfigurationPropertyAttribute("claimTypeRequirements")]
public ClaimTypeElementCollection ClaimTypeRequirements { get; }
    [ConfigurationPropertyAttribute("issuer")]
public IssuedTokenParametersEndpointAddressElement Issuer { get; }
    [ConfigurationPropertyAttribute("issuerMetadata")]
public EndpointAddressElementBase IssuerMetadata { get; }
    [ConfigurationPropertyAttribute("keySize")]
[IntegerValidatorAttribute]
public int KeySize { get; public set; }
    [ConfigurationPropertyAttribute("keyType")]
[ServiceModelEnumValidatorAttribute("System.IdentityModel.Tokens.SecurityKeyTypeHelper")]
public SecurityKeyType KeyType { get; public set; }
    internal Collection`1<IssuedTokenParametersElement> OptionalIssuedTokenParameters { get; }
    [ConfigurationPropertyAttribute("tokenType")]
[StringValidatorAttribute]
public string TokenType { get; public set; }
    [ConfigurationPropertyAttribute("useStrTransform")]
public bool UseStrTransform { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MessageSecurityVersion get_DefaultMessageSecurityVersion();
    public void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    public XmlElementElementCollection get_AdditionalRequestParameters();
    public ClaimTypeElementCollection get_ClaimTypeRequirements();
    public IssuedTokenParametersEndpointAddressElement get_Issuer();
    public EndpointAddressElementBase get_IssuerMetadata();
    public int get_KeySize();
    public void set_KeySize(int value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    internal Collection`1<IssuedTokenParametersElement> get_OptionalIssuedTokenParameters();
    public string get_TokenType();
    public void set_TokenType(string value);
    public bool get_UseStrTransform();
    public void set_UseStrTransform(bool value);
    internal void ApplyConfiguration(IssuedSecurityTokenParameters parameters);
    internal void Copy(IssuedTokenParametersElement source);
    internal IssuedSecurityTokenParameters Create(bool createTemplateOnly, SecurityKeyType templateKeyType);
    internal void InitializeFrom(IssuedSecurityTokenParameters source, bool initializeNestedBindings);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.IssuedTokenParametersEndpointAddressElement : EndpointAddressElementBase {
    [ConfigurationPropertyAttribute("binding")]
[StringValidatorAttribute]
public string Binding { get; public set; }
    [ConfigurationPropertyAttribute("bindingConfiguration")]
[StringValidatorAttribute]
public string BindingConfiguration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_Binding();
    public void set_Binding(string value);
    public string get_BindingConfiguration();
    public void set_BindingConfiguration(string value);
    internal void Copy(IssuedTokenParametersEndpointAddressElement source);
    internal void Validate();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.IssuedTokenServiceElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("allowedAudienceUris")]
public AllowedAudienceUriElementCollection AllowedAudienceUris { get; }
    [ConfigurationPropertyAttribute("audienceUriMode")]
[ServiceModelEnumValidatorAttribute("System.IdentityModel.Selectors.AudienceUriModeValidationHelper")]
public AudienceUriMode AudienceUriMode { get; public set; }
    [ConfigurationPropertyAttribute("customCertificateValidatorType")]
[StringValidatorAttribute]
public string CustomCertificateValidatorType { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.X509CertificateValidationModeHelper")]
public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("revocationMode")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509RevocationMode")]
public X509RevocationMode RevocationMode { get; public set; }
    [ConfigurationPropertyAttribute("trustedStoreLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation TrustedStoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("samlSerializerType")]
[StringValidatorAttribute]
public string SamlSerializerType { get; public set; }
    [ConfigurationPropertyAttribute("knownCertificates")]
public X509CertificateTrustedIssuerElementCollection KnownCertificates { get; }
    [ConfigurationPropertyAttribute("allowUntrustedRsaIssuers")]
public bool AllowUntrustedRsaIssuers { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public AllowedAudienceUriElementCollection get_AllowedAudienceUris();
    public AudienceUriMode get_AudienceUriMode();
    public void set_AudienceUriMode(AudienceUriMode value);
    public string get_CustomCertificateValidatorType();
    public void set_CustomCertificateValidatorType(string value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public string get_SamlSerializerType();
    public void set_SamlSerializerType(string value);
    public X509CertificateTrustedIssuerElementCollection get_KnownCertificates();
    public bool get_AllowUntrustedRsaIssuers();
    public void set_AllowUntrustedRsaIssuers(bool value);
    public void Copy(IssuedTokenServiceElement from);
    internal void ApplyConfiguration(IssuedTokenServiceCredential issuedToken);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.LocalClientSecuritySettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("cacheCookies")]
public bool CacheCookies { get; public set; }
    [ConfigurationPropertyAttribute("detectReplays")]
public bool DetectReplays { get; public set; }
    [ConfigurationPropertyAttribute("replayCacheSize")]
[IntegerValidatorAttribute]
public int ReplayCacheSize { get; public set; }
    [ConfigurationPropertyAttribute("maxClockSkew")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan MaxClockSkew { get; public set; }
    [ConfigurationPropertyAttribute("maxCookieCachingTime")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan MaxCookieCachingTime { get; public set; }
    [ConfigurationPropertyAttribute("replayWindow")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReplayWindow { get; public set; }
    [ConfigurationPropertyAttribute("sessionKeyRenewalInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SessionKeyRenewalInterval { get; public set; }
    [ConfigurationPropertyAttribute("sessionKeyRolloverInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SessionKeyRolloverInterval { get; public set; }
    [ConfigurationPropertyAttribute("reconnectTransportOnFailure")]
public bool ReconnectTransportOnFailure { get; public set; }
    [ConfigurationPropertyAttribute("timestampValidityDuration")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TimestampValidityDuration { get; public set; }
    [ConfigurationPropertyAttribute("cookieRenewalThresholdPercentage")]
[IntegerValidatorAttribute]
public int CookieRenewalThresholdPercentage { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_CacheCookies();
    public void set_CacheCookies(bool value);
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public TimeSpan get_MaxCookieCachingTime();
    public void set_MaxCookieCachingTime(TimeSpan value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    public bool get_ReconnectTransportOnFailure();
    public void set_ReconnectTransportOnFailure(bool value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    public int get_CookieRenewalThresholdPercentage();
    public void set_CookieRenewalThresholdPercentage(int value);
    internal void ApplyConfiguration(LocalClientSecuritySettings settings);
    internal void InitializeFrom(LocalClientSecuritySettings settings);
    internal void CopyFrom(LocalClientSecuritySettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.LocalServiceSecuritySettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("detectReplays")]
public bool DetectReplays { get; public set; }
    [ConfigurationPropertyAttribute("issuedCookieLifetime")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan IssuedCookieLifetime { get; public set; }
    [ConfigurationPropertyAttribute("maxStatefulNegotiations")]
[IntegerValidatorAttribute]
public int MaxStatefulNegotiations { get; public set; }
    [ConfigurationPropertyAttribute("replayCacheSize")]
[IntegerValidatorAttribute]
public int ReplayCacheSize { get; public set; }
    [ConfigurationPropertyAttribute("maxClockSkew")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan MaxClockSkew { get; public set; }
    [ConfigurationPropertyAttribute("negotiationTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan NegotiationTimeout { get; public set; }
    [ConfigurationPropertyAttribute("replayWindow")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReplayWindow { get; public set; }
    [ConfigurationPropertyAttribute("inactivityTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan InactivityTimeout { get; public set; }
    [ConfigurationPropertyAttribute("sessionKeyRenewalInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SessionKeyRenewalInterval { get; public set; }
    [ConfigurationPropertyAttribute("sessionKeyRolloverInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SessionKeyRolloverInterval { get; public set; }
    [ConfigurationPropertyAttribute("reconnectTransportOnFailure")]
public bool ReconnectTransportOnFailure { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingSessions")]
[IntegerValidatorAttribute]
public int MaxPendingSessions { get; public set; }
    [ConfigurationPropertyAttribute("maxCachedCookies")]
[IntegerValidatorAttribute]
public int MaxCachedCookies { get; public set; }
    [ConfigurationPropertyAttribute("timestampValidityDuration")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TimestampValidityDuration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public TimeSpan get_IssuedCookieLifetime();
    public void set_IssuedCookieLifetime(TimeSpan value);
    public int get_MaxStatefulNegotiations();
    public void set_MaxStatefulNegotiations(int value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public TimeSpan get_NegotiationTimeout();
    public void set_NegotiationTimeout(TimeSpan value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    public bool get_ReconnectTransportOnFailure();
    public void set_ReconnectTransportOnFailure(bool value);
    public int get_MaxPendingSessions();
    public void set_MaxPendingSessions(int value);
    public int get_MaxCachedCookies();
    public void set_MaxCachedCookies(int value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    internal void ApplyConfiguration(LocalServiceSecuritySettings settings);
    internal void InitializeFrom(LocalServiceSecuritySettings settings);
    internal void CopyFrom(LocalServiceSecuritySettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MessageLoggingElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("logEntireMessage")]
public bool LogEntireMessage { get; public set; }
    [ConfigurationPropertyAttribute("logKnownPii")]
public bool LogKnownPii { get; public set; }
    [ConfigurationPropertyAttribute("logMalformedMessages")]
public bool LogMalformedMessages { get; public set; }
    [ConfigurationPropertyAttribute("logMessagesAtServiceLevel")]
public bool LogMessagesAtServiceLevel { get; public set; }
    [ConfigurationPropertyAttribute("logMessagesAtTransportLevel")]
public bool LogMessagesAtTransportLevel { get; public set; }
    [ConfigurationPropertyAttribute("maxMessagesToLog")]
[IntegerValidatorAttribute]
public int MaxMessagesToLog { get; public set; }
    [ConfigurationPropertyAttribute("maxSizeOfMessageToLog")]
[IntegerValidatorAttribute]
public int MaxSizeOfMessageToLog { get; public set; }
    [ConfigurationPropertyAttribute("filters")]
public XPathMessageFilterElementCollection Filters { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_LogEntireMessage();
    public void set_LogEntireMessage(bool value);
    public bool get_LogKnownPii();
    public void set_LogKnownPii(bool value);
    public bool get_LogMalformedMessages();
    public void set_LogMalformedMessages(bool value);
    public bool get_LogMessagesAtServiceLevel();
    public void set_LogMessagesAtServiceLevel(bool value);
    public bool get_LogMessagesAtTransportLevel();
    public void set_LogMessagesAtTransportLevel(bool value);
    public int get_MaxMessagesToLog();
    public void set_MaxMessagesToLog(int value);
    public int get_MaxSizeOfMessageToLog();
    public void set_MaxSizeOfMessageToLog(int value);
    public XPathMessageFilterElementCollection get_Filters();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MessageSecurityOverHttpElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MessageCredentialTypeHelper")]
public MessageCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("negotiateServiceCredential")]
public bool NegotiateServiceCredential { get; public set; }
    [ConfigurationPropertyAttribute("algorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public bool get_NegotiateServiceCredential();
    public void set_NegotiateServiceCredential(bool value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal void ApplyConfiguration(MessageSecurityOverHttp security);
    internal void InitializeFrom(MessageSecurityOverHttp security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MessageSecurityOverMsmqElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MessageCredentialTypeHelper")]
public MessageCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("algorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal void ApplyConfiguration(MessageSecurityOverMsmq security);
    internal void InitializeFrom(MessageSecurityOverMsmq security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MessageSecurityOverTcpElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MessageCredentialTypeHelper")]
public MessageCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("algorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal void ApplyConfiguration(MessageSecurityOverTcp security);
    internal void InitializeFrom(MessageSecurityOverTcp security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.ServiceModel.Configuration.MessageSecurityVersionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.ServiceModel.Configuration.MessageVersionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.MetadataElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("policyImporters")]
public PolicyImporterElementCollection PolicyImporters { get; }
    [ConfigurationPropertyAttribute("wsdlImporters")]
public WsdlImporterElementCollection WsdlImporters { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public PolicyImporterElementCollection get_PolicyImporters();
    public WsdlImporterElementCollection get_WsdlImporters();
    public Collection`1<IWsdlImportExtension> LoadWsdlImportExtensions();
    public Collection`1<IPolicyImportExtension> LoadPolicyImportExtensions();
    internal void SetDefaults();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.MexBindingBindingCollectionElement`2 : StandardBindingCollectionElement`2<TStandardBinding, TBindingConfiguration> {
    protected internal virtual bool TryAdd(string name, Binding binding, Configuration config);
}
public abstract class System.ServiceModel.Configuration.MexBindingElement`1 : StandardBindingElement {
    protected Type BindingElementType { get; }
    protected MexBindingElement`1(string name);
    protected virtual Type get_BindingElementType();
    protected virtual void OnApplyConfiguration(Binding binding);
}
public class System.ServiceModel.Configuration.MexHttpBindingCollectionElement : MexBindingBindingCollectionElement`2<WSHttpBinding, MexHttpBindingElement> {
    internal static MexHttpBindingCollectionElement GetBindingCollectionElement();
    protected internal virtual Binding GetDefault();
}
public class System.ServiceModel.Configuration.MexHttpBindingElement : MexBindingElement`1<WSHttpBinding> {
    public MexHttpBindingElement(string name);
}
public class System.ServiceModel.Configuration.MexHttpsBindingCollectionElement : MexBindingBindingCollectionElement`2<WSHttpBinding, MexHttpsBindingElement> {
    internal static MexHttpsBindingCollectionElement GetBindingCollectionElement();
    protected internal virtual Binding GetDefault();
}
public class System.ServiceModel.Configuration.MexHttpsBindingElement : MexBindingElement`1<WSHttpBinding> {
    public MexHttpsBindingElement(string name);
}
public class System.ServiceModel.Configuration.MexNamedPipeBindingCollectionElement : MexBindingBindingCollectionElement`2<CustomBinding, MexNamedPipeBindingElement> {
    internal static MexNamedPipeBindingCollectionElement GetBindingCollectionElement();
    protected internal virtual Binding GetDefault();
}
public class System.ServiceModel.Configuration.MexNamedPipeBindingElement : MexBindingElement`1<CustomBinding> {
    public MexNamedPipeBindingElement(string name);
}
public class System.ServiceModel.Configuration.MexTcpBindingCollectionElement : MexBindingBindingCollectionElement`2<CustomBinding, MexTcpBindingElement> {
    internal static MexTcpBindingCollectionElement GetBindingCollectionElement();
    protected internal virtual Binding GetDefault();
}
public class System.ServiceModel.Configuration.MexTcpBindingElement : MexBindingElement`1<CustomBinding> {
    public MexTcpBindingElement(string name);
}
public abstract class System.ServiceModel.Configuration.MsmqBindingElementBase : StandardBindingElement {
    [ConfigurationPropertyAttribute("customDeadLetterQueue")]
public Uri CustomDeadLetterQueue { get; public set; }
    [ConfigurationPropertyAttribute("deadLetterQueue")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.DeadLetterQueueHelper")]
public DeadLetterQueue DeadLetterQueue { get; public set; }
    [ConfigurationPropertyAttribute("durable")]
public bool Durable { get; public set; }
    [ConfigurationPropertyAttribute("exactlyOnce")]
public bool ExactlyOnce { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("maxRetryCycles")]
[IntegerValidatorAttribute]
public int MaxRetryCycles { get; public set; }
    [ConfigurationPropertyAttribute("receiveContextEnabled")]
public bool ReceiveContextEnabled { get; public set; }
    [ConfigurationPropertyAttribute("receiveErrorHandling")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.ReceiveErrorHandlingHelper")]
public ReceiveErrorHandling ReceiveErrorHandling { get; public set; }
    [ConfigurationPropertyAttribute("receiveRetryCount")]
[IntegerValidatorAttribute]
public int ReceiveRetryCount { get; public set; }
    [ConfigurationPropertyAttribute("retryCycleDelay")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan RetryCycleDelay { get; public set; }
    [ConfigurationPropertyAttribute("timeToLive")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TimeToLive { get; public set; }
    [ConfigurationPropertyAttribute("useSourceJournal")]
public bool UseSourceJournal { get; public set; }
    [ConfigurationPropertyAttribute("useMsmqTracing")]
public bool UseMsmqTracing { get; public set; }
    [ConfigurationPropertyAttribute("validityDuration")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ValidityDuration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected MsmqBindingElementBase(string name);
    public Uri get_CustomDeadLetterQueue();
    public void set_CustomDeadLetterQueue(Uri value);
    public DeadLetterQueue get_DeadLetterQueue();
    public void set_DeadLetterQueue(DeadLetterQueue value);
    public bool get_Durable();
    public void set_Durable(bool value);
    public bool get_ExactlyOnce();
    public void set_ExactlyOnce(bool value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public int get_MaxRetryCycles();
    public void set_MaxRetryCycles(int value);
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    public ReceiveErrorHandling get_ReceiveErrorHandling();
    public void set_ReceiveErrorHandling(ReceiveErrorHandling value);
    public int get_ReceiveRetryCount();
    public void set_ReceiveRetryCount(int value);
    public TimeSpan get_RetryCycleDelay();
    public void set_RetryCycleDelay(TimeSpan value);
    public TimeSpan get_TimeToLive();
    public void set_TimeToLive(TimeSpan value);
    public bool get_UseSourceJournal();
    public void set_UseSourceJournal(bool value);
    public bool get_UseMsmqTracing();
    public void set_UseMsmqTracing(bool value);
    public TimeSpan get_ValidityDuration();
    public void set_ValidityDuration(TimeSpan value);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.MsmqElementBase : TransportElement {
    [ConfigurationPropertyAttribute("customDeadLetterQueue")]
public Uri CustomDeadLetterQueue { get; public set; }
    [ConfigurationPropertyAttribute("deadLetterQueue")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.DeadLetterQueueHelper")]
public DeadLetterQueue DeadLetterQueue { get; public set; }
    [ConfigurationPropertyAttribute("durable")]
public bool Durable { get; public set; }
    [ConfigurationPropertyAttribute("exactlyOnce")]
public bool ExactlyOnce { get; public set; }
    [ConfigurationPropertyAttribute("maxRetryCycles")]
[IntegerValidatorAttribute]
public int MaxRetryCycles { get; public set; }
    [ConfigurationPropertyAttribute("receiveContextEnabled")]
public bool ReceiveContextEnabled { get; public set; }
    [ConfigurationPropertyAttribute("receiveErrorHandling")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.ReceiveErrorHandlingHelper")]
public ReceiveErrorHandling ReceiveErrorHandling { get; public set; }
    [ConfigurationPropertyAttribute("receiveRetryCount")]
[IntegerValidatorAttribute]
public int ReceiveRetryCount { get; public set; }
    [ConfigurationPropertyAttribute("retryCycleDelay")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan RetryCycleDelay { get; public set; }
    [ConfigurationPropertyAttribute("msmqTransportSecurity")]
public MsmqTransportSecurityElement MsmqTransportSecurity { get; }
    [ConfigurationPropertyAttribute("timeToLive")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TimeToLive { get; public set; }
    [ConfigurationPropertyAttribute("useSourceJournal")]
public bool UseSourceJournal { get; public set; }
    [ConfigurationPropertyAttribute("useMsmqTracing")]
public bool UseMsmqTracing { get; public set; }
    [ConfigurationPropertyAttribute("validityDuration")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ValidityDuration { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Uri get_CustomDeadLetterQueue();
    public void set_CustomDeadLetterQueue(Uri value);
    public DeadLetterQueue get_DeadLetterQueue();
    public void set_DeadLetterQueue(DeadLetterQueue value);
    public bool get_Durable();
    public void set_Durable(bool value);
    public bool get_ExactlyOnce();
    public void set_ExactlyOnce(bool value);
    public int get_MaxRetryCycles();
    public void set_MaxRetryCycles(int value);
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    public ReceiveErrorHandling get_ReceiveErrorHandling();
    public void set_ReceiveErrorHandling(ReceiveErrorHandling value);
    public int get_ReceiveRetryCount();
    public void set_ReceiveRetryCount(int value);
    public TimeSpan get_RetryCycleDelay();
    public void set_RetryCycleDelay(TimeSpan value);
    public MsmqTransportSecurityElement get_MsmqTransportSecurity();
    public TimeSpan get_TimeToLive();
    public void set_TimeToLive(TimeSpan value);
    public bool get_UseSourceJournal();
    public void set_UseSourceJournal(bool value);
    public bool get_UseMsmqTracing();
    public void set_UseMsmqTracing(bool value);
    public TimeSpan get_ValidityDuration();
    public void set_ValidityDuration(TimeSpan value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MsmqIntegrationBindingCollectionElement : StandardBindingCollectionElement`2<MsmqIntegrationBinding, MsmqIntegrationBindingElement> {
    internal static MsmqIntegrationBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.MsmqIntegrationBindingElement : MsmqBindingElementBase {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("security")]
public MsmqIntegrationSecurityElement Security { get; }
    [ConfigurationPropertyAttribute("serializationFormat")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormatHelper")]
public MsmqMessageSerializationFormat SerializationFormat { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MsmqIntegrationBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public MsmqIntegrationSecurityElement get_Security();
    public MsmqMessageSerializationFormat get_SerializationFormat();
    public void set_SerializationFormat(MsmqMessageSerializationFormat value);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MsmqIntegrationElement : MsmqElementBase {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("serializationFormat")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormatHelper")]
public MsmqMessageSerializationFormat SerializationFormat { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public MsmqMessageSerializationFormat get_SerializationFormat();
    public void set_SerializationFormat(MsmqMessageSerializationFormat value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MsmqIntegrationSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqIntegration.MsmqIntegrationSecurityModeHelper")]
public MsmqIntegrationSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public MsmqTransportSecurityElement Transport { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MsmqIntegrationSecurityMode get_Mode();
    public void set_Mode(MsmqIntegrationSecurityMode value);
    public MsmqTransportSecurityElement get_Transport();
    internal void ApplyConfiguration(MsmqIntegrationSecurity security);
    internal void InitializeFrom(MsmqIntegrationSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MsmqTransportElement : MsmqElementBase {
    [ConfigurationPropertyAttribute("maxPoolSize")]
[IntegerValidatorAttribute]
public int MaxPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("queueTransferProtocol")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.QueueTransferProtocolHelper")]
public QueueTransferProtocol QueueTransferProtocol { get; public set; }
    [ConfigurationPropertyAttribute("useActiveDirectory")]
public bool UseActiveDirectory { get; public set; }
    public Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public int get_MaxPoolSize();
    public void set_MaxPoolSize(int value);
    public QueueTransferProtocol get_QueueTransferProtocol();
    public void set_QueueTransferProtocol(QueueTransferProtocol value);
    public bool get_UseActiveDirectory();
    public void set_UseActiveDirectory(bool value);
    public virtual Type get_BindingElementType();
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MsmqTransportSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("msmqAuthenticationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqAuthenticationModeHelper")]
public MsmqAuthenticationMode MsmqAuthenticationMode { get; public set; }
    [ConfigurationPropertyAttribute("msmqEncryptionAlgorithm")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqEncryptionAlgorithmHelper")]
public MsmqEncryptionAlgorithm MsmqEncryptionAlgorithm { get; public set; }
    [ConfigurationPropertyAttribute("msmqProtectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel MsmqProtectionLevel { get; public set; }
    [ConfigurationPropertyAttribute("msmqSecureHashAlgorithm")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.MsmqSecureHashAlgorithmHelper")]
public MsmqSecureHashAlgorithm MsmqSecureHashAlgorithm { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public MsmqAuthenticationMode get_MsmqAuthenticationMode();
    public void set_MsmqAuthenticationMode(MsmqAuthenticationMode value);
    public MsmqEncryptionAlgorithm get_MsmqEncryptionAlgorithm();
    public void set_MsmqEncryptionAlgorithm(MsmqEncryptionAlgorithm value);
    public ProtectionLevel get_MsmqProtectionLevel();
    public void set_MsmqProtectionLevel(ProtectionLevel value);
    public MsmqSecureHashAlgorithm get_MsmqSecureHashAlgorithm();
    public void set_MsmqSecureHashAlgorithm(MsmqSecureHashAlgorithm value);
    internal void ApplyConfiguration(MsmqTransportSecurity security);
    internal void InitializeFrom(MsmqTransportSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.MtomMessageEncodingElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("maxReadPoolSize")]
[IntegerValidatorAttribute]
public int MaxReadPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxWritePoolSize")]
[IntegerValidatorAttribute]
public int MaxWritePoolSize { get; public set; }
    [ConfigurationPropertyAttribute("messageVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.MessageVersionConverter")]
public MessageVersion MessageVersion { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("writeEncoding")]
[TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding WriteEncoding { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public MessageVersion get_MessageVersion();
    public void set_MessageVersion(MessageVersion value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NamedPipeConnectionPoolSettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("groupName")]
[StringValidatorAttribute]
public string GroupName { get; public set; }
    [ConfigurationPropertyAttribute("idleTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan IdleTimeout { get; public set; }
    [ConfigurationPropertyAttribute("maxOutboundConnectionsPerEndpoint")]
[IntegerValidatorAttribute]
public int MaxOutboundConnectionsPerEndpoint { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_GroupName();
    public void set_GroupName(string value);
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public int get_MaxOutboundConnectionsPerEndpoint();
    public void set_MaxOutboundConnectionsPerEndpoint(int value);
    internal void ApplyConfiguration(NamedPipeConnectionPoolSettings settings);
    internal void InitializeFrom(NamedPipeConnectionPoolSettings settings);
    internal void CopyFrom(NamedPipeConnectionPoolSettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NamedPipeSettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("applicationContainerSettings")]
public ApplicationContainerSettingsElement ApplicationContainerSettings { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ApplicationContainerSettingsElement get_ApplicationContainerSettings();
    public void set_ApplicationContainerSettings(ApplicationContainerSettingsElement value);
    internal void ApplyConfiguration(NamedPipeSettings settings);
    internal void InitializeFrom(NamedPipeSettings settings);
    internal void CopyFrom(NamedPipeSettingsElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NamedPipeTransportElement : ConnectionOrientedTransportElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("connectionPoolSettings")]
public NamedPipeConnectionPoolSettingsElement ConnectionPoolSettings { get; public set; }
    [ConfigurationPropertyAttribute("pipeSettings")]
public NamedPipeSettingsElement PipeSettings { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    public NamedPipeConnectionPoolSettingsElement get_ConnectionPoolSettings();
    public void set_ConnectionPoolSettings(NamedPipeConnectionPoolSettingsElement value);
    public NamedPipeSettingsElement get_PipeSettings();
    public void set_PipeSettings(NamedPipeSettingsElement value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NamedPipeTransportSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("protectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel ProtectionLevel { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    internal void ApplyConfiguration(NamedPipeTransportSecurity security);
    internal void InitializeFrom(NamedPipeTransportSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.ServiceModel.Configuration.NamedServiceModelExtensionCollectionElement`1 : ServiceModelExtensionCollectionElement`1<TServiceModelExtensionElement> {
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal NamedServiceModelExtensionCollectionElement`1(string extensionCollectionName, string name);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetHttpBindingCollectionElement : StandardBindingCollectionElement`2<NetHttpBinding, NetHttpBindingElement> {
    internal static NetHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.NetHttpBindingElement : HttpBindingBaseElement {
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.NetHttpMessageEncodingHelper")]
public NetHttpMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("reliableSession")]
public StandardBindingOptionalReliableSessionElement ReliableSession { get; }
    [ConfigurationPropertyAttribute("security")]
public BasicHttpSecurityElement Security { get; }
    [ConfigurationPropertyAttribute("webSocketSettings")]
public NetHttpWebSocketTransportSettingsElement WebSocketSettings { get; public set; }
    protected Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetHttpBindingElement(string name);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public StandardBindingOptionalReliableSessionElement get_ReliableSession();
    public BasicHttpSecurityElement get_Security();
    public NetHttpWebSocketTransportSettingsElement get_WebSocketSettings();
    public void set_WebSocketSettings(NetHttpWebSocketTransportSettingsElement value);
    protected virtual Type get_BindingElementType();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetHttpsBindingCollectionElement : StandardBindingCollectionElement`2<NetHttpsBinding, NetHttpsBindingElement> {
    internal static NetHttpsBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.NetHttpsBindingElement : HttpBindingBaseElement {
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.NetHttpMessageEncodingHelper")]
public NetHttpMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("reliableSession")]
public StandardBindingOptionalReliableSessionElement ReliableSession { get; }
    [ConfigurationPropertyAttribute("security")]
public BasicHttpsSecurityElement Security { get; }
    [ConfigurationPropertyAttribute("webSocketSettings")]
public NetHttpWebSocketTransportSettingsElement WebSocketSettings { get; public set; }
    protected Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetHttpsBindingElement(string name);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public StandardBindingOptionalReliableSessionElement get_ReliableSession();
    public BasicHttpsSecurityElement get_Security();
    public NetHttpWebSocketTransportSettingsElement get_WebSocketSettings();
    public void set_WebSocketSettings(NetHttpWebSocketTransportSettingsElement value);
    protected virtual Type get_BindingElementType();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetHttpWebSocketTransportSettingsElement : WebSocketTransportSettingsElement {
    [ConfigurationPropertyAttribute("transportUsage")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Channels.WebSocketTransportUsageHelper")]
public WebSocketTransportUsage TransportUsage { get; public set; }
    [ConfigurationPropertyAttribute("subProtocol")]
[StringValidatorAttribute]
public string SubProtocol { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual WebSocketTransportUsage get_TransportUsage();
    public virtual void set_TransportUsage(WebSocketTransportUsage value);
    public virtual string get_SubProtocol();
    public virtual void set_SubProtocol(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetMsmqBindingCollectionElement : StandardBindingCollectionElement`2<NetMsmqBinding, NetMsmqBindingElement> {
    internal static NetMsmqBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.NetMsmqBindingElement : MsmqBindingElementBase {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("queueTransferProtocol")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.QueueTransferProtocolHelper")]
public QueueTransferProtocol QueueTransferProtocol { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public NetMsmqSecurityElement Security { get; }
    [ConfigurationPropertyAttribute("useActiveDirectory")]
public bool UseActiveDirectory { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetMsmqBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public QueueTransferProtocol get_QueueTransferProtocol();
    public void set_QueueTransferProtocol(QueueTransferProtocol value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public NetMsmqSecurityElement get_Security();
    public bool get_UseActiveDirectory();
    public void set_UseActiveDirectory(bool value);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetMsmqSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.SecurityModeHelper")]
public NetMsmqSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public MsmqTransportSecurityElement Transport { get; }
    [ConfigurationPropertyAttribute("message")]
public MessageSecurityOverMsmqElement Message { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetMsmqSecurityMode get_Mode();
    public void set_Mode(NetMsmqSecurityMode value);
    public MsmqTransportSecurityElement get_Transport();
    public MessageSecurityOverMsmqElement get_Message();
    internal void ApplyConfiguration(NetMsmqSecurity security);
    internal void InitializeFrom(NetMsmqSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetNamedPipeBindingCollectionElement : StandardBindingCollectionElement`2<NetNamedPipeBinding, NetNamedPipeBindingElement> {
    internal static NetNamedPipeBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.NetNamedPipeBindingElement : StandardBindingElement {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("transactionFlow")]
public bool TransactionFlow { get; public set; }
    [ConfigurationPropertyAttribute("transferMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TransferModeHelper")]
public TransferMode TransferMode { get; public set; }
    [ConfigurationPropertyAttribute("transactionProtocol")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TransactionProtocolConverter")]
public TransactionProtocol TransactionProtocol { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("maxConnections")]
[IntegerValidatorAttribute]
public int MaxConnections { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("security")]
public NetNamedPipeSecurityElement Security { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetNamedPipeBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxConnections();
    public void set_MaxConnections(int value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public NetNamedPipeSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetNamedPipeSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.NetNamedPipeSecurityModeHelper")]
public NetNamedPipeSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public NamedPipeTransportSecurityElement Transport { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetNamedPipeSecurityMode get_Mode();
    public void set_Mode(NetNamedPipeSecurityMode value);
    public NamedPipeTransportSecurityElement get_Transport();
    internal void ApplyConfiguration(NetNamedPipeSecurity security);
    internal void InitializeFrom(NetNamedPipeSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.Configuration.NetPeerTcpBindingCollectionElement : StandardBindingCollectionElement`2<NetPeerTcpBinding, NetPeerTcpBindingElement> {
    internal static NetPeerTcpBindingCollectionElement GetBindingCollectionElement();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.Configuration.NetPeerTcpBindingElement : StandardBindingElement {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("listenIPAddress")]
[TypeConverterAttribute("System.ServiceModel.Configuration.PeerTransportListenAddressConverter")]
[PeerTransportListenAddressValidatorAttribute]
public IPAddress ListenIPAddress { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("port")]
[IntegerValidatorAttribute]
public int Port { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("resolver")]
public PeerResolverElement Resolver { get; }
    [ConfigurationPropertyAttribute("security")]
public PeerSecurityElement Security { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetPeerTcpBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public IPAddress get_ListenIPAddress();
    public void set_ListenIPAddress(IPAddress value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public int get_Port();
    public void set_Port(int value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public PeerResolverElement get_Resolver();
    public PeerSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetTcpBindingCollectionElement : StandardBindingCollectionElement`2<NetTcpBinding, NetTcpBindingElement> {
    internal static NetTcpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.NetTcpBindingElement : StandardBindingElement {
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("transactionFlow")]
public bool TransactionFlow { get; public set; }
    [ConfigurationPropertyAttribute("transferMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TransferModeHelper")]
public TransferMode TransferMode { get; public set; }
    [ConfigurationPropertyAttribute("transactionProtocol")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TransactionProtocolConverter")]
public TransactionProtocol TransactionProtocol { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("listenBacklog")]
[IntegerValidatorAttribute]
public int ListenBacklog { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferSize")]
[IntegerValidatorAttribute]
public int MaxBufferSize { get; public set; }
    [ConfigurationPropertyAttribute("maxConnections")]
[IntegerValidatorAttribute]
public int MaxConnections { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("portSharingEnabled")]
public bool PortSharingEnabled { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("reliableSession")]
public StandardBindingOptionalReliableSessionElement ReliableSession { get; }
    [ConfigurationPropertyAttribute("security")]
public NetTcpSecurityElement Security { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetTcpBindingElement(string name);
    protected virtual Type get_BindingElementType();
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public int get_ListenBacklog();
    public void set_ListenBacklog(int value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxConnections();
    public void set_MaxConnections(int value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public bool get_PortSharingEnabled();
    public void set_PortSharingEnabled(bool value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public StandardBindingOptionalReliableSessionElement get_ReliableSession();
    public NetTcpSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.NetTcpContextBindingCollectionElement : StandardBindingCollectionElement`2<NetTcpContextBinding, NetTcpContextBindingElement> {
    internal static string netTcpContextBindingName;
    internal static NetTcpContextBindingCollectionElement GetBindingCollectionElement();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.NetTcpContextBindingElement : NetTcpBindingElement {
    [ConfigurationPropertyAttribute("clientCallbackAddress")]
public Uri ClientCallbackAddress { get; public set; }
    [ConfigurationPropertyAttribute("contextManagementEnabled")]
public bool ContextManagementEnabled { get; public set; }
    [ConfigurationPropertyAttribute("contextProtectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel ContextProtectionLevel { get; public set; }
    protected Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public NetTcpContextBindingElement(string name);
    public Uri get_ClientCallbackAddress();
    public void set_ClientCallbackAddress(Uri value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public ProtectionLevel get_ContextProtectionLevel();
    public void set_ContextProtectionLevel(ProtectionLevel value);
    protected virtual Type get_BindingElementType();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NetTcpSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.SecurityModeHelper")]
public SecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public TcpTransportSecurityElement Transport { get; }
    [ConfigurationPropertyAttribute("message")]
public MessageSecurityOverTcpElement Message { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public TcpTransportSecurityElement get_Transport();
    public MessageSecurityOverTcpElement get_Message();
    internal void ApplyConfiguration(NetTcpSecurity security);
    internal void InitializeFrom(NetTcpSecurity security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.NonDualMessageSecurityOverHttpElement : MessageSecurityOverHttpElement {
    [ConfigurationPropertyAttribute("establishSecurityContext")]
public bool EstablishSecurityContext { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_EstablishSecurityContext();
    public void set_EstablishSecurityContext(bool value);
    internal void ApplyConfiguration(NonDualMessageSecurityOverHttp security);
    internal void InitializeFrom(NonDualMessageSecurityOverHttp security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.OneWayElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("channelPoolSettings")]
public ChannelPoolSettingsElement ChannelPoolSettings { get; }
    [ConfigurationPropertyAttribute("maxAcceptedChannels")]
[IntegerValidatorAttribute]
public int MaxAcceptedChannels { get; public set; }
    [ConfigurationPropertyAttribute("packetRoutable")]
public bool PacketRoutable { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public ChannelPoolSettingsElement get_ChannelPoolSettings();
    public int get_MaxAcceptedChannels();
    public void set_MaxAcceptedChannels(int value);
    public bool get_PacketRoutable();
    public void set_PacketRoutable(bool value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected internal virtual BindingElement CreateBindingElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.PeerCredentialElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("certificate")]
public X509PeerCertificateElement Certificate { get; }
    [ConfigurationPropertyAttribute("peerAuthentication")]
public X509PeerCertificateAuthenticationElement PeerAuthentication { get; }
    [ConfigurationPropertyAttribute("messageSenderAuthentication")]
public X509PeerCertificateAuthenticationElement MessageSenderAuthentication { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public X509PeerCertificateElement get_Certificate();
    public X509PeerCertificateAuthenticationElement get_PeerAuthentication();
    public X509PeerCertificateAuthenticationElement get_MessageSenderAuthentication();
    public void Copy(PeerCredentialElement from);
    internal void ApplyConfiguration(PeerCredential creds);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.PeerCustomResolverElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("address")]
public Uri Address { get; public set; }
    [ConfigurationPropertyAttribute("headers")]
public AddressHeaderCollectionElement Headers { get; }
    [ConfigurationPropertyAttribute("identity")]
public IdentityElement Identity { get; }
    [ConfigurationPropertyAttribute("binding")]
[StringValidatorAttribute]
public string Binding { get; public set; }
    [ConfigurationPropertyAttribute("bindingConfiguration")]
[StringValidatorAttribute]
public string BindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("resolverType")]
[StringValidatorAttribute]
public string ResolverType { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Uri get_Address();
    public void set_Address(Uri value);
    public AddressHeaderCollectionElement get_Headers();
    public IdentityElement get_Identity();
    public string get_Binding();
    public void set_Binding(string value);
    public string get_BindingConfiguration();
    public void set_BindingConfiguration(string value);
    public string get_ResolverType();
    public void set_ResolverType(string value);
    internal void ApplyConfiguration(PeerCustomResolverSettings settings);
    internal void InitializeFrom(PeerCustomResolverSettings settings);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.PeerResolverElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.PeerResolvers.PeerResolverModeHelper")]
public PeerResolverMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("referralPolicy")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.PeerResolvers.PeerReferralPolicyHelper")]
public PeerReferralPolicy ReferralPolicy { get; public set; }
    [ConfigurationPropertyAttribute("custom")]
public PeerCustomResolverElement Custom { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public PeerResolverMode get_Mode();
    public void set_Mode(PeerResolverMode value);
    public PeerReferralPolicy get_ReferralPolicy();
    public void set_ReferralPolicy(PeerReferralPolicy value);
    public PeerCustomResolverElement get_Custom();
    internal void ApplyConfiguration(PeerResolverSettings settings);
    internal void InitializeFrom(PeerResolverSettings settings);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.PeerSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.SecurityModeHelper")]
public SecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public PeerTransportSecurityElement Transport { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public PeerTransportSecurityElement get_Transport();
    internal void ApplyConfiguration(PeerSecuritySettings security);
    internal void InitializeFrom(PeerSecuritySettings security);
    internal void CopyFrom(PeerSecurityElement source);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.Configuration.PeerTransportElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("listenIPAddress")]
[TypeConverterAttribute("System.ServiceModel.Configuration.PeerTransportListenAddressConverter")]
[PeerTransportListenAddressValidatorAttribute]
public IPAddress ListenIPAddress { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("port")]
[IntegerValidatorAttribute]
public int Port { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public PeerSecurityElement Security { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual Type get_BindingElementType();
    public IPAddress get_ListenIPAddress();
    public void set_ListenIPAddress(IPAddress value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public int get_Port();
    public void set_Port(int value);
    public PeerSecurityElement get_Security();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.ServiceModel.Configuration.PeerTransportListenAddressConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.ServiceModel.Configuration.PeerTransportListenAddressValidator : ConfigurationValidatorBase {
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.PeerTransportListenAddressValidatorAttribute : ConfigurationValidatorAttribute {
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.ServiceModel.Configuration.PeerTransportSecurityElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("credentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.PeerTransportCredentialTypeHelper")]
public PeerTransportCredentialType CredentialType { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public PeerTransportCredentialType get_CredentialType();
    public void set_CredentialType(PeerTransportCredentialType value);
    internal void ApplyConfiguration(PeerTransportSecuritySettings security);
    internal void InitializeFrom(PeerTransportSecuritySettings security);
    internal void CopyFrom(PeerTransportSecurityElement security);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.PnrpPeerResolverElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    public virtual Type get_BindingElementType();
    protected internal virtual BindingElement CreateBindingElement();
}
public class System.ServiceModel.Configuration.PolicyImporterElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public PolicyImporterElement(string type);
    public PolicyImporterElement(Type type);
    public string get_Type();
    public void set_Type(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.PolicyImporterElement")]
public class System.ServiceModel.Configuration.PolicyImporterElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<PolicyImporterElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
    internal void SetDefaults();
}
internal class System.ServiceModel.Configuration.PolicyVersionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.PrivacyNoticeElement : BindingElementExtensionElement {
    [ConfigurationPropertyAttribute("url")]
public Uri Url { get; public set; }
    [ConfigurationPropertyAttribute("version")]
[IntegerValidatorAttribute]
public int Version { get; public set; }
    public Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Uri get_Url();
    public void set_Url(Uri value);
    public int get_Version();
    public void set_Version(int value);
    public virtual Type get_BindingElementType();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    protected internal virtual BindingElement CreateBindingElement();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ProtocolMappingElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("scheme")]
[StringValidatorAttribute]
public string Scheme { get; public set; }
    [ConfigurationPropertyAttribute("binding")]
[StringValidatorAttribute]
public string Binding { get; public set; }
    [ConfigurationPropertyAttribute("bindingConfiguration")]
[StringValidatorAttribute]
public string BindingConfiguration { get; public set; }
    public ProtocolMappingElement(string schemeType, string binding, string bindingConfiguration);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Binding();
    public void set_Binding(string value);
    public string get_BindingConfiguration();
    public void set_BindingConfiguration(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ProtocolMappingElement")]
public class System.ServiceModel.Configuration.ProtocolMappingElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ProtocolMappingElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ProtocolMappingSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public ProtocolMappingElementCollection ProtocolMappingCollection { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ProtocolMappingElementCollection get_ProtocolMappingCollection();
    protected virtual void InitializeDefault();
    internal static ProtocolMappingSection GetSection();
    [SecurityCriticalAttribute]
internal static ProtocolMappingSection UnsafeGetSection();
}
internal class System.ServiceModel.Configuration.ReliableMessagingVersionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.ReliableSessionElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("acknowledgementInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan AcknowledgementInterval { get; public set; }
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("flowControlEnabled")]
public bool FlowControlEnabled { get; public set; }
    [ConfigurationPropertyAttribute("inactivityTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan InactivityTimeout { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingChannels")]
[IntegerValidatorAttribute]
public int MaxPendingChannels { get; public set; }
    [ConfigurationPropertyAttribute("maxRetryCount")]
[IntegerValidatorAttribute]
public int MaxRetryCount { get; public set; }
    [ConfigurationPropertyAttribute("maxTransferWindowSize")]
[IntegerValidatorAttribute]
public int MaxTransferWindowSize { get; public set; }
    [ConfigurationPropertyAttribute("ordered")]
public bool Ordered { get; public set; }
    [ConfigurationPropertyAttribute("reliableMessagingVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.ReliableMessagingVersionConverter")]
public ReliableMessagingVersion ReliableMessagingVersion { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public TimeSpan get_AcknowledgementInterval();
    public void set_AcknowledgementInterval(TimeSpan value);
    public virtual Type get_BindingElementType();
    public bool get_FlowControlEnabled();
    public void set_FlowControlEnabled(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public int get_MaxPendingChannels();
    public void set_MaxPendingChannels(int value);
    public int get_MaxRetryCount();
    public void set_MaxRetryCount(int value);
    public int get_MaxTransferWindowSize();
    public void set_MaxTransferWindowSize(int value);
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public ReliableMessagingVersion get_ReliableMessagingVersion();
    public void set_ReliableMessagingVersion(ReliableMessagingVersion value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
}
public class System.ServiceModel.Configuration.RemoveBehaviorElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.RsaElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("value")]
[StringValidatorAttribute]
public string Value { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Value();
    public void set_Value(string value);
}
public class System.ServiceModel.Configuration.SecureConversationServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("securityStateEncoderType")]
[StringValidatorAttribute]
public string SecurityStateEncoderType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_SecurityStateEncoderType();
    public void set_SecurityStateEncoderType(string value);
    public void Copy(SecureConversationServiceElement from);
    internal void ApplyConfiguration(SecureConversationServiceCredential secureConversation);
}
internal class System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.SecurityElement : SecurityElementBase {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("secureConversationBootstrap")]
public SecurityElementBase SecureConversationBootstrap { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SecurityElementBase get_SecureConversationBootstrap();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement(bool createTemplateOnly);
    protected virtual void AddBindingTemplates(Dictionary`2<AuthenticationMode, SecurityBindingElement> bindingTemplates);
    protected virtual void InitializeNestedTokenParameterSettings(SecurityTokenParameters sp, bool initializeNestedBindings);
}
public class System.ServiceModel.Configuration.SecurityElementBase : BindingElementExtensionElement {
    internal static AuthenticationMode defaultAuthenticationMode;
    protected ConfigurationPropertyCollection Properties { get; }
    internal bool HasImportFailed { get; }
    internal bool IsSecurityElementBootstrap { get; internal set; }
    [ConfigurationPropertyAttribute("defaultAlgorithmSuite")]
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public SecurityAlgorithmSuite DefaultAlgorithmSuite { get; public set; }
    [ConfigurationPropertyAttribute("allowSerializedSigningTokenOnReply")]
public bool AllowSerializedSigningTokenOnReply { get; public set; }
    [ConfigurationPropertyAttribute("enableUnsecuredResponse")]
public bool EnableUnsecuredResponse { get; public set; }
    [ConfigurationPropertyAttribute("authenticationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Configuration.AuthenticationModeHelper")]
public AuthenticationMode AuthenticationMode { get; public set; }
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("requireDerivedKeys")]
public bool RequireDerivedKeys { get; public set; }
    [ConfigurationPropertyAttribute("securityHeaderLayout")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Channels.SecurityHeaderLayoutHelper")]
public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    [ConfigurationPropertyAttribute("includeTimestamp")]
public bool IncludeTimestamp { get; public set; }
    [ConfigurationPropertyAttribute("allowInsecureTransport")]
public bool AllowInsecureTransport { get; public set; }
    [ConfigurationPropertyAttribute("keyEntropyMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.SecurityKeyEntropyModeHelper")]
public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    [ConfigurationPropertyAttribute("issuedTokenParameters")]
public IssuedTokenParametersElement IssuedTokenParameters { get; }
    [ConfigurationPropertyAttribute("localClientSettings")]
public LocalClientSecuritySettingsElement LocalClientSettings { get; }
    [ConfigurationPropertyAttribute("localServiceSettings")]
public LocalServiceSecuritySettingsElement LocalServiceSettings { get; }
    [ConfigurationPropertyAttribute("messageProtectionOrder")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.MessageProtectionOrderHelper")]
public MessageProtectionOrder MessageProtectionOrder { get; public set; }
    [ConfigurationPropertyAttribute("protectTokens")]
public bool ProtectTokens { get; public set; }
    [ConfigurationPropertyAttribute("messageSecurityVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.MessageSecurityVersionConverter")]
public MessageSecurityVersion MessageSecurityVersion { get; public set; }
    [ConfigurationPropertyAttribute("requireSecurityContextCancellation")]
public bool RequireSecurityContextCancellation { get; public set; }
    [ConfigurationPropertyAttribute("requireSignatureConfirmation")]
public bool RequireSignatureConfirmation { get; public set; }
    [ConfigurationPropertyAttribute("canRenewSecurityContextToken")]
public bool CanRenewSecurityContextToken { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal bool get_HasImportFailed();
    [CompilerGeneratedAttribute]
internal bool get_IsSecurityElementBootstrap();
    [CompilerGeneratedAttribute]
internal void set_IsSecurityElementBootstrap(bool value);
    public SecurityAlgorithmSuite get_DefaultAlgorithmSuite();
    public void set_DefaultAlgorithmSuite(SecurityAlgorithmSuite value);
    public bool get_AllowSerializedSigningTokenOnReply();
    public void set_AllowSerializedSigningTokenOnReply(bool value);
    public bool get_EnableUnsecuredResponse();
    public void set_EnableUnsecuredResponse(bool value);
    public AuthenticationMode get_AuthenticationMode();
    public void set_AuthenticationMode(AuthenticationMode value);
    public virtual Type get_BindingElementType();
    public bool get_RequireDerivedKeys();
    public void set_RequireDerivedKeys(bool value);
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public bool get_IncludeTimestamp();
    public void set_IncludeTimestamp(bool value);
    public bool get_AllowInsecureTransport();
    public void set_AllowInsecureTransport(bool value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public IssuedTokenParametersElement get_IssuedTokenParameters();
    public LocalClientSecuritySettingsElement get_LocalClientSettings();
    public LocalServiceSecuritySettingsElement get_LocalServiceSettings();
    public MessageProtectionOrder get_MessageProtectionOrder();
    public void set_MessageProtectionOrder(MessageProtectionOrder value);
    public bool get_ProtectTokens();
    public void set_ProtectTokens(bool value);
    public MessageSecurityVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(MessageSecurityVersion value);
    public bool get_RequireSecurityContextCancellation();
    public void set_RequireSecurityContextCancellation(bool value);
    public bool get_RequireSignatureConfirmation();
    public void set_RequireSignatureConfirmation(bool value);
    public bool get_CanRenewSecurityContextToken();
    public void set_CanRenewSecurityContextToken(bool value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual BindingElement CreateBindingElement(bool createTemplateOnly);
    protected void AddBindingTemplate(Dictionary`2<AuthenticationMode, SecurityBindingElement> bindingTemplates, AuthenticationMode mode);
    internal static bool AreBindingsMatching(SecurityBindingElement b1, SecurityBindingElement b2);
    internal static bool AreBindingsMatching(SecurityBindingElement b1, SecurityBindingElement b2, bool exactMessageSecurityVersion);
    protected virtual void AddBindingTemplates(Dictionary`2<AuthenticationMode, SecurityBindingElement> bindingTemplates);
    protected virtual void InitializeNestedTokenParameterSettings(SecurityTokenParameters sp, bool initializeNestedBindings);
    internal void InitializeFrom(BindingElement bindingElement, bool initializeNestedBindings);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
}
public class System.ServiceModel.Configuration.ServiceActivationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("relativeAddress")]
[RelativeAddressValidatorAttribute]
public string RelativeAddress { get; public set; }
    [ConfigurationPropertyAttribute("service")]
[StringValidatorAttribute]
public string Service { get; public set; }
    [ConfigurationPropertyAttribute("factory")]
[StringValidatorAttribute]
public string Factory { get; public set; }
    public ServiceActivationElement(string relativeAddress);
    public ServiceActivationElement(string relativeAddress, string service);
    public ServiceActivationElement(string relativeAddress, string service, string factory);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_RelativeAddress();
    public void set_RelativeAddress(string value);
    public string get_Service();
    public void set_Service(string value);
    public string get_Factory();
    public void set_Factory(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ServiceActivationElement")]
public class System.ServiceModel.Configuration.ServiceActivationElementCollection : ServiceModelConfigurationElementCollection`1<ServiceActivationElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
public class System.ServiceModel.Configuration.ServiceAuthenticationElement : BehaviorExtensionElement {
    [ConfigurationPropertyAttribute("serviceAuthenticationManagerType")]
[StringValidatorAttribute]
public string ServiceAuthenticationManagerType { get; public set; }
    [ConfigurationPropertyAttribute("authenticationSchemes")]
[StandardRuntimeFlagEnumValidatorAttribute("System.Net.AuthenticationSchemes")]
public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public Type BehaviorType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_ServiceAuthenticationManagerType();
    public void set_ServiceAuthenticationManagerType(string value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public virtual Type get_BehaviorType();
    protected internal virtual object CreateBehavior();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.ServiceAuthorizationElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("principalPermissionMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Description.PrincipalPermissionModeHelper")]
public PrincipalPermissionMode PrincipalPermissionMode { get; public set; }
    [ConfigurationPropertyAttribute("roleProviderName")]
[StringValidatorAttribute]
public string RoleProviderName { get; public set; }
    [ConfigurationPropertyAttribute("impersonateCallerForAllOperations")]
public bool ImpersonateCallerForAllOperations { get; public set; }
    [ConfigurationPropertyAttribute("impersonateOnSerializingReply")]
public bool ImpersonateOnSerializingReply { get; public set; }
    [ConfigurationPropertyAttribute("serviceAuthorizationManagerType")]
[StringValidatorAttribute]
public string ServiceAuthorizationManagerType { get; public set; }
    [ConfigurationPropertyAttribute("authorizationPolicies")]
public AuthorizationPolicyTypeElementCollection AuthorizationPolicies { get; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public PrincipalPermissionMode get_PrincipalPermissionMode();
    public void set_PrincipalPermissionMode(PrincipalPermissionMode value);
    public string get_RoleProviderName();
    public void set_RoleProviderName(string value);
    public bool get_ImpersonateCallerForAllOperations();
    public void set_ImpersonateCallerForAllOperations(bool value);
    public bool get_ImpersonateOnSerializingReply();
    public void set_ImpersonateOnSerializingReply(bool value);
    public string get_ServiceAuthorizationManagerType();
    public void set_ServiceAuthorizationManagerType(string value);
    public AuthorizationPolicyTypeElementCollection get_AuthorizationPolicies();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ServiceBehaviorElement : NamedServiceModelExtensionCollectionElement`1<BehaviorExtensionElement> {
    public ServiceBehaviorElement(string name);
    public virtual void Add(BehaviorExtensionElement element);
    public virtual bool CanAdd(BehaviorExtensionElement element);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ServiceBehaviorElement")]
public class System.ServiceModel.Configuration.ServiceBehaviorElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ServiceBehaviorElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ServiceCredentialsElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    [ConfigurationPropertyAttribute("clientCertificate")]
public X509InitiatorCertificateServiceElement ClientCertificate { get; }
    [ConfigurationPropertyAttribute("serviceCertificate")]
public X509RecipientCertificateServiceElement ServiceCertificate { get; }
    [ConfigurationPropertyAttribute("userNameAuthentication")]
public UserNameServiceElement UserNameAuthentication { get; }
    [ConfigurationPropertyAttribute("useIdentityConfiguration")]
public bool UseIdentityConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("identityConfiguration")]
[StringValidatorAttribute]
public string IdentityConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("windowsAuthentication")]
public WindowsServiceElement WindowsAuthentication { get; }
    [ConfigurationPropertyAttribute("peer")]
public PeerCredentialElement Peer { get; }
    [ConfigurationPropertyAttribute("issuedTokenAuthentication")]
public IssuedTokenServiceElement IssuedTokenAuthentication { get; }
    [ConfigurationPropertyAttribute("secureConversationAuthentication")]
public SecureConversationServiceElement SecureConversationAuthentication { get; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
    public X509InitiatorCertificateServiceElement get_ClientCertificate();
    public X509RecipientCertificateServiceElement get_ServiceCertificate();
    public UserNameServiceElement get_UserNameAuthentication();
    public bool get_UseIdentityConfiguration();
    public void set_UseIdentityConfiguration(bool value);
    public string get_IdentityConfiguration();
    public void set_IdentityConfiguration(string value);
    public WindowsServiceElement get_WindowsAuthentication();
    public PeerCredentialElement get_Peer();
    public IssuedTokenServiceElement get_IssuedTokenAuthentication();
    public SecureConversationServiceElement get_SecureConversationAuthentication();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    protected internal void ApplyConfiguration(ServiceCredentials behavior);
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ServiceDebugElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("httpHelpPageEnabled")]
public bool HttpHelpPageEnabled { get; public set; }
    [ConfigurationPropertyAttribute("httpHelpPageUrl")]
public Uri HttpHelpPageUrl { get; public set; }
    [ConfigurationPropertyAttribute("httpsHelpPageEnabled")]
public bool HttpsHelpPageEnabled { get; public set; }
    [ConfigurationPropertyAttribute("httpsHelpPageUrl")]
public Uri HttpsHelpPageUrl { get; public set; }
    [ConfigurationPropertyAttribute("httpHelpPageBinding")]
[StringValidatorAttribute]
public string HttpHelpPageBinding { get; public set; }
    [ConfigurationPropertyAttribute("httpHelpPageBindingConfiguration")]
[StringValidatorAttribute]
public string HttpHelpPageBindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("httpsHelpPageBinding")]
[StringValidatorAttribute]
public string HttpsHelpPageBinding { get; public set; }
    [ConfigurationPropertyAttribute("httpsHelpPageBindingConfiguration")]
[StringValidatorAttribute]
public string HttpsHelpPageBindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("includeExceptionDetailInFaults")]
public bool IncludeExceptionDetailInFaults { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_HttpHelpPageEnabled();
    public void set_HttpHelpPageEnabled(bool value);
    public Uri get_HttpHelpPageUrl();
    public void set_HttpHelpPageUrl(Uri value);
    public bool get_HttpsHelpPageEnabled();
    public void set_HttpsHelpPageEnabled(bool value);
    public Uri get_HttpsHelpPageUrl();
    public void set_HttpsHelpPageUrl(Uri value);
    public string get_HttpHelpPageBinding();
    public void set_HttpHelpPageBinding(string value);
    public string get_HttpHelpPageBindingConfiguration();
    public void set_HttpHelpPageBindingConfiguration(string value);
    public string get_HttpsHelpPageBinding();
    public void set_HttpsHelpPageBinding(string value);
    public string get_HttpsHelpPageBindingConfiguration();
    public void set_HttpsHelpPageBindingConfiguration(string value);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("behaviorConfiguration")]
[StringValidatorAttribute]
public string BehaviorConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("")]
public ServiceEndpointElementCollection Endpoints { get; }
    [ConfigurationPropertyAttribute("host")]
public HostElement Host { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    public ServiceElement(string serviceName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_BehaviorConfiguration();
    public void set_BehaviorConfiguration(string value);
    public ServiceEndpointElementCollection get_Endpoints();
    public HostElement get_Host();
    public string get_Name();
    public void set_Name(string value);
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ServiceElement")]
public class System.ServiceModel.Configuration.ServiceElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ServiceElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ServiceEndpointElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("address")]
public Uri Address { get; public set; }
    [ConfigurationPropertyAttribute("behaviorConfiguration")]
[StringValidatorAttribute]
public string BehaviorConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("binding")]
[StringValidatorAttribute]
public string Binding { get; public set; }
    [ConfigurationPropertyAttribute("bindingConfiguration")]
[StringValidatorAttribute]
public string BindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("bindingName")]
[StringValidatorAttribute]
public string BindingName { get; public set; }
    [ConfigurationPropertyAttribute("bindingNamespace")]
[StringValidatorAttribute]
public string BindingNamespace { get; public set; }
    [ConfigurationPropertyAttribute("contract")]
[StringValidatorAttribute]
public string Contract { get; public set; }
    [ConfigurationPropertyAttribute("headers")]
public AddressHeaderCollectionElement Headers { get; }
    [ConfigurationPropertyAttribute("identity")]
public IdentityElement Identity { get; }
    [ConfigurationPropertyAttribute("listenUriMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Description.ListenUriModeHelper")]
public ListenUriMode ListenUriMode { get; public set; }
    [ConfigurationPropertyAttribute("listenUri")]
public Uri ListenUri { get; public set; }
    [ConfigurationPropertyAttribute("isSystemEndpoint")]
public bool IsSystemEndpoint { get; public set; }
    [ConfigurationPropertyAttribute("kind")]
[StringValidatorAttribute]
public string Kind { get; public set; }
    [ConfigurationPropertyAttribute("endpointConfiguration")]
[StringValidatorAttribute]
public string EndpointConfiguration { get; public set; }
    public ServiceEndpointElement(Uri address, string contractType);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal void Copy(ServiceEndpointElement source);
    public Uri get_Address();
    public void set_Address(Uri value);
    public string get_BehaviorConfiguration();
    public void set_BehaviorConfiguration(string value);
    public string get_Binding();
    public void set_Binding(string value);
    public string get_BindingConfiguration();
    public void set_BindingConfiguration(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_BindingName();
    public void set_BindingName(string value);
    public string get_BindingNamespace();
    public void set_BindingNamespace(string value);
    public string get_Contract();
    public void set_Contract(string value);
    public AddressHeaderCollectionElement get_Headers();
    public IdentityElement get_Identity();
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public bool get_IsSystemEndpoint();
    public void set_IsSystemEndpoint(bool value);
    public string get_Kind();
    public void set_Kind(string value);
    public string get_EndpointConfiguration();
    public void set_EndpointConfiguration(string value);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.ServiceEndpointElement")]
public class System.ServiceModel.Configuration.ServiceEndpointElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<ServiceEndpointElement> {
    protected bool ThrowOnDuplicate { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.ServiceHostingEnvironmentSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public TransportConfigurationTypeElementCollection TransportConfigurationTypes { get; }
    [ConfigurationPropertyAttribute("baseAddressPrefixFilters")]
public BaseAddressPrefixFilterElementCollection BaseAddressPrefixFilters { get; }
    [ConfigurationPropertyAttribute("serviceActivations")]
public ServiceActivationElementCollection ServiceActivations { get; }
    [ConfigurationPropertyAttribute("aspNetCompatibilityEnabled")]
public bool AspNetCompatibilityEnabled { get; public set; }
    [ConfigurationPropertyAttribute("closeIdleServicesAtLowMemory")]
public bool CloseIdleServicesAtLowMemory { get; public set; }
    [ConfigurationPropertyAttribute("minFreeMemoryPercentageToActivateService")]
[IntegerValidatorAttribute]
public int MinFreeMemoryPercentageToActivateService { get; public set; }
    [ConfigurationPropertyAttribute("multipleSiteBindingsEnabled")]
public bool MultipleSiteBindingsEnabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void PostDeserialize();
    public TransportConfigurationTypeElementCollection get_TransportConfigurationTypes();
    public BaseAddressPrefixFilterElementCollection get_BaseAddressPrefixFilters();
    public ServiceActivationElementCollection get_ServiceActivations();
    public bool get_AspNetCompatibilityEnabled();
    public void set_AspNetCompatibilityEnabled(bool value);
    public bool get_CloseIdleServicesAtLowMemory();
    public void set_CloseIdleServicesAtLowMemory(bool value);
    public int get_MinFreeMemoryPercentageToActivateService();
    public void set_MinFreeMemoryPercentageToActivateService(int value);
    public bool get_MultipleSiteBindingsEnabled();
    public void set_MultipleSiteBindingsEnabled(bool value);
    internal static ServiceHostingEnvironmentSection GetSection();
    [SecurityCriticalAttribute]
internal static ServiceHostingEnvironmentSection UnsafeGetSection();
}
public class System.ServiceModel.Configuration.ServiceMetadataEndpointCollectionElement : StandardEndpointCollectionElement`2<ServiceMetadataEndpoint, ServiceMetadataEndpointElement> {
}
public class System.ServiceModel.Configuration.ServiceMetadataEndpointElement : StandardEndpointElement {
    protected internal Type EndpointType { get; }
    protected internal virtual Type get_EndpointType();
    protected internal virtual ServiceEndpoint CreateServiceEndpoint(ContractDescription contractDescription);
    protected virtual void OnInitializeAndValidate(ChannelEndpointElement channelEndpointElement);
    protected virtual void OnInitializeAndValidate(ServiceEndpointElement serviceEndpointElement);
    protected virtual void OnApplyConfiguration(ServiceEndpoint endpoint, ServiceEndpointElement serviceEndpointElement);
    protected virtual void OnApplyConfiguration(ServiceEndpoint endpoint, ChannelEndpointElement serviceEndpointElement);
}
public class System.ServiceModel.Configuration.ServiceMetadataPublishingElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("externalMetadataLocation")]
public Uri ExternalMetadataLocation { get; public set; }
    [ConfigurationPropertyAttribute("httpGetEnabled")]
public bool HttpGetEnabled { get; public set; }
    [ConfigurationPropertyAttribute("httpGetUrl")]
public Uri HttpGetUrl { get; public set; }
    [ConfigurationPropertyAttribute("httpsGetEnabled")]
public bool HttpsGetEnabled { get; public set; }
    [ConfigurationPropertyAttribute("httpsGetUrl")]
public Uri HttpsGetUrl { get; public set; }
    [ConfigurationPropertyAttribute("httpGetBinding")]
[StringValidatorAttribute]
public string HttpGetBinding { get; public set; }
    [ConfigurationPropertyAttribute("httpGetBindingConfiguration")]
[StringValidatorAttribute]
public string HttpGetBindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("httpsGetBinding")]
[StringValidatorAttribute]
public string HttpsGetBinding { get; public set; }
    [ConfigurationPropertyAttribute("httpsGetBindingConfiguration")]
[StringValidatorAttribute]
public string HttpsGetBindingConfiguration { get; public set; }
    [ConfigurationPropertyAttribute("policyVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.PolicyVersionConverter")]
public PolicyVersion PolicyVersion { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Uri get_ExternalMetadataLocation();
    public void set_ExternalMetadataLocation(Uri value);
    public bool get_HttpGetEnabled();
    public void set_HttpGetEnabled(bool value);
    public Uri get_HttpGetUrl();
    public void set_HttpGetUrl(Uri value);
    public bool get_HttpsGetEnabled();
    public void set_HttpsGetEnabled(bool value);
    public Uri get_HttpsGetUrl();
    public void set_HttpsGetUrl(Uri value);
    public string get_HttpGetBinding();
    public void set_HttpGetBinding(string value);
    public string get_HttpGetBindingConfiguration();
    public void set_HttpGetBindingConfiguration(string value);
    public string get_HttpsGetBinding();
    public void set_HttpsGetBinding(string value);
    public string get_HttpsGetBindingConfiguration();
    public void set_HttpsGetBindingConfiguration(string value);
    public PolicyVersion get_PolicyVersion();
    public void set_PolicyVersion(PolicyVersion value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public abstract class System.ServiceModel.Configuration.ServiceModelConfigurationElement : ConfigurationElement {
    protected void SetPropertyValueIfNotDefaultValue(string propertyName, T value);
}
[DefaultMemberAttribute("Item")]
public abstract class System.ServiceModel.Configuration.ServiceModelConfigurationElementCollection`1 : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public ConfigurationElementType Item { get; public set; }
    public ConfigurationElementType Item { get; public set; }
    internal ServiceModelConfigurationElementCollection`1(ConfigurationElementCollectionType collectionType, string elementName);
    internal ServiceModelConfigurationElementCollection`1(ConfigurationElementCollectionType collectionType, string elementName, IComparer comparer);
    protected virtual void BaseAdd(ConfigurationElement element);
    public void Add(ConfigurationElementType element);
    public void Clear();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    public virtual bool ContainsKey(object key);
    protected virtual ConfigurationElement CreateNewElement();
    public void CopyTo(ConfigurationElementType[] array, int start);
    protected virtual string get_ElementName();
    public int IndexOf(ConfigurationElementType element);
    public void Remove(ConfigurationElementType element);
    public void RemoveAt(object key);
    public void RemoveAt(int index);
    public virtual ConfigurationElementType get_Item(object key);
    public virtual void set_Item(object key, ConfigurationElementType value);
    public ConfigurationElementType get_Item(int index);
    public void set_Item(int index, ConfigurationElementType value);
}
public abstract class System.ServiceModel.Configuration.ServiceModelEnhancedConfigurationElementCollection`1 : ServiceModelConfigurationElementCollection`1<TConfigurationElement> {
    protected bool ThrowOnDuplicate { get; }
    internal ServiceModelEnhancedConfigurationElementCollection`1(string elementName);
    protected virtual void BaseAdd(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
}
internal class System.ServiceModel.Configuration.ServiceModelEnumValidator : ConfigurationValidatorBase {
    public ServiceModelEnumValidator(Type enumHelperType);
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.ServiceModelEnumValidatorAttribute : ConfigurationValidatorAttribute {
    public Type EnumHelperType { get; public set; }
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public ServiceModelEnumValidatorAttribute(Type enumHelperType);
    public Type get_EnumHelperType();
    public void set_EnumHelperType(Type value);
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
[DefaultMemberAttribute("Item")]
public abstract class System.ServiceModel.Configuration.ServiceModelExtensionCollectionElement`1 : ConfigurationElement {
    public TServiceModelExtensionElement Item { get; }
    public TServiceModelExtensionElement Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TServiceModelExtensionElement>.IsReadOnly { get; }
    internal List`1<TServiceModelExtensionElement> Items { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal Type CollectionElementBaseType { get; }
    internal ServiceModelExtensionCollectionElement`1(string extensionCollectionName);
    public TServiceModelExtensionElement get_Item(int index);
    public TServiceModelExtensionElement get_Item(Type extensionType);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TServiceModelExtensionElement>.get_IsReadOnly();
    internal List`1<TServiceModelExtensionElement> get_Items();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual void Add(TServiceModelExtensionElement element);
    internal void AddItem(TServiceModelExtensionElement element);
    public virtual bool CanAdd(TServiceModelExtensionElement element);
    public sealed virtual void Clear();
    internal Type get_CollectionElementBaseType();
    public sealed virtual bool Contains(TServiceModelExtensionElement element);
    public bool ContainsKey(Type elementType);
    public bool ContainsKey(string elementName);
    public sealed virtual void CopyTo(TServiceModelExtensionElement[] elements, int start);
    internal void MergeWith(List`1<TServiceModelExtensionElement> parentExtensionElements);
    [SecuritySafeCriticalAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    [IteratorStateMachineAttribute("System.ServiceModel.Configuration.ServiceModelExtensionCollectionElement`1/<GetEnumerator>d__37")]
public sealed virtual IEnumerator`1<TServiceModelExtensionElement> GetEnumerator();
    protected virtual bool IsModified();
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    public sealed virtual bool Remove(TServiceModelExtensionElement element);
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    protected virtual void ResetModified();
    protected void SetIsModified();
    protected virtual void SetReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public abstract class System.ServiceModel.Configuration.ServiceModelExtensionElement : ServiceModelConfigurationElement {
    public string ConfigurationElementName { get; internal set; }
    internal ContextInformation ContainingEvaluationContext { get; internal set; }
    internal string ExtensionCollectionName { get; internal set; }
    internal ContextInformation EvalContext { get; }
    internal ConfigurationPropertyCollection PropertiesInternal { get; }
    [SecuritySafeCriticalAttribute]
internal bool CanAdd(string extensionCollectionName, ContextInformation evaluationContext);
    public string get_ConfigurationElementName();
    internal void set_ConfigurationElementName(string value);
    internal ContextInformation get_ContainingEvaluationContext();
    internal void set_ContainingEvaluationContext(ContextInformation value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    internal void DeserializeInternal(XmlReader reader, bool serializeCollectionKey);
    internal void set_ExtensionCollectionName(string value);
    internal string get_ExtensionCollectionName();
    internal ContextInformation get_EvalContext();
    internal object FromProperty(ConfigurationProperty property);
    internal void InternalInitializeDefault();
    protected virtual bool IsModified();
    internal bool IsModifiedInternal();
    internal ConfigurationPropertyCollection get_PropertiesInternal();
    internal void ResetModifiedInternal();
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    internal bool SerializeInternal(XmlWriter writer, bool serializeCollectionKey);
    internal void SetReadOnlyInternal();
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.ServiceModelSectionGroup : ConfigurationSectionGroup {
    public BehaviorsSection Behaviors { get; }
    public BindingsSection Bindings { get; }
    public ClientSection Client { get; }
    public ComContractsSection ComContracts { get; }
    public CommonBehaviorsSection CommonBehaviors { get; }
    public DiagnosticSection Diagnostic { get; }
    public ServiceHostingEnvironmentSection ServiceHostingEnvironment { get; }
    public ExtensionsSection Extensions { get; }
    public ProtocolMappingSection ProtocolMapping { get; }
    public ServicesSection Services { get; }
    public StandardEndpointsSection StandardEndpoints { get; }
    public BehaviorsSection get_Behaviors();
    public BindingsSection get_Bindings();
    public ClientSection get_Client();
    public ComContractsSection get_ComContracts();
    public CommonBehaviorsSection get_CommonBehaviors();
    public DiagnosticSection get_Diagnostic();
    public ServiceHostingEnvironmentSection get_ServiceHostingEnvironment();
    public ExtensionsSection get_Extensions();
    public ProtocolMappingSection get_ProtocolMapping();
    public ServicesSection get_Services();
    public StandardEndpointsSection get_StandardEndpoints();
    public static ServiceModelSectionGroup GetSectionGroup(Configuration config);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.ServiceModelTimeSpanValidatorAttribute : ConfigurationValidatorAttribute {
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public TimeSpan MinValue { get; }
    public string MinValueString { get; public set; }
    public TimeSpan MaxValue { get; }
    public string MaxValueString { get; public set; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
    public TimeSpan get_MinValue();
    public string get_MinValueString();
    public void set_MinValueString(string value);
    public TimeSpan get_MaxValue();
    public string get_MaxValueString();
    public void set_MaxValueString(string value);
}
public class System.ServiceModel.Configuration.ServicePrincipalNameElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("value")]
[StringValidatorAttribute]
public string Value { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Value();
    public void set_Value(string value);
}
public class System.ServiceModel.Configuration.ServiceSecurityAuditElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("auditLogLocation")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.AuditLogLocationHelper")]
public AuditLogLocation AuditLogLocation { get; public set; }
    [ConfigurationPropertyAttribute("suppressAuditFailure")]
public bool SuppressAuditFailure { get; public set; }
    [ConfigurationPropertyAttribute("serviceAuthorizationAuditLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.AuditLevelHelper")]
public AuditLevel ServiceAuthorizationAuditLevel { get; public set; }
    [ConfigurationPropertyAttribute("messageAuthenticationAuditLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.AuditLevelHelper")]
public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public AuditLogLocation get_AuditLogLocation();
    public void set_AuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_ServiceAuthorizationAuditLevel();
    public void set_ServiceAuthorizationAuditLevel(AuditLevel value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ServicesSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public ServiceElementCollection Services { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ServiceElementCollection get_Services();
    internal static ServicesSection GetSection();
    [SecurityCriticalAttribute]
internal static ServicesSection UnsafeGetSection();
    protected virtual void PostDeserialize();
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.ServiceThrottlingElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("maxConcurrentCalls")]
[IntegerValidatorAttribute]
public int MaxConcurrentCalls { get; public set; }
    [ConfigurationPropertyAttribute("maxConcurrentSessions")]
[IntegerValidatorAttribute]
public int MaxConcurrentSessions { get; public set; }
    [ConfigurationPropertyAttribute("maxConcurrentInstances")]
[IntegerValidatorAttribute]
public int MaxConcurrentInstances { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_MaxConcurrentCalls();
    public void set_MaxConcurrentCalls(int value);
    public int get_MaxConcurrentSessions();
    public void set_MaxConcurrentSessions(int value);
    public int get_MaxConcurrentInstances();
    public void set_MaxConcurrentInstances(int value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.ServiceTimeoutsElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("transactionTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan TransactionTimeout { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public TimeSpan get_TransactionTimeout();
    public void set_TransactionTimeout(TimeSpan value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
internal class System.ServiceModel.Configuration.SessionIdTypeConvertor : Int32Converter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object data);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
}
public class System.ServiceModel.Configuration.SslStreamSecurityElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("requireClientCertificate")]
public bool RequireClientCertificate { get; public set; }
    [ConfigurationPropertyAttribute("sslProtocols")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.SslProtocolsHelper")]
public SslProtocols SslProtocols { get; private set; }
    public Type BindingElementType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    public SslProtocols get_SslProtocols();
    private void set_SslProtocols(SslProtocols value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    protected internal virtual BindingElement CreateBindingElement();
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
}
public class System.ServiceModel.Configuration.StandardBindingCollectionElement`2 : BindingCollectionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public StandardBindingElementCollection`1<TBindingConfiguration> Bindings { get; }
    public Type BindingType { get; }
    public ReadOnlyCollection`1<IBindingConfigurationElement> ConfiguredBindings { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public StandardBindingElementCollection`1<TBindingConfiguration> get_Bindings();
    public virtual Type get_BindingType();
    public virtual ReadOnlyCollection`1<IBindingConfigurationElement> get_ConfiguredBindings();
    public virtual bool ContainsKey(string name);
    protected internal virtual Binding GetDefault();
    protected internal virtual bool TryAdd(string name, Binding binding, Configuration config);
}
public abstract class System.ServiceModel.Configuration.StandardBindingElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("closeTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan CloseTimeout { get; public set; }
    [ConfigurationPropertyAttribute("openTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan OpenTimeout { get; public set; }
    [ConfigurationPropertyAttribute("receiveTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan ReceiveTimeout { get; public set; }
    [ConfigurationPropertyAttribute("sendTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan SendTimeout { get; public set; }
    protected StandardBindingElement(string name);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected abstract virtual Type get_BindingElementType();
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_SendTimeout();
    public void set_SendTimeout(TimeSpan value);
    public sealed virtual void ApplyConfiguration(Binding binding);
    protected internal virtual void InitializeFrom(Binding binding);
    protected abstract virtual void OnApplyConfiguration(Binding binding);
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.StandardBindingElementCollection`1 : ServiceModelEnhancedConfigurationElementCollection`1<TBindingConfiguration> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.StandardBindingOptionalReliableSessionElement : StandardBindingReliableSessionElement {
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public void InitializeFrom(OptionalReliableSession optionalReliableSession);
    public void ApplyConfiguration(OptionalReliableSession optionalReliableSession);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.StandardBindingReliableSessionElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("ordered")]
public bool Ordered { get; public set; }
    [ConfigurationPropertyAttribute("inactivityTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan InactivityTimeout { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public void InitializeFrom(ReliableSession reliableSession);
    public void ApplyConfiguration(ReliableSession reliableSession);
}
public class System.ServiceModel.Configuration.StandardEndpointCollectionElement`2 : EndpointCollectionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public StandardEndpointElementCollection`1<TEndpointConfiguration> Endpoints { get; }
    public Type EndpointType { get; }
    public ReadOnlyCollection`1<StandardEndpointElement> ConfiguredEndpoints { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public StandardEndpointElementCollection`1<TEndpointConfiguration> get_Endpoints();
    public virtual Type get_EndpointType();
    public virtual ReadOnlyCollection`1<StandardEndpointElement> get_ConfiguredEndpoints();
    public virtual bool ContainsKey(string name);
    protected internal virtual StandardEndpointElement GetDefaultStandardEndpointElement();
    protected internal virtual bool TryAdd(string name, ServiceEndpoint endpoint, Configuration config);
}
public abstract class System.ServiceModel.Configuration.StandardEndpointElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    protected internal Type EndpointType { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected internal abstract virtual Type get_EndpointType();
    public string get_Name();
    public void set_Name(string value);
    public void InitializeAndValidate(ChannelEndpointElement channelEndpointElement);
    public void InitializeAndValidate(ServiceEndpointElement serviceEndpointElement);
    public void ApplyConfiguration(ServiceEndpoint endpoint, ChannelEndpointElement channelEndpointElement);
    public void ApplyConfiguration(ServiceEndpoint endpoint, ServiceEndpointElement serviceEndpointElement);
    protected internal virtual void InitializeFrom(ServiceEndpoint endpoint);
    protected internal abstract virtual ServiceEndpoint CreateServiceEndpoint(ContractDescription contractDescription);
    protected abstract virtual void OnApplyConfiguration(ServiceEndpoint endpoint, ChannelEndpointElement channelEndpointElement);
    protected abstract virtual void OnApplyConfiguration(ServiceEndpoint endpoint, ServiceEndpointElement serviceEndpointElement);
    protected abstract virtual void OnInitializeAndValidate(ChannelEndpointElement channelEndpointElement);
    protected abstract virtual void OnInitializeAndValidate(ServiceEndpointElement serviceEndpointElement);
    [SecurityCriticalAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    [SecurityCriticalAttribute]
private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
public class System.ServiceModel.Configuration.StandardEndpointElementCollection`1 : ServiceModelEnhancedConfigurationElementCollection`1<TEndpointConfiguration> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Configuration.StandardEndpointsSection : ConfigurationSection {
    public EndpointCollectionElement Item { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("mexEndpoint")]
public ServiceMetadataEndpointCollectionElement MexEndpoint { get; }
    public List`1<EndpointCollectionElement> EndpointCollections { get; }
    public EndpointCollectionElement get_Item(string endpoint);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ServiceMetadataEndpointCollectionElement get_MexEndpoint();
    public static StandardEndpointsSection GetSection(Configuration config);
    public List`1<EndpointCollectionElement> get_EndpointCollections();
    internal static bool TryAdd(string name, ServiceEndpoint endpoint, Configuration config, String& endpointSectionName);
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    internal static bool TryAdd(string name, ServiceEndpoint endpoint, String& endpointSectionName);
    [SecuritySafeCriticalAttribute]
internal void UpdateEndpointSections(ContextInformation evaluationContext);
    [SecuritySafeCriticalAttribute]
internal static void ValidateEndpointReference(string endpoint, string endpointConfiguration, ContextInformation evaluationContext, ConfigurationElement configurationElement);
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext();
    private sealed virtual override ContextInformation System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext();
}
internal class System.ServiceModel.Configuration.StandardRuntimeEnumValidator : ConfigurationValidatorBase {
    public StandardRuntimeEnumValidator(Type enumType);
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.StandardRuntimeEnumValidatorAttribute : ConfigurationValidatorAttribute {
    public Type EnumType { get; public set; }
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public StandardRuntimeEnumValidatorAttribute(Type enumType);
    public Type get_EnumType();
    public void set_EnumType(Type value);
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
internal class System.ServiceModel.Configuration.StandardRuntimeFlagEnumValidator`1 : ConfigurationValidatorBase {
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.ServiceModel.Configuration.StandardRuntimeFlagEnumValidatorAttribute : ConfigurationValidatorAttribute {
    public Type EnumType { get; public set; }
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public StandardRuntimeFlagEnumValidatorAttribute(Type enumType);
    public Type get_EnumType();
    public void set_EnumType(Type value);
    internal static void ValidateFlagEnumType(Type value);
    internal static bool IsCombinedValue(int combinedValue, Int32[] allowedValues, int startPosition);
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.ServiceModel.Configuration.SynchronousReceiveElement : BehaviorExtensionElement {
    public Type BehaviorType { get; }
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.TcpConnectionPoolSettingsElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("groupName")]
[StringValidatorAttribute]
public string GroupName { get; public set; }
    [ConfigurationPropertyAttribute("leaseTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan LeaseTimeout { get; public set; }
    [ConfigurationPropertyAttribute("idleTimeout")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan IdleTimeout { get; public set; }
    [ConfigurationPropertyAttribute("maxOutboundConnectionsPerEndpoint")]
[IntegerValidatorAttribute]
public int MaxOutboundConnectionsPerEndpoint { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_GroupName();
    public void set_GroupName(string value);
    public TimeSpan get_LeaseTimeout();
    public void set_LeaseTimeout(TimeSpan value);
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public int get_MaxOutboundConnectionsPerEndpoint();
    public void set_MaxOutboundConnectionsPerEndpoint(int value);
    internal void ApplyConfiguration(TcpConnectionPoolSettings settings);
    internal void InitializeFrom(TcpConnectionPoolSettings settings);
    internal void CopyFrom(TcpConnectionPoolSettingsElement source);
}
public class System.ServiceModel.Configuration.TcpTransportElement : ConnectionOrientedTransportElement {
    protected ConfigurationPropertyCollection Properties { get; }
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("listenBacklog")]
[IntegerValidatorAttribute]
public int ListenBacklog { get; public set; }
    [ConfigurationPropertyAttribute("portSharingEnabled")]
public bool PortSharingEnabled { get; public set; }
    [ConfigurationPropertyAttribute("teredoEnabled")]
public bool TeredoEnabled { get; public set; }
    [ConfigurationPropertyAttribute("connectionPoolSettings")]
public TcpConnectionPoolSettingsElement ConnectionPoolSettings { get; public set; }
    [ConfigurationPropertyAttribute("extendedProtectionPolicy")]
public ExtendedProtectionPolicyElement ExtendedProtectionPolicy { get; private set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected virtual TransportBindingElement CreateDefaultBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public int get_ListenBacklog();
    public void set_ListenBacklog(int value);
    public bool get_PortSharingEnabled();
    public void set_PortSharingEnabled(bool value);
    public bool get_TeredoEnabled();
    public void set_TeredoEnabled(bool value);
    public TcpConnectionPoolSettingsElement get_ConnectionPoolSettings();
    public void set_ConnectionPoolSettings(TcpConnectionPoolSettingsElement value);
    public ExtendedProtectionPolicyElement get_ExtendedProtectionPolicy();
    private void set_ExtendedProtectionPolicy(ExtendedProtectionPolicyElement value);
}
public class System.ServiceModel.Configuration.TcpTransportSecurityElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.TcpClientCredentialTypeHelper")]
public TcpClientCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("protectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel ProtectionLevel { get; public set; }
    [ConfigurationPropertyAttribute("extendedProtectionPolicy")]
public ExtendedProtectionPolicyElement ExtendedProtectionPolicy { get; private set; }
    [ConfigurationPropertyAttribute("sslProtocols")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.SslProtocolsHelper")]
public SslProtocols SslProtocols { get; private set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public TcpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(TcpClientCredentialType value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public ExtendedProtectionPolicyElement get_ExtendedProtectionPolicy();
    private void set_ExtendedProtectionPolicy(ExtendedProtectionPolicyElement value);
    public SslProtocols get_SslProtocols();
    private void set_SslProtocols(SslProtocols value);
    internal void ApplyConfiguration(TcpTransportSecurity security);
    internal void InitializeFrom(TcpTransportSecurity security);
}
public class System.ServiceModel.Configuration.TextMessageEncodingElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    public Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("maxReadPoolSize")]
[IntegerValidatorAttribute]
public int MaxReadPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxWritePoolSize")]
[IntegerValidatorAttribute]
public int MaxWritePoolSize { get; public set; }
    [ConfigurationPropertyAttribute("messageVersion")]
[TypeConverterAttribute("System.ServiceModel.Configuration.MessageVersionConverter")]
public MessageVersion MessageVersion { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("writeEncoding")]
[TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding WriteEncoding { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public MessageVersion get_MessageVersion();
    public void set_MessageVersion(MessageVersion value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
}
internal class System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter : TimeSpanConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object data);
}
internal class System.ServiceModel.Configuration.TimeSpanOrInfiniteValidator : TimeSpanValidator {
    public TimeSpanOrInfiniteValidator(TimeSpan minValue, TimeSpan maxValue);
    public virtual void Validate(object value);
}
public class System.ServiceModel.Configuration.TransactedBatchingElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("maxBatchSize")]
[IntegerValidatorAttribute]
public int MaxBatchSize { get; public set; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_MaxBatchSize();
    public void set_MaxBatchSize(int value);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.TransactionFlowElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("transactionProtocol")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TransactionProtocolConverter")]
public TransactionProtocol TransactionProtocol { get; public set; }
    [ConfigurationPropertyAttribute("allowWildcardAction")]
public bool AllowWildcardAction { get; public set; }
    public Type BindingElementType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    public bool get_AllowWildcardAction();
    public void set_AllowWildcardAction(bool value);
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
}
internal class System.ServiceModel.Configuration.TransactionProtocolConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ServiceModel.Configuration.TransportConfigurationTypeElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("transportConfigurationType")]
[StringValidatorAttribute]
public string TransportConfigurationType { get; public set; }
    public TransportConfigurationTypeElement(string name);
    public TransportConfigurationTypeElement(string name, string transportConfigurationTypeName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public string get_TransportConfigurationType();
    public void set_TransportConfigurationType(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.TransportConfigurationTypeElement")]
public class System.ServiceModel.Configuration.TransportConfigurationTypeElementCollection : ServiceModelConfigurationElementCollection`1<TransportConfigurationTypeElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public abstract class System.ServiceModel.Configuration.TransportElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("manualAddressing")]
public bool ManualAddressing { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected abstract virtual TransportBindingElement CreateDefaultBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
}
internal class System.ServiceModel.Configuration.UnrecognizedPolicyAssertionElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual BindingElement CreateBindingElement();
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
}
public class System.ServiceModel.Configuration.UseManagedPresentationElement : BindingElementExtensionElement {
    public Type BindingElementType { get; }
    public virtual Type get_BindingElementType();
    protected internal virtual BindingElement CreateBindingElement();
}
public class System.ServiceModel.Configuration.UseRequestHeadersForMetadataAddressElement : BehaviorExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("defaultPorts")]
public DefaultPortElementCollection DefaultPorts { get; }
    public Type BehaviorType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public DefaultPortElementCollection get_DefaultPorts();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual object CreateBehavior();
    public virtual Type get_BehaviorType();
}
public class System.ServiceModel.Configuration.UserNameServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("userNamePasswordValidationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.UserNamePasswordValidationModeHelper")]
public UserNamePasswordValidationMode UserNamePasswordValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("includeWindowsGroups")]
public bool IncludeWindowsGroups { get; public set; }
    [ConfigurationPropertyAttribute("membershipProviderName")]
[StringValidatorAttribute]
public string MembershipProviderName { get; public set; }
    [ConfigurationPropertyAttribute("customUserNamePasswordValidatorType")]
[StringValidatorAttribute]
public string CustomUserNamePasswordValidatorType { get; public set; }
    [ConfigurationPropertyAttribute("cacheLogonTokens")]
public bool CacheLogonTokens { get; public set; }
    [ConfigurationPropertyAttribute("maxCachedLogonTokens")]
[IntegerValidatorAttribute]
public int MaxCachedLogonTokens { get; public set; }
    [ConfigurationPropertyAttribute("cachedLogonTokenLifetime")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan CachedLogonTokenLifetime { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public UserNamePasswordValidationMode get_UserNamePasswordValidationMode();
    public void set_UserNamePasswordValidationMode(UserNamePasswordValidationMode value);
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    public string get_MembershipProviderName();
    public void set_MembershipProviderName(string value);
    public string get_CustomUserNamePasswordValidatorType();
    public void set_CustomUserNamePasswordValidatorType(string value);
    public bool get_CacheLogonTokens();
    public void set_CacheLogonTokens(bool value);
    public int get_MaxCachedLogonTokens();
    public void set_MaxCachedLogonTokens(int value);
    public TimeSpan get_CachedLogonTokenLifetime();
    public void set_CachedLogonTokenLifetime(TimeSpan value);
    public void Copy(UserNameServiceElement from);
    internal void ApplyConfiguration(UserNamePasswordServiceCredential userName);
}
public class System.ServiceModel.Configuration.UserPrincipalNameElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("value")]
[StringValidatorAttribute]
public string Value { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Value();
    public void set_Value(string value);
}
public class System.ServiceModel.Configuration.WebSocketTransportSettingsElement : ServiceModelConfigurationElement {
    [ConfigurationPropertyAttribute("transportUsage")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Channels.WebSocketTransportUsageHelper")]
public WebSocketTransportUsage TransportUsage { get; public set; }
    [ConfigurationPropertyAttribute("createNotificationOnConnection")]
public bool CreateNotificationOnConnection { get; public set; }
    [ConfigurationPropertyAttribute("keepAliveInterval")]
[TypeConverterAttribute("System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter")]
[ServiceModelTimeSpanValidatorAttribute]
public TimeSpan KeepAliveInterval { get; public set; }
    [ConfigurationPropertyAttribute("subProtocol")]
[StringValidatorAttribute]
public string SubProtocol { get; public set; }
    [ConfigurationPropertyAttribute("disablePayloadMasking")]
public bool DisablePayloadMasking { get; public set; }
    [ConfigurationPropertyAttribute("maxPendingConnections")]
[IntegerValidatorAttribute]
public int MaxPendingConnections { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public virtual WebSocketTransportUsage get_TransportUsage();
    public virtual void set_TransportUsage(WebSocketTransportUsage value);
    public bool get_CreateNotificationOnConnection();
    public void set_CreateNotificationOnConnection(bool value);
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    public virtual string get_SubProtocol();
    public virtual void set_SubProtocol(string value);
    public bool get_DisablePayloadMasking();
    public void set_DisablePayloadMasking(bool value);
    public int get_MaxPendingConnections();
    public void set_MaxPendingConnections(int value);
    public void InitializeFrom(WebSocketTransportSettings settings);
    public void ApplyConfiguration(WebSocketTransportSettings settings);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.WindowsClientElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("allowNtlm")]
public bool AllowNtlm { get; public set; }
    [ConfigurationPropertyAttribute("allowedImpersonationLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.TokenImpersonationLevelHelper")]
public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_AllowNtlm();
    public void set_AllowNtlm(bool value);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public void Copy(WindowsClientElement from);
    internal void ApplyConfiguration(WindowsClientCredential windows);
}
public class System.ServiceModel.Configuration.WindowsServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("includeWindowsGroups")]
public bool IncludeWindowsGroups { get; public set; }
    [ConfigurationPropertyAttribute("allowAnonymousLogons")]
public bool AllowAnonymousLogons { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    public bool get_AllowAnonymousLogons();
    public void set_AllowAnonymousLogons(bool value);
    public void Copy(WindowsServiceElement from);
    internal void ApplyConfiguration(WindowsServiceCredential windows);
}
public class System.ServiceModel.Configuration.WindowsStreamSecurityElement : BindingElementExtensionElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("protectionLevel")]
[StandardRuntimeEnumValidatorAttribute("System.Net.Security.ProtectionLevel")]
public ProtectionLevel ProtectionLevel { get; public set; }
    public Type BindingElementType { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public virtual void ApplyConfiguration(BindingElement bindingElement);
    protected internal virtual BindingElement CreateBindingElement();
    public virtual Type get_BindingElementType();
    public virtual void CopyFrom(ServiceModelExtensionElement from);
    protected internal virtual void InitializeFrom(BindingElement bindingElement);
}
public class System.ServiceModel.Configuration.WS2007FederationHttpBindingCollectionElement : StandardBindingCollectionElement`2<WS2007FederationHttpBinding, WS2007FederationHttpBindingElement> {
    internal static WS2007FederationHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.WS2007FederationHttpBindingElement : WSFederationHttpBindingElement {
    protected Type BindingElementType { get; }
    public WS2007FederationHttpBindingElement(string name);
    protected virtual Type get_BindingElementType();
}
public class System.ServiceModel.Configuration.WS2007HttpBindingCollectionElement : StandardBindingCollectionElement`2<WS2007HttpBinding, WS2007HttpBindingElement> {
    internal static WS2007HttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.WS2007HttpBindingElement : WSHttpBindingElement {
    protected Type BindingElementType { get; }
    public WS2007HttpBindingElement(string name);
    protected virtual Type get_BindingElementType();
}
public class System.ServiceModel.Configuration.WsdlImporterElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    public WsdlImporterElement(string type);
    public WsdlImporterElement(Type type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.WsdlImporterElement")]
public class System.ServiceModel.Configuration.WsdlImporterElementCollection : ServiceModelEnhancedConfigurationElementCollection`1<WsdlImporterElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
    internal void SetDefaults();
}
public class System.ServiceModel.Configuration.WSDualHttpBindingCollectionElement : StandardBindingCollectionElement`2<WSDualHttpBinding, WSDualHttpBindingElement> {
    internal static WSDualHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.WSDualHttpBindingElement : StandardBindingElement {
    protected ConfigurationPropertyCollection Properties { get; }
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("bypassProxyOnLocal")]
public bool BypassProxyOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("clientBaseAddress")]
public Uri ClientBaseAddress { get; public set; }
    [ConfigurationPropertyAttribute("transactionFlow")]
public bool TransactionFlow { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSMessageEncodingHelper")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("proxyAddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("reliableSession")]
public StandardBindingReliableSessionElement ReliableSession { get; }
    [ConfigurationPropertyAttribute("security")]
public WSDualHttpSecurityElement Security { get; }
    [ConfigurationPropertyAttribute("textEncoding")]
[TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [ConfigurationPropertyAttribute("useDefaultWebProxy")]
public bool UseDefaultWebProxy { get; public set; }
    public WSDualHttpBindingElement(string name);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual Type get_BindingElementType();
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public Uri get_ClientBaseAddress();
    public void set_ClientBaseAddress(Uri value);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public StandardBindingReliableSessionElement get_ReliableSession();
    public WSDualHttpSecurityElement get_Security();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
}
public class System.ServiceModel.Configuration.WSDualHttpSecurityElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSDualHttpSecurityModeHelper")]
public WSDualHttpSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("message")]
public MessageSecurityOverHttpElement Message { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public WSDualHttpSecurityMode get_Mode();
    public void set_Mode(WSDualHttpSecurityMode value);
    public MessageSecurityOverHttpElement get_Message();
    internal void ApplyConfiguration(WSDualHttpSecurity security);
    internal void InitializeFrom(WSDualHttpSecurity security);
}
public class System.ServiceModel.Configuration.WSFederationHttpBindingCollectionElement : StandardBindingCollectionElement`2<WSFederationHttpBinding, WSFederationHttpBindingElement> {
    internal static WSFederationHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.WSFederationHttpBindingElement : WSHttpBindingBaseElement {
    protected ConfigurationPropertyCollection Properties { get; }
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("privacyNoticeAt")]
public Uri PrivacyNoticeAt { get; public set; }
    [ConfigurationPropertyAttribute("privacyNoticeVersion")]
[IntegerValidatorAttribute]
public int PrivacyNoticeVersion { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public WSFederationHttpSecurityElement Security { get; }
    public WSFederationHttpBindingElement(string name);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual Type get_BindingElementType();
    public Uri get_PrivacyNoticeAt();
    public void set_PrivacyNoticeAt(Uri value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public WSFederationHttpSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
}
public class System.ServiceModel.Configuration.WSFederationHttpSecurityElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSFederationHttpSecurityModeHelper")]
public WSFederationHttpSecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("message")]
public FederatedMessageSecurityOverHttpElement Message { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public WSFederationHttpSecurityMode get_Mode();
    public void set_Mode(WSFederationHttpSecurityMode value);
    public FederatedMessageSecurityOverHttpElement get_Message();
    internal void ApplyConfiguration(WSFederationHttpSecurity security);
    internal void InitializeFrom(WSFederationHttpSecurity security);
}
public abstract class System.ServiceModel.Configuration.WSHttpBindingBaseElement : StandardBindingElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("bypassProxyOnLocal")]
public bool BypassProxyOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("transactionFlow")]
public bool TransactionFlow { get; public set; }
    [ConfigurationPropertyAttribute("hostNameComparisonMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HostNameComparisonModeHelper")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [ConfigurationPropertyAttribute("maxBufferPoolSize")]
[LongValidatorAttribute]
public long MaxBufferPoolSize { get; public set; }
    [ConfigurationPropertyAttribute("maxReceivedMessageSize")]
[LongValidatorAttribute]
public long MaxReceivedMessageSize { get; public set; }
    [ConfigurationPropertyAttribute("messageEncoding")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.WSMessageEncodingHelper")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [ConfigurationPropertyAttribute("proxyAddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("readerQuotas")]
public XmlDictionaryReaderQuotasElement ReaderQuotas { get; }
    [ConfigurationPropertyAttribute("reliableSession")]
public StandardBindingOptionalReliableSessionElement ReliableSession { get; }
    [ConfigurationPropertyAttribute("textEncoding")]
[TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [ConfigurationPropertyAttribute("useDefaultWebProxy")]
public bool UseDefaultWebProxy { get; public set; }
    protected WSHttpBindingBaseElement(string name);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotasElement get_ReaderQuotas();
    public StandardBindingOptionalReliableSessionElement get_ReliableSession();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
}
public class System.ServiceModel.Configuration.WSHttpBindingCollectionElement : StandardBindingCollectionElement`2<WSHttpBinding, WSHttpBindingElement> {
    internal static WSHttpBindingCollectionElement GetBindingCollectionElement();
}
public class System.ServiceModel.Configuration.WSHttpBindingElement : WSHttpBindingBaseElement {
    protected ConfigurationPropertyCollection Properties { get; }
    protected Type BindingElementType { get; }
    [ConfigurationPropertyAttribute("allowCookies")]
public bool AllowCookies { get; public set; }
    [ConfigurationPropertyAttribute("security")]
public WSHttpSecurityElement Security { get; }
    public WSHttpBindingElement(string name);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual Type get_BindingElementType();
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public WSHttpSecurityElement get_Security();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.WSHttpContextBindingCollectionElement : StandardBindingCollectionElement`2<WSHttpContextBinding, WSHttpContextBindingElement> {
    internal static string wsHttpContextBindingName;
    internal static WSHttpContextBindingCollectionElement GetBindingCollectionElement();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Configuration.WSHttpContextBindingElement : WSHttpBindingElement {
    [ConfigurationPropertyAttribute("clientCallbackAddress")]
public Uri ClientCallbackAddress { get; public set; }
    [ConfigurationPropertyAttribute("contextManagementEnabled")]
public bool ContextManagementEnabled { get; public set; }
    [ConfigurationPropertyAttribute("contextProtectionLevel")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.ProtectionLevelHelper")]
public ProtectionLevel ContextProtectionLevel { get; public set; }
    protected Type BindingElementType { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public WSHttpContextBindingElement(string name);
    public Uri get_ClientCallbackAddress();
    public void set_ClientCallbackAddress(Uri value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public ProtectionLevel get_ContextProtectionLevel();
    public void set_ContextProtectionLevel(ProtectionLevel value);
    protected virtual Type get_BindingElementType();
    protected internal virtual void InitializeFrom(Binding binding);
    protected virtual void OnApplyConfiguration(Binding binding);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.ServiceModel.Configuration.WSHttpSecurityElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("mode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.SecurityModeHelper")]
public SecurityMode Mode { get; public set; }
    [ConfigurationPropertyAttribute("transport")]
public WSHttpTransportSecurityElement Transport { get; }
    [ConfigurationPropertyAttribute("message")]
public NonDualMessageSecurityOverHttpElement Message { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public WSHttpTransportSecurityElement get_Transport();
    public NonDualMessageSecurityOverHttpElement get_Message();
    internal void ApplyConfiguration(WSHttpSecurity security);
    internal void InitializeFrom(WSHttpSecurity security);
}
public class System.ServiceModel.Configuration.WSHttpTransportSecurityElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("clientCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HttpClientCredentialTypeHelper")]
public HttpClientCredentialType ClientCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("proxyCredentialType")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.HttpProxyCredentialTypeHelper")]
public HttpProxyCredentialType ProxyCredentialType { get; public set; }
    [ConfigurationPropertyAttribute("extendedProtectionPolicy")]
public ExtendedProtectionPolicyElement ExtendedProtectionPolicy { get; private set; }
    [ConfigurationPropertyAttribute("realm")]
[StringValidatorAttribute]
public string Realm { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public HttpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(HttpClientCredentialType value);
    public HttpProxyCredentialType get_ProxyCredentialType();
    public void set_ProxyCredentialType(HttpProxyCredentialType value);
    public ExtendedProtectionPolicyElement get_ExtendedProtectionPolicy();
    private void set_ExtendedProtectionPolicy(ExtendedProtectionPolicyElement value);
    public string get_Realm();
    public void set_Realm(string value);
    internal void ApplyConfiguration(HttpTransportSecurity security);
    internal void InitializeFrom(HttpTransportSecurity security);
}
public class System.ServiceModel.Configuration.X509CertificateTrustedIssuerElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509CertificateTrustedIssuerElement from);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.X509CertificateTrustedIssuerElement")]
public class System.ServiceModel.Configuration.X509CertificateTrustedIssuerElementCollection : ServiceModelConfigurationElementCollection`1<X509CertificateTrustedIssuerElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.X509ClientCertificateAuthenticationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("customCertificateValidatorType")]
[StringValidatorAttribute]
public string CustomCertificateValidatorType { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.X509CertificateValidationModeHelper")]
public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("revocationMode")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509RevocationMode")]
public X509RevocationMode RevocationMode { get; public set; }
    [ConfigurationPropertyAttribute("trustedStoreLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation TrustedStoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("includeWindowsGroups")]
public bool IncludeWindowsGroups { get; public set; }
    [ConfigurationPropertyAttribute("mapClientCertificateToWindowsAccount")]
public bool MapClientCertificateToWindowsAccount { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_CustomCertificateValidatorType();
    public void set_CustomCertificateValidatorType(string value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    public bool get_MapClientCertificateToWindowsAccount();
    public void set_MapClientCertificateToWindowsAccount(bool value);
    public void Copy(X509ClientCertificateAuthenticationElement from);
    internal void ApplyConfiguration(X509ClientCertificateAuthentication cert);
}
public class System.ServiceModel.Configuration.X509ClientCertificateCredentialsElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509ClientCertificateCredentialsElement from);
    internal void ApplyConfiguration(X509CertificateInitiatorServiceCredential creds);
}
public class System.ServiceModel.Configuration.X509DefaultServiceCertificateElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509DefaultServiceCertificateElement from);
    internal void ApplyConfiguration(X509CertificateRecipientClientCredential creds);
}
public class System.ServiceModel.Configuration.X509InitiatorCertificateClientElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509InitiatorCertificateClientElement from);
    internal void ApplyConfiguration(X509CertificateInitiatorClientCredential cert);
}
public class System.ServiceModel.Configuration.X509InitiatorCertificateServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("certificate")]
public X509ClientCertificateCredentialsElement Certificate { get; }
    [ConfigurationPropertyAttribute("authentication")]
public X509ClientCertificateAuthenticationElement Authentication { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public X509ClientCertificateCredentialsElement get_Certificate();
    public X509ClientCertificateAuthenticationElement get_Authentication();
    public void Copy(X509InitiatorCertificateServiceElement from);
    internal void ApplyConfiguration(X509CertificateInitiatorServiceCredential cert);
}
public class System.ServiceModel.Configuration.X509PeerCertificateAuthenticationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("customCertificateValidatorType")]
[StringValidatorAttribute]
public string CustomCertificateValidatorType { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.X509CertificateValidationModeHelper")]
public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("revocationMode")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509RevocationMode")]
public X509RevocationMode RevocationMode { get; public set; }
    [ConfigurationPropertyAttribute("trustedStoreLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation TrustedStoreLocation { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_CustomCertificateValidatorType();
    public void set_CustomCertificateValidatorType(string value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public void Copy(X509PeerCertificateAuthenticationElement from);
    internal void ApplyConfiguration(X509PeerCertificateAuthentication cert);
}
public class System.ServiceModel.Configuration.X509PeerCertificateElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509PeerCertificateElement from);
    internal void ApplyConfiguration(PeerCredential cert);
}
public class System.ServiceModel.Configuration.X509RecipientCertificateClientElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("defaultCertificate")]
public X509DefaultServiceCertificateElement DefaultCertificate { get; }
    [ConfigurationPropertyAttribute("scopedCertificates")]
public X509ScopedServiceCertificateElementCollection ScopedCertificates { get; }
    [ConfigurationPropertyAttribute("authentication")]
public X509ServiceCertificateAuthenticationElement Authentication { get; }
    [ConfigurationPropertyAttribute("sslCertificateAuthentication")]
public X509ServiceCertificateAuthenticationElement SslCertificateAuthentication { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public X509DefaultServiceCertificateElement get_DefaultCertificate();
    public X509ScopedServiceCertificateElementCollection get_ScopedCertificates();
    public X509ServiceCertificateAuthenticationElement get_Authentication();
    public X509ServiceCertificateAuthenticationElement get_SslCertificateAuthentication();
    public void Copy(X509RecipientCertificateClientElement from);
    internal void ApplyConfiguration(X509CertificateRecipientClientCredential cert);
}
public class System.ServiceModel.Configuration.X509RecipientCertificateServiceElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509RecipientCertificateServiceElement from);
    internal void ApplyConfiguration(X509CertificateRecipientServiceCredential cert);
}
public class System.ServiceModel.Configuration.X509ScopedServiceCertificateElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("targetUri")]
public Uri TargetUri { get; public set; }
    [ConfigurationPropertyAttribute("findValue")]
[StringValidatorAttribute]
public string FindValue { get; public set; }
    [ConfigurationPropertyAttribute("storeLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation StoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("storeName")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreName")]
public StoreName StoreName { get; public set; }
    [ConfigurationPropertyAttribute("x509FindType")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509FindType")]
public X509FindType X509FindType { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Uri get_TargetUri();
    public void set_TargetUri(Uri value);
    public string get_FindValue();
    public void set_FindValue(string value);
    public StoreLocation get_StoreLocation();
    public void set_StoreLocation(StoreLocation value);
    public StoreName get_StoreName();
    public void set_StoreName(StoreName value);
    public X509FindType get_X509FindType();
    public void set_X509FindType(X509FindType value);
    public void Copy(X509ScopedServiceCertificateElement from);
    internal void ApplyConfiguration(X509CertificateRecipientClientCredential creds);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.X509ScopedServiceCertificateElement")]
public class System.ServiceModel.Configuration.X509ScopedServiceCertificateElementCollection : ServiceModelConfigurationElementCollection`1<X509ScopedServiceCertificateElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.ServiceModel.Configuration.X509ServiceCertificateAuthenticationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("customCertificateValidatorType")]
[StringValidatorAttribute]
public string CustomCertificateValidatorType { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidationMode")]
[ServiceModelEnumValidatorAttribute("System.ServiceModel.Security.X509CertificateValidationModeHelper")]
public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("revocationMode")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509RevocationMode")]
public X509RevocationMode RevocationMode { get; public set; }
    [ConfigurationPropertyAttribute("trustedStoreLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation TrustedStoreLocation { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_CustomCertificateValidatorType();
    public void set_CustomCertificateValidatorType(string value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public void Copy(X509ServiceCertificateAuthenticationElement from);
    internal void ApplyConfiguration(X509ServiceCertificateAuthentication cert);
}
public class System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement : ServiceModelConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("maxDepth")]
[IntegerValidatorAttribute]
public int MaxDepth { get; public set; }
    [ConfigurationPropertyAttribute("maxStringContentLength")]
[IntegerValidatorAttribute]
public int MaxStringContentLength { get; public set; }
    [ConfigurationPropertyAttribute("maxArrayLength")]
[IntegerValidatorAttribute]
public int MaxArrayLength { get; public set; }
    [ConfigurationPropertyAttribute("maxBytesPerRead")]
[IntegerValidatorAttribute]
public int MaxBytesPerRead { get; public set; }
    [ConfigurationPropertyAttribute("maxNameTableCharCount")]
[IntegerValidatorAttribute]
public int MaxNameTableCharCount { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    internal void ApplyConfiguration(XmlDictionaryReaderQuotas readerQuotas);
    internal void InitializeFrom(XmlDictionaryReaderQuotas readerQuotas);
}
public class System.ServiceModel.Configuration.XmlElementElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("xmlElement")]
public XmlElement XmlElement { get; public set; }
    public XmlElementElement(XmlElement element);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public void Copy(XmlElementElement source);
    [SecuritySafeCriticalAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    internal void ResetInternal(XmlElementElement element);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual void PostDeserialize();
    public XmlElement get_XmlElement();
    public void set_XmlElement(XmlElement value);
}
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.XmlElementElement")]
public class System.ServiceModel.Configuration.XmlElementElementCollection : ServiceModelConfigurationElementCollection`1<XmlElementElement> {
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
}
public class System.ServiceModel.Configuration.XPathMessageFilterElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("filter")]
public XPathMessageFilter Filter { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public XPathMessageFilter get_Filter();
    public void set_Filter(XPathMessageFilter value);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.ServiceModel.Configuration.XPathMessageFilterElement")]
public class System.ServiceModel.Configuration.XPathMessageFilterElementCollection : ServiceModelConfigurationElementCollection`1<XPathMessageFilterElement> {
    protected ConfigurationPropertyCollection Properties { get; }
    public XPathMessageFilterElement Item { get; public set; }
    public virtual bool ContainsKey(object key);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual XPathMessageFilterElement get_Item(object key);
    public virtual void set_Item(object key, XPathMessageFilterElement value);
}
public class System.ServiceModel.Configuration.XPathMessageFilterElementComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    internal static string ParseXPathString(XPathMessageFilter filter);
    internal static string ParseXPathString(XPathMessageFilter filter, bool throwOnFailure);
}
internal class System.ServiceModel.ConfigurationEndpointTrait`1 : EndpointTrait`1<TChannel> {
    public ConfigurationEndpointTrait`1(string endpointConfigurationName, EndpointAddress remoteAddress, InstanceContext callbackInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ChannelFactory`1<TChannel> CreateChannelFactory();
}
internal class System.ServiceModel.CoordinationExternal10Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CreateCoordinationContextAction;
    public XmlDictionaryString CreateCoordinationContextResponseAction;
    public XmlDictionaryString RegisterAction;
    public XmlDictionaryString RegisterResponseAction;
    public XmlDictionaryString FaultAction;
    public CoordinationExternal10Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.CoordinationExternal10Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
}
internal class System.ServiceModel.CoordinationExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CreateCoordinationContextAction;
    public XmlDictionaryString CreateCoordinationContextResponseAction;
    public XmlDictionaryString RegisterAction;
    public XmlDictionaryString RegisterResponseAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString CannotCreateContext;
    public XmlDictionaryString CannotRegisterParticipant;
    public CoordinationExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.CoordinationExternal11Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
    public static string CannotCreateContext;
    public static string CannotRegisterParticipant;
}
internal class System.ServiceModel.CoordinationExternalDictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString CreateCoordinationContext;
    public XmlDictionaryString CreateCoordinationContextResponse;
    public XmlDictionaryString CoordinationContext;
    public XmlDictionaryString CurrentContext;
    public XmlDictionaryString CoordinationType;
    public XmlDictionaryString RegistrationService;
    public XmlDictionaryString Register;
    public XmlDictionaryString RegisterResponse;
    public XmlDictionaryString Protocol;
    public XmlDictionaryString CoordinatorProtocolService;
    public XmlDictionaryString ParticipantProtocolService;
    public XmlDictionaryString Expires;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString ActivationCoordinatorPortType;
    public XmlDictionaryString RegistrationCoordinatorPortType;
    public XmlDictionaryString InvalidState;
    public XmlDictionaryString InvalidProtocol;
    public XmlDictionaryString InvalidParameters;
    public XmlDictionaryString NoActivity;
    public XmlDictionaryString ContextRefused;
    public XmlDictionaryString AlreadyRegistered;
    public CoordinationExternalDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.CoordinationExternalStrings : object {
    public static string Prefix;
    public static string CreateCoordinationContext;
    public static string CreateCoordinationContextResponse;
    public static string CoordinationContext;
    public static string CurrentContext;
    public static string CoordinationType;
    public static string RegistrationService;
    public static string Register;
    public static string RegisterResponse;
    public static string Protocol;
    public static string CoordinatorProtocolService;
    public static string ParticipantProtocolService;
    public static string Expires;
    public static string Identifier;
    public static string ActivationCoordinatorPortType;
    public static string RegistrationCoordinatorPortType;
    public static string InvalidState;
    public static string InvalidProtocol;
    public static string InvalidParameters;
    public static string NoActivity;
    public static string ContextRefused;
    public static string AlreadyRegistered;
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.DataContractFormatAttribute : Attribute {
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
}
public enum System.ServiceModel.DeadLetterQueue : Enum {
    public int value__;
    public static DeadLetterQueue None;
    public static DeadLetterQueue System;
    public static DeadLetterQueue Custom;
}
internal static class System.ServiceModel.DeadLetterQueueHelper : object {
    public static bool IsDefined(DeadLetterQueue mode);
}
[AttributeUsageAttribute("1028")]
public class System.ServiceModel.DeliveryRequirementsAttribute : Attribute {
    public Type TargetContract { get; public set; }
    public QueuedDeliveryRequirementsMode QueuedDeliveryRequirements { get; public set; }
    public bool RequireOrderedDelivery { get; public set; }
    public sealed virtual Type get_TargetContract();
    public void set_TargetContract(Type value);
    public QueuedDeliveryRequirementsMode get_QueuedDeliveryRequirements();
    public void set_QueuedDeliveryRequirements(QueuedDeliveryRequirementsMode value);
    public bool get_RequireOrderedDelivery();
    public void set_RequireOrderedDelivery(bool value);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
}
public class System.ServiceModel.Description.CallbackDebugBehavior : object {
    public bool IncludeExceptionDetailInFaults { get; public set; }
    public CallbackDebugBehavior(bool includeExceptionDetailInFaults);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
internal class System.ServiceModel.Description.CallbackTimeoutsBehavior : object {
    public TimeSpan TransactionTimeout { get; public set; }
    public TimeSpan get_TransactionTimeout();
    public void set_TransactionTimeout(TimeSpan value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
internal class System.ServiceModel.Description.ClientClassGenerator : object {
    internal ClientClassGenerator(bool tryAddHelperMethod);
    internal ClientClassGenerator(bool tryAddHelperMethod, bool generateEventAsyncMethods);
    private static ClientClassGenerator();
    private sealed virtual override void System.ServiceModel.Description.IServiceContractGenerationExtension.GenerateContract(ServiceContractGenerationContext context);
    internal static CodeAttributeDeclaration CreateEditorBrowsableAttribute(EditorBrowsableState editorBrowsableState);
    internal static bool DoesMemberNameExist(string name, object typeDeclarationObject);
    internal static bool DoesTypeNameExists(string name, object codeTypeDeclarationCollectionObject);
    internal static bool DoesTypeAndMemberNameExist(string name, object nameCollection);
    internal static bool DoesMethodNameExist(string name, object operationsObject);
    internal static bool DoesParameterNameExist(string name, object methodObject);
    internal static string GetClientClassName(string interfaceName);
}
public class System.ServiceModel.Description.ClientCredentials : SecurityCredentialsManager {
    internal static bool SupportInteractiveDefault;
    internal GetInfoCardTokenCallback GetInfoCardTokenCallback { get; }
    public IssuedTokenClientCredential IssuedToken { get; }
    public UserNamePasswordClientCredential UserName { get; }
    public X509CertificateInitiatorClientCredential ClientCertificate { get; }
    public X509CertificateRecipientClientCredential ServiceCertificate { get; }
    public WindowsClientCredential Windows { get; }
    public HttpDigestClientCredential HttpDigest { get; }
    public PeerCredential Peer { get; }
    public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager { get; public set; }
    public bool UseIdentityConfiguration { get; public set; }
    public bool SupportInteractive { get; public set; }
    protected ClientCredentials(ClientCredentials other);
    internal GetInfoCardTokenCallback get_GetInfoCardTokenCallback();
    public IssuedTokenClientCredential get_IssuedToken();
    public UserNamePasswordClientCredential get_UserName();
    public X509CertificateInitiatorClientCredential get_ClientCertificate();
    public X509CertificateRecipientClientCredential get_ServiceCertificate();
    public WindowsClientCredential get_Windows();
    public HttpDigestClientCredential get_HttpDigest();
    public PeerCredential get_Peer();
    public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager();
    public void set_SecurityTokenHandlerCollectionManager(SecurityTokenHandlerCollectionManager value);
    public bool get_UseIdentityConfiguration();
    public void set_UseIdentityConfiguration(bool value);
    public bool get_SupportInteractive();
    public void set_SupportInteractive(bool value);
    internal static ClientCredentials CreateDefaultCredentials();
    public virtual SecurityTokenManager CreateSecurityTokenManager();
    protected virtual ClientCredentials CloneCore();
    public ClientCredentials Clone();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    public virtual void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    internal void MakeReadOnly();
    protected internal virtual SecurityToken GetInfoCardSecurityToken(bool requiresInfoCard, CardSpacePolicyElement[] chain, SecurityTokenSerializer tokenSerializer);
}
public class System.ServiceModel.Description.ClientViaBehavior : object {
    public Uri Uri { get; public set; }
    public ClientViaBehavior(Uri uri);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
internal class System.ServiceModel.Description.ConfigLoader : object {
    public ConfigLoader(ContextInformation configurationContext);
    public ConfigLoader(IContractResolver contractResolver);
    private static ConfigLoader();
    [SecuritySafeCriticalAttribute]
internal static EndpointIdentity LoadIdentity(IdentityElement element);
    [SecuritySafeCriticalAttribute]
internal void LoadChannelBehaviors(ServiceEndpoint serviceEndpoint, string configurationName);
    [SecuritySafeCriticalAttribute]
internal void LoadCommonClientBehaviors(ServiceEndpoint serviceEndpoint);
    [SecuritySafeCriticalAttribute]
internal static void LoadChannelBehaviors(string behaviorName, ContextInformation context, KeyedByTypeCollection`1<IEndpointBehavior> channelBehaviors);
    [SecuritySafeCriticalAttribute]
internal static Collection`1<IWsdlImportExtension> LoadWsdlImporters(WsdlImporterElementCollection wsdlImporterElements, ContextInformation context);
    [SecuritySafeCriticalAttribute]
internal static Collection`1<IPolicyImportExtension> LoadPolicyImporters(PolicyImporterElementCollection policyImporterElements, ContextInformation context);
    [SecuritySafeCriticalAttribute]
internal static EndpointAddress LoadEndpointAddress(EndpointAddressElementBase element);
    [SecuritySafeCriticalAttribute]
public void LoadHostConfig(ServiceElement serviceElement, ServiceHostBase host, Action`1<Uri> addBaseAddress);
    [SecuritySafeCriticalAttribute]
public void LoadServiceDescription(ServiceHostBase host, ServiceDescription description, ServiceElement serviceElement, Action`1<Uri> addBaseAddress, bool skipHost);
    [SecuritySafeCriticalAttribute]
public static void LoadDefaultEndpointBehaviors(ServiceEndpoint endpoint);
    [SecuritySafeCriticalAttribute]
internal static ServiceEndpoint LookupEndpoint(string configurationName, EndpointAddress address, ContractDescription contract);
    [SecuritySafeCriticalAttribute]
internal static ServiceEndpoint LookupEndpoint(string configurationName, EndpointAddress address, ContractDescription contract, ContextInformation configurationContext);
    internal static ServiceEndpoint LookupEndpoint(ChannelEndpointElement channelEndpointElement, ContextInformation context);
    [SecuritySafeCriticalAttribute]
internal ServiceEndpoint LookupEndpoint(ServiceEndpointElement serviceEndpointElement, ContextInformation context, ServiceHostBase host, ServiceDescription description, bool omitSettingEndpointAddress);
    internal static void ConfigureEndpointAddress(ServiceEndpointElement serviceEndpointElement, ServiceHostBase host, ServiceEndpoint endpoint);
    internal static void ConfigureEndpointListenUri(ServiceEndpointElement serviceEndpointElement, ServiceHostBase host, ServiceEndpoint endpoint);
    internal static Binding LookupBinding(string bindingSectionName, string configurationName);
    internal static ComContractElement LookupComContract(Guid contractIID);
    [SecuritySafeCriticalAttribute]
internal static ProtocolMappingItem LookupProtocolMapping(string scheme);
    [SecuritySafeCriticalAttribute]
internal static Binding LookupBinding(string bindingSectionName, string configurationName, ContextInformation context);
    internal ContractDescription LookupContract(string contractName, string serviceName);
    internal ContractDescription LookupContractForStandardEndpoint(string contractName, string serviceName);
    [SecurityCriticalAttribute]
public ServiceElement LookupService(string serviceConfigurationName);
    public ServiceElement LookupService(string serviceConfigurationName, ServicesSection servicesSection);
}
internal class System.ServiceModel.Description.ConfigWriter : object {
    internal ConfigWriter(Configuration configuration);
    internal ChannelEndpointElement WriteChannelDescription(ServiceEndpoint endpoint, string typeName);
    internal void WriteBinding(Binding binding, String& bindingSectionName, String& configurationName);
}
[DebuggerDisplayAttribute("Name={name}, Namespace={ns}, ContractType={contractType}")]
public class System.ServiceModel.Description.ContractDescription : object {
    internal string CodeName { get; }
    [DefaultValueAttribute("")]
public string ConfigurationName { get; public set; }
    public Type ContractType { get; public set; }
    public Type CallbackContractType { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public OperationDescriptionCollection Operations { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SessionMode SessionMode { get; public set; }
    public KeyedCollection`2<Type, IContractBehavior> ContractBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IContractBehavior> Behaviors { get; }
    public ContractDescription(string name);
    public ContractDescription(string name, string ns);
    internal string get_CodeName();
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public Type get_ContractType();
    public void set_ContractType(Type value);
    public Type get_CallbackContractType();
    public void set_CallbackContractType(Type value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public OperationDescriptionCollection get_Operations();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    public KeyedCollection`2<Type, IContractBehavior> get_ContractBehaviors();
    public KeyedByTypeCollection`1<IContractBehavior> get_Behaviors();
    public static ContractDescription GetContract(Type contractType);
    public static ContractDescription GetContract(Type contractType, Type serviceType);
    public static ContractDescription GetContract(Type contractType, object serviceImplementation);
    public Collection`1<ContractDescription> GetInheritedContracts();
    internal void EnsureInvariants();
    internal bool IsDuplex();
}
internal class System.ServiceModel.Description.DataContractSerializerMessageContractExporter : MessageContractExporter {
    internal DataContractSerializerMessageContractExporter(WsdlExporter exporter, WsdlContractConversionContext context, OperationDescription operation, IOperationBehavior extension);
    protected virtual void Compile();
    protected virtual bool IsRpcStyle();
    protected virtual bool IsEncoded();
    protected virtual object OnExportMessageContract();
    protected virtual void ExportHeaders(int messageIndex, object state);
    internal static bool IsTypeNullable(Type type);
    protected virtual void ExportBody(int messageIndex, object state);
    protected virtual void ExportKnownTypes();
    protected virtual object GetExtensionData();
}
public class System.ServiceModel.Description.DataContractSerializerMessageContractImporter : object {
    internal static string GenericMessageSchemaTypeName;
    internal static string GenericMessageSchemaTypeNamespace;
    internal static XmlQualifiedName GenericMessageTypeName;
    internal static XmlQualifiedName StreamBodyTypeName;
    public bool Enabled { get; public set; }
    private static DataContractSerializerMessageContractImporter();
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext endpointContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportContract(WsdlImporter importer, WsdlContractConversionContext contractContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    public bool get_Enabled();
    public void set_Enabled(bool value);
}
public class System.ServiceModel.Description.DataContractSerializerOperationBehavior : object {
    internal bool ignoreExtensionDataObject;
    internal int maxItemsInObjectGraph;
    public DataContractFormatAttribute DataContractFormatAttribute { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public int MaxItemsInObjectGraph { get; public set; }
    internal bool MaxItemsInObjectGraphSetExplicit { get; internal set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    internal bool IgnoreExtensionDataObjectSetExplicit { get; internal set; }
    public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public DataContractResolver DataContractResolver { get; public set; }
    public DataContractSerializerOperationBehavior(OperationDescription operation);
    public DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute);
    internal DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute, bool builtInOperationBehavior);
    public DataContractFormatAttribute get_DataContractFormatAttribute();
    internal bool get_IsBuiltInOperationBehavior();
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    internal bool get_MaxItemsInObjectGraphSetExplicit();
    internal void set_MaxItemsInObjectGraphSetExplicit(bool value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    internal bool get_IgnoreExtensionDataObjectSetExplicit();
    internal void set_IgnoreExtensionDataObjectSetExplicit(bool value);
    public IDataContractSurrogate get_DataContractSurrogate();
    public void set_DataContractSurrogate(IDataContractSurrogate value);
    public DataContractResolver get_DataContractResolver();
    public void set_DataContractResolver(DataContractResolver value);
    public virtual XmlObjectSerializer CreateSerializer(Type type, string name, string ns, IList`1<Type> knownTypes);
    public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList`1<Type> knownTypes);
    internal object GetFormatter(OperationDescription operation, Boolean& formatRequest, Boolean& formatReply, bool isProxy);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext contractContext);
}
internal class System.ServiceModel.Description.DataContractSerializerOperationGenerator : object {
    internal OperationGenerator OperationGenerator { get; }
    internal Dictionary`2<OperationDescription, DataContractFormatAttribute> OperationAttributes { get; }
    internal Dictionary`2<MessagePartDescription, ICollection`1<CodeTypeReference>> KnownTypes { get; }
    public DataContractSerializerOperationGenerator(CodeCompileUnit codeCompileUnit);
    internal void Add(MessagePartDescription part, CodeTypeReference typeReference, ICollection`1<CodeTypeReference> knownTypeReferences, bool isNonNillableReferenceType);
    internal OperationGenerator get_OperationGenerator();
    internal Dictionary`2<OperationDescription, DataContractFormatAttribute> get_OperationAttributes();
    internal Dictionary`2<MessagePartDescription, ICollection`1<CodeTypeReference>> get_KnownTypes();
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationContractGenerationExtension.GenerateOperation(OperationContractGenerationContext context);
    internal static void UpdateTargetCompileUnit(OperationContractGenerationContext context, CodeCompileUnit codeCompileUnit);
}
internal class System.ServiceModel.Description.DispatcherBuilder : object {
    internal static ClientRuntime BuildProxyBehavior(ServiceEndpoint serviceEndpoint, BindingParameterCollection& parameters);
    internal static Type MaybeCreateListener(bool actuallyCreate, Type[] supportedChannels, Binding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode, ServiceThrottle throttle, IChannelListener& result);
    internal static BindingParameterCollection GetBindingParameters(ServiceHostBase serviceHost, Collection`1<ServiceEndpoint> endpoints);
    internal static ListenUriInfo GetListenUriInfoForEndpoint(ServiceHostBase host, ServiceEndpoint endpoint);
    public void InitializeServiceHost(ServiceDescription description, ServiceHostBase serviceHost);
    internal static Type[] GetSupportedChannelTypes(ContractDescription contractDescription);
}
public class System.ServiceModel.Description.DispatcherSynchronizationBehavior : object {
    public bool AsynchronousSendEnabled { get; public set; }
    public int MaxPendingReceives { get; public set; }
    public DispatcherSynchronizationBehavior(bool asynchronousSendEnabled, int maxPendingReceives);
    [CompilerGeneratedAttribute]
public bool get_AsynchronousSendEnabled();
    [CompilerGeneratedAttribute]
public void set_AsynchronousSendEnabled(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxPendingReceives();
    [CompilerGeneratedAttribute]
public void set_MaxPendingReceives(int value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
[DebuggerDisplayAttribute("Name={name}, Action={action}, DetailType={detailType}")]
public class System.ServiceModel.Description.FaultDescription : object {
    public string Action { get; internal set; }
    public Type DetailType { get; public set; }
    internal CodeTypeReference DetailTypeReference { get; internal set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    internal XmlName ElementName { get; internal set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public FaultDescription(string action);
    public string get_Action();
    internal void set_Action(string value);
    public Type get_DetailType();
    public void set_DetailType(Type value);
    internal CodeTypeReference get_DetailTypeReference();
    internal void set_DetailTypeReference(CodeTypeReference value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    internal XmlName get_ElementName();
    internal void set_ElementName(XmlName value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    internal void ResetProtectionLevel();
    internal void SetNameAndElement(XmlName name);
    internal void SetNameOnly(XmlName name);
}
public class System.ServiceModel.Description.FaultDescriptionCollection : Collection`1<FaultDescription> {
    public FaultDescription Find(string action);
    public Collection`1<FaultDescription> FindAll(string action);
}
[MessageContractAttribute]
internal class System.ServiceModel.Description.GetResponse : object {
    [MessageBodyMemberAttribute]
internal MetadataSet Metadata { get; internal set; }
    internal GetResponse(MetadataSet metadataSet);
    internal MetadataSet get_Metadata();
    internal void set_Metadata(MetadataSet value);
}
public interface System.ServiceModel.Description.IContractBehavior {
    public abstract virtual void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
    public abstract virtual void ApplyDispatchBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, DispatchRuntime dispatchRuntime);
    public abstract virtual void ApplyClientBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    public abstract virtual void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
}
public interface System.ServiceModel.Description.IContractBehaviorAttribute {
    public Type TargetContract { get; }
    public abstract virtual Type get_TargetContract();
}
internal interface System.ServiceModel.Description.IContractResolver {
    public abstract virtual ContractDescription ResolveContract(string contractName);
}
public interface System.ServiceModel.Description.IEndpointBehavior {
    public abstract virtual void Validate(ServiceEndpoint endpoint);
    public abstract virtual void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    public abstract virtual void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
    public abstract virtual void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Description.IMetadataExchange {
    [OperationContractAttribute]
public abstract virtual Message Get(Message request);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginGet(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndGet(IAsyncResult result);
}
public interface System.ServiceModel.Description.IOperationBehavior {
    public abstract virtual void Validate(OperationDescription operationDescription);
    public abstract virtual void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    public abstract virtual void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    public abstract virtual void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
}
public interface System.ServiceModel.Description.IOperationContractGenerationExtension {
    public abstract virtual void GenerateOperation(OperationContractGenerationContext context);
}
public interface System.ServiceModel.Description.IPolicyExportExtension {
    public abstract virtual void ExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
public interface System.ServiceModel.Description.IPolicyImportExtension {
    public abstract virtual void ImportPolicy(MetadataImporter importer, PolicyConversionContext context);
}
public interface System.ServiceModel.Description.IServiceBehavior {
    public abstract virtual void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    public abstract virtual void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    public abstract virtual void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
}
public interface System.ServiceModel.Description.IServiceContractGenerationExtension {
    public abstract virtual void GenerateContract(ServiceContractGenerationContext context);
}
internal interface System.ServiceModel.Description.IWrappedBodyTypeGenerator {
    public abstract virtual void ValidateForParameterMode(OperationDescription operationDescription);
    public abstract virtual void AddMemberAttributes(XmlName messageName, MessagePartDescription part, CodeAttributeDeclarationCollection attributesImported, CodeAttributeDeclarationCollection typeAttributes, CodeAttributeDeclarationCollection fieldAttributes);
    public abstract virtual void AddTypeAttributes(string messageName, string typeNS, CodeAttributeDeclarationCollection typeAttributes, bool isEncoded);
}
public interface System.ServiceModel.Description.IWsdlExportExtension {
    public abstract virtual void ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    public abstract virtual void ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext context);
}
public interface System.ServiceModel.Description.IWsdlImportExtension {
    public abstract virtual void BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
    public abstract virtual void ImportContract(WsdlImporter importer, WsdlContractConversionContext context);
    public abstract virtual void ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext context);
}
public enum System.ServiceModel.Description.ListenUriMode : Enum {
    public int value__;
    public static ListenUriMode Explicit;
    public static ListenUriMode Unique;
}
internal static class System.ServiceModel.Description.ListenUriModeHelper : object {
    public static bool IsDefined(ListenUriMode mode);
}
public class System.ServiceModel.Description.MessageBodyDescription : object {
    public MessagePartDescriptionCollection Parts { get; }
    [DefaultValueAttribute("")]
public MessagePartDescription ReturnValue { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperName { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperNamespace { get; public set; }
    internal MessageBodyDescription(MessageBodyDescription other);
    internal MessageBodyDescription Clone();
    public MessagePartDescriptionCollection get_Parts();
    public MessagePartDescription get_ReturnValue();
    public void set_ReturnValue(MessagePartDescription value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    public string get_WrapperNamespace();
    public void set_WrapperNamespace(string value);
}
internal abstract class System.ServiceModel.Description.MessageContractExporter : object {
    protected WsdlContractConversionContext contractContext;
    protected WsdlExporter exporter;
    protected OperationDescription operation;
    protected IOperationBehavior extension;
    protected MessageExportContext ExportedMessages { get; }
    protected XsdDataContractExporter DataContractExporter { get; }
    protected XmlSchemaSet SchemaSet { get; }
    protected MessageContractExporter(WsdlExporter exporter, WsdlContractConversionContext context, OperationDescription operation, IOperationBehavior extension);
    private static MessageContractExporter();
    internal static void ExportMessageBinding(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext, Type messageContractExporterType, OperationDescription operation);
    protected abstract virtual object OnExportMessageContract();
    protected abstract virtual void ExportHeaders(int messageIndex, object state);
    protected abstract virtual void ExportBody(int messageIndex, object state);
    protected abstract virtual void ExportKnownTypes();
    protected abstract virtual bool IsRpcStyle();
    protected abstract virtual bool IsEncoded();
    protected abstract virtual object GetExtensionData();
    protected MessageExportContext get_ExportedMessages();
    internal void ExportMessageContract();
    protected virtual void ExportFaults(object state);
    protected bool IsOperationInherited();
    protected void ExportStreamBody(Message message, string wrapperName, string wrapperNs, string partName, string partNs, bool isRpc, bool skipSchemaExport);
    protected XsdDataContractExporter get_DataContractExporter();
    protected XmlQualifiedName ExportType(Type type, string partName, string operationName, XmlSchemaType& xsdType);
    protected XmlSchemaSet get_SchemaSet();
    protected static MessagePart AddMessagePart(Message message, string partName, XmlQualifiedName elementName, XmlQualifiedName typeName);
    protected static bool IsNullOrEmpty(XmlQualifiedName qname);
    protected void ExportGlobalElement(string elementName, string elementNs, bool isNillable, XmlQualifiedName typeName, XmlSchemaType xsdType, XmlSchemaSet schemaSet);
    protected XmlSchemaSequence ExportWrappedPart(Message message, string elementName, string elementNs, XmlSchemaSet schemaSet, bool skipSchemaExport);
    protected bool CreateMessage(MessageDescription message, int messageIndex, Message& wsdlMessage);
    protected bool CreateHeaderMessage(MessageDescription message, Message& wsdlMessage);
    protected string GetFaultMessageName(string faultName);
    protected void ExportMessagePart(Message message, MessagePartDescription part, XmlQualifiedName typeName, XmlSchemaType xsdType, bool isOptional, bool isNillable, bool skipSchemaExport, bool generateElement, string wrapperNs, XmlSchemaSequence wrapperSequence, XmlSchemaSet schemaSet);
    protected void AddParameterOrder(MessageDescription message);
    protected virtual void Compile();
}
internal class System.ServiceModel.Description.MessageContractImporter : object {
    private static MessageContractImporter();
    internal static void ImportMessageBinding(WsdlImporter importer, WsdlEndpointConversionContext endpointContext, Type schemaImporterType);
    internal static void ImportMessageContract(WsdlImporter importer, WsdlContractConversionContext contractContext, SchemaImporter schemaImporter);
    internal void AddWarning(string message);
}
internal enum System.ServiceModel.Description.MessageContractType : Enum {
    public int value__;
    public static MessageContractType None;
    public static MessageContractType WrappedMessageContract;
    public static MessageContractType BareMessageContract;
}
[DebuggerDisplayAttribute("Action={action}, Direction={direction}, MessageType={messageType}")]
public class System.ServiceModel.Description.MessageDescription : object {
    public string Action { get; internal set; }
    public MessageBodyDescription Body { get; }
    public MessageDirection Direction { get; }
    public MessageHeaderDescriptionCollection Headers { get; }
    public MessagePropertyDescriptionCollection Properties { get; }
    internal MessageDescriptionItems Items { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    internal static Type TypeOfUntypedMessage { get; }
    internal XmlName MessageName { get; internal set; }
    [DefaultValueAttribute("")]
public Type MessageType { get; public set; }
    internal bool IsTypedMessage { get; }
    internal bool IsUntypedMessage { get; }
    internal bool IsVoid { get; }
    internal XmlQualifiedName XsdTypeName { get; internal set; }
    public MessageDescription(string action, MessageDirection direction);
    internal MessageDescription(string action, MessageDirection direction, MessageDescriptionItems items);
    internal MessageDescription(MessageDescription other);
    internal MessageDescription Clone();
    public string get_Action();
    internal void set_Action(string value);
    public MessageBodyDescription get_Body();
    public MessageDirection get_Direction();
    public MessageHeaderDescriptionCollection get_Headers();
    public MessagePropertyDescriptionCollection get_Properties();
    internal MessageDescriptionItems get_Items();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    internal static Type get_TypeOfUntypedMessage();
    internal XmlName get_MessageName();
    internal void set_MessageName(XmlName value);
    public Type get_MessageType();
    public void set_MessageType(Type value);
    internal bool get_IsTypedMessage();
    internal bool get_IsUntypedMessage();
    internal bool get_IsVoid();
    internal XmlQualifiedName get_XsdTypeName();
    internal void set_XsdTypeName(XmlQualifiedName value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessageDescriptionCollection : Collection`1<MessageDescription> {
    public MessageDescription Find(string action);
    public Collection`1<MessageDescription> FindAll(string action);
}
internal class System.ServiceModel.Description.MessageDescriptionItems : object {
    internal MessageBodyDescription Body { get; internal set; }
    internal MessageHeaderDescriptionCollection Headers { get; }
    internal MessagePropertyDescriptionCollection Properties { get; }
    internal MessageBodyDescription get_Body();
    internal void set_Body(MessageBodyDescription value);
    internal MessageHeaderDescriptionCollection get_Headers();
    internal MessagePropertyDescriptionCollection get_Properties();
}
public enum System.ServiceModel.Description.MessageDirection : Enum {
    public int value__;
    public static MessageDirection Input;
    public static MessageDirection Output;
}
internal static class System.ServiceModel.Description.MessageDirectionHelper : object {
    internal static bool IsDefined(MessageDirection value);
    internal static MessageDirection Opposite(MessageDirection d);
}
public class System.ServiceModel.Description.MessageHeaderDescription : MessagePartDescription {
    [DefaultValueAttribute("")]
public string Actor { get; public set; }
    [DefaultValueAttribute("False")]
public bool MustUnderstand { get; public set; }
    [DefaultValueAttribute("False")]
public bool Relay { get; public set; }
    [DefaultValueAttribute("False")]
public bool TypedHeader { get; public set; }
    internal bool IsUnknownHeaderCollection { get; internal set; }
    public MessageHeaderDescription(string name, string ns);
    internal MessageHeaderDescription(MessageHeaderDescription other);
    internal virtual MessagePartDescription Clone();
    public string get_Actor();
    public void set_Actor(string value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public bool get_TypedHeader();
    public void set_TypedHeader(bool value);
    internal bool get_IsUnknownHeaderCollection();
    internal void set_IsUnknownHeaderCollection(bool value);
}
public class System.ServiceModel.Description.MessageHeaderDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessageHeaderDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessageHeaderDescription item);
}
[DebuggerDisplayAttribute("Name={name}, Namespace={ns}, Type={Type}, Index={index}}")]
public class System.ServiceModel.Description.MessagePartDescription : object {
    internal string BaseType { get; internal set; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type Type { get; public set; }
    public int Index { get; public set; }
    [DefaultValueAttribute("False")]
public bool Multiple { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public MemberInfo MemberInfo { get; public set; }
    internal ICustomAttributeProvider AdditionalAttributesProvider { get; internal set; }
    internal string UniquePartName { get; internal set; }
    internal int SerializationPosition { get; internal set; }
    public MessagePartDescription(string name, string ns);
    internal MessagePartDescription(MessagePartDescription other);
    internal virtual MessagePartDescription Clone();
    internal string get_BaseType();
    internal void set_BaseType(string value);
    internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    public string get_Namespace();
    public Type get_Type();
    public void set_Type(Type value);
    public int get_Index();
    public void set_Index(int value);
    public bool get_Multiple();
    public void set_Multiple(bool value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public MemberInfo get_MemberInfo();
    public void set_MemberInfo(MemberInfo value);
    internal ICustomAttributeProvider get_AdditionalAttributesProvider();
    internal void set_AdditionalAttributesProvider(ICustomAttributeProvider value);
    internal string get_UniquePartName();
    internal void set_UniquePartName(string value);
    internal int get_SerializationPosition();
    internal void set_SerializationPosition(int value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessagePartDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessagePartDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessagePartDescription item);
}
public class System.ServiceModel.Description.MessagePropertyDescription : MessagePartDescription {
    public MessagePropertyDescription(string name);
    internal MessagePropertyDescription(MessagePropertyDescription other);
    internal virtual MessagePartDescription Clone();
}
public class System.ServiceModel.Description.MessagePropertyDescriptionCollection : KeyedCollection`2<string, MessagePropertyDescription> {
    protected virtual string GetKeyForItem(MessagePropertyDescription item);
}
public class System.ServiceModel.Description.MetadataConversionError : object {
    public string Message { get; }
    public bool IsWarning { get; }
    public MetadataConversionError(string message);
    public MetadataConversionError(string message, bool isWarning);
    public string get_Message();
    public bool get_IsWarning();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class System.ServiceModel.Description.MetadataExchangeBindings : object {
    internal static Binding Http { get; }
    internal static Binding HttpGet { get; }
    internal static Binding Https { get; }
    internal static Binding HttpsGet { get; }
    internal static Binding Tcp { get; }
    internal static Binding NamedPipe { get; }
    internal static Binding get_Http();
    internal static Binding get_HttpGet();
    internal static Binding get_Https();
    internal static Binding get_HttpsGet();
    internal static Binding get_Tcp();
    internal static Binding get_NamedPipe();
    public static Binding CreateMexHttpBinding();
    public static Binding CreateMexHttpsBinding();
    public static Binding CreateMexTcpBinding();
    public static Binding CreateMexNamedPipeBinding();
    internal static Binding GetBindingForScheme(string scheme);
    internal static bool TryGetBindingForScheme(string scheme, Binding& binding);
    internal static bool IsSchemeSupported(string scheme);
}
public class System.ServiceModel.Description.MetadataExchangeClient : object {
    internal static string MetadataExchangeClientKey;
    public ClientCredentials SoapCredentials { get; public set; }
    public ICredentials HttpCredentials { get; public set; }
    public TimeSpan OperationTimeout { get; public set; }
    public int MaximumResolvedReferences { get; public set; }
    public bool ResolveMetadataReferences { get; public set; }
    internal object ThisLock { get; }
    internal long MaxMessageSize { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public MetadataExchangeClient(Uri address, MetadataExchangeClientMode mode);
    public MetadataExchangeClient(EndpointAddress address);
    public MetadataExchangeClient(string endpointConfigurationName);
    public MetadataExchangeClient(Binding mexBinding);
    public ClientCredentials get_SoapCredentials();
    public void set_SoapCredentials(ClientCredentials value);
    public ICredentials get_HttpCredentials();
    public void set_HttpCredentials(ICredentials value);
    public TimeSpan get_OperationTimeout();
    public void set_OperationTimeout(TimeSpan value);
    public int get_MaximumResolvedReferences();
    public void set_MaximumResolvedReferences(int value);
    public bool get_ResolveMetadataReferences();
    public void set_ResolveMetadataReferences(bool value);
    internal object get_ThisLock();
    internal long get_MaxMessageSize();
    internal void set_MaxMessageSize(long value);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    public IAsyncResult BeginGetMetadata(AsyncCallback callback, object asyncState);
    public IAsyncResult BeginGetMetadata(Uri address, MetadataExchangeClientMode mode, AsyncCallback callback, object asyncState);
    public IAsyncResult BeginGetMetadata(EndpointAddress address, AsyncCallback callback, object asyncState);
    public MetadataSet EndGetMetadata(IAsyncResult result);
    public Task`1<MetadataSet> GetMetadataAsync();
    public Task`1<MetadataSet> GetMetadataAsync(Uri address, MetadataExchangeClientMode mode);
    public Task`1<MetadataSet> GetMetadataAsync(EndpointAddress address);
    public Task`1<MetadataSet> GetMetadataAsync(EndpointAddress address, Uri via);
    public MetadataSet GetMetadata();
    public MetadataSet GetMetadata(Uri address, MetadataExchangeClientMode mode);
    public MetadataSet GetMetadata(EndpointAddress address);
    public MetadataSet GetMetadata(EndpointAddress address, Uri via);
    protected internal virtual ChannelFactory`1<IMetadataExchange> GetChannelFactory(EndpointAddress metadataAddress, string dialect, string identifier);
    protected internal virtual HttpWebRequest GetWebRequest(Uri location, string dialect, string identifier);
    internal static void TraceSendRequest(Uri address);
    internal static void TraceSendRequest(EndpointAddress address);
    internal static void TraceReceiveReply(string sourceUrl, Type metadataType);
}
public enum System.ServiceModel.Description.MetadataExchangeClientMode : Enum {
    public int value__;
    public static MetadataExchangeClientMode MetadataExchange;
    public static MetadataExchangeClientMode HttpGet;
}
internal static class System.ServiceModel.Description.MetadataExchangeClientModeHelper : object {
    public static bool IsDefined(MetadataExchangeClientMode x);
    public static void Validate(MetadataExchangeClientMode value);
}
public abstract class System.ServiceModel.Description.MetadataExporter : object {
    public PolicyVersion PolicyVersion { get; public set; }
    public Collection`1<MetadataConversionError> Errors { get; }
    public Dictionary`2<object, object> State { get; }
    public PolicyVersion get_PolicyVersion();
    public void set_PolicyVersion(PolicyVersion value);
    public Collection`1<MetadataConversionError> get_Errors();
    public Dictionary`2<object, object> get_State();
    public abstract virtual void ExportContract(ContractDescription contract);
    public abstract virtual void ExportEndpoint(ServiceEndpoint endpoint);
    public abstract virtual MetadataSet GetGeneratedMetadata();
    internal PolicyConversionContext ExportPolicy(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    protected internal PolicyConversionContext ExportPolicy(ServiceEndpoint endpoint);
}
public abstract class System.ServiceModel.Description.MetadataImporter : object {
    internal MetadataImporterQuotas Quotas;
    public KeyedByTypeCollection`1<IPolicyImportExtension> PolicyImportExtensions { get; }
    public Collection`1<MetadataConversionError> Errors { get; }
    public Dictionary`2<object, object> State { get; }
    public Dictionary`2<XmlQualifiedName, ContractDescription> KnownContracts { get; }
    internal MetadataImporter(IEnumerable`1<IPolicyImportExtension> policyImportExtensions);
    internal MetadataImporter(IEnumerable`1<IPolicyImportExtension> policyImportExtensions, MetadataImporterQuotas quotas);
    internal static IEnumerable`1<PolicyConversionContext> GetPolicyConversionContextEnumerator(ServiceEndpoint endpoint, PolicyAlternatives policyAlternatives);
    internal static IEnumerable`1<PolicyConversionContext> GetPolicyConversionContextEnumerator(ServiceEndpoint endpoint, PolicyAlternatives policyAlternatives, MetadataImporterQuotas quotas);
    public KeyedByTypeCollection`1<IPolicyImportExtension> get_PolicyImportExtensions();
    public Collection`1<MetadataConversionError> get_Errors();
    public Dictionary`2<object, object> get_State();
    public Dictionary`2<XmlQualifiedName, ContractDescription> get_KnownContracts();
    public abstract virtual Collection`1<ContractDescription> ImportAllContracts();
    public abstract virtual ServiceEndpointCollection ImportAllEndpoints();
    internal virtual XmlElement ResolvePolicyReference(string policyReference, XmlElement contextAssertion);
    internal BindingElementCollection ImportPolicy(ServiceEndpoint endpoint, Collection`1<Collection`1<XmlElement>> policyAlternatives);
    internal bool TryImportPolicy(PolicyConversionContext policyContext);
    [CompilerGeneratedAttribute]
internal void add_PolicyWarningOccured(PolicyWarningHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PolicyWarningOccured(PolicyWarningHandler value);
    internal IEnumerable`1<IEnumerable`1<XmlElement>> NormalizePolicy(IEnumerable`1<XmlElement> policyAssertions);
}
public class System.ServiceModel.Description.MetadataImporterQuotas : object {
    public static MetadataImporterQuotas Defaults { get; }
    public static MetadataImporterQuotas Max { get; }
    internal int MaxPolicyConversionContexts { get; internal set; }
    internal int MaxPolicyNodes { get; internal set; }
    internal int MaxPolicyAssertions { get; internal set; }
    internal int MaxYields { get; internal set; }
    public static MetadataImporterQuotas get_Defaults();
    public static MetadataImporterQuotas get_Max();
    internal int get_MaxPolicyConversionContexts();
    internal void set_MaxPolicyConversionContexts(int value);
    internal int get_MaxPolicyNodes();
    internal void set_MaxPolicyNodes(int value);
    internal int get_MaxPolicyAssertions();
    internal void set_MaxPolicyAssertions(int value);
    internal int get_MaxYields();
    internal void set_MaxYields(int value);
}
[XmlRootAttribute]
public class System.ServiceModel.Description.MetadataLocation : object {
    [XmlTextAttribute]
public string Location { get; public set; }
    public MetadataLocation(string location);
    public string get_Location();
    public void set_Location(string value);
}
[XmlRootAttribute]
public class System.ServiceModel.Description.MetadataReference : object {
    public EndpointAddress Address { get; public set; }
    public AddressingVersion AddressVersion { get; public set; }
    public MetadataReference(EndpointAddress address, AddressingVersion addressVersion);
    private static MetadataReference();
    public EndpointAddress get_Address();
    public void set_Address(EndpointAddress value);
    public AddressingVersion get_AddressVersion();
    public void set_AddressVersion(AddressingVersion value);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
public static class System.ServiceModel.Description.MetadataResolver : object {
    public static ServiceEndpointCollection Resolve(Type contract, EndpointAddress address);
    public static ServiceEndpointCollection Resolve(IEnumerable`1<ContractDescription> contracts, EndpointAddress address);
    public static ServiceEndpointCollection Resolve(IEnumerable`1<ContractDescription> contracts, EndpointAddress address, MetadataExchangeClient client);
    public static ServiceEndpointCollection Resolve(Type contract, Uri address, MetadataExchangeClientMode mode);
    public static ServiceEndpointCollection Resolve(IEnumerable`1<ContractDescription> contracts, Uri address, MetadataExchangeClientMode mode);
    public static ServiceEndpointCollection Resolve(IEnumerable`1<ContractDescription> contracts, Uri address, MetadataExchangeClientMode mode, MetadataExchangeClient client);
    public static IAsyncResult BeginResolve(Type contract, EndpointAddress address, AsyncCallback callback, object asyncState);
    public static IAsyncResult BeginResolve(IEnumerable`1<ContractDescription> contracts, EndpointAddress address, AsyncCallback callback, object asyncState);
    public static IAsyncResult BeginResolve(IEnumerable`1<ContractDescription> contracts, EndpointAddress address, MetadataExchangeClient client, AsyncCallback callback, object asyncState);
    public static IAsyncResult BeginResolve(Type contract, Uri address, MetadataExchangeClientMode mode, AsyncCallback callback, object asyncState);
    public static IAsyncResult BeginResolve(IEnumerable`1<ContractDescription> contracts, Uri address, MetadataExchangeClientMode mode, AsyncCallback callback, object asyncState);
    public static IAsyncResult BeginResolve(IEnumerable`1<ContractDescription> contracts, Uri address, MetadataExchangeClientMode mode, MetadataExchangeClient client, AsyncCallback callback, object asyncState);
    public static ServiceEndpointCollection EndResolve(IAsyncResult result);
}
[XmlRootAttribute]
public class System.ServiceModel.Description.MetadataSection : object {
    public static string ServiceDescriptionDialect { get; }
    public static string XmlSchemaDialect { get; }
    public static string PolicyDialect { get; }
    public static string MetadataExchangeDialect { get; }
    [XmlAnyAttributeAttribute]
public Collection`1<XmlAttribute> Attributes { get; }
    [XmlAttributeAttribute]
public string Dialect { get; public set; }
    [XmlAttributeAttribute]
public string Identifier { get; public set; }
    [XmlAnyElementAttribute]
[XmlElementAttribute("schema", "System.Xml.Schema.XmlSchema")]
[XmlElementAttribute("definitions", "System.Web.Services.Description.ServiceDescription")]
[XmlElementAttribute("MetadataReference", "System.ServiceModel.Description.MetadataReference")]
[XmlElementAttribute("Location", "System.ServiceModel.Description.MetadataLocation")]
[XmlElementAttribute("Metadata", "System.ServiceModel.Description.MetadataSet")]
public object Metadata { get; public set; }
    internal string SourceUrl { get; internal set; }
    public MetadataSection(string dialect, string identifier, object metadata);
    private static MetadataSection();
    public static string get_ServiceDescriptionDialect();
    public static string get_XmlSchemaDialect();
    public static string get_PolicyDialect();
    public static string get_MetadataExchangeDialect();
    public Collection`1<XmlAttribute> get_Attributes();
    public string get_Dialect();
    public void set_Dialect(string value);
    public string get_Identifier();
    public void set_Identifier(string value);
    public object get_Metadata();
    public void set_Metadata(object value);
    internal string get_SourceUrl();
    internal void set_SourceUrl(string value);
    public static MetadataSection CreateFromPolicy(XmlElement policy, string identifier);
    public static MetadataSection CreateFromSchema(XmlSchema schema);
    public static MetadataSection CreateFromServiceDescription(ServiceDescription serviceDescription);
    internal static bool IsPolicyElement(XmlElement policy);
}
[XmlRootAttribute("Metadata")]
public class System.ServiceModel.Description.MetadataSet : object {
    internal WriteFilter WriteFilter;
    [XmlElementAttribute("MetadataSection")]
public Collection`1<MetadataSection> MetadataSections { get; }
    [XmlAnyAttributeAttribute]
public Collection`1<XmlAttribute> Attributes { get; }
    public MetadataSet(IEnumerable`1<MetadataSection> sections);
    public Collection`1<MetadataSection> get_MetadataSections();
    public Collection`1<XmlAttribute> get_Attributes();
    public void WriteTo(XmlWriter writer);
    public static MetadataSet ReadFrom(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
internal class System.ServiceModel.Description.MetadataSetSerializer : XmlSerializer1 {
    public bool ProcessOuterElement { get; public set; }
    public bool get_ProcessOuterElement();
    public void set_ProcessOuterElement(bool value);
    public virtual bool CanDeserialize(XmlReader xmlReader);
    protected virtual void Serialize(object objectToSerialize, XmlSerializationWriter writer);
    protected virtual object Deserialize(XmlSerializationReader reader);
}
internal static class System.ServiceModel.Description.MetadataStrings : object {
}
public class System.ServiceModel.Description.MustUnderstandBehavior : object {
    public bool ValidateMustUnderstand { get; public set; }
    public MustUnderstandBehavior(bool validate);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
internal static class System.ServiceModel.Description.NamingHelper : object {
    internal static string DefaultNamespace;
    internal static string DefaultServiceName;
    internal static string MSNamespace;
    internal static string CombineUriStrings(string baseUri, string path);
    internal static string TypeName(Type t);
    internal static XmlQualifiedName GetContractName(Type contractType, string name, string ns);
    internal static XmlName GetOperationName(string logicalMethodName, string name);
    internal static string GetMessageAction(OperationDescription operation, bool isResponse);
    internal static string GetMessageAction(XmlQualifiedName contractName, string opname, string action, bool isResponse);
    internal static string GetUniqueName(string baseName, DoesNameExist doesNameExist, object nameCollection);
    internal static void CheckUriProperty(string ns, string propName);
    internal static void CheckUriParameter(string ns, string paramName);
    internal static string XmlName(string name);
    internal static string CodeName(string name);
    internal static bool IsValidNCName(string name);
}
internal class System.ServiceModel.Description.NetDataContractSerializerOperationBehavior : DataContractSerializerOperationBehavior {
    internal NetDataContractSerializerOperationBehavior(OperationDescription operation);
    public virtual XmlObjectSerializer CreateSerializer(Type type, string name, string ns, IList`1<Type> knownTypes);
    public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList`1<Type> knownTypes);
    internal static NetDataContractSerializerOperationBehavior ApplyTo(OperationDescription operation);
}
public class System.ServiceModel.Description.OperationContractGenerationContext : object {
    public ServiceContractGenerationContext Contract { get; }
    public CodeTypeDeclaration DeclaringType { get; }
    internal CodeTypeReference DeclaringTypeReference { get; internal set; }
    public CodeMemberMethod BeginMethod { get; }
    public CodeMemberMethod EndMethod { get; }
    public CodeMemberMethod TaskMethod { get; }
    public CodeMemberMethod SyncMethod { get; }
    public bool IsAsync { get; }
    public bool IsTask { get; }
    internal bool IsInherited { get; }
    public OperationDescription Operation { get; }
    public ServiceContractGenerator ServiceContractGenerator { get; }
    public OperationContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ServiceContractGenerationContext contract, OperationDescription operation, CodeTypeDeclaration declaringType, CodeMemberMethod syncMethod, CodeMemberMethod beginMethod, CodeMemberMethod endMethod, CodeMemberMethod taskMethod);
    public OperationContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ServiceContractGenerationContext contract, OperationDescription operation, CodeTypeDeclaration declaringType, CodeMemberMethod syncMethod, CodeMemberMethod beginMethod, CodeMemberMethod endMethod);
    public OperationContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ServiceContractGenerationContext contract, OperationDescription operation, CodeTypeDeclaration declaringType, CodeMemberMethod syncMethod, CodeMemberMethod taskMethod);
    public OperationContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ServiceContractGenerationContext contract, OperationDescription operation, CodeTypeDeclaration declaringType, CodeMemberMethod method);
    public ServiceContractGenerationContext get_Contract();
    public CodeTypeDeclaration get_DeclaringType();
    internal CodeTypeReference get_DeclaringTypeReference();
    internal void set_DeclaringTypeReference(CodeTypeReference value);
    public CodeMemberMethod get_BeginMethod();
    public CodeMemberMethod get_EndMethod();
    public CodeMemberMethod get_TaskMethod();
    public CodeMemberMethod get_SyncMethod();
    public bool get_IsAsync();
    public bool get_IsTask();
    internal bool get_IsInherited();
    public OperationDescription get_Operation();
    public ServiceContractGenerator get_ServiceContractGenerator();
}
[DebuggerDisplayAttribute("Name={name}, IsInitiating={isInitiating}, IsTerminating={isTerminating}")]
public class System.ServiceModel.Description.OperationDescription : object {
    internal static string SessionOpenedAction;
    public KeyedCollection`2<Type, IOperationBehavior> OperationBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IOperationBehavior> Behaviors { get; }
    public MethodInfo TaskMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public MethodInfo BeginMethod { get; public set; }
    internal MethodInfo OperationMethod { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    internal bool HasNoDisposableParameters { get; internal set; }
    public MethodInfo EndMethod { get; public set; }
    public ContractDescription DeclaringContract { get; public set; }
    public FaultDescriptionCollection Faults { get; }
    public bool IsOneWay { get; }
    [DefaultValueAttribute("False")]
public bool IsInitiating { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsTerminating { get; public set; }
    public Collection`1<Type> KnownTypes { get; }
    public MessageDescriptionCollection Messages { get; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    internal bool IsValidateRpcWrapperName { get; }
    internal bool IsInsideTransactedReceiveScope { get; internal set; }
    internal bool IsFirstReceiveOfTransactedReceiveScopeTree { get; internal set; }
    internal Type TaskTResult { get; internal set; }
    internal bool HasOutputParameters { get; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public OperationDescription(string name, ContractDescription declaringContract);
    internal OperationDescription(string name, ContractDescription declaringContract, bool validateRpcWrapperName);
    public KeyedCollection`2<Type, IOperationBehavior> get_OperationBehaviors();
    public KeyedByTypeCollection`1<IOperationBehavior> get_Behaviors();
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    public MethodInfo get_SyncMethod();
    public void set_SyncMethod(MethodInfo value);
    public MethodInfo get_BeginMethod();
    public void set_BeginMethod(MethodInfo value);
    internal MethodInfo get_OperationMethod();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    internal bool get_HasNoDisposableParameters();
    internal void set_HasNoDisposableParameters(bool value);
    public MethodInfo get_EndMethod();
    public void set_EndMethod(MethodInfo value);
    public ContractDescription get_DeclaringContract();
    public void set_DeclaringContract(ContractDescription value);
    public FaultDescriptionCollection get_Faults();
    public bool get_IsOneWay();
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    internal bool IsServerInitiated();
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    public Collection`1<Type> get_KnownTypes();
    public MessageDescriptionCollection get_Messages();
    internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    internal bool get_IsValidateRpcWrapperName();
    [CompilerGeneratedAttribute]
internal bool get_IsInsideTransactedReceiveScope();
    [CompilerGeneratedAttribute]
internal void set_IsInsideTransactedReceiveScope(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsFirstReceiveOfTransactedReceiveScopeTree();
    [CompilerGeneratedAttribute]
internal void set_IsFirstReceiveOfTransactedReceiveScopeTree(bool value);
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal bool get_HasOutputParameters();
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    internal void EnsureInvariants();
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.OperationDescriptionCollection : Collection`1<OperationDescription> {
    public OperationDescription Find(string name);
    public Collection`1<OperationDescription> FindAll(string name);
    protected virtual void InsertItem(int index, OperationDescription item);
    protected virtual void SetItem(int index, OperationDescription item);
}
internal class System.ServiceModel.Description.OperationGenerator : object {
    internal Dictionary`2<MessagePartDescription, CodeAttributeDeclarationCollection> ParameterAttributes { get; }
    internal Dictionary`2<MessagePartDescription, CodeTypeReference> ParameterTypes { get; }
    internal Dictionary`2<MessagePartDescription, string> SpecialPartName { get; }
    internal Dictionary`2<MessagePartDescription, CodeAttributeDeclarationCollection> get_ParameterAttributes();
    internal Dictionary`2<MessagePartDescription, CodeTypeReference> get_ParameterTypes();
    internal Dictionary`2<MessagePartDescription, string> get_SpecialPartName();
    internal void GenerateOperation(OperationContractGenerationContext context, OperationFormatStyle& style, bool isEncoded, IWrappedBodyTypeGenerator wrappedBodyTypeGenerator, Dictionary`2<MessagePartDescription, ICollection`1<CodeTypeReference>> knownTypes);
    internal static CodeAttributeDeclaration GenerateAttributeDeclaration(ServiceContractGenerator generator, Attribute attribute);
}
internal class System.ServiceModel.Description.ParameterModeException : Exception {
    public MessageContractType MessageContractType { get; public set; }
    public ParameterModeException(string message);
    public ParameterModeException(SerializationInfo info, StreamingContext context);
    public MessageContractType get_MessageContractType();
    public void set_MessageContractType(MessageContractType value);
}
public static class System.ServiceModel.Description.ParameterXPathQueryGenerator : object {
    public static string CreateFromDataContractSerializer(XName serviceContractName, string operationName, string parameterName, bool isReply, Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
}
public class System.ServiceModel.Description.PolicyAssertionCollection : Collection`1<XmlElement> {
    public PolicyAssertionCollection(IEnumerable`1<XmlElement> elements);
    internal void AddRange(IEnumerable`1<XmlElement> elements);
    public bool Contains(string localName, string namespaceUri);
    public XmlElement Find(string localName, string namespaceUri);
    public XmlElement Remove(string localName, string namespaceUri);
    public Collection`1<XmlElement> FindAll(string localName, string namespaceUri);
    public Collection`1<XmlElement> RemoveAll(string localName, string namespaceUri);
    protected virtual void InsertItem(int index, XmlElement item);
    protected virtual void SetItem(int index, XmlElement item);
}
public abstract class System.ServiceModel.Description.PolicyConversionContext : object {
    public BindingElementCollection BindingElements { get; }
    internal BindingParameterCollection BindingParameters { get; }
    public ContractDescription Contract { get; }
    protected PolicyConversionContext(ServiceEndpoint endpoint);
    public abstract virtual BindingElementCollection get_BindingElements();
    internal virtual BindingParameterCollection get_BindingParameters();
    public ContractDescription get_Contract();
    public abstract virtual PolicyAssertionCollection GetBindingAssertions();
    public abstract virtual PolicyAssertionCollection GetOperationBindingAssertions(OperationDescription operation);
    public abstract virtual PolicyAssertionCollection GetMessageBindingAssertions(MessageDescription message);
    public abstract virtual PolicyAssertionCollection GetFaultBindingAssertions(FaultDescription fault);
    internal static XmlElement FindAssertion(ICollection`1<XmlElement> assertions, string localName, string namespaceUri, bool remove);
}
public class System.ServiceModel.Description.PolicyVersion : object {
    public static PolicyVersion Policy12 { get; }
    public static PolicyVersion Policy15 { get; }
    public static PolicyVersion Default { get; }
    public string Namespace { get; }
    private static PolicyVersion();
    public static PolicyVersion get_Policy12();
    public static PolicyVersion get_Policy15();
    public static PolicyVersion get_Default();
    public string get_Namespace();
    public virtual string ToString();
}
public enum System.ServiceModel.Description.PrincipalPermissionMode : Enum {
    public int value__;
    public static PrincipalPermissionMode None;
    public static PrincipalPermissionMode UseWindowsGroups;
    public static PrincipalPermissionMode UseAspNetRoles;
    public static PrincipalPermissionMode Custom;
    public static PrincipalPermissionMode Always;
}
internal static class System.ServiceModel.Description.PrincipalPermissionModeHelper : object {
    public static bool IsDefined(PrincipalPermissionMode principalPermissionMode);
}
internal class System.ServiceModel.Description.ProtocolMappingItem : object {
    public string Binding { get; public set; }
    public string BindingConfiguration { get; public set; }
    public ProtocolMappingItem(string binding, string bindingConfiguration);
    [CompilerGeneratedAttribute]
public string get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(string value);
    [CompilerGeneratedAttribute]
public string get_BindingConfiguration();
    [CompilerGeneratedAttribute]
public void set_BindingConfiguration(string value);
}
internal static class System.ServiceModel.Description.SchemaHelper : object {
    private static SchemaHelper();
    internal static void AddElementForm(XmlSchemaElement element, XmlSchema schema);
    internal static void AddElementToSchema(XmlSchemaElement element, XmlSchema schema, XmlSchemaSet schemaSet);
    internal static void AddImportToSchema(string ns, XmlSchema schema);
    internal static void AddTypeToSchema(XmlSchemaType type, XmlSchema schema, XmlSchemaSet schemaSet);
    internal static XmlSchema GetSchema(string ns, XmlSchemaSet schemaSet);
    internal static bool IsMatch(XmlSchemaElement e1, XmlSchemaElement e2);
    internal static bool NamespacesEqual(string ns1, string ns2);
    internal static void Compile(XmlSchemaSet schemaSet, Collection`1<MetadataConversionError> errors);
    internal static void HandleSchemaValidationError(object sender, ValidationEventArgs args, Collection`1<MetadataConversionError> errors);
    internal static bool IsElementValueType(XmlSchemaElement element);
}
public class System.ServiceModel.Description.ServiceAuthenticationBehavior : object {
    internal ServiceAuthenticationManager defaultServiceAuthenticationManager;
    public ServiceAuthenticationManager ServiceAuthenticationManager { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ServiceAuthenticationManager get_ServiceAuthenticationManager();
    public void set_ServiceAuthenticationManager(ServiceAuthenticationManager value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public bool ShouldSerializeServiceAuthenticationManager();
    public bool ShouldSerializeAuthenticationSchemes();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    internal ServiceAuthenticationBehavior Clone();
    internal void MakeReadOnly();
}
public class System.ServiceModel.Description.ServiceAuthorizationBehavior : object {
    internal static bool DefaultImpersonateCallerForAllOperations;
    internal static bool DefaultImpersonateOnSerializingReply;
    internal static PrincipalPermissionMode DefaultPrincipalPermissionMode;
    public ReadOnlyCollection`1<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; public set; }
    public ServiceAuthorizationManager ServiceAuthorizationManager { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public PrincipalPermissionMode PrincipalPermissionMode { get; public set; }
    [DefaultValueAttribute("")]
public RoleProvider RoleProvider { get; public set; }
    [DefaultValueAttribute("False")]
public bool ImpersonateCallerForAllOperations { get; public set; }
    [DefaultValueAttribute("False")]
public bool ImpersonateOnSerializingReply { get; public set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_ExternalAuthorizationPolicies();
    public void set_ExternalAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public bool ShouldSerializeExternalAuthorizationPolicies();
    public ServiceAuthorizationManager get_ServiceAuthorizationManager();
    public void set_ServiceAuthorizationManager(ServiceAuthorizationManager value);
    public bool ShouldSerializeServiceAuthorizationManager();
    public PrincipalPermissionMode get_PrincipalPermissionMode();
    public void set_PrincipalPermissionMode(PrincipalPermissionMode value);
    public RoleProvider get_RoleProvider();
    public void set_RoleProvider(RoleProvider value);
    public bool get_ImpersonateCallerForAllOperations();
    public void set_ImpersonateCallerForAllOperations(bool value);
    public bool get_ImpersonateOnSerializingReply();
    public void set_ImpersonateOnSerializingReply(bool value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    internal ServiceAuthorizationBehavior Clone();
    internal void MakeReadOnly();
}
public class System.ServiceModel.Description.ServiceContractGenerationContext : object {
    internal CodeTypeDeclaration ChannelType { get; internal set; }
    internal CodeTypeReference ChannelTypeReference { get; internal set; }
    internal CodeTypeDeclaration ClientType { get; internal set; }
    internal CodeTypeReference ClientTypeReference { get; internal set; }
    public ContractDescription Contract { get; }
    public CodeTypeDeclaration ContractType { get; }
    internal CodeTypeReference ContractTypeReference { get; internal set; }
    public CodeTypeDeclaration DuplexCallbackType { get; }
    internal CodeTypeReference DuplexCallbackTypeReference { get; internal set; }
    internal CodeNamespace Namespace { get; internal set; }
    public Collection`1<OperationContractGenerationContext> Operations { get; }
    public ServiceContractGenerator ServiceContractGenerator { get; }
    internal CodeTypeFactory TypeFactory { get; internal set; }
    public ServiceContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ContractDescription contract, CodeTypeDeclaration contractType);
    public ServiceContractGenerationContext(ServiceContractGenerator serviceContractGenerator, ContractDescription contract, CodeTypeDeclaration contractType, CodeTypeDeclaration duplexCallbackType);
    internal CodeTypeDeclaration get_ChannelType();
    internal void set_ChannelType(CodeTypeDeclaration value);
    internal CodeTypeReference get_ChannelTypeReference();
    internal void set_ChannelTypeReference(CodeTypeReference value);
    internal CodeTypeDeclaration get_ClientType();
    internal void set_ClientType(CodeTypeDeclaration value);
    internal CodeTypeReference get_ClientTypeReference();
    internal void set_ClientTypeReference(CodeTypeReference value);
    public ContractDescription get_Contract();
    public CodeTypeDeclaration get_ContractType();
    internal CodeTypeReference get_ContractTypeReference();
    internal void set_ContractTypeReference(CodeTypeReference value);
    public CodeTypeDeclaration get_DuplexCallbackType();
    internal CodeTypeReference get_DuplexCallbackTypeReference();
    internal void set_DuplexCallbackTypeReference(CodeTypeReference value);
    internal CodeNamespace get_Namespace();
    internal void set_Namespace(CodeNamespace value);
    public Collection`1<OperationContractGenerationContext> get_Operations();
    public ServiceContractGenerator get_ServiceContractGenerator();
    internal CodeTypeFactory get_TypeFactory();
    internal void set_TypeFactory(CodeTypeFactory value);
}
[FlagsAttribute]
public enum System.ServiceModel.Description.ServiceContractGenerationOptions : Enum {
    public int value__;
    public static ServiceContractGenerationOptions None;
    public static ServiceContractGenerationOptions AsynchronousMethods;
    public static ServiceContractGenerationOptions ChannelInterface;
    public static ServiceContractGenerationOptions InternalTypes;
    public static ServiceContractGenerationOptions ClientClass;
    public static ServiceContractGenerationOptions TypedMessages;
    public static ServiceContractGenerationOptions EventBasedAsynchronousMethods;
    public static ServiceContractGenerationOptions TaskBasedAsynchronousMethod;
}
public class System.ServiceModel.Description.ServiceContractGenerator : object {
    public ServiceContractGenerationOptions Options { get; public set; }
    internal OptionsHelper OptionsInternal { get; }
    public Dictionary`2<ContractDescription, Type> ReferencedTypes { get; }
    public CodeCompileUnit TargetCompileUnit { get; }
    public Configuration Configuration { get; }
    public Dictionary`2<string, string> NamespaceMappings { get; }
    public Collection`1<MetadataConversionError> Errors { get; }
    internal NamespaceHelper NamespaceManager { get; }
    internal Dictionary`2<MessageDescription, CodeTypeReference> GeneratedTypedMessages { get; }
    public ServiceContractGenerator(Configuration targetConfig);
    public ServiceContractGenerator(CodeCompileUnit targetCompileUnit);
    public ServiceContractGenerator(CodeCompileUnit targetCompileUnit, Configuration targetConfig);
    internal CodeTypeReference GetCodeTypeReference(Type type);
    internal void AddReferencedAssembly(Assembly assembly);
    public ServiceContractGenerationOptions get_Options();
    public void set_Options(ServiceContractGenerationOptions value);
    internal OptionsHelper get_OptionsInternal();
    public Dictionary`2<ContractDescription, Type> get_ReferencedTypes();
    public CodeCompileUnit get_TargetCompileUnit();
    public Configuration get_Configuration();
    public Dictionary`2<string, string> get_NamespaceMappings();
    public Collection`1<MetadataConversionError> get_Errors();
    internal NamespaceHelper get_NamespaceManager();
    public void GenerateBinding(Binding binding, String& bindingSectionName, String& configurationName);
    public CodeTypeReference GenerateServiceEndpoint(ServiceEndpoint endpoint, ChannelEndpointElement& channelElement);
    public CodeTypeReference GenerateServiceContractType(ContractDescription contractDescription);
    internal static CodeExpression GetEnumReference(EnumType value);
    internal Dictionary`2<MessageDescription, CodeTypeReference> get_GeneratedTypedMessages();
}
public class System.ServiceModel.Description.ServiceCredentials : SecurityCredentialsManager {
    public UserNamePasswordServiceCredential UserNameAuthentication { get; }
    public X509CertificateInitiatorServiceCredential ClientCertificate { get; }
    public X509CertificateRecipientServiceCredential ServiceCertificate { get; }
    public WindowsServiceCredential WindowsAuthentication { get; }
    public IssuedTokenServiceCredential IssuedTokenAuthentication { get; }
    public PeerCredential Peer { get; }
    public SecureConversationServiceCredential SecureConversationAuthentication { get; }
    public ExceptionMapper ExceptionMapper { get; public set; }
    public IdentityConfiguration IdentityConfiguration { get; public set; }
    public bool UseIdentityConfiguration { get; public set; }
    protected ServiceCredentials(ServiceCredentials other);
    public UserNamePasswordServiceCredential get_UserNameAuthentication();
    public X509CertificateInitiatorServiceCredential get_ClientCertificate();
    public X509CertificateRecipientServiceCredential get_ServiceCertificate();
    public WindowsServiceCredential get_WindowsAuthentication();
    public IssuedTokenServiceCredential get_IssuedTokenAuthentication();
    public PeerCredential get_Peer();
    public SecureConversationServiceCredential get_SecureConversationAuthentication();
    public ExceptionMapper get_ExceptionMapper();
    public void set_ExceptionMapper(ExceptionMapper value);
    public IdentityConfiguration get_IdentityConfiguration();
    public void set_IdentityConfiguration(IdentityConfiguration value);
    public bool get_UseIdentityConfiguration();
    public void set_UseIdentityConfiguration(bool value);
    internal static ServiceCredentials CreateDefaultCredentials();
    public virtual SecurityTokenManager CreateSecurityTokenManager();
    protected virtual ServiceCredentials CloneCore();
    public ServiceCredentials Clone();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Description.ServiceDebugBehavior : object {
    [DefaultValueAttribute("True")]
public bool HttpHelpPageEnabled { get; public set; }
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri HttpHelpPageUrl { get; public set; }
    [DefaultValueAttribute("True")]
public bool HttpsHelpPageEnabled { get; public set; }
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri HttpsHelpPageUrl { get; public set; }
    public Binding HttpHelpPageBinding { get; public set; }
    public Binding HttpsHelpPageBinding { get; public set; }
    [DefaultValueAttribute("False")]
public bool IncludeExceptionDetailInFaults { get; public set; }
    public bool get_HttpHelpPageEnabled();
    public void set_HttpHelpPageEnabled(bool value);
    public Uri get_HttpHelpPageUrl();
    public void set_HttpHelpPageUrl(Uri value);
    public bool get_HttpsHelpPageEnabled();
    public void set_HttpsHelpPageEnabled(bool value);
    public Uri get_HttpsHelpPageUrl();
    public void set_HttpsHelpPageUrl(Uri value);
    public Binding get_HttpHelpPageBinding();
    public void set_HttpHelpPageBinding(Binding value);
    public Binding get_HttpsHelpPageBinding();
    public void set_HttpsHelpPageBinding(Binding value);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
[DebuggerDisplayAttribute("ServiceType={serviceType}")]
public class System.ServiceModel.Description.ServiceDescription : object {
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public KeyedByTypeCollection`1<IServiceBehavior> Behaviors { get; }
    public string ConfigurationName { get; public set; }
    public ServiceEndpointCollection Endpoints { get; }
    public Type ServiceType { get; public set; }
    internal ServiceDescription(string serviceName);
    public ServiceDescription(IEnumerable`1<ServiceEndpoint> endpoints);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public KeyedByTypeCollection`1<IServiceBehavior> get_Behaviors();
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public ServiceEndpointCollection get_Endpoints();
    public Type get_ServiceType();
    public void set_ServiceType(Type value);
    internal static object CreateImplementation(Type serviceType);
    internal void EnsureInvariants();
    public static ServiceDescription GetService(Type serviceType);
    public static ServiceDescription GetService(object serviceImplementation);
}
[DebuggerDisplayAttribute("Address={address}")]
[DebuggerDisplayAttribute("Name={name}")]
public class System.ServiceModel.Description.ServiceEndpoint : object {
    public EndpointAddress Address { get; public set; }
    public KeyedCollection`2<Type, IEndpointBehavior> EndpointBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IEndpointBehavior> Behaviors { get; }
    public Binding Binding { get; public set; }
    public ContractDescription Contract { get; public set; }
    public bool IsSystemEndpoint { get; public set; }
    public string Name { get; public set; }
    public Uri ListenUri { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    internal string Id { get; }
    internal Uri UnresolvedAddress { get; internal set; }
    internal Uri UnresolvedListenUri { get; internal set; }
    internal bool IsFullyConfigured { get; internal set; }
    public ServiceEndpoint(ContractDescription contract);
    public ServiceEndpoint(ContractDescription contract, Binding binding, EndpointAddress address);
    public EndpointAddress get_Address();
    public void set_Address(EndpointAddress value);
    public KeyedCollection`2<Type, IEndpointBehavior> get_EndpointBehaviors();
    public KeyedByTypeCollection`1<IEndpointBehavior> get_Behaviors();
    public Binding get_Binding();
    public void set_Binding(Binding value);
    public ContractDescription get_Contract();
    public void set_Contract(ContractDescription value);
    [CompilerGeneratedAttribute]
public bool get_IsSystemEndpoint();
    [CompilerGeneratedAttribute]
public void set_IsSystemEndpoint(bool value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    internal string get_Id();
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedAddress();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedAddress(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedListenUri();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedListenUri(Uri value);
    internal void EnsureInvariants();
    internal void ValidateForClient();
    internal void ValidateForService(bool runOperationValidators);
    internal bool get_IsFullyConfigured();
    internal void set_IsFullyConfigured(bool value);
    internal bool InternalIsSystemEndpoint(ServiceDescription description);
}
public class System.ServiceModel.Description.ServiceEndpointCollection : Collection`1<ServiceEndpoint> {
    public ServiceEndpoint Find(Type contractType);
    public ServiceEndpoint Find(XmlQualifiedName contractName);
    public ServiceEndpoint Find(Type contractType, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(XmlQualifiedName contractName, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(Uri address);
    public Collection`1<ServiceEndpoint> FindAll(Type contractType);
    public Collection`1<ServiceEndpoint> FindAll(XmlQualifiedName contractName);
    protected virtual void InsertItem(int index, ServiceEndpoint item);
    protected virtual void SetItem(int index, ServiceEndpoint item);
}
public class System.ServiceModel.Description.ServiceMetadataBehavior : object {
    public static string MexContractName;
    internal static string MexContractNamespace;
    public bool HttpGetEnabled { get; public set; }
    [TypeConverterAttribute("System.UriTypeConverter")]
public Uri HttpGetUrl { get; public set; }
    public bool HttpsGetEnabled { get; public set; }
    [TypeConverterAttribute("System.UriTypeConverter")]
public Uri HttpsGetUrl { get; public set; }
    public Binding HttpGetBinding { get; public set; }
    public Binding HttpsGetBinding { get; public set; }
    [TypeConverterAttribute("System.UriTypeConverter")]
public Uri ExternalMetadataLocation { get; public set; }
    public MetadataExporter MetadataExporter { get; public set; }
    internal static ContractDescription MexContract { get; }
    private static ServiceMetadataBehavior();
    public bool get_HttpGetEnabled();
    public void set_HttpGetEnabled(bool value);
    public Uri get_HttpGetUrl();
    public void set_HttpGetUrl(Uri value);
    public bool get_HttpsGetEnabled();
    public void set_HttpsGetEnabled(bool value);
    public Uri get_HttpsGetUrl();
    public void set_HttpsGetUrl(Uri value);
    public Binding get_HttpGetBinding();
    public void set_HttpGetBinding(Binding value);
    public Binding get_HttpsGetBinding();
    public void set_HttpsGetBinding(Binding value);
    public Uri get_ExternalMetadataLocation();
    public void set_ExternalMetadataLocation(Uri value);
    public MetadataExporter get_MetadataExporter();
    public void set_MetadataExporter(MetadataExporter value);
    internal static ContractDescription get_MexContract();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    internal static bool IsMetadataDispatcher(ServiceDescription description, ChannelDispatcher channelDispatcher);
    internal static bool IsHttpGetMetadataDispatcher(ServiceDescription description, ChannelDispatcher channelDispatcher);
    internal static bool IsMetadataEndpoint(ServiceDescription description, ServiceEndpoint endpoint);
    internal static bool IsMetadataImplementedType(ServiceDescription description, Type type);
    internal static bool IsMetadataImplementedType(Type type);
    internal void AddImplementedContracts(ServiceAndBehaviorsContractResolver resolver);
}
public class System.ServiceModel.Description.ServiceMetadataContractBehavior : object {
    public bool MetadataGenerationDisabled { get; public set; }
    public ServiceMetadataContractBehavior(bool metadataGenerationDisabled);
    public bool get_MetadataGenerationDisabled();
    public void set_MetadataGenerationDisabled(bool value);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
[DebuggerDisplayAttribute("Address={address}")]
[DebuggerDisplayAttribute("Name={name}")]
public class System.ServiceModel.Description.ServiceMetadataEndpoint : ServiceEndpoint {
    public ServiceMetadataEndpoint(EndpointAddress address);
    public ServiceMetadataEndpoint(Binding binding, EndpointAddress address);
}
public class System.ServiceModel.Description.ServiceMetadataExtension : object {
    internal MetadataExtensionInitializer Initializer { get; internal set; }
    public MetadataSet Metadata { get; }
    public ServiceDescription SingleWsdl { get; }
    internal Uri ExternalMetadataLocation { get; internal set; }
    internal bool MexEnabled { get; internal set; }
    internal bool HttpGetEnabled { get; internal set; }
    internal bool HttpsGetEnabled { get; internal set; }
    internal bool HelpPageEnabled { get; }
    internal bool MetadataEnabled { get; }
    internal bool HttpHelpPageEnabled { get; internal set; }
    internal bool HttpsHelpPageEnabled { get; internal set; }
    internal Uri MexUrl { get; internal set; }
    internal Uri HttpGetUrl { get; internal set; }
    internal Uri HttpsGetUrl { get; internal set; }
    internal Uri HttpHelpPageUrl { get; internal set; }
    internal Uri HttpsHelpPageUrl { get; internal set; }
    internal Binding HttpHelpPageBinding { get; internal set; }
    internal Binding HttpsHelpPageBinding { get; internal set; }
    internal Binding HttpGetBinding { get; internal set; }
    internal Binding HttpsGetBinding { get; internal set; }
    internal bool UpdateAddressDynamically { get; internal set; }
    internal IDictionary`2<string, int> UpdatePortsByScheme { get; internal set; }
    internal ServiceMetadataExtension(MetadataExtensionInitializer initializer);
    private static ServiceMetadataExtension();
    internal MetadataExtensionInitializer get_Initializer();
    internal void set_Initializer(MetadataExtensionInitializer value);
    public MetadataSet get_Metadata();
    public ServiceDescription get_SingleWsdl();
    internal Uri get_ExternalMetadataLocation();
    internal void set_ExternalMetadataLocation(Uri value);
    internal bool get_MexEnabled();
    internal void set_MexEnabled(bool value);
    internal bool get_HttpGetEnabled();
    internal void set_HttpGetEnabled(bool value);
    internal bool get_HttpsGetEnabled();
    internal void set_HttpsGetEnabled(bool value);
    internal bool get_HelpPageEnabled();
    internal bool get_MetadataEnabled();
    internal bool get_HttpHelpPageEnabled();
    internal void set_HttpHelpPageEnabled(bool value);
    internal bool get_HttpsHelpPageEnabled();
    internal void set_HttpsHelpPageEnabled(bool value);
    internal Uri get_MexUrl();
    internal void set_MexUrl(Uri value);
    internal Uri get_HttpGetUrl();
    internal void set_HttpGetUrl(Uri value);
    internal Uri get_HttpsGetUrl();
    internal void set_HttpsGetUrl(Uri value);
    internal Uri get_HttpHelpPageUrl();
    internal void set_HttpHelpPageUrl(Uri value);
    internal Uri get_HttpsHelpPageUrl();
    internal void set_HttpsHelpPageUrl(Uri value);
    internal Binding get_HttpHelpPageBinding();
    internal void set_HttpHelpPageBinding(Binding value);
    internal Binding get_HttpsHelpPageBinding();
    internal void set_HttpsHelpPageBinding(Binding value);
    internal Binding get_HttpGetBinding();
    internal void set_HttpGetBinding(Binding value);
    internal Binding get_HttpsGetBinding();
    internal void set_HttpsGetBinding(Binding value);
    [CompilerGeneratedAttribute]
internal bool get_UpdateAddressDynamically();
    [CompilerGeneratedAttribute]
internal void set_UpdateAddressDynamically(bool value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, int> get_UpdatePortsByScheme();
    [CompilerGeneratedAttribute]
internal void set_UpdatePortsByScheme(IDictionary`2<string, int> value);
    internal static bool TryGetHttpHostAndPort(Uri listenUri, Message request, String& host, Int32& port);
    private sealed virtual override void System.ServiceModel.IExtension<System.ServiceModel.ServiceHostBase>.Attach(ServiceHostBase owner);
    private sealed virtual override void System.ServiceModel.IExtension<System.ServiceModel.ServiceHostBase>.Detach(ServiceHostBase owner);
    internal static ServiceMetadataExtension EnsureServiceMetadataExtension(ServiceDescription description, ServiceHostBase host);
    internal ChannelDispatcher EnsureGetDispatcher(Uri listenUri);
    internal ChannelDispatcher EnsureGetDispatcher(Uri listenUri, bool isServiceDebugBehavior);
}
internal static class System.ServiceModel.Description.ServiceReflector : object {
    internal static BindingFlags ServiceModelBindingFlags;
    internal static string BeginMethodNamePrefix;
    internal static string EndMethodNamePrefix;
    internal static Type VoidType;
    internal static string AsyncMethodNameSuffix;
    internal static Type taskType;
    internal static Type taskTResultType;
    internal static Type CancellationTokenType;
    internal static Type IProgressType;
    private static ServiceReflector();
    internal static Type GetOperationContractProviderType(MethodInfo method);
    internal static List`1<Type> GetInterfaces(Type service);
    internal static List`1<Type> GetInheritedContractTypes(Type service);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider attrProvider, Type attrType);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider attrProvider, Type attrType, bool inherit);
    internal static T GetFirstAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetRequiredSingleAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(ICustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static T GetRequiredSingleAttribute(ICustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static Type GetContractType(Type interfaceType);
    internal static Type GetContractTypeAndAttribute(Type interfaceType, ServiceContractAttribute& contractAttribute);
    internal static void ValidateParameterMetadata(MethodInfo methodInfo);
    internal static bool FlowsIn(ParameterInfo paramInfo);
    internal static bool FlowsOut(ParameterInfo paramInfo);
    internal static ParameterInfo[] GetInputParameters(MethodInfo method, bool asyncPattern);
    internal static ParameterInfo[] GetOutputParameters(MethodInfo method, bool asyncPattern);
    internal static bool HasOutputParameters(MethodInfo method, bool asyncPattern);
    internal static MethodInfo GetEndMethod(MethodInfo beginMethod);
    internal static XmlName GetOperationName(MethodInfo method);
    internal static bool HasBeginMethodShape(MethodInfo method);
    internal static bool IsBegin(OperationContractAttribute opSettings, MethodInfo method);
    internal static bool IsTask(MethodInfo method);
    internal static bool IsTask(MethodInfo method, Type& taskTResult);
    internal static bool HasEndMethodShape(MethodInfo method);
    internal static OperationContractAttribute GetOperationContractAttribute(MethodInfo method);
    internal static bool IsBegin(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method, bool isAsync, bool isTask);
    internal static bool HasNoDisposableParameters(MethodInfo methodInfo);
    internal static bool IsParameterDisposable(Type type);
}
public class System.ServiceModel.Description.ServiceSecurityAuditBehavior : object {
    internal static AuditLogLocation defaultAuditLogLocation;
    internal static bool defaultSuppressAuditFailure;
    internal static AuditLevel defaultServiceAuthorizationAuditLevel;
    internal static AuditLevel defaultMessageAuthenticationAuditLevel;
    public AuditLogLocation AuditLogLocation { get; public set; }
    public bool SuppressAuditFailure { get; public set; }
    public AuditLevel ServiceAuthorizationAuditLevel { get; public set; }
    public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public AuditLogLocation get_AuditLogLocation();
    public void set_AuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_ServiceAuthorizationAuditLevel();
    public void set_ServiceAuthorizationAuditLevel(AuditLevel value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    internal ServiceSecurityAuditBehavior Clone();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
public class System.ServiceModel.Description.ServiceThrottlingBehavior : object {
    internal static int DefaultMaxConcurrentInstances;
    public int MaxConcurrentCalls { get; public set; }
    public int MaxConcurrentSessions { get; public set; }
    public int MaxConcurrentInstances { get; public set; }
    private static ServiceThrottlingBehavior();
    public int get_MaxConcurrentCalls();
    public void set_MaxConcurrentCalls(int value);
    public int get_MaxConcurrentSessions();
    public void set_MaxConcurrentSessions(int value);
    public int get_MaxConcurrentInstances();
    public void set_MaxConcurrentInstances(int value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal class System.ServiceModel.Description.ServiceTimeoutsBehavior : object {
    internal TimeSpan TransactionTimeout { get; internal set; }
    internal ServiceTimeoutsBehavior(TimeSpan transactionTimeout);
    internal TimeSpan get_TransactionTimeout();
    internal void set_TransactionTimeout(TimeSpan value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal static class System.ServiceModel.Description.SoapHelper : object {
    private static SoapHelper();
    internal static SoapAddressBinding GetOrCreateSoapAddressBinding(Binding wsdlBinding, Port wsdlPort, WsdlExporter exporter);
    internal static SoapBinding GetOrCreateSoapBinding(WsdlEndpointConversionContext endpointContext, WsdlExporter exporter);
    internal static SoapOperationBinding GetOrCreateSoapOperationBinding(WsdlEndpointConversionContext endpointContext, OperationDescription operation, WsdlExporter exporter);
    internal static SoapBodyBinding GetOrCreateSoapBodyBinding(WsdlEndpointConversionContext endpointContext, MessageBinding wsdlMessageBinding, WsdlExporter exporter);
    internal static SoapHeaderBinding CreateSoapHeaderBinding(WsdlEndpointConversionContext endpointContext, MessageBinding wsdlMessageBinding);
    internal static void CreateSoapFaultBinding(string name, WsdlEndpointConversionContext endpointContext, FaultBinding wsdlFaultBinding, bool isEncoded);
    internal static void SetSoapVersion(WsdlEndpointConversionContext endpointContext, WsdlExporter exporter, EnvelopeVersion version);
    internal static EnvelopeVersion GetSoapVersion(Binding wsdlBinding);
    internal static SoapAddressBinding GetSoapAddressBinding(Port wsdlPort);
    internal static string ReadSoapAction(OperationBinding wsdlOperationBinding);
    internal static SoapBindingStyle GetStyle(Binding binding);
    internal static SoapBindingStyle GetStyle(OperationBinding operationBinding, SoapBindingStyle defaultBindingStyle);
    internal static bool IsSoapFaultBinding(XmlElement element);
    internal static bool IsEncoded(XmlElement element);
}
internal static class System.ServiceModel.Description.StockSchemas : object {
    internal static string WsdlNamespace;
    internal static string SoapNamespace;
    internal static string SoapEncodingNamespace;
    internal static XmlSchema CreateWsdl();
    internal static XmlSchema CreateSoap();
    internal static XmlSchema CreateSoapEncoding();
    internal static XmlSchema CreateFakeSoapEncoding();
    internal static XmlSchema CreateFakeXsdSchema();
    internal static XmlSchema CreateFakeXmlSchema();
    internal static bool IsKnownSchema(string ns);
}
public class System.ServiceModel.Description.SynchronousReceiveBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
internal static class System.ServiceModel.Description.TaskOperationDescriptionValidator : object {
    internal static void Validate(OperationDescription operationDescription, bool isForService);
}
public class System.ServiceModel.Description.TransactedBatchingBehavior : object {
    public int MaxBatchSize { get; public set; }
    public TransactedBatchingBehavior(int maxBatchSize);
    public int get_MaxBatchSize();
    public void set_MaxBatchSize(int value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
public abstract class System.ServiceModel.Description.TypedMessageConverter : object {
    public static TypedMessageConverter Create(Type messageContract, string action);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace);
    public static TypedMessageConverter Create(Type messageContract, string action, XmlSerializerFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, DataContractFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace, XmlSerializerFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace, DataContractFormatAttribute formatterAttribute);
    public abstract virtual Message ToMessage(object typedMessage);
    public abstract virtual Message ToMessage(object typedMessage, MessageVersion version);
    public abstract virtual object FromMessage(Message message);
}
internal class System.ServiceModel.Description.TypeLoader : object {
    internal static DataContractFormatAttribute DefaultDataContractFormatAttribute;
    internal static XmlSerializerFormatAttribute DefaultXmlSerializerFormatAttribute;
    internal static string ReturnSuffix;
    internal static string ResponseSuffix;
    internal static string FaultSuffix;
    internal static BindingFlags DefaultBindingFlags;
    private static TypeLoader();
    public ContractDescription LoadContractDescription(Type contractType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType, object serviceImplementation);
    internal void AddBehaviorsSFx(ServiceEndpoint serviceEndpoint, Type contractType);
    internal void AddBehaviorsFromImplementationType(ServiceEndpoint serviceEndpoint, Type implementationType);
    internal static int CompareMessagePartDescriptions(MessagePartDescription a, MessagePartDescription b);
    internal static XmlName GetBodyWrapperResponseName(string operationName);
    internal static XmlName GetBodyWrapperResponseName(XmlName operationName);
    internal static void EnsureCallbackType(Type callbackType);
    internal static void EnsureSubcontract(ServiceContractAttribute svcContractAttr, Type contractType);
    internal static Attribute GetFormattingAttribute(ICustomAttributeProvider attrProvider, Attribute defaultFormatAttribute);
    internal MessageDescription CreateTypedMessageDescription(Type typedMessageType, ICustomAttributeProvider returnAttrProvider, XmlName returnValueName, string defaultNS, string action, MessageDirection direction);
    internal static XmlName GetReturnValueName(XmlName methodName);
    internal static XmlName GetReturnValueName(string methodName);
    internal static Type GetParameterType(ParameterInfo parameterInfo);
    internal static XmlName GetWrapperName(string wrapperName, XmlName defaultName);
    public static void ApplyServiceInheritance(Type serviceType, TBehaviorCollection descriptionBehaviors, ServiceInheritanceCallback`2<IBehavior, TBehaviorCollection> callback);
}
internal class System.ServiceModel.Description.UniqueCodeIdentifierScope : object {
    protected virtual void AddIdentifier(string identifier);
    public void AddReserved(string identifier);
    public string AddUnique(string name, string defaultName);
    public virtual bool IsUnique(string identifier);
    public static string MakeValid(string identifier, string defaultIdentifier);
}
internal class System.ServiceModel.Description.UniqueCodeNamespaceScope : UniqueCodeIdentifierScope {
    public CodeNamespace CodeNamespace { get; }
    public UniqueCodeNamespaceScope(CodeNamespace codeNamespace);
    public CodeNamespace get_CodeNamespace();
    protected virtual void AddIdentifier(string identifier);
    public CodeTypeReference AddUnique(CodeTypeDeclaration codeType, string name, string defaultName);
    public virtual bool IsUnique(string identifier);
}
public class System.ServiceModel.Description.UseRequestHeadersForMetadataAddressBehavior : object {
    public IDictionary`2<string, int> DefaultPortsByScheme { get; }
    public IDictionary`2<string, int> get_DefaultPortsByScheme();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
}
internal static class System.ServiceModel.Description.ValidWsdl : object {
    internal static bool Check(SoapHeaderBinding soapHeaderBinding, MessageBinding messageBinding, WsdlWarningHandler warningHandler);
    internal static bool Check(SoapFaultBinding soapFaultBinding, FaultBinding faultBinding, WsdlWarningHandler warningHandler);
    internal static bool Check(MessagePart part, Message message, WsdlWarningHandler warningHandler);
}
public class System.ServiceModel.Description.WsdlContractConversionContext : object {
    internal IEnumerable`1<IWsdlExportExtension> ExportExtensions { get; }
    public ContractDescription Contract { get; }
    public PortType WsdlPortType { get; }
    internal WsdlContractConversionContext(ContractDescription contract, PortType wsdlPortType);
    [IteratorStateMachineAttribute("System.ServiceModel.Description.WsdlContractConversionContext/<get_ExportExtensions>d__11")]
internal IEnumerable`1<IWsdlExportExtension> get_ExportExtensions();
    public ContractDescription get_Contract();
    public PortType get_WsdlPortType();
    public Operation GetOperation(OperationDescription operation);
    public OperationMessage GetOperationMessage(MessageDescription message);
    public OperationFault GetOperationFault(FaultDescription fault);
    public OperationDescription GetOperationDescription(Operation operation);
    public MessageDescription GetMessageDescription(OperationMessage operationMessage);
    public FaultDescription GetFaultDescription(OperationFault operationFault);
    internal void AddOperation(OperationDescription operationDescription, Operation wsdlOperation);
    internal void AddMessage(MessageDescription messageDescription, OperationMessage wsdlOperationMessage);
    internal void AddFault(FaultDescription faultDescription, OperationFault wsdlOperationFault);
    internal Collection`1<OperationBinding> GetOperationBindings(Operation operation);
}
public class System.ServiceModel.Description.WsdlEndpointConversionContext : object {
    internal IEnumerable`1<IWsdlExportExtension> ExportExtensions { get; }
    public ServiceEndpoint Endpoint { get; }
    public Binding WsdlBinding { get; }
    public Port WsdlPort { get; }
    public WsdlContractConversionContext ContractConversionContext { get; }
    internal WsdlEndpointConversionContext(WsdlContractConversionContext contractContext, ServiceEndpoint endpoint, Binding wsdlBinding, Port wsdlport);
    internal WsdlEndpointConversionContext(WsdlEndpointConversionContext bindingContext, ServiceEndpoint endpoint, Port wsdlport);
    [IteratorStateMachineAttribute("System.ServiceModel.Description.WsdlEndpointConversionContext/<get_ExportExtensions>d__13")]
internal IEnumerable`1<IWsdlExportExtension> get_ExportExtensions();
    public ServiceEndpoint get_Endpoint();
    public Binding get_WsdlBinding();
    public Port get_WsdlPort();
    public WsdlContractConversionContext get_ContractConversionContext();
    public OperationBinding GetOperationBinding(OperationDescription operation);
    public MessageBinding GetMessageBinding(MessageDescription message);
    public FaultBinding GetFaultBinding(FaultDescription fault);
    public OperationDescription GetOperationDescription(OperationBinding operationBinding);
    public MessageDescription GetMessageDescription(MessageBinding messageBinding);
    public FaultDescription GetFaultDescription(FaultBinding faultBinding);
    internal void AddOperationBinding(OperationDescription operationDescription, OperationBinding wsdlOperationBinding);
    internal void AddMessageBinding(MessageDescription messageDescription, MessageBinding wsdlMessageBinding);
    internal void AddFaultBinding(FaultDescription faultDescription, FaultBinding wsdlFaultBinding);
}
public class System.ServiceModel.Description.WsdlExporter : MetadataExporter {
    public ServiceDescriptionCollection GeneratedWsdlDocuments { get; }
    public XmlSchemaSet GeneratedXmlSchemas { get; }
    public virtual void ExportContract(ContractDescription contract);
    public virtual void ExportEndpoint(ServiceEndpoint endpoint);
    public void ExportEndpoints(IEnumerable`1<ServiceEndpoint> endpoints, XmlQualifiedName wsdlServiceQName);
    internal void ExportEndpoints(IEnumerable`1<ServiceEndpoint> endpoints, XmlQualifiedName wsdlServiceQName, BindingParameterCollection bindingParameters);
    public virtual MetadataSet GetGeneratedMetadata();
    public ServiceDescriptionCollection get_GeneratedWsdlDocuments();
    public XmlSchemaSet get_GeneratedXmlSchemas();
    internal static bool OperationIsExportable(OperationDescription operation);
    internal static bool OperationIsExportable(OperationDescription operation, Boolean& isWildcardAction);
    internal static bool IsBuiltInOperationBehavior(IWsdlExportExtension extension);
    internal ServiceDescription GetOrCreateWsdl(string ns);
    internal static XmlSchemaSet GetEmptySchemaSet();
}
internal static class System.ServiceModel.Description.WsdlHelper : object {
    public static ServiceDescription GetSingleWsdl(MetadataSet metadataSet);
}
public class System.ServiceModel.Description.WsdlImporter : MetadataImporter {
    public KeyedByTypeCollection`1<IWsdlImportExtension> WsdlImportExtensions { get; }
    public ServiceDescriptionCollection WsdlDocuments { get; }
    public XmlSchemaSet XmlSchemas { get; }
    public WsdlImporter(MetadataSet metadata);
    public WsdlImporter(MetadataSet metadata, IEnumerable`1<IPolicyImportExtension> policyImportExtensions, IEnumerable`1<IWsdlImportExtension> wsdlImportExtensions);
    public WsdlImporter(MetadataSet metadata, IEnumerable`1<IPolicyImportExtension> policyImportExtensions, IEnumerable`1<IWsdlImportExtension> wsdlImportExtensions, MetadataImporterQuotas quotas);
    public KeyedByTypeCollection`1<IWsdlImportExtension> get_WsdlImportExtensions();
    public ServiceDescriptionCollection get_WsdlDocuments();
    public XmlSchemaSet get_XmlSchemas();
    internal virtual XmlElement ResolvePolicyReference(string policyReference, XmlElement contextAssertion);
    public virtual Collection`1<ContractDescription> ImportAllContracts();
    public virtual ServiceEndpointCollection ImportAllEndpoints();
    public Collection`1<Binding> ImportAllBindings();
    public ContractDescription ImportContract(PortType wsdlPortType);
    public Binding ImportBinding(Binding wsdlBinding);
    public ServiceEndpoint ImportEndpoint(Port wsdlPort);
    public ServiceEndpointCollection ImportEndpoints(PortType wsdlPortType);
    internal ServiceEndpointCollection ImportEndpoints(ContractDescription contract);
    public ServiceEndpointCollection ImportEndpoints(Binding wsdlBinding);
    public ServiceEndpointCollection ImportEndpoints(Service wsdlService);
    [IteratorStateMachineAttribute("System.ServiceModel.Description.WsdlImporter/<CreateMetadataDocuments>d__67")]
internal static IEnumerable`1<MetadataSection> CreateMetadataDocuments(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, IEnumerable`1<XmlElement> policyDocuments);
}
internal class System.ServiceModel.Description.WsdlWarningHandler : MulticastDelegate {
    public WsdlWarningHandler(object object, IntPtr method);
    public virtual void Invoke(string warning);
    public virtual IAsyncResult BeginInvoke(string warning, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Description.XmlMessageConverter : TypedMessageConverter {
    internal string Action { get; }
    internal XmlMessageConverter(OperationFormatter formatter);
    internal string get_Action();
    public virtual Message ToMessage(object typedMessage);
    public virtual Message ToMessage(object typedMessage, MessageVersion version);
    public virtual object FromMessage(Message message);
}
internal class System.ServiceModel.Description.XmlName : object {
    internal string EncodedName { get; }
    internal string DecodedName { get; }
    internal XmlName(string name);
    internal XmlName(string name, bool isEncoded);
    internal string get_EncodedName();
    internal string get_DecodedName();
    internal static bool IsNullOrEmpty(XmlName xmlName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(XmlName a, XmlName b);
    public static bool op_Inequality(XmlName a, XmlName b);
}
internal class System.ServiceModel.Description.XmlSerializationReaderMetadataSet : XmlSerializationReader {
    public bool ProcessOuterElement { get; public set; }
    public bool get_ProcessOuterElement();
    public void set_ProcessOuterElement(bool value);
    public object Read68_Metadata();
    protected virtual void InitCallbacks();
    protected virtual void InitIDs();
}
internal class System.ServiceModel.Description.XmlSerializationWriterMetadataSet : XmlSerializationWriter {
    public bool ProcessOuterElement { get; public set; }
    public bool get_ProcessOuterElement();
    public void set_ProcessOuterElement(bool value);
    public void Write68_Metadata(object o);
    protected virtual void InitCallbacks();
}
internal abstract class System.ServiceModel.Description.XmlSerializer1 : XmlSerializer {
    protected virtual XmlSerializationReader CreateReader();
    protected virtual XmlSerializationWriter CreateWriter();
}
internal class System.ServiceModel.Description.XmlSerializerContract : XmlSerializerImplementation {
    public XmlSerializationReader Reader { get; }
    public XmlSerializationWriter Writer { get; }
    public Hashtable ReadMethods { get; }
    public Hashtable WriteMethods { get; }
    public Hashtable TypedSerializers { get; }
    public virtual XmlSerializationReader get_Reader();
    public virtual XmlSerializationWriter get_Writer();
    public virtual Hashtable get_ReadMethods();
    public virtual Hashtable get_WriteMethods();
    public virtual Hashtable get_TypedSerializers();
    public virtual bool CanSerialize(Type type);
    public virtual XmlSerializer GetSerializer(Type type);
}
internal static class System.ServiceModel.Description.XmlSerializerHelper : object {
    internal static XmlReflectionMember GetXmlReflectionMember(MessagePartDescription part, bool isRpc, bool isEncoded, bool isWrapped);
    internal static XmlReflectionMember GetXmlReflectionMember(XmlName memberName, XmlName elementName, string ns, Type type, ICustomAttributeProvider additionalAttributesProvider, bool isMultiple, bool isEncoded, bool isWrapped);
}
internal class System.ServiceModel.Description.XmlSerializerMessageContractExporter : MessageContractExporter {
    internal XmlSerializerMessageContractExporter(WsdlExporter exporter, WsdlContractConversionContext context, OperationDescription operation, IOperationBehavior extension);
    protected virtual bool IsRpcStyle();
    protected virtual bool IsEncoded();
    protected virtual object OnExportMessageContract();
    protected virtual void ExportHeaders(int messageIndex, object state);
    protected virtual void ExportBody(int messageIndex, object state);
    protected virtual void ExportFaults(object state);
    protected virtual void ExportKnownTypes();
    protected virtual object GetExtensionData();
    protected virtual void Compile();
}
public class System.ServiceModel.Description.XmlSerializerMessageContractImporter : object {
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportEndpoint(WsdlImporter importer, WsdlEndpointConversionContext endpointContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.ImportContract(WsdlImporter importer, WsdlContractConversionContext contractContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlImportExtension.BeforeImport(ServiceDescriptionCollection wsdlDocuments, XmlSchemaSet xmlSchemas, ICollection`1<XmlElement> policy);
}
public class System.ServiceModel.Description.XmlSerializerOperationBehavior : object {
    internal OperationReflector OperationReflector { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public XmlSerializerFormatAttribute XmlSerializerFormatAttribute { get; }
    public XmlSerializerOperationBehavior(OperationDescription operation);
    public XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute);
    internal XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute, Reflector parentReflector);
    internal OperationReflector get_OperationReflector();
    internal bool get_IsBuiltInOperationBehavior();
    public XmlSerializerFormatAttribute get_XmlSerializerFormatAttribute();
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation);
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation, XmlSerializerFormatAttribute attr);
    internal static void AddBehaviors(ContractDescription contract);
    internal static void AddBuiltInBehaviors(ContractDescription contract);
    internal XmlSerializerOperationFormatter CreateFormatter();
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext endpointContext);
    private sealed virtual override void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(WsdlExporter exporter, WsdlContractConversionContext contractContext);
    public Collection`1<XmlMapping> GetXmlMappings();
}
internal class System.ServiceModel.Description.XmlSerializerOperationGenerator : object {
    public XmlCodeExporter XmlExporter { get; }
    public SoapCodeExporter SoapExporter { get; }
    internal Dictionary`2<OperationDescription, XmlSerializerFormatAttribute> OperationAttributes { get; }
    internal XmlSerializerOperationGenerator(XmlSerializerImportOptions options);
    private static XmlSerializerOperationGenerator();
    internal void Add(MessagePartDescription part, XmlMemberMapping memberMapping, XmlMembersMapping membersMapping, bool isEncoded);
    public XmlCodeExporter get_XmlExporter();
    public SoapCodeExporter get_SoapExporter();
    internal Dictionary`2<OperationDescription, XmlSerializerFormatAttribute> get_OperationAttributes();
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    private sealed virtual override void System.ServiceModel.Description.IOperationContractGenerationExtension.GenerateOperation(OperationContractGenerationContext context);
    internal string GetTypeName(XmlMemberMapping member);
}
internal class System.ServiceModel.Diagnostics.AcknowledgementTraceRecord : WsrmTraceRecord {
    internal AcknowledgementTraceRecord(UniqueId id, IList`1<SequenceRange> ranges, int bufferRemaining);
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.ActivityIdHeader : DictionaryHeader {
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    internal ActivityIdHeader(Guid activityId);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    internal static Guid ExtractActivityId(Message message);
    internal static bool ExtractActivityAndCorrelationId(Message message, Guid& activityId, Guid& correlationId);
    internal void AddTo(Message message);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal enum System.ServiceModel.Diagnostics.ActivityType : Enum {
    public int value__;
    public static ActivityType Unknown;
    public static ActivityType Close;
    public static ActivityType Construct;
    public static ActivityType ExecuteUserCode;
    public static ActivityType ListenAt;
    public static ActivityType Open;
    public static ActivityType OpenClient;
    public static ActivityType ProcessMessage;
    public static ActivityType ProcessAction;
    public static ActivityType ReceiveBytes;
    public static ActivityType SecuritySetup;
    public static ActivityType TransferToComPlus;
    public static ActivityType WmiGetObject;
    public static ActivityType WmiPutInstance;
    public static ActivityType NumItems;
}
internal class System.ServiceModel.Diagnostics.AddressingProperty : object {
    public string Action { get; }
    public UniqueId MessageId { get; }
    public static string Name { get; }
    public EndpointAddress ReplyTo { get; }
    public Uri To { get; }
    public AddressingProperty(MessageHeaders headers);
    public string get_Action();
    public UniqueId get_MessageId();
    public static string get_Name();
    public EndpointAddress get_ReplyTo();
    public Uri get_To();
}
internal class System.ServiceModel.Diagnostics.Application.TD : object {
    internal static CultureInfo Culture { get; internal set; }
    private static TD();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool ClientOperationPreparedIsEnabled();
    internal static void ClientOperationPrepared(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination, Guid relatedActivityId);
    internal static bool ClientMessageInspectorAfterReceiveInvokedIsEnabled();
    internal static void ClientMessageInspectorAfterReceiveInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ClientMessageInspectorBeforeSendInvokedIsEnabled();
    internal static void ClientMessageInspectorBeforeSendInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ClientParameterInspectorAfterCallInvokedIsEnabled();
    internal static void ClientParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ClientParameterInspectorBeforeCallInvokedIsEnabled();
    internal static void ClientParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool OperationInvokedIsEnabled();
    internal static void OperationInvoked(EventTraceActivity eventTraceActivity, string MethodName, string CallerInfo);
    internal static bool ErrorHandlerInvokedIsEnabled();
    internal static void ErrorHandlerInvoked(string TypeName, bool Handled, string ExceptionTypeName);
    internal static bool FaultProviderInvokedIsEnabled();
    internal static void FaultProviderInvoked(string TypeName, string ExceptionTypeName);
    internal static bool MessageInspectorAfterReceiveInvokedIsEnabled();
    internal static void MessageInspectorAfterReceiveInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool MessageInspectorBeforeSendInvokedIsEnabled();
    internal static void MessageInspectorBeforeSendInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool MessageThrottleExceededIsEnabled();
    internal static void MessageThrottleExceeded(string ThrottleName, long Limit);
    internal static bool ParameterInspectorAfterCallInvokedIsEnabled();
    internal static void ParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ParameterInspectorBeforeCallInvokedIsEnabled();
    internal static void ParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool OperationCompletedIsEnabled();
    internal static void OperationCompleted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    internal static bool MessageReceivedByTransportIsEnabled();
    internal static void MessageReceivedByTransport(EventTraceActivity eventTraceActivity, string ListenAddress, Guid relatedActivityId);
    internal static bool MessageSentByTransportIsEnabled();
    internal static void MessageSentByTransport(EventTraceActivity eventTraceActivity, string DestinationAddress);
    internal static bool MessageLogInfoIsEnabled();
    internal static bool MessageLogInfo(string param0);
    internal static bool MessageLogWarningIsEnabled();
    internal static bool MessageLogWarning(string param0);
    internal static bool MessageLogEventSizeExceededIsEnabled();
    internal static void MessageLogEventSizeExceeded();
    internal static bool ResumeSignpostEventIsEnabled();
    internal static void ResumeSignpostEvent(TraceRecord traceRecord);
    internal static bool StartSignpostEventIsEnabled();
    internal static void StartSignpostEvent(TraceRecord traceRecord);
    internal static bool StopSignpostEventIsEnabled();
    internal static void StopSignpostEvent(TraceRecord traceRecord);
    internal static bool SuspendSignpostEventIsEnabled();
    internal static void SuspendSignpostEvent(TraceRecord traceRecord);
    internal static bool ServiceChannelCallStopIsEnabled();
    internal static void ServiceChannelCallStop(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination);
    internal static bool ServiceExceptionIsEnabled();
    internal static void ServiceException(EventTraceActivity eventTraceActivity, string ExceptionToString, string ExceptionTypeName);
    internal static bool OperationFailedIsEnabled();
    internal static void OperationFailed(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    internal static bool OperationFaultedIsEnabled();
    internal static void OperationFaulted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    internal static bool MessageThrottleAtSeventyPercentIsEnabled();
    internal static void MessageThrottleAtSeventyPercent(string ThrottleName, long Limit);
    internal static bool MessageReceivedFromTransportIsEnabled();
    internal static void MessageReceivedFromTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId, string reference);
    internal static bool MessageSentToTransportIsEnabled();
    internal static void MessageSentToTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId);
    internal static bool ServiceHostOpenStartIsEnabled();
    internal static void ServiceHostOpenStart(EventTraceActivity eventTraceActivity);
    internal static bool ServiceHostOpenStopIsEnabled();
    internal static void ServiceHostOpenStop(EventTraceActivity eventTraceActivity);
    internal static bool ServiceChannelOpenStartIsEnabled();
    internal static void ServiceChannelOpenStart(EventTraceActivity eventTraceActivity);
    internal static bool ServiceChannelOpenStopIsEnabled();
    internal static void ServiceChannelOpenStop(EventTraceActivity eventTraceActivity);
    internal static bool ServiceChannelCallStartIsEnabled();
    internal static void ServiceChannelCallStart(EventTraceActivity eventTraceActivity);
    internal static bool ServiceChannelBeginCallStartIsEnabled();
    internal static void ServiceChannelBeginCallStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpSendMessageStartIsEnabled();
    internal static void HttpSendMessageStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpSendStopIsEnabled();
    internal static void HttpSendStop(EventTraceActivity eventTraceActivity);
    internal static bool HttpMessageReceiveStartIsEnabled();
    internal static void HttpMessageReceiveStart(EventTraceActivity eventTraceActivity);
    internal static bool DispatchMessageStartIsEnabled();
    internal static void DispatchMessageStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpContextBeforeProcessAuthenticationIsEnabled();
    internal static void HttpContextBeforeProcessAuthentication(EventTraceActivity eventTraceActivity);
    internal static bool DispatchMessageBeforeAuthorizationIsEnabled();
    internal static void DispatchMessageBeforeAuthorization(EventTraceActivity eventTraceActivity);
    internal static bool DispatchMessageStopIsEnabled();
    internal static void DispatchMessageStop(EventTraceActivity eventTraceActivity);
    internal static bool ClientChannelOpenStartIsEnabled();
    internal static void ClientChannelOpenStart(EventTraceActivity eventTraceActivity);
    internal static bool ClientChannelOpenStopIsEnabled();
    internal static void ClientChannelOpenStop(EventTraceActivity eventTraceActivity);
    internal static bool HttpSendStreamedMessageStartIsEnabled();
    internal static void HttpSendStreamedMessageStart(EventTraceActivity eventTraceActivity);
    internal static bool ReceiveContextAbandonFailedIsEnabled();
    internal static void ReceiveContextAbandonFailed(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ReceiveContextAbandonWithExceptionIsEnabled();
    internal static void ReceiveContextAbandonWithException(EventTraceActivity eventTraceActivity, string TypeName, string ExceptionToString);
    internal static bool ReceiveContextCompleteFailedIsEnabled();
    internal static void ReceiveContextCompleteFailed(EventTraceActivity eventTraceActivity, string TypeName);
    internal static bool ReceiveContextFaultedIsEnabled();
    internal static void ReceiveContextFaulted(EventTraceActivity eventTraceActivity, object source);
    internal static bool ClientBaseCachedChannelFactoryCountIsEnabled();
    internal static void ClientBaseCachedChannelFactoryCount(int Count, int MaxNum, object source);
    internal static bool ClientBaseChannelFactoryAgedOutofCacheIsEnabled();
    internal static void ClientBaseChannelFactoryAgedOutofCache(int Count, object source);
    internal static bool ClientBaseChannelFactoryCacheHitIsEnabled();
    internal static void ClientBaseChannelFactoryCacheHit(object source);
    internal static bool ClientBaseUsingLocalChannelFactoryIsEnabled();
    internal static void ClientBaseUsingLocalChannelFactory(object source);
    internal static bool QueryCompositionExecutedIsEnabled();
    internal static void QueryCompositionExecuted(EventTraceActivity eventTraceActivity, string TypeName, string Uri, object source);
    internal static bool DispatchFailedIsEnabled();
    internal static void DispatchFailed(EventTraceActivity eventTraceActivity, string OperationName);
    internal static bool DispatchSuccessfulIsEnabled();
    internal static void DispatchSuccessful(EventTraceActivity eventTraceActivity, string OperationName);
    internal static bool MessageReadByEncoderIsEnabled();
    internal static void MessageReadByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    internal static bool MessageWrittenByEncoderIsEnabled();
    internal static void MessageWrittenByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    internal static bool SessionIdleTimeoutIsEnabled();
    internal static void SessionIdleTimeout(string RemoteAddress);
    internal static bool SocketAcceptEnqueuedIsEnabled();
    internal static void SocketAcceptEnqueued(EventTraceActivity eventTraceActivity);
    internal static bool SocketAcceptedIsEnabled();
    internal static void SocketAccepted(EventTraceActivity eventTraceActivity, int ListenerHashCode, int SocketHashCode);
    internal static bool ConnectionPoolMissIsEnabled();
    internal static void ConnectionPoolMiss(string PoolKey, int busy);
    internal static bool DispatchFormatterDeserializeRequestStartIsEnabled();
    internal static void DispatchFormatterDeserializeRequestStart(EventTraceActivity eventTraceActivity);
    internal static bool DispatchFormatterDeserializeRequestStopIsEnabled();
    internal static void DispatchFormatterDeserializeRequestStop(EventTraceActivity eventTraceActivity);
    internal static bool DispatchFormatterSerializeReplyStartIsEnabled();
    internal static void DispatchFormatterSerializeReplyStart(EventTraceActivity eventTraceActivity);
    internal static bool DispatchFormatterSerializeReplyStopIsEnabled();
    internal static void DispatchFormatterSerializeReplyStop(EventTraceActivity eventTraceActivity);
    internal static bool ClientFormatterSerializeRequestStartIsEnabled();
    internal static void ClientFormatterSerializeRequestStart(EventTraceActivity eventTraceActivity);
    internal static bool ClientFormatterSerializeRequestStopIsEnabled();
    internal static void ClientFormatterSerializeRequestStop(EventTraceActivity eventTraceActivity);
    internal static bool ClientFormatterDeserializeReplyStartIsEnabled();
    internal static void ClientFormatterDeserializeReplyStart(EventTraceActivity eventTraceActivity);
    internal static bool ClientFormatterDeserializeReplyStopIsEnabled();
    internal static void ClientFormatterDeserializeReplyStop(EventTraceActivity eventTraceActivity);
    internal static bool SecurityNegotiationStartIsEnabled();
    internal static void SecurityNegotiationStart(EventTraceActivity eventTraceActivity);
    internal static bool SecurityNegotiationStopIsEnabled();
    internal static void SecurityNegotiationStop(EventTraceActivity eventTraceActivity);
    internal static bool SecurityTokenProviderOpenedIsEnabled();
    internal static void SecurityTokenProviderOpened(EventTraceActivity eventTraceActivity);
    internal static bool OutgoingMessageSecuredIsEnabled();
    internal static void OutgoingMessageSecured(EventTraceActivity eventTraceActivity);
    internal static bool IncomingMessageVerifiedIsEnabled();
    internal static void IncomingMessageVerified(EventTraceActivity eventTraceActivity);
    internal static bool GetServiceInstanceStartIsEnabled();
    internal static void GetServiceInstanceStart(EventTraceActivity eventTraceActivity);
    internal static bool GetServiceInstanceStopIsEnabled();
    internal static void GetServiceInstanceStop(EventTraceActivity eventTraceActivity);
    internal static bool ChannelReceiveStartIsEnabled();
    internal static void ChannelReceiveStart(EventTraceActivity eventTraceActivity, int ChannelId);
    internal static bool ChannelReceiveStopIsEnabled();
    internal static void ChannelReceiveStop(EventTraceActivity eventTraceActivity, int ChannelId);
    internal static bool ChannelFactoryCreatedIsEnabled();
    internal static void ChannelFactoryCreated(object source);
    internal static bool PipeConnectionAcceptStartIsEnabled();
    internal static void PipeConnectionAcceptStart(EventTraceActivity eventTraceActivity, string uri);
    internal static bool PipeConnectionAcceptStopIsEnabled();
    internal static void PipeConnectionAcceptStop(EventTraceActivity eventTraceActivity);
    internal static bool EstablishConnectionStartIsEnabled();
    internal static void EstablishConnectionStart(EventTraceActivity eventTraceActivity, string Key);
    internal static bool EstablishConnectionStopIsEnabled();
    internal static void EstablishConnectionStop(EventTraceActivity eventTraceActivity);
    internal static bool SessionPreambleUnderstoodIsEnabled();
    internal static void SessionPreambleUnderstood(string Via);
    internal static bool ConnectionReaderSendFaultIsEnabled();
    internal static void ConnectionReaderSendFault(string FaultString);
    internal static bool SocketAcceptClosedIsEnabled();
    internal static void SocketAcceptClosed(EventTraceActivity eventTraceActivity);
    internal static bool ServiceHostFaultedIsEnabled();
    internal static void ServiceHostFaulted(EventTraceActivity eventTraceActivity, object source);
    internal static bool ListenerOpenStartIsEnabled();
    internal static void ListenerOpenStart(EventTraceActivity eventTraceActivity, string Uri, Guid relatedActivityId);
    internal static bool ListenerOpenStopIsEnabled();
    internal static void ListenerOpenStop(EventTraceActivity eventTraceActivity);
    internal static bool ServerMaxPooledConnectionsQuotaReachedIsEnabled();
    internal static void ServerMaxPooledConnectionsQuotaReached();
    internal static bool TcpConnectionTimedOutIsEnabled();
    internal static void TcpConnectionTimedOut(int SocketId, string Uri);
    internal static bool TcpConnectionResetErrorIsEnabled();
    internal static void TcpConnectionResetError(int SocketId, string Uri);
    internal static bool ServiceSecurityNegotiationCompletedIsEnabled();
    internal static void ServiceSecurityNegotiationCompleted(EventTraceActivity eventTraceActivity);
    internal static bool SecurityNegotiationProcessingFailureIsEnabled();
    internal static void SecurityNegotiationProcessingFailure(EventTraceActivity eventTraceActivity);
    internal static bool SecurityIdentityVerificationSuccessIsEnabled();
    internal static void SecurityIdentityVerificationSuccess(EventTraceActivity eventTraceActivity);
    internal static bool SecurityIdentityVerificationFailureIsEnabled();
    internal static void SecurityIdentityVerificationFailure(EventTraceActivity eventTraceActivity);
    internal static bool PortSharingDuplicatedSocketIsEnabled();
    internal static void PortSharingDuplicatedSocket(EventTraceActivity eventTraceActivity, string Uri);
    internal static bool SecurityImpersonationSuccessIsEnabled();
    internal static void SecurityImpersonationSuccess(EventTraceActivity eventTraceActivity);
    internal static bool SecurityImpersonationFailureIsEnabled();
    internal static void SecurityImpersonationFailure(EventTraceActivity eventTraceActivity);
    internal static bool HttpChannelRequestAbortedIsEnabled();
    internal static void HttpChannelRequestAborted(EventTraceActivity eventTraceActivity);
    internal static bool HttpChannelResponseAbortedIsEnabled();
    internal static void HttpChannelResponseAborted(EventTraceActivity eventTraceActivity);
    internal static bool HttpAuthFailedIsEnabled();
    internal static void HttpAuthFailed(EventTraceActivity eventTraceActivity);
    internal static bool SharedListenerProxyRegisterStartIsEnabled();
    internal static void SharedListenerProxyRegisterStart(string Uri);
    internal static bool SharedListenerProxyRegisterStopIsEnabled();
    internal static void SharedListenerProxyRegisterStop();
    internal static bool SharedListenerProxyRegisterFailedIsEnabled();
    internal static void SharedListenerProxyRegisterFailed(string Status);
    internal static bool ConnectionPoolPreambleFailedIsEnabled();
    internal static void ConnectionPoolPreambleFailed(EventTraceActivity eventTraceActivity);
    internal static bool SslOnInitiateUpgradeIsEnabled();
    internal static void SslOnInitiateUpgrade();
    internal static bool SslOnAcceptUpgradeIsEnabled();
    internal static void SslOnAcceptUpgrade(EventTraceActivity eventTraceActivity);
    internal static bool BinaryMessageEncodingStartIsEnabled();
    internal static void BinaryMessageEncodingStart(EventTraceActivity eventTraceActivity);
    internal static bool MtomMessageEncodingStartIsEnabled();
    internal static void MtomMessageEncodingStart(EventTraceActivity eventTraceActivity);
    internal static bool TextMessageEncodingStartIsEnabled();
    internal static void TextMessageEncodingStart(EventTraceActivity eventTraceActivity);
    internal static bool BinaryMessageDecodingStartIsEnabled();
    internal static void BinaryMessageDecodingStart();
    internal static bool MtomMessageDecodingStartIsEnabled();
    internal static void MtomMessageDecodingStart();
    internal static bool TextMessageDecodingStartIsEnabled();
    internal static void TextMessageDecodingStart();
    internal static bool HttpResponseReceiveStartIsEnabled();
    internal static void HttpResponseReceiveStart(EventTraceActivity eventTraceActivity);
    internal static bool SocketReadStopIsEnabled();
    internal static void SocketReadStop(int SocketId, int Size, string Endpoint);
    internal static bool SocketAsyncReadStopIsEnabled();
    internal static void SocketAsyncReadStop(int SocketId, int Size, string Endpoint);
    internal static bool SocketWriteStartIsEnabled();
    internal static void SocketWriteStart(int SocketId, int Size, string Endpoint);
    internal static bool SocketAsyncWriteStartIsEnabled();
    internal static void SocketAsyncWriteStart(int SocketId, int Size, string Endpoint);
    internal static bool SequenceAcknowledgementSentIsEnabled();
    internal static void SequenceAcknowledgementSent(string SessionId);
    internal static bool ClientReliableSessionReconnectIsEnabled();
    internal static void ClientReliableSessionReconnect(string SessionId);
    internal static bool ReliableSessionChannelFaultedIsEnabled();
    internal static void ReliableSessionChannelFaulted(string SessionId);
    internal static bool WindowsStreamSecurityOnInitiateUpgradeIsEnabled();
    internal static void WindowsStreamSecurityOnInitiateUpgrade();
    internal static bool WindowsStreamSecurityOnAcceptUpgradeIsEnabled();
    internal static void WindowsStreamSecurityOnAcceptUpgrade(EventTraceActivity eventTraceActivity);
    internal static bool SocketConnectionAbortIsEnabled();
    internal static void SocketConnectionAbort(int SocketId);
    internal static bool HttpGetContextStartIsEnabled();
    internal static void HttpGetContextStart(EventTraceActivity eventTraceActivity);
    internal static bool ClientSendPreambleStartIsEnabled();
    internal static void ClientSendPreambleStart(EventTraceActivity eventTraceActivity);
    internal static bool ClientSendPreambleStopIsEnabled();
    internal static void ClientSendPreambleStop(EventTraceActivity eventTraceActivity);
    internal static bool HttpMessageReceiveFailedIsEnabled();
    internal static void HttpMessageReceiveFailed();
    internal static bool TransactionScopeCreateIsEnabled();
    internal static void TransactionScopeCreate(EventTraceActivity eventTraceActivity, string LocalId, Guid Distributed);
    internal static bool StreamedMessageReadByEncoderIsEnabled();
    internal static void StreamedMessageReadByEncoder(EventTraceActivity eventTraceActivity);
    internal static bool StreamedMessageWrittenByEncoderIsEnabled();
    internal static void StreamedMessageWrittenByEncoder(EventTraceActivity eventTraceActivity);
    internal static bool MessageWrittenAsynchronouslyByEncoderIsEnabled();
    internal static void MessageWrittenAsynchronouslyByEncoder(EventTraceActivity eventTraceActivity);
    internal static bool BufferedAsyncWriteStartIsEnabled();
    internal static void BufferedAsyncWriteStart(EventTraceActivity eventTraceActivity, int BufferId, int Size);
    internal static bool BufferedAsyncWriteStopIsEnabled();
    internal static void BufferedAsyncWriteStop(EventTraceActivity eventTraceActivity);
    internal static bool ChannelInitializationTimeoutIsEnabled();
    internal static void ChannelInitializationTimeout(string param0);
    internal static bool CloseTimeoutIsEnabled();
    internal static void CloseTimeout(string param0);
    internal static bool IdleTimeoutIsEnabled();
    internal static void IdleTimeout(string msg, string key);
    internal static bool LeaseTimeoutIsEnabled();
    internal static void LeaseTimeout(string msg, string key);
    internal static bool OpenTimeoutIsEnabled();
    internal static void OpenTimeout(string param0);
    internal static bool ReceiveTimeoutIsEnabled();
    internal static void ReceiveTimeout(string param0);
    internal static bool SendTimeoutIsEnabled();
    internal static void SendTimeout(string param0);
    internal static bool InactivityTimeoutIsEnabled();
    internal static void InactivityTimeout(string param0);
    internal static bool MaxReceivedMessageSizeExceededIsEnabled();
    internal static void MaxReceivedMessageSizeExceeded(string param0);
    internal static bool MaxSentMessageSizeExceededIsEnabled();
    internal static void MaxSentMessageSizeExceeded(string param0);
    internal static bool MaxOutboundConnectionsPerEndpointExceededIsEnabled();
    internal static void MaxOutboundConnectionsPerEndpointExceeded(string param0);
    internal static bool MaxPendingConnectionsExceededIsEnabled();
    internal static void MaxPendingConnectionsExceeded(string param0);
    internal static bool NegotiateTokenAuthenticatorStateCacheExceededIsEnabled();
    internal static void NegotiateTokenAuthenticatorStateCacheExceeded(string msg);
    internal static bool NegotiateTokenAuthenticatorStateCacheRatioIsEnabled();
    internal static void NegotiateTokenAuthenticatorStateCacheRatio(int cur, int max);
    internal static bool SecuritySessionRatioIsEnabled();
    internal static void SecuritySessionRatio(int cur, int max);
    internal static bool PendingConnectionsRatioIsEnabled();
    internal static void PendingConnectionsRatio(int cur, int max);
    internal static bool OutboundConnectionsPerEndpointRatioIsEnabled();
    internal static void OutboundConnectionsPerEndpointRatio(int cur, int max);
    internal static bool ConcurrentInstancesRatioIsEnabled();
    internal static void ConcurrentInstancesRatio(int cur, int max);
    internal static bool ConcurrentSessionsRatioIsEnabled();
    internal static void ConcurrentSessionsRatio(int cur, int max);
    internal static bool ConcurrentCallsRatioIsEnabled();
    internal static void ConcurrentCallsRatio(int cur, int max);
    internal static bool PendingAcceptsAtZeroIsEnabled();
    internal static void PendingAcceptsAtZero();
    internal static bool MaxSessionSizeReachedIsEnabled();
    internal static void MaxSessionSizeReached(string param0);
    internal static bool ReceiveRetryCountReachedIsEnabled();
    internal static void ReceiveRetryCountReached(string param0);
    internal static bool MaxRetryCyclesExceededMsmqIsEnabled();
    internal static void MaxRetryCyclesExceededMsmq(string param0);
    internal static bool ReadPoolMissIsEnabled();
    internal static void ReadPoolMiss(string itemTypeName);
    internal static bool WritePoolMissIsEnabled();
    internal static void WritePoolMiss(string itemTypeName);
    internal static bool MaxRetryCyclesExceededIsEnabled();
    internal static void MaxRetryCyclesExceeded(string param0);
    internal static bool PipeSharedMemoryCreatedIsEnabled();
    internal static void PipeSharedMemoryCreated(string sharedMemoryName);
    internal static bool NamedPipeCreatedIsEnabled();
    internal static void NamedPipeCreated(string pipeName);
    internal static bool EncryptedDataProcessingStartIsEnabled();
    internal static void EncryptedDataProcessingStart(EventTraceActivity eventTraceActivity);
    internal static bool EncryptedDataProcessingSuccessIsEnabled();
    internal static void EncryptedDataProcessingSuccess(EventTraceActivity eventTraceActivity);
    internal static bool SignatureVerificationStartIsEnabled();
    internal static void SignatureVerificationStart(EventTraceActivity eventTraceActivity);
    internal static bool SignatureVerificationSuccessIsEnabled();
    internal static void SignatureVerificationSuccess(EventTraceActivity eventTraceActivity);
    internal static bool WrappedKeyDecryptionStartIsEnabled();
    internal static void WrappedKeyDecryptionStart(EventTraceActivity eventTraceActivity);
    internal static bool WrappedKeyDecryptionSuccessIsEnabled();
    internal static void WrappedKeyDecryptionSuccess(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineProcessInboundRequestStartIsEnabled();
    internal static void HttpPipelineProcessInboundRequestStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineBeginProcessInboundRequestStartIsEnabled();
    internal static void HttpPipelineBeginProcessInboundRequestStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineProcessInboundRequestStopIsEnabled();
    internal static void HttpPipelineProcessInboundRequestStop(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineFaultedIsEnabled();
    internal static void HttpPipelineFaulted(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineTimeoutExceptionIsEnabled();
    internal static void HttpPipelineTimeoutException(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineProcessResponseStartIsEnabled();
    internal static void HttpPipelineProcessResponseStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineBeginProcessResponseStartIsEnabled();
    internal static void HttpPipelineBeginProcessResponseStart(EventTraceActivity eventTraceActivity);
    internal static bool HttpPipelineProcessResponseStopIsEnabled();
    internal static void HttpPipelineProcessResponseStop(EventTraceActivity eventTraceActivity);
    internal static bool WebSocketConnectionRequestSendStartIsEnabled();
    internal static void WebSocketConnectionRequestSendStart(EventTraceActivity eventTraceActivity, string remoteAddress);
    internal static bool WebSocketConnectionRequestSendStopIsEnabled();
    internal static void WebSocketConnectionRequestSendStop(EventTraceActivity eventTraceActivity, int websocketId);
    internal static bool WebSocketConnectionAcceptStartIsEnabled();
    internal static void WebSocketConnectionAcceptStart(EventTraceActivity eventTraceActivity);
    internal static bool WebSocketConnectionAcceptedIsEnabled();
    internal static void WebSocketConnectionAccepted(EventTraceActivity eventTraceActivity, int websocketId);
    internal static bool WebSocketConnectionDeclinedIsEnabled();
    internal static void WebSocketConnectionDeclined(EventTraceActivity eventTraceActivity, string errorMessage);
    internal static bool WebSocketConnectionFailedIsEnabled();
    internal static void WebSocketConnectionFailed(EventTraceActivity eventTraceActivity, string errorMessage);
    internal static bool WebSocketConnectionAbortedIsEnabled();
    internal static void WebSocketConnectionAborted(EventTraceActivity eventTraceActivity, int websocketId);
    internal static bool WebSocketAsyncWriteStartIsEnabled();
    internal static void WebSocketAsyncWriteStart(int websocketId, int byteCount, string remoteAddress);
    internal static bool WebSocketAsyncWriteStopIsEnabled();
    internal static void WebSocketAsyncWriteStop(int websocketId);
    internal static bool WebSocketAsyncReadStartIsEnabled();
    internal static void WebSocketAsyncReadStart(int websocketId);
    internal static bool WebSocketAsyncReadStopIsEnabled();
    internal static void WebSocketAsyncReadStop(int websocketId, int byteCount, string remoteAddress);
    internal static bool WebSocketCloseSentIsEnabled();
    internal static void WebSocketCloseSent(int websocketId, string remoteAddress, string closeStatus);
    internal static bool WebSocketCloseOutputSentIsEnabled();
    internal static void WebSocketCloseOutputSent(int websocketId, string remoteAddress, string closeStatus);
    internal static bool WebSocketConnectionClosedIsEnabled();
    internal static void WebSocketConnectionClosed(int websocketId);
    internal static bool WebSocketCloseStatusReceivedIsEnabled();
    internal static void WebSocketCloseStatusReceived(int websocketId, string closeStatus);
    internal static bool WebSocketUseVersionFromClientWebSocketFactoryIsEnabled();
    internal static void WebSocketUseVersionFromClientWebSocketFactory(EventTraceActivity eventTraceActivity, string clientWebSocketFactoryType);
    internal static bool WebSocketCreateClientWebSocketWithFactoryIsEnabled();
    internal static void WebSocketCreateClientWebSocketWithFactory(EventTraceActivity eventTraceActivity, string clientWebSocketFactoryType);
}
internal class System.ServiceModel.Diagnostics.ChannelTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal ChannelTraceRecord(IChannel channel);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.CollectionTraceRecord : TraceRecord {
    internal string EventId { get; }
    public CollectionTraceRecord(string collectionName, string elementName, IEnumerable entries);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.DefaultPerformanceCounters : PerformanceCountersBase {
    internal PerformanceCounter[] Counters { get; internal set; }
    internal string InstanceName { get; }
    internal String[] CounterNames { get; }
    internal int PerfCounterStart { get; }
    internal int PerfCounterEnd { get; }
    internal bool Initialized { get; }
    internal DefaultPerformanceCounters(ServiceHostBase serviceHost);
    [CompilerGeneratedAttribute]
internal PerformanceCounter[] get_Counters();
    [CompilerGeneratedAttribute]
internal void set_Counters(PerformanceCounter[] value);
    internal virtual string get_InstanceName();
    internal virtual String[] get_CounterNames();
    internal virtual int get_PerfCounterStart();
    internal virtual int get_PerfCounterEnd();
    internal static string CreateFriendlyInstanceName(ServiceHostBase serviceHost);
    internal virtual bool get_Initialized();
    protected virtual void Dispose(bool disposing);
}
internal class System.ServiceModel.Diagnostics.EndpointPerformanceCounters : EndpointPerformanceCountersBase {
    internal PerformanceCounter[] Counters { get; internal set; }
    internal bool Initialized { get; }
    internal EndpointPerformanceCounters(string service, string contract, string uri);
    [CompilerGeneratedAttribute]
internal PerformanceCounter[] get_Counters();
    [CompilerGeneratedAttribute]
internal void set_Counters(PerformanceCounter[] value);
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void SessionFaulted();
    internal virtual void MessageDropped();
    internal virtual void TxFlowed();
    internal virtual bool get_Initialized();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Diagnostics.EndpointPerformanceCountersBase : PerformanceCountersBase {
    protected string instanceName;
    protected static String[] perfCounterNames;
    internal string InstanceName { get; }
    internal String[] CounterNames { get; }
    internal int PerfCounterStart { get; }
    internal int PerfCounterEnd { get; }
    internal EndpointPerformanceCountersBase(string service, string contract, string uri);
    private static EndpointPerformanceCountersBase();
    internal static string CreateFriendlyInstanceName(string service, string contract, string uri);
    internal static string GetFriendlyInstanceName(string service, string contract, string uri);
    internal virtual string get_InstanceName();
    internal virtual String[] get_CounterNames();
    internal virtual int get_PerfCounterStart();
    internal virtual int get_PerfCounterEnd();
    internal abstract virtual void MethodCalled();
    internal abstract virtual void MethodReturnedSuccess();
    internal abstract virtual void MethodReturnedError();
    internal abstract virtual void MethodReturnedFault();
    internal abstract virtual void SaveCallDuration(long time);
    internal abstract virtual void AuthenticationFailed();
    internal abstract virtual void AuthorizationFailed();
    internal abstract virtual void SessionFaulted();
    internal abstract virtual void MessageDropped();
    internal abstract virtual void TxFlowed();
}
internal class System.ServiceModel.Diagnostics.EndpointPerformanceCountersV2 : EndpointPerformanceCountersBase {
    internal bool Initialized { get; }
    internal EndpointPerformanceCountersV2(string service, string contract, string uri);
    private static EndpointPerformanceCountersV2();
    internal static void EnsureCounterSet();
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void SessionFaulted();
    internal virtual void MessageDropped();
    internal virtual void TxFlowed();
    internal virtual bool get_Initialized();
    internal void DeleteInstance();
    protected virtual void Dispose(bool disposing);
    internal static void CleanupCache();
}
internal static class System.ServiceModel.Diagnostics.EventTraceActivityHelper : object {
    public static bool TryAttachActivity(Message message, EventTraceActivity activity);
    public static EventTraceActivity TryExtractActivity(Message message);
    public static EventTraceActivity TryExtractActivity(Message message, bool createIfNotExist);
    [SecurityCriticalAttribute]
internal static void SetOnThread(EventTraceActivity eventTraceActivity);
}
internal class System.ServiceModel.Diagnostics.HttpErrorTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal HttpErrorTraceRecord(string html);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.HttpListenerRequestTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal HttpListenerRequestTraceRecord(HttpListenerRequest request);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.MessageDroppedTraceRecord : MessageTraceRecord {
    internal string EventId { get; }
    internal MessageDroppedTraceRecord(Message message, EndpointAddress endpointAddress);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.MessageHeaderInfoTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal MessageHeaderInfoTraceRecord(MessageHeaderInfo messageHeaderInfo);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal static class System.ServiceModel.Diagnostics.MessageLogger : object {
    internal static bool LogKnownPii { get; internal set; }
    internal static bool LogMalformedMessages { get; internal set; }
    internal static bool LogMessagesAtServiceLevel { get; internal set; }
    internal static bool LogMessagesAtTransportLevel { get; internal set; }
    internal static bool LogMessageBody { get; internal set; }
    internal static bool LoggingEnabled { get; }
    internal static int MaxMessageSize { get; internal set; }
    internal static int MaxNumberOfMessagesToLog { get; internal set; }
    internal static bool ShouldLogMalformed { get; }
    internal static TraceSource MessageTraceSource { get; }
    private static MessageLogger();
    internal static bool get_LogKnownPii();
    internal static void set_LogKnownPii(bool value);
    internal static bool get_LogMalformedMessages();
    internal static void set_LogMalformedMessages(bool value);
    internal static bool get_LogMessagesAtServiceLevel();
    internal static void set_LogMessagesAtServiceLevel(bool value);
    internal static bool get_LogMessagesAtTransportLevel();
    internal static void set_LogMessagesAtTransportLevel(bool value);
    internal static bool get_LogMessageBody();
    internal static void set_LogMessageBody(bool value);
    internal static bool get_LoggingEnabled();
    internal static int get_MaxMessageSize();
    internal static void set_MaxMessageSize(int value);
    internal static int get_MaxNumberOfMessagesToLog();
    internal static void set_MaxNumberOfMessagesToLog(int value);
    internal static bool get_ShouldLogMalformed();
    internal static void LogMessage(MessageLoggingSource source, string data);
    internal static void LogMessage(Stream stream, MessageLoggingSource source);
    internal static void LogMessage(ArraySegment`1<byte> buffer, MessageLoggingSource source);
    internal static void LogMessage(Message& message, XmlReader reader, MessageLoggingSource source);
    internal static void LogMessage(Message& message, MessageLoggingSource source);
    internal static TraceSource get_MessageTraceSource();
    internal static void EnsureInitialized();
}
internal class System.ServiceModel.Diagnostics.MessageLoggingFilterTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal MessageLoggingFilterTraceRecord(XPathMessageFilter filter);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
[FlagsAttribute]
internal enum System.ServiceModel.Diagnostics.MessageLoggingSource : Enum {
    public int value__;
    public static MessageLoggingSource None;
    public static MessageLoggingSource TransportReceive;
    public static MessageLoggingSource TransportSend;
    public static MessageLoggingSource Transport;
    public static MessageLoggingSource ServiceLevelReceiveDatagram;
    public static MessageLoggingSource ServiceLevelSendDatagram;
    public static MessageLoggingSource ServiceLevelReceiveRequest;
    public static MessageLoggingSource ServiceLevelSendRequest;
    public static MessageLoggingSource ServiceLevelReceiveReply;
    public static MessageLoggingSource ServiceLevelSendReply;
    public static MessageLoggingSource ServiceLevelReceive;
    public static MessageLoggingSource ServiceLevelSend;
    public static MessageLoggingSource ServiceLevelService;
    public static MessageLoggingSource ServiceLevelProxy;
    public static MessageLoggingSource ServiceLevel;
    public static MessageLoggingSource Malformed;
    public static MessageLoggingSource LastChance;
    public static MessageLoggingSource All;
}
internal class System.ServiceModel.Diagnostics.MessageLogTraceRecord : TraceRecord {
    internal static string AddressingElementName;
    internal static string BodyElementName;
    internal static string HttpRequestMessagePropertyElementName;
    internal static string HttpResponseMessagePropertyElementName;
    internal static string NamespaceUri;
    internal static string NamespacePrefix;
    internal static string MessageHeaderElementName;
    internal static string MessageHeadersElementName;
    internal static string MessageLogTraceRecordElementName;
    internal static string MethodElementName;
    internal static string QueryStringElementName;
    internal static string StatusCodeElementName;
    internal static string StatusDescriptionElementName;
    internal static string TraceTimeAttributeName;
    internal static string TypeElementName;
    internal static string WebHeadersElementName;
    public Message Message { get; }
    public MessageLoggingSource MessageLoggingSource { get; }
    internal MessageLogTraceRecord(ArraySegment`1<byte> buffer, MessageLoggingSource source);
    internal MessageLogTraceRecord(string message, MessageLoggingSource source);
    internal MessageLogTraceRecord(Stream stream, MessageLoggingSource source);
    internal MessageLogTraceRecord(Message& message, XmlReader reader, MessageLoggingSource source, bool logMessageBody);
    public Message get_Message();
    public MessageLoggingSource get_MessageLoggingSource();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.MessageTraceRecord : TraceRecord {
    internal string EventId { get; }
    protected Message Message { get; }
    internal MessageTraceRecord(Message message);
    internal virtual string get_EventId();
    protected Message get_Message();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.MessageTransmitTraceRecord : MessageTraceRecord {
    internal string EventId { get; }
    internal virtual string get_EventId();
    internal static MessageTransmitTraceRecord CreateSendTraceRecord(Message message, EndpointAddress address);
    internal static MessageTransmitTraceRecord CreateReceiveTraceRecord(Message message, Uri uri);
    internal static MessageTransmitTraceRecord CreateReceiveTraceRecord(Message message, EndpointAddress address);
    internal static MessageTransmitTraceRecord CreateReceiveTraceRecord(Message message);
    internal virtual void WriteTo(XmlWriter xml);
}
internal static class System.ServiceModel.Diagnostics.OperationInvokerTrace : object {
    internal static SourceSwitch CodeGenerationSwitch { get; }
    internal static MethodInfo TraceInstructionMethod { get; }
    internal static SourceSwitch get_CodeGenerationSwitch();
    internal static void WriteInstruction(int lineNumber, string instruction);
    internal static MethodInfo get_TraceInstructionMethod();
    internal static void TraceInstruction(string instruction);
}
internal class System.ServiceModel.Diagnostics.OperationPerformanceCounters : OperationPerformanceCountersBase {
    internal PerformanceCounter[] Counters { get; internal set; }
    internal bool Initialized { get; }
    internal OperationPerformanceCounters(string service, string contract, string operationName, string uri);
    [CompilerGeneratedAttribute]
internal PerformanceCounter[] get_Counters();
    [CompilerGeneratedAttribute]
internal void set_Counters(PerformanceCounter[] value);
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void TxFlowed();
    internal virtual bool get_Initialized();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Diagnostics.OperationPerformanceCountersBase : PerformanceCountersBase {
    protected string instanceName;
    protected string operationName;
    protected static String[] perfCounterNames;
    internal string InstanceName { get; }
    internal string OperationName { get; }
    internal String[] CounterNames { get; }
    internal int PerfCounterStart { get; }
    internal int PerfCounterEnd { get; }
    internal OperationPerformanceCountersBase(string service, string contract, string operationName, string uri);
    private static OperationPerformanceCountersBase();
    internal static string CreateFriendlyInstanceName(string service, string contract, string operation, string uri);
    internal static string GetFriendlyInstanceName(string service, string contract, string operation, string uri);
    internal virtual string get_InstanceName();
    internal string get_OperationName();
    internal virtual String[] get_CounterNames();
    internal virtual int get_PerfCounterStart();
    internal virtual int get_PerfCounterEnd();
    internal abstract virtual void MethodCalled();
    internal abstract virtual void MethodReturnedSuccess();
    internal abstract virtual void MethodReturnedError();
    internal abstract virtual void MethodReturnedFault();
    internal abstract virtual void SaveCallDuration(long time);
    internal abstract virtual void AuthenticationFailed();
    internal abstract virtual void AuthorizationFailed();
    internal abstract virtual void TxFlowed();
}
internal class System.ServiceModel.Diagnostics.OperationPerformanceCountersV2 : OperationPerformanceCountersBase {
    internal bool Initialized { get; }
    internal OperationPerformanceCountersV2(string service, string contract, string operationName, string uri);
    private static OperationPerformanceCountersV2();
    internal static void EnsureCounterSet();
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void TxFlowed();
    internal virtual bool get_Initialized();
    internal void DeleteInstance();
    protected virtual void Dispose(bool disposing);
    internal static void CleanupCache();
}
internal class System.ServiceModel.Diagnostics.PeerAuthenticationFailureTraceRecord : PeerSecurityTraceRecord {
    internal string EventId { get; }
    public PeerAuthenticationFailureTraceRecord(string meshId, string remoteAddress, ClaimSet claimSet, Exception e);
    public PeerAuthenticationFailureTraceRecord(string meshId, string remoteAddress);
    internal virtual string get_EventId();
}
internal class System.ServiceModel.Diagnostics.PeerFlooderTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PeerFlooderTraceRecord(string meshId, PeerNodeAddress fromAddress, Exception e);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerMaintainerTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PeerMaintainerTraceRecord(string activity);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerNeighborCloseTraceRecord : PeerNeighborTraceRecord {
    public PeerNeighborCloseTraceRecord(ulong remoteNodeId, ulong localNodeId, PeerNodeAddress listenAddress, IPAddress connectIPAddress, int hashCode, bool initiator, string state, string previousState, string attemptedState, string closeInitiator, string closeReason);
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerNeighborTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PeerNeighborTraceRecord(ulong remoteNodeId, ulong localNodeId, PeerNodeAddress listenAddress, IPAddress connectIPAddress, int hashCode, bool initiator, string state, string previousState, string attemptedState, string action);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerNodeTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PeerNodeTraceRecord(ulong id);
    public PeerNodeTraceRecord(ulong id, string meshId);
    public PeerNodeTraceRecord(ulong id, string meshId, PeerNodeAddress address);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerSecurityTraceRecord : TraceRecord {
    protected string meshId;
    protected string remoteAddress;
    protected ClaimSet claimSet;
    protected PeerSecurityTraceRecord(string meshId, string remoteAddress, ClaimSet claimSet, Exception exception);
    protected PeerSecurityTraceRecord(string meshId, string remoteAddress);
    internal virtual void WriteTo(XmlWriter writer);
    internal static void WriteClaimSet(XmlWriter writer, ClaimSet claimSet);
}
internal class System.ServiceModel.Diagnostics.PeerSignatureFailureTraceRecord : PeerSecurityTraceRecord {
    internal string EventId { get; }
    public PeerSignatureFailureTraceRecord(string meshId, Uri via, ClaimSet claimSet, Exception exception);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PeerThrottleTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PeerThrottleTraceRecord(string meshId, string message);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal static class System.ServiceModel.Diagnostics.PerformanceCounters : object {
    internal static int MaxInstanceNameLength;
    internal static PerformanceCounterScope Scope { get; internal set; }
    internal static bool PerformanceCountersEnabled { get; }
    internal static bool MinimalPerformanceCountersEnabled { get; }
    internal static Dictionary`2<string, ServiceModelPerformanceCounters> PerformanceCountersForEndpoint { get; }
    internal static List`1<ServiceModelPerformanceCounters> PerformanceCountersForEndpointList { get; }
    internal static Dictionary`2<string, ServiceModelPerformanceCountersEntry> PerformanceCountersForBaseUri { get; }
    private static PerformanceCounters();
    internal static PerformanceCounterScope get_Scope();
    internal static void set_Scope(PerformanceCounterScope value);
    internal static bool get_PerformanceCountersEnabled();
    internal static bool get_MinimalPerformanceCountersEnabled();
    internal static PerformanceCounter GetOperationPerformanceCounter(string perfCounterName, string instanceName);
    internal static PerformanceCounter GetEndpointPerformanceCounter(string perfCounterName, string instanceName);
    internal static PerformanceCounter GetServicePerformanceCounter(string perfCounterName, string instanceName);
    internal static PerformanceCounter GetDefaultPerformanceCounter(string perfCounterName, string instanceName);
    internal static PerformanceCounter GetPerformanceCounter(string categoryName, string perfCounterName, string instanceName, PerformanceCounterInstanceLifetime instanceLifetime);
    internal static PerformanceCounter GetPerformanceCounterInternal(string categoryName, string perfCounterName, string instanceName, PerformanceCounterInstanceLifetime instanceLifetime);
    internal static Dictionary`2<string, ServiceModelPerformanceCounters> get_PerformanceCountersForEndpoint();
    internal static List`1<ServiceModelPerformanceCounters> get_PerformanceCountersForEndpointList();
    internal static Dictionary`2<string, ServiceModelPerformanceCountersEntry> get_PerformanceCountersForBaseUri();
    internal static void AddPerformanceCountersForEndpoint(ServiceHostBase serviceHost, ContractDescription contractDescription, EndpointDispatcher endpointDispatcher);
    internal static void ReleasePerformanceCountersForEndpoint(string id, string baseId);
    internal static void ReleasePerformanceCounter(PerformanceCounter& counter);
    internal static void TxFlowed(EndpointDispatcher el, string operation);
    internal static void TxAborted(EndpointDispatcher el, long count);
    internal static void TxCommitted(EndpointDispatcher el, long count);
    internal static void TxInDoubt(EndpointDispatcher el, long count);
    internal static void MethodCalled(string operationName);
    internal static void MethodReturnedSuccess(string operationName);
    internal static void MethodReturnedSuccess(string operationName, long time);
    internal static void MethodReturnedFault(string operationName);
    internal static void MethodReturnedFault(string operationName, long time);
    internal static void MethodReturnedError(string operationName);
    internal static void MethodReturnedError(string operationName, long time);
    internal static void AuthenticationFailed(Message message, Uri listenUri);
    internal static void AuthorizationFailed(string operationName);
    internal static void SessionFaulted(string uri);
    internal static void MessageDropped(string uri);
    internal static void MsmqDroppedMessage(string uri);
    internal static void MsmqPoisonMessage(string uri);
    internal static void MsmqRejectedMessage(string uri);
    internal static EndpointDispatcher GetEndpointDispatcher();
    internal static void TracePerformanceCounterUpdateFailure(string instanceName, string perfCounterName);
}
internal abstract class System.ServiceModel.Diagnostics.PerformanceCountersBase : object {
    protected int disposed;
    internal string InstanceName { get; }
    internal String[] CounterNames { get; }
    internal int PerfCounterStart { get; }
    internal int PerfCounterEnd { get; }
    internal bool Initialized { get; }
    internal abstract virtual string get_InstanceName();
    internal abstract virtual String[] get_CounterNames();
    internal abstract virtual int get_PerfCounterStart();
    internal abstract virtual int get_PerfCounterEnd();
    protected static string EnsureUniqueInstanceName(string categoryName, string instanceName, string fullInstanceName);
    protected static string GetUniqueInstanceName(string categoryName, string instanceName, string fullInstanceName);
    protected static string GetHashedString(string str, int startIndex, int count, bool hashAtEnd);
    internal abstract virtual bool get_Initialized();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.ServiceModel.Diagnostics.PerformanceCounterScope : Enum {
    public int value__;
    public static PerformanceCounterScope Off;
    public static PerformanceCounterScope ServiceOnly;
    public static PerformanceCounterScope All;
    public static PerformanceCounterScope Default;
}
internal static class System.ServiceModel.Diagnostics.PerformanceCounterScopeHelper : object {
    internal static bool IsDefined(PerformanceCounterScope value);
    public static void Validate(PerformanceCounterScope value);
}
internal static class System.ServiceModel.Diagnostics.PerformanceCountersFactory : object {
    private static PerformanceCountersFactory();
    internal static ServicePerformanceCountersBase CreateServiceCounters(ServiceHostBase serviceHost);
    internal static EndpointPerformanceCountersBase CreateEndpointCounters(string service, string contract, string uri);
    internal static OperationPerformanceCountersBase CreateOperationCounters(string service, string contract, string operationName, string uri);
}
internal static class System.ServiceModel.Diagnostics.PerformanceCounterStrings : object {
}
internal class System.ServiceModel.Diagnostics.PerformanceCounterTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal PerformanceCounterTraceRecord(string perfCounterName);
    internal PerformanceCounterTraceRecord(string categoryName, string perfCounterName);
    internal PerformanceCounterTraceRecord(string categoryName, string perfCounterName, string instanceName);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PnrpPeerResolverTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PnrpPeerResolverTraceRecord(string meshId, List`1<PeerNodeAddress> addresses);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PnrpRegisterTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PnrpRegisterTraceRecord(string meshId, PnrpRegistration global, IEnumerable`1<PnrpRegistration> siteEntries, IEnumerable`1<PnrpRegistration> linkEntries);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.PnrpResolveExceptionTraceRecord : TraceRecord {
    internal string EventId { get; }
    public PnrpResolveExceptionTraceRecord(string peerName, string cloudName, Exception exception);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.ReliableChannelTraceRecord : ChannelTraceRecord {
    internal ReliableChannelTraceRecord(IChannel channel, UniqueId id);
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.SecurityTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal SecurityTraceRecord(string traceName);
    internal virtual string get_EventId();
}
internal static class System.ServiceModel.Diagnostics.SecurityTraceRecordHelper : object {
    internal static void TraceRemovedCachedServiceToken(IssuanceTokenProviderBase`1<T> provider, SecurityToken serviceToken);
    internal static void TraceUsingCachedServiceToken(IssuanceTokenProviderBase`1<T> provider, SecurityToken serviceToken, EndpointAddress target);
    internal static void TraceBeginSecurityNegotiation(IssuanceTokenProviderBase`1<T> provider, EndpointAddress target);
    internal static void TraceEndSecurityNegotiation(IssuanceTokenProviderBase`1<T> provider, SecurityToken serviceToken, EndpointAddress target);
    internal static void TraceRedirectApplied(IssuanceTokenProviderBase`1<T> provider, EndpointAddress newTarget, EndpointAddress oldTarget);
    internal static void TraceClientServiceTokenCacheFull(IssuanceTokenProviderBase`1<T> provider, int cacheSize);
    internal static void TraceClientSpnego(WindowsSspiNegotiation windowsNegotiation);
    internal static void TraceServiceSpnego(WindowsSspiNegotiation windowsNegotiation);
    internal static void TraceClientOutgoingSpnego(WindowsSspiNegotiation windowsNegotiation);
    internal static void TraceServiceOutgoingSpnego(WindowsSspiNegotiation windowsNegotiation);
    internal static void TraceNegotiationTokenAuthenticatorAttached(NegotiationTokenAuthenticator`1<T> authenticator, IChannelListener transportChannelListener);
    internal static void TraceServiceSecurityNegotiationCompleted(Message message, NegotiationTokenAuthenticator`1<T> authenticator, SecurityContextSecurityToken serviceToken);
    internal static void TraceServiceSecurityNegotiationFailure(EventTraceActivity eventTraceActivity, NegotiationTokenAuthenticator`1<T> authenticator, Exception e);
    internal static void TraceSecurityContextTokenCacheFull(int capacity, int pruningAmount);
    internal static void TraceIdentityVerificationSuccess(EventTraceActivity eventTraceActivity, EndpointIdentity identity, Claim claim, Type identityVerifier);
    internal static void TraceIdentityVerificationFailure(EndpointIdentity identity, AuthorizationContext authContext, Type identityVerifier);
    internal static void TraceIdentityDeterminationSuccess(EndpointAddress epr, EndpointIdentity identity, Type identityVerifier);
    internal static void TraceIdentityDeterminationFailure(EndpointAddress epr, Type identityVerifier);
    internal static void TraceIdentityHostNameNormalizationFailure(EndpointAddress epr, Type identityVerifier, Exception e);
    internal static void TraceExportChannelBindingEntry();
    internal static void TraceExportChannelBindingExit();
    internal static void TraceImportChannelBindingEntry();
    internal static void TraceImportChannelBindingExit();
    internal static void TraceTokenProviderOpened(EventTraceActivity eventTraceActivity, SecurityTokenProvider provider);
    internal static void TraceTokenProviderClosed(SecurityTokenProvider provider);
    internal static void TraceTokenAuthenticatorOpened(SecurityTokenAuthenticator authenticator);
    internal static void TraceTokenAuthenticatorClosed(SecurityTokenAuthenticator authenticator);
    internal static void TraceOutgoingMessageSecured(SecurityProtocol binding, Message message);
    internal static void TraceIncomingMessageVerified(SecurityProtocol binding, Message message);
    internal static void TraceSecureOutgoingMessageFailure(SecurityProtocol binding, Message message);
    internal static void TraceVerifyIncomingMessageFailure(SecurityProtocol binding, Message message);
    internal static void TraceSpnToSidMappingFailure(string spn, Exception e);
    internal static void TraceSessionRedirectApplied(EndpointAddress previousTarget, EndpointAddress newTarget, GenericXmlSecurityToken sessionToken);
    internal static void TraceCloseMessageSent(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TraceCloseResponseMessageSent(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TraceCloseMessageReceived(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TraceSessionKeyRenewalFault(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TraceRemoteSessionAbortedFault(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TraceCloseResponseReceived(SecurityToken sessionToken, EndpointAddress remoteTarget);
    internal static void TracePreviousSessionKeyDiscarded(SecurityToken previousSessionToken, SecurityToken currentSessionToken, EndpointAddress remoteAddress);
    internal static void TraceSessionKeyRenewed(SecurityToken newSessionToken, SecurityToken currentSessionToken, EndpointAddress remoteAddress);
    internal static void TracePendingSessionAdded(UniqueId sessionId, Uri listenAddress);
    internal static void TracePendingSessionClosed(UniqueId sessionId, Uri listenAddress);
    internal static void TracePendingSessionActivated(UniqueId sessionId, Uri listenAddress);
    internal static void TraceActiveSessionRemoved(UniqueId sessionId, Uri listenAddress);
    internal static void TraceNewServerSessionKeyIssued(SecurityContextSecurityToken newToken, SecurityContextSecurityToken supportingToken, Uri listenAddress);
    internal static void TraceInactiveSessionFaulted(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceServerSessionKeyUpdated(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceServerSessionCloseReceived(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceServerSessionCloseResponseReceived(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceSessionRenewalFaultSent(SecurityContextSecurityToken sessionToken, Uri listenAddress, Message message);
    internal static void TraceSessionAbortedFaultSent(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceSessionClosedResponseSent(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceSessionClosedSent(SecurityContextSecurityToken sessionToken, Uri listenAddress);
    internal static void TraceRenewFaultSendFailure(SecurityContextSecurityToken sessionToken, Uri listenAddress, Exception e);
    internal static void TraceSessionAbortedFaultSendFailure(SecurityContextSecurityToken sessionToken, Uri listenAddress, Exception e);
    internal static void TraceSessionClosedResponseSendFailure(SecurityContextSecurityToken sessionToken, Uri listenAddress, Exception e);
    internal static void TraceSessionCloseSendFailure(SecurityContextSecurityToken sessionToken, Uri listenAddress, Exception e);
    internal static void TraceBeginSecuritySessionOperation(SecuritySessionOperation operation, EndpointAddress target, SecurityToken currentToken);
    internal static void TraceSecuritySessionOperationSuccess(SecuritySessionOperation operation, EndpointAddress target, SecurityToken currentToken, SecurityToken issuedToken);
    internal static void TraceSecuritySessionOperationFailure(SecuritySessionOperation operation, EndpointAddress target, SecurityToken currentToken, Exception e);
    internal static void TraceServerSessionOperationException(SecuritySessionOperation operation, Exception e, Uri listenAddress);
    internal static void TraceImpersonationSucceeded(EventTraceActivity eventTraceActivity, DispatchOperationRuntime operation);
    internal static void TraceImpersonationFailed(EventTraceActivity eventTraceActivity, DispatchOperationRuntime operation, Exception e);
    internal static void WriteClaim(XmlWriter xml, Claim claim);
}
internal class System.ServiceModel.Diagnostics.SequenceFaultedTraceRecord : WsrmTraceRecord {
    internal SequenceFaultedTraceRecord(UniqueId id, string reason);
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.SequenceTraceRecord : WsrmTraceRecord {
    internal SequenceTraceRecord(UniqueId id, long sequenceNumber, bool isLast);
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.ServiceModel.Diagnostics.ServiceConfigurationTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal ServiceConfigurationTraceRecord(ServiceElement serviceElement);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.ServiceModelActivity : object {
    internal ActivityType ActivityType { get; }
    internal ServiceModelActivity PreviousActivity { get; }
    internal static ServiceModelActivity Current { get; private set; }
    internal Guid Id { get; }
    internal string Name { get; internal set; }
    private static ServiceModelActivity();
    internal ActivityType get_ActivityType();
    internal ServiceModelActivity get_PreviousActivity();
    internal static Activity BoundOperation(ServiceModelActivity activity);
    internal static Activity BoundOperation(ServiceModelActivity activity, bool addTransfer);
    internal static ServiceModelActivity CreateActivity();
    internal static ServiceModelActivity CreateActivity(bool autoStop);
    internal static ServiceModelActivity CreateActivity(bool autoStop, string activityName, ActivityType activityType);
    internal static ServiceModelActivity CreateAsyncActivity();
    internal static ServiceModelActivity CreateBoundedActivity();
    internal static ServiceModelActivity CreateBoundedActivity(bool suspendCurrent);
    internal static ServiceModelActivity CreateBoundedActivity(Guid activityId);
    internal static ServiceModelActivity CreateBoundedActivityWithTransferInOnly(Guid activityId);
    internal static ServiceModelActivity CreateLightWeightAsyncActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId, bool autoStop);
    internal static ServiceModelActivity get_Current();
    private static void set_Current(ServiceModelActivity value);
    public sealed virtual void Dispose();
    internal Guid get_Id();
    internal string get_Name();
    internal void set_Name(string value);
    internal void Resume();
    internal void Resume(string activityName);
    internal static void Start(ServiceModelActivity activity, string activityName, ActivityType activityType);
    internal void Stop();
    internal static void Stop(ServiceModelActivity activity);
    internal void Suspend();
    public virtual string ToString();
}
internal class System.ServiceModel.Diagnostics.ServiceModelPerformanceCounters : object {
    internal bool Initialized { get; }
    internal EndpointPerformanceCountersBase EndpointPerformanceCounters { get; }
    internal ServicePerformanceCountersBase ServicePerformanceCounters { get; }
    internal DefaultPerformanceCounters DefaultPerformanceCounters { get; }
    internal string PerfCounterId { get; }
    internal ServiceModelPerformanceCounters(ServiceHostBase serviceHost, ContractDescription contractDescription, EndpointDispatcher endpointDispatcher);
    internal OperationPerformanceCountersBase GetOperationPerformanceCountersFromMessage(Message message);
    internal OperationPerformanceCountersBase GetOperationPerformanceCounters(string operation);
    internal bool get_Initialized();
    internal EndpointPerformanceCountersBase get_EndpointPerformanceCounters();
    internal ServicePerformanceCountersBase get_ServicePerformanceCounters();
    internal DefaultPerformanceCounters get_DefaultPerformanceCounters();
    internal string get_PerfCounterId();
}
internal class System.ServiceModel.Diagnostics.ServiceModelPerformanceCountersEntry : object {
    public ServicePerformanceCountersBase ServicePerformanceCounters { get; public set; }
    public DefaultPerformanceCounters DefaultPerformanceCounters { get; public set; }
    public List`1<ServiceModelPerformanceCounters> CounterList { get; }
    public ServiceModelPerformanceCountersEntry(ServicePerformanceCountersBase serviceCounters);
    public ServiceModelPerformanceCountersEntry(DefaultPerformanceCounters defaultServiceCounters);
    public void Add(ServiceModelPerformanceCounters counters);
    public void Remove(string id);
    public void Clear();
    public ServicePerformanceCountersBase get_ServicePerformanceCounters();
    public void set_ServicePerformanceCounters(ServicePerformanceCountersBase value);
    public DefaultPerformanceCounters get_DefaultPerformanceCounters();
    public void set_DefaultPerformanceCounters(DefaultPerformanceCounters value);
    public List`1<ServiceModelPerformanceCounters> get_CounterList();
}
internal class System.ServiceModel.Diagnostics.ServicePerformanceCounters : ServicePerformanceCountersBase {
    internal PerformanceCounter[] Counters { get; internal set; }
    internal bool Initialized { get; }
    internal ServicePerformanceCounters(ServiceHostBase serviceHost);
    [CompilerGeneratedAttribute]
internal PerformanceCounter[] get_Counters();
    [CompilerGeneratedAttribute]
internal void set_Counters(PerformanceCounter[] value);
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void ServiceInstanceCreated();
    internal virtual void ServiceInstanceRemoved();
    internal virtual void SessionFaulted();
    internal virtual void MessageDropped();
    internal virtual void TxCommitted(long count);
    internal virtual void TxInDoubt(long count);
    internal virtual void TxAborted(long count);
    internal virtual void TxFlowed();
    internal virtual void MsmqDroppedMessage();
    internal virtual void MsmqPoisonMessage();
    internal virtual void MsmqRejectedMessage();
    internal virtual void IncrementThrottlePercent(int counterIndex);
    internal virtual void SetThrottleBase(int counterIndex, long denominator);
    internal virtual void DecrementThrottlePercent(int counterIndex);
    internal virtual bool get_Initialized();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Diagnostics.ServicePerformanceCountersBase : PerformanceCountersBase {
    protected static String[] perfCounterNames;
    internal string InstanceName { get; }
    internal String[] CounterNames { get; }
    internal int PerfCounterStart { get; }
    internal int PerfCounterEnd { get; }
    internal ServicePerformanceCountersBase(ServiceHostBase serviceHost);
    private static ServicePerformanceCountersBase();
    internal virtual string get_InstanceName();
    internal virtual String[] get_CounterNames();
    internal virtual int get_PerfCounterStart();
    internal virtual int get_PerfCounterEnd();
    internal static string CreateFriendlyInstanceName(ServiceHostBase serviceHost);
    internal static string GetFriendlyInstanceName(ServiceHostBase serviceHost);
    internal abstract virtual void MethodCalled();
    internal abstract virtual void MethodReturnedSuccess();
    internal abstract virtual void MethodReturnedError();
    internal abstract virtual void MethodReturnedFault();
    internal abstract virtual void SaveCallDuration(long time);
    internal abstract virtual void AuthenticationFailed();
    internal abstract virtual void AuthorizationFailed();
    internal abstract virtual void ServiceInstanceCreated();
    internal abstract virtual void ServiceInstanceRemoved();
    internal abstract virtual void SessionFaulted();
    internal abstract virtual void MessageDropped();
    internal abstract virtual void TxCommitted(long count);
    internal abstract virtual void TxInDoubt(long count);
    internal abstract virtual void TxAborted(long count);
    internal abstract virtual void TxFlowed();
    internal abstract virtual void MsmqDroppedMessage();
    internal abstract virtual void MsmqPoisonMessage();
    internal abstract virtual void MsmqRejectedMessage();
    internal abstract virtual void IncrementThrottlePercent(int counterIndex);
    internal abstract virtual void SetThrottleBase(int counterIndex, long denominator);
    internal abstract virtual void DecrementThrottlePercent(int counterIndex);
}
internal class System.ServiceModel.Diagnostics.ServicePerformanceCountersV2 : ServicePerformanceCountersBase {
    internal bool Initialized { get; }
    internal ServicePerformanceCountersV2(ServiceHostBase serviceHost);
    private static ServicePerformanceCountersV2();
    internal virtual void MethodCalled();
    internal virtual void MethodReturnedSuccess();
    internal virtual void MethodReturnedError();
    internal virtual void MethodReturnedFault();
    internal virtual void SaveCallDuration(long time);
    internal virtual void AuthenticationFailed();
    internal virtual void AuthorizationFailed();
    internal virtual void ServiceInstanceCreated();
    internal virtual void ServiceInstanceRemoved();
    internal virtual void SessionFaulted();
    internal virtual void MessageDropped();
    internal virtual void TxCommitted(long count);
    internal virtual void TxInDoubt(long count);
    internal virtual void TxAborted(long count);
    internal virtual void TxFlowed();
    internal virtual void MsmqDroppedMessage();
    internal virtual void MsmqPoisonMessage();
    internal virtual void MsmqRejectedMessage();
    internal virtual void IncrementThrottlePercent(int counterIndex);
    internal virtual void SetThrottleBase(int counterIndex, long denominator);
    internal virtual void DecrementThrottlePercent(int counterIndex);
    internal virtual bool get_Initialized();
    internal void DeleteInstance();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Diagnostics.SystemDiagnosticsPerformanceCountersExtension : object {
    [ExtensionAttribute]
internal static void Increment(PerformanceCountersBase thisPtr, PerformanceCounter[] counters, int counterIndex);
    [ExtensionAttribute]
internal static void IncrementBy(PerformanceCountersBase thisPtr, PerformanceCounter[] counters, int counterIndex, long time);
    [ExtensionAttribute]
internal static void Set(PerformanceCountersBase thisPtr, PerformanceCounter[] counters, int counterIndex, long value);
    [ExtensionAttribute]
internal static void Decrement(PerformanceCountersBase thisPtr, PerformanceCounter[] counters, int counterIndex);
}
internal abstract class System.ServiceModel.Diagnostics.TraceAsyncResult : AsyncResult {
    public ServiceModelActivity CallbackActivity { get; private set; }
    protected TraceAsyncResult(AsyncCallback callback, object state);
    private static TraceAsyncResult();
    [CompilerGeneratedAttribute]
public ServiceModelActivity get_CallbackActivity();
    [CompilerGeneratedAttribute]
private void set_CallbackActivity(ServiceModelActivity value);
}
internal static class System.ServiceModel.Diagnostics.TraceCode : object {
    public static int Administration;
    public static int WmiPut;
    public static int Diagnostics;
    public static int AppDomainUnload;
    public static int EventLog;
    public static int ThrowingException;
    public static int TraceHandledException;
    public static int UnhandledException;
    public static int FailedToAddAnActivityIdHeader;
    public static int FailedToReadAnActivityIdHeader;
    public static int FilterNotMatchedNodeQuotaExceeded;
    public static int MessageCountLimitExceeded;
    public static int DiagnosticsFailedMessageTrace;
    public static int MessageNotLoggedQuotaExceeded;
    public static int TraceTruncatedQuotaExceeded;
    public static int ActivityBoundary;
    public static int Serialization;
    public static int ElementIgnored;
    public static int Channels;
    public static int ConnectionAbandoned;
    public static int ConnectionPoolCloseException;
    public static int ConnectionPoolIdleTimeoutReached;
    public static int ConnectionPoolLeaseTimeoutReached;
    public static int ConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached;
    public static int ServerMaxPooledConnectionsQuotaReached;
    public static int EndpointListenerClose;
    public static int EndpointListenerOpen;
    public static int HttpResponseReceived;
    public static int HttpChannelConcurrentReceiveQuotaReached;
    public static int HttpChannelMessageReceiveFailed;
    public static int HttpChannelUnexpectedResponse;
    public static int HttpChannelRequestAborted;
    public static int HttpChannelResponseAborted;
    public static int HttpsClientCertificateInvalid;
    public static int HttpsClientCertificateNotPresent;
    public static int NamedPipeChannelMessageReceiveFailed;
    public static int NamedPipeChannelMessageReceived;
    public static int MessageReceived;
    public static int MessageSent;
    public static int RequestChannelReplyReceived;
    public static int TcpChannelMessageReceiveFailed;
    public static int TcpChannelMessageReceived;
    public static int ConnectToIPEndpoint;
    public static int SocketConnectionCreate;
    public static int SocketConnectionClose;
    public static int SocketConnectionAbort;
    public static int SocketConnectionAbortClose;
    public static int PipeConnectionAbort;
    public static int RequestContextAbort;
    public static int ChannelCreated;
    public static int ChannelDisposed;
    public static int ListenerCreated;
    public static int ListenerDisposed;
    public static int PrematureDatagramEof;
    public static int MaxPendingConnectionsReached;
    public static int MaxAcceptedChannelsReached;
    public static int ChannelConnectionDropped;
    public static int HttpAuthFailed;
    public static int NoExistingTransportManager;
    public static int IncompatibleExistingTransportManager;
    public static int InitiatingNamedPipeConnection;
    public static int InitiatingTcpConnection;
    public static int OpenedListener;
    public static int SslClientCertMissing;
    public static int StreamSecurityUpgradeAccepted;
    public static int TcpConnectError;
    public static int FailedAcceptFromPool;
    public static int FailedPipeConnect;
    public static int SystemTimeResolution;
    public static int PeerNeighborCloseFailed;
    public static int PeerNeighborClosingFailed;
    public static int PeerNeighborNotAccepted;
    public static int PeerNeighborNotFound;
    public static int PeerNeighborOpenFailed;
    public static int PeerNeighborStateChanged;
    public static int PeerNeighborStateChangeFailed;
    public static int PeerNeighborMessageReceived;
    public static int PeerNeighborManagerOffline;
    public static int PeerNeighborManagerOnline;
    public static int PeerChannelMessageReceived;
    public static int PeerChannelMessageSent;
    public static int PeerNodeAddressChanged;
    public static int PeerNodeOpening;
    public static int PeerNodeOpened;
    public static int PeerNodeOpenFailed;
    public static int PeerNodeClosing;
    public static int PeerNodeClosed;
    public static int PeerFloodedMessageReceived;
    public static int PeerFloodedMessageNotPropagated;
    public static int PeerFloodedMessageNotMatched;
    public static int PnrpRegisteredAddresses;
    public static int PnrpUnregisteredAddresses;
    public static int PnrpResolvedAddresses;
    public static int PnrpResolveException;
    public static int PeerReceiveMessageAuthenticationFailure;
    public static int PeerNodeAuthenticationFailure;
    public static int PeerNodeAuthenticationTimeout;
    public static int PeerFlooderReceiveMessageQuotaExceeded;
    public static int PeerServiceOpened;
    public static int PeerMaintainerActivity;
    public static int MsmqCannotPeekOnQueue;
    public static int MsmqCannotReadQueues;
    public static int MsmqDatagramSent;
    public static int MsmqDatagramReceived;
    public static int MsmqDetected;
    public static int MsmqEnteredBatch;
    public static int MsmqExpectedException;
    public static int MsmqFoundBaseAddress;
    public static int MsmqLeftBatch;
    public static int MsmqMatchedApplicationFound;
    public static int MsmqMessageDropped;
    public static int MsmqMessageLockedUnderTheTransaction;
    public static int MsmqMessageRejected;
    public static int MsmqMoveOrDeleteAttemptFailed;
    public static int MsmqPoisonMessageMovedPoison;
    public static int MsmqPoisonMessageMovedRetry;
    public static int MsmqPoisonMessageRejected;
    public static int MsmqPoolFull;
    public static int MsmqPotentiallyPoisonMessageDetected;
    public static int MsmqQueueClosed;
    public static int MsmqQueueOpened;
    public static int MsmqQueueTransactionalStatusUnknown;
    public static int MsmqScanStarted;
    public static int MsmqSessiongramReceived;
    public static int MsmqSessiongramSent;
    public static int MsmqStartingApplication;
    public static int MsmqStartingService;
    public static int MsmqUnexpectedAcknowledgment;
    public static int WsrmNegativeElapsedTimeDetected;
    public static int TcpTransferError;
    public static int TcpConnectionResetError;
    public static int TcpConnectionTimedOut;
    public static int ComIntegration;
    public static int ComIntegrationServiceHostStartingService;
    public static int ComIntegrationServiceHostStartedService;
    public static int ComIntegrationServiceHostCreatedServiceContract;
    public static int ComIntegrationServiceHostStartedServiceDetails;
    public static int ComIntegrationServiceHostCreatedServiceEndpoint;
    public static int ComIntegrationServiceHostStoppingService;
    public static int ComIntegrationServiceHostStoppedService;
    public static int ComIntegrationDllHostInitializerStarting;
    public static int ComIntegrationDllHostInitializerAddingHost;
    public static int ComIntegrationDllHostInitializerStarted;
    public static int ComIntegrationDllHostInitializerStopping;
    public static int ComIntegrationDllHostInitializerStopped;
    public static int ComIntegrationTLBImportStarting;
    public static int ComIntegrationTLBImportFromAssembly;
    public static int ComIntegrationTLBImportFromTypelib;
    public static int ComIntegrationTLBImportConverterEvent;
    public static int ComIntegrationTLBImportFinished;
    public static int ComIntegrationInstanceCreationRequest;
    public static int ComIntegrationInstanceCreationSuccess;
    public static int ComIntegrationInstanceReleased;
    public static int ComIntegrationEnteringActivity;
    public static int ComIntegrationExecutingCall;
    public static int ComIntegrationLeftActivity;
    public static int ComIntegrationInvokingMethod;
    public static int ComIntegrationInvokedMethod;
    public static int ComIntegrationInvokingMethodNewTransaction;
    public static int ComIntegrationInvokingMethodContextTransaction;
    public static int ComIntegrationServiceMonikerParsed;
    public static int ComIntegrationWsdlChannelBuilderLoaded;
    public static int ComIntegrationTypedChannelBuilderLoaded;
    public static int ComIntegrationChannelCreated;
    public static int ComIntegrationDispatchMethod;
    public static int ComIntegrationTxProxyTxCommitted;
    public static int ComIntegrationTxProxyTxAbortedByContext;
    public static int ComIntegrationTxProxyTxAbortedByTM;
    public static int ComIntegrationMexMonikerMetadataExchangeComplete;
    public static int ComIntegrationMexChannelBuilderLoaded;
    public static int Security;
    public static int SecurityIdentityVerificationSuccess;
    public static int SecurityIdentityVerificationFailure;
    public static int SecurityIdentityDeterminationSuccess;
    public static int SecurityIdentityDeterminationFailure;
    public static int SecurityIdentityHostNameNormalizationFailure;
    public static int SecurityImpersonationSuccess;
    public static int SecurityImpersonationFailure;
    public static int SecurityNegotiationProcessingFailure;
    public static int IssuanceTokenProviderRemovedCachedToken;
    public static int IssuanceTokenProviderUsingCachedToken;
    public static int IssuanceTokenProviderBeginSecurityNegotiation;
    public static int IssuanceTokenProviderEndSecurityNegotiation;
    public static int IssuanceTokenProviderRedirectApplied;
    public static int IssuanceTokenProviderServiceTokenCacheFull;
    public static int NegotiationTokenProviderAttached;
    public static int SpnegoClientNegotiationCompleted;
    public static int SpnegoServiceNegotiationCompleted;
    public static int SpnegoClientNegotiation;
    public static int SpnegoServiceNegotiation;
    public static int NegotiationAuthenticatorAttached;
    public static int ServiceSecurityNegotiationCompleted;
    public static int SecurityContextTokenCacheFull;
    public static int ExportSecurityChannelBindingEntry;
    public static int ExportSecurityChannelBindingExit;
    public static int ImportSecurityChannelBindingEntry;
    public static int ImportSecurityChannelBindingExit;
    public static int SecurityTokenProviderOpened;
    public static int SecurityTokenProviderClosed;
    public static int SecurityTokenAuthenticatorOpened;
    public static int SecurityTokenAuthenticatorClosed;
    public static int SecurityBindingOutgoingMessageSecured;
    public static int SecurityBindingIncomingMessageVerified;
    public static int SecurityBindingSecureOutgoingMessageFailure;
    public static int SecurityBindingVerifyIncomingMessageFailure;
    public static int SecuritySpnToSidMappingFailure;
    public static int SecuritySessionRedirectApplied;
    public static int SecurityClientSessionCloseSent;
    public static int SecurityClientSessionCloseResponseSent;
    public static int SecurityClientSessionCloseMessageReceived;
    public static int SecuritySessionKeyRenewalFaultReceived;
    public static int SecuritySessionAbortedFaultReceived;
    public static int SecuritySessionClosedResponseReceived;
    public static int SecurityClientSessionPreviousKeyDiscarded;
    public static int SecurityClientSessionKeyRenewed;
    public static int SecurityPendingServerSessionAdded;
    public static int SecurityPendingServerSessionClosed;
    public static int SecurityPendingServerSessionActivated;
    public static int SecurityActiveServerSessionRemoved;
    public static int SecurityNewServerSessionKeyIssued;
    public static int SecurityInactiveSessionFaulted;
    public static int SecurityServerSessionKeyUpdated;
    public static int SecurityServerSessionCloseReceived;
    public static int SecurityServerSessionRenewalFaultSent;
    public static int SecurityServerSessionAbortedFaultSent;
    public static int SecuritySessionCloseResponseSent;
    public static int SecuritySessionServerCloseSent;
    public static int SecurityServerSessionCloseResponseReceived;
    public static int SecuritySessionRenewFaultSendFailure;
    public static int SecuritySessionAbortedFaultSendFailure;
    public static int SecuritySessionClosedResponseSendFailure;
    public static int SecuritySessionServerCloseSendFailure;
    public static int SecuritySessionRequestorStartOperation;
    public static int SecuritySessionRequestorOperationSuccess;
    public static int SecuritySessionRequestorOperationFailure;
    public static int SecuritySessionResponderOperationFailure;
    public static int SecuritySessionDemuxFailure;
    public static int SecurityAuditWrittenSuccess;
    public static int SecurityAuditWrittenFailure;
    public static int ServiceModel;
    public static int AsyncCallbackThrewException;
    public static int CommunicationObjectAborted;
    public static int CommunicationObjectAbortFailed;
    public static int CommunicationObjectCloseFailed;
    public static int CommunicationObjectOpenFailed;
    public static int CommunicationObjectClosing;
    public static int CommunicationObjectClosed;
    public static int CommunicationObjectCreated;
    public static int CommunicationObjectDisposing;
    public static int CommunicationObjectFaultReason;
    public static int CommunicationObjectFaulted;
    public static int CommunicationObjectOpening;
    public static int CommunicationObjectOpened;
    public static int DidNotUnderstandMessageHeader;
    public static int UnderstoodMessageHeader;
    public static int MessageClosed;
    public static int MessageClosedAgain;
    public static int MessageCopied;
    public static int MessageRead;
    public static int MessageWritten;
    public static int BeginExecuteMethod;
    public static int ConfigurationIsReadOnly;
    public static int ConfiguredExtensionTypeNotFound;
    public static int EvaluationContextNotFound;
    public static int EndExecuteMethod;
    public static int ExtensionCollectionDoesNotExist;
    public static int ExtensionCollectionNameNotFound;
    public static int ExtensionCollectionIsEmpty;
    public static int ExtensionElementAlreadyExistsInCollection;
    public static int ElementTypeDoesntMatchConfiguredType;
    public static int ErrorInvokingUserCode;
    public static int GetBehaviorElement;
    public static int GetCommonBehaviors;
    public static int GetConfiguredBinding;
    public static int GetChannelEndpointElement;
    public static int GetConfigurationSection;
    public static int GetDefaultConfiguredBinding;
    public static int GetServiceElement;
    public static int MessageProcessingPaused;
    public static int ManualFlowThrottleLimitReached;
    public static int OverridingDuplicateConfigurationKey;
    public static int RemoveBehavior;
    public static int ServiceChannelLifetime;
    public static int ServiceHostCreation;
    public static int ServiceHostBaseAddresses;
    public static int ServiceHostTimeoutOnClose;
    public static int ServiceHostFaulted;
    public static int ServiceHostErrorOnReleasePerformanceCounter;
    public static int ServiceThrottleLimitReached;
    public static int ServiceOperationMissingReply;
    public static int ServiceOperationMissingReplyContext;
    public static int ServiceOperationExceptionOnReply;
    public static int SkipBehavior;
    public static int TransportListen;
    public static int UnhandledAction;
    public static int PerformanceCounterFailedToLoad;
    public static int PerformanceCountersFailed;
    public static int PerformanceCountersFailedDuringUpdate;
    public static int PerformanceCountersFailedForService;
    public static int PerformanceCountersFailedOnRelease;
    public static int WsmexNonCriticalWsdlExportError;
    public static int WsmexNonCriticalWsdlImportError;
    public static int FailedToOpenIncomingChannel;
    public static int UnhandledExceptionInUserOperation;
    public static int DroppedAMessage;
    public static int CannotBeImportedInCurrentFormat;
    public static int GetConfiguredEndpoint;
    public static int GetDefaultConfiguredEndpoint;
    public static int ExtensionTypeNotFound;
    public static int DefaultEndpointsAdded;
    public static int MetadataExchangeClientSendRequest;
    public static int MetadataExchangeClientReceiveReply;
    public static int WarnHelpPageEnabledNoBaseAddress;
    public static int PortSharing;
    public static int PortSharingClosed;
    public static int PortSharingDuplicatedPipe;
    public static int PortSharingDupHandleGranted;
    public static int PortSharingDuplicatedSocket;
    public static int PortSharingListening;
    public static int SharedManagerServiceEndpointNotExist;
    public static int ServiceModelTransaction;
    public static int TxSourceTxScopeRequiredIsTransactedTransport;
    public static int TxSourceTxScopeRequiredIsTransactionFlow;
    public static int TxSourceTxScopeRequiredIsAttachedTransaction;
    public static int TxSourceTxScopeRequiredIsCreateNewTransaction;
    public static int TxCompletionStatusCompletedForAutocomplete;
    public static int TxCompletionStatusCompletedForError;
    public static int TxCompletionStatusCompletedForSetComplete;
    public static int TxCompletionStatusCompletedForTACOSC;
    public static int TxCompletionStatusCompletedForAsyncAbort;
    public static int TxCompletionStatusRemainsAttached;
    public static int TxCompletionStatusAbortedOnSessionClose;
    public static int TxReleaseServiceInstanceOnCompletion;
    public static int TxAsyncAbort;
    public static int TxFailedToNegotiateOleTx;
    public static int TxSourceTxScopeRequiredUsingExistingTransaction;
    public static int NetFx35;
    public static int ActivatingMessageReceived;
    public static int InstanceContextBoundToDurableInstance;
    public static int InstanceContextDetachedFromDurableInstance;
    public static int ContextChannelFactoryChannelCreated;
    public static int ContextChannelListenerChannelAccepted;
    public static int ContextProtocolContextAddedToMessage;
    public static int ContextProtocolContextRetrievedFromMessage;
    public static int DICPInstanceContextCached;
    public static int DICPInstanceContextRemovedFromCache;
    public static int ServiceDurableInstanceDeleted;
    public static int ServiceDurableInstanceDisposed;
    public static int ServiceDurableInstanceLoaded;
    public static int ServiceDurableInstanceSaved;
    public static int SqlPersistenceProviderSQLCallStart;
    public static int SqlPersistenceProviderSQLCallEnd;
    public static int SqlPersistenceProviderOpenParameters;
    public static int SyncContextSchedulerServiceTimerCancelled;
    public static int SyncContextSchedulerServiceTimerCreated;
    public static int WorkflowDurableInstanceLoaded;
    public static int WorkflowDurableInstanceAborted;
    public static int WorkflowDurableInstanceActivated;
    public static int WorkflowOperationInvokerItemQueued;
    public static int WorkflowRequestContextReplySent;
    public static int WorkflowRequestContextFaultSent;
    public static int WorkflowServiceHostCreated;
    public static int SyndicationReadFeedBegin;
    public static int SyndicationReadFeedEnd;
    public static int SyndicationReadItemBegin;
    public static int SyndicationReadItemEnd;
    public static int SyndicationWriteFeedBegin;
    public static int SyndicationWriteFeedEnd;
    public static int SyndicationWriteItemBegin;
    public static int SyndicationWriteItemEnd;
    public static int SyndicationProtocolElementIgnoredOnRead;
    public static int SyndicationProtocolElementIgnoredOnWrite;
    public static int SyndicationProtocolElementInvalid;
    public static int WebUnknownQueryParameterIgnored;
    public static int WebRequestMatchesOperation;
    public static int WebRequestDoesNotMatchOperations;
    public static int WebRequestRedirect;
    public static int SyndicationReadServiceDocumentBegin;
    public static int SyndicationReadServiceDocumentEnd;
    public static int SyndicationReadCategoriesDocumentBegin;
    public static int SyndicationReadCategoriesDocumentEnd;
    public static int SyndicationWriteServiceDocumentBegin;
    public static int SyndicationWriteServiceDocumentEnd;
    public static int SyndicationWriteCategoriesDocumentBegin;
    public static int SyndicationWriteCategoriesDocumentEnd;
    public static int AutomaticFormatSelectedOperationDefault;
    public static int AutomaticFormatSelectedRequestBased;
    public static int RequestFormatSelectedFromContentTypeMapper;
    public static int RequestFormatSelectedByEncoderDefaults;
    public static int AddingResponseToOutputCache;
    public static int AddingAuthenticatedResponseToOutputCache;
    public static int JsonpCallbackNameSet;
}
internal static class System.ServiceModel.Diagnostics.TraceUtility : object {
    public static string E2EActivityId;
    public static string TraceApplicationReference;
    public static bool PropagateUserActivity { get; }
    internal static bool ShouldPropagateActivity { get; }
    internal static bool ShouldPropagateActivityGlobal { get; }
    internal static bool ActivityTracing { get; }
    internal static bool MessageFlowTracing { get; }
    internal static bool MessageFlowTracingOnly { get; }
    private static TraceUtility();
    public static InputQueue`1<T> CreateInputQueue();
    internal static void AddActivityHeader(Message message);
    internal static void AddAmbientActivityToMessage(Message message);
    internal static void CopyActivity(Message source, Message destination);
    internal static long GetUtcBasedDurationForTrace(long startTicks);
    internal static ServiceModelActivity ExtractActivity(Message message);
    internal static ServiceModelActivity ExtractActivity(RequestContext request);
    internal static Guid ExtractActivityId(Message message);
    internal static Guid GetReceivedActivityId(OperationContext operationContext);
    internal static ServiceModelActivity ExtractAndRemoveActivity(Message message);
    internal static void ProcessIncomingMessage(Message message, EventTraceActivity eventTraceActivity);
    internal static void ProcessOutgoingMessage(Message message, EventTraceActivity eventTraceActivity);
    internal static void SetActivity(Message message, ServiceModelActivity activity);
    internal static void TraceDroppedMessage(Message message, EndpointDispatcher dispatcher);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source, Exception exception);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, Message message);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source, Message message);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, Exception exception, Message message);
    internal static void TraceEventNoCheck(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception, Message message);
    internal static void TraceEventNoCheck(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception, Guid activityId);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception, Guid activityId);
    internal static Exception ThrowHelperError(Exception exception, Message message);
    internal static Exception ThrowHelperError(Exception exception, Guid activityId, object source);
    internal static Exception ThrowHelperWarning(Exception exception, Message message);
    internal static ArgumentException ThrowHelperArgument(string paramName, string message, Message msg);
    internal static ArgumentNullException ThrowHelperArgumentNull(string paramName, Message message);
    internal static string CreateSourceString(object source);
    internal static void TraceHttpConnectionInformation(string localEndpoint, string remoteEndpoint, object source);
    internal static void TraceUserCodeException(Exception e, MethodInfo method);
    public static long RetrieveMessageNumber();
    public static bool get_PropagateUserActivity();
    internal static string GetCallerInfo(OperationContext context);
    [SecuritySafeCriticalAttribute]
internal static void SetEtwProviderId();
    internal static void SetActivityId(MessageProperties properties);
    internal static bool get_ShouldPropagateActivity();
    internal static bool get_ShouldPropagateActivityGlobal();
    internal static bool get_ActivityTracing();
    internal static bool get_MessageFlowTracing();
    internal static bool get_MessageFlowTracingOnly();
    internal static void MessageFlowAtMessageSent(Message message, EventTraceActivity eventTraceActivity);
    internal static void MessageFlowAtMessageReceived(Message message, OperationContext context, EventTraceActivity eventTraceActivity, bool createNewActivityId);
    internal static string GetAnnotation(OperationContext context);
    internal static void TransferFromTransport(Message message);
    internal static void UpdateAsyncOperationContextWithActivity(object activity);
    internal static object ExtractAsyncOperationContextActivity();
    internal static void UpdateAsyncOperationContextWithStartTime(EventTraceActivity eventTraceActivity, long startTime);
    internal static void ExtractAsyncOperationStartTime(EventTraceActivity& eventTraceActivity, Int64& startTime);
    internal static AsyncCallback WrapExecuteUserCodeAsyncCallback(AsyncCallback callback);
    internal static string GetRemoteEndpointAddressPort(IPEndPoint iPEndPoint);
    internal static string GetRemoteEndpointAddressPort(RemoteEndpointMessageProperty remoteEndpointMessageProperty);
}
internal class System.ServiceModel.Diagnostics.WmiPutTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal WmiPutTraceRecord(string valueName, object originalValue, object newValue);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.ServiceModel.Diagnostics.WsrmTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal WsrmTraceRecord(UniqueId id);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal static class System.ServiceModel.DiagnosticUtility : object {
    internal static string EventSourceName;
    internal static string DefaultTraceListenerName;
    internal static SourceLevels Level { get; internal set; }
    internal static LegacyDiagnosticTrace DiagnosticTrace { get; }
    internal static ExceptionUtility ExceptionUtility { get; }
    internal static Utility Utility { get; }
    internal static EventLogger EventLog { get; }
    internal static EventLogger UnsafeEventLog { get; }
    internal static bool TracingEnabled { get; internal set; }
    internal static bool ShouldTraceCritical { get; }
    internal static bool ShouldUseActivity { get; internal set; }
    internal static bool ShouldTraceError { get; }
    internal static bool ShouldTraceWarning { get; }
    internal static bool ShouldTraceInformation { get; }
    internal static bool ShouldTraceVerbose { get; }
    private static DiagnosticUtility();
    internal static SourceLevels get_Level();
    [SecurityCriticalAttribute]
internal static void set_Level(SourceLevels value);
    internal static LegacyDiagnosticTrace get_DiagnosticTrace();
    internal static ExceptionUtility get_ExceptionUtility();
    internal static Utility get_Utility();
    internal static EventLogger get_EventLog();
    [SecuritySafeCriticalAttribute]
internal static EventLogger get_UnsafeEventLog();
    [SecuritySafeCriticalAttribute]
internal static void InitDiagnosticTraceImpl(TraceSourceKind sourceType, string traceSourceName);
    internal static void set_TracingEnabled(bool value);
    internal static bool get_TracingEnabled();
    internal static bool ShouldTrace(TraceEventType type);
    internal static void TraceHandledException(Exception exception, TraceEventType traceEventType);
    internal static bool get_ShouldTraceCritical();
    internal static bool get_ShouldUseActivity();
    internal static void set_ShouldUseActivity(bool value);
    internal static bool get_ShouldTraceError();
    internal static bool get_ShouldTraceWarning();
    internal static bool get_ShouldTraceInformation();
    internal static bool get_ShouldTraceVerbose();
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(string message);
    internal static Exception FailFast(string message);
    internal static Exception InvokeFinalHandler(Exception exception);
}
[DataContractAttribute]
public class System.ServiceModel.Dispatcher.ActionMessageFilter : MessageFilter {
    [DataMemberAttribute]
internal String[] DCActions { get; internal set; }
    public ReadOnlyCollection`1<string> Actions { get; }
    public ActionMessageFilter(String[] actions);
    internal String[] get_DCActions();
    internal void set_DCActions(String[] value);
    public ReadOnlyCollection`1<string> get_Actions();
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public virtual bool Match(Message message);
    public virtual bool Match(MessageBuffer messageBuffer);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
internal class System.ServiceModel.Dispatcher.ActionMessageFilterTable`1 : object {
    public TFilterData Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<TFilterData> Values { get; }
    public sealed virtual TFilterData get_Item(MessageFilter filter);
    public sealed virtual void set_Item(MessageFilter filter, TFilterData value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<TFilterData> get_Values();
    public void Add(ActionMessageFilter filter, TFilterData data);
    public sealed virtual void Add(MessageFilter filter, TFilterData data);
    public sealed virtual void Add(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool ContainsKey(MessageFilter filter);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageFilter, TFilterData>> GetEnumerator();
    public sealed virtual bool GetMatchingValue(Message message, TFilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer messageBuffer, TFilterData& data);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<TFilterData> results);
    public bool Remove(ActionMessageFilter filter);
    public sealed virtual bool Remove(MessageFilter filter);
    public sealed virtual bool Remove(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool TryGetValue(MessageFilter filter, TFilterData& data);
}
internal class System.ServiceModel.Dispatcher.AndMessageFilter : MessageFilter {
    public MessageFilter Filter1 { get; }
    public MessageFilter Filter2 { get; }
    public AndMessageFilter(MessageFilter filter1, MessageFilter filter2);
    public MessageFilter get_Filter1();
    public MessageFilter get_Filter2();
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public virtual bool Match(Message message);
    internal bool Match(Message message, Boolean& addressMatched);
    public virtual bool Match(MessageBuffer messageBuffer);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.AndMessageFilterTable`1 : object {
    public FilterData Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<FilterData> Values { get; }
    public sealed virtual FilterData get_Item(MessageFilter filter);
    public sealed virtual void set_Item(MessageFilter filter, FilterData value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<FilterData> get_Values();
    public sealed virtual void Add(MessageFilter filter, FilterData data);
    public sealed virtual void Add(KeyValuePair`2<MessageFilter, FilterData> item);
    public void Add(AndMessageFilter filter, FilterData data);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<MessageFilter, FilterData> item);
    public sealed virtual bool ContainsKey(MessageFilter filter);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageFilter, FilterData>> GetEnumerator();
    internal bool GetMatchingValue(Message message, FilterData& data, Boolean& addressMatched);
    public sealed virtual bool GetMatchingValue(Message message, FilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer messageBuffer, FilterData& data);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<FilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<FilterData> results);
    public sealed virtual bool Remove(MessageFilter filter);
    public sealed virtual bool Remove(KeyValuePair`2<MessageFilter, FilterData> item);
    public bool Remove(AndMessageFilter filter);
    public sealed virtual bool TryGetValue(MessageFilter filter, FilterData& data);
}
internal class System.ServiceModel.Dispatcher.ApplyBooleanOpcode : JumpIfOpcode {
    internal ApplyBooleanOpcode(Opcode jump, bool test);
    protected ApplyBooleanOpcode(OpcodeID id, Opcode jump, bool test);
    internal virtual Opcode Eval(ProcessingContext context);
    protected int UpdateResultMask(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.ApplyFilterOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.ArgBuilder : object {
    internal int Index;
    internal Type ArgType;
    internal ArgBuilder(int index, Type argType);
}
internal class System.ServiceModel.Dispatcher.AsyncMethodInvoker : object {
    public MethodInfo BeginMethod { get; }
    public MethodInfo EndMethod { get; }
    public bool IsSynchronous { get; }
    public AsyncMethodInvoker(MethodInfo beginMethod, MethodInfo endMethod);
    public MethodInfo get_BeginMethod();
    public MethodInfo get_EndMethod();
    public sealed virtual bool get_IsSynchronous();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual object Invoke(object instance, Object[] inputs, Object[]& outputs);
    internal static void CreateActivityInfo(ServiceModelActivity& activity, Activity& boundActivity);
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    internal static void GetActivityInfo(ServiceModelActivity& activity, Activity& boundOperation);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
    internal static void StartOperationInvokeTrace(string methodName);
    internal static void StopOperationInvokeTrace(bool callFailed, bool callFaulted, string methodName);
    internal static void StartOperationInvokePerformanceCounters(string methodName);
    internal static void StopOperationInvokePerformanceCounters(bool callFailed, bool callFaulted, string methodName);
}
internal class System.ServiceModel.Dispatcher.AuthenticationBehavior : object {
    public void Authenticate(MessageRpc& rpc);
    public static AuthenticationBehavior TryCreate(DispatchRuntime dispatch);
    internal static Exception CreateFailedAuthenticationFaultException();
}
internal class System.ServiceModel.Dispatcher.AuthorizationBehavior : object {
    private static AuthorizationBehavior();
    public void Authorize(MessageRpc& rpc);
    public static AuthorizationBehavior TryCreate(DispatchRuntime dispatch);
    internal static Exception CreateAccessDeniedFaultException();
}
internal enum System.ServiceModel.Dispatcher.AxisDirection : Enum {
    public byte value__;
    public static AxisDirection Forward;
    public static AxisDirection Reverse;
}
internal class System.ServiceModel.Dispatcher.BlockEndOpcode : Opcode {
    internal void DeLinkJump(Opcode jump);
    internal void LinkJump(Opcode jump);
    internal virtual void Remove();
}
internal class System.ServiceModel.Dispatcher.BranchContext : ValueType {
    private ProcessingContext branchContext;
    private ProcessingContext sourceContext;
    internal BranchContext(ProcessingContext context);
    internal ProcessingContext Create();
    internal void Release();
}
internal class System.ServiceModel.Dispatcher.BranchMatcher : ValueType {
    private int resultCount;
    private QueryBranchResultSet resultTable;
    internal QueryBranchResultSet ResultTable { get; }
    internal BranchMatcher(int resultCount, QueryBranchResultSet resultTable);
    internal QueryBranchResultSet get_ResultTable();
    internal void InvokeMatches(ProcessingContext context);
    internal void InvokeNonMatches(ProcessingContext context, QueryBranchTable nonMatchTable);
    internal void Release(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.BranchOpcode : Opcode {
    internal OpcodeList Branches { get; }
    internal BranchOpcode(OpcodeID id);
    internal OpcodeList get_Branches();
    internal virtual void Add(Opcode opcode);
    internal virtual void AddBranch(Opcode opcode);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual void DelinkFromConditional(Opcode child);
    internal virtual Opcode Eval(ProcessingContext context);
    internal virtual bool IsInConditional();
    internal virtual void LinkToConditional(Opcode child);
    internal virtual Opcode Locate(Opcode opcode);
    internal virtual void Remove();
    internal virtual void RemoveChild(Opcode opcode);
    internal virtual void Replace(Opcode replace, Opcode with);
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.BufferedReceiveBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public BufferedReceiveBinder(IChannelBinder channelBinder);
    private static BufferedReceiveBinder();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    internal void InjectRequest(RequestContext requestContext);
}
public class System.ServiceModel.Dispatcher.ChannelDispatcher : ChannelDispatcherBase {
    public string BindingName { get; }
    public SynchronizedCollection`1<IChannelInitializer> ChannelInitializers { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable EndpointDispatcherTable { get; }
    internal CommunicationObjectManager`1<IChannel> Channels { get; }
    public SynchronizedCollection`1<EndpointDispatcher> Endpoints { get; }
    public Collection`1<IErrorHandler> ErrorHandlers { get; }
    public MessageVersion MessageVersion { get; public set; }
    internal bool Session { get; }
    public ServiceHostBase Host { get; }
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    public bool IsTransactedAccept { get; }
    public bool IsTransactedReceive { get; public set; }
    public bool AsynchronousTransactedAcceptEnabled { get; public set; }
    public bool ReceiveContextEnabled { get; public set; }
    internal bool BufferedReceiveEnabled { get; internal set; }
    public IChannelListener Listener { get; }
    public int MaxTransactedBatchSize { get; public set; }
    public ServiceThrottle ServiceThrottle { get; public set; }
    public bool ManualAddressing { get; public set; }
    internal SynchronizedChannelCollection`1<IChannel> PendingChannels { get; }
    public bool ReceiveSynchronously { get; public set; }
    public bool SendAsynchronously { get; public set; }
    public int MaxPendingReceives { get; public set; }
    public bool IncludeExceptionDetailInFaults { get; public set; }
    internal IDefaultCommunicationTimeouts DefaultCommunicationTimeouts { get; }
    public IsolationLevel TransactionIsolationLevel { get; public set; }
    internal bool TransactionIsolationLevelSet { get; }
    public TimeSpan TransactionTimeout { get; public set; }
    internal ChannelDispatcher(SharedRuntimeState shared);
    public ChannelDispatcher(IChannelListener listener);
    public ChannelDispatcher(IChannelListener listener, string bindingName);
    public ChannelDispatcher(IChannelListener listener, string bindingName, IDefaultCommunicationTimeouts timeouts);
    public string get_BindingName();
    public SynchronizedCollection`1<IChannelInitializer> get_ChannelInitializers();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal EndpointDispatcherTable get_EndpointDispatcherTable();
    internal CommunicationObjectManager`1<IChannel> get_Channels();
    public SynchronizedCollection`1<EndpointDispatcher> get_Endpoints();
    public Collection`1<IErrorHandler> get_ErrorHandlers();
    public MessageVersion get_MessageVersion();
    public void set_MessageVersion(MessageVersion value);
    internal bool get_Session();
    public virtual ServiceHostBase get_Host();
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    internal bool get_IsOnServer();
    public bool get_IsTransactedAccept();
    public bool get_IsTransactedReceive();
    public void set_IsTransactedReceive(bool value);
    public bool get_AsynchronousTransactedAcceptEnabled();
    public void set_AsynchronousTransactedAcceptEnabled(bool value);
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BufferedReceiveEnabled();
    [CompilerGeneratedAttribute]
internal void set_BufferedReceiveEnabled(bool value);
    public virtual IChannelListener get_Listener();
    public int get_MaxTransactedBatchSize();
    public void set_MaxTransactedBatchSize(int value);
    public ServiceThrottle get_ServiceThrottle();
    public void set_ServiceThrottle(ServiceThrottle value);
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    internal SynchronizedChannelCollection`1<IChannel> get_PendingChannels();
    public bool get_ReceiveSynchronously();
    public void set_ReceiveSynchronously(bool value);
    public bool get_SendAsynchronously();
    public void set_SendAsynchronously(bool value);
    public int get_MaxPendingReceives();
    public void set_MaxPendingReceives(int value);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    internal IDefaultCommunicationTimeouts get_DefaultCommunicationTimeouts();
    public IsolationLevel get_TransactionIsolationLevel();
    public void set_TransactionIsolationLevel(IsolationLevel value);
    internal bool get_TransactionIsolationLevelSet();
    public TimeSpan get_TransactionTimeout();
    public void set_TransactionTimeout(TimeSpan value);
    internal virtual void CloseInput(TimeSpan timeout);
    internal void ReleasePerformanceCounters();
    public virtual void CloseInput();
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal void InitializeChannel(IClientChannel channel);
    internal EndpointDispatcher Match(Message message, Boolean& addressMatched);
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    internal bool HasApplicationEndpoints();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnOpen(TimeSpan timeout);
    internal string CreateContractListString();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpening();
    protected virtual void OnOpened();
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void SetEndpointAddressTable(ThreadSafeMessageFilterTable`1<EndpointAddress> table);
    internal void ThrowIfDisposedOrImmutable();
    protected virtual void Attach(ServiceHostBase host);
    protected virtual void Detach(ServiceHostBase host);
}
public abstract class System.ServiceModel.Dispatcher.ChannelDispatcherBase : CommunicationObject {
    public ServiceHostBase Host { get; }
    public IChannelListener Listener { get; }
    public abstract virtual ServiceHostBase get_Host();
    public abstract virtual IChannelListener get_Listener();
    internal void AttachInternal(ServiceHostBase host);
    protected virtual void Attach(ServiceHostBase host);
    internal void DetachInternal(ServiceHostBase host);
    protected virtual void Detach(ServiceHostBase host);
    public virtual void CloseInput();
    internal virtual void CloseInput(TimeSpan timeout);
}
public class System.ServiceModel.Dispatcher.ChannelDispatcherCollection : SynchronizedCollection`1<ChannelDispatcherBase> {
    internal ChannelDispatcherCollection(ServiceHostBase service, object syncRoot);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, ChannelDispatcherBase item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, ChannelDispatcherBase item);
}
internal class System.ServiceModel.Dispatcher.ChannelHandler : object {
    public static TimeSpan CloseAfterFaultTimeout;
    public static string MessageBufferPropertyName;
    internal IChannelBinder Binder { get; }
    internal ServiceChannel Channel { get; }
    internal bool HasRegisterBeenCalled { get; }
    internal InstanceContext InstanceContext { get; }
    internal ServiceThrottle InstanceContextServiceThrottle { get; internal set; }
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ServiceChannel channel);
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ServiceThrottle throttle, ListenerHandler listener, bool wasChannelThrottled, WrappedTransaction acceptTransaction, SessionIdleManager idleManager);
    internal ChannelHandler(ChannelHandler handler, TransactedBatchContext context);
    private static ChannelHandler();
    internal IChannelBinder get_Binder();
    internal ServiceChannel get_Channel();
    internal bool get_HasRegisterBeenCalled();
    internal InstanceContext get_InstanceContext();
    internal ServiceThrottle get_InstanceContextServiceThrottle();
    internal void set_InstanceContextServiceThrottle(ServiceThrottle value);
    internal static void Register(ChannelHandler handler);
    internal static void Register(ChannelHandler handler, RequestContext request);
    internal void DispatchDone();
    internal bool HandleError(Exception e);
    internal void ThrottleAcquiredForCall();
    internal void ThrottleAcquired();
}
public class System.ServiceModel.Dispatcher.ClientOperation : ClientOperationCompatBase {
    public string Action { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public MethodInfo BeginMethod { get; public set; }
    public MethodInfo EndMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public IClientMessageFormatter Formatter { get; public set; }
    internal IClientFaultFormatter FaultFormatter { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; }
    internal IClientMessageFormatter InternalFormatter { get; internal set; }
    public bool IsInitiating { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsTerminating { get; public set; }
    public string Name { get; }
    public ICollection`1<IParameterInspector> ClientParameterInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public ClientRuntime Parent { get; }
    public string ReplyAction { get; }
    public bool SerializeRequest { get; public set; }
    public bool DeserializeReply { get; public set; }
    public MethodInfo TaskMethod { get; public set; }
    public Type TaskTResult { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public ClientOperation(ClientRuntime parent, string name, string action);
    public ClientOperation(ClientRuntime parent, string name, string action, string replyAction);
    public string get_Action();
    public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public MethodInfo get_BeginMethod();
    public void set_BeginMethod(MethodInfo value);
    public MethodInfo get_EndMethod();
    public void set_EndMethod(MethodInfo value);
    public MethodInfo get_SyncMethod();
    public void set_SyncMethod(MethodInfo value);
    public IClientMessageFormatter get_Formatter();
    public void set_Formatter(IClientMessageFormatter value);
    internal IClientFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IClientFaultFormatter value);
    internal bool get_IsFaultFormatterSetExplicit();
    internal IClientMessageFormatter get_InternalFormatter();
    internal void set_InternalFormatter(IClientMessageFormatter value);
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    public string get_Name();
    public ICollection`1<IParameterInspector> get_ClientParameterInspectors();
    public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    public ClientRuntime get_Parent();
    public string get_ReplyAction();
    public bool get_SerializeRequest();
    public void set_SerializeRequest(bool value);
    public bool get_DeserializeReply();
    public void set_DeserializeReply(bool value);
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    public Type get_TaskTResult();
    public void set_TaskTResult(Type value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientOperationCompatBase : object {
    internal SynchronizedCollection`1<IParameterInspector> parameterInspectors;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IParameterInspector> ParameterInspectors { get; }
    public IList`1<IParameterInspector> get_ParameterInspectors();
}
public class System.ServiceModel.Dispatcher.ClientRuntime : ClientRuntimeCompatBase {
    internal bool AddTransactionFlowProperties { get; internal set; }
    public Type CallbackClientType { get; public set; }
    public SynchronizedCollection`1<IChannelInitializer> ChannelInitializers { get; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    public Type ContractClientType { get; public set; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri Via { get; public set; }
    public bool ValidateMustUnderstand { get; public set; }
    public bool MessageVersionNoneFaultsEnabled { get; public set; }
    internal DispatchRuntime DispatchRuntime { get; }
    public DispatchRuntime CallbackDispatchRuntime { get; }
    internal bool EnableFaults { get; internal set; }
    public SynchronizedCollection`1<IInteractiveChannelInitializer> InteractiveChannelInitializers { get; }
    public int MaxFaultSize { get; public set; }
    internal bool IsOnServer { get; }
    public bool ManualAddressing { get; public set; }
    internal int MaxParameterInspectors { get; }
    public ICollection`1<IClientMessageInspector> ClientMessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IClientMessageInspector> MessageInspectors { get; }
    public ICollection`1<ClientOperation> ClientOperations { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedKeyedCollection`2<string, ClientOperation> Operations { get; }
    public IClientOperationSelector OperationSelector { get; public set; }
    internal object ThisLock { get; }
    public ClientOperation UnhandledClientOperation { get; }
    internal bool UseSynchronizationContext { get; internal set; }
    internal ClientRuntime(DispatchRuntime dispatchRuntime, SharedRuntimeState shared);
    internal ClientRuntime(string contractName, string contractNamespace);
    internal bool get_AddTransactionFlowProperties();
    internal void set_AddTransactionFlowProperties(bool value);
    public Type get_CallbackClientType();
    public void set_CallbackClientType(Type value);
    public SynchronizedCollection`1<IChannelInitializer> get_ChannelInitializers();
    public string get_ContractName();
    public string get_ContractNamespace();
    public Type get_ContractClientType();
    public void set_ContractClientType(Type value);
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_MessageVersionNoneFaultsEnabled();
    public void set_MessageVersionNoneFaultsEnabled(bool value);
    internal DispatchRuntime get_DispatchRuntime();
    public DispatchRuntime get_CallbackDispatchRuntime();
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    public SynchronizedCollection`1<IInteractiveChannelInitializer> get_InteractiveChannelInitializers();
    public int get_MaxFaultSize();
    public void set_MaxFaultSize(int value);
    internal bool get_IsOnServer();
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    internal int get_MaxParameterInspectors();
    public ICollection`1<IClientMessageInspector> get_ClientMessageInspectors();
    public SynchronizedCollection`1<IClientMessageInspector> get_MessageInspectors();
    public ICollection`1<ClientOperation> get_ClientOperations();
    public SynchronizedKeyedCollection`2<string, ClientOperation> get_Operations();
    public IClientOperationSelector get_OperationSelector();
    public void set_OperationSelector(IClientOperationSelector value);
    internal object get_ThisLock();
    public ClientOperation get_UnhandledClientOperation();
    internal bool get_UseSynchronizationContext();
    internal void set_UseSynchronizationContext(bool value);
    internal T[] GetArray(SynchronizedCollection`1<T> collection);
    internal ImmutableClientRuntime GetRuntime();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    internal bool IsFault(Message& reply);
    internal static bool IsMessageVersionNoneFault(Message& message, int maxFaultSize);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientRuntimeCompatBase : object {
    internal SynchronizedCollection`1<IClientMessageInspector> messageInspectors;
    internal SynchronizedKeyedCollection`2<string, ClientOperation> operations;
    internal KeyedCollection`2<string, ClientOperation> compatOperations;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IClientMessageInspector> MessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public KeyedCollection`2<string, ClientOperation> Operations { get; }
    public IList`1<IClientMessageInspector> get_MessageInspectors();
    public KeyedCollection`2<string, ClientOperation> get_Operations();
}
internal class System.ServiceModel.Dispatcher.CloseInputAsyncResult : AsyncResult {
    public CloseInputAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, InstanceContext[] instances);
    private static CloseInputAsyncResult();
    public static void End(IAsyncResult result);
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Dispatcher.CodeGenerator : object {
    internal MethodInfo CurrentMethod { get; }
    private static CodeGenerator();
    internal void BeginMethod(string methodName, Type delegateType, bool allowPrivateMemberAccess);
    internal Delegate EndMethod();
    internal MethodInfo get_CurrentMethod();
    internal ArgBuilder GetArg(int index);
    internal Type GetVariableType(object var);
    internal LocalBuilder DeclareLocal(Type type, string name);
    internal LocalBuilder DeclareLocal(Type type, string name, bool isPinned);
    internal void If();
    internal void IfNot();
    internal void Else();
    internal void EndIf();
    internal void Call(MethodInfo methodInfo);
    internal void New(ConstructorInfo constructor);
    internal void InitObj(Type valueType);
    internal void LoadArrayElement(object obj, object arrayIndex);
    internal void StoreArrayElement(object obj, object arrayIndex, object value);
    internal void Load(object obj);
    internal void Store(object var);
    internal void LoadAddress(object obj);
    internal void ConvertAddress(Type source, Type target);
    internal void ConvertValue(Type source, Type target);
    internal void Castclass(Type target);
    internal void Box(Type type);
    internal void Unbox(Type type);
    internal void Ldobj(Type type);
    internal void Stobj(Type type);
    internal void Ldtoken(Type t);
    internal void Ldc(object o);
    internal void Ldc(bool boolVar);
    internal void Ldc(int intVar);
    internal void Ldstr(string strVar);
    internal void LdlocAddress(LocalBuilder localBuilder);
    internal void Ldloc(LocalBuilder localBuilder);
    internal void Stloc(LocalBuilder local);
    internal void Ldloc(int slot);
    internal void Stloc(int slot);
    internal void Ldloca(LocalBuilder localBuilder);
    internal void Ldloca(int slot);
    internal void LdargAddress(ArgBuilder argBuilder);
    internal void Ldarg(ArgBuilder arg);
    internal void Starg(ArgBuilder arg);
    internal void Ldarg(int slot);
    internal void Starg(int slot);
    internal void Ldarga(ArgBuilder argBuilder);
    internal void Ldarga(int slot);
    internal void Ldelem(Type arrayElementType);
    internal void Ldelema(Type arrayElementType);
    internal void Stelem(Type arrayElementType);
    internal Label DefineLabel();
    internal void MarkLabel(Label label);
    internal void Ret();
    internal void Br(Label label);
    internal void Brfalse(Label label);
    internal void Brtrue(Label label);
    internal void Pop();
    internal void Dup();
    internal void EmitSourceInstruction(string line);
    internal void EmitSourceLabel(string line);
    internal void EmitSourceComment(string comment);
    internal void EmitSourceLine(string line);
    internal void EmitStackTop(Type stackTopType);
    internal void ToString(Type type);
    internal void Concat2();
    internal void LoadZeroValueIntoLocal(Type type, LocalBuilder local);
}
internal class System.ServiceModel.Dispatcher.ConcatFunction : QueryFunction {
    internal ConcatFunction(int argCount);
    internal virtual bool Equals(QueryFunction function);
    internal virtual void Eval(ProcessingContext context);
    internal static ValueDataType[] MakeTypes(int size);
}
internal class System.ServiceModel.Dispatcher.ConcurrencyBehavior : object {
    internal ConcurrencyBehavior(DispatchRuntime runtime);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal static bool IsConcurrent(ConcurrencyMode concurrencyMode, bool ensureOrderedDispatch, bool hasSession, bool supportsTransactedBatch);
    internal static bool IsConcurrent(ChannelDispatcher runtime, bool hasSession);
    internal void LockInstance(MessageRpc& rpc);
    internal void UnlockInstance(MessageRpc& rpc);
    internal static void UnlockInstanceBeforeCallout(OperationContext operationContext);
    internal static void LockInstanceAfterCallout(OperationContext operationContext);
}
internal class System.ServiceModel.Dispatcher.ConcurrencyInstanceContextFacet : object {
    internal bool Locked;
    internal bool HasWaiters { get; }
    internal bool get_HasWaiters();
    internal IWaiter DequeueWaiter();
    internal void EnqueueNewMessage(IWaiter waiter);
    internal void EnqueueCalloutMessage(IWaiter waiter);
}
internal class System.ServiceModel.Dispatcher.CreateInstanceDelegate : MulticastDelegate {
    public CreateInstanceDelegate(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal static class System.ServiceModel.Dispatcher.DataContractSerializerDefaults : object {
    internal static bool IgnoreExtensionDataObject;
    internal static int MaxItemsInObjectGraph;
    internal static DataContractSerializer CreateSerializer(Type type, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerFaultFormatter : FaultFormatter {
    internal DataContractSerializerFaultFormatter(Type[] detailTypes);
    internal DataContractSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerOperationFormatter : OperationFormatter {
    protected MessageInfo requestMessageInfo;
    protected MessageInfo replyMessageInfo;
    public DataContractSerializerOperationFormatter(OperationDescription description, DataContractFormatAttribute dataContractFormatAttribute, DataContractSerializerOperationBehavior serializerFactory);
    private static DataContractSerializerOperationFormatter();
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    internal static Type GetSubstituteDataContractType(Type type, Boolean& isQueryable);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerServiceBehavior : object {
    public bool IgnoreExtensionDataObject { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    internal DataContractSerializerServiceBehavior(bool ignoreExtensionDataObject, int maxItemsInObjectGraph);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    internal static void ApplySerializationSettings(ServiceDescription description, bool ignoreExtensionDataObject, int maxItemsInObjectGraph);
    internal static void ApplySerializationSettings(ServiceEndpoint endpoint, bool ignoreExtensionDataObject, int maxItemsInObjectGraph);
}
public class System.ServiceModel.Dispatcher.DispatchOperation : object {
    public bool IsOneWay { get; }
    public string Action { get; }
    public SynchronizedCollection`1<ICallContextInitializer> CallContextInitializers { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public bool AutoDisposeParameters { get; public set; }
    public IDispatchMessageFormatter Formatter { get; public set; }
    internal IDispatchFaultFormatter FaultFormatter { get; internal set; }
    internal bool IncludeExceptionDetailInFaults { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; }
    public ImpersonationOption Impersonation { get; public set; }
    internal bool HasNoDisposableParameters { get; internal set; }
    internal IDispatchMessageFormatter InternalFormatter { get; internal set; }
    internal IOperationInvoker InternalInvoker { get; internal set; }
    public IOperationInvoker Invoker { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public string Name { get; }
    public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public DispatchRuntime Parent { get; }
    internal ReceiveContextAcknowledgementMode ReceiveContextAcknowledgementMode { get; internal set; }
    internal bool BufferedReceiveEnabled { get; internal set; }
    public bool ReleaseInstanceAfterCall { get; public set; }
    public bool ReleaseInstanceBeforeCall { get; public set; }
    public string ReplyAction { get; }
    public bool DeserializeRequest { get; public set; }
    public bool SerializeReply { get; public set; }
    public bool TransactionAutoComplete { get; public set; }
    public bool TransactionRequired { get; public set; }
    public bool IsInsideTransactedReceiveScope { get; public set; }
    public DispatchOperation(DispatchRuntime parent, string name, string action);
    public DispatchOperation(DispatchRuntime parent, string name, string action, string replyAction);
    public bool get_IsOneWay();
    public string get_Action();
    public SynchronizedCollection`1<ICallContextInitializer> get_CallContextInitializers();
    public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public bool get_AutoDisposeParameters();
    public void set_AutoDisposeParameters(bool value);
    public IDispatchMessageFormatter get_Formatter();
    public void set_Formatter(IDispatchMessageFormatter value);
    internal IDispatchFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IDispatchFaultFormatter value);
    internal bool get_IncludeExceptionDetailInFaults();
    internal void set_IncludeExceptionDetailInFaults(bool value);
    internal bool get_IsFaultFormatterSetExplicit();
    public ImpersonationOption get_Impersonation();
    public void set_Impersonation(ImpersonationOption value);
    internal bool get_HasNoDisposableParameters();
    internal void set_HasNoDisposableParameters(bool value);
    internal IDispatchMessageFormatter get_InternalFormatter();
    internal void set_InternalFormatter(IDispatchMessageFormatter value);
    internal IOperationInvoker get_InternalInvoker();
    internal void set_InternalInvoker(IOperationInvoker value);
    public IOperationInvoker get_Invoker();
    public void set_Invoker(IOperationInvoker value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    public string get_Name();
    public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    public DispatchRuntime get_Parent();
    [CompilerGeneratedAttribute]
internal ReceiveContextAcknowledgementMode get_ReceiveContextAcknowledgementMode();
    [CompilerGeneratedAttribute]
internal void set_ReceiveContextAcknowledgementMode(ReceiveContextAcknowledgementMode value);
    internal bool get_BufferedReceiveEnabled();
    internal void set_BufferedReceiveEnabled(bool value);
    public bool get_ReleaseInstanceAfterCall();
    public void set_ReleaseInstanceAfterCall(bool value);
    public bool get_ReleaseInstanceBeforeCall();
    public void set_ReleaseInstanceBeforeCall(bool value);
    public string get_ReplyAction();
    public bool get_DeserializeRequest();
    public void set_DeserializeRequest(bool value);
    public bool get_SerializeReply();
    public void set_SerializeReply(bool value);
    public bool get_TransactionAutoComplete();
    public void set_TransactionAutoComplete(bool value);
    public bool get_TransactionRequired();
    public void set_TransactionRequired(bool value);
    public bool get_IsInsideTransactedReceiveScope();
    public void set_IsInsideTransactedReceiveScope(bool value);
}
internal class System.ServiceModel.Dispatcher.DispatchOperationRuntime : object {
    internal string Action { get; }
    internal ICallContextInitializer[] CallContextInitializers { get; }
    internal bool DisposeParameters { get; }
    internal bool HasDefaultUnhandledActionInvoker { get; }
    internal bool SerializeReply { get; }
    internal IDispatchFaultFormatter FaultFormatter { get; }
    internal IDispatchMessageFormatter Formatter { get; }
    internal ImpersonationOption Impersonation { get; }
    internal IOperationInvoker Invoker { get; }
    internal bool IsSynchronous { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal string Name { get; }
    internal IParameterInspector[] ParameterInspectors { get; }
    internal ImmutableDispatchRuntime Parent { get; }
    internal ReceiveContextAcknowledgementMode ReceiveContextAcknowledgementMode { get; }
    internal bool ReleaseInstanceAfterCall { get; }
    internal bool ReleaseInstanceBeforeCall { get; }
    internal string ReplyAction { get; }
    internal bool TransactionAutoComplete { get; }
    internal bool TransactionRequired { get; }
    internal bool IsInsideTransactedReceiveScope { get; }
    internal DispatchOperationRuntime(DispatchOperation operation, ImmutableDispatchRuntime parent);
    private static DispatchOperationRuntime();
    internal string get_Action();
    internal ICallContextInitializer[] get_CallContextInitializers();
    internal bool get_DisposeParameters();
    internal bool get_HasDefaultUnhandledActionInvoker();
    internal bool get_SerializeReply();
    internal IDispatchFaultFormatter get_FaultFormatter();
    internal IDispatchMessageFormatter get_Formatter();
    internal ImpersonationOption get_Impersonation();
    internal IOperationInvoker get_Invoker();
    internal bool get_IsSynchronous();
    internal bool get_IsOneWay();
    internal bool get_IsTerminating();
    internal string get_Name();
    internal IParameterInspector[] get_ParameterInspectors();
    internal ImmutableDispatchRuntime get_Parent();
    internal ReceiveContextAcknowledgementMode get_ReceiveContextAcknowledgementMode();
    internal bool get_ReleaseInstanceAfterCall();
    internal bool get_ReleaseInstanceBeforeCall();
    internal string get_ReplyAction();
    internal bool get_TransactionAutoComplete();
    internal bool get_TransactionRequired();
    internal bool get_IsInsideTransactedReceiveScope();
    [DebuggerStepperBoundaryAttribute]
[SecuritySafeCriticalAttribute]
internal void InvokeBegin(MessageRpc& rpc);
    [DebuggerStepperBoundaryAttribute]
[SecuritySafeCriticalAttribute]
internal void InvokeEnd(MessageRpc& rpc);
}
public class System.ServiceModel.Dispatcher.DispatchRuntime : object {
    public IInstanceContextProvider InstanceContextProvider { get; public set; }
    public InstanceContext SingletonInstanceContext { get; public set; }
    public ConcurrencyMode ConcurrencyMode { get; public set; }
    public bool EnsureOrderedDispatch { get; public set; }
    public AuditLogLocation SecurityAuditLogLocation { get; public set; }
    public bool SuppressAuditFailure { get; public set; }
    public AuditLevel ServiceAuthorizationAuditLevel { get; public set; }
    public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; public set; }
    public ServiceAuthenticationManager ServiceAuthenticationManager { get; public set; }
    public ServiceAuthorizationManager ServiceAuthorizationManager { get; public set; }
    public bool AutomaticInputSessionShutdown { get; public set; }
    public ChannelDispatcher ChannelDispatcher { get; }
    public ClientRuntime CallbackClientRuntime { get; }
    public EndpointDispatcher EndpointDispatcher { get; }
    public bool ImpersonateCallerForAllOperations { get; public set; }
    public bool ImpersonateOnSerializingReply { get; public set; }
    internal bool RequireClaimsPrincipalOnOperationContext { get; internal set; }
    public SynchronizedCollection`1<IInputSessionShutdown> InputSessionShutdownHandlers { get; }
    public bool IgnoreTransactionMessageProperty { get; public set; }
    public IInstanceProvider InstanceProvider { get; public set; }
    public SynchronizedCollection`1<IDispatchMessageInspector> MessageInspectors { get; }
    public SynchronizedKeyedCollection`2<string, DispatchOperation> Operations { get; }
    public IDispatchOperationSelector OperationSelector { get; public set; }
    public bool ReleaseServiceInstanceOnTransactionComplete { get; public set; }
    public SynchronizedCollection`1<IInstanceContextInitializer> InstanceContextInitializers { get; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    public PrincipalPermissionMode PrincipalPermissionMode { get; public set; }
    public RoleProvider RoleProvider { get; public set; }
    public bool TransactionAutoCompleteOnSessionClose { get; public set; }
    public Type Type { get; public set; }
    public DispatchOperation UnhandledDispatchOperation { get; public set; }
    public bool ValidateMustUnderstand { get; public set; }
    public bool PreserveMessage { get; public set; }
    internal bool RequiresAuthentication { get; }
    internal bool RequiresAuthorization { get; }
    internal bool HasMatchAllOperation { get; }
    internal bool EnableFaults { get; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; }
    internal int MaxCallContextInitializers { get; }
    internal int MaxParameterInspectors { get; }
    internal ClientRuntime ClientRuntime { get; }
    internal object ThisLock { get; }
    internal bool IsRoleProviderSet { get; }
    internal DispatchRuntime(EndpointDispatcher endpointDispatcher);
    internal DispatchRuntime(ClientRuntime proxyRuntime, SharedRuntimeState shared);
    public IInstanceContextProvider get_InstanceContextProvider();
    public void set_InstanceContextProvider(IInstanceContextProvider value);
    public InstanceContext get_SingletonInstanceContext();
    public void set_SingletonInstanceContext(InstanceContext value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public bool get_EnsureOrderedDispatch();
    public void set_EnsureOrderedDispatch(bool value);
    public AuditLogLocation get_SecurityAuditLogLocation();
    public void set_SecurityAuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_ServiceAuthorizationAuditLevel();
    public void set_ServiceAuthorizationAuditLevel(AuditLevel value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_ExternalAuthorizationPolicies();
    public void set_ExternalAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public ServiceAuthenticationManager get_ServiceAuthenticationManager();
    public void set_ServiceAuthenticationManager(ServiceAuthenticationManager value);
    public ServiceAuthorizationManager get_ServiceAuthorizationManager();
    public void set_ServiceAuthorizationManager(ServiceAuthorizationManager value);
    public bool get_AutomaticInputSessionShutdown();
    public void set_AutomaticInputSessionShutdown(bool value);
    public ChannelDispatcher get_ChannelDispatcher();
    public ClientRuntime get_CallbackClientRuntime();
    public EndpointDispatcher get_EndpointDispatcher();
    public bool get_ImpersonateCallerForAllOperations();
    public void set_ImpersonateCallerForAllOperations(bool value);
    public bool get_ImpersonateOnSerializingReply();
    public void set_ImpersonateOnSerializingReply(bool value);
    internal bool get_RequireClaimsPrincipalOnOperationContext();
    internal void set_RequireClaimsPrincipalOnOperationContext(bool value);
    public SynchronizedCollection`1<IInputSessionShutdown> get_InputSessionShutdownHandlers();
    public bool get_IgnoreTransactionMessageProperty();
    public void set_IgnoreTransactionMessageProperty(bool value);
    public IInstanceProvider get_InstanceProvider();
    public void set_InstanceProvider(IInstanceProvider value);
    public SynchronizedCollection`1<IDispatchMessageInspector> get_MessageInspectors();
    public SynchronizedKeyedCollection`2<string, DispatchOperation> get_Operations();
    public IDispatchOperationSelector get_OperationSelector();
    public void set_OperationSelector(IDispatchOperationSelector value);
    public bool get_ReleaseServiceInstanceOnTransactionComplete();
    public void set_ReleaseServiceInstanceOnTransactionComplete(bool value);
    public SynchronizedCollection`1<IInstanceContextInitializer> get_InstanceContextInitializers();
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    public PrincipalPermissionMode get_PrincipalPermissionMode();
    public void set_PrincipalPermissionMode(PrincipalPermissionMode value);
    public RoleProvider get_RoleProvider();
    public void set_RoleProvider(RoleProvider value);
    public bool get_TransactionAutoCompleteOnSessionClose();
    public void set_TransactionAutoCompleteOnSessionClose(bool value);
    public Type get_Type();
    public void set_Type(Type value);
    public DispatchOperation get_UnhandledDispatchOperation();
    public void set_UnhandledDispatchOperation(DispatchOperation value);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_PreserveMessage();
    public void set_PreserveMessage(bool value);
    internal bool get_RequiresAuthentication();
    internal bool get_RequiresAuthorization();
    internal bool get_HasMatchAllOperation();
    internal bool get_EnableFaults();
    internal bool get_IsOnServer();
    internal bool get_ManualAddressing();
    internal int get_MaxCallContextInitializers();
    internal int get_MaxParameterInspectors();
    internal ClientRuntime get_ClientRuntime();
    internal object get_ThisLock();
    internal bool get_IsRoleProviderSet();
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal ImmutableDispatchRuntime GetRuntime();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    internal void SetDebugFlagInDispatchOperations(bool includeExceptionDetailInFaults);
}
internal class System.ServiceModel.Dispatcher.DivideOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.DummyNodeCounter : object {
    internal static DummyNodeCounter Dummy;
    public int CounterMarker { get; public set; }
    unknown int MaxCounter {public set; }
    private static DummyNodeCounter();
    public sealed virtual int get_CounterMarker();
    public sealed virtual void set_CounterMarker(int value);
    public sealed virtual void set_MaxCounter(int value);
    public sealed virtual int ElapsedCount(int marker);
    public sealed virtual void Increase();
    public sealed virtual void IncreaseBy(int count);
}
internal class System.ServiceModel.Dispatcher.DuplexChannelBinder : object {
    public IChannel Channel { get; }
    public TimeSpan DefaultCloseTimeout { get; public set; }
    internal ChannelHandler ChannelHandler { get; internal set; }
    public TimeSpan DefaultSendTimeout { get; public set; }
    public bool HasSession { get; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator);
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, bool useActiveAutoClose);
    public sealed virtual IChannel get_Channel();
    public TimeSpan get_DefaultCloseTimeout();
    public void set_DefaultCloseTimeout(TimeSpan value);
    internal ChannelHandler get_ChannelHandler();
    internal void set_ChannelHandler(ChannelHandler value);
    public TimeSpan get_DefaultSendTimeout();
    public void set_DefaultSendTimeout(TimeSpan value);
    public sealed virtual bool get_HasSession();
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    internal bool HandleRequestAsReply(Message message);
    public void EnsurePumping();
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.EndBooleanOpcode : ApplyBooleanOpcode {
    internal EndBooleanOpcode(Opcode jump, bool test);
    internal virtual Opcode Eval(ProcessingContext context);
}
public class System.ServiceModel.Dispatcher.EndpointAddressMessageFilter : MessageFilter {
    public EndpointAddress Address { get; }
    public bool IncludeHostNameInComparison { get; }
    internal Dictionary`2<string, HeaderBit[]> HeaderLookup { get; }
    unknown bool ComparePort {internal set; }
    public EndpointAddressMessageFilter(EndpointAddress address);
    public EndpointAddressMessageFilter(EndpointAddress address, bool includeHostNameInComparison);
    public EndpointAddress get_Address();
    public bool get_IncludeHostNameInComparison();
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public virtual bool Match(MessageBuffer messageBuffer);
    public virtual bool Match(Message message);
    internal Dictionary`2<string, HeaderBit[]> get_HeaderLookup();
    internal void set_ComparePort(bool value);
}
internal class System.ServiceModel.Dispatcher.EndpointAddressMessageFilterHelper : object {
    internal Dictionary`2<string, HeaderBit[]> HeaderLookup { get; }
    internal EndpointAddressMessageFilterHelper(EndpointAddress address);
    internal Dictionary`2<string, HeaderBit[]> get_HeaderLookup();
    internal bool Match(Message message);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.EndpointAddressMessageFilterTable`1 : object {
    protected Dictionary`2<MessageFilter, TFilterData> filters;
    protected Dictionary`2<MessageFilter, Candidate<TFilterData>> candidates;
    public TFilterData Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<TFilterData> Values { get; }
    protected virtual void InitializeLookupTables();
    public sealed virtual TFilterData get_Item(MessageFilter filter);
    public sealed virtual void set_Item(MessageFilter filter, TFilterData value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<TFilterData> get_Values();
    public virtual void Add(MessageFilter filter, TFilterData data);
    public virtual void Add(EndpointAddressMessageFilter filter, TFilterData data);
    protected void IncrementQNameCount(CandidateSet<TFilterData> cset, EndpointAddress address);
    public sealed virtual void Add(KeyValuePair`2<MessageFilter, TFilterData> item);
    protected Byte[] BuildMask(Dictionary`2<string, HeaderBit[]> headerLookup);
    public sealed virtual void Clear();
    protected virtual void ClearLookupTables();
    public sealed virtual bool Contains(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool ContainsKey(MessageFilter filter);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageFilter, TFilterData>> GetEnumerator();
    internal virtual bool TryMatchCandidateSet(Uri to, bool includeHostNameInComparison, CandidateSet& cset);
    protected void InnerMatchFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingValue(Message message, TFilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer messageBuffer, TFilterData& data);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
    protected void RebuildMasks();
    public virtual bool Remove(MessageFilter filter);
    public virtual bool Remove(EndpointAddressMessageFilter filter);
    protected void DecrementQNameCount(CandidateSet<TFilterData> cset, EndpointAddress address);
    public sealed virtual bool Remove(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool TryGetValue(MessageFilter filter, TFilterData& data);
}
internal class System.ServiceModel.Dispatcher.EndpointAddressProcessor : object {
    internal static QNameKeyComparer QNameComparer;
    internal static string XsiNs;
    internal static string SerNs;
    internal static string TypeLN;
    internal static string ItemTypeLN;
    internal static string FactoryTypeLN;
    internal EndpointAddressProcessor next;
    internal EndpointAddressProcessor Next { get; internal set; }
    internal EndpointAddressProcessor(int length);
    private static EndpointAddressProcessor();
    internal EndpointAddressProcessor get_Next();
    internal void set_Next(EndpointAddressProcessor value);
    internal static string GetComparableForm(StringBuilder builder, XmlReader reader);
    internal void Clear(int length);
    internal void ProcessHeaders(Message msg, Dictionary`2<QName, int> qnameLookup, Dictionary`2<string, HeaderBit[]> headerLookup);
    internal void SetBit(HeaderBit[] bits);
    internal bool TestExact(Byte[] exact);
    internal bool TestMask(Byte[] mask);
}
public class System.ServiceModel.Dispatcher.EndpointDispatcher : object {
    public MessageFilter AddressFilter { get; public set; }
    internal bool AddressFilterSetExplicit { get; }
    public ChannelDispatcher ChannelDispatcher { get; }
    public MessageFilter ContractFilter { get; public set; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    internal ServiceChannel DatagramChannel { get; internal set; }
    public DispatchRuntime DispatchRuntime { get; }
    internal Uri ListenUri { get; }
    internal EndpointAddress OriginalAddress { get; }
    public EndpointAddress EndpointAddress { get; }
    public bool IsSystemEndpoint { get; }
    internal MessageFilter EndpointFilter { get; }
    public int FilterPriority { get; public set; }
    internal string Id { get; internal set; }
    internal string PerfCounterId { get; }
    internal string PerfCounterBaseId { get; }
    internal int PerfCounterInstanceId { get; internal set; }
    internal EndpointDispatcher(EndpointAddress address, string contractName, string contractNamespace, string id, bool isSystemEndpoint);
    public EndpointDispatcher(EndpointAddress address, string contractName, string contractNamespace);
    public EndpointDispatcher(EndpointAddress address, string contractName, string contractNamespace, bool isSystemEndpoint);
    public MessageFilter get_AddressFilter();
    public void set_AddressFilter(MessageFilter value);
    internal bool get_AddressFilterSetExplicit();
    public ChannelDispatcher get_ChannelDispatcher();
    public MessageFilter get_ContractFilter();
    public void set_ContractFilter(MessageFilter value);
    public string get_ContractName();
    public string get_ContractNamespace();
    internal ServiceChannel get_DatagramChannel();
    internal void set_DatagramChannel(ServiceChannel value);
    public DispatchRuntime get_DispatchRuntime();
    internal Uri get_ListenUri();
    internal EndpointAddress get_OriginalAddress();
    public EndpointAddress get_EndpointAddress();
    public bool get_IsSystemEndpoint();
    internal MessageFilter get_EndpointFilter();
    public int get_FilterPriority();
    public void set_FilterPriority(int value);
    internal string get_Id();
    internal void set_Id(string value);
    internal string get_PerfCounterId();
    internal string get_PerfCounterBaseId();
    [CompilerGeneratedAttribute]
internal int get_PerfCounterInstanceId();
    [CompilerGeneratedAttribute]
internal void set_PerfCounterInstanceId(int value);
    internal static EndpointDispatcher AddEndpointDispatcher(EndpointDispatcher baseEndpoint, IEnumerable`1<AddressHeader> headers);
    internal void Attach(ChannelDispatcher channelDispatcher);
    internal void Detach(ChannelDispatcher channelDispatcher);
    internal void ReleasePerformanceCounters();
    internal bool SetPerfCounterId();
}
internal class System.ServiceModel.Dispatcher.EndpointDispatcherTable : object {
    public int Count { get; }
    public EndpointDispatcherTable(object thisLock);
    public int get_Count();
    public void AddEndpoint(EndpointDispatcher endpoint);
    public void RemoveEndpoint(EndpointDispatcher endpoint);
    public EndpointDispatcher Lookup(Message message, Boolean& addressMatched);
}
internal class System.ServiceModel.Dispatcher.EndpointFilterProvider : object {
    public SynchronizedCollection`1<string> InitiatingActions { get; }
    public EndpointFilterProvider(String[] initiatingActions);
    public SynchronizedCollection`1<string> get_InitiatingActions();
    public MessageFilter CreateFilter(Int32& priority);
}
internal class System.ServiceModel.Dispatcher.ErrorBehavior : object {
    internal IErrorHandler[] Handlers { get; }
    internal ErrorBehavior(ChannelDispatcher channelDispatcher);
    internal IErrorHandler[] get_Handlers();
    internal void ProvideMessageFault(MessageRpc& rpc);
    internal void ProvideOnlyFaultOfLastResort(MessageRpc& rpc);
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void HandleError(MessageRpc& rpc);
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal static bool ShouldRethrowExceptionAsIs(Exception e);
    internal static bool ShouldRethrowClientSideExceptionAsIs(Exception e);
    internal static void ThrowAndCatch(Exception e, Message message);
    internal static void ThrowAndCatch(Exception e);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlerFaultInfo : ValueType {
    private Message fault;
    private bool isConsideredUnhandled;
    private string defaultFaultAction;
    public Message Fault { get; public set; }
    public string DefaultFaultAction { get; public set; }
    public bool IsConsideredUnhandled { get; public set; }
    public ErrorHandlerFaultInfo(string defaultFaultAction);
    public Message get_Fault();
    public void set_Fault(Message value);
    public string get_DefaultFaultAction();
    public void set_DefaultFaultAction(string value);
    public bool get_IsConsideredUnhandled();
    public void set_IsConsideredUnhandled(bool value);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlingAcceptor : object {
    internal ErrorHandlingAcceptor(IListenerBinder binder, ChannelDispatcher dispatcher);
    internal void Close();
    internal bool TryAccept(TimeSpan timeout, IChannelBinder& channelBinder);
    internal IAsyncResult BeginTryAccept(TimeSpan timeout, AsyncCallback callback, object state);
    internal bool EndTryAccept(IAsyncResult result, IChannelBinder& channelBinder);
    internal void WaitForChannel();
    internal IAsyncResult BeginWaitForChannel(AsyncCallback callback, object state);
    internal void EndWaitForChannel(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlingReceiver : object {
    internal ErrorHandlingReceiver(IChannelBinder binder, ChannelDispatcher dispatcher);
    internal void Close();
    internal bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    internal IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    internal bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    internal void WaitForMessage();
    internal IAsyncResult BeginWaitForMessage(AsyncCallback callback, object state);
    internal void EndWaitForMessage(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.EvalStack : ValueType {
    internal QueryBuffer`1<Value> buffer;
    internal StackRegion frames;
    internal StackRegion stack;
    internal static int DefaultSize;
    internal bool contextOnTopOfStack;
    internal Value[] Buffer { get; }
    internal StackFrame Item { get; }
    internal StackFrame SecondArg { get; }
    internal StackFrame TopArg { get; }
    internal bool InUse { get; }
    internal EvalStack(int frameCapacity, int stackCapacity);
    internal Value[] get_Buffer();
    internal StackFrame get_Item(int frameIndex);
    internal StackFrame get_SecondArg();
    internal StackFrame get_TopArg();
    internal void Clear();
    internal void CopyFrom(EvalStack& stack);
    internal int CalculateNodecount();
    internal bool get_InUse();
    internal bool PeekBoolean(int index);
    internal double PeekDouble(int index);
    internal NodeSequence PeekSequence(int index);
    internal string PeekString(int index);
    internal void PopFrame(ProcessingContext context);
    internal void PushFrame();
    internal void PopSequenceFrameTo(EvalStack& dest);
    internal void Push(string val);
    internal void Push(string val, int addCount);
    internal void Push(bool val);
    internal void Push(bool val, int addCount);
    internal void Push(double val);
    internal void Push(double val, int addCount);
    internal void Push(NodeSequence val);
    internal void Push(NodeSequence val, int addCount);
    internal void Push(Value[] buffer, int startAt, int addCount);
    internal void ReplaceAt(int index, NodeSequence seq);
    internal void SetValue(ProcessingContext context, int index, bool val);
    internal void SetValue(ProcessingContext context, int index, double val);
    internal void SetValue(ProcessingContext context, int index, string val);
    internal void SetValue(ProcessingContext context, int index, NodeSequence val);
    internal void TransferPositionsTo(EvalStack& stack);
    internal void TransferSequenceSizeTo(EvalStack& stack);
}
public abstract class System.ServiceModel.Dispatcher.ExceptionHandler : object {
    public static ExceptionHandler AlwaysHandle { get; }
    public static ExceptionHandler AsynchronousThreadExceptionHandler { get; public set; }
    public static ExceptionHandler TransportExceptionHandler { get; public set; }
    private static ExceptionHandler();
    public static ExceptionHandler get_AlwaysHandle();
    [ReliabilityContractAttribute("3", "2")]
public static ExceptionHandler get_AsynchronousThreadExceptionHandler();
    [SecuritySafeCriticalAttribute]
public static void set_AsynchronousThreadExceptionHandler(ExceptionHandler value);
    public static ExceptionHandler get_TransportExceptionHandler();
    public static void set_TransportExceptionHandler(ExceptionHandler value);
    public abstract virtual bool HandleException(Exception exception);
    internal static bool HandleTransportExceptionHelper(Exception exception);
}
internal enum System.ServiceModel.Dispatcher.ExclusiveInstanceContextTransactionResult : Enum {
    public int value__;
    public static ExclusiveInstanceContextTransactionResult Acquired;
    public static ExclusiveInstanceContextTransactionResult Wait;
    public static ExclusiveInstanceContextTransactionResult Fault;
}
public class System.ServiceModel.Dispatcher.FaultContractInfo : object {
    public string Action { get; }
    public Type Detail { get; }
    internal string ElementName { get; }
    internal string ElementNamespace { get; }
    internal IList`1<Type> KnownTypes { get; }
    internal DataContractSerializer Serializer { get; }
    public FaultContractInfo(string action, Type detail);
    internal FaultContractInfo(string action, Type detail, XmlName elementName, string ns, IList`1<Type> knownTypes);
    public string get_Action();
    public Type get_Detail();
    internal string get_ElementName();
    internal string get_ElementNamespace();
    internal IList`1<Type> get_KnownTypes();
    internal DataContractSerializer get_Serializer();
}
internal class System.ServiceModel.Dispatcher.FaultFormatter : object {
    internal FaultFormatter(Type[] detailTypes);
    internal FaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
    public sealed virtual MessageFault Serialize(FaultException faultException, String& action);
    public sealed virtual FaultException Deserialize(MessageFault messageFault, string action);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
    protected FaultException CreateFaultException(MessageFault messageFault, string action, object detailObj, Type detailType, XmlDictionaryReader detailReader);
}
public class System.ServiceModel.Dispatcher.FilterInvalidBodyAccessException : InvalidBodyAccessException {
    public Collection`1<MessageFilter> Filters { get; }
    protected FilterInvalidBodyAccessException(SerializationInfo info, StreamingContext context);
    public FilterInvalidBodyAccessException(string message);
    public FilterInvalidBodyAccessException(string message, Exception innerException);
    public FilterInvalidBodyAccessException(string message, Collection`1<MessageFilter> filters);
    public FilterInvalidBodyAccessException(string message, Exception innerException, Collection`1<MessageFilter> filters);
    public Collection`1<MessageFilter> get_Filters();
}
internal class System.ServiceModel.Dispatcher.FilterResult : ValueType {
    private QueryProcessor processor;
    private bool result;
    internal QueryProcessor Processor { get; }
    internal bool Result { get; }
    internal FilterResult(QueryProcessor processor);
    internal FilterResult(bool result);
    internal QueryProcessor get_Processor();
    internal bool get_Result();
    internal MessageFilter GetSingleMatch();
}
internal class System.ServiceModel.Dispatcher.FlowThrottle : object {
    internal int Capacity { get; internal set; }
    internal FlowThrottle(WaitCallback release, int capacity, string propertyName, string configName);
    internal int get_Capacity();
    internal void set_Capacity(int value);
    internal bool Acquire(object o);
    internal void Release();
    internal void SetReleased(Action action);
    internal void SetAcquired(Action action);
    internal void SetRatio(Action`1<int> action);
}
internal class System.ServiceModel.Dispatcher.FunctionCallOpcode : Opcode {
    internal FunctionCallOpcode(QueryFunction function);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.GenericSeekableNavigator : SeekableXPathNavigator {
    public string BaseURI { get; }
    public bool HasAttributes { get; }
    public bool HasChildren { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XPathNodeType NodeType { get; }
    public string Prefix { get; }
    public string Value { get; }
    public string XmlLang { get; }
    public long CurrentPosition { get; public set; }
    internal XPathNavigator Item { get; }
    internal GenericSeekableNavigator(XPathNavigator navigator);
    internal GenericSeekableNavigator(GenericSeekableNavigator navigator);
    public virtual string get_BaseURI();
    public virtual bool get_HasAttributes();
    public virtual bool get_HasChildren();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XPathNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual long get_CurrentPosition();
    public virtual void set_CurrentPosition(long value);
    internal XPathNavigator get_Item(long nodePosition);
    public virtual XPathNavigator Clone();
    public virtual XmlNodeOrder ComparePosition(XPathNavigator navigator);
    public virtual XmlNodeOrder ComparePosition(long x, long y);
    public virtual string GetLocalName(long nodePosition);
    public virtual string GetName(long nodePosition);
    public virtual string GetNamespace(long nodePosition);
    public virtual XPathNodeType GetNodeType(long nodePosition);
    public virtual string GetValue(long nodePosition);
    public virtual string GetNamespace(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual bool IsDescendant(XPathNavigator navigator);
    public virtual bool IsSamePosition(XPathNavigator other);
    public virtual void MoveToRoot();
    public virtual bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToPrevious();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNamespace(string name);
    public virtual bool MoveToParent();
    public virtual bool MoveTo(XPathNavigator other);
    public virtual bool MoveToId(string id);
    public virtual bool MoveToFirstChild();
    public virtual bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToNext();
    public virtual bool MoveToFirst();
    internal void SnapshotNavigator();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.Dispatcher.HashBranchIndex : QueryBranchIndex {
    internal int Count { get; }
    internal QueryBranch Item { get; internal set; }
    internal virtual int get_Count();
    internal virtual QueryBranch get_Item(object literal);
    internal virtual void set_Item(object literal, QueryBranch value);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual void Remove(object key);
    internal virtual void Trim();
}
internal abstract class System.ServiceModel.Dispatcher.HeaderFilter : MessageFilter {
    public virtual bool Match(MessageBuffer buffer);
}
public interface System.ServiceModel.Dispatcher.ICallContextInitializer {
    public abstract virtual object BeforeInvoke(InstanceContext instanceContext, IClientChannel channel, Message message);
    public abstract virtual void AfterInvoke(object correlationState);
}
internal interface System.ServiceModel.Dispatcher.IChannelBinder {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public abstract virtual IChannel get_Channel();
    public abstract virtual bool get_HasSession();
    public abstract virtual Uri get_ListenUri();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual void Abort();
    public abstract virtual void CloseAfterFault(TimeSpan timeout);
    public abstract virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
    public abstract virtual RequestContext CreateRequestContext(Message message);
}
public interface System.ServiceModel.Dispatcher.IChannelInitializer {
    public abstract virtual void Initialize(IClientChannel channel);
}
internal interface System.ServiceModel.Dispatcher.IClientFaultFormatter {
    public abstract virtual FaultException Deserialize(MessageFault messageFault, string action);
}
public interface System.ServiceModel.Dispatcher.IClientMessageFormatter {
    public abstract virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public abstract virtual object DeserializeReply(Message message, Object[] parameters);
}
public interface System.ServiceModel.Dispatcher.IClientMessageInspector {
    public abstract virtual object BeforeSendRequest(Message& request, IClientChannel channel);
    public abstract virtual void AfterReceiveReply(Message& reply, object correlationState);
}
public interface System.ServiceModel.Dispatcher.IClientOperationSelector {
    public bool AreParametersRequiredForSelection { get; }
    public abstract virtual bool get_AreParametersRequiredForSelection();
    public abstract virtual string SelectOperation(MethodBase method, Object[] parameters);
}
internal interface System.ServiceModel.Dispatcher.IDispatchFaultFormatter {
    public abstract virtual MessageFault Serialize(FaultException faultException, String& action);
}
internal interface System.ServiceModel.Dispatcher.IDispatchFaultFormatterWrapper {
    public IDispatchFaultFormatter InnerFaultFormatter { get; public set; }
    public abstract virtual IDispatchFaultFormatter get_InnerFaultFormatter();
    public abstract virtual void set_InnerFaultFormatter(IDispatchFaultFormatter value);
}
public interface System.ServiceModel.Dispatcher.IDispatchMessageFormatter {
    public abstract virtual void DeserializeRequest(Message message, Object[] parameters);
    public abstract virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
}
public interface System.ServiceModel.Dispatcher.IDispatchMessageInspector {
    public abstract virtual object AfterReceiveRequest(Message& request, IClientChannel channel, InstanceContext instanceContext);
    public abstract virtual void BeforeSendReply(Message& reply, object correlationState);
}
public interface System.ServiceModel.Dispatcher.IDispatchOperationSelector {
    public abstract virtual string SelectOperation(Message& message);
}
public interface System.ServiceModel.Dispatcher.IErrorHandler {
    public abstract virtual void ProvideFault(Exception error, MessageVersion version, Message& fault);
    public abstract virtual bool HandleError(Exception error);
}
internal class System.ServiceModel.Dispatcher.IfState : object {
    internal Label EndIf { get; internal set; }
    internal Label ElseBegin { get; internal set; }
    internal Label get_EndIf();
    internal void set_EndIf(Label value);
    internal Label get_ElseBegin();
    internal void set_ElseBegin(Label value);
}
internal interface System.ServiceModel.Dispatcher.IFunctionLibrary {
    public abstract virtual QueryFunction Bind(string functionName, string functionNamespace, XPathExprList args);
}
public interface System.ServiceModel.Dispatcher.IInputSessionShutdown {
    public abstract virtual void ChannelFaulted(IDuplexContextChannel channel);
    public abstract virtual void DoneReceiving(IDuplexContextChannel channel);
}
public interface System.ServiceModel.Dispatcher.IInstanceContextInitializer {
    public abstract virtual void Initialize(InstanceContext instanceContext, Message message);
}
internal interface System.ServiceModel.Dispatcher.IInstanceContextManager {
    public abstract virtual void Abort();
    public abstract virtual void Add(InstanceContext instanceContext);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginCloseInput(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void CloseInput(TimeSpan timeout);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void EndCloseInput(IAsyncResult result);
    public abstract virtual bool Remove(InstanceContext instanceContext);
    public abstract virtual InstanceContext[] ToArray();
}
public interface System.ServiceModel.Dispatcher.IInstanceContextProvider {
    public abstract virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    public abstract virtual void InitializeInstanceContext(InstanceContext instanceContext, Message message, IContextChannel channel);
    public abstract virtual bool IsIdle(InstanceContext instanceContext);
    public abstract virtual void NotifyIdle(InstanceContextIdleCallback callback, InstanceContext instanceContext);
}
public interface System.ServiceModel.Dispatcher.IInstanceProvider {
    public abstract virtual object GetInstance(InstanceContext instanceContext);
    public abstract virtual object GetInstance(InstanceContext instanceContext, Message message);
    public abstract virtual void ReleaseInstance(InstanceContext instanceContext, object instance);
}
internal interface System.ServiceModel.Dispatcher.IInstanceTransaction {
    public abstract virtual Transaction GetTransactionForInstance(OperationContext operationContext);
}
public interface System.ServiceModel.Dispatcher.IInteractiveChannelInitializer {
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(IClientChannel channel, AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
internal interface System.ServiceModel.Dispatcher.IInvokeReceivedNotification {
    public abstract virtual void NotifyInvokeReceived();
    public abstract virtual void NotifyInvokeReceived(RequestContext request);
}
internal interface System.ServiceModel.Dispatcher.IItemComparer`2 {
    public abstract virtual int Compare(K key, V value);
}
internal interface System.ServiceModel.Dispatcher.IListenerBinder {
    public IChannelListener Listener { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual IChannelListener get_Listener();
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual IChannelBinder Accept(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAccept(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IChannelBinder EndAccept(IAsyncResult result);
}
internal interface System.ServiceModel.Dispatcher.IManualConcurrencyOperationInvoker {
    public bool OwnsFormatter { get; }
    public abstract virtual bool get_OwnsFormatter();
    public abstract virtual object Invoke(object instance, Object[] inputs, IInvokeReceivedNotification notification, Object[]& outputs);
    public abstract virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, IInvokeReceivedNotification notification, AsyncCallback callback, object state);
}
public interface System.ServiceModel.Dispatcher.IMessageFilterTable`1 {
    public abstract virtual bool GetMatchingValue(Message message, TFilterData& value);
    public abstract virtual bool GetMatchingValue(MessageBuffer messageBuffer, TFilterData& value);
    public abstract virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public abstract virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<TFilterData> results);
    public abstract virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public abstract virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public abstract virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public abstract virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
}
internal class System.ServiceModel.Dispatcher.ImmutableClientRuntime : object {
    internal int MessageInspectorCorrelationOffset { get; }
    internal int ParameterInspectorCorrelationOffset { get; }
    internal int CorrelationCount { get; }
    internal IClientOperationSelector OperationSelector { get; }
    internal ProxyOperationRuntime UnhandledProxyOperation { get; }
    internal bool UseSynchronizationContext { get; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal ImmutableClientRuntime(ClientRuntime behavior);
    internal int get_MessageInspectorCorrelationOffset();
    internal int get_ParameterInspectorCorrelationOffset();
    internal int get_CorrelationCount();
    internal IClientOperationSelector get_OperationSelector();
    internal ProxyOperationRuntime get_UnhandledProxyOperation();
    internal bool get_UseSynchronizationContext();
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void AfterReceiveReply(ProxyRpc& rpc);
    internal void BeforeSendRequest(ProxyRpc& rpc);
    internal void DisplayInitializationUI(ServiceChannel channel);
    internal IAsyncResult BeginDisplayInitializationUI(ServiceChannel channel, AsyncCallback callback, object state);
    internal void EndDisplayInitializationUI(IAsyncResult result);
    internal void InitializeChannel(IClientChannel channel);
    internal ProxyOperationRuntime GetOperation(MethodBase methodBase, Object[] args, Boolean& canCacheResult);
    internal ProxyOperationRuntime GetOperationByName(string operationName);
}
internal class System.ServiceModel.Dispatcher.ImmutableCommunicationTimeouts : object {
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    internal ImmutableCommunicationTimeouts(IDefaultCommunicationTimeouts timeouts);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
}
internal class System.ServiceModel.Dispatcher.ImmutableDispatchRuntime : object {
    internal int CallContextCorrelationOffset { get; }
    internal int CorrelationCount { get; }
    internal bool EnableFaults { get; }
    internal InstanceBehavior InstanceBehavior { get; }
    internal bool IsImpersonationEnabledOnSerializingReply { get; }
    internal bool RequireClaimsPrincipalOnOperationContext { get; }
    internal bool ManualAddressing { get; }
    internal int MessageInspectorCorrelationOffset { get; }
    internal int ParameterInspectorCorrelationOffset { get; }
    internal IRequestReplyCorrelator RequestReplyCorrelator { get; }
    internal SecurityImpersonationBehavior SecurityImpersonation { get; }
    internal bool ValidateMustUnderstand { get; }
    internal ErrorBehavior ErrorBehavior { get; }
    internal ImmutableDispatchRuntime(DispatchRuntime dispatch);
    private static ImmutableDispatchRuntime();
    internal int get_CallContextCorrelationOffset();
    internal int get_CorrelationCount();
    internal bool get_EnableFaults();
    internal InstanceBehavior get_InstanceBehavior();
    internal bool get_IsImpersonationEnabledOnSerializingReply();
    internal bool get_RequireClaimsPrincipalOnOperationContext();
    internal bool get_ManualAddressing();
    internal int get_MessageInspectorCorrelationOffset();
    internal int get_ParameterInspectorCorrelationOffset();
    internal IRequestReplyCorrelator get_RequestReplyCorrelator();
    internal SecurityImpersonationBehavior get_SecurityImpersonation();
    internal bool get_ValidateMustUnderstand();
    internal ErrorBehavior get_ErrorBehavior();
    internal void AfterReceiveRequest(MessageRpc& rpc);
    internal void AfterReceiveRequestCore(MessageRpc& rpc);
    internal void BeforeSendReplyCore(MessageRpc& rpc, Exception& exception, Boolean& thereIsAnUnhandledException);
    internal bool Dispatch(MessageRpc& rpc, bool isOperationContextSet);
    internal void InputSessionDoneReceiving(ServiceChannel channel);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal void InputSessionFaulted(ServiceChannel channel);
    internal static void GotDynamicInstanceContext(object state);
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal void ProcessMessage1(MessageRpc& rpc);
    internal void ProcessMessage11(MessageRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.InitialSelectOpcode : SelectOpcode {
    internal InitialSelectOpcode(NodeSelectCriteria criteria);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal interface System.ServiceModel.Dispatcher.INodeCounter {
    public int CounterMarker { get; public set; }
    unknown int MaxCounter {public set; }
    public abstract virtual int get_CounterMarker();
    public abstract virtual void set_CounterMarker(int value);
    public abstract virtual void set_MaxCounter(int value);
    public abstract virtual int ElapsedCount(int marker);
    public abstract virtual void Increase();
    public abstract virtual void IncreaseBy(int count);
}
internal class System.ServiceModel.Dispatcher.InputChannelBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal InputChannelBinder(IInputChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InstanceBehavior : object {
    internal bool TransactionAutoCompleteOnSessionClose { get; }
    internal bool ReleaseServiceInstanceOnTransactionComplete { get; }
    internal IInstanceContextProvider InstanceContextProvider { get; }
    internal InstanceBehavior(DispatchRuntime dispatch, ImmutableDispatchRuntime immutableRuntime);
    internal bool get_TransactionAutoCompleteOnSessionClose();
    internal bool get_ReleaseServiceInstanceOnTransactionComplete();
    internal IInstanceContextProvider get_InstanceContextProvider();
    internal void AfterReply(MessageRpc& rpc, ErrorBehavior error);
    internal bool CanUnload(InstanceContext instanceContext);
    internal void EnsureInstanceContext(MessageRpc& rpc);
    internal object GetInstance(InstanceContext instanceContext);
    internal object GetInstance(InstanceContext instanceContext, Message request);
    internal void Initialize(InstanceContext instanceContext);
    internal void EnsureServiceInstance(MessageRpc& rpc);
    internal void ReleaseInstance(InstanceContext instanceContext, object instance);
}
public class System.ServiceModel.Dispatcher.InstanceContextIdleCallback : MulticastDelegate {
    public InstanceContextIdleCallback(object object, IntPtr method);
    public virtual void Invoke(InstanceContext instanceContext);
    public virtual IAsyncResult BeginInvoke(InstanceContext instanceContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InstanceContextManager : LifetimeManager {
    public InstanceContextManager(object mutex);
    public sealed virtual void Add(InstanceContext instanceContext);
    public sealed virtual IAsyncResult BeginCloseInput(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void CloseInput(TimeSpan timeout);
    public sealed virtual void EndCloseInput(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    public sealed virtual bool Remove(InstanceContext instanceContext);
    public sealed virtual InstanceContext[] ToArray();
}
internal abstract class System.ServiceModel.Dispatcher.InstanceContextProviderBase : object {
    public DispatchRuntime DispatchRuntime { get; }
    internal InstanceContextProviderBase(DispatchRuntime dispatchRuntime);
    public DispatchRuntime get_DispatchRuntime();
    internal static bool IsProviderSingleton(IInstanceContextProvider provider);
    internal static bool IsProviderSessionful(IInstanceContextProvider provider);
    internal static IInstanceContextProvider GetProviderForMode(InstanceContextMode instanceMode, DispatchRuntime runtime);
    internal static bool IsProviderPerCall(IInstanceContextProvider provider);
    internal ServiceChannel GetServiceChannelFromProxy(IContextChannel channel);
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    public virtual void InitializeInstanceContext(InstanceContext instanceContext, Message message, IContextChannel channel);
    public virtual bool IsIdle(InstanceContext instanceContext);
    public virtual void NotifyIdle(InstanceContextIdleCallback callback, InstanceContext instanceContext);
}
internal class System.ServiceModel.Dispatcher.InstanceProvider : object {
    internal InstanceProvider(CreateInstanceDelegate creator);
    public sealed virtual object GetInstance(InstanceContext instanceContext);
    public sealed virtual object GetInstance(InstanceContext instanceContext, Message message);
    public sealed virtual void ReleaseInstance(InstanceContext instanceContext, object instance);
}
internal class System.ServiceModel.Dispatcher.InternalSubExprOpcode : SubExprOpcode {
    internal InternalSubExprOpcode(SubExpr expr);
    internal virtual Opcode Eval(ProcessingContext context);
    internal virtual Opcode EvalSpecial(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.Interval : object {
    internal QueryBranch Branch { get; internal set; }
    internal double LowerBound { get; }
    internal IntervalOp LowerOp { get; }
    internal double UpperBound { get; }
    internal IntervalOp UpperOp { get; }
    internal Interval(double literal, RelationOperator op);
    internal QueryBranch get_Branch();
    internal void set_Branch(QueryBranch value);
    internal double get_LowerBound();
    internal IntervalOp get_LowerOp();
    internal double get_UpperBound();
    internal IntervalOp get_UpperOp();
    internal bool Equals(double lowerBound, IntervalOp lowerOp, double upperBound, IntervalOp upperOp);
    internal bool HasMatchingEndPoint(double endpoint);
}
internal class System.ServiceModel.Dispatcher.IntervalBoundary : object {
    internal IntervalCollection EqSlot { get; }
    internal IntervalCollection GtSlot { get; }
    internal IntervalBoundary Left { get; internal set; }
    internal IntervalCollection LtSlot { get; }
    internal IntervalBoundary Parent { get; internal set; }
    internal IntervalBoundary Right { get; internal set; }
    internal double Value { get; internal set; }
    internal IntervalBoundary(double val, IntervalBoundary parent);
    internal IntervalCollection get_EqSlot();
    internal IntervalCollection get_GtSlot();
    internal IntervalBoundary get_Left();
    internal void set_Left(IntervalBoundary value);
    internal IntervalCollection get_LtSlot();
    internal IntervalBoundary get_Parent();
    internal void set_Parent(IntervalBoundary value);
    internal IntervalBoundary get_Right();
    internal void set_Right(IntervalBoundary value);
    internal double get_Value();
    internal void set_Value(double value);
    internal void AddToEqSlot(Interval interval);
    internal void AddToGtSlot(Interval interval);
    internal void AddToLtSlot(Interval interval);
    internal IntervalBoundary EnsureLeft(double val);
    internal IntervalBoundary EnsureRight(double val);
    internal void RemoveFromEqSlot(Interval interval);
    internal void RemoveFromGtSlot(Interval interval);
    internal void RemoveFromLtSlot(Interval interval);
    internal void Trim();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.IntervalBranchIndex : QueryBranchIndex {
    internal int Count { get; }
    internal QueryBranch Item { get; internal set; }
    internal virtual int get_Count();
    internal virtual QueryBranch get_Item(object key);
    internal virtual void set_Item(object key, QueryBranch value);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual void Match(int valIndex, Value& val, QueryBranchResultSet results);
    internal virtual void Remove(object key);
    internal virtual void Trim();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.IntervalCollection : ArrayList {
    internal bool HasIntervals { get; }
    internal Interval Item { get; }
    internal bool get_HasIntervals();
    internal Interval get_Item(int index);
    internal int Add(Interval interval);
    internal int AddUnique(Interval interval);
    internal IntervalCollection GetIntervalsWithEndPoint(double endPoint);
    internal int IndexOf(Interval interval);
    internal int IndexOf(double endPoint);
    internal int IndexOf(double lowerBound, IntervalOp lowerOp, double upperBound, IntervalOp upperOp);
    internal void Remove(Interval interval);
    internal void Trim();
}
internal enum System.ServiceModel.Dispatcher.IntervalOp : Enum {
    public byte value__;
    public static IntervalOp LessThan;
    public static IntervalOp LessThanEquals;
}
internal class System.ServiceModel.Dispatcher.IntervalTree : object {
    internal int Count { get; }
    internal IntervalCollection Intervals { get; }
    internal IntervalBoundary Root { get; }
    internal int get_Count();
    internal IntervalCollection get_Intervals();
    internal IntervalBoundary get_Root();
    internal void Add(Interval interval);
    internal IntervalBoundary FindBoundaryNode(double val);
    internal IntervalBoundary FindBoundaryNode(IntervalBoundary root, double val);
    internal Interval FindInterval(Interval interval);
    internal Interval FindInterval(double lowerBound, IntervalOp lowerOp, double upperBound, IntervalOp upperOp);
    internal void Remove(Interval interval);
    internal void Trim();
}
internal class System.ServiceModel.Dispatcher.IntervalTreeTraverser : ValueType {
    private IntervalBoundary currentNode;
    private IntervalBoundary nextNode;
    private IntervalCollection slot;
    private double val;
    internal IntervalCollection Slot { get; }
    internal IntervalTreeTraverser(double val, IntervalBoundary root);
    internal IntervalCollection get_Slot();
    internal bool MoveNext();
}
public abstract class System.ServiceModel.Dispatcher.InvalidBodyAccessException : SystemException {
    protected InvalidBodyAccessException(SerializationInfo info, StreamingContext context);
    protected InvalidBodyAccessException(string message);
    protected InvalidBodyAccessException(string message, Exception innerException);
}
internal class System.ServiceModel.Dispatcher.InverseQueryMatcher : QueryMatcher {
    internal InverseQueryMatcher(bool match);
    internal void Add(string expression, XmlNamespaceManager names, object item, bool forceExternal);
    internal void Clear();
    internal void Remove(object item);
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.InvokeBeginDelegate : MulticastDelegate {
    public InvokeBeginDelegate(object object, IntPtr method);
    public virtual IAsyncResult Invoke(object target, Object[] inputs, AsyncCallback asyncCallback, object state);
    public virtual IAsyncResult BeginInvoke(object target, Object[] inputs, AsyncCallback asyncCallback, object state, AsyncCallback callback, object object);
    public virtual IAsyncResult EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InvokeDelegate : MulticastDelegate {
    public InvokeDelegate(object object, IntPtr method);
    public virtual object Invoke(object target, Object[] inputs, Object[] outputs);
    public virtual IAsyncResult BeginInvoke(object target, Object[] inputs, Object[] outputs, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InvokeEndDelegate : MulticastDelegate {
    public InvokeEndDelegate(object object, IntPtr method);
    public virtual object Invoke(object target, Object[] outputs, IAsyncResult result);
    public virtual IAsyncResult BeginInvoke(object target, Object[] outputs, IAsyncResult result, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InvokerUtil : object {
    [SecuritySafeCriticalAttribute]
internal CreateInstanceDelegate GenerateCreateInstanceDelegate(Type type, ConstructorInfo constructor);
    [SecuritySafeCriticalAttribute]
internal InvokeDelegate GenerateInvokeDelegate(MethodInfo method, Int32& inputParameterCount, Int32& outputParameterCount);
    [SecuritySafeCriticalAttribute]
internal InvokeBeginDelegate GenerateInvokeBeginDelegate(MethodInfo method, Int32& inputParameterCount);
    [SecuritySafeCriticalAttribute]
internal InvokeEndDelegate GenerateInvokeEndDelegate(MethodInfo method, Int32& outputParameterCount);
}
public interface System.ServiceModel.Dispatcher.IOperationInvoker {
    public bool IsSynchronous { get; }
    public abstract virtual bool get_IsSynchronous();
    public abstract virtual Object[] AllocateInputs();
    public abstract virtual object Invoke(object instance, Object[] inputs, Object[]& outputs);
    public abstract virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public abstract virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
}
public interface System.ServiceModel.Dispatcher.IParameterInspector {
    public abstract virtual object BeforeCall(string operationName, Object[] inputs);
    public abstract virtual void AfterCall(string operationName, Object[] outputs, object returnValue, object correlationState);
}
internal interface System.ServiceModel.Dispatcher.IResumeMessageRpc {
    public abstract virtual InstanceContext GetMessageInstanceContext();
    public abstract virtual void Resume();
    public abstract virtual void Resume(Boolean& alreadyResumedNoLock);
    public abstract virtual void Resume(IAsyncResult result);
    public abstract virtual void Resume(object instance);
    public abstract virtual void SignalConditionalResume(IAsyncResult result);
}
internal interface System.ServiceModel.Dispatcher.ISessionThrottleNotification {
    public abstract virtual void ThrottleAcquired();
}
internal class System.ServiceModel.Dispatcher.JumpIfOpcode : JumpOpcode {
    protected bool test;
    internal bool Test { get; }
    internal JumpIfOpcode(Opcode jump, bool test);
    protected JumpIfOpcode(OpcodeID id, Opcode jump, bool test);
    internal bool get_Test();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal abstract class System.ServiceModel.Dispatcher.JumpOpcode : Opcode {
    internal Opcode Jump { get; internal set; }
    internal JumpOpcode(OpcodeID id, Opcode jump);
    internal Opcode get_Jump();
    internal void set_Jump(Opcode value);
    internal void AddJump(BlockEndOpcode jumpTo);
    internal virtual void Remove();
    internal void RemoveJump(BlockEndOpcode jumpTo);
    internal virtual void Trim();
}
internal static class System.ServiceModel.Dispatcher.ListenerBinder : object {
    internal static IListenerBinder GetBinder(IChannelListener listener, MessageVersion messageVersion);
}
internal class System.ServiceModel.Dispatcher.ListenerChannel : object {
    public IChannelBinder Binder { get; }
    public ServiceThrottle Throttle { get; public set; }
    public ListenerChannel(IChannelBinder binder);
    public IChannelBinder get_Binder();
    public ServiceThrottle get_Throttle();
    public void set_Throttle(ServiceThrottle value);
}
internal class System.ServiceModel.Dispatcher.ListenerHandler : CommunicationObject {
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal ListenerChannel Channel { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable Endpoints { get; internal set; }
    internal ServiceHostBase Host { get; }
    internal object ThisLock { get; }
    internal ListenerHandler(IListenerBinder listenerBinder, ChannelDispatcher channelDispatcher, ServiceHostBase host, ServiceThrottle throttle, IDefaultCommunicationTimeouts timeouts);
    private static ListenerHandler();
    internal ChannelDispatcher get_ChannelDispatcher();
    internal ListenerChannel get_Channel();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal EndpointDispatcherTable get_Endpoints();
    internal void set_Endpoints(EndpointDispatcherTable value);
    internal ServiceHostBase get_Host();
    internal object get_ThisLock();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
    internal void NewChannelPump();
    public sealed virtual void ThrottleAcquired();
    public void CloseInput(TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.LiteralOrdinalOpcode : Opcode {
    internal LiteralOrdinalOpcode(int ordinal);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal abstract class System.ServiceModel.Dispatcher.LiteralRelationOpcode : Opcode {
    internal object Literal { get; }
    internal LiteralRelationOpcode(OpcodeID id);
    internal abstract virtual object get_Literal();
}
[DataContractAttribute]
public class System.ServiceModel.Dispatcher.MatchAllMessageFilter : MessageFilter {
    public virtual bool Match(MessageBuffer messageBuffer);
    public virtual bool Match(Message message);
}
internal class System.ServiceModel.Dispatcher.MatchMultipleResultOpcode : MultipleResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
[DataContractAttribute]
public class System.ServiceModel.Dispatcher.MatchNoneMessageFilter : MessageFilter {
    public virtual bool Match(MessageBuffer messageBuffer);
    public virtual bool Match(Message message);
}
internal class System.ServiceModel.Dispatcher.MatchResultOpcode : ResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
    protected bool IsSuccess(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.MatchSingleFxEngineResultOpcode : SingleFxEngineResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
    internal bool Match(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.MathOpcode : Opcode {
    internal MathOpcode(OpcodeID id, MathOperator op);
    internal virtual bool Equals(Opcode op);
}
internal enum System.ServiceModel.Dispatcher.MathOperator : Enum {
    public int value__;
    public static MathOperator None;
    public static MathOperator Plus;
    public static MathOperator Minus;
    public static MathOperator Div;
    public static MathOperator Multiply;
    public static MathOperator Mod;
    public static MathOperator Negate;
}
internal class System.ServiceModel.Dispatcher.MergeOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
[DataContractAttribute]
[KnownTypeAttribute("System.ServiceModel.Dispatcher.XPathMessageFilter")]
[KnownTypeAttribute("System.ServiceModel.Dispatcher.ActionMessageFilter")]
[KnownTypeAttribute("System.ServiceModel.Dispatcher.MatchAllMessageFilter")]
[KnownTypeAttribute("System.ServiceModel.Dispatcher.MatchNoneMessageFilter")]
public abstract class System.ServiceModel.Dispatcher.MessageFilter : object {
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public abstract virtual bool Match(MessageBuffer buffer);
    public abstract virtual bool Match(Message message);
}
public class System.ServiceModel.Dispatcher.MessageFilterException : CommunicationException {
    public Collection`1<MessageFilter> Filters { get; }
    protected MessageFilterException(SerializationInfo info, StreamingContext context);
    public MessageFilterException(string message);
    public MessageFilterException(string message, Exception innerException);
    public MessageFilterException(string message, Collection`1<MessageFilter> filters);
    public MessageFilterException(string message, Exception innerException, Collection`1<MessageFilter> filters);
    public Collection`1<MessageFilter> get_Filters();
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class System.ServiceModel.Dispatcher.MessageFilterTable`1 : object {
    public TFilterData Item { get; public set; }
    public int Count { get; }
    [DataMemberAttribute]
public int DefaultPriority { get; public set; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<TFilterData> Values { get; }
    public MessageFilterTable`1(int defaultPriority);
    private static MessageFilterTable`1();
    public sealed virtual TFilterData get_Item(MessageFilter filter);
    public sealed virtual void set_Item(MessageFilter filter, TFilterData value);
    public sealed virtual int get_Count();
    public int get_DefaultPriority();
    public void set_DefaultPriority(int value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<TFilterData> get_Values();
    public sealed virtual void Add(MessageFilter filter, TFilterData data);
    public void Add(MessageFilter filter, TFilterData data, int priority);
    public sealed virtual void Add(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool ContainsKey(MessageFilter filter);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    protected virtual IMessageFilterTable`1<TFilterData> CreateFilterTable(MessageFilter filter);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageFilter, TFilterData>> GetEnumerator();
    public int GetPriority(MessageFilter filter);
    public sealed virtual bool GetMatchingValue(Message message, TFilterData& data);
    internal bool GetMatchingValue(Message message, TFilterData& data, Boolean& addressMatched);
    public sealed virtual bool GetMatchingValue(MessageBuffer buffer, TFilterData& data);
    internal bool GetMatchingValue(MessageBuffer buffer, Message messageToReadHeaders, TFilterData& data);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer buffer, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer buffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer buffer, ICollection`1<MessageFilter> results);
    public sealed virtual bool Remove(MessageFilter filter);
    public sealed virtual bool Remove(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool TryGetValue(MessageFilter filter, TFilterData& data);
}
internal class System.ServiceModel.Dispatcher.MessageOperationFormatter : object {
    internal static MessageOperationFormatter Instance { get; }
    internal static MessageOperationFormatter get_Instance();
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    public bool IsFault(string operation, Exception error);
    public MessageFault SerializeFault(Exception error);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
}
public abstract class System.ServiceModel.Dispatcher.MessageQuery : object {
    public virtual MessageQueryCollection CreateMessageQueryCollection();
    public abstract virtual TResult Evaluate(Message message);
    public abstract virtual TResult Evaluate(MessageBuffer buffer);
}
public abstract class System.ServiceModel.Dispatcher.MessageQueryCollection : Collection`1<MessageQuery> {
    public abstract virtual IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(Message message);
    public abstract virtual IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(MessageBuffer buffer);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Dispatcher.MessageQueryTable`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageQuery> Keys { get; }
    public ICollection`1<TItem> Values { get; }
    public TItem Item { get; public set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageQuery> get_Keys();
    public sealed virtual ICollection`1<TItem> get_Values();
    public sealed virtual TItem get_Item(MessageQuery key);
    public sealed virtual void set_Item(MessageQuery key, TItem value);
    public sealed virtual void Add(MessageQuery key, TItem value);
    public sealed virtual void Add(KeyValuePair`2<MessageQuery, TItem> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<MessageQuery, TItem> item);
    public sealed virtual bool ContainsKey(MessageQuery key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(Message message);
    public IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(MessageBuffer buffer);
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageQuery, TItem>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(MessageQuery key);
    public sealed virtual bool Remove(KeyValuePair`2<MessageQuery, TItem> item);
    public sealed virtual bool TryGetValue(MessageQuery key, TItem& value);
}
internal class System.ServiceModel.Dispatcher.MessageRpc : ValueType {
    internal ServiceChannel Channel;
    internal ChannelHandler channelHandler;
    internal Object[] Correlation;
    internal ServiceHostBase Host;
    internal OperationContext OperationContext;
    internal ServiceModelActivity Activity;
    internal Guid ResponseActivityId;
    internal IAsyncResult AsyncResult;
    internal bool CanSendReply;
    internal bool SuccessfullySendReply;
    internal CorrelationCallbackMessageProperty CorrelationCallback;
    internal Object[] InputParameters;
    internal Object[] OutputParameters;
    internal object ReturnParameter;
    internal bool ParametersDisposed;
    internal bool DidDeserializeRequestBody;
    internal TransactionMessageProperty TransactionMessageProperty;
    internal TransactedBatchContext TransactedBatchContext;
    internal Exception Error;
    internal MessageRpcProcessor ErrorProcessor;
    internal ErrorHandlerFaultInfo FaultInfo;
    internal bool HasSecurityContext;
    internal object Instance;
    internal bool MessageRpcOwnsInstanceContextThrottle;
    internal MessageRpcProcessor NextProcessor;
    internal Collection`1<MessageHeaderInfo> NotUnderstoodHeaders;
    internal DispatchOperationRuntime Operation;
    internal Message Request;
    internal RequestContext RequestContext;
    internal bool RequestContextThrewOnReply;
    internal UniqueId RequestID;
    internal Message Reply;
    internal TimeoutHelper ReplyTimeoutHelper;
    internal ReplyToInfo ReplyToInfo;
    internal MessageVersion RequestVersion;
    internal ServiceSecurityContext SecurityContext;
    internal InstanceContext InstanceContext;
    internal bool SuccessfullyBoundInstance;
    internal bool SuccessfullyIncrementedActivity;
    internal bool SuccessfullyLockedInstance;
    internal ReceiveContextRPCFacet ReceiveContext;
    internal TransactionRpcFacet transaction;
    internal IAspNetMessageProperty HostingProperty;
    internal MessageRpcInvokeNotification InvokeNotification;
    internal EventTraceActivity EventTraceActivity;
    private bool paused;
    private bool switchedThreads;
    private bool isInstanceContextSingleton;
    private SignalGate`1<IAsyncResult> invokeContinueGate;
    internal bool FinalizeCorrelationImplicitly { get; }
    internal bool IsPaused { get; }
    internal bool SwitchedThreads { get; }
    unknown bool IsInstanceContextSingleton {internal set; }
    internal TransactionRpcFacet Transaction { get; }
    internal MessageRpc(RequestContext requestContext, Message request, DispatchOperationRuntime operation, ServiceChannel channel, ServiceHostBase host, ChannelHandler channelHandler, bool cleanThread, OperationContext operationContext, InstanceContext instanceContext, EventTraceActivity eventTraceActivity);
    private static MessageRpc();
    internal bool get_FinalizeCorrelationImplicitly();
    internal bool get_IsPaused();
    internal bool get_SwitchedThreads();
    internal void set_IsInstanceContextSingleton(bool value);
    internal TransactionRpcFacet get_Transaction();
    internal void Abort();
    internal void AbortRequestContext();
    internal void CloseRequestContext();
    internal void AbortChannel();
    internal void CloseChannel();
    internal void AbortInstanceContext();
    internal void EnsureReceive();
    internal void DisposeParameters(bool excludeInput);
    internal void DisposeParametersCore(bool excludeInput);
    internal IResumeMessageRpc Pause();
    [SecuritySafeCriticalAttribute]
internal bool Process(bool isOperationContextSet);
    internal void UnPause();
    internal bool UnlockInvokeContinueGate(IAsyncResult& result);
    internal void PrepareInvokeContinueGate();
}
internal class System.ServiceModel.Dispatcher.MessageRpcInvokeNotification : object {
    public bool DidInvokerEnsurePump { get; public set; }
    public MessageRpcInvokeNotification(ServiceModelActivity activity, ChannelHandler handler);
    [CompilerGeneratedAttribute]
public bool get_DidInvokerEnsurePump();
    [CompilerGeneratedAttribute]
public void set_DidInvokerEnsurePump(bool value);
    public sealed virtual void NotifyInvokeReceived();
    public sealed virtual void NotifyInvokeReceived(RequestContext request);
}
internal class System.ServiceModel.Dispatcher.MessageRpcProcessor : MulticastDelegate {
    public MessageRpcProcessor(object object, IntPtr method);
    public virtual void Invoke(MessageRpc& rpc);
    public virtual IAsyncResult BeginInvoke(MessageRpc& rpc, AsyncCallback callback, object object);
    public virtual void EndInvoke(MessageRpc& rpc, IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.MinusOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.ModulusOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
public class System.ServiceModel.Dispatcher.MultipleFilterMatchesException : SystemException {
    public Collection`1<MessageFilter> Filters { get; }
    protected MultipleFilterMatchesException(SerializationInfo info, StreamingContext context);
    public MultipleFilterMatchesException(string message);
    public MultipleFilterMatchesException(string message, Exception innerException);
    public MultipleFilterMatchesException(string message, Collection`1<MessageFilter> filters);
    public MultipleFilterMatchesException(string message, Exception innerException, Collection`1<MessageFilter> filters);
    public Collection`1<MessageFilter> get_Filters();
}
internal class System.ServiceModel.Dispatcher.MultipleReceiveBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public MultipleReceiveBinder(IChannelBinder channelBinder, int size, bool ordered);
    private static MultipleReceiveBinder();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal abstract class System.ServiceModel.Dispatcher.MultipleResultOpcode : ResultOpcode {
    protected QueryBuffer`1<object> results;
    internal MultipleResultOpcode(OpcodeID id);
    internal virtual void Add(Opcode op);
    public void AddItem(object item);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual bool Equals(Opcode op);
    public void RemoveItem(object item);
    internal virtual void Remove();
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.MultiplyOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
public class System.ServiceModel.Dispatcher.NavigatorInvalidBodyAccessException : InvalidBodyAccessException {
    protected NavigatorInvalidBodyAccessException(SerializationInfo info, StreamingContext context);
    public NavigatorInvalidBodyAccessException(string message);
    public NavigatorInvalidBodyAccessException(string message, Exception innerException);
    internal FilterInvalidBodyAccessException Process(Opcode op);
}
internal class System.ServiceModel.Dispatcher.NegateOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.NetDispatcherFaultException : FaultException {
    public NetDispatcherFaultException(string reason, FaultCode code, Exception innerException);
    public NetDispatcherFaultException(FaultReason reason, FaultCode code, Exception innerException);
}
internal class System.ServiceModel.Dispatcher.NodeQName : ValueType {
    internal static NodeQName Empty;
    internal string name;
    internal string ns;
    internal bool IsEmpty { get; }
    internal bool IsNameDefined { get; }
    internal bool IsNameWildcard { get; }
    internal bool IsNamespaceDefined { get; }
    internal bool IsNamespaceWildcard { get; }
    internal string Name { get; }
    internal string Namespace { get; }
    internal NodeQName(string name);
    internal NodeQName(string name, string ns);
    private static NodeQName();
    internal bool get_IsEmpty();
    internal bool get_IsNameDefined();
    internal bool get_IsNameWildcard();
    internal bool get_IsNamespaceDefined();
    internal bool get_IsNamespaceWildcard();
    internal string get_Name();
    internal string get_Namespace();
    internal bool EqualsName(string name);
    internal bool Equals(NodeQName qname);
    internal bool EqualsNamespace(string ns);
    internal NodeQNameType GetQNameType();
}
internal enum System.ServiceModel.Dispatcher.NodeQNameType : Enum {
    public byte value__;
    public static NodeQNameType Empty;
    public static NodeQNameType Name;
    public static NodeQNameType Namespace;
    public static NodeQNameType Standard;
    public static NodeQNameType NameWildcard;
    public static NodeQNameType NamespaceWildcard;
    public static NodeQNameType Wildcard;
}
internal class System.ServiceModel.Dispatcher.NodeSelectCriteria : object {
    protected QueryAxis axis;
    protected NodeQName qname;
    protected NodeQNameType qnameType;
    protected QueryNodeType type;
    internal QueryAxis Axis { get; }
    internal bool IsCompressable { get; }
    internal NodeQName QName { get; }
    internal QueryNodeType Type { get; }
    internal NodeSelectCriteria(QueryAxisType axis, NodeQName qname, QueryNodeType nodeType);
    internal QueryAxis get_Axis();
    internal bool get_IsCompressable();
    internal NodeQName get_QName();
    internal QueryNodeType get_Type();
    public bool Equals(NodeSelectCriteria criteria);
    internal bool MatchType(SeekableXPathNavigator node);
    internal bool MatchQName(SeekableXPathNavigator node);
    internal void Select(SeekableXPathNavigator contextNode, NodeSequence destSequence);
    internal Opcode Select(SeekableXPathNavigator contextNode, NodeSequence destSequence, SelectOpcode next);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.NodeSequence : object {
    internal static NodeSequence Empty;
    internal int refCount;
    internal int Count { get; }
    internal NodeSequenceItem Item { get; }
    internal NodeSequenceItem[] Items { get; }
    internal bool IsNotEmpty { get; }
    internal string LocalName { get; }
    internal string Name { get; }
    internal string Namespace { get; }
    internal NodeSequence Next { get; internal set; }
    internal ProcessingContext OwnerContext { get; internal set; }
    internal NodeSequence(int capacity);
    internal NodeSequence(int capacity, ProcessingContext ownerContext);
    private static NodeSequence();
    internal int get_Count();
    internal NodeSequenceItem get_Item(int index);
    internal NodeSequenceItem[] get_Items();
    internal bool get_IsNotEmpty();
    internal string get_LocalName();
    internal string get_Name();
    internal string get_Namespace();
    internal NodeSequence get_Next();
    internal void set_Next(NodeSequence value);
    internal ProcessingContext get_OwnerContext();
    internal void set_OwnerContext(ProcessingContext value);
    internal void Add(XPathNodeIterator iter);
    internal void Add(SeekableXPathNavigator node);
    internal void Add(QueryNode node);
    internal void Add(NodeSequenceItem& item);
    internal void AddCopy(NodeSequenceItem& item, int size);
    internal void AddCopy(NodeSequenceItem& item);
    internal bool CanReuse(ProcessingContext context);
    internal void Clear();
    internal void Reset(NodeSequence nextSeq);
    internal bool Compare(double val, RelationOperator op);
    internal bool Compare(string val, RelationOperator op);
    internal bool Compare(NodeSequenceItem& item, RelationOperator op);
    internal bool Compare(NodeSequence sequence, RelationOperator op);
    internal bool Equals(string val);
    internal bool Equals(double val);
    internal static int GetContextSize(NodeSequence sequence, int itemIndex);
    internal void Merge();
    internal void Merge(bool renumber);
    internal void StartNodeset();
    internal void StopNodeset();
    internal string StringValue();
    internal NodeSequence Union(ProcessingContext context, NodeSequence otherSeq);
}
internal class System.ServiceModel.Dispatcher.NodeSequenceBuilder : ValueType {
    private ProcessingContext context;
    private NodeSequence sequence;
    internal NodeSequence Sequence { get; internal set; }
    internal NodeSequenceBuilder(ProcessingContext context, NodeSequence sequence);
    internal NodeSequenceBuilder(ProcessingContext context);
    internal NodeSequence get_Sequence();
    internal void set_Sequence(NodeSequence value);
    internal void Add(NodeSequenceItem& item);
    internal void EndNodeset();
    internal void StartNodeset();
}
internal class System.ServiceModel.Dispatcher.NodeSequenceEnumerator : object {
    public object Current { get; }
    internal NodeSequenceEnumerator(NodeSequenceIterator iter);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.ServiceModel.Dispatcher.NodeSequenceItem : ValueType {
    private NodeSequenceItemFlags flags;
    private QueryNode node;
    private int position;
    private int size;
    internal NodeSequenceItemFlags Flags { get; internal set; }
    internal bool Last { get; internal set; }
    internal string LocalName { get; }
    internal string Name { get; }
    internal string Namespace { get; }
    internal QueryNode Node { get; }
    internal int Position { get; }
    internal int Size { get; internal set; }
    internal NodeSequenceItemFlags get_Flags();
    internal void set_Flags(NodeSequenceItemFlags value);
    internal bool get_Last();
    internal void set_Last(bool value);
    internal string get_LocalName();
    internal string get_Name();
    internal string get_Namespace();
    internal QueryNode get_Node();
    internal int get_Position();
    internal int get_Size();
    internal void set_Size(int value);
    internal bool Compare(double dblVal, RelationOperator op);
    internal bool Compare(string strVal, RelationOperator op);
    internal bool Compare(NodeSequenceItem& item, RelationOperator op);
    internal bool Equals(string literal);
    internal bool Equals(double literal);
    internal SeekableXPathNavigator GetNavigator();
    internal long GetNavigatorPosition();
    internal double NumberValue();
    internal void Set(SeekableXPathNavigator node, int position, int size);
    internal void Set(QueryNode node, int position, int size);
    internal void Set(NodeSequenceItem& item, int position, int size);
    internal void SetPositionAndSize(int position, int size);
    internal void SetSizeAndLast();
    internal string StringValue();
}
internal enum System.ServiceModel.Dispatcher.NodeSequenceItemFlags : Enum {
    public byte value__;
    public static NodeSequenceItemFlags None;
    public static NodeSequenceItemFlags NodesetLast;
}
internal class System.ServiceModel.Dispatcher.NodeSequenceIterator : XPathNodeIterator {
    public int Count { get; }
    public XPathNavigator Current { get; }
    public int CurrentPosition { get; }
    internal NodeSequenceIterator(NodeSequence seq);
    internal NodeSequenceIterator(NodeSequenceIterator iter);
    public virtual int get_Count();
    public virtual XPathNavigator get_Current();
    public virtual int get_CurrentPosition();
    internal void Clear();
    public virtual XPathNodeIterator Clone();
    public virtual IEnumerator GetEnumerator();
    public virtual bool MoveNext();
    public void Reset();
}
internal class System.ServiceModel.Dispatcher.NodesetIterator : ValueType {
    private int index;
    private int indexStart;
    private NodeSequence sequence;
    private NodeSequenceItem[] items;
    internal int Index { get; }
    internal NodesetIterator(NodeSequence sequence);
    internal int get_Index();
    internal bool NextItem();
    internal bool NextNodeset();
}
internal class System.ServiceModel.Dispatcher.NoOpOpcode : Opcode {
    internal NoOpOpcode(OpcodeID id);
}
internal class System.ServiceModel.Dispatcher.NumberBranchIndex : HashBranchIndex {
    internal virtual void Match(int valIndex, Value& val, QueryBranchResultSet results);
}
internal class System.ServiceModel.Dispatcher.NumberEqualsBranchOpcode : QueryConditionalBranchOpcode {
    internal virtual LiteralRelationOpcode ValidateOpcode(Opcode opcode);
}
internal class System.ServiceModel.Dispatcher.NumberEqualsOpcode : LiteralRelationOpcode {
    internal object Literal { get; }
    internal NumberEqualsOpcode(double literal);
    internal virtual object get_Literal();
    internal virtual void Add(Opcode op);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.NumberIntervalBranchOpcode : QueryConditionalBranchOpcode {
    internal virtual LiteralRelationOpcode ValidateOpcode(Opcode opcode);
}
internal class System.ServiceModel.Dispatcher.NumberIntervalOpcode : NumberRelationOpcode {
    internal object Literal { get; }
    internal NumberIntervalOpcode(double literal, RelationOperator op);
    internal virtual object get_Literal();
    internal virtual void Add(Opcode op);
}
internal class System.ServiceModel.Dispatcher.NumberRelationOpcode : LiteralRelationOpcode {
    internal object Literal { get; }
    internal NumberRelationOpcode(double literal, RelationOperator op);
    protected NumberRelationOpcode(OpcodeID id, double literal, RelationOperator op);
    internal virtual object get_Literal();
    internal virtual bool Equals(Opcode opcode);
    internal virtual Opcode Eval(ProcessingContext context);
    internal Interval ToInterval();
}
internal abstract class System.ServiceModel.Dispatcher.Opcode : object {
    protected OpcodeFlags flags;
    protected Opcode next;
    protected Opcode prev;
    internal OpcodeFlags Flags { get; internal set; }
    internal OpcodeID ID { get; }
    internal Opcode Next { get; internal set; }
    internal Opcode Prev { get; internal set; }
    internal Opcode(OpcodeID id);
    internal OpcodeFlags get_Flags();
    internal void set_Flags(OpcodeFlags value);
    internal OpcodeID get_ID();
    internal Opcode get_Next();
    internal void set_Next(Opcode value);
    internal Opcode get_Prev();
    internal void set_Prev(Opcode value);
    internal virtual void Add(Opcode op);
    internal virtual void AddBranch(Opcode opcode);
    internal void Attach(Opcode op);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual bool IsEquivalentForAdd(Opcode opcode);
    internal bool IsMultipleResult();
    internal virtual void DelinkFromConditional(Opcode child);
    internal Opcode DetachChild();
    internal void DetachFromParent();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
    internal virtual Opcode Eval(NodeSequence sequence, SeekableXPathNavigator node);
    internal virtual Opcode EvalSpecial(ProcessingContext context);
    internal virtual bool IsInConditional();
    internal bool IsReachableFromConditional();
    internal virtual Opcode Locate(Opcode opcode);
    internal virtual void LinkToConditional(Opcode child);
    internal virtual void Remove();
    internal virtual void RemoveChild(Opcode opcode);
    internal virtual void Replace(Opcode replace, Opcode with);
    internal bool TestFlag(OpcodeFlags flag);
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.OpcodeBlock : ValueType {
    private Opcode first;
    private Opcode last;
    internal Opcode First { get; }
    internal Opcode Last { get; }
    internal OpcodeBlock(Opcode first);
    internal Opcode get_First();
    internal Opcode get_Last();
    internal void Append(Opcode opcode);
    internal void Append(OpcodeBlock block);
    internal void DetachLast();
}
internal enum System.ServiceModel.Dispatcher.OpcodeFlags : Enum {
    public int value__;
    public static OpcodeFlags None;
    public static OpcodeFlags Single;
    public static OpcodeFlags Multiple;
    public static OpcodeFlags Branch;
    public static OpcodeFlags Result;
    public static OpcodeFlags Jump;
    public static OpcodeFlags Literal;
    public static OpcodeFlags Select;
    public static OpcodeFlags Deleted;
    public static OpcodeFlags InConditional;
    public static OpcodeFlags NoContextCopy;
    public static OpcodeFlags InitialSelect;
    public static OpcodeFlags CompressableSelect;
    public static OpcodeFlags Fx;
}
internal enum System.ServiceModel.Dispatcher.OpcodeID : Enum {
    public int value__;
    public static OpcodeID NoOp;
    public static OpcodeID SubExpr;
    public static OpcodeID Branch;
    public static OpcodeID JumpIfNot;
    public static OpcodeID Filter;
    public static OpcodeID Function;
    public static OpcodeID XsltFunction;
    public static OpcodeID XsltInternalFunction;
    public static OpcodeID Cast;
    public static OpcodeID QueryTree;
    public static OpcodeID BlockEnd;
    public static OpcodeID SubRoutine;
    public static OpcodeID Ordinal;
    public static OpcodeID LiteralOrdinal;
    public static OpcodeID Empty;
    public static OpcodeID Union;
    public static OpcodeID Merge;
    public static OpcodeID ApplyBoolean;
    public static OpcodeID StartBoolean;
    public static OpcodeID EndBoolean;
    public static OpcodeID Relation;
    public static OpcodeID StringEquals;
    public static OpcodeID NumberEquals;
    public static OpcodeID StringEqualsBranch;
    public static OpcodeID NumberEqualsBranch;
    public static OpcodeID NumberRelation;
    public static OpcodeID NumberInterval;
    public static OpcodeID NumberIntervalBranch;
    public static OpcodeID Select;
    public static OpcodeID InitialSelect;
    public static OpcodeID SelectRoot;
    public static OpcodeID PushXsltVariable;
    public static OpcodeID PushBool;
    public static OpcodeID PushString;
    public static OpcodeID PushDouble;
    public static OpcodeID PushContextNode;
    public static OpcodeID PushNodeSequence;
    public static OpcodeID PushPosition;
    public static OpcodeID PopSequenceToValueStack;
    public static OpcodeID PopSequenceToSequenceStack;
    public static OpcodeID PopContextNodes;
    public static OpcodeID PushContextCopy;
    public static OpcodeID PopValueFrame;
    public static OpcodeID Plus;
    public static OpcodeID Minus;
    public static OpcodeID Multiply;
    public static OpcodeID Divide;
    public static OpcodeID Mod;
    public static OpcodeID Negate;
    public static OpcodeID StringPrefix;
    public static OpcodeID StringPrefixBranch;
    public static OpcodeID MatchAlways;
    public static OpcodeID MatchResult;
    public static OpcodeID MatchFilterResult;
    public static OpcodeID MatchMultipleResult;
    public static OpcodeID MatchSingleFx;
    public static OpcodeID QuerySingleFx;
    public static OpcodeID QueryResult;
    public static OpcodeID QueryMultipleResult;
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.OpcodeList : object {
    public int Count { get; }
    public Opcode Item { get; public set; }
    public OpcodeList(int capacity);
    public int get_Count();
    public Opcode get_Item(int index);
    public void set_Item(int index, Opcode value);
    public void Add(Opcode opcode);
    public int IndexOf(Opcode opcode);
    public void Remove(Opcode opcode);
    public void Trim();
}
internal abstract class System.ServiceModel.Dispatcher.OperationFormatter : object {
    protected StreamFormatter requestStreamFormatter;
    protected StreamFormatter replyStreamFormatter;
    internal string RequestAction { get; }
    internal string ReplyAction { get; }
    protected XmlDictionary Dictionary { get; }
    protected string OperationName { get; }
    protected MessageDescription ReplyDescription { get; }
    protected MessageDescription RequestDescription { get; }
    public OperationFormatter(OperationDescription description, bool isRpc, bool isEncoded);
    private static OperationFormatter();
    protected abstract virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected abstract virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal string get_RequestAction();
    internal string get_ReplyAction();
    protected XmlDictionary get_Dictionary();
    protected string get_OperationName();
    protected MessageDescription get_ReplyDescription();
    protected MessageDescription get_RequestDescription();
    protected XmlDictionaryString AddToDictionary(string s);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    internal static object GetContentOfMessageHeaderOfT(MessageHeaderDescription headerDescription, object parameterValue, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static bool IsValidReturnValue(MessagePartDescription returnValue);
    internal static XmlDictionaryString AddToDictionary(XmlDictionary dictionary, string s);
    internal static void Validate(OperationDescription operation, bool isRpc, bool isEncoded);
    internal static void GetActions(OperationDescription description, XmlDictionary dictionary, XmlDictionaryString& action, XmlDictionaryString& replyAction);
    internal static NetDispatcherFaultException CreateDeserializationFailedFault(string reason, Exception innerException);
    internal static void TraceAndSkipElement(XmlReader xmlReader);
}
internal class System.ServiceModel.Dispatcher.OperationInvokerBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
internal class System.ServiceModel.Dispatcher.OperationSelectorBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
internal class System.ServiceModel.Dispatcher.OrdinalOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.OutputChannelBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal OutputChannelBinder(IOutputChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.PartialTrustValidationBehavior : object {
    internal static PartialTrustValidationBehavior Instance { get; }
    private static PartialTrustValidationBehavior();
    internal static PartialTrustValidationBehavior get_Instance();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    public sealed virtual void Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    public sealed virtual void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    public sealed virtual void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
internal class System.ServiceModel.Dispatcher.PeerValidationBehavior : object {
    public static PeerValidationBehavior Instance { get; }
    public static PeerValidationBehavior get_Instance();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal class System.ServiceModel.Dispatcher.PerCallInstanceContextProvider : InstanceContextProviderBase {
    internal PerCallInstanceContextProvider(DispatchRuntime dispatchRuntime);
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    public virtual void InitializeInstanceContext(InstanceContext instanceContext, Message message, IContextChannel channel);
    public virtual bool IsIdle(InstanceContext instanceContext);
    public virtual void NotifyIdle(InstanceContextIdleCallback callback, InstanceContext instanceContext);
}
internal class System.ServiceModel.Dispatcher.PerSessionInstanceContextProvider : InstanceContextProviderBase {
    internal PerSessionInstanceContextProvider(DispatchRuntime dispatchRuntime);
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    public virtual void InitializeInstanceContext(InstanceContext instanceContext, Message message, IContextChannel channel);
    public virtual bool IsIdle(InstanceContext instanceContext);
    public virtual void NotifyIdle(InstanceContextIdleCallback callback, InstanceContext instanceContext);
}
internal class System.ServiceModel.Dispatcher.PlusOpcode : MathOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PopContextNodes : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PopSequenceToSequenceStackOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PopSequenceToValueStackOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
public class System.ServiceModel.Dispatcher.PrefixEndpointAddressMessageFilter : MessageFilter {
    public EndpointAddress Address { get; }
    public bool IncludeHostNameInComparison { get; }
    internal Dictionary`2<string, HeaderBit[]> HeaderLookup { get; }
    public PrefixEndpointAddressMessageFilter(EndpointAddress address);
    public PrefixEndpointAddressMessageFilter(EndpointAddress address, bool includeHostNameInComparison);
    public EndpointAddress get_Address();
    public bool get_IncludeHostNameInComparison();
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public virtual bool Match(MessageBuffer messageBuffer);
    public virtual bool Match(Message message);
    internal Dictionary`2<string, HeaderBit[]> get_HeaderLookup();
}
internal class System.ServiceModel.Dispatcher.PrefixEndpointAddressMessageFilterTable`1 : EndpointAddressMessageFilterTable`1<TFilterData> {
    protected virtual void InitializeLookupTables();
    public virtual void Add(MessageFilter filter, TFilterData data);
    public virtual void Add(EndpointAddressMessageFilter filter, TFilterData data);
    public void Add(PrefixEndpointAddressMessageFilter filter, TFilterData data);
    internal virtual bool TryMatchCandidateSet(Uri to, bool includeHostNameInComparison, CandidateSet& cset);
    protected virtual void ClearLookupTables();
    public virtual bool Remove(MessageFilter filter);
    public virtual bool Remove(EndpointAddressMessageFilter filter);
    public bool Remove(PrefixEndpointAddressMessageFilter filter);
}
internal class System.ServiceModel.Dispatcher.PrimitiveOperationFormatter : object {
    public PrimitiveOperationFormatter(OperationDescription description, bool isRpc);
    public static bool IsContractSupported(OperationDescription description);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.ProcessingContext : object {
    internal ProcessingContext next;
    internal StackFrame Item { get; }
    internal int IterationCount { get; }
    internal int NodeCount { get; internal set; }
    internal ProcessingContext Next { get; internal set; }
    internal QueryProcessor Processor { get; internal set; }
    internal StackFrame SecondArg { get; }
    internal Value[] Sequences { get; }
    internal bool SequenceStackInUse { get; }
    internal bool StacksInUse { get; }
    internal StackFrame TopArg { get; }
    internal StackFrame TopSequenceArg { get; }
    internal Value[] Values { get; }
    internal StackFrame get_Item(int frameIndex);
    internal int get_IterationCount();
    internal int get_NodeCount();
    internal void set_NodeCount(int value);
    internal ProcessingContext get_Next();
    internal void set_Next(ProcessingContext value);
    internal QueryProcessor get_Processor();
    internal void set_Processor(QueryProcessor value);
    internal StackFrame get_SecondArg();
    internal Value[] get_Sequences();
    internal bool get_SequenceStackInUse();
    internal bool get_StacksInUse();
    internal StackFrame get_TopArg();
    internal StackFrame get_TopSequenceArg();
    internal Value[] get_Values();
    internal ProcessingContext Clone();
    internal void ClearContext();
    internal void CopyFrom(ProcessingContext context);
    internal NodeSequence CreateSequence();
    internal bool LoadVariable(int var);
    internal void EvalCodeBlock(Opcode block);
    internal bool PeekBoolean(int index);
    internal double PeekDouble(int index);
    internal NodeSequence PeekSequence(int index);
    internal string PeekString(int index);
    internal void PopFrame();
    internal void PopSequenceFrame();
    internal void PopContextSequenceFrame();
    internal void Push(bool boolVal);
    internal void Push(bool boolVal, int addCount);
    internal void Push(double doubleVal, int addCount);
    internal void Push(NodeSequence sequence);
    internal void Push(NodeSequence sequence, int addCount);
    internal void Push(string stringVal);
    internal void Push(string stringVal, int addCount);
    internal void PushFrame();
    internal void PopSequenceFrameToValueStack();
    internal void PushSequence(NodeSequence seq);
    internal void PushSequenceFrame();
    internal void PushContextSequenceFrame();
    internal void PushSequenceFrameFromValueStack();
    internal void ReleaseSequence(NodeSequence sequence);
    internal void Release();
    internal void ReplaceSequenceAt(int index, NodeSequence sequence);
    internal void SaveVariable(int var, int count);
    internal void SetValue(ProcessingContext context, int index, bool val);
    internal void SetValue(ProcessingContext context, int index, double val);
    internal void SetValue(ProcessingContext context, int index, string val);
    internal void SetValue(ProcessingContext context, int index, NodeSequence val);
    internal void TransferSequenceSize();
    internal void TransferSequencePositions();
}
internal class System.ServiceModel.Dispatcher.ProxyOperationRuntime : object {
    internal static ParameterInfo[] NoParams;
    internal static Object[] EmptyArray;
    internal string Action { get; }
    internal IClientFaultFormatter FaultFormatter { get; }
    internal bool IsInitiating { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    internal string Name { get; }
    internal ImmutableClientRuntime Parent { get; }
    internal string ReplyAction { get; }
    internal bool DeserializeReply { get; }
    internal bool SerializeRequest { get; }
    internal Type TaskTResult { get; internal set; }
    internal ProxyOperationRuntime(ClientOperation operation, ImmutableClientRuntime parent);
    private static ProxyOperationRuntime();
    internal string get_Action();
    internal IClientFaultFormatter get_FaultFormatter();
    internal bool get_IsInitiating();
    internal bool get_IsOneWay();
    internal bool get_IsTerminating();
    internal bool get_IsSessionOpenNotificationEnabled();
    internal string get_Name();
    internal ImmutableClientRuntime get_Parent();
    internal string get_ReplyAction();
    internal bool get_DeserializeReply();
    internal bool get_SerializeRequest();
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal void AfterReply(ProxyRpc& rpc);
    internal void BeforeRequest(ProxyRpc& rpc);
    internal static object GetDefaultParameterValue(Type parameterType);
    [SecurityCriticalAttribute]
internal bool IsSyncCall(IMethodCallMessage methodCall);
    [SecurityCriticalAttribute]
internal bool IsBeginCall(IMethodCallMessage methodCall);
    [SecurityCriticalAttribute]
internal bool IsTaskCall(IMethodCallMessage methodCall);
    [SecurityCriticalAttribute]
internal Object[] MapSyncInputs(IMethodCallMessage methodCall, Object[]& outs);
    [SecurityCriticalAttribute]
internal Object[] MapAsyncBeginInputs(IMethodCallMessage methodCall, AsyncCallback& callback, Object& asyncState);
    [SecurityCriticalAttribute]
internal void MapAsyncEndInputs(IMethodCallMessage methodCall, IAsyncResult& result, Object[]& outs);
    [SecurityCriticalAttribute]
internal Object[] MapSyncOutputs(IMethodCallMessage methodCall, Object[] outs, Object& ret);
    [SecurityCriticalAttribute]
internal Object[] MapAsyncOutputs(IMethodCallMessage methodCall, Object[] outs, Object& ret);
    internal static bool IsValidAction(Message message, string action);
}
internal class System.ServiceModel.Dispatcher.ProxyRpc : ValueType {
    internal string Action;
    internal ServiceModelActivity Activity;
    internal Guid ActivityId;
    internal ServiceChannel Channel;
    internal Object[] Correlation;
    internal Object[] InputParameters;
    internal ProxyOperationRuntime Operation;
    internal Object[] OutputParameters;
    internal Message Request;
    internal Message Reply;
    internal object ReturnValue;
    internal MessageVersion MessageVersion;
    internal TimeoutHelper TimeoutHelper;
    private EventTraceActivity eventTraceActivity;
    internal EventTraceActivity EventTraceActivity { get; internal set; }
    internal ProxyRpc(ServiceChannel channel, ProxyOperationRuntime operation, string action, Object[] inputs, TimeSpan timeout);
    internal EventTraceActivity get_EventTraceActivity();
    internal void set_EventTraceActivity(EventTraceActivity value);
}
internal class System.ServiceModel.Dispatcher.PushBooleanOpcode : Opcode {
    internal PushBooleanOpcode(bool literal);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PushContextNodeOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PushContextPositionOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PushNumberOpcode : Opcode {
    internal PushNumberOpcode(double literal);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PushStringOpcode : Opcode {
    internal PushStringOpcode(string literal);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.PushXsltVariableOpcode : Opcode {
    internal PushXsltVariableOpcode(XsltContext context, IXsltContextVariable variable);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.QueryAxis : ValueType {
    private AxisDirection direction;
    private QueryNodeType principalNode;
    private QueryAxisType type;
    private QueryNodeType validNodeTypes;
    internal QueryNodeType PrincipalNodeType { get; }
    internal QueryAxisType Type { get; }
    internal QueryNodeType ValidNodeTypes { get; }
    internal QueryAxis(QueryAxisType type, AxisDirection direction, QueryNodeType principalNode, QueryNodeType validNodeTypes);
    internal QueryNodeType get_PrincipalNodeType();
    internal QueryAxisType get_Type();
    internal QueryNodeType get_ValidNodeTypes();
    internal bool IsSupported();
}
internal enum System.ServiceModel.Dispatcher.QueryAxisType : Enum {
    public byte value__;
    public static QueryAxisType None;
    public static QueryAxisType Ancestor;
    public static QueryAxisType AncestorOrSelf;
    public static QueryAxisType Attribute;
    public static QueryAxisType Child;
    public static QueryAxisType Descendant;
    public static QueryAxisType DescendantOrSelf;
    public static QueryAxisType Following;
    public static QueryAxisType FollowingSibling;
    public static QueryAxisType Namespace;
    public static QueryAxisType Parent;
    public static QueryAxisType Preceding;
    public static QueryAxisType PrecedingSibling;
    public static QueryAxisType Self;
}
internal class System.ServiceModel.Dispatcher.QueryBranch : object {
    internal Opcode branch;
    internal int id;
    internal Opcode Branch { get; }
    internal int ID { get; }
    internal QueryBranch(Opcode branch, int id);
    internal Opcode get_Branch();
    internal int get_ID();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.Dispatcher.QueryBranchIndex : object {
    internal int Count { get; }
    internal QueryBranch Item { get; internal set; }
    internal abstract virtual int get_Count();
    internal abstract virtual QueryBranch get_Item(object key);
    internal abstract virtual void set_Item(object key, QueryBranch value);
    internal abstract virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal abstract virtual void Match(int valIndex, Value& val, QueryBranchResultSet results);
    internal abstract virtual void Remove(object key);
    internal abstract virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.QueryBranchResult : ValueType {
    internal QueryBranch branch;
    private int valIndex;
    internal QueryBranch Branch { get; }
    internal int ValIndex { get; }
    internal QueryBranchResult(QueryBranch branch, int valIndex);
    internal QueryBranch get_Branch();
    internal int get_ValIndex();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.QueryBranchResultSet : object {
    internal static SortComparer comparer;
    internal int Count { get; }
    internal QueryBranchResult Item { get; }
    internal QueryBranchResultSet Next { get; internal set; }
    internal QueryBranchResultSet(int capacity);
    private static QueryBranchResultSet();
    internal int get_Count();
    internal QueryBranchResult get_Item(int index);
    internal QueryBranchResultSet get_Next();
    internal void set_Next(QueryBranchResultSet value);
    internal void Add(QueryBranch branch, int valIndex);
    internal void Clear();
    internal void Sort();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.QueryBranchTable : object {
    internal int Count { get; }
    internal QueryBranch Item { get; }
    internal QueryBranchTable(int capacity);
    internal int get_Count();
    internal QueryBranch get_Item(int index);
    internal void AddInOrder(QueryBranch branch);
    public int IndexOf(Opcode opcode);
    public int IndexOfID(int id);
    internal void InsertAt(int index, QueryBranch branch);
    internal bool Remove(Opcode branch);
    internal void RemoveAt(int index);
    internal void Trim();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.QueryBuffer`1 : ValueType {
    internal T[] buffer;
    internal int count;
    internal static T[] EmptyBuffer;
    internal int Count { get; }
    internal T Item { get; internal set; }
    internal QueryBuffer`1(int capacity);
    private static QueryBuffer`1();
    internal int get_Count();
    internal T get_Item(int index);
    internal void set_Item(int index, T value);
    internal void Add(T t);
    internal void Add(QueryBuffer`1& addBuffer);
    internal void Clear();
    internal void CopyFrom(QueryBuffer`1& addBuffer);
    internal void CopyTo(T[] dest);
    internal int IndexOf(T t);
    internal int IndexOf(T t, int startAt);
    internal bool IsValidIndex(int index);
    internal void Reserve(int reserveCount);
    internal void ReserveAt(int index, int reserveCount);
    internal void Remove(T t);
    internal void RemoveAt(int index);
    internal void Sort(IComparer`1<T> comparer);
    internal void TrimToCount();
}
internal enum System.ServiceModel.Dispatcher.QueryCompileError : Enum {
    public int value__;
    public static QueryCompileError None;
    public static QueryCompileError General;
    public static QueryCompileError CouldNotParseExpression;
    public static QueryCompileError UnexpectedToken;
    public static QueryCompileError UnsupportedOperator;
    public static QueryCompileError UnsupportedAxis;
    public static QueryCompileError UnsupportedFunction;
    public static QueryCompileError UnsupportedNodeTest;
    public static QueryCompileError UnsupportedExpression;
    public static QueryCompileError AbsolutePathRequired;
    public static QueryCompileError InvalidNCName;
    public static QueryCompileError InvalidVariable;
    public static QueryCompileError InvalidNumber;
    public static QueryCompileError InvalidLiteral;
    public static QueryCompileError InvalidOperatorName;
    public static QueryCompileError InvalidNodeType;
    public static QueryCompileError InvalidExpression;
    public static QueryCompileError InvalidFunction;
    public static QueryCompileError InvalidLocationPath;
    public static QueryCompileError InvalidLocationStep;
    public static QueryCompileError InvalidAxisSpecifier;
    public static QueryCompileError InvalidNodeTest;
    public static QueryCompileError InvalidPredicate;
    public static QueryCompileError InvalidComparison;
    public static QueryCompileError InvalidOrdinal;
    public static QueryCompileError InvalidType;
    public static QueryCompileError InvalidTypeConversion;
    public static QueryCompileError NoNamespaceForPrefix;
    public static QueryCompileError MismatchedParen;
    public static QueryCompileError DuplicateOpcode;
    public static QueryCompileError OpcodeExists;
    public static QueryCompileError OpcodeNotFound;
    public static QueryCompileError PredicateNestingTooDeep;
}
internal class System.ServiceModel.Dispatcher.QueryCompileException : XPathException {
    internal QueryCompileException(QueryCompileError error, string message);
    internal QueryCompileException(QueryCompileError error);
    public virtual string ToString();
}
internal enum System.ServiceModel.Dispatcher.QueryCompilerFlags : Enum {
    public int value__;
    public static QueryCompilerFlags None;
    public static QueryCompilerFlags InverseQuery;
}
internal class System.ServiceModel.Dispatcher.QueryConditionalBranchOpcode : Opcode {
    internal QueryBranchTable AlwaysBranches { get; }
    internal QueryConditionalBranchOpcode(OpcodeID id, QueryBranchIndex branchIndex);
    internal QueryBranchTable get_AlwaysBranches();
    internal virtual void Add(Opcode opcode);
    internal void AddAlwaysBranch(Opcode literal, Opcode next);
    internal void AddAlwaysBranch(LiteralRelationOpcode literal, Opcode next);
    internal virtual void CollectMatches(int valIndex, Value& val, QueryBranchResultSet results);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual Opcode Eval(ProcessingContext context);
    internal QueryBranch GetBranch(Opcode op);
    internal virtual bool IsEquivalentForAdd(Opcode opcode);
    internal virtual Opcode Locate(Opcode opcode);
    internal virtual void Remove();
    internal virtual void RemoveChild(Opcode opcode);
    internal void RemoveAlwaysBranch(Opcode opcode);
    internal virtual void Replace(Opcode replace, Opcode with);
    internal virtual void Trim();
    internal virtual LiteralRelationOpcode ValidateOpcode(Opcode opcode);
}
internal static class System.ServiceModel.Dispatcher.QueryDataModel : object {
    internal static QueryAxis[] axes;
    internal static string Wildcard;
    private static QueryDataModel();
    internal static bool IsAttribute(string ns);
    internal static QueryAxis GetAxis(QueryAxisType type);
}
internal abstract class System.ServiceModel.Dispatcher.QueryFunction : object {
    protected string name;
    internal ValueDataType[] ParamTypes { get; }
    internal ValueDataType ReturnType { get; }
    internal QueryFunction(string name, ValueDataType returnType);
    internal QueryFunction(string name, ValueDataType returnType, QueryFunctionFlag flags);
    internal QueryFunction(string name, ValueDataType returnType, ValueDataType[] paramTypes);
    internal QueryFunction(string name, ValueDataType returnType, ValueDataType[] paramTypes, QueryFunctionFlag flags);
    private static QueryFunction();
    internal ValueDataType[] get_ParamTypes();
    internal ValueDataType get_ReturnType();
    internal bool Bind(string name, XPathExprList args);
    internal abstract virtual bool Equals(QueryFunction function);
    internal abstract virtual void Eval(ProcessingContext context);
    internal bool TestFlag(QueryFunctionFlag flag);
}
internal enum System.ServiceModel.Dispatcher.QueryFunctionFlag : Enum {
    public int value__;
    public static QueryFunctionFlag None;
    public static QueryFunctionFlag UsesContextNode;
}
internal abstract class System.ServiceModel.Dispatcher.QueryMatcher : object {
    protected int maxNodes;
    protected Opcode query;
    protected int subExprVars;
    protected WeakReference processorPool;
    internal bool IsCompiled { get; }
    internal int NodeQuota { get; internal set; }
    internal Opcode RootOpcode { get; }
    internal int SubExprVarCount { get; }
    private static QueryMatcher();
    internal bool get_IsCompiled();
    internal int get_NodeQuota();
    internal void set_NodeQuota(int value);
    internal Opcode get_RootOpcode();
    internal int get_SubExprVarCount();
    internal static OpcodeBlock CompileForExternalEngine(string expression, XmlNamespaceManager namespaces, object item, bool match);
    internal static OpcodeBlock CompileForInternalEngine(XPathMessageFilter filter, QueryCompilerFlags flags, IFunctionLibrary[] functionLibs, ValueDataType& returnType);
    internal static OpcodeBlock CompileForInternalEngine(string xpath, XmlNamespaceManager nsManager, QueryCompilerFlags flags, IFunctionLibrary[] functionLibs, ValueDataType& returnType);
    internal static OpcodeBlock CompileForInternalEngine(string xpath, XmlNamespaceManager ns, QueryCompilerFlags flags, ValueDataType& returnType);
    internal SeekableXPathNavigator CreateMessageNavigator(Message message, bool matchBody);
    internal SeekableXPathNavigator CreateSeekableNavigator(XPathNavigator navigator);
    internal SeekableXPathNavigator CreateSafeNavigator(SeekableXPathNavigator navigator);
    internal QueryProcessor CreateProcessor();
    internal FilterResult Match(MessageBuffer messageBuffer, ICollection`1<MessageFilter> matches);
    internal FilterResult Match(Message message, bool matchBody, ICollection`1<MessageFilter> matches);
    internal QueryResult`1<TResult> Evaluate(MessageBuffer messageBuffer);
    internal QueryResult`1<TResult> Evaluate(Message message, bool matchBody);
    internal FilterResult Match(SeekableXPathNavigator navigator, ICollection`1<MessageFilter> matches);
    internal FilterResult Match(XPathNavigator navigator, ICollection`1<MessageFilter> matches);
    internal void ReleaseProcessor(QueryProcessor processor);
    internal void ReleaseResult(FilterResult result);
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.QueryMultipleResultOpcode : MultipleResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.QueryNode : ValueType {
    private SeekableXPathNavigator node;
    private long nodePosition;
    internal string LocalName { get; }
    internal string Name { get; }
    internal string Namespace { get; }
    internal SeekableXPathNavigator Node { get; }
    internal long Position { get; }
    internal string Value { get; }
    internal QueryNode(SeekableXPathNavigator node);
    internal string get_LocalName();
    internal string get_Name();
    internal string get_Namespace();
    internal SeekableXPathNavigator get_Node();
    internal long get_Position();
    internal string get_Value();
    internal SeekableXPathNavigator MoveTo();
}
internal class System.ServiceModel.Dispatcher.QueryNodeComparer : object {
    public sealed virtual int Compare(QueryNode item1, QueryNode item2);
    public bool Equals(QueryNode item1, QueryNode item2);
    public int GetHashCode(QueryNode item);
}
internal enum System.ServiceModel.Dispatcher.QueryNodeType : Enum {
    public byte value__;
    public static QueryNodeType Any;
    public static QueryNodeType Root;
    public static QueryNodeType Attribute;
    public static QueryNodeType Element;
    public static QueryNodeType Text;
    public static QueryNodeType Comment;
    public static QueryNodeType Processing;
    public static QueryNodeType Namespace;
    public static QueryNodeType Multiple;
    public static QueryNodeType ChildNodes;
    public static QueryNodeType Ancestor;
    public static QueryNodeType All;
}
internal enum System.ServiceModel.Dispatcher.QueryProcessingError : Enum {
    public int value__;
    public static QueryProcessingError None;
    public static QueryProcessingError Unexpected;
    public static QueryProcessingError TypeMismatch;
    public static QueryProcessingError UnsupportedXmlNodeType;
    public static QueryProcessingError NodeCountMaxExceeded;
    public static QueryProcessingError InvalidXmlAttributes;
    public static QueryProcessingError InvalidNavigatorPosition;
    public static QueryProcessingError NotAtomized;
    public static QueryProcessingError NotSupported;
    public static QueryProcessingError InvalidBodyAccess;
    public static QueryProcessingError InvalidNamespacePrefix;
}
internal class System.ServiceModel.Dispatcher.QueryProcessingException : XPathException {
    internal QueryProcessingException(QueryProcessingError error, string message);
    internal QueryProcessingException(QueryProcessingError error);
    public virtual string ToString();
}
internal enum System.ServiceModel.Dispatcher.QueryProcessingFlags : Enum {
    public byte value__;
    public static QueryProcessingFlags None;
    public static QueryProcessingFlags Match;
    public static QueryProcessingFlags Message;
}
internal class System.ServiceModel.Dispatcher.QueryProcessor : ProcessingContext {
    internal string Action { get; internal set; }
    internal SeekableXPathNavigator ContextNode { get; internal set; }
    internal Message ContextMessage { get; internal set; }
    internal int CounterMarker { get; internal set; }
    unknown bool MatchBody {internal set; }
    internal QueryMatcher Matcher { get; }
    internal ICollection`1<KeyValuePair`2<MessageQuery, XPathResult>> ResultSet { get; internal set; }
    internal string MessageId { get; internal set; }
    internal bool Result { get; internal set; }
    internal XPathResult QueryResult { get; internal set; }
    internal Collection`1<MessageFilter> MatchList { get; }
    internal ICollection`1<MessageFilter> MatchSet { get; internal set; }
    internal string SoapUri { get; internal set; }
    internal string ToHeader { get; internal set; }
    internal QueryProcessor(QueryMatcher matcher);
    internal string get_Action();
    internal void set_Action(string value);
    internal SeekableXPathNavigator get_ContextNode();
    internal void set_ContextNode(SeekableXPathNavigator value);
    internal Message get_ContextMessage();
    internal void set_ContextMessage(Message value);
    internal int get_CounterMarker();
    internal void set_CounterMarker(int value);
    internal void set_MatchBody(bool value);
    internal QueryMatcher get_Matcher();
    internal ICollection`1<KeyValuePair`2<MessageQuery, XPathResult>> get_ResultSet();
    internal void set_ResultSet(ICollection`1<KeyValuePair`2<MessageQuery, XPathResult>> value);
    internal string get_MessageId();
    internal void set_MessageId(string value);
    internal bool get_Result();
    internal void set_Result(bool value);
    internal XPathResult get_QueryResult();
    internal void set_QueryResult(XPathResult value);
    internal Collection`1<MessageFilter> get_MatchList();
    internal ICollection`1<MessageFilter> get_MatchSet();
    internal void set_MatchSet(ICollection`1<MessageFilter> value);
    internal string get_SoapUri();
    internal void set_SoapUri(string value);
    internal string get_ToHeader();
    internal void set_ToHeader(string value);
    internal void AddRef();
    internal void ClearProcessor();
    internal ProcessingContext CloneContext(ProcessingContext srcContext);
    internal QueryBranchResultSet CreateResultSet();
    internal int ElapsedCount(int marker);
    internal void EnsureFilterCollection();
    internal void Eval(Opcode block);
    internal void Eval(Opcode block, ProcessingContext context);
    internal void Eval(Opcode block, Message message, bool matchBody);
    internal void Eval(Opcode block, SeekableXPathNavigator navigator);
    internal bool LoadVariable(ProcessingContext context, int var);
    internal ProcessingContext PopContext();
    internal NodeSequence PopSequence();
    internal QueryBranchResultSet PopResultSet();
    internal void PushContext(ProcessingContext context);
    internal void PushResultSet(QueryBranchResultSet resultSet);
    internal bool ReleaseRef();
    internal void ReleaseContext(ProcessingContext context);
    internal void ReleaseResults(QueryBranchResultSet resultSet);
    internal void ReleaseSequenceToPool(NodeSequence sequence);
    internal void SaveVariable(ProcessingContext context, int var, int count);
}
internal class System.ServiceModel.Dispatcher.QueryRange : ValueType {
    internal int end;
    internal int start;
    internal int Count { get; }
    internal QueryRange(int start, int end);
    internal int get_Count();
    internal bool IsInRange(int point);
    internal void Shift(int offset);
}
internal class System.ServiceModel.Dispatcher.QueryResult`1 : object {
    internal QueryResult`1(QueryMatcher matcher, Message message, bool evalBody);
    public TResult GetSingleResult();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageQuery, TResult>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.ServiceModel.Dispatcher.QueryResultOpcode : ResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.QuerySingleFxEngineResultOpcode : SingleFxEngineResultOpcode {
    internal virtual Opcode Eval(ProcessingContext context);
    internal XPathResult Select(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.QueryTreeBuilder : object {
    internal Opcode LastOpcode { get; }
    internal Opcode get_LastOpcode();
    internal Opcode Build(Opcode tree, OpcodeBlock newBlock);
}
internal static class System.ServiceModel.Dispatcher.QueryValueModel : object {
    internal static bool Boolean(string val);
    internal static bool Boolean(double dblVal);
    internal static bool Boolean(NodeSequence sequence);
    internal static bool Boolean(XPathNodeIterator iterator);
    internal static double Double(bool val);
    internal static double Double(string val);
    internal static double Double(NodeSequence sequence);
    internal static double Double(XPathNodeIterator iterator);
    internal static string String(bool val);
    internal static string String(double val);
    internal static string String(NodeSequence sequence);
    internal static string String(XPathNodeIterator iterator);
    internal static bool Compare(bool x, bool y, RelationOperator op);
    internal static bool Compare(bool x, double y, RelationOperator op);
    internal static bool Compare(bool x, string y, RelationOperator op);
    internal static bool Compare(bool x, NodeSequence y, RelationOperator op);
    internal static bool Compare(double x, bool y, RelationOperator op);
    internal static bool Compare(double x, double y, RelationOperator op);
    internal static bool Compare(double x, string y, RelationOperator op);
    internal static bool Compare(double x, NodeSequence y, RelationOperator op);
    internal static bool Compare(string x, bool y, RelationOperator op);
    internal static bool Compare(string x, double y, RelationOperator op);
    internal static bool Compare(string x, string y, RelationOperator op);
    internal static bool Compare(string x, NodeSequence y, RelationOperator op);
    internal static bool Compare(NodeSequence x, bool y, RelationOperator op);
    internal static bool Compare(NodeSequence x, double y, RelationOperator op);
    internal static bool Compare(NodeSequence x, string y, RelationOperator op);
    internal static bool Compare(NodeSequence x, NodeSequence y, RelationOperator op);
    internal static bool CompileTimeCompare(object x, object y, RelationOperator op);
    internal static bool Equals(bool x, string y);
    internal static bool Equals(double x, string y);
    internal static bool Equals(string x, string y);
    internal static bool Equals(NodeSequence x, string y);
    internal static bool Equals(bool x, double y);
    internal static bool Equals(double x, double y);
    internal static bool Equals(NodeSequence x, double y);
    internal static double Round(double val);
}
internal class System.ServiceModel.Dispatcher.QuotaThrottle : object {
    unknown string Owner {internal set; }
    internal int Limit { get; }
    internal QuotaThrottle(WaitCallback release, object mutex);
    internal void set_Owner(string value);
    internal int get_Limit();
    internal bool Acquire(object o);
    internal int IncrementLimit(int incrementBy);
    internal void SetLimit(int messageLimit);
    internal void Release(Object[] released);
}
internal enum System.ServiceModel.Dispatcher.ReceiveContextAcknowledgementMode : Enum {
    public int value__;
    public static ReceiveContextAcknowledgementMode AutoAcknowledgeOnReceive;
    public static ReceiveContextAcknowledgementMode AutoAcknowledgeOnRPCComplete;
    public static ReceiveContextAcknowledgementMode ManualAcknowledgement;
}
internal class System.ServiceModel.Dispatcher.ReceiveContextRPCFacet : object {
    private static ReceiveContextRPCFacet();
    public static void CreateIfRequired(ImmutableDispatchRuntime dispatchRuntime, MessageRpc& messageRpc);
    public void Complete(ImmutableDispatchRuntime dispatchRuntime, MessageRpc& rpc, TimeSpan timeout, Transaction transaction);
    public IAsyncResult BeginComplete(TimeSpan timeout, Transaction transaction, ChannelHandler channelHandler, AsyncCallback callback, object state);
    public void EndComplete(IAsyncResult result);
    public IAsyncResult BeginAbandon(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndAbandon(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.RelationOpcode : Opcode {
    protected RelationOperator op;
    internal RelationOpcode(RelationOperator op);
    protected RelationOpcode(OpcodeID id, RelationOperator op);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal enum System.ServiceModel.Dispatcher.RelationOperator : Enum {
    public int value__;
    public static RelationOperator None;
    public static RelationOperator Eq;
    public static RelationOperator Ne;
    public static RelationOperator Gt;
    public static RelationOperator Ge;
    public static RelationOperator Lt;
    public static RelationOperator Le;
}
internal class System.ServiceModel.Dispatcher.ReplyChannelBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal ReplyChannelBinder(IReplyChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.RequestChannelBinder : object {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal RequestChannelBinder(IRequestChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal abstract class System.ServiceModel.Dispatcher.ResultOpcode : Opcode {
    internal ResultOpcode(OpcodeID id);
}
internal class System.ServiceModel.Dispatcher.SafeNodeSequenceIterator : NodeSequenceIterator {
    public SafeNodeSequenceIterator(NodeSequence seq, ProcessingContext context);
    public virtual XPathNodeIterator Clone();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Dispatcher.SafeSeekableNavigator : SeekableXPathNavigator {
    public string BaseURI { get; }
    public int CounterMarker { get; public set; }
    unknown int MaxCounter {public set; }
    public long CurrentPosition { get; public set; }
    public bool HasAttributes { get; }
    public bool HasChildren { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XPathNodeType NodeType { get; }
    public string Prefix { get; }
    public string Value { get; }
    public string XmlLang { get; }
    internal SafeSeekableNavigator(SafeSeekableNavigator nav);
    internal SafeSeekableNavigator(SeekableXPathNavigator navigator, int nodeCountMax);
    public virtual string get_BaseURI();
    public sealed virtual int get_CounterMarker();
    public sealed virtual void set_CounterMarker(int value);
    public sealed virtual void set_MaxCounter(int value);
    public virtual long get_CurrentPosition();
    public virtual void set_CurrentPosition(long value);
    public virtual bool get_HasAttributes();
    public virtual bool get_HasChildren();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XPathNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XPathNavigator Clone();
    public virtual XmlNodeOrder ComparePosition(XPathNavigator navigator);
    public virtual XmlNodeOrder ComparePosition(long x, long y);
    public sealed virtual int ElapsedCount(int marker);
    public virtual string GetLocalName(long nodePosition);
    public virtual string GetName(long nodePosition);
    public virtual string GetNamespace(long nodePosition);
    public virtual XPathNodeType GetNodeType(long nodePosition);
    public virtual string GetValue(long nodePosition);
    public virtual string GetNamespace(string name);
    public virtual string GetAttribute(string localName, string namespaceURI);
    public sealed virtual void Increase();
    public sealed virtual void IncreaseBy(int count);
    internal void IncrementNodeCount();
    public virtual bool IsDescendant(XPathNavigator navigator);
    public virtual bool IsSamePosition(XPathNavigator other);
    public virtual void MoveToRoot();
    public virtual bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToPrevious();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNamespace(string name);
    public virtual bool MoveToParent();
    public virtual bool MoveTo(XPathNavigator other);
    public virtual bool MoveToId(string id);
    public virtual bool MoveToFirstChild();
    public virtual bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToNext();
    public virtual bool MoveToFirst();
}
internal class System.ServiceModel.Dispatcher.SecurityImpersonationBehavior : object {
    public static SecurityImpersonationBehavior CreateIfNecessary(DispatchRuntime dispatch);
    internal bool IsSecurityContextImpersonationRequired(MessageRpc& rpc);
    internal bool IsImpersonationEnabledOnCurrentOperation(MessageRpc& rpc);
    [SecurityCriticalAttribute]
public void StartImpersonation(MessageRpc& rpc, IDisposable& impersonationContext, IPrincipal& originalPrincipal, Boolean& isThreadPrincipalSet);
    public void StopImpersonation(MessageRpc& rpc, IDisposable impersonationContext, IPrincipal originalPrincipal, bool isThreadPrincipalSet);
}
internal class System.ServiceModel.Dispatcher.SecurityValidationBehavior : object {
    public static SecurityValidationBehavior Instance { get; }
    public static SecurityValidationBehavior get_Instance();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    internal void AfterBuildTimeValidation(ServiceDescription description);
}
internal class System.ServiceModel.Dispatcher.SeekableMessageNavigator : SeekableXPathNavigator {
    public string BaseURI { get; }
    public long CurrentPosition { get; public set; }
    public bool HasAttributes { get; }
    public bool HasChildren { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    internal Message Message { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XPathNodeType NodeType { get; }
    public string Prefix { get; }
    public string Value { get; }
    public string XmlLang { get; }
    private int System.ServiceModel.Dispatcher.INodeCounter.CounterMarker { get; private set; }
    unknown int System.ServiceModel.Dispatcher.INodeCounter.MaxCounter {private set; }
    private static SeekableMessageNavigator();
    internal SeekableMessageNavigator(SeekableMessageNavigator nav);
    internal SeekableMessageNavigator(Message msg, int countMax, XmlSpace space, bool includeBody, bool atomize);
    public virtual string get_BaseURI();
    public virtual long get_CurrentPosition();
    public virtual void set_CurrentPosition(long value);
    public virtual bool get_HasAttributes();
    public virtual bool get_HasChildren();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    internal Message get_Message();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XPathNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XPathNavigator Clone();
    public virtual XmlNodeOrder ComparePosition(XPathNavigator nav);
    internal XmlNodeOrder ComparePosition(SeekableMessageNavigator nav);
    public virtual XmlNodeOrder ComparePosition(long pos1, long pos2);
    public virtual object Evaluate(string xpath);
    public virtual object Evaluate(XPathExpression expr);
    public virtual object Evaluate(XPathExpression expr, XPathNodeIterator context);
    public virtual string GetAttribute(string name, string ns);
    public virtual string GetLocalName(long pos);
    public virtual string GetName(long pos);
    public virtual string GetNamespace(long pos);
    public virtual string GetNamespace(string name);
    public virtual XPathNodeType GetNodeType(long pos);
    public virtual string GetValue(long pos);
    public virtual bool IsDescendant(XPathNavigator nav);
    internal bool IsDescendant(SeekableMessageNavigator nav);
    public virtual bool IsSamePosition(XPathNavigator nav);
    internal bool IsSamePosition(SeekableMessageNavigator nav);
    public virtual bool Matches(string xpath);
    public virtual bool Matches(XPathExpression expr);
    public virtual bool MoveTo(XPathNavigator nav);
    internal bool MoveTo(SeekableMessageNavigator nav);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToFirst();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToFirstChild();
    public virtual bool MoveToFirstNamespace(XPathNamespaceScope scope);
    public virtual bool MoveToId(string id);
    public virtual bool MoveToNamespace(string name);
    public virtual bool MoveToNext();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToNextNamespace(XPathNamespaceScope scope);
    public virtual bool MoveToParent();
    public virtual bool MoveToPrevious();
    public virtual void MoveToRoot();
    public virtual XPathNodeIterator Select(string xpath);
    public virtual XPathNodeIterator Select(XPathExpression xpath);
    public virtual XPathNodeIterator SelectAncestors(XPathNodeType type, bool matchSelf);
    public virtual XPathNodeIterator SelectAncestors(string name, string namespaceURI, bool matchSelf);
    public virtual XPathNodeIterator SelectChildren(XPathNodeType type);
    public virtual XPathNodeIterator SelectChildren(string name, string namespaceURI);
    public virtual XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf);
    public virtual XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf);
    internal void Atomize();
    internal void ForkNodeCount(int count);
    internal void Init(Message msg, int countMax, XmlSpace space, bool includeBody, bool atomize);
    private sealed virtual override int System.ServiceModel.Dispatcher.INodeCounter.get_CounterMarker();
    private sealed virtual override void System.ServiceModel.Dispatcher.INodeCounter.set_CounterMarker(int value);
    private sealed virtual override void System.ServiceModel.Dispatcher.INodeCounter.set_MaxCounter(int value);
    private sealed virtual override int System.ServiceModel.Dispatcher.INodeCounter.ElapsedCount(int marker);
    private sealed virtual override void System.ServiceModel.Dispatcher.INodeCounter.Increase();
    private sealed virtual override void System.ServiceModel.Dispatcher.INodeCounter.IncreaseBy(int count);
}
public abstract class System.ServiceModel.Dispatcher.SeekableXPathNavigator : XPathNavigator {
    public long CurrentPosition { get; public set; }
    public abstract virtual long get_CurrentPosition();
    public abstract virtual void set_CurrentPosition(long value);
    public abstract virtual XmlNodeOrder ComparePosition(long firstPosition, long secondPosition);
    public abstract virtual string GetLocalName(long nodePosition);
    public abstract virtual string GetName(long nodePosition);
    public abstract virtual string GetNamespace(long nodePosition);
    public abstract virtual XPathNodeType GetNodeType(long nodePosition);
    public abstract virtual string GetValue(long nodePosition);
}
internal class System.ServiceModel.Dispatcher.SelectOpcode : Opcode {
    protected NodeSelectCriteria criteria;
    internal NodeSelectCriteria Criteria { get; }
    internal SelectOpcode(NodeSelectCriteria criteria);
    internal SelectOpcode(OpcodeID id, NodeSelectCriteria criteria);
    internal SelectOpcode(OpcodeID id, NodeSelectCriteria criteria, OpcodeFlags flags);
    internal NodeSelectCriteria get_Criteria();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
    internal virtual Opcode Eval(NodeSequence sequence, SeekableXPathNavigator node);
}
internal class System.ServiceModel.Dispatcher.SelectRootOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.SequentialMessageFilterTable`1 : object {
    public int Count { get; }
    public FilterData Item { get; public set; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<FilterData> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual bool GetMatchingValue(Message message, FilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer buffer, FilterData& data);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<FilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer buffer, ICollection`1<FilterData> results);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer buffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer buffer, ICollection`1<MessageFilter> results);
    public sealed virtual FilterData get_Item(MessageFilter key);
    public sealed virtual void set_Item(MessageFilter key, FilterData value);
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<FilterData> get_Values();
    public sealed virtual bool ContainsKey(MessageFilter key);
    public sealed virtual void Add(MessageFilter key, FilterData value);
    public sealed virtual bool Remove(MessageFilter key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Add(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Contains(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Remove(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<MessageFilter, FilterData>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.GetEnumerator();
    public sealed virtual bool TryGetValue(MessageFilter filter, FilterData& data);
}
public class System.ServiceModel.Dispatcher.ServiceThrottle : object {
    internal static int DefaultMaxConcurrentCalls;
    internal static int DefaultMaxConcurrentSessions;
    internal static int DefaultMaxConcurrentCallsCpuCount;
    internal static int DefaultMaxConcurrentSessionsCpuCount;
    internal int ManualFlowControlLimit { get; internal set; }
    public int MaxConcurrentCalls { get; public set; }
    public int MaxConcurrentSessions { get; public set; }
    public int MaxConcurrentInstances { get; public set; }
    internal bool IsActive { get; }
    internal object ThisLock { get; }
    internal ServiceThrottle(ServiceHostBase host);
    private static ServiceThrottle();
    internal int get_ManualFlowControlLimit();
    internal void set_ManualFlowControlLimit(int value);
    public int get_MaxConcurrentCalls();
    public void set_MaxConcurrentCalls(int value);
    public int get_MaxConcurrentSessions();
    public void set_MaxConcurrentSessions(int value);
    public int get_MaxConcurrentInstances();
    public void set_MaxConcurrentInstances(int value);
    internal bool get_IsActive();
    internal object get_ThisLock();
    internal void SetServicePerformanceCounters(ServicePerformanceCountersBase counters);
    internal bool AcquireCall(ChannelHandler channel);
    internal bool AcquireInstanceContextAndDynamic(ChannelHandler channel, bool acquireInstanceContextThrottle);
    internal bool AcquireSession(ISessionThrottleNotification source);
    internal bool AcquireSession(ListenerHandler listener);
    internal void DeactivateChannel();
    internal void DeactivateCall();
    internal void DeactivateInstanceContext();
    internal int IncrementManualFlowControlLimit(int incrementBy);
    internal void AcquiredCallsToken();
    internal void ReleasedCallsToken();
    internal void RatioCallsToken(int count);
    internal void AcquiredInstancesToken();
    internal void ReleasedInstancesToken();
    internal void RatioInstancesToken(int count);
    internal void AcquiredSessionsToken();
    internal void ReleasedSessionsToken();
    internal void RatioSessionsToken(int count);
}
internal class System.ServiceModel.Dispatcher.SharedRuntimeState : object {
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; internal set; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal SharedRuntimeState(bool isOnServer);
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    internal bool get_IsOnServer();
    internal bool get_ManualAddressing();
    internal void set_ManualAddressing(bool value);
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void LockDownProperties();
    internal void ThrowIfImmutable();
}
internal class System.ServiceModel.Dispatcher.SharedTransactedBatchContext : object {
    internal int CurrentBatchSize { get; }
    internal IsolationLevel IsolationLevel { get; }
    internal TimeSpan TransactionTimeout { get; }
    internal object ReceiveLock { get; }
    internal SharedTransactedBatchContext(ChannelHandler handler, ChannelDispatcher dispatcher, int maxConcurrentBatches);
    internal TransactedBatchContext CreateTransactedBatchContext();
    internal void DispatchStarted();
    internal void DispatchEnded();
    internal void BatchDone();
    internal int get_CurrentBatchSize();
    internal IsolationLevel get_IsolationLevel();
    internal TimeSpan get_TransactionTimeout();
    internal void ReportAbort();
    internal void ReportCommit();
    internal object get_ReceiveLock();
}
internal abstract class System.ServiceModel.Dispatcher.SingleFxEngineResultOpcode : ResultOpcode {
    protected XPathExpression xpath;
    protected object item;
    unknown object Item {internal set; }
    unknown XPathExpression XPath {internal set; }
    internal SingleFxEngineResultOpcode(OpcodeID id);
    internal void set_Item(object value);
    internal void set_XPath(XPathExpression value);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual bool Equals(Opcode op);
    protected object Evaluate(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.SingletonInstanceContextProvider : InstanceContextProviderBase {
    internal InstanceContext SingletonInstance { get; }
    internal SingletonInstanceContextProvider(DispatchRuntime dispatchRuntime);
    internal InstanceContext get_SingletonInstance();
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    public virtual void InitializeInstanceContext(InstanceContext instanceContext, Message message, IContextChannel channel);
    public virtual bool IsIdle(InstanceContext instanceContext);
    public virtual void NotifyIdle(InstanceContextIdleCallback callback, InstanceContext instanceContext);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.SortedBuffer`2 : ValueType {
    private int size;
    private T[] buffer;
    internal T Item { get; }
    unknown int Capacity {internal set; }
    internal int Count { get; }
    internal SortedBuffer`2(C comparerInstance);
    internal T get_Item(int index);
    internal void set_Capacity(int value);
    internal int get_Count();
    internal int Add(T item);
    internal void Clear();
    internal void Exchange(T old, T replace);
    internal T GetAt(int index);
    internal int IndexOf(T item);
    internal int IndexOfKey(K key, IItemComparer`2<K, T> itemComp);
    internal int Insert(T item);
    internal bool Remove(T item);
    internal void RemoveAt(int index);
    internal void Trim();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.StackFrame : ValueType {
    internal int basePtr;
    internal int endPtr;
    internal int Count { get; }
    unknown int EndPtr {internal set; }
    internal int Item { get; }
    internal int get_Count();
    internal void set_EndPtr(int value);
    internal int get_Item(int offset);
    internal bool IsValidPtr(int ptr);
}
internal class System.ServiceModel.Dispatcher.StackRegion : ValueType {
    internal QueryRange bounds;
    internal int stackPtr;
    internal int Count { get; }
    internal bool NeedsGrowth { get; }
    internal StackRegion(QueryRange bounds);
    internal int get_Count();
    internal bool get_NeedsGrowth();
    internal void Clear();
    internal void Grow(int growBy);
    internal bool IsValidStackPtr();
    internal bool IsValidStackPtr(int stackPtr);
    internal void Shift(int shiftBy);
}
internal class System.ServiceModel.Dispatcher.StartBooleanOpcode : Opcode {
    internal StartBooleanOpcode(bool test);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.StreamFormatter : object {
    internal string WrapperName { get; internal set; }
    internal string WrapperNamespace { get; internal set; }
    internal string PartName { get; }
    internal string PartNamespace { get; }
    internal static StreamFormatter Create(MessageDescription messageDescription, string operationName, bool isRequest);
    internal void Serialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    internal IAsyncResult BeginSerialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue, AsyncCallback callback, object state);
    public void EndSerialize(IAsyncResult result);
    internal void Deserialize(Object[] parameters, Object& retVal, Message message);
    internal string get_WrapperName();
    internal void set_WrapperName(string value);
    internal string get_WrapperNamespace();
    internal void set_WrapperNamespace(string value);
    internal string get_PartName();
    internal string get_PartNamespace();
    internal static bool IsStream(MessageDescription messageDescription);
}
internal class System.ServiceModel.Dispatcher.StringBranchIndex : HashBranchIndex {
    internal virtual void Match(int valIndex, Value& val, QueryBranchResultSet results);
}
internal class System.ServiceModel.Dispatcher.StringEqualsBranchOpcode : QueryConditionalBranchOpcode {
    internal virtual LiteralRelationOpcode ValidateOpcode(Opcode opcode);
}
internal class System.ServiceModel.Dispatcher.StringEqualsOpcode : LiteralRelationOpcode {
    internal object Literal { get; }
    internal StringEqualsOpcode(string literal);
    internal virtual object get_Literal();
    internal virtual void Add(Opcode op);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.StringPrefixBranchOpcode : QueryConditionalBranchOpcode {
}
internal class System.ServiceModel.Dispatcher.StringPrefixOpcode : LiteralRelationOpcode {
    internal object Literal { get; }
    internal StringPrefixOpcode(string literal);
    internal virtual object get_Literal();
    internal virtual void Add(Opcode op);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.SubExpr : object {
    internal int var;
    internal int refCount;
    internal bool useSpecial;
    protected List`1<SubExpr> children;
    internal Opcode FirstOp { get; }
    internal int Variable { get; }
    internal SubExpr(SubExpr parent, Opcode ops, int var);
    internal Opcode get_FirstOp();
    internal int get_Variable();
    internal SubExprOpcode Add(Opcode opseq, SubExprEliminator elim);
    internal virtual void AddChild(SubExpr expr);
    internal void CleanUp(SubExprEliminator elim);
    internal void DecRef(SubExprEliminator elim);
    internal void Eval(ProcessingContext context);
    internal virtual void EvalSpecial(ProcessingContext context);
    internal void IncRef();
    internal virtual void RemoveChild(SubExpr expr);
    internal void Renumber(SubExprEliminator elim);
    internal void Trim();
}
internal class System.ServiceModel.Dispatcher.SubExprEliminator : object {
    internal List`1<SubExpr> Exprs { get; }
    internal int VariableCount { get; }
    internal List`1<SubExpr> get_Exprs();
    internal int get_VariableCount();
    internal Opcode Add(object item, Opcode ops);
    internal static bool IsExprStarter(Opcode op);
    internal int NewVarID();
    internal void Remove(object item);
    internal void Trim();
}
internal class System.ServiceModel.Dispatcher.SubExprHeader : SubExpr {
    internal SubExprHeader(Opcode ops, int var);
    internal virtual void AddChild(SubExpr expr);
    internal virtual void EvalSpecial(ProcessingContext context);
    internal void RebuildIndex();
    internal virtual void RemoveChild(SubExpr expr);
}
internal class System.ServiceModel.Dispatcher.SubExprOpcode : Opcode {
    protected SubExpr expr;
    internal SubExpr Expr { get; }
    internal SubExprOpcode(SubExpr expr);
    internal SubExpr get_Expr();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
    internal virtual Opcode EvalSpecial(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.SynchronizedChannelCollection`1 : SynchronizedCollection`1<TChannel> {
    internal SynchronizedChannelCollection`1(object syncRoot);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TChannel item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TChannel item);
}
internal class System.ServiceModel.Dispatcher.SyncMethodInvoker : object {
    public bool IsSynchronous { get; }
    public MethodInfo Method { get; }
    public string MethodName { get; }
    public SyncMethodInvoker(MethodInfo method);
    public SyncMethodInvoker(Type type, string methodName);
    public sealed virtual bool get_IsSynchronous();
    public MethodInfo get_Method();
    public string get_MethodName();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual object Invoke(object instance, Object[] inputs, Object[]& outputs);
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
}
internal static class System.ServiceModel.Dispatcher.TaskExtensions : object {
    public static MethodInfo TaskAsAsyncResultMethodInfo { get; }
    public static MethodInfo get_TaskAsAsyncResultMethodInfo();
    public static MethodInfo MakeGenericMethod(Type genericArgument);
}
internal class System.ServiceModel.Dispatcher.TaskMethodInvoker : object {
    public bool IsSynchronous { get; }
    public MethodInfo TaskMethod { get; }
    public TaskMethodInvoker(MethodInfo taskMethod, Type taskType);
    public sealed virtual bool get_IsSynchronous();
    public MethodInfo get_TaskMethod();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual object Invoke(object instance, Object[] inputs, Object[]& outputs);
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.TerminatingOperationBehavior : object {
    public static TerminatingOperationBehavior CreateIfNecessary(DispatchRuntime dispatch);
    internal void AfterReply(MessageRpc& rpc);
    internal static void AfterReply(ProxyRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.ThreadBehavior : object {
    internal ThreadBehavior(DispatchRuntime dispatch);
    internal void BindThread(MessageRpc& rpc);
    internal void BindEndThread(MessageRpc& rpc);
    internal static SynchronizationContext GetCurrentSynchronizationContext();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.ThreadSafeMessageFilterTable`1 : object {
    internal object SyncRoot { get; }
    public int DefaultPriority { get; public set; }
    public int Count { get; }
    public FilterData Item { get; public set; }
    public ICollection`1<MessageFilter> Keys { get; }
    public ICollection`1<FilterData> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.IsReadOnly { get; }
    internal object get_SyncRoot();
    public int get_DefaultPriority();
    public void set_DefaultPriority(int value);
    internal void Add(MessageFilter filter, FilterData data, int priority);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual bool GetMatchingValue(Message message, FilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer buffer, FilterData& data);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<FilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer buffer, ICollection`1<FilterData> results);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer buffer, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer buffer, ICollection`1<MessageFilter> results);
    public sealed virtual FilterData get_Item(MessageFilter key);
    public sealed virtual void set_Item(MessageFilter key, FilterData value);
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public sealed virtual ICollection`1<FilterData> get_Values();
    public sealed virtual bool ContainsKey(MessageFilter key);
    public sealed virtual void Add(MessageFilter key, FilterData value);
    public sealed virtual bool Remove(MessageFilter key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Add(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Contains(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.Remove(KeyValuePair`2<MessageFilter, FilterData> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<MessageFilter, FilterData>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.ServiceModel.Dispatcher.MessageFilter,FilterData>>.GetEnumerator();
    public sealed virtual bool TryGetValue(MessageFilter filter, FilterData& data);
}
internal class System.ServiceModel.Dispatcher.TransactedBatchContext : object {
    internal bool AboutToExpire { get; }
    internal bool IsActive { get; }
    internal bool InDispatch { get; internal set; }
    internal SharedTransactedBatchContext Shared { get; }
    internal Transaction Transaction { get; }
    internal TransactedBatchContext(SharedTransactedBatchContext shared);
    internal bool get_AboutToExpire();
    internal bool get_IsActive();
    internal bool get_InDispatch();
    internal void set_InDispatch(bool value);
    internal SharedTransactedBatchContext get_Shared();
    internal void ForceRollback();
    internal void ForceCommit();
    internal void Complete();
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Prepare(PreparingEnlistment preparingEnlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Commit(Enlistment enlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.Rollback(Enlistment enlistment);
    private sealed virtual override void System.Transactions.IEnlistmentNotification.InDoubt(Enlistment enlistment);
    internal Transaction get_Transaction();
}
internal class System.ServiceModel.Dispatcher.TransactionBehavior : object {
    internal TransactionBehavior(DispatchRuntime dispatch);
    internal static Exception CreateFault(string reasonText, string codeString, bool isNetDispatcherFault);
    internal static TransactionBehavior CreateIfNeeded(DispatchRuntime dispatch);
    internal static TimeSpan NormalizeTimeout(TimeSpan timeout);
    internal static CommittableTransaction CreateTransaction(IsolationLevel isolation, TimeSpan timeout);
    internal void SetCurrent(MessageRpc& rpc);
    internal void ResolveOutcome(MessageRpc& rpc);
    internal void ResolveTransaction(MessageRpc& rpc);
    internal void InitializeCallContext(MessageRpc& rpc);
    internal void ClearCallContext(MessageRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.TransactionInstanceContextFacet : object {
    internal Transaction waiting;
    internal Transaction Attached;
    internal bool ShouldReleaseInstance { get; internal set; }
    internal TransactionInstanceContextFacet(InstanceContext instanceContext);
    internal bool get_ShouldReleaseInstance();
    internal void set_ShouldReleaseInstance(bool value);
    internal void CheckIfTxCompletedAndUpdateAttached(MessageRpc& rpc, bool isConcurrent);
    internal void CompletePendingTransaction(Transaction transaction, Exception error);
    internal static void Complete(Transaction transaction, Exception error);
    internal TransactionScope CreateTransactionScope(Transaction transaction);
    internal void SetCurrent(MessageRpc& rpc);
    internal void AddReference(MessageRpc& rpc, Transaction tx, bool updateCallCount);
    internal void RemoveReference(Transaction tx);
}
internal class System.ServiceModel.Dispatcher.TransactionRpcFacet : object {
    internal Transaction Current;
    internal Transaction Clone;
    internal DependentTransaction dependentClone;
    internal bool IsCompleted;
    internal MessageRpc rpc;
    internal TransactionRpcFacet(MessageRpc& rpc);
    internal void Complete(Exception error);
    internal void SetIncomplete();
    internal void Completed();
    internal void ThreadEnter(Exception& error);
    internal void ThreadLeave();
    internal void CreateDependentClone();
    internal void CompleteDependentClone();
}
internal class System.ServiceModel.Dispatcher.TransactionValidationBehavior : object {
    internal static TransactionValidationBehavior Instance { get; }
    internal static TransactionValidationBehavior get_Instance();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription service, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription service, ServiceHostBase serviceHostBase);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.Trie : object {
    internal TrieSegment Item { get; }
    internal TrieSegment Root { get; }
    internal TrieSegment get_Item(string prefix);
    internal TrieSegment get_Root();
    internal TrieSegment Add(string newPrefix);
    internal void Remove(string segment);
    internal void Trim();
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.TrieBranchIndex : QueryBranchIndex {
    internal int Count { get; }
    internal QueryBranch Item { get; internal set; }
    internal virtual int get_Count();
    internal virtual QueryBranch get_Item(object key);
    internal virtual void set_Item(object key, QueryBranch value);
    internal virtual void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal virtual void Match(int valIndex, Value& val, QueryBranchResultSet results);
    internal virtual void Remove(object key);
    internal virtual void Trim();
}
internal class System.ServiceModel.Dispatcher.TrieSegment : object {
    internal bool CanMerge { get; }
    internal bool CanPrune { get; }
    internal QueryBranch Data { get; internal set; }
    internal char FirstChar { get; }
    internal bool HasChildren { get; }
    internal int Length { get; }
    internal TrieSegment(char firstChar);
    internal TrieSegment(char firstChar, string segmentTail);
    internal TrieSegment(string sourceSegment, int offset, int length);
    private static TrieSegment();
    internal bool get_CanMerge();
    internal bool get_CanPrune();
    internal void CollectXPathFilters(ICollection`1<MessageFilter> filters);
    internal QueryBranch get_Data();
    internal void set_Data(QueryBranch value);
    internal char get_FirstChar();
    internal bool get_HasChildren();
    internal int get_Length();
    internal TrieSegment AddChild(TrieSegment segment);
    internal int FindDivergence(string compareString, int offset, int length);
    internal TrieSegment GetChild(int index);
    internal int GetChildPosition(string matchString, int offset, int length);
    internal int GetChildPosition(char ch);
    internal int IndexOf(TrieSegment segment);
    internal void MergeChild(TrieSegment segment);
    internal void MergeChild(int childIndex);
    internal void Remove();
    internal void RemoveChild(int childIndex, bool fixupTree);
    internal TrieSegment SplitChild(int childIndex, int charIndex);
    internal void Trim();
}
internal class System.ServiceModel.Dispatcher.TrieSegmentComparer : object {
    public sealed virtual int Compare(TrieSegment t1, TrieSegment t2);
    public bool Equals(TrieSegment t1, TrieSegment t2);
    public int GetHashCode(TrieSegment t);
}
internal class System.ServiceModel.Dispatcher.TrieSegmentKeyComparer : object {
    public sealed virtual int Compare(char c, TrieSegment t);
}
internal class System.ServiceModel.Dispatcher.TrieTraverser : ValueType {
    private int length;
    private int offset;
    private string prefix;
    private TrieSegment rootSegment;
    private TrieSegment segment;
    private int segmentIndex;
    internal int Length { get; }
    internal int Offset { get; }
    internal TrieSegment Segment { get; internal set; }
    internal int SegmentIndex { get; }
    internal TrieTraverser(TrieSegment root, string prefix);
    internal int get_Length();
    internal int get_Offset();
    internal TrieSegment get_Segment();
    internal void set_Segment(TrieSegment value);
    internal int get_SegmentIndex();
    internal bool MoveNext();
    internal bool MoveNextByFirstChar();
}
internal class System.ServiceModel.Dispatcher.TypecastOpcode : Opcode {
    internal TypecastOpcode(ValueDataType newType);
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.UnionOpcode : Opcode {
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.UniqueContractNameValidationBehavior : object {
    public sealed virtual void Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    public sealed virtual void AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    public sealed virtual void ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal class System.ServiceModel.Dispatcher.Value : ValueType {
    private bool boolVal;
    private double dblVal;
    private StackFrame frame;
    private NodeSequence sequence;
    private string strVal;
    private ValueDataType type;
    internal bool Boolean { get; internal set; }
    internal double Double { get; internal set; }
    internal StackFrame Frame { get; }
    unknown int FrameEndPtr {internal set; }
    internal int NodeCount { get; }
    internal NodeSequence Sequence { get; internal set; }
    internal string String { get; internal set; }
    internal ValueDataType Type { get; }
    internal bool get_Boolean();
    internal void set_Boolean(bool value);
    internal double get_Double();
    internal void set_Double(double value);
    internal StackFrame get_Frame();
    internal void set_FrameEndPtr(int value);
    internal int get_NodeCount();
    internal NodeSequence get_Sequence();
    internal void set_Sequence(NodeSequence value);
    internal string get_String();
    internal void set_String(string value);
    internal ValueDataType get_Type();
    internal void Add(double val);
    internal void Clear(ProcessingContext context);
    internal bool CompareTo(Value& val, RelationOperator op);
    internal bool CompareTo(double val, RelationOperator op);
    internal void ConvertTo(ProcessingContext context, ValueDataType newType);
    internal bool Equals(string val);
    internal bool Equals(double val);
    internal bool GetBoolean();
    internal double GetDouble();
    internal NodeSequence GetSequence();
    internal string GetString();
    internal bool IsType(ValueDataType type);
    internal void Multiply(double val);
    internal void Negate();
    internal void Not();
    internal void ReleaseSequence(ProcessingContext context);
    internal void StartFrame(int start);
    internal bool ToBoolean();
    internal double ToDouble();
    public virtual string ToString();
    internal void Update(ProcessingContext context, bool val);
    internal void Update(ProcessingContext context, double val);
    internal void Update(ProcessingContext context, string val);
    internal void Update(ProcessingContext context, NodeSequence val);
}
internal enum System.ServiceModel.Dispatcher.ValueDataType : Enum {
    public byte value__;
    public static ValueDataType None;
    public static ValueDataType Boolean;
    public static ValueDataType Double;
    public static ValueDataType StackFrame;
    public static ValueDataType Sequence;
    public static ValueDataType String;
}
internal class System.ServiceModel.Dispatcher.WrappedTransaction : object {
    internal Transaction Transaction { get; }
    internal WrappedTransaction(Transaction transaction);
    internal Transaction get_Transaction();
}
internal class System.ServiceModel.Dispatcher.XmlSerializerFaultFormatter : FaultFormatter {
    internal XmlSerializerFaultFormatter(Type[] detailTypes, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    internal XmlSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerObjectSerializer : XmlObjectSerializer {
    internal XmlSerializerObjectSerializer(Type type);
    internal XmlSerializerObjectSerializer(Type type, XmlQualifiedName qualifiedName, XmlSerializer xmlSerializer);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerOperationFormatter : OperationFormatter {
    public XmlSerializerOperationFormatter(OperationDescription description, XmlSerializerFormatAttribute xmlSerializerFormatAttribute, MessageInfo requestMessageInfo, MessageInfo replyMessageInfo);
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion version);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    internal static string GetEncoding(EnvelopeVersion version);
}
internal static class System.ServiceModel.Dispatcher.XPathCharTypes : object {
    private static XPathCharTypes();
    internal static bool IsDigit(char c);
    internal static bool IsWhitespace(char c);
    internal static bool IsNCName(char c);
    internal static bool IsNCNameStart(char c);
}
internal class System.ServiceModel.Dispatcher.XPathCompiler : object {
    internal XPathCompiler(QueryCompilerFlags flags);
    internal virtual OpcodeBlock Compile(XPathExpr expr);
}
internal class System.ServiceModel.Dispatcher.XPathConjunctExpr : XPathExpr {
    internal XPathExpr Left { get; }
    internal XPathExpr Right { get; }
    internal XPathConjunctExpr(XPathExprType type, ValueDataType returnType, XPathExpr left, XPathExpr right);
    internal XPathExpr get_Left();
    internal XPathExpr get_Right();
}
internal class System.ServiceModel.Dispatcher.XPathExpr : object {
    internal bool IsLiteral { get; }
    internal bool Negate { get; internal set; }
    internal ValueDataType ReturnType { get; internal set; }
    internal int SubExprCount { get; }
    internal XPathExprList SubExpr { get; }
    internal XPathExprType Type { get; }
    internal bool TypecastRequired { get; internal set; }
    internal XPathExpr(XPathExprType type, ValueDataType returnType, XPathExprList subExpr);
    internal XPathExpr(XPathExprType type, ValueDataType returnType);
    internal virtual bool get_IsLiteral();
    internal bool get_Negate();
    internal void set_Negate(bool value);
    internal ValueDataType get_ReturnType();
    internal void set_ReturnType(ValueDataType value);
    internal int get_SubExprCount();
    internal XPathExprList get_SubExpr();
    internal XPathExprType get_Type();
    internal bool get_TypecastRequired();
    internal void set_TypecastRequired(bool value);
    internal void Add(XPathExpr expr);
    internal void AddBooleanExpression(XPathExprType boolExprType, XPathExpr expr);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Dispatcher.XPathExprList : object {
    internal int Count { get; }
    internal XPathExpr Item { get; }
    internal int get_Count();
    internal XPathExpr get_Item(int index);
    internal void Add(XPathExpr expr);
}
internal enum System.ServiceModel.Dispatcher.XPathExprType : Enum {
    public byte value__;
    public static XPathExprType Unknown;
    public static XPathExprType Or;
    public static XPathExprType And;
    public static XPathExprType Relational;
    public static XPathExprType Union;
    public static XPathExprType LocationPath;
    public static XPathExprType RelativePath;
    public static XPathExprType PathStep;
    public static XPathExprType XsltVariable;
    public static XPathExprType String;
    public static XPathExprType Number;
    public static XPathExprType Function;
    public static XPathExprType XsltFunction;
    public static XPathExprType Math;
    public static XPathExprType Filter;
    public static XPathExprType Path;
}
internal enum System.ServiceModel.Dispatcher.XPathFilterFlags : Enum {
    public int value__;
    public static XPathFilterFlags None;
    public static XPathFilterFlags AlwaysMatch;
    public static XPathFilterFlags IsFxFilter;
}
internal class System.ServiceModel.Dispatcher.XPathFunction : QueryFunction {
    internal XPathFunctionID ID { get; }
    internal XPathFunction(XPathFunctionID functionID, string name, ValueDataType returnType);
    internal XPathFunction(XPathFunctionID functionID, string name, ValueDataType returnType, QueryFunctionFlag flags);
    internal XPathFunction(XPathFunctionID functionID, string name, ValueDataType returnType, ValueDataType[] argTypes);
    internal XPathFunctionID get_ID();
    internal virtual bool Equals(QueryFunction function);
    internal virtual void Eval(ProcessingContext context);
    internal static void BooleanBoolean(ProcessingContext context);
    internal static void BooleanFalse(ProcessingContext context);
    internal static void BooleanNot(ProcessingContext context);
    internal static void BooleanTrue(ProcessingContext context);
    internal static void BooleanLang(ProcessingContext context);
    internal static void IterateAndPushSequences(ProcessingContext context);
    internal static void NodesetCount(ProcessingContext context);
    internal static void NodesetLast(ProcessingContext context);
    internal static void NodesetLocalName(ProcessingContext context);
    internal static void NodesetLocalNameDefault(ProcessingContext context);
    internal static void NodesetName(ProcessingContext context);
    internal static void NodesetNameDefault(ProcessingContext context);
    internal static void NodesetNamespaceUri(ProcessingContext context);
    internal static void NodesetNamespaceUriDefault(ProcessingContext context);
    internal static void NodesetPosition(ProcessingContext context);
    internal static void NumberCeiling(ProcessingContext context);
    internal static void NumberNumber(ProcessingContext context);
    internal static void NumberNumberDefault(ProcessingContext context);
    internal static void NumberFloor(ProcessingContext context);
    internal static void NumberRound(ProcessingContext context);
    internal static void NumberSum(ProcessingContext context);
    internal static void StringString(ProcessingContext context);
    internal static void StringStringDefault(ProcessingContext context);
    internal static void StringConcatTwo(ProcessingContext context);
    internal static void StringConcatThree(ProcessingContext context);
    internal static void StringConcatFour(ProcessingContext context);
    internal static void StringContains(ProcessingContext context);
    internal static void StringLength(ProcessingContext context);
    internal static void StringLengthDefault(ProcessingContext context);
    internal static void StringStartsWith(ProcessingContext context);
    internal static void SubstringBefore(ProcessingContext context);
    internal static void SubstringAfter(ProcessingContext context);
    internal static void Substring(ProcessingContext context);
    internal static void SubstringLimit(ProcessingContext context);
    internal static void Translate(ProcessingContext context);
    internal static void NormalizeSpace(ProcessingContext context);
    internal static void NormalizeSpaceDefault(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.XPathFunctionExpr : XPathExpr {
    internal QueryFunction Function { get; }
    internal XPathFunctionExpr(QueryFunction function, XPathExprList subExpr);
    internal QueryFunction get_Function();
}
internal enum System.ServiceModel.Dispatcher.XPathFunctionID : Enum {
    public int value__;
    public static XPathFunctionID IterateSequences;
    public static XPathFunctionID Count;
    public static XPathFunctionID Position;
    public static XPathFunctionID Last;
    public static XPathFunctionID LocalName;
    public static XPathFunctionID LocalNameDefault;
    public static XPathFunctionID Name;
    public static XPathFunctionID NameDefault;
    public static XPathFunctionID NamespaceUri;
    public static XPathFunctionID NamespaceUriDefault;
    public static XPathFunctionID Boolean;
    public static XPathFunctionID Not;
    public static XPathFunctionID True;
    public static XPathFunctionID False;
    public static XPathFunctionID Lang;
    public static XPathFunctionID Number;
    public static XPathFunctionID NumberDefault;
    public static XPathFunctionID Ceiling;
    public static XPathFunctionID Floor;
    public static XPathFunctionID Round;
    public static XPathFunctionID Sum;
    public static XPathFunctionID String;
    public static XPathFunctionID StringDefault;
    public static XPathFunctionID StartsWith;
    public static XPathFunctionID ConcatTwo;
    public static XPathFunctionID ConcatThree;
    public static XPathFunctionID ConcatFour;
    public static XPathFunctionID Contains;
    public static XPathFunctionID NormalizeSpace;
    public static XPathFunctionID NormalizeSpaceDefault;
    public static XPathFunctionID StringLength;
    public static XPathFunctionID StringLengthDefault;
    public static XPathFunctionID SubstringBefore;
    public static XPathFunctionID SubstringAfter;
    public static XPathFunctionID Substring;
    public static XPathFunctionID SubstringLimit;
    public static XPathFunctionID Translate;
}
internal class System.ServiceModel.Dispatcher.XPathFunctionLibrary : object {
    private static XPathFunctionLibrary();
    public sealed virtual QueryFunction Bind(string functionName, string functionNamespace, XPathExprList args);
}
internal class System.ServiceModel.Dispatcher.XPathLexer : object {
    internal int FirstTokenChar { get; }
    internal XPathToken Token { get; }
    private static XPathLexer();
    internal XPathLexer(string xpath);
    internal XPathLexer(string xpath, bool resolveKeywords);
    internal int get_FirstTokenChar();
    internal XPathToken get_Token();
    internal string ConsumedSubstring();
    internal bool MoveNext();
}
internal abstract class System.ServiceModel.Dispatcher.XPathLiteralExpr : XPathExpr {
    internal bool IsLiteral { get; }
    internal object Literal { get; }
    internal XPathLiteralExpr(XPathExprType type, ValueDataType returnType);
    internal virtual bool get_IsLiteral();
    internal abstract virtual object get_Literal();
}
internal class System.ServiceModel.Dispatcher.XPathMathExpr : XPathConjunctExpr {
    internal MathOperator Op { get; }
    internal XPathMathExpr(MathOperator op, XPathExpr left, XPathExpr right);
    internal MathOperator get_Op();
}
[TypeConverterAttribute("System.ServiceModel.XamlIntegration.XPathMessageContextTypeConverter")]
public class System.ServiceModel.Dispatcher.XPathMessageContext : XsltContext {
    internal static string S11NS;
    internal static string S12NS;
    internal static string Wsa200408NS;
    internal static string Wsa10NS;
    internal static string WsaNoneNS;
    internal static string TempUriNS;
    internal static string SerializationNS;
    internal static string IndigoNS;
    internal static string S11P;
    internal static string S12P;
    internal static string Wsa200408P;
    internal static string Wsa10P;
    internal static string TempUriP;
    internal static string SerializationP;
    internal static string IndigoP;
    internal static Dictionary`2<string, string> defaultNamespaces;
    internal static string EnvelopeE;
    internal static string HeaderE;
    internal static string BodyE;
    internal static string ActionE;
    internal static string ToE;
    internal static string MessageIDE;
    internal static string RelatesToE;
    internal static string ReplyToE;
    internal static string FromE;
    internal static string FaultToE;
    internal static string Actor11A;
    internal static string Actor12A;
    internal static string MandatoryA;
    internal static XPathMessageFunction HeaderFun;
    internal static XPathMessageFunction BodyFun;
    internal static XPathMessageFunction SoapUriFun;
    internal static XPathMessageFunction MessageIDFun;
    internal static XPathMessageFunction RelatesToFun;
    internal static XPathMessageFunction ReplyToFun;
    internal static XPathMessageFunction FromFun;
    internal static XPathMessageFunction FaultToFun;
    internal static XPathMessageFunction ToFun;
    internal static XPathMessageFunction ActionFun;
    internal static XPathMessageFunction DateNowFun;
    internal static XPathMessageFunction HeadersWithActorFun;
    internal static XPathMessageFunction ActorFun;
    internal static XPathMessageFunction IsMandatoryFun;
    internal static XPathMessageFunction IsActorNextFun;
    internal static XPathMessageFunction IsActorUltRecFun;
    internal static XPathMessageFunction DateFun;
    internal static XPathMessageFunction SpanFun;
    internal static XPathMessageFunction CorrelationDataFun;
    public bool Whitespace { get; }
    private static XPathMessageContext();
    public XPathMessageContext(NameTable table);
    public virtual bool get_Whitespace();
    public virtual int CompareDocument(string baseUri, string nextBaseUri);
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
}
[XmlSchemaProviderAttribute("StaticGetSchema")]
[XmlRootAttribute]
public class System.ServiceModel.Dispatcher.XPathMessageFilter : MessageFilter {
    internal static string NodeQuotaAttr;
    internal static string XPathDialect;
    internal XmlNamespaceManager namespaces;
    public XmlNamespaceManager Namespaces { get; }
    public int NodeQuota { get; public set; }
    public string XPath { get; }
    public XPathMessageFilter(string xpath);
    public XPathMessageFilter(string xpath, XmlNamespaceManager namespaces);
    public XPathMessageFilter(string xpath, XsltContext context);
    public XPathMessageFilter(XmlReader reader);
    public XPathMessageFilter(XmlReader reader, XmlNamespaceManager namespaces);
    public XPathMessageFilter(XmlReader reader, XsltContext context);
    private static XPathMessageFilter();
    public static XmlSchemaType StaticGetSchema(XmlSchemaSet schemas);
    public XmlNamespaceManager get_Namespaces();
    public int get_NodeQuota();
    public void set_NodeQuota(int value);
    public string get_XPath();
    internal void Compile(bool internalEngine);
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    protected virtual XmlSchema OnGetSchema();
    public virtual bool Match(Message message);
    public virtual bool Match(MessageBuffer messageBuffer);
    public bool Match(XPathNavigator navigator);
    public bool Match(SeekableXPathNavigator navigator);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    protected virtual void OnReadXml(XmlReader reader);
    protected void ReadXPath(XmlReader reader, XmlNamespaceManager namespaces);
    public void TrimToSize();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    protected virtual void OnWriteXml(XmlWriter writer);
    protected void WriteXPath(XmlWriter writer, IXmlNamespaceResolver resolver);
    public void WriteXPathTo(XmlWriter writer, string prefix, string localName, string ns, bool writeNamespaces);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class System.ServiceModel.Dispatcher.XPathMessageFilterTable`1 : object {
    internal Dictionary`2<MessageFilter, TFilterData> filters;
    public TFilterData Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<MessageFilter> Keys { get; }
    [DataMemberAttribute]
public int NodeQuota { get; public set; }
    public ICollection`1<TFilterData> Values { get; }
    public XPathMessageFilterTable`1(int capacity);
    public sealed virtual TFilterData get_Item(MessageFilter filter);
    public sealed virtual void set_Item(MessageFilter filter, TFilterData value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<MessageFilter> get_Keys();
    public int get_NodeQuota();
    public void set_NodeQuota(int value);
    public sealed virtual ICollection`1<TFilterData> get_Values();
    public sealed virtual void Add(MessageFilter filter, TFilterData data);
    public sealed virtual void Add(KeyValuePair`2<MessageFilter, TFilterData> item);
    public void Add(XPathMessageFilter filter, TFilterData data);
    internal void Add(XPathMessageFilter filter, TFilterData data, bool forceExternal);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<MessageFilter, TFilterData> item);
    public sealed virtual bool ContainsKey(MessageFilter filter);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<MessageFilter, TFilterData>> GetEnumerator();
    public sealed virtual bool GetMatchingValue(Message message, TFilterData& data);
    public sealed virtual bool GetMatchingValue(MessageBuffer messageBuffer, TFilterData& data);
    public bool GetMatchingValue(SeekableXPathNavigator navigator, TFilterData& data);
    public bool GetMatchingValue(XPathNavigator navigator, TFilterData& data);
    public sealed virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public bool GetMatchingFilter(SeekableXPathNavigator navigator, MessageFilter& filter);
    public bool GetMatchingFilter(XPathNavigator navigator, MessageFilter& filter);
    public sealed virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
    public bool GetMatchingFilters(SeekableXPathNavigator navigator, ICollection`1<MessageFilter> results);
    public bool GetMatchingFilters(XPathNavigator navigator, ICollection`1<MessageFilter> results);
    public sealed virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public sealed virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<TFilterData> results);
    public bool GetMatchingValues(SeekableXPathNavigator navigator, ICollection`1<TFilterData> results);
    public bool GetMatchingValues(XPathNavigator navigator, ICollection`1<TFilterData> results);
    public sealed virtual bool Remove(MessageFilter filter);
    public sealed virtual bool Remove(KeyValuePair`2<MessageFilter, TFilterData> item);
    public bool Remove(XPathMessageFilter filter);
    public void TrimToSize();
    public sealed virtual bool TryGetValue(MessageFilter filter, TFilterData& data);
}
internal abstract class System.ServiceModel.Dispatcher.XPathMessageFunction : object {
    internal static DateTime ZeroDate;
    internal static XmlNamespaceManager Namespaces;
    public XPathResultType[] ArgTypes { get; }
    public int Maxargs { get; }
    public int Minargs { get; }
    public XPathResultType ReturnType { get; }
    private static XPathMessageFunction();
    protected XPathMessageFunction(XPathResultType[] argTypes, int max, int min, XPathResultType retType);
    public sealed virtual XPathResultType[] get_ArgTypes();
    public sealed virtual int get_Maxargs();
    public sealed virtual int get_Minargs();
    public sealed virtual XPathResultType get_ReturnType();
    public abstract virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal abstract virtual void InvokeInternal(ProcessingContext context, int argCount);
    internal static bool MoveToAddressingHeader(XPathNavigator nav, string name);
    internal static bool MoveToChild(XPathNavigator nav, string name, string ns);
    internal static bool MoveToAddressingHeaderSibling(XPathNavigator nav, string name);
    internal static bool MoveToSibling(XPathNavigator nav, string name, string ns);
    internal static bool MoveToHeader(XPathNavigator nav);
    internal static bool MoveToBody(XPathNavigator nav);
    internal static string ToString(object o);
    internal static double ConvertDate(DateTime date);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionAction : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static string ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionActor : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static string ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionBody : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionCallOpcode : Opcode {
    internal XPathResultType ReturnType { get; }
    internal int ArgCount { get; }
    internal XPathMessageFunctionCallOpcode(XPathMessageFunction fun, int argCount);
    internal XPathResultType get_ReturnType();
    internal int get_ArgCount();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionCorrelationData : XPathMessageFunction {
    private static XPathMessageFunctionCorrelationData();
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionDateNow : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionDateStr : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static double Convert(string dateStr);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionFaultTo : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionFrom : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionHeader : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionHeadersWithActor : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionIsActorNext : XPathMessageFunction {
    private static XPathMessageFunctionIsActorNext();
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator nav);
    internal static bool ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionIsActorUltimateReceiver : XPathMessageFunction {
    private static XPathMessageFunctionIsActorUltimateReceiver();
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator nav);
    internal static bool ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionIsMandatory : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static bool ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionMessageID : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionRelatesTo : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionReplyTo : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionSoapUri : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static string ExtractFromNavigator(XPathNavigator nav);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionSpanStr : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
    internal static double Convert(string spanStr);
}
internal class System.ServiceModel.Dispatcher.XPathMessageFunctionTo : XPathMessageFunction {
    internal virtual void InvokeInternal(ProcessingContext context, int argCount);
    public virtual object Invoke(XsltContext xsltContext, Object[] args, XPathNavigator docContext);
}
public class System.ServiceModel.Dispatcher.XPathMessageQueryCollection : MessageQueryCollection {
    public virtual IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(Message message);
    public virtual IEnumerable`1<KeyValuePair`2<MessageQuery, TResult>> Evaluate(MessageBuffer buffer);
    protected virtual void InsertItem(int index, MessageQuery item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, MessageQuery item);
}
[KnownTypeAttribute("System.String[]")]
public class System.ServiceModel.Dispatcher.XPathNavigatorException : XPathException {
    protected XPathNavigatorException(SerializationInfo info, StreamingContext context);
    public XPathNavigatorException(string message);
    public XPathNavigatorException(string message, Exception innerException);
    internal MessageFilterException Process(Opcode op);
}
internal class System.ServiceModel.Dispatcher.XPathNumberExpr : XPathLiteralExpr {
    internal object Literal { get; }
    internal double Number { get; }
    internal XPathNumberExpr(double literal);
    internal virtual object get_Literal();
    internal double get_Number();
}
internal class System.ServiceModel.Dispatcher.XPathParser : object {
    internal XPathParser(string xpath, XmlNamespaceManager namespaces, IFunctionLibrary[] functionLibraries);
    internal XPathExpr Parse();
    internal XPathExpr ParseLocationPath();
    internal XPathExpr ParseUnionExpression();
    internal XPathExpr ParseVariableExpression();
    internal void ThrowError(QueryCompileError error);
}
internal class System.ServiceModel.Dispatcher.XPathQueryMatcher : QueryMatcher {
    internal bool IsAlwaysMatch { get; }
    internal bool IsFxFilter { get; }
    private static XPathQueryMatcher();
    internal XPathQueryMatcher(bool match);
    internal bool get_IsAlwaysMatch();
    internal bool get_IsFxFilter();
    internal void Compile(string expression, XmlNamespaceManager namespaces);
    internal void CompileForExternal(string xpath, XmlNamespaceManager names);
    internal void CompileForInternal(string xpath, XmlNamespaceManager names);
    internal FilterResult Match(MessageBuffer messageBuffer);
    internal FilterResult Match(Message message, bool matchBody);
    internal FilterResult Match(SeekableXPathNavigator navigator);
    internal FilterResult Match(XPathNavigator navigator);
    internal bool MatchFx(XPathNavigator navigator);
}
internal class System.ServiceModel.Dispatcher.XPathRelationExpr : XPathConjunctExpr {
    internal RelationOperator Op { get; internal set; }
    internal XPathRelationExpr(RelationOperator op, XPathExpr left, XPathExpr right);
    internal RelationOperator get_Op();
    internal void set_Op(RelationOperator value);
}
public class System.ServiceModel.Dispatcher.XPathResult : object {
    public XPathResultType ResultType { get; }
    internal XPathResult(XPathNodeIterator nodeSetResult);
    internal XPathResult(string stringResult);
    internal XPathResult(bool boolResult);
    internal XPathResult(double numberResult);
    public XPathResultType get_ResultType();
    public sealed virtual void Dispose();
    public bool GetResultAsBoolean();
    public XPathNodeIterator GetResultAsNodeset();
    public double GetResultAsNumber();
    public string GetResultAsString();
    internal XPathResult Copy();
}
internal class System.ServiceModel.Dispatcher.XPathStepExpr : XPathExpr {
    internal NodeSelectCriteria SelectDesc { get; }
    internal XPathStepExpr(NodeSelectCriteria desc);
    internal XPathStepExpr(NodeSelectCriteria desc, XPathExprList predicates);
    internal NodeSelectCriteria get_SelectDesc();
}
internal class System.ServiceModel.Dispatcher.XPathStringExpr : XPathLiteralExpr {
    internal object Literal { get; }
    internal string String { get; }
    internal XPathStringExpr(string literal);
    internal virtual object get_Literal();
    internal string get_String();
}
internal class System.ServiceModel.Dispatcher.XPathToken : object {
    internal string Name { get; }
    internal double Number { get; }
    internal string Prefix { get; }
    internal XPathTokenID TokenID { get; }
    internal string get_Name();
    internal double get_Number();
    internal string get_Prefix();
    internal XPathTokenID get_TokenID();
    internal void Clear();
    internal void Set(XPathTokenID id);
    internal void Set(XPathTokenID id, double number);
    internal void Set(XPathTokenID id, string name);
    internal void Set(XPathTokenID id, QName qname);
}
internal enum System.ServiceModel.Dispatcher.XPathTokenID : Enum {
    public int value__;
    public static XPathTokenID Unknown;
    public static XPathTokenID Terminal;
    public static XPathTokenID NameTest;
    public static XPathTokenID NodeType;
    public static XPathTokenID Operator;
    public static XPathTokenID NamedOperator;
    public static XPathTokenID Function;
    public static XPathTokenID Axis;
    public static XPathTokenID Literal;
    public static XPathTokenID Number;
    public static XPathTokenID Variable;
    public static XPathTokenID TypeMask;
    public static XPathTokenID LParen;
    public static XPathTokenID RParen;
    public static XPathTokenID LBracket;
    public static XPathTokenID RBracket;
    public static XPathTokenID Period;
    public static XPathTokenID DblPeriod;
    public static XPathTokenID AtSign;
    public static XPathTokenID Comma;
    public static XPathTokenID DblColon;
    public static XPathTokenID Whitespace;
    public static XPathTokenID Eq;
    public static XPathTokenID Neq;
    public static XPathTokenID Gt;
    public static XPathTokenID Gte;
    public static XPathTokenID Lt;
    public static XPathTokenID Lte;
    public static XPathTokenID Plus;
    public static XPathTokenID Minus;
    public static XPathTokenID Slash;
    public static XPathTokenID Multiply;
    public static XPathTokenID Pipe;
    public static XPathTokenID DblSlash;
    public static XPathTokenID Mod;
    public static XPathTokenID And;
    public static XPathTokenID Or;
    public static XPathTokenID Div;
    public static XPathTokenID Integer;
    public static XPathTokenID Decimal;
    public static XPathTokenID String;
    public static XPathTokenID Comment;
    public static XPathTokenID Text;
    public static XPathTokenID Processing;
    public static XPathTokenID Node;
    public static XPathTokenID Wildcard;
    public static XPathTokenID NameWildcard;
    public static XPathTokenID Ancestor;
    public static XPathTokenID AncestorOrSelf;
    public static XPathTokenID Attribute;
    public static XPathTokenID Child;
    public static XPathTokenID Descendant;
    public static XPathTokenID DescendantOrSelf;
    public static XPathTokenID Following;
    public static XPathTokenID FollowingSibling;
    public static XPathTokenID Namespace;
    public static XPathTokenID Parent;
    public static XPathTokenID Preceding;
    public static XPathTokenID PrecedingSibling;
    public static XPathTokenID Self;
}
internal class System.ServiceModel.Dispatcher.XPathXsltFunctionExpr : XPathExpr {
    internal XsltContext Context { get; }
    internal IXsltContextFunction Function { get; }
    internal XPathXsltFunctionExpr(XsltContext context, IXsltContextFunction function, XPathExprList subExpr);
    internal XsltContext get_Context();
    internal IXsltContextFunction get_Function();
    internal static XPathResultType ConvertTypeToXslt(ValueDataType type);
    internal static ValueDataType ConvertTypeFromXslt(XPathResultType type);
}
internal class System.ServiceModel.Dispatcher.XPathXsltVariableExpr : XPathExpr {
    internal XsltContext Context { get; }
    internal IXsltContextVariable Variable { get; }
    internal XPathXsltVariableExpr(XsltContext context, IXsltContextVariable variable);
    internal XsltContext get_Context();
    internal IXsltContextVariable get_Variable();
}
internal class System.ServiceModel.Dispatcher.XsltFunctionCallOpcode : Opcode {
    internal XsltFunctionCallOpcode(XsltContext context, IXsltContextFunction function, int argCount);
    private static XsltFunctionCallOpcode();
    internal virtual bool Equals(Opcode op);
    internal virtual Opcode Eval(ProcessingContext context);
}
public class System.ServiceModel.DnsEndpointIdentity : EndpointIdentity {
    public DnsEndpointIdentity(string dnsName);
    public DnsEndpointIdentity(Claim identity);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.DotNetAddressingDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString RedirectTo;
    public XmlDictionaryString Via;
    public DotNetAddressingDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.DotNetAddressingStrings : object {
    public static string Namespace;
    public static string RedirectTo;
    public static string Via;
}
internal class System.ServiceModel.DotNetAtomicTransactionExternalDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString Enlistment;
    public XmlDictionaryString Protocol;
    public XmlDictionaryString LocalTransactionId;
    public XmlDictionaryString IsolationLevel;
    public XmlDictionaryString IsolationFlags;
    public XmlDictionaryString Description;
    public XmlDictionaryString Loopback;
    public XmlDictionaryString RegisterInfo;
    public XmlDictionaryString ContextId;
    public XmlDictionaryString TokenId;
    public XmlDictionaryString AccessDenied;
    public XmlDictionaryString InvalidPolicy;
    public XmlDictionaryString CoordinatorRegistrationFailed;
    public XmlDictionaryString TooManyEnlistments;
    public XmlDictionaryString Disabled;
    public DotNetAtomicTransactionExternalDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.DotNetAtomicTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string Enlistment;
    public static string Protocol;
    public static string LocalTransactionId;
    public static string IsolationLevel;
    public static string IsolationFlags;
    public static string Description;
    public static string Loopback;
    public static string RegisterInfo;
    public static string ContextId;
    public static string TokenId;
    public static string AccessDenied;
    public static string InvalidPolicy;
    public static string CoordinatorRegistrationFailed;
    public static string TooManyEnlistments;
    public static string Disabled;
}
internal class System.ServiceModel.DotNetOneWayDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString HeaderName;
    public DotNetOneWayDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.DotNetOneWayStrings : object {
    public static string Namespace;
    public static string HeaderName;
}
internal class System.ServiceModel.DotNetSecurityDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public DotNetSecurityDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.DotNetSecurityStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string KeyRenewalNeededFault;
    public static string SecuritySessionAbortedFault;
    public static string SecurityServerTooBusyFault;
    public static string SecuritySessionFaultAction;
    public static string SecureConversationCancelNotAllowedFault;
}
public class System.ServiceModel.DuplexChannelFactory`1 : ChannelFactory`1<TChannel> {
    public DuplexChannelFactory`1(Type callbackInstanceType);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding);
    public DuplexChannelFactory`1(Type callbackInstanceType, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, string endpointConfigurationName);
    public DuplexChannelFactory`1(Type callbackInstanceType, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(InstanceContext callbackInstance);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, string endpointConfigurationName);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(object callbackObject);
    public DuplexChannelFactory`1(object callbackObject, string endpointConfigurationName);
    public DuplexChannelFactory`1(object callbackObject, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, Binding binding);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, ServiceEndpoint endpoint);
    internal void CheckAndAssignCallbackInstance(object callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public virtual TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address, Uri via);
    public static TChannel CreateChannel(object callbackObject, string endpointConfigurationName);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress, Uri via);
    public static TChannel CreateChannel(InstanceContext callbackInstance, string endpointConfigurationName);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress, Uri via);
}
public abstract class System.ServiceModel.DuplexClientBase`1 : ClientBase`1<TChannel> {
    public IDuplexContextChannel InnerDuplexChannel { get; }
    protected DuplexClientBase`1(object callbackInstance);
    protected DuplexClientBase`1(object callbackInstance, string endpointConfigurationName);
    protected DuplexClientBase`1(object callbackInstance, string endpointConfigurationName, string remoteAddress);
    protected DuplexClientBase`1(object callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    protected DuplexClientBase`1(object callbackInstance, Binding binding, EndpointAddress remoteAddress);
    protected DuplexClientBase`1(object callbackInstance, ServiceEndpoint endpoint);
    protected DuplexClientBase`1(InstanceContext callbackInstance);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, string remoteAddress);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    protected DuplexClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    protected DuplexClientBase`1(InstanceContext callbackInstance, ServiceEndpoint endpoint);
    public IDuplexContextChannel get_InnerDuplexChannel();
}
internal static class System.ServiceModel.DXD : object {
    public static AtomicTransactionExternal11Dictionary AtomicTransactionExternal11Dictionary { get; }
    public static CoordinationExternal11Dictionary CoordinationExternal11Dictionary { get; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; }
    public static Wsrm11Dictionary Wsrm11Dictionary { get; }
    private static DXD();
    public static AtomicTransactionExternal11Dictionary get_AtomicTransactionExternal11Dictionary();
    public static CoordinationExternal11Dictionary get_CoordinationExternal11Dictionary();
    public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public static Wsrm11Dictionary get_Wsrm11Dictionary();
}
internal class System.ServiceModel.EmptyArray : object {
    internal static Object[] Instance { get; }
    private static EmptyArray();
    internal static Object[] get_Instance();
    internal static Object[] Allocate(int n);
}
internal class System.ServiceModel.EmptyArray`1 : object {
    internal static T[] Instance { get; }
    internal static T[] get_Instance();
    internal static T[] Allocate(int n);
    internal static T[] ToArray(IList`1<T> collection);
    internal static T[] ToArray(SynchronizedCollection`1<T> collection);
}
public class System.ServiceModel.EndpointAddress : object {
    internal static string DummyName;
    internal static string DummyNamespace;
    internal static EndpointAddress AnonymousAddress { get; }
    public static Uri AnonymousUri { get; }
    public static Uri NoneUri { get; }
    internal XmlBuffer Buffer { get; }
    public AddressHeaderCollection Headers { get; }
    public EndpointIdentity Identity { get; }
    public bool IsAnonymous { get; }
    public bool IsNone { get; }
    [TypeConverterAttribute("System.UriTypeConverter")]
public Uri Uri { get; }
    public EndpointAddress(string uri);
    public EndpointAddress(Uri uri, AddressHeader[] addressHeaders);
    public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeader[] addressHeaders);
    public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers);
    internal EndpointAddress(Uri newUri, EndpointAddress oldEndpointAddress);
    internal EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlDictionaryReader metadataReader, XmlDictionaryReader extensionReader, XmlDictionaryReader pspReader);
    public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlDictionaryReader metadataReader, XmlDictionaryReader extensionReader);
    internal static EndpointAddress get_AnonymousAddress();
    public static Uri get_AnonymousUri();
    public static Uri get_NoneUri();
    internal XmlBuffer get_Buffer();
    public AddressHeaderCollection get_Headers();
    public EndpointIdentity get_Identity();
    public bool get_IsAnonymous();
    public bool get_IsNone();
    public Uri get_Uri();
    public void ApplyTo(Message message);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison, bool includePortInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison, bool includePortInComparison);
    internal bool EndpointEquals(EndpointAddress endpointAddress);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal XmlDictionaryReader GetReaderAtPsp();
    public XmlDictionaryReader GetReaderAtMetadata();
    public XmlDictionaryReader GetReaderAtExtensions();
    public static EndpointAddress ReadFrom(XmlDictionaryReader reader);
    internal static EndpointAddress ReadFrom(XmlDictionaryReader reader, AddressingVersion& version);
    public static EndpointAddress ReadFrom(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    internal static EndpointAddress ReadFrom(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns, AddressingVersion& version);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlReader reader);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlReader reader, string localName, string ns);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    internal static XmlBuffer ReadExtensions(XmlDictionaryReader reader, AddressingVersion version, XmlBuffer buffer, EndpointIdentity& identity, Int32& section);
    internal static void Copy(XmlDictionaryWriter writer, XmlDictionaryReader reader);
    public virtual string ToString();
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer, string localName, string ns);
    public static bool op_Equality(EndpointAddress address1, EndpointAddress address2);
    public static bool op_Inequality(EndpointAddress address1, EndpointAddress address2);
}
[XmlSchemaProviderAttribute("GetSchema")]
[XmlRootAttribute("EndpointReference")]
public class System.ServiceModel.EndpointAddress10 : object {
    public static EndpointAddress10 FromEndpointAddress(EndpointAddress address);
    public EndpointAddress ToEndpointAddress();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public static XmlQualifiedName GetSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
}
[XmlSchemaProviderAttribute("GetSchema")]
[XmlRootAttribute("EndpointReference")]
public class System.ServiceModel.EndpointAddressAugust2004 : object {
    public static EndpointAddressAugust2004 FromEndpointAddress(EndpointAddress address);
    public EndpointAddress ToEndpointAddress();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public static XmlQualifiedName GetSchema(XmlSchemaSet xmlSchemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
}
public class System.ServiceModel.EndpointAddressBuilder : object {
    public Uri Uri { get; public set; }
    public EndpointIdentity Identity { get; public set; }
    public Collection`1<AddressHeader> Headers { get; }
    public EndpointAddressBuilder(EndpointAddress address);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    public EndpointIdentity get_Identity();
    public void set_Identity(EndpointIdentity value);
    public Collection`1<AddressHeader> get_Headers();
    public XmlDictionaryReader GetReaderAtMetadata();
    public void SetMetadataReader(XmlDictionaryReader reader);
    public XmlDictionaryReader GetReaderAtExtensions();
    public void SetExtensionReader(XmlDictionaryReader reader);
    public EndpointAddress ToEndpointAddress();
}
public abstract class System.ServiceModel.EndpointIdentity : object {
    internal static StoreLocation defaultStoreLocation;
    internal static StoreName defaultStoreName;
    internal static X509FindType defaultX509FindType;
    public Claim IdentityClaim { get; }
    protected void Initialize(Claim identityClaim);
    protected void Initialize(Claim identityClaim, IEqualityComparer`1<Claim> claimComparer);
    public Claim get_IdentityClaim();
    public static EndpointIdentity CreateIdentity(Claim identity);
    public static EndpointIdentity CreateDnsIdentity(string dnsName);
    public static EndpointIdentity CreateSpnIdentity(string spnName);
    public static EndpointIdentity CreateUpnIdentity(string upnName);
    public static EndpointIdentity CreateRsaIdentity(string publicKey);
    public static EndpointIdentity CreateRsaIdentity(X509Certificate2 certificate);
    public static EndpointIdentity CreateX509CertificateIdentity(X509Certificate2 certificate);
    public static EndpointIdentity CreateX509CertificateIdentity(X509Certificate2 primaryCertificate, X509Certificate2Collection supportingCertificates);
    internal static EndpointIdentity CreateX509CertificateIdentity(X509Chain certificateChain);
    internal virtual void EnsureIdentityClaim();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool Matches(Claim claim);
    internal static EndpointIdentity ReadIdentity(XmlDictionaryReader reader);
    internal void WriteTo(XmlDictionaryWriter writer);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
public class System.ServiceModel.EndpointNotFoundException : CommunicationException {
    public EndpointNotFoundException(string message);
    public EndpointNotFoundException(string message, Exception innerException);
    protected EndpointNotFoundException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.ServiceModel.EndpointTrait`1 : object {
    public abstract virtual ChannelFactory`1<TChannel> CreateChannelFactory();
}
public class System.ServiceModel.EnvelopeVersion : object {
    internal string Actor { get; }
    internal XmlDictionaryString DictionaryActor { get; }
    internal string Namespace { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    public string NextDestinationActorValue { get; }
    public static EnvelopeVersion None { get; }
    public static EnvelopeVersion Soap11 { get; }
    public static EnvelopeVersion Soap12 { get; }
    internal string ReceiverFaultName { get; }
    internal string SenderFaultName { get; }
    internal String[] MustUnderstandActorValues { get; }
    internal string UltimateDestinationActor { get; }
    internal String[] UltimateDestinationActorValues { get; }
    private static EnvelopeVersion();
    internal string get_Actor();
    internal XmlDictionaryString get_DictionaryActor();
    internal string get_Namespace();
    internal XmlDictionaryString get_DictionaryNamespace();
    public string get_NextDestinationActorValue();
    public static EnvelopeVersion get_None();
    public static EnvelopeVersion get_Soap11();
    public static EnvelopeVersion get_Soap12();
    internal string get_ReceiverFaultName();
    internal string get_SenderFaultName();
    internal String[] get_MustUnderstandActorValues();
    internal string get_UltimateDestinationActor();
    public String[] GetUltimateDestinationActorValues();
    internal String[] get_UltimateDestinationActorValues();
    internal bool IsUltimateDestinationActor(string actor);
    public virtual string ToString();
}
[DataContractAttribute]
public class System.ServiceModel.ExceptionDetail : object {
    [DataMemberAttribute]
public string HelpLink { get; public set; }
    [DataMemberAttribute]
public ExceptionDetail InnerException { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string StackTrace { get; public set; }
    [DataMemberAttribute]
public string Type { get; public set; }
    public ExceptionDetail(Exception exception);
    public string get_HelpLink();
    public void set_HelpLink(string value);
    public ExceptionDetail get_InnerException();
    public void set_InnerException(ExceptionDetail value);
    public string get_Message();
    public void set_Message(string value);
    public string get_StackTrace();
    public void set_StackTrace(string value);
    public string get_Type();
    public void set_Type(string value);
    public virtual string ToString();
}
public class System.ServiceModel.ExceptionMapper : object {
    internal static string SoapSenderFaultCode;
    public virtual FaultException FromException(Exception ex);
    public virtual FaultException FromException(Exception ex, string soapNamespace, string trustNamespace);
    public virtual bool HandleSecurityTokenProcessingException(Exception ex);
}
internal class System.ServiceModel.ExclusiveC14NDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString PrefixList;
    public XmlDictionaryString InclusiveNamespaces;
    public XmlDictionaryString Prefix;
    public ExclusiveC14NDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
public class System.ServiceModel.ExtensionCollection`1 : SynchronizedCollection`1<IExtension`1<T>> {
    private bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.IsReadOnly { get; }
    public ExtensionCollection`1(T owner);
    public ExtensionCollection`1(T owner, object syncRoot);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.get_IsReadOnly();
    protected virtual void ClearItems();
    public sealed virtual E Find();
    public sealed virtual Collection`1<E> FindAll();
    protected virtual void InsertItem(int index, IExtension`1<T> item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, IExtension`1<T> item);
}
public class System.ServiceModel.FaultCode : object {
    public bool IsPredefinedFault { get; }
    public bool IsSenderFault { get; }
    public bool IsReceiverFault { get; }
    public string Namespace { get; }
    public string Name { get; }
    public FaultCode SubCode { get; }
    public FaultCode(string name);
    public FaultCode(string name, FaultCode subCode);
    public FaultCode(string name, string ns);
    public FaultCode(string name, string ns, FaultCode subCode);
    public bool get_IsPredefinedFault();
    public bool get_IsSenderFault();
    public bool get_IsReceiverFault();
    public string get_Namespace();
    public string get_Name();
    public FaultCode get_SubCode();
    public static FaultCode CreateSenderFaultCode(FaultCode subCode);
    public static FaultCode CreateSenderFaultCode(string name, string ns);
    public static FaultCode CreateReceiverFaultCode(FaultCode subCode);
    public static FaultCode CreateReceiverFaultCode(string name, string ns);
}
internal class System.ServiceModel.FaultCodeConstants : object {
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.FaultContractAttribute : Attribute {
    internal static string ProtectionLevelPropertyName;
    public Type DetailType { get; }
    public string Action { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public FaultContractAttribute(Type detailType);
    public Type get_DetailType();
    public string get_Action();
    public void set_Action(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
}
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData[]")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData[]")]
public class System.ServiceModel.FaultException : CommunicationException {
    internal static string Namespace;
    public string Action { get; }
    public FaultCode Code { get; }
    public string Message { get; }
    public FaultReason Reason { get; }
    internal MessageFault Fault { get; }
    public FaultException(string reason);
    public FaultException(FaultReason reason);
    public FaultException(string reason, FaultCode code);
    public FaultException(FaultReason reason, FaultCode code);
    public FaultException(string reason, FaultCode code, string action);
    internal FaultException(string reason, FaultCode code, string action, Exception innerException);
    public FaultException(FaultReason reason, FaultCode code, string action);
    internal FaultException(FaultReason reason, FaultCode code, string action, Exception innerException);
    public FaultException(MessageFault fault);
    public FaultException(MessageFault fault, string action);
    protected FaultException(SerializationInfo info, StreamingContext context);
    public string get_Action();
    public FaultCode get_Code();
    public virtual string get_Message();
    public FaultReason get_Reason();
    internal MessageFault get_Fault();
    internal void AddFaultCodeObjectData(SerializationInfo info, string key, FaultCode code);
    internal void AddFaultReasonObjectData(SerializationInfo info, string key, FaultReason reason);
    public static FaultException CreateFault(MessageFault messageFault, Type[] faultDetailTypes);
    public static FaultException CreateFault(MessageFault messageFault, string action, Type[] faultDetailTypes);
    public virtual MessageFault CreateMessageFault();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static string GetSafeReasonText(MessageFault messageFault);
    internal static string GetSafeReasonText(FaultReason reason);
    internal FaultCode ReconstructFaultCode(SerializationInfo info, string key);
    internal FaultReason ReconstructFaultReason(SerializationInfo info, string key);
}
public class System.ServiceModel.FaultException`1 : FaultException {
    public TDetail Detail { get; }
    public FaultException`1(TDetail detail);
    public FaultException`1(TDetail detail, string reason);
    public FaultException`1(TDetail detail, FaultReason reason);
    public FaultException`1(TDetail detail, string reason, FaultCode code);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code);
    public FaultException`1(TDetail detail, string reason, FaultCode code, string action);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code, string action);
    protected FaultException`1(SerializationInfo info, StreamingContext context);
    public TDetail get_Detail();
    public virtual MessageFault CreateMessageFault();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.ServiceModel.FaultImportOptions : object {
    public bool UseMessageFormat { get; public set; }
    public bool get_UseMessageFormat();
    public void set_UseMessageFormat(bool value);
}
public class System.ServiceModel.FaultReason : object {
    public SynchronizedReadOnlyCollection`1<FaultReasonText> Translations { get; }
    public FaultReason(FaultReasonText translation);
    public FaultReason(string text);
    internal FaultReason(string text, string xmlLang);
    internal FaultReason(string text, CultureInfo cultureInfo);
    public FaultReason(IEnumerable`1<FaultReasonText> translations);
    public FaultReasonText GetMatchingTranslation();
    public FaultReasonText GetMatchingTranslation(CultureInfo cultureInfo);
    public SynchronizedReadOnlyCollection`1<FaultReasonText> get_Translations();
    public virtual string ToString();
}
public class System.ServiceModel.FaultReasonText : object {
    public string XmlLang { get; }
    public string Text { get; }
    public FaultReasonText(string text);
    public FaultReasonText(string text, string xmlLang);
    public FaultReasonText(string text, CultureInfo cultureInfo);
    public bool Matches(CultureInfo cultureInfo);
    public string get_XmlLang();
    public string get_Text();
}
public class System.ServiceModel.FederatedMessageSecurityOverHttp : object {
    internal static bool DefaultNegotiateServiceCredential;
    internal static SecurityKeyType DefaultIssuedKeyType;
    internal static bool DefaultEstablishSecurityContext;
    public bool NegotiateServiceCredential { get; public set; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    public bool EstablishSecurityContext { get; public set; }
    [DefaultValueAttribute("")]
public EndpointAddress IssuerAddress { get; public set; }
    [DefaultValueAttribute("")]
public EndpointAddress IssuerMetadataAddress { get; public set; }
    [DefaultValueAttribute("")]
public Binding IssuerBinding { get; public set; }
    [DefaultValueAttribute("")]
public string IssuedTokenType { get; public set; }
    public SecurityKeyType IssuedKeyType { get; public set; }
    public Collection`1<ClaimTypeRequirement> ClaimTypeRequirements { get; }
    public Collection`1<XmlElement> TokenRequestParameters { get; }
    public bool get_NegotiateServiceCredential();
    public void set_NegotiateServiceCredential(bool value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    public bool get_EstablishSecurityContext();
    public void set_EstablishSecurityContext(bool value);
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public EndpointAddress get_IssuerMetadataAddress();
    public void set_IssuerMetadataAddress(EndpointAddress value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public string get_IssuedTokenType();
    public void set_IssuedTokenType(string value);
    public SecurityKeyType get_IssuedKeyType();
    public void set_IssuedKeyType(SecurityKeyType value);
    public Collection`1<ClaimTypeRequirement> get_ClaimTypeRequirements();
    public Collection`1<XmlElement> get_TokenRequestParameters();
    internal SecurityBindingElement CreateSecurityBindingElement(bool isSecureTransportMode, bool isReliableSession, MessageSecurityVersion version);
    internal static bool TryCreate(SecurityBindingElement sbe, bool isSecureTransportMode, bool isReliableSession, MessageSecurityVersion version, FederatedMessageSecurityOverHttp& messageSecurity);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAlgorithmSuite();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeClaimTypeRequirements();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeNegotiateServiceCredential();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeEstablishSecurityContext();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeIssuedKeyType();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTokenRequestParameters();
}
internal static class System.ServiceModel.FxTrace : object {
    public static bool ShouldTraceCritical { get; }
    public static bool TracingEnabled { get; }
    public static bool ShouldTraceError { get; }
    public static bool ShouldTraceInformation { get; }
    public static bool ShouldTraceVerbose { get; }
    public static bool ShouldTraceWarning { get; }
    public static bool ShouldTraceCriticalToTraceSource { get; }
    public static bool ShouldTraceErrorToTraceSource { get; }
    public static bool ShouldTraceInformationToTraceSource { get; }
    public static bool ShouldTraceVerboseToTraceSource { get; }
    public static bool ShouldTraceWarningToTraceSource { get; }
    public static ExceptionTrace Exception { get; }
    public static EtwDiagnosticTrace Trace { get; }
    public static EventLogger EventLog { get; }
    private static FxTrace();
    [SecuritySafeCriticalAttribute]
public static void UpdateEventDefinitions(EventDescriptor[] eventDescriptors, UInt16[] end2EndEvents);
    public static bool IsEventEnabled(int index);
    public static bool get_ShouldTraceCritical();
    public static bool get_TracingEnabled();
    public static bool get_ShouldTraceError();
    public static bool get_ShouldTraceInformation();
    public static bool get_ShouldTraceVerbose();
    public static bool get_ShouldTraceWarning();
    public static bool get_ShouldTraceCriticalToTraceSource();
    public static bool get_ShouldTraceErrorToTraceSource();
    public static bool get_ShouldTraceInformationToTraceSource();
    public static bool get_ShouldTraceVerboseToTraceSource();
    public static bool get_ShouldTraceWarningToTraceSource();
    public static ExceptionTrace get_Exception();
    public static EtwDiagnosticTrace get_Trace();
    public static EventLogger get_EventLog();
}
internal class System.ServiceModel.GeneralEndpointIdentity : EndpointIdentity {
    public GeneralEndpointIdentity(Claim identityClaim);
}
public enum System.ServiceModel.HostNameComparisonMode : Enum {
    public int value__;
    public static HostNameComparisonMode StrongWildcard;
    public static HostNameComparisonMode Exact;
    public static HostNameComparisonMode WeakWildcard;
}
internal static class System.ServiceModel.HostNameComparisonModeHelper : object {
    internal static bool IsDefined(HostNameComparisonMode value);
    public static void Validate(HostNameComparisonMode value);
}
public abstract class System.ServiceModel.HttpBindingBase : Binding {
    [DefaultValueAttribute("False")]
public bool AllowCookies { get; public set; }
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri ProxyAddress { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    [TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    internal TextMessageEncodingBindingElement TextMessageEncodingBindingElement { get; }
    internal MtomMessageEncodingBindingElement MtomMessageEncodingBindingElement { get; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    internal WebSocketTransportSettings InternalWebSocketSettings { get; }
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    internal TextMessageEncodingBindingElement get_TextMessageEncodingBindingElement();
    internal MtomMessageEncodingBindingElement get_MtomMessageEncodingBindingElement();
    internal abstract virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal WebSocketTransportSettings get_InternalWebSocketSettings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTextEncoding();
    internal static bool GetSecurityModeFromTransport(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity, UnifiedSecurityMode& mode);
    internal static bool TryCreateSecurity(SecurityBindingElement securityElement, UnifiedSecurityMode mode, HttpTransportSecurity transportSecurity, BasicHttpSecurity& security);
    internal TransportBindingElement GetTransport();
    internal abstract virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual void InitializeFrom(HttpTransportBindingElement transport, MessageEncodingBindingElement encoding);
    internal virtual void CheckSettings();
}
public enum System.ServiceModel.HttpClientCredentialType : Enum {
    public int value__;
    public static HttpClientCredentialType None;
    public static HttpClientCredentialType Basic;
    public static HttpClientCredentialType Digest;
    public static HttpClientCredentialType Ntlm;
    public static HttpClientCredentialType Windows;
    public static HttpClientCredentialType Certificate;
    public static HttpClientCredentialType InheritedFromHost;
}
internal static class System.ServiceModel.HttpClientCredentialTypeHelper : object {
    internal static bool IsDefined(HttpClientCredentialType value);
    internal static AuthenticationSchemes MapToAuthenticationScheme(HttpClientCredentialType clientCredentialType);
    internal static HttpClientCredentialType MapToClientCredentialType(AuthenticationSchemes authenticationSchemes);
}
public enum System.ServiceModel.HttpProxyCredentialType : Enum {
    public int value__;
    public static HttpProxyCredentialType None;
    public static HttpProxyCredentialType Basic;
    public static HttpProxyCredentialType Digest;
    public static HttpProxyCredentialType Ntlm;
    public static HttpProxyCredentialType Windows;
}
internal static class System.ServiceModel.HttpProxyCredentialTypeHelper : object {
    internal static bool IsDefined(HttpProxyCredentialType value);
    internal static AuthenticationSchemes MapToAuthenticationScheme(HttpProxyCredentialType proxyCredentialType);
    internal static HttpProxyCredentialType MapToProxyCredentialType(AuthenticationSchemes authenticationSchemes);
}
public class System.ServiceModel.HttpTransportSecurity : object {
    internal static HttpClientCredentialType DefaultClientCredentialType;
    internal static HttpProxyCredentialType DefaultProxyCredentialType;
    internal static string DefaultRealm;
    public HttpClientCredentialType ClientCredentialType { get; public set; }
    public HttpProxyCredentialType ProxyCredentialType { get; public set; }
    public string Realm { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public HttpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(HttpClientCredentialType value);
    public HttpProxyCredentialType get_ProxyCredentialType();
    public void set_ProxyCredentialType(HttpProxyCredentialType value);
    public string get_Realm();
    public void set_Realm(string value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal void ConfigureTransportProtectionOnly(HttpsTransportBindingElement https);
    internal void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https);
    internal static void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal void ConfigureTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsConfiguredTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsDisabledTransportAuthentication(HttpTransportBindingElement http);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeClientCredentialType();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeProxyCredentialType();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeRealm();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeExtendedProtectionPolicy();
}
internal interface System.ServiceModel.IChannelBaseProxy {
    public abstract virtual ServiceChannel GetServiceChannel();
}
public interface System.ServiceModel.IClientChannel {
    public bool AllowInitializationUI { get; public set; }
    public bool DidInteractiveInitialization { get; }
    public Uri Via { get; }
    public abstract virtual bool get_AllowInitializationUI();
    public abstract virtual void set_AllowInitializationUI(bool value);
    public abstract virtual bool get_DidInteractiveInitialization();
    public abstract virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public abstract virtual void DisplayInitializationUI();
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
public interface System.ServiceModel.ICommunicationObject {
    public CommunicationState State { get; }
    public abstract virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opening(EventHandler value);
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void Open();
    public abstract virtual void Open(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOpen(IAsyncResult result);
}
public interface System.ServiceModel.IContextChannel {
    public bool AllowOutputBatching { get; public set; }
    public IInputSession InputSession { get; }
    public EndpointAddress LocalAddress { get; }
    public TimeSpan OperationTimeout { get; public set; }
    public IOutputSession OutputSession { get; }
    public EndpointAddress RemoteAddress { get; }
    public string SessionId { get; }
    public abstract virtual bool get_AllowOutputBatching();
    public abstract virtual void set_AllowOutputBatching(bool value);
    public abstract virtual IInputSession get_InputSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual TimeSpan get_OperationTimeout();
    public abstract virtual void set_OperationTimeout(TimeSpan value);
    public abstract virtual IOutputSession get_OutputSession();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual string get_SessionId();
}
internal interface System.ServiceModel.IContextSessionProvider {
}
public interface System.ServiceModel.IDefaultCommunicationTimeouts {
    public TimeSpan CloseTimeout { get; }
    public TimeSpan OpenTimeout { get; }
    public TimeSpan ReceiveTimeout { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_CloseTimeout();
    public abstract virtual TimeSpan get_OpenTimeout();
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual TimeSpan get_SendTimeout();
}
public interface System.ServiceModel.IDuplexContextChannel {
    public bool AutomaticInputSessionShutdown { get; public set; }
    public InstanceContext CallbackInstance { get; public set; }
    public abstract virtual bool get_AutomaticInputSessionShutdown();
    public abstract virtual void set_AutomaticInputSessionShutdown(bool value);
    public abstract virtual InstanceContext get_CallbackInstance();
    public abstract virtual void set_CallbackInstance(InstanceContext value);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
}
public interface System.ServiceModel.IExtensibleObject`1 {
    public IExtensionCollection`1<T> Extensions { get; }
    public abstract virtual IExtensionCollection`1<T> get_Extensions();
}
public interface System.ServiceModel.IExtension`1 {
    public abstract virtual void Attach(T owner);
    public abstract virtual void Detach(T owner);
}
public interface System.ServiceModel.IExtensionCollection`1 {
    public abstract virtual E Find();
    public abstract virtual Collection`1<E> FindAll();
}
public enum System.ServiceModel.ImpersonationOption : Enum {
    public int value__;
    public static ImpersonationOption NotAllowed;
    public static ImpersonationOption Allowed;
    public static ImpersonationOption Required;
}
internal static class System.ServiceModel.ImpersonationOptionHelper : object {
    public static bool IsDefined(ImpersonationOption option);
    internal static bool AllowedOrRequired(ImpersonationOption option);
}
public class System.ServiceModel.InstanceContext : CommunicationObject {
    internal static InstanceContextEmptyCallback NotifyEmptyCallback;
    internal static InstanceContextIdleCallback NotifyIdleCallback;
    internal bool IsUserCreated { get; internal set; }
    internal bool IsWellKnown { get; }
    internal bool AutoClose { get; internal set; }
    internal InstanceBehavior Behavior { get; internal set; }
    internal ConcurrencyInstanceContextFacet Concurrency { get; }
    internal static InstanceContext Current { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public IExtensionCollection`1<InstanceContext> Extensions { get; }
    internal bool HasTransaction { get; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public ServiceHostBase Host { get; }
    public int ManualFlowControlLimit { get; public set; }
    internal QuotaThrottle QuotaThrottle { get; }
    internal ServiceThrottle ServiceThrottle { get; internal set; }
    internal int InstanceContextManagerIndex { get; internal set; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    internal object ThisLock { get; }
    internal TransactionInstanceContextFacet Transaction { get; }
    internal object UserObject { get; }
    internal ICollection`1<IChannel> WmiChannels { get; }
    public InstanceContext(object implementation);
    public InstanceContext(ServiceHostBase host, object implementation);
    internal InstanceContext(ServiceHostBase host, object implementation, bool isUserCreated);
    internal InstanceContext(ServiceHostBase host, object implementation, bool wellKnown, bool isUserCreated);
    public InstanceContext(ServiceHostBase host);
    internal InstanceContext(ServiceHostBase host, bool isUserCreated);
    private static InstanceContext();
    internal bool get_IsUserCreated();
    internal void set_IsUserCreated(bool value);
    internal bool get_IsWellKnown();
    internal bool get_AutoClose();
    internal void set_AutoClose(bool value);
    internal InstanceBehavior get_Behavior();
    internal void set_Behavior(InstanceBehavior value);
    internal ConcurrencyInstanceContextFacet get_Concurrency();
    internal static InstanceContext get_Current();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual IExtensionCollection`1<InstanceContext> get_Extensions();
    internal bool get_HasTransaction();
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    public ServiceHostBase get_Host();
    public int get_ManualFlowControlLimit();
    public void set_ManualFlowControlLimit(int value);
    internal QuotaThrottle get_QuotaThrottle();
    internal ServiceThrottle get_ServiceThrottle();
    internal void set_ServiceThrottle(ServiceThrottle value);
    internal int get_InstanceContextManagerIndex();
    internal void set_InstanceContextManagerIndex(int value);
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    internal object get_ThisLock();
    internal TransactionInstanceContextFacet get_Transaction();
    internal object get_UserObject();
    internal ICollection`1<IChannel> get_WmiChannels();
    protected virtual void OnAbort();
    internal IAsyncResult BeginCloseInput(TimeSpan timeout, AsyncCallback callback, object state);
    internal void BindRpc(MessageRpc& rpc);
    internal void BindIncomingChannel(ServiceChannel channel);
    internal void CloseInput(TimeSpan timeout);
    internal void EndCloseInput(IAsyncResult result);
    internal void CompleteAttachedTransaction();
    internal void FaultInternal();
    public object GetServiceInstance();
    public object GetServiceInstance(Message message);
    public int IncrementManualFlowControlLimit(int incrementBy);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    public void ReleaseServiceInstance();
    internal void UnbindRpc(MessageRpc& rpc);
    internal void UnbindIncomingChannel(ServiceChannel channel);
}
internal class System.ServiceModel.InstanceContextEmptyCallback : MulticastDelegate {
    public InstanceContextEmptyCallback(object object, IntPtr method);
    public virtual void Invoke(InstanceContext instanceContext);
    public virtual IAsyncResult BeginInvoke(InstanceContext instanceContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ServiceModel.InstanceContextMode : Enum {
    public int value__;
    public static InstanceContextMode PerSession;
    public static InstanceContextMode PerCall;
    public static InstanceContextMode Single;
}
internal static class System.ServiceModel.InstanceContextModeHelper : object {
    public static bool IsDefined(InstanceContextMode x);
}
public class System.ServiceModel.InvalidMessageContractException : SystemException {
    public InvalidMessageContractException(string message);
    public InvalidMessageContractException(string message, Exception innerException);
    protected InvalidMessageContractException(SerializationInfo info, StreamingContext context);
}
public interface System.ServiceModel.IOnlineStatus {
    public bool IsOnline { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Online(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Online(EventHandler value);
    public abstract virtual bool get_IsOnline();
}
internal interface System.ServiceModel.IOperationContractAttributeProvider {
    public abstract virtual OperationContractAttribute GetOperationContractAttribute();
}
public interface System.ServiceModel.IServiceChannel {
    public Uri ListenUri { get; }
    public abstract virtual Uri get_ListenUri();
}
internal static class System.ServiceModel.LocalAppContextSwitches : object {
    public static bool DisableExplicitConnectionCloseHeader { get; }
    public static bool AllowUnsignedToHeader { get; }
    public static bool DisableCngCertificates { get; }
    public static bool get_DisableExplicitConnectionCloseHeader();
    public static bool get_AllowUnsignedToHeader();
    public static bool get_DisableCngCertificates();
    public static void SetDefaultsLessOrEqual_452();
    public static void SetDefaultsLessOrEqual_461();
}
internal class System.ServiceModel.Message11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Actor;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultString;
    public XmlDictionaryString FaultActor;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultNamespace;
    public Message11Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message11Strings : object {
    public static string Namespace;
    public static string Actor;
    public static string FaultCode;
    public static string FaultString;
    public static string FaultActor;
    public static string FaultDetail;
    public static string FaultNamespace;
}
internal class System.ServiceModel.Message12Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Role;
    public XmlDictionaryString Relay;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultReason;
    public XmlDictionaryString FaultText;
    public XmlDictionaryString FaultNode;
    public XmlDictionaryString FaultRole;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultValue;
    public XmlDictionaryString FaultSubcode;
    public XmlDictionaryString NotUnderstood;
    public XmlDictionaryString QName;
    public Message12Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message12Strings : object {
    public static string Namespace;
    public static string Role;
    public static string Relay;
    public static string FaultCode;
    public static string FaultReason;
    public static string FaultText;
    public static string FaultNode;
    public static string FaultRole;
    public static string FaultDetail;
    public static string FaultValue;
    public static string FaultSubcode;
    public static string NotUnderstood;
    public static string QName;
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageBodyMemberAttribute : MessageContractMemberAttribute {
    internal static string OrderPropertyName;
    public int Order { get; public set; }
    public int get_Order();
    public void set_Order(int value);
}
[AttributeUsageAttribute("12")]
public class System.ServiceModel.MessageContractAttribute : Attribute {
    internal static string ProtectionLevelPropertyName;
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public bool IsWrapped { get; public set; }
    public string WrapperName { get; public set; }
    public string WrapperNamespace { get; public set; }
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public bool get_IsWrapped();
    public void set_IsWrapped(bool value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    public string get_WrapperNamespace();
    public void set_WrapperNamespace(string value);
}
public abstract class System.ServiceModel.MessageContractMemberAttribute : Attribute {
    internal static string NamespacePropertyName;
    internal static string NamePropertyName;
    internal static string ProtectionLevelPropertyName;
    public string Namespace { get; public set; }
    internal bool IsNamespaceSetExplicit { get; }
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public string get_Namespace();
    public void set_Namespace(string value);
    internal bool get_IsNamespaceSetExplicit();
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
}
public enum System.ServiceModel.MessageCredentialType : Enum {
    public int value__;
    public static MessageCredentialType None;
    public static MessageCredentialType Windows;
    public static MessageCredentialType UserName;
    public static MessageCredentialType Certificate;
    public static MessageCredentialType IssuedToken;
}
internal static class System.ServiceModel.MessageCredentialTypeHelper : object {
    internal static bool IsDefined(MessageCredentialType value);
}
internal class System.ServiceModel.MessageDictionary : object {
    public XmlDictionaryString MustUnderstand;
    public XmlDictionaryString Envelope;
    public XmlDictionaryString Header;
    public XmlDictionaryString Body;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString Fault;
    public XmlDictionaryString MustUnderstandFault;
    public XmlDictionaryString Namespace;
    public MessageDictionary(ServiceModelDictionary dictionary);
}
public class System.ServiceModel.MessageHeader`1 : object {
    public string Actor { get; public set; }
    public T Content { get; public set; }
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public MessageHeader`1(T content);
    public MessageHeader`1(T content, bool mustUnderstand, string actor, bool relay);
    public string get_Actor();
    public void set_Actor(string value);
    public T get_Content();
    public void set_Content(T value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    internal Type GetGenericArgument();
    public MessageHeader GetUntypedHeader(string name, string ns);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderArrayAttribute : MessageHeaderAttribute {
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderAttribute : MessageContractMemberAttribute {
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public string Actor { get; public set; }
    internal bool IsMustUnderstandSet { get; }
    internal bool IsRelaySet { get; }
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public string get_Actor();
    public void set_Actor(string value);
    internal bool get_IsMustUnderstandSet();
    internal bool get_IsRelaySet();
}
public class System.ServiceModel.MessageHeaderException : ProtocolException {
    public string HeaderName { get; }
    public string HeaderNamespace { get; }
    public bool IsDuplicate { get; }
    public MessageHeaderException(string message);
    public MessageHeaderException(string message, bool isDuplicate);
    public MessageHeaderException(string message, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate);
    public MessageHeaderException(string message, string headerName, string ns, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate, Exception innerException);
    protected MessageHeaderException(SerializationInfo info, StreamingContext context);
    public string get_HeaderName();
    public string get_HeaderNamespace();
    public bool get_IsDuplicate();
    internal Message ProvideFault(MessageVersion messageVersion);
}
[AttributeUsageAttribute("10240")]
public class System.ServiceModel.MessageParameterAttribute : Attribute {
    internal static string NamePropertyName;
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessagePropertyAttribute : Attribute {
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
}
public class System.ServiceModel.MessageSecurityOverHttp : object {
    internal static MessageCredentialType DefaultClientCredentialType;
    internal static bool DefaultNegotiateServiceCredential;
    public MessageCredentialType ClientCredentialType { get; public set; }
    public bool NegotiateServiceCredential { get; public set; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    internal bool WasAlgorithmSuiteSet { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public bool get_NegotiateServiceCredential();
    public void set_NegotiateServiceCredential(bool value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal bool get_WasAlgorithmSuiteSet();
    protected virtual bool IsSecureConversationEnabled();
    internal SecurityBindingElement CreateSecurityBindingElement(bool isSecureTransportMode, bool isReliableSession, MessageSecurityVersion version);
    internal static bool TryCreate(SecurityBindingElement sbe, bool isSecureTransportMode, bool isReliableSession, TSecurity& messageSecurity);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAlgorithmSuite();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeClientCredentialType();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeNegotiateServiceCredential();
}
public class System.ServiceModel.MessageSecurityOverMsmq : object {
    internal static MessageCredentialType DefaultClientCredentialType;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MessageCredentialType ClientCredentialType { get; public set; }
    [DefaultValueAttribute("System.ServiceModel.Security.SecurityAlgorithmSuite", "Default")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    internal bool WasAlgorithmSuiteSet { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal bool get_WasAlgorithmSuiteSet();
    internal SecurityBindingElement CreateSecurityBindingElement();
    internal static bool TryCreate(SecurityBindingElement sbe, MessageSecurityOverMsmq& messageSecurity);
}
public class System.ServiceModel.MessageSecurityOverTcp : object {
    internal static MessageCredentialType DefaultClientCredentialType;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MessageCredentialType ClientCredentialType { get; public set; }
    [DefaultValueAttribute("System.ServiceModel.Security.SecurityAlgorithmSuite", "Default")]
public SecurityAlgorithmSuite AlgorithmSuite { get; public set; }
    internal bool WasAlgorithmSuiteSet { get; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public void set_AlgorithmSuite(SecurityAlgorithmSuite value);
    internal bool get_WasAlgorithmSuiteSet();
    internal SecurityBindingElement CreateSecurityBindingElement(bool isSecureTransportMode, bool isReliableSession, BindingElement transportBindingElement);
    internal static bool TryCreate(SecurityBindingElement sbe, bool isReliableSession, BindingElement transportBindingElement, MessageSecurityOverTcp& messageSecurity);
    internal bool InternalShouldSerialize();
}
public abstract class System.ServiceModel.MessageSecurityVersion : object {
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion Default { get; }
    internal static MessageSecurityVersion WSSXDefault { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    public SecurityTokenVersion SecurityTokenVersion { get; }
    public SecurityPolicyVersion SecurityPolicyVersion { get; }
    public BasicSecurityProfileVersion BasicSecurityProfileVersion { get; }
    internal MessageSecurityTokenVersion MessageSecurityTokenVersion { get; }
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11();
    public static MessageSecurityVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12();
    public static MessageSecurityVersion get_WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_Default();
    internal static MessageSecurityVersion get_WSSXDefault();
    public SecurityVersion get_SecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    public SecurityTokenVersion get_SecurityTokenVersion();
    public abstract virtual SecurityPolicyVersion get_SecurityPolicyVersion();
    public abstract virtual BasicSecurityProfileVersion get_BasicSecurityProfileVersion();
    internal abstract virtual MessageSecurityTokenVersion get_MessageSecurityTokenVersion();
}
internal static class System.ServiceModel.MessageStrings : object {
    public static string MustUnderstand;
    public static string Envelope;
    public static string Header;
    public static string Body;
    public static string Prefix;
    public static string Fault;
    public static string MustUnderstandFault;
    public static string Namespace;
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.MostlySingletonList`1 : ValueType {
    private int count;
    private T singleton;
    private List`1<T> list;
    public T Item { get; }
    public int Count { get; }
    public T get_Item(int index);
    public int get_Count();
    public void Add(T item);
    public bool Contains(T item);
    public int IndexOf(T item);
    public bool Remove(T item);
    public void RemoveAt(int index);
}
public enum System.ServiceModel.MsmqAuthenticationMode : Enum {
    public int value__;
    public static MsmqAuthenticationMode None;
    public static MsmqAuthenticationMode WindowsDomain;
    public static MsmqAuthenticationMode Certificate;
}
internal static class System.ServiceModel.MsmqAuthenticationModeHelper : object {
    public static bool IsDefined(MsmqAuthenticationMode mode);
}
public abstract class System.ServiceModel.MsmqBindingBase : Binding {
    internal MsmqBindingElementBase transport;
    [DefaultValueAttribute("System.TimeSpan", "00:05:00")]
public TimeSpan ValidityDuration { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public Uri CustomDeadLetterQueue { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DeadLetterQueue DeadLetterQueue { get; public set; }
    [DefaultValueAttribute("True")]
public bool Durable { get; public set; }
    [DefaultValueAttribute("True")]
public bool ExactlyOnce { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("5")]
public int ReceiveRetryCount { get; public set; }
    [DefaultValueAttribute("2")]
public int MaxRetryCycles { get; public set; }
    [DefaultValueAttribute("True")]
public bool ReceiveContextEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ReceiveErrorHandling ReceiveErrorHandling { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:30:00")]
public TimeSpan RetryCycleDelay { get; public set; }
    public string Scheme { get; }
    [DefaultValueAttribute("System.TimeSpan", "1.00:00:00")]
public TimeSpan TimeToLive { get; public set; }
    [DefaultValueAttribute("False")]
public bool UseSourceJournal { get; public set; }
    [DefaultValueAttribute("False")]
public bool UseMsmqTracing { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    public TimeSpan get_ValidityDuration();
    public void set_ValidityDuration(TimeSpan value);
    public Uri get_CustomDeadLetterQueue();
    public void set_CustomDeadLetterQueue(Uri value);
    public DeadLetterQueue get_DeadLetterQueue();
    public void set_DeadLetterQueue(DeadLetterQueue value);
    public bool get_Durable();
    public void set_Durable(bool value);
    public bool get_ExactlyOnce();
    public void set_ExactlyOnce(bool value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public int get_ReceiveRetryCount();
    public void set_ReceiveRetryCount(int value);
    public int get_MaxRetryCycles();
    public void set_MaxRetryCycles(int value);
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    public ReceiveErrorHandling get_ReceiveErrorHandling();
    public void set_ReceiveErrorHandling(ReceiveErrorHandling value);
    public TimeSpan get_RetryCycleDelay();
    public void set_RetryCycleDelay(TimeSpan value);
    public virtual string get_Scheme();
    public TimeSpan get_TimeToLive();
    public void set_TimeToLive(TimeSpan value);
    public bool get_UseSourceJournal();
    public void set_UseSourceJournal(bool value);
    public bool get_UseMsmqTracing();
    public void set_UseMsmqTracing(bool value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
}
public enum System.ServiceModel.MsmqEncryptionAlgorithm : Enum {
    public int value__;
    public static MsmqEncryptionAlgorithm RC4Stream;
    public static MsmqEncryptionAlgorithm Aes;
}
internal static class System.ServiceModel.MsmqEncryptionAlgorithmHelper : object {
    public static bool IsDefined(MsmqEncryptionAlgorithm algorithm);
    public static int ToInt32(MsmqEncryptionAlgorithm algorithm);
}
internal static class System.ServiceModel.MsmqError : object {
    public static string GetErrorString(int error);
}
public class System.ServiceModel.MsmqException : ExternalException {
    internal bool FaultSender { get; }
    internal bool FaultReceiver { get; }
    internal Exception Normalized { get; }
    public MsmqException(string message);
    public MsmqException(string message, int error);
    public MsmqException(string message, Exception inner);
    protected MsmqException(SerializationInfo info, StreamingContext context);
    internal bool get_FaultSender();
    internal bool get_FaultReceiver();
    internal Exception get_Normalized();
}
internal class System.ServiceModel.MsmqIntegration.ActiveXSerializer : object {
    public object Deserialize(MemoryStream stream, int bodyType);
    public void Serialize(Stream stream, object obj, Int32& bodyType);
}
public class System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding : MsmqBindingBase {
    public MsmqIntegrationSecurity Security { get; public set; }
    internal Type[] TargetSerializationTypes { get; internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MsmqMessageSerializationFormat SerializationFormat { get; public set; }
    public MsmqIntegrationBinding(string configurationName);
    public MsmqIntegrationBinding(MsmqIntegrationSecurityMode securityMode);
    public MsmqIntegrationSecurity get_Security();
    public void set_Security(MsmqIntegrationSecurity value);
    internal Type[] get_TargetSerializationTypes();
    internal void set_TargetSerializationTypes(Type[] value);
    public MsmqMessageSerializationFormat get_SerializationFormat();
    public void set_SerializationFormat(MsmqMessageSerializationFormat value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    public virtual BindingElementCollection CreateBindingElements();
}
public class System.ServiceModel.MsmqIntegration.MsmqIntegrationBindingElement : MsmqBindingElementBase {
    public string Scheme { get; }
    internal IAddressTranslator AddressTranslator { get; }
    public MsmqMessageSerializationFormat SerializationFormat { get; public set; }
    public Type[] TargetSerializationTypes { get; public set; }
    public virtual string get_Scheme();
    internal virtual IAddressTranslator get_AddressTranslator();
    public MsmqMessageSerializationFormat get_SerializationFormat();
    public void set_SerializationFormat(MsmqMessageSerializationFormat value);
    public Type[] get_TargetSerializationTypes();
    public void set_TargetSerializationTypes(Type[] value);
    public virtual BindingElement Clone();
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelListener(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationChannelFactory : MsmqChannelFactoryBase`1<IOutputChannel> {
    public MsmqMessageSerializationFormat SerializationFormat { get; }
    internal MsmqIntegrationChannelFactory(MsmqIntegrationBindingElement bindingElement, BindingContext context);
    public MsmqMessageSerializationFormat get_SerializationFormat();
    protected virtual IOutputChannel OnCreateChannel(EndpointAddress to, Uri via);
    internal Stream Serialize(MsmqIntegrationMessageProperty property);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationChannelListener : MsmqInputChannelListenerBase {
    public string Scheme { get; }
    internal XmlSerializer[] XmlSerializerList { get; }
    internal MsmqIntegrationChannelListener(MsmqBindingElementBase bindingElement, BindingContext context, MsmqReceiveParameters receiveParameters);
    public virtual string get_Scheme();
    internal XmlSerializer[] get_XmlSerializerList();
    protected virtual IInputChannel CreateInputChannel(MsmqInputChannelListenerBase listener);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationInputChannel : MsmqInputChannelBase {
    public MsmqIntegrationInputChannel(MsmqIntegrationChannelListener listener);
    protected virtual Message DecodeMsmqMessage(MsmqInputMessage msmqMessage, MsmqMessageProperty property);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationInputMessage : MsmqInputMessage {
    public MsmqIntegrationInputMessage(int maxBufferSize);
    protected MsmqIntegrationInputMessage(SizeQuota bufferSizeQuota);
    protected virtual void OnGrowBuffers(SizeQuota bufferSizeQuota);
    public void SetMessageProperties(MsmqIntegrationMessageProperty property);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationMessagePool : SynchronizedDisposablePool`1<MsmqIntegrationInputMessage> {
    internal MsmqIntegrationMessagePool(int maxPoolSize);
    private sealed virtual override MsmqInputMessage System.ServiceModel.Channels.IMsmqMessagePool.TakeMessage();
    private sealed virtual override void System.ServiceModel.Channels.IMsmqMessagePool.ReturnMessage(MsmqInputMessage message);
}
public class System.ServiceModel.MsmqIntegration.MsmqIntegrationMessageProperty : object {
    public static string Name;
    public object Body { get; public set; }
    public Nullable`1<AcknowledgeTypes> AcknowledgeType { get; public set; }
    public Nullable`1<Acknowledgment> Acknowledgment { get; internal set; }
    public Uri AdministrationQueue { get; public set; }
    public Nullable`1<int> AppSpecific { get; public set; }
    public Nullable`1<DateTime> ArrivedTime { get; internal set; }
    public Nullable`1<bool> Authenticated { get; internal set; }
    public Nullable`1<int> BodyType { get; public set; }
    public string CorrelationId { get; public set; }
    public Uri DestinationQueue { get; internal set; }
    public Byte[] Extension { get; public set; }
    public string Id { get; internal set; }
    public string Label { get; public set; }
    public Nullable`1<MessageType> MessageType { get; internal set; }
    public Nullable`1<MessagePriority> Priority { get; public set; }
    public Uri ResponseQueue { get; public set; }
    public Byte[] SenderId { get; internal set; }
    public Nullable`1<DateTime> SentTime { get; internal set; }
    public Nullable`1<TimeSpan> TimeToReachQueue { get; public set; }
    public static MsmqIntegrationMessageProperty Get(Message message);
    public object get_Body();
    public void set_Body(object value);
    public Nullable`1<AcknowledgeTypes> get_AcknowledgeType();
    public void set_AcknowledgeType(Nullable`1<AcknowledgeTypes> value);
    public Nullable`1<Acknowledgment> get_Acknowledgment();
    internal void set_Acknowledgment(Nullable`1<Acknowledgment> value);
    public Uri get_AdministrationQueue();
    public void set_AdministrationQueue(Uri value);
    public Nullable`1<int> get_AppSpecific();
    public void set_AppSpecific(Nullable`1<int> value);
    public Nullable`1<DateTime> get_ArrivedTime();
    internal void set_ArrivedTime(Nullable`1<DateTime> value);
    public Nullable`1<bool> get_Authenticated();
    internal void set_Authenticated(Nullable`1<bool> value);
    public Nullable`1<int> get_BodyType();
    public void set_BodyType(Nullable`1<int> value);
    public string get_CorrelationId();
    public void set_CorrelationId(string value);
    public Uri get_DestinationQueue();
    internal void set_DestinationQueue(Uri value);
    public Byte[] get_Extension();
    public void set_Extension(Byte[] value);
    public string get_Id();
    internal void set_Id(string value);
    public string get_Label();
    public void set_Label(string value);
    public Nullable`1<MessageType> get_MessageType();
    internal void set_MessageType(Nullable`1<MessageType> value);
    public Nullable`1<MessagePriority> get_Priority();
    public void set_Priority(Nullable`1<MessagePriority> value);
    public Uri get_ResponseQueue();
    public void set_ResponseQueue(Uri value);
    public Byte[] get_SenderId();
    internal void set_SenderId(Byte[] value);
    public Nullable`1<DateTime> get_SentTime();
    internal void set_SentTime(Nullable`1<DateTime> value);
    public Nullable`1<TimeSpan> get_TimeToReachQueue();
    public void set_TimeToReachQueue(Nullable`1<TimeSpan> value);
    internal void InternalSetTimeToReachQueue(TimeSpan timeout);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationOutputChannel : TransportOutputChannel {
    public MsmqIntegrationOutputChannel(MsmqIntegrationChannelFactory factory, EndpointAddress to, Uri via, bool manualAddressing);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndSend(IAsyncResult result);
    protected virtual void OnSend(Message message, TimeSpan timeout);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationReceiveParameters : MsmqReceiveParameters {
    internal MsmqMessageSerializationFormat SerializationFormat { get; }
    internal Type[] TargetSerializationTypes { get; }
    internal MsmqIntegrationReceiveParameters(MsmqIntegrationBindingElement bindingElement);
    internal MsmqMessageSerializationFormat get_SerializationFormat();
    internal Type[] get_TargetSerializationTypes();
}
public class System.ServiceModel.MsmqIntegration.MsmqIntegrationSecurity : object {
    internal static MsmqIntegrationSecurityMode DefaultMode;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MsmqIntegrationSecurityMode Mode { get; public set; }
    public MsmqTransportSecurity Transport { get; public set; }
    public MsmqIntegrationSecurityMode get_Mode();
    public void set_Mode(MsmqIntegrationSecurityMode value);
    public MsmqTransportSecurity get_Transport();
    public void set_Transport(MsmqTransportSecurity value);
    internal void ConfigureTransportSecurity(MsmqBindingElementBase msmq);
}
public enum System.ServiceModel.MsmqIntegration.MsmqIntegrationSecurityMode : Enum {
    public int value__;
    public static MsmqIntegrationSecurityMode None;
    public static MsmqIntegrationSecurityMode Transport;
}
internal static class System.ServiceModel.MsmqIntegration.MsmqIntegrationSecurityModeHelper : object {
    internal static bool IsDefined(MsmqIntegrationSecurityMode value);
}
internal class System.ServiceModel.MsmqIntegration.MsmqIntegrationValidationBehavior : object {
    internal static MsmqIntegrationValidationBehavior Instance { get; }
    internal static MsmqIntegrationValidationBehavior get_Instance();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
}
[MessageContractAttribute]
public class System.ServiceModel.MsmqIntegration.MsmqMessage`1 : object {
    public T Body { get; public set; }
    public Nullable`1<AcknowledgeTypes> AcknowledgeType { get; public set; }
    public Nullable`1<Acknowledgment> Acknowledgment { get; }
    public Uri AdministrationQueue { get; public set; }
    public Nullable`1<int> AppSpecific { get; public set; }
    public Nullable`1<DateTime> ArrivedTime { get; }
    public Nullable`1<bool> Authenticated { get; }
    public Nullable`1<int> BodyType { get; public set; }
    public string CorrelationId { get; public set; }
    public Uri DestinationQueue { get; }
    public Byte[] Extension { get; public set; }
    public string Id { get; }
    public string Label { get; public set; }
    public Nullable`1<MessageType> MessageType { get; }
    public Nullable`1<MessagePriority> Priority { get; public set; }
    public Uri ResponseQueue { get; public set; }
    public Byte[] SenderId { get; }
    public Nullable`1<DateTime> SentTime { get; }
    public Nullable`1<TimeSpan> TimeToReachQueue { get; public set; }
    public MsmqMessage`1(T body);
    public T get_Body();
    public void set_Body(T value);
    public Nullable`1<AcknowledgeTypes> get_AcknowledgeType();
    public void set_AcknowledgeType(Nullable`1<AcknowledgeTypes> value);
    public Nullable`1<Acknowledgment> get_Acknowledgment();
    public Uri get_AdministrationQueue();
    public void set_AdministrationQueue(Uri value);
    public Nullable`1<int> get_AppSpecific();
    public void set_AppSpecific(Nullable`1<int> value);
    public Nullable`1<DateTime> get_ArrivedTime();
    public Nullable`1<bool> get_Authenticated();
    public Nullable`1<int> get_BodyType();
    public void set_BodyType(Nullable`1<int> value);
    public string get_CorrelationId();
    public void set_CorrelationId(string value);
    public Uri get_DestinationQueue();
    public Byte[] get_Extension();
    public void set_Extension(Byte[] value);
    public string get_Id();
    public string get_Label();
    public void set_Label(string value);
    public Nullable`1<MessageType> get_MessageType();
    public Nullable`1<MessagePriority> get_Priority();
    public void set_Priority(Nullable`1<MessagePriority> value);
    public Uri get_ResponseQueue();
    public void set_ResponseQueue(Uri value);
    public Byte[] get_SenderId();
    public Nullable`1<DateTime> get_SentTime();
    public Nullable`1<TimeSpan> get_TimeToReachQueue();
    public void set_TimeToReachQueue(Nullable`1<TimeSpan> value);
}
public enum System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat : Enum {
    public int value__;
    public static MsmqMessageSerializationFormat Xml;
    public static MsmqMessageSerializationFormat Binary;
    public static MsmqMessageSerializationFormat ActiveX;
    public static MsmqMessageSerializationFormat ByteArray;
    public static MsmqMessageSerializationFormat Stream;
}
internal static class System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormatHelper : object {
    internal static bool IsDefined(MsmqMessageSerializationFormat value);
}
public class System.ServiceModel.MsmqPoisonMessageException : PoisonMessageException {
    public long MessageLookupId { get; }
    public MsmqPoisonMessageException(string message);
    public MsmqPoisonMessageException(string message, Exception innerException);
    public MsmqPoisonMessageException(long messageLookupId);
    public MsmqPoisonMessageException(long messageLookupId, Exception innerException);
    protected MsmqPoisonMessageException(SerializationInfo info, StreamingContext context);
    public long get_MessageLookupId();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.MsmqSecureHashAlgorithm : Enum {
    public int value__;
    public static MsmqSecureHashAlgorithm MD5;
    public static MsmqSecureHashAlgorithm Sha1;
    public static MsmqSecureHashAlgorithm Sha256;
    public static MsmqSecureHashAlgorithm Sha512;
}
internal static class System.ServiceModel.MsmqSecureHashAlgorithmHelper : object {
    public static bool IsDefined(MsmqSecureHashAlgorithm algorithm);
    public static int ToInt32(MsmqSecureHashAlgorithm algorithm);
}
public class System.ServiceModel.MsmqTransportSecurity : object {
    internal bool Enabled { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MsmqAuthenticationMode MsmqAuthenticationMode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MsmqEncryptionAlgorithm MsmqEncryptionAlgorithm { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MsmqSecureHashAlgorithm MsmqSecureHashAlgorithm { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel MsmqProtectionLevel { get; public set; }
    public MsmqTransportSecurity(MsmqTransportSecurity other);
    internal bool get_Enabled();
    public MsmqAuthenticationMode get_MsmqAuthenticationMode();
    public void set_MsmqAuthenticationMode(MsmqAuthenticationMode value);
    public MsmqEncryptionAlgorithm get_MsmqEncryptionAlgorithm();
    public void set_MsmqEncryptionAlgorithm(MsmqEncryptionAlgorithm value);
    public MsmqSecureHashAlgorithm get_MsmqSecureHashAlgorithm();
    public void set_MsmqSecureHashAlgorithm(MsmqSecureHashAlgorithm value);
    public ProtectionLevel get_MsmqProtectionLevel();
    public void set_MsmqProtectionLevel(ProtectionLevel value);
    internal void Disable();
}
internal class System.ServiceModel.MustUnderstandSoapException : CommunicationException {
    public Collection`1<MessageHeaderInfo> NotUnderstoodHeaders { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    protected MustUnderstandSoapException(SerializationInfo info, StreamingContext context);
    public MustUnderstandSoapException(Collection`1<MessageHeaderInfo> notUnderstoodHeaders, EnvelopeVersion envelopeVersion);
    public Collection`1<MessageHeaderInfo> get_NotUnderstoodHeaders();
    public EnvelopeVersion get_EnvelopeVersion();
    internal Message ProvideFault(MessageVersion messageVersion);
}
public class System.ServiceModel.NamedPipeTransportSecurity : object {
    internal static ProtectionLevel DefaultProtectionLevel;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ProtectionLevel { get; public set; }
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    internal WindowsStreamSecurityBindingElement CreateTransportProtectionAndAuthentication();
    internal static bool IsTransportProtectionAndAuthentication(WindowsStreamSecurityBindingElement wssbe, NamedPipeTransportSecurity transportSecurity);
}
public class System.ServiceModel.NetHttpBinding : HttpBindingBase {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NetHttpMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpSecurity Security { get; public set; }
    public OptionalReliableSession ReliableSession { get; public set; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public NetHttpBinding(BasicHttpSecurityMode securityMode);
    public NetHttpBinding(BasicHttpSecurityMode securityMode, bool reliableSessionEnabled);
    public NetHttpBinding(string configurationName);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public BasicHttpSecurity get_Security();
    public void set_Security(BasicHttpSecurity value);
    public OptionalReliableSession get_ReliableSession();
    public void set_ReliableSession(OptionalReliableSession value);
    public WebSocketTransportSettings get_WebSocketSettings();
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReliableSession();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void CheckSettings();
}
public enum System.ServiceModel.NetHttpMessageEncoding : Enum {
    public int value__;
    public static NetHttpMessageEncoding Binary;
    public static NetHttpMessageEncoding Text;
    public static NetHttpMessageEncoding Mtom;
}
internal static class System.ServiceModel.NetHttpMessageEncodingHelper : object {
    internal static bool IsDefined(NetHttpMessageEncoding value);
}
public class System.ServiceModel.NetHttpsBinding : HttpBindingBase {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NetHttpMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpsSecurity Security { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public OptionalReliableSession ReliableSession { get; public set; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    public NetHttpsBinding(BasicHttpsSecurityMode securityMode);
    public NetHttpsBinding(BasicHttpsSecurityMode securityMode, bool reliableSessionEnabled);
    public NetHttpsBinding(string configurationName);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public BasicHttpsSecurity get_Security();
    public void set_Security(BasicHttpsSecurity value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    public OptionalReliableSession get_ReliableSession();
    public void set_ReliableSession(OptionalReliableSession value);
    public WebSocketTransportSettings get_WebSocketSettings();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReliableSession();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void CheckSettings();
}
public class System.ServiceModel.NetMsmqBinding : MsmqBindingBase {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public QueueTransferProtocol QueueTransferProtocol { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public NetMsmqSecurity Security { get; public set; }
    public EnvelopeVersion EnvelopeVersion { get; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    internal int MaxPoolSize { get; internal set; }
    [DefaultValueAttribute("False")]
public bool UseActiveDirectory { get; public set; }
    public NetMsmqBinding(string configurationName);
    public NetMsmqBinding(NetMsmqSecurityMode securityMode);
    public QueueTransferProtocol get_QueueTransferProtocol();
    public void set_QueueTransferProtocol(QueueTransferProtocol value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public NetMsmqSecurity get_Security();
    public void set_Security(NetMsmqSecurity value);
    public EnvelopeVersion get_EnvelopeVersion();
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    internal int get_MaxPoolSize();
    internal void set_MaxPoolSize(int value);
    public bool get_UseActiveDirectory();
    public void set_UseActiveDirectory(bool value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
}
public class System.ServiceModel.NetMsmqSecurity : object {
    internal static NetMsmqSecurityMode DefaultMode;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NetMsmqSecurityMode Mode { get; public set; }
    public MsmqTransportSecurity Transport { get; public set; }
    public MessageSecurityOverMsmq Message { get; public set; }
    internal NetMsmqSecurity(NetMsmqSecurityMode mode);
    public NetMsmqSecurityMode get_Mode();
    public void set_Mode(NetMsmqSecurityMode value);
    public MsmqTransportSecurity get_Transport();
    public void set_Transport(MsmqTransportSecurity value);
    public MessageSecurityOverMsmq get_Message();
    public void set_Message(MessageSecurityOverMsmq value);
    internal void ConfigureTransportSecurity(MsmqBindingElementBase msmq);
    internal static bool IsConfiguredTransportSecurity(MsmqTransportBindingElement msmq, UnifiedSecurityMode& mode);
    internal SecurityBindingElement CreateMessageSecurity();
    internal static bool TryCreate(SecurityBindingElement sbe, NetMsmqSecurityMode mode, NetMsmqSecurity& security);
}
public enum System.ServiceModel.NetMsmqSecurityMode : Enum {
    public int value__;
    public static NetMsmqSecurityMode None;
    public static NetMsmqSecurityMode Transport;
    public static NetMsmqSecurityMode Message;
    public static NetMsmqSecurityMode Both;
}
internal static class System.ServiceModel.NetMsmqSecurityModeHelper : object {
    internal static bool IsDefined(NetMsmqSecurityMode value);
    internal static NetMsmqSecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
public class System.ServiceModel.NetNamedPipeBinding : Binding {
    [DefaultValueAttribute("False")]
public bool TransactionFlow { get; public set; }
    public TransactionProtocol TransactionProtocol { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    public int MaxConnections { get; public set; }
    internal bool IsMaxConnectionsSet { get; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    public NetNamedPipeSecurity Security { get; public set; }
    public NetNamedPipeBinding(NetNamedPipeSecurityMode securityMode);
    public NetNamedPipeBinding(string configurationName);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxConnections();
    public void set_MaxConnections(int value);
    internal bool get_IsMaxConnectionsSet();
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public NetNamedPipeSecurity get_Security();
    public void set_Security(NetNamedPipeSecurity value);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransactionProtocol();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMaxConnections();
}
public class System.ServiceModel.NetNamedPipeSecurity : object {
    internal static NetNamedPipeSecurityMode DefaultMode;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NetNamedPipeSecurityMode Mode { get; public set; }
    public NamedPipeTransportSecurity Transport { get; public set; }
    public NetNamedPipeSecurityMode get_Mode();
    public void set_Mode(NetNamedPipeSecurityMode value);
    public NamedPipeTransportSecurity get_Transport();
    public void set_Transport(NamedPipeTransportSecurity value);
    internal WindowsStreamSecurityBindingElement CreateTransportSecurity();
    internal static bool TryCreate(WindowsStreamSecurityBindingElement wssbe, NetNamedPipeSecurityMode mode, NetNamedPipeSecurity& security);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransport();
}
public enum System.ServiceModel.NetNamedPipeSecurityMode : Enum {
    public int value__;
    public static NetNamedPipeSecurityMode None;
    public static NetNamedPipeSecurityMode Transport;
}
internal static class System.ServiceModel.NetNamedPipeSecurityModeHelper : object {
    internal static bool IsDefined(NetNamedPipeSecurityMode value);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
public class System.ServiceModel.NetPeerTcpBinding : Binding {
    public static bool IsPnrpAvailable { get; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.ServiceModel.Configuration.PeerTransportListenAddressConverter")]
public IPAddress ListenIPAddress { get; public set; }
    public PeerSecuritySettings Security { get; public set; }
    [DefaultValueAttribute("0")]
public int Port { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public PeerResolverSettings Resolver { get; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    public NetPeerTcpBinding(string configurationName);
    public static bool get_IsPnrpAvailable();
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public IPAddress get_ListenIPAddress();
    public void set_ListenIPAddress(IPAddress value);
    public PeerSecuritySettings get_Security();
    public void set_Security(PeerSecuritySettings value);
    public int get_Port();
    public void set_Port(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public PeerResolverSettings get_Resolver();
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
}
public class System.ServiceModel.NetTcpBinding : Binding {
    [DefaultValueAttribute("False")]
public bool TransactionFlow { get; public set; }
    public TransactionProtocol TransactionProtocol { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    public int MaxConnections { get; public set; }
    internal bool IsMaxConnectionsSet { get; }
    public int ListenBacklog { get; public set; }
    internal bool IsListenBacklogSet { get; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("False")]
public bool PortSharingEnabled { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    public OptionalReliableSession ReliableSession { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    public NetTcpSecurity Security { get; public set; }
    public NetTcpBinding(SecurityMode securityMode);
    public NetTcpBinding(SecurityMode securityMode, bool reliableSessionEnabled);
    public NetTcpBinding(string configurationName);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public TransactionProtocol get_TransactionProtocol();
    public void set_TransactionProtocol(TransactionProtocol value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxConnections();
    public void set_MaxConnections(int value);
    internal bool get_IsMaxConnectionsSet();
    public int get_ListenBacklog();
    public void set_ListenBacklog(int value);
    internal bool get_IsListenBacklogSet();
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public bool get_PortSharingEnabled();
    public void set_PortSharingEnabled(bool value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    public OptionalReliableSession get_ReliableSession();
    public void set_ReliableSession(OptionalReliableSession value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public NetTcpSecurity get_Security();
    public void set_Security(NetTcpSecurity value);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransactionProtocol();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReliableSession();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeListenBacklog();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMaxConnections();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.NetTcpContextBinding : NetTcpBinding {
    [DefaultValueAttribute("")]
public Uri ClientCallbackAddress { get; public set; }
    [DefaultValueAttribute("True")]
public bool ContextManagementEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ContextProtectionLevel { get; public set; }
    public NetTcpContextBinding(SecurityMode securityMode);
    public NetTcpContextBinding(string configName);
    public NetTcpContextBinding(SecurityMode securityMode, bool reliableSessionEnabled);
    [CompilerGeneratedAttribute]
public Uri get_ClientCallbackAddress();
    [CompilerGeneratedAttribute]
public void set_ClientCallbackAddress(Uri value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public ProtectionLevel get_ContextProtectionLevel();
    public void set_ContextProtectionLevel(ProtectionLevel value);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection bindingElements, Binding& binding);
}
public class System.ServiceModel.NetTcpSecurity : object {
    internal static SecurityMode DefaultMode;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SecurityMode Mode { get; public set; }
    public TcpTransportSecurity Transport { get; public set; }
    public MessageSecurityOverTcp Message { get; public set; }
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public TcpTransportSecurity get_Transport();
    public void set_Transport(TcpTransportSecurity value);
    public MessageSecurityOverTcp get_Message();
    public void set_Message(MessageSecurityOverTcp value);
    internal BindingElement CreateTransportSecurity();
    internal static UnifiedSecurityMode GetModeFromTransportSecurity(BindingElement transport);
    internal static bool SetTransportSecurity(BindingElement transport, SecurityMode mode, TcpTransportSecurity transportSecurity);
    internal SecurityBindingElement CreateMessageSecurity(bool isReliableSessionEnabled);
    internal static bool TryCreate(SecurityBindingElement wsSecurity, SecurityMode mode, bool isReliableSessionEnabled, BindingElement transportSecurity, TcpTransportSecurity tcpTransportSecurity, NetTcpSecurity& security);
    internal bool InternalShouldSerialize();
}
public class System.ServiceModel.NonDualMessageSecurityOverHttp : MessageSecurityOverHttp {
    internal static bool DefaultEstablishSecurityContext;
    public bool EstablishSecurityContext { get; public set; }
    public bool get_EstablishSecurityContext();
    public void set_EstablishSecurityContext(bool value);
    protected virtual bool IsSecureConversationEnabled();
}
internal class System.ServiceModel.OleTransactionsProtocol : TransactionProtocol {
    internal static TransactionProtocol Instance { get; }
    internal string Name { get; }
    private static OleTransactionsProtocol();
    internal static TransactionProtocol get_Instance();
    internal virtual string get_Name();
}
internal class System.ServiceModel.OleTxTransactionExternalDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString OleTxTransaction;
    public XmlDictionaryString PropagationToken;
    public OleTxTransactionExternalDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.OleTxTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string OleTxTransaction;
    public static string PropagationToken;
}
internal class System.ServiceModel.OpenCollectionAsyncResult : AsyncResult {
    public OpenCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static OpenCollectionAsyncResult();
    public static void End(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.OperationBehaviorAttribute : Attribute {
    internal static ImpersonationOption DefaultImpersonationOption;
    public bool TransactionAutoComplete { get; public set; }
    public bool TransactionScopeRequired { get; public set; }
    public bool AutoDisposeParameters { get; public set; }
    public ImpersonationOption Impersonation { get; public set; }
    public ReleaseInstanceMode ReleaseInstanceMode { get; public set; }
    internal bool PreferAsyncInvocation { get; internal set; }
    public bool get_TransactionAutoComplete();
    public void set_TransactionAutoComplete(bool value);
    public bool get_TransactionScopeRequired();
    public void set_TransactionScopeRequired(bool value);
    public bool get_AutoDisposeParameters();
    public void set_AutoDisposeParameters(bool value);
    public ImpersonationOption get_Impersonation();
    public void set_Impersonation(ImpersonationOption value);
    public ReleaseInstanceMode get_ReleaseInstanceMode();
    public void set_ReleaseInstanceMode(ReleaseInstanceMode value);
    internal bool get_PreferAsyncInvocation();
    internal void set_PreferAsyncInvocation(bool value);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
public class System.ServiceModel.OperationContext : object {
    internal IPrincipal threadPrincipal;
    public IContextChannel Channel { get; }
    public static OperationContext Current { get; public set; }
    internal static Holder CurrentHolder { get; }
    public EndpointDispatcher EndpointDispatcher { get; public set; }
    public bool IsUserContext { get; }
    public IExtensionCollection`1<OperationContext> Extensions { get; }
    internal bool IsServiceReentrant { get; internal set; }
    public bool HasSupportingTokens { get; }
    public ServiceHostBase Host { get; }
    internal Message IncomingMessage { get; }
    internal ServiceChannel InternalServiceChannel { get; internal set; }
    internal bool HasOutgoingMessageHeaders { get; }
    public MessageHeaders OutgoingMessageHeaders { get; }
    internal bool HasOutgoingMessageProperties { get; }
    public MessageProperties OutgoingMessageProperties { get; }
    internal MessageVersion OutgoingMessageVersion { get; }
    public MessageHeaders IncomingMessageHeaders { get; }
    public MessageProperties IncomingMessageProperties { get; }
    public MessageVersion IncomingMessageVersion { get; }
    public InstanceContext InstanceContext { get; }
    public RequestContext RequestContext { get; public set; }
    public ServiceSecurityContext ServiceSecurityContext { get; }
    public string SessionId { get; }
    public ICollection`1<SupportingTokenSpecification> SupportingTokens { get; }
    internal IPrincipal ThreadPrincipal { get; internal set; }
    public ClaimsPrincipal ClaimsPrincipal { get; internal set; }
    internal TransactionRpcFacet TransactionFacet { get; internal set; }
    public OperationContext(IContextChannel channel);
    internal OperationContext(ServiceHostBase host);
    internal OperationContext(ServiceHostBase host, MessageVersion outgoingMessageVersion);
    internal OperationContext(RequestContext requestContext, Message request, ServiceChannel channel, ServiceHostBase host);
    private static OperationContext();
    [CompilerGeneratedAttribute]
public void add_OperationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationCompleted(EventHandler value);
    public IContextChannel get_Channel();
    public static OperationContext get_Current();
    public static void set_Current(OperationContext value);
    internal static Holder get_CurrentHolder();
    public EndpointDispatcher get_EndpointDispatcher();
    public void set_EndpointDispatcher(EndpointDispatcher value);
    public bool get_IsUserContext();
    public sealed virtual IExtensionCollection`1<OperationContext> get_Extensions();
    internal bool get_IsServiceReentrant();
    internal void set_IsServiceReentrant(bool value);
    public bool get_HasSupportingTokens();
    public ServiceHostBase get_Host();
    internal Message get_IncomingMessage();
    internal ServiceChannel get_InternalServiceChannel();
    internal void set_InternalServiceChannel(ServiceChannel value);
    internal bool get_HasOutgoingMessageHeaders();
    public MessageHeaders get_OutgoingMessageHeaders();
    internal bool get_HasOutgoingMessageProperties();
    public MessageProperties get_OutgoingMessageProperties();
    internal MessageVersion get_OutgoingMessageVersion();
    public MessageHeaders get_IncomingMessageHeaders();
    public MessageProperties get_IncomingMessageProperties();
    public MessageVersion get_IncomingMessageVersion();
    public InstanceContext get_InstanceContext();
    public RequestContext get_RequestContext();
    public void set_RequestContext(RequestContext value);
    public ServiceSecurityContext get_ServiceSecurityContext();
    public string get_SessionId();
    public ICollection`1<SupportingTokenSpecification> get_SupportingTokens();
    internal IPrincipal get_ThreadPrincipal();
    internal void set_ThreadPrincipal(IPrincipal value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
internal void set_ClaimsPrincipal(ClaimsPrincipal value);
    internal TransactionRpcFacet get_TransactionFacet();
    internal void set_TransactionFacet(TransactionRpcFacet value);
    internal void ClearClientReplyNoThrow();
    internal static void EnableAsyncFlow();
    internal static void DisableAsyncFlow();
    internal void FireOperationCompleted();
    public T GetCallbackChannel();
    internal void ReInit(RequestContext requestContext, Message request, ServiceChannel channel);
    internal void Recycle();
    internal void SetClientReply(Message message, bool closeMessage);
    public void SetTransactionComplete();
    internal void SetInstanceContext(InstanceContext instanceContext);
}
public class System.ServiceModel.OperationContextScope : object {
    public OperationContextScope(IContextChannel channel);
    public OperationContextScope(OperationContext context);
    private static OperationContextScope();
    public sealed virtual void Dispose();
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.OperationContractAttribute : Attribute {
    internal static string ActionPropertyName;
    internal static string ProtectionLevelPropertyName;
    internal static string ReplyActionPropertyName;
    public string Name { get; public set; }
    public string Action { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public string ReplyAction { get; public set; }
    public bool AsyncPattern { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsInitiating { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Action();
    public void set_Action(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public string get_ReplyAction();
    public void set_ReplyAction(string value);
    public bool get_AsyncPattern();
    public void set_AsyncPattern(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void EnsureInvariants(MethodInfo methodInfo, string operationName);
}
public enum System.ServiceModel.OperationFormatStyle : Enum {
    public int value__;
    public static OperationFormatStyle Document;
    public static OperationFormatStyle Rpc;
}
internal static class System.ServiceModel.OperationFormatStyleHelper : object {
    public static bool IsDefined(OperationFormatStyle x);
}
public enum System.ServiceModel.OperationFormatUse : Enum {
    public int value__;
    public static OperationFormatUse Literal;
    public static OperationFormatUse Encoded;
}
internal static class System.ServiceModel.OperationFormatUseHelper : object {
    public static bool IsDefined(OperationFormatUse x);
}
public class System.ServiceModel.OptionalReliableSession : ReliableSession {
    public bool Enabled { get; public set; }
    public OptionalReliableSession(ReliableSessionBindingElement reliableSessionBindingElement);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    internal void CopySettings(OptionalReliableSession copyFrom);
}
internal static class System.ServiceModel.OSEnvironmentHelper : object {
    internal static bool IsVistaOrGreater { get; }
    internal static bool IsApplicationTargeting45 { get; }
    internal static int ProcessorCount { get; }
    private static OSEnvironmentHelper();
    internal static bool get_IsVistaOrGreater();
    internal static bool get_IsApplicationTargeting45();
    internal static int get_ProcessorCount();
    internal static bool IsAtLeast(OSVersion version);
}
internal enum System.ServiceModel.OSVersion : Enum {
    public int value__;
    public static OSVersion Unknown;
    public static OSVersion PreWinXP;
    public static OSVersion WinXP;
    public static OSVersion Win2003;
    public static OSVersion WinVista;
    public static OSVersion Win7;
    public static OSVersion Win8;
    public static OSVersion PostWin8;
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.PeerHopCountAttribute : MessageHeaderAttribute {
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    public string Namespace { get; }
    public string Name { get; }
    public ProtectionLevel ProtectionLevel { get; }
    public bool get_MustUnderstand();
    public bool get_Relay();
    public string get_Actor();
    public string get_Namespace();
    public string get_Name();
    public ProtectionLevel get_ProtectionLevel();
}
public enum System.ServiceModel.PeerMessageOrigination : Enum {
    public int value__;
    public static PeerMessageOrigination Local;
    public static PeerMessageOrigination Remote;
}
public enum System.ServiceModel.PeerMessagePropagation : Enum {
    public int value__;
    public static PeerMessagePropagation None;
    public static PeerMessagePropagation Local;
    public static PeerMessagePropagation Remote;
    public static PeerMessagePropagation LocalAndRemote;
}
public abstract class System.ServiceModel.PeerMessagePropagationFilter : object {
    public abstract virtual PeerMessagePropagation ShouldMessagePropagate(Message message, PeerMessageOrigination origination);
}
public class System.ServiceModel.PeerNode : object {
    public bool IsOnline { get; }
    internal bool IsOpen { get; }
    public int Port { get; }
    public PeerMessagePropagationFilter MessagePropagationFilter { get; public set; }
    internal PeerNodeImplementation InnerNode { get; }
    internal PeerNode(PeerNodeImplementation peerNode);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Offline(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Online(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Online(EventHandler value);
    internal void FireOffline(object source, EventArgs args);
    internal void FireOnline(object source, EventArgs args);
    public sealed virtual bool get_IsOnline();
    internal bool get_IsOpen();
    public int get_Port();
    public PeerMessagePropagationFilter get_MessagePropagationFilter();
    public void set_MessagePropagationFilter(PeerMessagePropagationFilter value);
    internal void OnOpen();
    internal void OnClose();
    internal PeerNodeImplementation get_InnerNode();
    public void RefreshConnection();
    public virtual string ToString();
}
[DataContractAttribute]
[KnownTypeAttribute("System.Net.IPAddress[]")]
public class System.ServiceModel.PeerNodeAddress : object {
    [DataMemberAttribute]
internal EndpointAddress10 InnerEPR { get; internal set; }
    [DataMemberAttribute]
internal IList`1<IPAddress> ipAddressesDataMember { get; internal set; }
    public EndpointAddress EndpointAddress { get; }
    internal string ServicePath { get; }
    public ReadOnlyCollection`1<IPAddress> IPAddresses { get; }
    public PeerNodeAddress(EndpointAddress endpointAddress, ReadOnlyCollection`1<IPAddress> ipAddresses);
    internal EndpointAddress10 get_InnerEPR();
    internal void set_InnerEPR(EndpointAddress10 value);
    internal IList`1<IPAddress> get_ipAddressesDataMember();
    internal void set_ipAddressesDataMember(IList`1<IPAddress> value);
    public EndpointAddress get_EndpointAddress();
    internal string get_ServicePath();
    public ReadOnlyCollection`1<IPAddress> get_IPAddresses();
}
public abstract class System.ServiceModel.PeerResolver : object {
    public bool CanShareReferrals { get; }
    public abstract virtual bool get_CanShareReferrals();
    public abstract virtual object Register(string meshId, PeerNodeAddress nodeAddress, TimeSpan timeout);
    public abstract virtual ReadOnlyCollection`1<PeerNodeAddress> Resolve(string meshId, int maxAddresses, TimeSpan timeout);
    public abstract virtual void Unregister(object registrationId, TimeSpan timeout);
    public abstract virtual void Update(object registrationId, PeerNodeAddress updatedNodeAddress, TimeSpan timeout);
    public virtual void Initialize(EndpointAddress address, Binding binding, ClientCredentials credentials, PeerReferralPolicy referralPolicy);
}
[ObsoleteAttribute("PeerChannel feature is obsolete and will be removed in the future.", "False")]
[ServiceBehaviorAttribute]
public class System.ServiceModel.PeerResolvers.CustomPeerResolverService : object {
    public TimeSpan CleanupInterval { get; public set; }
    public TimeSpan RefreshInterval { get; public set; }
    public bool ControlShape { get; public set; }
    public TimeSpan get_CleanupInterval();
    public void set_CleanupInterval(TimeSpan value);
    public TimeSpan get_RefreshInterval();
    public void set_RefreshInterval(TimeSpan value);
    public bool get_ControlShape();
    public void set_ControlShape(bool value);
    public virtual RegisterResponseInfo Register(Guid clientId, string meshId, PeerNodeAddress address);
    public virtual RegisterResponseInfo Register(RegisterInfo registerInfo);
    public virtual RegisterResponseInfo Update(UpdateInfo updateInfo);
    public virtual ResolveResponseInfo Resolve(ResolveInfo resolveInfo);
    public virtual void Unregister(UnregisterInfo unregisterInfo);
    public virtual RefreshResponseInfo Refresh(RefreshInfo refreshInfo);
    public virtual ServiceSettingsResponseInfo GetServiceSettings();
    public virtual void Open();
    public virtual void Close();
    internal virtual void CleanupActivity(object state);
}
internal interface System.ServiceModel.PeerResolvers.IPeerResolverClient {
}
[ServiceContractAttribute]
public interface System.ServiceModel.PeerResolvers.IPeerResolverContract {
    [OperationContractAttribute]
public abstract virtual RegisterResponseInfo Register(RegisterInfo registerInfo);
    [OperationContractAttribute]
public abstract virtual RegisterResponseInfo Update(UpdateInfo updateInfo);
    [OperationContractAttribute]
public abstract virtual ResolveResponseInfo Resolve(ResolveInfo resolveInfo);
    [OperationContractAttribute]
public abstract virtual void Unregister(UnregisterInfo unregisterInfo);
    [OperationContractAttribute]
public abstract virtual RefreshResponseInfo Refresh(RefreshInfo refreshInfo);
    [OperationContractAttribute]
public abstract virtual ServiceSettingsResponseInfo GetServiceSettings();
}
public class System.ServiceModel.PeerResolvers.PeerCustomResolverSettings : object {
    public EndpointAddress Address { get; public set; }
    public Binding Binding { get; public set; }
    public bool IsBindingSpecified { get; }
    public PeerResolver Resolver { get; public set; }
    internal string BindingSection { get; internal set; }
    internal string BindingConfiguration { get; internal set; }
    public EndpointAddress get_Address();
    public void set_Address(EndpointAddress value);
    public Binding get_Binding();
    public void set_Binding(Binding value);
    public bool get_IsBindingSpecified();
    public PeerResolver get_Resolver();
    public void set_Resolver(PeerResolver value);
    internal string get_BindingSection();
    internal void set_BindingSection(string value);
    internal string get_BindingConfiguration();
    internal void set_BindingConfiguration(string value);
}
internal class System.ServiceModel.PeerResolvers.PeerDefaultCustomResolverClient : PeerResolver {
    public bool CanShareReferrals { get; }
    internal string BindingName { get; internal set; }
    internal string BindingConfigurationName { get; internal set; }
    public virtual bool get_CanShareReferrals();
    public virtual void Initialize(EndpointAddress address, Binding binding, ClientCredentials credentials, PeerReferralPolicy referralPolicy);
    public virtual object Register(string meshId, PeerNodeAddress nodeAddress, TimeSpan timeout);
    public virtual void Unregister(object registrationId, TimeSpan timeout);
    public virtual void Update(object registrationId, PeerNodeAddress updatedNodeAddress, TimeSpan timeout);
    public virtual ReadOnlyCollection`1<PeerNodeAddress> Resolve(string meshId, int maxAddresses, TimeSpan timeout);
    internal string get_BindingName();
    internal void set_BindingName(string value);
    internal string get_BindingConfigurationName();
    internal void set_BindingConfigurationName(string value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public enum System.ServiceModel.PeerResolvers.PeerReferralPolicy : Enum {
    public int value__;
    public static PeerReferralPolicy Service;
    public static PeerReferralPolicy Share;
    public static PeerReferralPolicy DoNotShare;
}
internal static class System.ServiceModel.PeerResolvers.PeerReferralPolicyHelper : object {
    internal static bool IsDefined(PeerReferralPolicy value);
}
public enum System.ServiceModel.PeerResolvers.PeerResolverMode : Enum {
    public int value__;
    public static PeerResolverMode Auto;
    public static PeerResolverMode Pnrp;
    public static PeerResolverMode Custom;
}
internal static class System.ServiceModel.PeerResolvers.PeerResolverModeHelper : object {
    internal static bool IsDefined(PeerResolverMode value);
}
public class System.ServiceModel.PeerResolvers.PeerResolverSettings : object {
    public PeerResolverMode Mode { get; public set; }
    public PeerReferralPolicy ReferralPolicy { get; public set; }
    public PeerCustomResolverSettings Custom { get; }
    public PeerResolverMode get_Mode();
    public void set_Mode(PeerResolverMode value);
    public PeerReferralPolicy get_ReferralPolicy();
    public void set_ReferralPolicy(PeerReferralPolicy value);
    public PeerCustomResolverSettings get_Custom();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.RefreshInfo : object {
    public string MeshId { get; }
    public Guid RegistrationId { get; }
    public RefreshInfo(string meshId, Guid regId);
    public string get_MeshId();
    public Guid get_RegistrationId();
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.RefreshResponseInfo : object {
    public TimeSpan RegistrationLifetime { get; public set; }
    public RefreshResult Result { get; public set; }
    public RefreshResponseInfo(TimeSpan registrationLifetime, RefreshResult result);
    public TimeSpan get_RegistrationLifetime();
    public void set_RegistrationLifetime(TimeSpan value);
    public RefreshResult get_Result();
    public void set_Result(RefreshResult value);
    public bool HasBody();
}
public enum System.ServiceModel.PeerResolvers.RefreshResult : Enum {
    public int value__;
    public static RefreshResult Success;
    public static RefreshResult RegistrationNotFound;
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.RegisterInfo : object {
    public Guid ClientId { get; }
    public string MeshId { get; }
    public PeerNodeAddress NodeAddress { get; }
    public RegisterInfo(Guid client, string meshId, PeerNodeAddress address);
    public Guid get_ClientId();
    public string get_MeshId();
    public PeerNodeAddress get_NodeAddress();
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.RegisterResponseInfo : object {
    public Guid RegistrationId { get; public set; }
    public TimeSpan RegistrationLifetime { get; public set; }
    public RegisterResponseInfo(Guid registrationId, TimeSpan registrationLifetime);
    public Guid get_RegistrationId();
    public void set_RegistrationId(Guid value);
    public TimeSpan get_RegistrationLifetime();
    public void set_RegistrationLifetime(TimeSpan value);
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.ResolveInfo : object {
    public Guid ClientId { get; }
    public string MeshId { get; }
    public int MaxAddresses { get; }
    public ResolveInfo(Guid clientId, string meshId, int maxAddresses);
    public Guid get_ClientId();
    public string get_MeshId();
    public int get_MaxAddresses();
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.ResolveResponseInfo : object {
    public IList`1<PeerNodeAddress> Addresses { get; public set; }
    public ResolveResponseInfo(PeerNodeAddress[] addresses);
    public IList`1<PeerNodeAddress> get_Addresses();
    public void set_Addresses(IList`1<PeerNodeAddress> value);
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.ServiceSettingsResponseInfo : object {
    public bool ControlMeshShape { get; public set; }
    public ServiceSettingsResponseInfo(bool control);
    public bool get_ControlMeshShape();
    public void set_ControlMeshShape(bool value);
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.UnregisterInfo : object {
    public Guid RegistrationId { get; }
    public string MeshId { get; }
    public UnregisterInfo(string meshId, Guid registrationId);
    public Guid get_RegistrationId();
    public string get_MeshId();
    public bool HasBody();
}
[MessageContractAttribute]
public class System.ServiceModel.PeerResolvers.UpdateInfo : object {
    public Guid ClientId { get; }
    public Guid RegistrationId { get; }
    public string MeshId { get; }
    public PeerNodeAddress NodeAddress { get; }
    public UpdateInfo(Guid registrationId, Guid client, string meshId, PeerNodeAddress address);
    public Guid get_ClientId();
    public Guid get_RegistrationId();
    public string get_MeshId();
    public PeerNodeAddress get_NodeAddress();
    public bool HasBody();
}
public class System.ServiceModel.PeerSecuritySettings : object {
    internal static SecurityMode DefaultMode;
    public SecurityMode Mode { get; public set; }
    public PeerTransportSecuritySettings Transport { get; public set; }
    internal bool SupportsAuthentication { get; }
    internal ProtectionLevel SupportedProtectionLevel { get; }
    internal PeerSecuritySettings(PeerSecuritySettings other);
    internal PeerSecuritySettings(PeerSecurityElement element);
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public PeerTransportSecuritySettings get_Transport();
    public void set_Transport(PeerTransportSecuritySettings value);
    internal bool get_SupportsAuthentication();
    internal ProtectionLevel get_SupportedProtectionLevel();
    internal void OnImportPolicy(MetadataImporter importer, PolicyConversionContext context);
    internal void OnExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMode();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransport();
}
public enum System.ServiceModel.PeerTransportCredentialType : Enum {
    public int value__;
    public static PeerTransportCredentialType Password;
    public static PeerTransportCredentialType Certificate;
}
internal static class System.ServiceModel.PeerTransportCredentialTypeHelper : object {
    internal static bool IsDefined(PeerTransportCredentialType value);
}
public class System.ServiceModel.PeerTransportSecuritySettings : object {
    internal static PeerTransportCredentialType DefaultCredentialType;
    public PeerTransportCredentialType CredentialType { get; public set; }
    internal PeerTransportSecuritySettings(PeerTransportSecuritySettings other);
    internal PeerTransportSecuritySettings(PeerTransportSecurityElement element);
    public PeerTransportCredentialType get_CredentialType();
    public void set_CredentialType(PeerTransportCredentialType value);
    internal void OnImportPolicy(MetadataImporter importer, PolicyConversionContext context);
    internal void OnExportPolicy(MetadataExporter exporter, PolicyConversionContext context);
}
internal class System.ServiceModel.PeerWireStringsDictionary : object {
    public XmlDictionaryString FloodAction;
    public XmlDictionaryString LinkUtilityAction;
    public XmlDictionaryString HopCount;
    public XmlDictionaryString HopCountNamespace;
    public XmlDictionaryString PeerVia;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Demuxer;
    public XmlDictionaryString PeerTo;
    public PeerWireStringsDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.PeerWireStringsStrings : object {
    public static string FloodAction;
    public static string LinkUtilityAction;
    public static string HopCount;
    public static string HopCountNamespace;
    public static string PeerVia;
    public static string Namespace;
    public static string Demuxer;
    public static string PeerTo;
}
public class System.ServiceModel.PoisonMessageException : CommunicationException {
    public PoisonMessageException(string message);
    public PoisonMessageException(string message, Exception innerException);
    protected PoisonMessageException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.PolicyDictionary : object {
    public XmlDictionaryString Namespace;
    public PolicyDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.PolicyStrings : object {
    public static string Namespace;
}
internal class System.ServiceModel.Pool`1 : object {
    public int Count { get; }
    public Pool`1(int maxCount);
    public int get_Count();
    public T Take();
    public bool Return(T item);
    public void Clear();
}
internal class System.ServiceModel.ProgrammaticEndpointTrait`1 : EndpointTrait`1<TChannel> {
    public ProgrammaticEndpointTrait`1(Binding binding, EndpointAddress remoteAddress, InstanceContext callbackInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ChannelFactory`1<TChannel> CreateChannelFactory();
}
public class System.ServiceModel.ProtocolException : CommunicationException {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    protected ProtocolException(SerializationInfo info, StreamingContext context);
    internal static ProtocolException ReceiveShutdownReturnedNonNull(Message message);
    internal static ProtocolException OneWayOperationReturnedNonNull(Message message);
}
public enum System.ServiceModel.QueuedDeliveryRequirementsMode : Enum {
    public int value__;
    public static QueuedDeliveryRequirementsMode Allowed;
    public static QueuedDeliveryRequirementsMode Required;
    public static QueuedDeliveryRequirementsMode NotAllowed;
}
internal static class System.ServiceModel.QueuedDeliveryRequirementsModeHelper : object {
    public static bool IsDefined(QueuedDeliveryRequirementsMode x);
}
public enum System.ServiceModel.QueueTransferProtocol : Enum {
    public int value__;
    public static QueueTransferProtocol Native;
    public static QueueTransferProtocol Srmp;
    public static QueueTransferProtocol SrmpSecure;
}
internal static class System.ServiceModel.QueueTransferProtocolHelper : object {
    public static bool IsDefined(QueueTransferProtocol mode);
}
public class System.ServiceModel.QuotaExceededException : SystemException {
    public QuotaExceededException(string message);
    public QuotaExceededException(string message, Exception innerException);
    protected QuotaExceededException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.ReceiveContextEnabledAttribute : Attribute {
    public bool ManualControl { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ManualControl();
    [CompilerGeneratedAttribute]
public void set_ManualControl(bool value);
    public sealed virtual void Validate(OperationDescription operationDescription);
    public sealed virtual void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    public sealed virtual void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    public sealed virtual void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
}
public enum System.ServiceModel.ReceiveErrorHandling : Enum {
    public int value__;
    public static ReceiveErrorHandling Fault;
    public static ReceiveErrorHandling Drop;
    public static ReceiveErrorHandling Reject;
    public static ReceiveErrorHandling Move;
}
internal static class System.ServiceModel.ReceiveErrorHandlingHelper : object {
    internal static bool IsDefined(ReceiveErrorHandling value);
}
public enum System.ServiceModel.ReleaseInstanceMode : Enum {
    public int value__;
    public static ReleaseInstanceMode None;
    public static ReleaseInstanceMode BeforeCall;
    public static ReleaseInstanceMode AfterCall;
    public static ReleaseInstanceMode BeforeAndAfterCall;
}
internal static class System.ServiceModel.ReleaseInstanceModeHelper : object {
    public static bool IsDefined(ReleaseInstanceMode x);
}
[TypeConverterAttribute("System.ServiceModel.Configuration.ReliableMessagingVersionConverter")]
public abstract class System.ServiceModel.ReliableMessagingVersion : object {
    public static ReliableMessagingVersion Default { get; }
    public static ReliableMessagingVersion WSReliableMessaging11 { get; }
    public static ReliableMessagingVersion WSReliableMessagingFebruary2005 { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    internal string Namespace { get; }
    internal ReliableMessagingVersion(string ns, XmlDictionaryString dictionaryNs);
    public static ReliableMessagingVersion get_Default();
    public static ReliableMessagingVersion get_WSReliableMessaging11();
    public static ReliableMessagingVersion get_WSReliableMessagingFebruary2005();
    internal XmlDictionaryString get_DictionaryNamespace();
    internal string get_Namespace();
    internal static bool IsDefined(ReliableMessagingVersion reliableMessagingVersion);
}
public class System.ServiceModel.ReliableSession : object {
    [DefaultValueAttribute("True")]
public bool Ordered { get; public set; }
    public TimeSpan InactivityTimeout { get; public set; }
    public ReliableSession(ReliableSessionBindingElement reliableSessionBindingElement);
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    internal void CopySettings(ReliableSession copyFrom);
}
public class System.ServiceModel.RsaEndpointIdentity : EndpointIdentity {
    public RsaEndpointIdentity(string publicKey);
    public RsaEndpointIdentity(X509Certificate2 certificate);
    public RsaEndpointIdentity(Claim identity);
    internal RsaEndpointIdentity(XmlDictionaryReader reader);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.SamlDictionary : object {
    public XmlDictionaryString Access;
    public XmlDictionaryString AccessDecision;
    public XmlDictionaryString Action;
    public XmlDictionaryString Advice;
    public XmlDictionaryString Assertion;
    public XmlDictionaryString AssertionId;
    public XmlDictionaryString AssertionIdReference;
    public XmlDictionaryString Attribute;
    public XmlDictionaryString AttributeName;
    public XmlDictionaryString AttributeNamespace;
    public XmlDictionaryString AttributeStatement;
    public XmlDictionaryString AttributeValue;
    public XmlDictionaryString Audience;
    public XmlDictionaryString AudienceRestrictionCondition;
    public XmlDictionaryString AuthenticationInstant;
    public XmlDictionaryString AuthenticationMethod;
    public XmlDictionaryString AuthenticationStatement;
    public XmlDictionaryString AuthorityBinding;
    public XmlDictionaryString AuthorityKind;
    public XmlDictionaryString AuthorizationDecisionStatement;
    public XmlDictionaryString Binding;
    public XmlDictionaryString Condition;
    public XmlDictionaryString Conditions;
    public XmlDictionaryString Decision;
    public XmlDictionaryString DoNotCacheCondition;
    public XmlDictionaryString Evidence;
    public XmlDictionaryString IssueInstant;
    public XmlDictionaryString Issuer;
    public XmlDictionaryString Location;
    public XmlDictionaryString MajorVersion;
    public XmlDictionaryString MinorVersion;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NameIdentifier;
    public XmlDictionaryString NameIdentifierFormat;
    public XmlDictionaryString NameIdentifierNameQualifier;
    public XmlDictionaryString ActionNamespaceAttribute;
    public XmlDictionaryString NotBefore;
    public XmlDictionaryString NotOnOrAfter;
    public XmlDictionaryString PreferredPrefix;
    public XmlDictionaryString Statement;
    public XmlDictionaryString Subject;
    public XmlDictionaryString SubjectConfirmation;
    public XmlDictionaryString SubjectConfirmationData;
    public XmlDictionaryString SubjectConfirmationMethod;
    public XmlDictionaryString HolderOfKey;
    public XmlDictionaryString SenderVouches;
    public XmlDictionaryString SubjectLocality;
    public XmlDictionaryString SubjectLocalityDNSAddress;
    public XmlDictionaryString SubjectLocalityIPAddress;
    public XmlDictionaryString SubjectStatement;
    public XmlDictionaryString UnspecifiedAuthenticationMethod;
    public XmlDictionaryString NamespaceAttributePrefix;
    public XmlDictionaryString Resource;
    public XmlDictionaryString UserName;
    public XmlDictionaryString UserNameNamespace;
    public XmlDictionaryString EmailName;
    public XmlDictionaryString EmailNamespace;
    public SamlDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal class System.ServiceModel.SCTServiceAuthenticationManagerWrapper : ServiceAuthenticationManager {
    internal SCTServiceAuthenticationManagerWrapper(ServiceAuthenticationManager wrappedServiceAuthManager);
    public virtual ReadOnlyCollection`1<IAuthorizationPolicy> Authenticate(ReadOnlyCollection`1<IAuthorizationPolicy> authPolicy, Uri listenUri, Message& message);
}
internal class System.ServiceModel.SecureConversationApr2004Dictionary : SecureConversationDictionary {
    public SecureConversationApr2004Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecureConversationApr2004Strings : object {
    public static string SecurityContextToken;
    public static string DerivedKeyToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Length;
    public static string Nonce;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string Prefix;
    public static string Namespace;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
}
internal class System.ServiceModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public List`1<XmlDictionaryString> SecureConversationDictionaryStrings;
    public SecureConversationDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecureConversationDec2005();
}
internal static class System.ServiceModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.ServiceModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public SecureConversationDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public SecureConversationFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.ServiceModel.SecureConversationStrings : object {
}
internal class System.ServiceModel.Security.AcceleratedTokenAuthenticator : NegotiationTokenAuthenticator`1<NegotiationTokenAuthenticatorState> {
    public bool PreserveBootstrapTokens { get; public set; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    protected bool IsMultiLegNegotiation { get; }
    public bool get_PreserveBootstrapTokens();
    public void set_PreserveBootstrapTokens(bool value);
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseFinalAction();
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    protected virtual bool get_IsMultiLegNegotiation();
    protected virtual MessageFilter GetListenerFilter();
    protected virtual Binding GetNegotiationBinding(Binding binding);
    internal IChannelListener`1<TChannel> BuildNegotiationChannelListener(BindingContext context);
    protected virtual BodyWriter ProcessRequestSecurityToken(Message request, RequestSecurityToken requestSecurityToken, NegotiationTokenAuthenticatorState& negotiationState);
    protected virtual BodyWriter ProcessRequestSecurityTokenResponse(NegotiationTokenAuthenticatorState negotiationState, Message request, RequestSecurityTokenResponse requestSecurityTokenResponse);
}
internal class System.ServiceModel.Security.AcceleratedTokenAuthenticatorBindingElement : BindingElement {
    public AcceleratedTokenAuthenticatorBindingElement(AcceleratedTokenAuthenticator authenticator);
    public virtual IChannelListener`1<TChannel> BuildChannelListener(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
}
internal class System.ServiceModel.Security.AcceleratedTokenProvider : NegotiationTokenProvider`1<AcceleratedTokenProviderState> {
    internal static SecurityKeyEntropyMode defaultKeyEntropyMode;
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public Uri PrivacyNoticeUri { get; public set; }
    public int PrivacyNoticeVersion { get; public set; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    protected bool IsMultiLegNegotiation { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public AcceleratedTokenProvider(SafeFreeCredentials credentialsHandle);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public Uri get_PrivacyNoticeUri();
    public void set_PrivacyNoticeUri(Uri value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    protected virtual bool get_IsMultiLegNegotiation();
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpening();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual IChannelFactory`1<IRequestChannel> GetNegotiationChannelFactory(IChannelFactory`1<IRequestChannel> transportChannelFactory, ChannelBuilder channelBuilder);
    protected virtual IRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    protected virtual bool CreateNegotiationStateCompletesSynchronously(EndpointAddress target, Uri via);
    protected virtual AcceleratedTokenProviderState CreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout);
    protected virtual IAsyncResult BeginCreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual AcceleratedTokenProviderState EndCreateNegotiationState(IAsyncResult result);
    protected virtual BodyWriter GetFirstOutgoingMessageBody(AcceleratedTokenProviderState negotiationState, MessageProperties& messageProperties);
    protected virtual BodyWriter GetNextOutgoingMessageBody(Message incomingMessage, AcceleratedTokenProviderState negotiationState);
}
internal class System.ServiceModel.Security.AcceleratedTokenProviderState : IssuanceTokenProviderState {
    public AcceleratedTokenProviderState(Byte[] value);
    public Byte[] GetRequestorEntropy();
}
internal class System.ServiceModel.Security.AcceptorSessionSymmetricMessageSecurityProtocol : MessageSecurityProtocol {
    public bool ReturnCorrelationState { get; public set; }
    protected bool PerformIncomingAndOutgoingMessageExpectationChecks { get; }
    public AcceptorSessionSymmetricMessageSecurityProtocol(SessionSymmetricMessageSecurityProtocolFactory factory, EndpointAddress target);
    public sealed virtual bool get_ReturnCorrelationState();
    public sealed virtual void set_ReturnCorrelationState(bool value);
    protected virtual bool get_PerformIncomingAndOutgoingMessageExpectationChecks();
    public sealed virtual SecurityToken GetOutgoingSessionToken();
    public sealed virtual void SetOutgoingSessionToken(SecurityToken token);
    public sealed virtual void SetSessionTokenAuthenticator(UniqueId sessionId, SecurityTokenAuthenticator sessionTokenAuthenticator, SecurityTokenResolver sessionTokenResolver);
    protected virtual IAsyncResult BeginSecureOutgoingMessageCore(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    protected virtual SecurityProtocolCorrelationState SecureOutgoingMessageCore(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual void EndSecureOutgoingMessageCore(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    protected virtual SecurityProtocolCorrelationState VerifyIncomingMessageCore(Message& message, string actor, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
}
internal class System.ServiceModel.Security.AcceptorSessionSymmetricTransportSecurityProtocol : TransportSecurityProtocol {
    public bool ReturnCorrelationState { get; public set; }
    public AcceptorSessionSymmetricTransportSecurityProtocol(SessionSymmetricTransportSecurityProtocolFactory factory);
    public sealed virtual bool get_ReturnCorrelationState();
    public sealed virtual void set_ReturnCorrelationState(bool value);
    public sealed virtual void SetSessionTokenAuthenticator(UniqueId sessionId, SecurityTokenAuthenticator sessionTokenAuthenticator, SecurityTokenResolver sessionTokenResolver);
    public sealed virtual SecurityToken GetOutgoingSessionToken();
    public sealed virtual void SetOutgoingSessionToken(SecurityToken token);
    protected virtual void VerifyIncomingMessageCore(Message& message, TimeSpan timeout);
}
internal class System.ServiceModel.Security.AggregateSecurityHeaderTokenResolver : AggregateTokenResolver {
    public AggregateSecurityHeaderTokenResolver(SecurityHeaderTokenResolver tokenResolver, ReadOnlyCollection`1<SecurityTokenResolver> outOfBandTokenResolvers);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
}
internal abstract class System.ServiceModel.Security.ApplySecurityAndSendAsyncResult`1 : AsyncResult {
    protected SecurityProtocolCorrelationState CorrelationState { get; }
    protected SecurityProtocol SecurityProtocol { get; }
    public ApplySecurityAndSendAsyncResult`1(SecurityProtocol binding, MessageSenderType channel, TimeSpan timeout, AsyncCallback callback, object state);
    private static ApplySecurityAndSendAsyncResult`1();
    protected SecurityProtocolCorrelationState get_CorrelationState();
    protected SecurityProtocol get_SecurityProtocol();
    protected void Begin(Message message, SecurityProtocolCorrelationState correlationState);
    protected static void OnEnd(ApplySecurityAndSendAsyncResult`1<MessageSenderType> self);
    protected abstract virtual IAsyncResult BeginSendCore(MessageSenderType channel, Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void EndSendCore(MessageSenderType channel, IAsyncResult result);
    protected abstract virtual void OnSendCompleteCore(TimeSpan timeout);
}
internal class System.ServiceModel.Security.AsymmetricSecurityProtocol : MessageSecurityProtocol {
    protected bool DoAutomaticEncryptionMatch { get; }
    public SecurityTokenProvider InitiatorCryptoTokenProvider { get; }
    public SecurityTokenAuthenticator InitiatorAsymmetricTokenAuthenticator { get; }
    public SecurityTokenProvider InitiatorAsymmetricTokenProvider { get; }
    public AsymmetricSecurityProtocol(AsymmetricSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    protected virtual bool get_DoAutomaticEncryptionMatch();
    public SecurityTokenProvider get_InitiatorCryptoTokenProvider();
    public SecurityTokenAuthenticator get_InitiatorAsymmetricTokenAuthenticator();
    public SecurityTokenProvider get_InitiatorAsymmetricTokenProvider();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult BeginSecureOutgoingMessageCore(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    protected virtual void EndSecureOutgoingMessageCore(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    protected virtual SecurityProtocolCorrelationState SecureOutgoingMessageCore(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual SecurityProtocolCorrelationState VerifyIncomingMessageCore(Message& message, string actor, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
}
internal class System.ServiceModel.Security.AsymmetricSecurityProtocolFactory : MessageSecurityProtocolFactory {
    public bool AllowSerializedSigningTokenOnReply { get; public set; }
    public SecurityTokenParameters AsymmetricTokenParameters { get; public set; }
    public SecurityTokenProvider RecipientAsymmetricTokenProvider { get; }
    public SecurityTokenAuthenticator RecipientCryptoTokenAuthenticator { get; }
    public ReadOnlyCollection`1<SecurityTokenResolver> RecipientOutOfBandTokenResolverList { get; }
    public SecurityTokenParameters CryptoTokenParameters { get; public set; }
    internal AsymmetricSecurityProtocolFactory(AsymmetricSecurityProtocolFactory factory);
    public bool get_AllowSerializedSigningTokenOnReply();
    public void set_AllowSerializedSigningTokenOnReply(bool value);
    public SecurityTokenParameters get_AsymmetricTokenParameters();
    public void set_AsymmetricTokenParameters(SecurityTokenParameters value);
    public SecurityTokenProvider get_RecipientAsymmetricTokenProvider();
    public SecurityTokenAuthenticator get_RecipientCryptoTokenAuthenticator();
    public ReadOnlyCollection`1<SecurityTokenResolver> get_RecipientOutOfBandTokenResolverList();
    public SecurityTokenParameters get_CryptoTokenParameters();
    public void set_CryptoTokenParameters(SecurityTokenParameters value);
    public virtual EndpointIdentity GetIdentityOfSelf();
    public virtual T GetProperty();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
}
internal class System.ServiceModel.Security.Basic128Rsa15SecurityAlgorithmSuite : Basic128SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    public virtual string ToString();
}
public class System.ServiceModel.Security.Basic128SecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic128Sha256Rsa15SecurityAlgorithmSuite : Basic128Rsa15SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic128Sha256SecurityAlgorithmSuite : Basic128SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic192Rsa15SecurityAlgorithmSuite : Basic192SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    public virtual string ToString();
}
public class System.ServiceModel.Security.Basic192SecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic192Sha256Rsa15SecurityAlgorithmSuite : Basic192Rsa15SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic192Sha256SecurityAlgorithmSuite : Basic192SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic256Rsa15SecurityAlgorithmSuite : Basic256SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    public virtual string ToString();
}
public class System.ServiceModel.Security.Basic256SecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic256Sha256Rsa15SecurityAlgorithmSuite : Basic256Rsa15SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Basic256Sha256SecurityAlgorithmSuite : Basic256SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.BasicSecurityProfileVersion : object {
    public static BasicSecurityProfileVersion BasicSecurityProfile10 { get; }
    public static BasicSecurityProfileVersion get_BasicSecurityProfile10();
}
internal class System.ServiceModel.Security.BinaryNegotiation : object {
    public string ValueTypeUri { get; }
    public BinaryNegotiation(string valueTypeUri, Byte[] negotiationData);
    public BinaryNegotiation(XmlDictionaryString valueTypeDictionaryString, Byte[] negotiationData);
    public void Validate(XmlDictionaryString valueTypeUriDictionaryString);
    public void WriteTo(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, XmlDictionaryString valueTypeLocalName, XmlDictionaryString valueTypeNs);
    public string get_ValueTypeUri();
    public Byte[] GetNegotiationData();
}
public class System.ServiceModel.Security.ChannelProtectionRequirements : object {
    public bool IsReadOnly { get; }
    public ScopedMessagePartSpecification IncomingSignatureParts { get; }
    public ScopedMessagePartSpecification IncomingEncryptionParts { get; }
    public ScopedMessagePartSpecification OutgoingSignatureParts { get; }
    public ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
    public ChannelProtectionRequirements(ChannelProtectionRequirements other);
    internal ChannelProtectionRequirements(ChannelProtectionRequirements other, ProtectionLevel newBodyProtectionLevel);
    public bool get_IsReadOnly();
    public ScopedMessagePartSpecification get_IncomingSignatureParts();
    public ScopedMessagePartSpecification get_IncomingEncryptionParts();
    public ScopedMessagePartSpecification get_OutgoingSignatureParts();
    public ScopedMessagePartSpecification get_OutgoingEncryptionParts();
    public void Add(ChannelProtectionRequirements protectionRequirements);
    public void Add(ChannelProtectionRequirements protectionRequirements, bool channelScopeOnly);
    public void MakeReadOnly();
    public ChannelProtectionRequirements CreateInverse();
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    internal static ChannelProtectionRequirements CreateFromContractAndUnionResponseProtectionRequirements(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ProtectionLevel defaultRequestProtectionLevel, ProtectionLevel defaultResponseProtectionLevel, bool isForClient);
}
internal class System.ServiceModel.Security.ClaimStringValueComparer : object {
    public sealed virtual bool Equals(Claim claim1, Claim claim2);
    public sealed virtual int GetHashCode(Claim claim);
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public virtual void OnFaulted();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenProvider : SecurityTokenProvider {
    internal EventTraceActivity EventTraceActivity { get; }
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal EventTraceActivity get_EventTraceActivity();
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public virtual void OnFaulted();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal static class System.ServiceModel.Security.ContextImportHelper : object {
    internal static XmlDictionaryReader CreateSplicedReader(Byte[] decryptedBuffer, XmlAttributeHolder[] outerContext1, XmlAttributeHolder[] outerContext2, XmlAttributeHolder[] outerContext3, XmlDictionaryReaderQuotas quotas);
    internal static string GetPrefixIfNamespaceDeclaration(string prefix, string localName);
    internal static Byte[] SpliceBuffers(Byte[] middle, Byte[] wrapper, int wrapperLength, int wrappingDepth);
}
internal static class System.ServiceModel.Security.CryptoHelper : object {
    internal static Byte[] EmptyBuffer { get; }
    private static CryptoHelper();
    internal static Byte[] get_EmptyBuffer();
    internal static HashAlgorithm NewSha1HashAlgorithm();
    internal static HashAlgorithm NewSha256HashAlgorithm();
    internal static HashAlgorithm CreateHashAlgorithm(string digestMethod);
    internal static HashAlgorithm CreateHashForAsymmetricSignature(string signatureMethod);
    internal static Byte[] ExtractIVAndDecrypt(SymmetricAlgorithm algorithm, Byte[] cipherText, int offset, int count);
    internal static void FillRandomBytes(Byte[] buffer);
    internal static Byte[] GenerateIVAndEncrypt(SymmetricAlgorithm algorithm, Byte[] plainText, int offset, int count);
    internal static void GenerateIVAndEncrypt(SymmetricAlgorithm algorithm, ArraySegment`1<byte> plainText, Byte[]& iv, Byte[]& cipherText);
    internal static bool IsEqual(Byte[] a, Byte[] b);
    internal static bool IsSymmetricAlgorithm(string algorithm);
    internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize);
    internal static void ValidateBufferBounds(Array buffer, int offset, int count);
    internal static void ValidateSymmetricKeyLength(int keyLength, SecurityAlgorithmSuite algorithmSuite);
}
public class System.ServiceModel.Security.DataProtectionSecurityStateEncoder : SecurityStateEncoder {
    public bool UseCurrentUserProtectionScope { get; }
    public DataProtectionSecurityStateEncoder(bool useCurrentUserProtectionScope);
    public DataProtectionSecurityStateEncoder(bool useCurrentUserProtectionScope, Byte[] entropy);
    public bool get_UseCurrentUserProtectionScope();
    public Byte[] GetEntropy();
    public virtual string ToString();
    protected internal virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal virtual Byte[] EncodeSecurityState(Byte[] data);
}
internal class System.ServiceModel.Security.DecryptedHeader : ReadableMessageHeader {
    public string Actor { get; }
    public string Id { get; }
    public bool IsReferenceParameter { get; }
    public bool MustUnderstand { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool Relay { get; }
    public DecryptedHeader(Byte[] decryptedBuffer, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes, MessageVersion version, SignatureTargetIdManager idManager, XmlDictionaryReaderQuotas quotas);
    public virtual string get_Actor();
    public string get_Id();
    public virtual bool get_IsReferenceParameter();
    public virtual bool get_MustUnderstand();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_Relay();
    public virtual XmlDictionaryReader GetHeaderReader();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
}
internal abstract class System.ServiceModel.Security.DelegatingHeader : MessageHeader {
    public bool MustUnderstand { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool Relay { get; }
    public string Actor { get; }
    protected MessageHeader InnerHeader { get; }
    protected DelegatingHeader(MessageHeader innerHeader);
    public virtual bool get_MustUnderstand();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_Relay();
    public virtual string get_Actor();
    protected MessageHeader get_InnerHeader();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Security.DerivedKeyCachingSecurityTokenSerializer : SecurityTokenSerializer {
    internal DerivedKeyCachingSecurityTokenSerializer(int cacheSize, bool isInitiator, WSSecureConversation secureConversation, SecurityTokenSerializer innerTokenSerializer);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
}
public class System.ServiceModel.Security.DispatchContext : object {
    public ClaimsPrincipal Principal { get; public set; }
    public string RequestAction { get; public set; }
    public WSTrustMessage RequestMessage { get; public set; }
    public string ResponseAction { get; public set; }
    public RequestSecurityTokenResponse ResponseMessage { get; public set; }
    public SecurityTokenService SecurityTokenService { get; public set; }
    public string TrustNamespace { get; public set; }
    public ClaimsPrincipal get_Principal();
    public void set_Principal(ClaimsPrincipal value);
    public string get_RequestAction();
    public void set_RequestAction(string value);
    public WSTrustMessage get_RequestMessage();
    public void set_RequestMessage(WSTrustMessage value);
    public string get_ResponseAction();
    public void set_ResponseAction(string value);
    public RequestSecurityTokenResponse get_ResponseMessage();
    public void set_ResponseMessage(RequestSecurityTokenResponse value);
    public SecurityTokenService get_SecurityTokenService();
    public void set_SecurityTokenService(SecurityTokenService value);
    public string get_TrustNamespace();
    public void set_TrustNamespace(string value);
}
internal class System.ServiceModel.Security.DuplexSecurityProtocolFactory : SecurityProtocolFactory {
    public SecurityProtocolFactory ForwardProtocolFactory { get; public set; }
    public bool RequireSecurityOnBothDuplexDirections { get; public set; }
    public SecurityProtocolFactory ReverseProtocolFactory { get; public set; }
    public bool SupportsDuplex { get; }
    public bool SupportsReplayDetection { get; }
    public bool SupportsRequestReply { get; }
    public DuplexSecurityProtocolFactory(SecurityProtocolFactory forwardProtocolFactory, SecurityProtocolFactory reverseProtocolFactory);
    public SecurityProtocolFactory get_ForwardProtocolFactory();
    public void set_ForwardProtocolFactory(SecurityProtocolFactory value);
    public bool get_RequireSecurityOnBothDuplexDirections();
    public void set_RequireSecurityOnBothDuplexDirections(bool value);
    public SecurityProtocolFactory get_ReverseProtocolFactory();
    public void set_ReverseProtocolFactory(SecurityProtocolFactory value);
    public virtual bool get_SupportsDuplex();
    public virtual bool get_SupportsReplayDetection();
    public virtual bool get_SupportsRequestReply();
    public virtual EndpointIdentity GetIdentityOfSelf();
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
}
internal static class System.ServiceModel.Security.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal class System.ServiceModel.Security.EncryptedData : EncryptedType {
    internal static XmlDictionaryString ElementName;
    internal static string ElementType;
    internal static string ContentType;
    protected XmlDictionaryString OpeningElementName { get; }
    private static EncryptedData();
    protected virtual XmlDictionaryString get_OpeningElementName();
    protected virtual void ForceEncryption();
    public Byte[] GetDecryptedBuffer();
    protected virtual void ReadCipherData(XmlDictionaryReader reader);
    protected virtual void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize);
    public void SetUpDecryption(SymmetricAlgorithm algorithm);
    public void SetUpEncryption(SymmetricAlgorithm algorithm, ArraySegment`1<byte> buffer);
    protected virtual void WriteCipherData(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.EncryptedHeader : DelegatingHeader {
    public string Id { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string Actor { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    internal MessageHeader OriginalHeader { get; }
    public EncryptedHeader(MessageHeader plainTextHeader, EncryptedHeaderXml headerXml, string name, string namespaceUri, MessageVersion version);
    public string get_Id();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual string get_Actor();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    internal MessageHeader get_OriginalHeader();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Security.EncryptedHeaderXml : object {
    internal static XmlDictionaryString ElementName;
    internal static XmlDictionaryString NamespaceUri;
    public string Actor { get; public set; }
    public string EncryptionMethod { get; public set; }
    public XmlDictionaryString EncryptionMethodDictionaryString { get; public set; }
    public bool HasId { get; }
    public string Id { get; public set; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public SecurityTokenSerializer SecurityTokenSerializer { get; public set; }
    public EncryptedHeaderXml(MessageVersion version, bool shouldReadXmlReferenceKeyInfoClause);
    private static EncryptedHeaderXml();
    public string get_Actor();
    public void set_Actor(string value);
    public string get_EncryptionMethod();
    public void set_EncryptionMethod(string value);
    public XmlDictionaryString get_EncryptionMethodDictionaryString();
    public void set_EncryptionMethodDictionaryString(XmlDictionaryString value);
    public bool get_HasId();
    public string get_Id();
    public void set_Id(string value);
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public SecurityTokenSerializer get_SecurityTokenSerializer();
    public void set_SecurityTokenSerializer(SecurityTokenSerializer value);
    public Byte[] GetDecryptedBuffer();
    public void ReadFrom(XmlDictionaryReader reader, long maxBufferSize);
    public void SetUpDecryption(SymmetricAlgorithm algorithm);
    public void SetUpEncryption(SymmetricAlgorithm algorithm, MemoryStream source);
    public void WriteHeaderElement(XmlDictionaryWriter writer);
    public void WriteHeaderId(XmlDictionaryWriter writer);
    public void WriteHeaderContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Security.ExpiredSecurityTokenException : MessageSecurityException {
    public ExpiredSecurityTokenException(string message);
    public ExpiredSecurityTokenException(string message, Exception innerException);
    protected ExpiredSecurityTokenException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Security.FederatedSecurityTokenManager : ServiceCredentialsSecurityTokenManager {
    public SecurityTokenHandlerCollection SecurityTokenHandlers { get; }
    public ExceptionMapper ExceptionMapper { get; public set; }
    public FederatedSecurityTokenManager(ServiceCredentials parentCredentials);
    private static FederatedSecurityTokenManager();
    public SecurityTokenHandlerCollection get_SecurityTokenHandlers();
    public ExceptionMapper get_ExceptionMapper();
    public void set_ExceptionMapper(ExceptionMapper value);
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
    public virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    internal static SecurityVersion GetSecurityVersion(SecurityTokenVersion tokenVersion);
    public static string GetNormalizedEndpointId(SecurityTokenRequirement tokenRequirement);
}
internal class System.ServiceModel.Security.GetInfoCardTokenCallback : MulticastDelegate {
    public GetInfoCardTokenCallback(object object, IntPtr method);
    public virtual SecurityToken Invoke(bool requiresInfoCard, CardSpacePolicyElement[] chain, SecurityTokenSerializer tokenSerializer);
    public virtual IAsyncResult BeginInvoke(bool requiresInfoCard, CardSpacePolicyElement[] chain, SecurityTokenSerializer tokenSerializer, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Security.GetTokenUIAsyncResult : AsyncResult {
    internal GetTokenUIAsyncResult(Binding binding, IClientChannel channel, ClientCredentials credentials, AsyncCallback callback, object state);
    private static GetTokenUIAsyncResult();
    internal static void End(IAsyncResult result);
}
public class System.ServiceModel.Security.HttpDigestClientCredential : object {
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    public NetworkCredential ClientCredential { get; public set; }
    internal HttpDigestClientCredential(HttpDigestClientCredential other);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    internal void MakeReadOnly();
}
internal interface System.ServiceModel.Security.IAcceptorSecuritySessionProtocol {
    public bool ReturnCorrelationState { get; public set; }
    public abstract virtual bool get_ReturnCorrelationState();
    public abstract virtual void set_ReturnCorrelationState(bool value);
    public abstract virtual SecurityToken GetOutgoingSessionToken();
    public abstract virtual void SetOutgoingSessionToken(SecurityToken token);
    public abstract virtual void SetSessionTokenAuthenticator(UniqueId sessionId, SecurityTokenAuthenticator sessionTokenAuthenticator, SecurityTokenResolver sessionTokenResolver);
}
internal interface System.ServiceModel.Security.IChannelSecureConversationSessionSettings {
    public TimeSpan KeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public bool TolerateTransportFailures { get; public set; }
    public abstract virtual TimeSpan get_KeyRenewalInterval();
    public abstract virtual void set_KeyRenewalInterval(TimeSpan value);
    public abstract virtual TimeSpan get_KeyRolloverInterval();
    public abstract virtual void set_KeyRolloverInterval(TimeSpan value);
    public abstract virtual bool get_TolerateTransportFailures();
    public abstract virtual void set_TolerateTransportFailures(bool value);
}
internal class System.ServiceModel.Security.IdentityModelServiceAuthorizationManager : ServiceAuthorizationManager {
    protected static ReadOnlyCollection`1<IAuthorizationPolicy> AnonymousAuthorizationPolicy;
    private static IdentityModelServiceAuthorizationManager();
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> GetAuthorizationPolicies(OperationContext operationContext);
    internal static AuthorizationPolicy TransformAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> baseAuthorizationPolicies, SecurityTokenHandlerCollection securityTokenHandlerCollection, bool includeTransportTokens);
    internal static ClaimsIdentity MergeClaims(ClaimsIdentity identity1, ClaimsIdentity identity2);
    protected virtual bool CheckAccessCore(OperationContext operationContext);
}
public abstract class System.ServiceModel.Security.IdentityVerifier : object {
    public static IdentityVerifier CreateDefault();
    internal bool CheckAccess(EndpointAddress reference, Message message);
    public abstract virtual bool CheckAccess(EndpointIdentity identity, AuthorizationContext authContext);
    public abstract virtual bool TryGetIdentity(EndpointAddress reference, EndpointIdentity& identity);
    internal bool TryGetIdentity(EndpointAddress reference, Uri via, EndpointIdentity& identity);
    internal void EnsureIncomingIdentity(EndpointAddress serviceReference, AuthorizationContext authorizationContext);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, Uri via, AuthorizationContext authorizationContext);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
}
public interface System.ServiceModel.Security.IEndpointIdentityProvider {
    public abstract virtual EndpointIdentity GetIdentityOfSelf(SecurityTokenRequirement tokenRequirement);
}
internal interface System.ServiceModel.Security.IInitiatorSecuritySessionProtocol {
    public bool ReturnCorrelationState { get; public set; }
    public abstract virtual bool get_ReturnCorrelationState();
    public abstract virtual void set_ReturnCorrelationState(bool value);
    public abstract virtual SecurityToken GetOutgoingSessionToken();
    public abstract virtual void SetIdentityCheckAuthenticator(SecurityTokenAuthenticator tokenAuthenticator);
    public abstract virtual void SetOutgoingSessionToken(SecurityToken token);
    public abstract virtual List`1<SecurityToken> GetIncomingSessionTokens();
    public abstract virtual void SetIncomingSessionTokens(List`1<SecurityToken> tokens);
}
internal interface System.ServiceModel.Security.IListenerSecureConversationSessionSettings {
    public bool TolerateTransportFailures { get; public set; }
    public int MaximumPendingSessions { get; public set; }
    public TimeSpan InactivityTimeout { get; public set; }
    public TimeSpan MaximumKeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public int MaximumPendingKeysPerSession { get; public set; }
    public abstract virtual bool get_TolerateTransportFailures();
    public abstract virtual void set_TolerateTransportFailures(bool value);
    public abstract virtual int get_MaximumPendingSessions();
    public abstract virtual void set_MaximumPendingSessions(int value);
    public abstract virtual TimeSpan get_InactivityTimeout();
    public abstract virtual void set_InactivityTimeout(TimeSpan value);
    public abstract virtual TimeSpan get_MaximumKeyRenewalInterval();
    public abstract virtual void set_MaximumKeyRenewalInterval(TimeSpan value);
    public abstract virtual TimeSpan get_KeyRolloverInterval();
    public abstract virtual void set_KeyRolloverInterval(TimeSpan value);
    public abstract virtual int get_MaximumPendingKeysPerSession();
    public abstract virtual void set_MaximumPendingKeysPerSession(int value);
}
public class System.ServiceModel.Security.ImpersonateOnSerializingReplyMessageProperty : object {
    public static string Name { get; }
    internal ImpersonateOnSerializingReplyMessageProperty(MessageRpc& rpc);
    public static string get_Name();
    public static bool TryGet(Message message, ImpersonateOnSerializingReplyMessageProperty& property);
    public static bool TryGet(MessageProperties properties, ImpersonateOnSerializingReplyMessageProperty& property);
    public sealed virtual IMessageProperty CreateCopy();
    [SecuritySafeCriticalAttribute]
public void StartImpersonation(IDisposable& impersonationContext, IPrincipal& originalPrincipal, Boolean& isThreadPrincipalSet);
    [SecuritySafeCriticalAttribute]
public void StopImpersonation(IDisposable impersonationContext, IPrincipal originalPrincipal, bool isThreadPrincipalSet);
}
internal class System.ServiceModel.Security.ImpersonatingMessage : Message {
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public ImpersonatingMessage(Message innerMessage);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    internal virtual RecycledMessageState get_RecycledMessageState();
    protected virtual void OnClose();
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.InfoCardChannelParameter : object {
    public SecurityToken Token { get; }
    public Uri RelyingPartyIssuer { get; }
    public bool RequiresInfoCard { get; }
    public InfoCardChannelParameter(SecurityToken token, Uri relyingIssuer, bool requiresInfoCard);
    public SecurityToken get_Token();
    public Uri get_RelyingPartyIssuer();
    public bool get_RequiresInfoCard();
}
internal static class System.ServiceModel.Security.InfoCardHelper : object {
    public static bool TryCreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement, ClientCredentialsSecurityTokenManager clientCredentialsTokenManager, SecurityTokenProvider& provider);
    public static bool IsInfocardRequired(Binding binding, ClientCredentials clientCreds, SecurityTokenManager clientCredentialsTokenManager, EndpointAddress target, CardSpacePolicyElement[]& infocardChain, Uri& relyingPartyIssuer);
    public static MessageSecurityVersion GetBindingSecurityVersionOrDefault(Binding binding);
}
public class System.ServiceModel.Security.InfocardInteractiveChannelInitializer : object {
    public Binding Binding { get; }
    public InfocardInteractiveChannelInitializer(ClientCredentials credentials, Binding binding);
    public Binding get_Binding();
    public virtual IAsyncResult BeginDisplayInitializationUI(IClientChannel channel, AsyncCallback callback, object state);
    public virtual void EndDisplayInitializationUI(IAsyncResult result);
}
internal class System.ServiceModel.Security.InitiatorSessionSymmetricMessageSecurityProtocol : MessageSecurityProtocol {
    protected bool PerformIncomingAndOutgoingMessageExpectationChecks { get; }
    public bool ReturnCorrelationState { get; public set; }
    public InitiatorSessionSymmetricMessageSecurityProtocol(SessionSymmetricMessageSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    protected virtual bool get_PerformIncomingAndOutgoingMessageExpectationChecks();
    public sealed virtual bool get_ReturnCorrelationState();
    public sealed virtual void set_ReturnCorrelationState(bool value);
    public sealed virtual SecurityToken GetOutgoingSessionToken();
    public sealed virtual void SetIdentityCheckAuthenticator(SecurityTokenAuthenticator authenticator);
    public sealed virtual void SetOutgoingSessionToken(SecurityToken token);
    public sealed virtual List`1<SecurityToken> GetIncomingSessionTokens();
    public sealed virtual void SetIncomingSessionTokens(List`1<SecurityToken> tokens);
    protected virtual IAsyncResult BeginSecureOutgoingMessageCore(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    internal SecurityProtocolCorrelationState CreateCorrelationStateIfRequired();
    protected virtual SecurityProtocolCorrelationState SecureOutgoingMessageCore(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual void EndSecureOutgoingMessageCore(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    internal void SetUpDelayedSecurityExecution(Message& message, SecurityToken signingToken, SecurityToken encryptionToken, SecurityToken sourceToken, SecurityTokenParameters tokenParameters, IList`1<SupportingTokenSpecification> supportingTokens, SecurityProtocolCorrelationState correlationState);
    protected virtual SecurityProtocolCorrelationState VerifyIncomingMessageCore(Message& message, string actor, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
}
internal class System.ServiceModel.Security.InitiatorSessionSymmetricTransportSecurityProtocol : TransportSecurityProtocol {
    public bool ReturnCorrelationState { get; public set; }
    public InitiatorSessionSymmetricTransportSecurityProtocol(SessionSymmetricTransportSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    public sealed virtual bool get_ReturnCorrelationState();
    public sealed virtual void set_ReturnCorrelationState(bool value);
    public sealed virtual SecurityToken GetOutgoingSessionToken();
    public sealed virtual void SetIdentityCheckAuthenticator(SecurityTokenAuthenticator authenticator);
    public sealed virtual void SetOutgoingSessionToken(SecurityToken token);
    public sealed virtual List`1<SecurityToken> GetIncomingSessionTokens();
    public sealed virtual void SetIncomingSessionTokens(List`1<SecurityToken> tokens);
    internal void SetupDelayedSecurityExecution(string actor, Message& message, SecurityToken signingToken, SecurityToken sourceToken, SecurityTokenParameters tokenParameters, IList`1<SupportingTokenSpecification> supportingTokens);
    protected virtual void SecureOutgoingMessageAtInitiator(Message& message, string actor, TimeSpan timeout);
    protected virtual IAsyncResult BeginSecureOutgoingMessageAtInitiatorCore(Message message, string actor, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual Message EndSecureOutgoingMessageAtInitiatorCore(IAsyncResult result);
}
internal class System.ServiceModel.Security.InMemoryNonceCache : NonceCache {
    public InMemoryNonceCache(TimeSpan cachingTime, int maxCachedNonces);
    public virtual bool CheckNonce(Byte[] nonce);
    public virtual bool TryAddNonce(Byte[] nonce);
    public virtual string ToString();
}
public interface System.ServiceModel.Security.ISecureConversationSession {
    public abstract virtual void WriteSessionTokenIdentifier(XmlDictionaryWriter writer);
    public abstract virtual bool TryReadSessionTokenIdentifier(XmlReader reader);
}
internal interface System.ServiceModel.Security.ISecurityCommunicationObject {
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public abstract virtual TimeSpan get_DefaultOpenTimeout();
    public abstract virtual TimeSpan get_DefaultCloseTimeout();
    public abstract virtual void OnAbort();
    public abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void OnClose(TimeSpan timeout);
    public abstract virtual void OnClosed();
    public abstract virtual void OnClosing();
    public abstract virtual void OnEndClose(IAsyncResult result);
    public abstract virtual void OnEndOpen(IAsyncResult result);
    public abstract virtual void OnFaulted();
    public abstract virtual void OnOpen(TimeSpan timeout);
    public abstract virtual void OnOpened();
    public abstract virtual void OnOpening();
}
public interface System.ServiceModel.Security.ISecuritySession {
    public EndpointIdentity RemoteIdentity { get; }
    public abstract virtual EndpointIdentity get_RemoteIdentity();
}
internal abstract class System.ServiceModel.Security.IssuanceTokenProviderBase`1 : CommunicationObjectSecurityTokenProvider {
    internal static string defaultClientMaxTokenCachingTimeString;
    internal static bool defaultClientCacheTokens;
    internal static int defaultServiceTokenValidityThresholdPercentage;
    public EndpointAddress IssuerAddress { get; public set; }
    public EndpointAddress TargetAddress { get; public set; }
    public bool CacheServiceTokens { get; public set; }
    internal static TimeSpan DefaultClientMaxTokenCachingTime { get; }
    public int ServiceTokenValidityThresholdPercentage { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public TimeSpan MaxServiceTokenCachingTime { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public ChannelProtectionRequirements ApplicationProtectionRequirements { get; public set; }
    public Uri Via { get; public set; }
    public bool SupportsTokenCancellation { get; }
    protected object ThisLock { get; }
    protected bool IsMultiLegNegotiation { get; }
    protected MessageVersion MessageVersion { get; }
    protected bool RequiresManualReplyAddressing { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    protected string SecurityContextTokenUri { get; }
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public bool get_CacheServiceTokens();
    public void set_CacheServiceTokens(bool value);
    internal static TimeSpan get_DefaultClientMaxTokenCachingTime();
    public int get_ServiceTokenValidityThresholdPercentage();
    public void set_ServiceTokenValidityThresholdPercentage(int value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public TimeSpan get_MaxServiceTokenCachingTime();
    public void set_MaxServiceTokenCachingTime(TimeSpan value);
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public ChannelProtectionRequirements get_ApplicationProtectionRequirements();
    public void set_ApplicationProtectionRequirements(ChannelProtectionRequirements value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public virtual bool get_SupportsTokenCancellation();
    protected object get_ThisLock();
    protected virtual bool get_IsMultiLegNegotiation();
    protected abstract virtual MessageVersion get_MessageVersion();
    protected abstract virtual bool get_RequiresManualReplyAddressing();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    protected string get_SecurityContextTokenUri();
    protected void ThrowIfCreated();
    protected void ThrowIfClosedOrCreated();
    public virtual void OnOpen(TimeSpan timeout);
    protected void EnsureEndpointAddressDoesNotRequireEncryption(EndpointAddress target);
    protected static void ThrowIfFault(Message message, EndpointAddress target);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual void CancelTokenCore(TimeSpan timeout, SecurityToken token);
    protected abstract virtual bool CreateNegotiationStateCompletesSynchronously(EndpointAddress target, Uri via);
    protected abstract virtual IAsyncResult BeginCreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual T CreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout);
    protected abstract virtual T EndCreateNegotiationState(IAsyncResult result);
    protected abstract virtual BodyWriter GetFirstOutgoingMessageBody(T negotiationState, MessageProperties& properties);
    protected abstract virtual BodyWriter GetNextOutgoingMessageBody(Message incomingMessage, T negotiationState);
    protected abstract virtual bool WillInitializeChannelFactoriesCompleteSynchronously(EndpointAddress target);
    protected abstract virtual void InitializeChannelFactories(EndpointAddress target, TimeSpan timeout);
    protected abstract virtual IAsyncResult BeginInitializeChannelFactories(EndpointAddress target, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void EndInitializeChannelFactories(IAsyncResult result);
    protected abstract virtual IRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    protected SecurityToken DoNegotiation(TimeSpan timeout);
    protected IAsyncResult BeginNegotiation(TimeSpan timeout, AsyncCallback callback, object state);
    protected SecurityToken EndNegotiation(IAsyncResult result);
    protected virtual void ValidateKeySize(GenericXmlSecurityToken issuedToken);
}
internal class System.ServiceModel.Security.IssuanceTokenProviderState : object {
    public bool IsNegotiationCompleted { get; }
    public GenericXmlSecurityToken ServiceToken { get; }
    public EndpointAddress TargetAddress { get; public set; }
    public EndpointAddress RemoteAddress { get; public set; }
    public string Context { get; public set; }
    public bool get_IsNegotiationCompleted();
    public GenericXmlSecurityToken get_ServiceToken();
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public EndpointAddress get_RemoteAddress();
    public void set_RemoteAddress(EndpointAddress value);
    public string get_Context();
    public void set_Context(string value);
    public virtual void Dispose();
    public void SetServiceToken(GenericXmlSecurityToken serviceToken);
}
public class System.ServiceModel.Security.IssuedTokenClientCredential : object {
    public EndpointAddress LocalIssuerAddress { get; public set; }
    public Binding LocalIssuerBinding { get; public set; }
    public SecurityKeyEntropyMode DefaultKeyEntropyMode { get; public set; }
    public bool CacheIssuedTokens { get; public set; }
    public int IssuedTokenRenewalThresholdPercentage { get; public set; }
    public Dictionary`2<Uri, KeyedByTypeCollection`1<IEndpointBehavior>> IssuerChannelBehaviors { get; }
    public KeyedByTypeCollection`1<IEndpointBehavior> LocalIssuerChannelBehaviors { get; }
    public TimeSpan MaxIssuedTokenCachingTime { get; public set; }
    internal IssuedTokenClientCredential(IssuedTokenClientCredential other);
    public EndpointAddress get_LocalIssuerAddress();
    public void set_LocalIssuerAddress(EndpointAddress value);
    public Binding get_LocalIssuerBinding();
    public void set_LocalIssuerBinding(Binding value);
    public SecurityKeyEntropyMode get_DefaultKeyEntropyMode();
    public void set_DefaultKeyEntropyMode(SecurityKeyEntropyMode value);
    public bool get_CacheIssuedTokens();
    public void set_CacheIssuedTokens(bool value);
    public int get_IssuedTokenRenewalThresholdPercentage();
    public void set_IssuedTokenRenewalThresholdPercentage(int value);
    public Dictionary`2<Uri, KeyedByTypeCollection`1<IEndpointBehavior>> get_IssuerChannelBehaviors();
    public KeyedByTypeCollection`1<IEndpointBehavior> get_LocalIssuerChannelBehaviors();
    public TimeSpan get_MaxIssuedTokenCachingTime();
    public void set_MaxIssuedTokenCachingTime(TimeSpan value);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.IssuedTokenServiceCredential : object {
    internal static bool DefaultAllowUntrustedRsaIssuers;
    internal static AudienceUriMode DefaultAudienceUriMode;
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    public IList`1<string> AllowedAudienceUris { get; }
    public AudienceUriMode AudienceUriMode { get; public set; }
    public IList`1<X509Certificate2> KnownCertificates { get; }
    public SamlSerializer SamlSerializer { get; public set; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    public bool AllowUntrustedRsaIssuers { get; public set; }
    internal IssuedTokenServiceCredential(IssuedTokenServiceCredential other);
    public IList`1<string> get_AllowedAudienceUris();
    public AudienceUriMode get_AudienceUriMode();
    public void set_AudienceUriMode(AudienceUriMode value);
    public IList`1<X509Certificate2> get_KnownCertificates();
    public SamlSerializer get_SamlSerializer();
    public void set_SamlSerializer(SamlSerializer value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    public bool get_AllowUntrustedRsaIssuers();
    public void set_AllowUntrustedRsaIssuers(bool value);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
}
internal class System.ServiceModel.Security.IssuedTokensHeader : MessageHeader {
    public ReadOnlyCollection`1<RequestSecurityTokenResponse> TokenIssuances { get; }
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Name { get; }
    public string Namespace { get; }
    public IssuedTokensHeader(RequestSecurityTokenResponse tokenIssuance, MessageSecurityVersion version, SecurityTokenSerializer tokenSerializer);
    public IssuedTokensHeader(RequestSecurityTokenResponse tokenIssuance, SecurityStandardsManager standardsManager);
    public IssuedTokensHeader(IEnumerable`1<RequestSecurityTokenResponse> tokenIssuances, SecurityStandardsManager standardsManager);
    public IssuedTokensHeader(XmlReader xmlReader, MessageVersion version, SecurityStandardsManager standardsManager);
    public ReadOnlyCollection`1<RequestSecurityTokenResponse> get_TokenIssuances();
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal static Collection`1<RequestSecurityTokenResponse> ExtractIssuances(Message message, MessageSecurityVersion version, WSSecurityTokenSerializer tokenSerializer, String[] actors, XmlQualifiedName expectedAppliesToQName);
    internal static Collection`1<RequestSecurityTokenResponse> ExtractIssuances(Message message, SecurityStandardsManager standardsManager, String[] actors, XmlQualifiedName expectedAppliesToQName);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Security.IWSTrust13AsyncContract {
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13Cancel(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13Cancel(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13Issue(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13Issue(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13Renew(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13Renew(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13Validate(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13Validate(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13CancelResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13CancelResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13IssueResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13IssueResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13RenewResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13RenewResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrust13ValidateResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrust13ValidateResponse(IAsyncResult ar);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Security.IWSTrust13SyncContract {
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13Cancel(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13Issue(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13Renew(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13Validate(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13CancelResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13IssueResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13RenewResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrust13ValidateResponse(Message message);
}
[ServiceContractAttribute]
[ComVisibleAttribute("False")]
public interface System.ServiceModel.Security.IWSTrustChannelContract {
    public abstract virtual RequestSecurityTokenResponse Cancel(RequestSecurityToken request);
    public abstract virtual IAsyncResult BeginCancel(RequestSecurityToken request, AsyncCallback callback, object state);
    public abstract virtual void EndCancel(IAsyncResult result, RequestSecurityTokenResponse& response);
    public abstract virtual SecurityToken Issue(RequestSecurityToken request);
    public abstract virtual SecurityToken Issue(RequestSecurityToken request, RequestSecurityTokenResponse& response);
    public abstract virtual IAsyncResult BeginIssue(RequestSecurityToken request, AsyncCallback callback, object asyncState);
    public abstract virtual SecurityToken EndIssue(IAsyncResult result, RequestSecurityTokenResponse& response);
    public abstract virtual RequestSecurityTokenResponse Renew(RequestSecurityToken request);
    public abstract virtual IAsyncResult BeginRenew(RequestSecurityToken request, AsyncCallback callback, object state);
    public abstract virtual void EndRenew(IAsyncResult result, RequestSecurityTokenResponse& response);
    public abstract virtual RequestSecurityTokenResponse Validate(RequestSecurityToken request);
    public abstract virtual IAsyncResult BeginValidate(RequestSecurityToken request, AsyncCallback callback, object state);
    public abstract virtual void EndValidate(IAsyncResult result, RequestSecurityTokenResponse& response);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Security.IWSTrustContract {
    [OperationContractAttribute]
public abstract virtual Message Cancel(Message message);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginCancel(Message message, AsyncCallback callback, object asyncState);
    public abstract virtual Message EndCancel(IAsyncResult asyncResult);
    [OperationContractAttribute]
public abstract virtual Message Issue(Message message);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginIssue(Message message, AsyncCallback callback, object asyncState);
    public abstract virtual Message EndIssue(IAsyncResult asyncResult);
    [OperationContractAttribute]
public abstract virtual Message Renew(Message message);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginRenew(Message message, AsyncCallback callback, object asyncState);
    public abstract virtual Message EndRenew(IAsyncResult asyncResult);
    [OperationContractAttribute]
public abstract virtual Message Validate(Message message);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginValidate(Message message, AsyncCallback callback, object asyncState);
    public abstract virtual Message EndValidate(IAsyncResult asyncResult);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Security.IWSTrustFeb2005AsyncContract {
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005Cancel(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005Cancel(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005Issue(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005Issue(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005Renew(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005Renew(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005Validate(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005Validate(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005CancelResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005CancelResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005IssueResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005IssueResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005RenewResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005RenewResponse(IAsyncResult ar);
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginTrustFeb2005ValidateResponse(Message request, AsyncCallback callback, object state);
    public abstract virtual Message EndTrustFeb2005ValidateResponse(IAsyncResult ar);
}
[ServiceContractAttribute]
public interface System.ServiceModel.Security.IWSTrustFeb2005SyncContract {
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005Cancel(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005Issue(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005Renew(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005Validate(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005CancelResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005IssueResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005RenewResponse(Message message);
    [OperationContractAttribute]
public abstract virtual Message ProcessTrustFeb2005ValidateResponse(Message message);
}
internal class System.ServiceModel.Security.LaxModeSecurityHeaderElementInferenceEngine : SecurityHeaderElementInferenceEngine {
    internal static LaxModeSecurityHeaderElementInferenceEngine Instance { get; }
    private static LaxModeSecurityHeaderElementInferenceEngine();
    internal static LaxModeSecurityHeaderElementInferenceEngine get_Instance();
    public virtual void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
    public virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
}
internal class System.ServiceModel.Security.LaxTimestampFirstModeSecurityHeaderElementInferenceEngine : LaxModeSecurityHeaderElementInferenceEngine {
    internal static LaxTimestampFirstModeSecurityHeaderElementInferenceEngine Instance { get; }
    private static LaxTimestampFirstModeSecurityHeaderElementInferenceEngine();
    internal static LaxTimestampFirstModeSecurityHeaderElementInferenceEngine get_Instance();
    public virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
}
internal class System.ServiceModel.Security.LaxTimestampLastModeSecurityHeaderElementInferenceEngine : LaxModeSecurityHeaderElementInferenceEngine {
    internal static LaxTimestampLastModeSecurityHeaderElementInferenceEngine Instance { get; }
    private static LaxTimestampLastModeSecurityHeaderElementInferenceEngine();
    internal static LaxTimestampLastModeSecurityHeaderElementInferenceEngine get_Instance();
    public virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
}
internal class System.ServiceModel.Security.MergedSupportingTokenAuthenticatorSpecification : ValueType {
    public Collection`1<SupportingTokenAuthenticatorSpecification> SupportingTokenAuthenticators;
    public bool ExpectSignedTokens;
    public bool ExpectEndorsingTokens;
    public bool ExpectBasicTokens;
}
internal enum System.ServiceModel.Security.MessagePartProtectionMode : Enum {
    public int value__;
    public static MessagePartProtectionMode None;
    public static MessagePartProtectionMode Sign;
    public static MessagePartProtectionMode Encrypt;
    public static MessagePartProtectionMode SignThenEncrypt;
    public static MessagePartProtectionMode EncryptThenSign;
}
internal static class System.ServiceModel.Security.MessagePartProtectionModeHelper : object {
    public static MessagePartProtectionMode GetProtectionMode(bool sign, bool encrypt, bool signThenEncrypt);
}
public class System.ServiceModel.Security.MessagePartSpecification : object {
    public ICollection`1<XmlQualifiedName> HeaderTypes { get; }
    internal bool HasHeaders { get; }
    public bool IsBodyIncluded { get; public set; }
    public bool IsReadOnly { get; }
    public static MessagePartSpecification NoParts { get; }
    public MessagePartSpecification(bool isBodyIncluded);
    public MessagePartSpecification(XmlQualifiedName[] headerTypes);
    public MessagePartSpecification(bool isBodyIncluded, XmlQualifiedName[] headerTypes);
    public ICollection`1<XmlQualifiedName> get_HeaderTypes();
    internal bool get_HasHeaders();
    public bool get_IsBodyIncluded();
    public void set_IsBodyIncluded(bool value);
    public bool get_IsReadOnly();
    public static MessagePartSpecification get_NoParts();
    public void Clear();
    public void Union(MessagePartSpecification specification);
    public void MakeReadOnly();
    internal bool IsHeaderIncluded(MessageHeader header);
    internal bool IsHeaderIncluded(string name, string ns);
    internal bool IsEmpty();
}
public enum System.ServiceModel.Security.MessageProtectionOrder : Enum {
    public int value__;
    public static MessageProtectionOrder SignBeforeEncrypt;
    public static MessageProtectionOrder SignBeforeEncryptAndEncryptSignature;
    public static MessageProtectionOrder EncryptBeforeSign;
}
internal static class System.ServiceModel.Security.MessageProtectionOrderHelper : object {
    internal static bool IsDefined(MessageProtectionOrder value);
}
public class System.ServiceModel.Security.MessageSecurityException : CommunicationException {
    internal bool ReplayDetected { get; }
    internal MessageFault Fault { get; }
    public MessageSecurityException(string message);
    public MessageSecurityException(string message, Exception innerException);
    protected MessageSecurityException(SerializationInfo info, StreamingContext context);
    internal MessageSecurityException(string message, Exception innerException, MessageFault fault);
    internal MessageSecurityException(string message, bool isReplay);
    internal bool get_ReplayDetected();
    internal MessageFault get_Fault();
}
internal abstract class System.ServiceModel.Security.MessageSecurityProtocol : SecurityProtocol {
    protected bool CacheIdentityCheckResultForToken { get; }
    protected bool DoAutomaticEncryptionMatch { get; }
    protected bool PerformIncomingAndOutgoingMessageExpectationChecks { get; }
    protected bool RequiresOutgoingSecurityProcessing { get; }
    protected MessageSecurityProtocolFactory MessageSecurityProtocolFactory { get; }
    protected MessageSecurityProtocol(MessageSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    protected virtual bool get_CacheIdentityCheckResultForToken();
    protected virtual bool get_DoAutomaticEncryptionMatch();
    protected virtual bool get_PerformIncomingAndOutgoingMessageExpectationChecks();
    protected bool RequiresIncomingSecurityProcessing(Message message);
    protected bool get_RequiresOutgoingSecurityProcessing();
    protected MessageSecurityProtocolFactory get_MessageSecurityProtocolFactory();
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    protected abstract virtual IAsyncResult BeginSecureOutgoingMessageCore(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    protected abstract virtual void EndSecureOutgoingMessageCore(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    protected void AttachRecipientSecurityProperty(Message message, SecurityToken protectionToken, bool isWrappedToken, IList`1<SecurityToken> basicTokens, IList`1<SecurityToken> endorsingTokens, IList`1<SecurityToken> signedEndorsingTokens, IList`1<SecurityToken> signedTokens, Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected void DoIdentityCheckAndAttachInitiatorSecurityProperty(Message message, SecurityToken protectionToken, ReadOnlyCollection`1<IAuthorizationPolicy> protectionTokenPolicies);
    protected AuthorizationContext EnsureIncomingIdentity(Message message, SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    protected void EnsureOutgoingIdentity(SecurityToken token, SecurityTokenAuthenticator authenticator);
    protected SecurityProtocolCorrelationState GetCorrelationState(SecurityToken correlationToken);
    protected SecurityProtocolCorrelationState GetCorrelationState(SecurityToken correlationToken, ReceiveSecurityHeader securityHeader);
    protected SecurityToken GetCorrelationToken(SecurityProtocolCorrelationState[] correlationStates);
    protected SecurityToken GetCorrelationToken(SecurityProtocolCorrelationState correlationState);
    protected static void EnsureNonWrappedToken(SecurityToken token, Message message);
    protected SecurityToken GetTokenAndEnsureOutgoingIdentity(SecurityTokenProvider provider, bool isEncryptionOn, TimeSpan timeout, SecurityTokenAuthenticator authenticator);
    protected SendSecurityHeader ConfigureSendSecurityHeader(Message message, string actor, IList`1<SupportingTokenSpecification> supportingTokens, SecurityProtocolCorrelationState correlationState);
    protected ReceiveSecurityHeader CreateSecurityHeader(Message message, string actor, MessageDirection transferDirection, SecurityStandardsManager standardsManager);
    protected ReceiveSecurityHeader ConfigureReceiveSecurityHeader(Message message, string actor, SecurityProtocolCorrelationState[] correlationStates, IList`1& supportingAuthenticators);
    protected ReceiveSecurityHeader ConfigureReceiveSecurityHeader(Message message, string actor, SecurityProtocolCorrelationState[] correlationStates, SecurityStandardsManager standardsManager, IList`1& supportingAuthenticators);
    protected void ProcessSecurityHeader(ReceiveSecurityHeader securityHeader, Message& message, SecurityToken requiredSigningToken, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
    protected void CheckSignatureConfirmation(ReceiveSecurityHeader securityHeader, SecurityProtocolCorrelationState[] correlationStates);
    public virtual void SecureOutgoingMessage(Message& message, TimeSpan timeout);
    public virtual SecurityProtocolCorrelationState SecureOutgoingMessage(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected abstract virtual SecurityProtocolCorrelationState SecureOutgoingMessageCore(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    public virtual void VerifyIncomingMessage(Message& message, TimeSpan timeout);
    public virtual SecurityProtocolCorrelationState VerifyIncomingMessage(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
    protected abstract virtual SecurityProtocolCorrelationState VerifyIncomingMessageCore(Message& message, string actor, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
    internal SecurityProtocolCorrelationState GetSignatureConfirmationCorrelationState(SecurityProtocolCorrelationState oldCorrelationState, SecurityProtocolCorrelationState newCorrelationState);
}
internal abstract class System.ServiceModel.Security.MessageSecurityProtocolFactory : SecurityProtocolFactory {
    internal static MessageProtectionOrder defaultMessageProtectionOrder;
    internal static bool defaultDoRequestSignatureConfirmation;
    public bool ApplyConfidentiality { get; public set; }
    public bool ApplyIntegrity { get; public set; }
    public bool DoRequestSignatureConfirmation { get; public set; }
    public IdentityVerifier IdentityVerifier { get; public set; }
    public ChannelProtectionRequirements ProtectionRequirements { get; }
    public MessageProtectionOrder MessageProtectionOrder { get; public set; }
    public bool RequireIntegrity { get; public set; }
    public bool RequireConfidentiality { get; public set; }
    internal List`1<SecurityTokenAuthenticator> WrappedKeySecurityTokenAuthenticator { get; }
    internal MessageSecurityProtocolFactory(MessageSecurityProtocolFactory factory);
    public bool get_ApplyConfidentiality();
    public void set_ApplyConfidentiality(bool value);
    public bool get_ApplyIntegrity();
    public void set_ApplyIntegrity(bool value);
    public bool get_DoRequestSignatureConfirmation();
    public void set_DoRequestSignatureConfirmation(bool value);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public ChannelProtectionRequirements get_ProtectionRequirements();
    public MessageProtectionOrder get_MessageProtectionOrder();
    public void set_MessageProtectionOrder(MessageProtectionOrder value);
    public bool get_RequireIntegrity();
    public void set_RequireIntegrity(bool value);
    public bool get_RequireConfidentiality();
    public void set_RequireConfidentiality(bool value);
    internal List`1<SecurityTokenAuthenticator> get_WrappedKeySecurityTokenAuthenticator();
    protected virtual void ValidateCorrelationSecuritySettings();
    public virtual void OnOpen(TimeSpan timeout);
    internal MessagePartSpecification GetIncomingEncryptionParts(string action);
    internal MessagePartSpecification GetIncomingSignatureParts(string action);
    internal MessagePartSpecification GetOutgoingEncryptionParts(string action);
    internal MessagePartSpecification GetOutgoingSignatureParts(string action);
}
internal class System.ServiceModel.Security.MessageSecurityTokenVersion : SecurityTokenVersion {
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    private static MessageSecurityTokenVersion();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion GetSecurityTokenVersion(SecurityVersion version, bool emitBspAttributes);
    public bool get_EmitBspRequiredAttributes();
    public SecurityVersion get_SecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    public virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
    public virtual string ToString();
}
internal static class System.ServiceModel.Security.Namespaces : object {
    internal static string WSPolicy;
    internal static string WSPolicyPrefix;
    internal static string XmlSchema;
    internal static string XmlSchemaPrefix;
}
internal abstract class System.ServiceModel.Security.NegotiationTokenAuthenticator`1 : CommunicationObjectSecurityTokenAuthenticator {
    internal static string defaultServerMaxNegotiationLifetimeString;
    internal static string defaultServerIssuedTokenLifetimeString;
    internal static string defaultServerIssuedTransitionTokenLifetimeString;
    internal static int defaultServerMaxActiveNegotiations;
    internal static TimeSpan defaultServerMaxNegotiationLifetime;
    internal static TimeSpan defaultServerIssuedTokenLifetime;
    internal static TimeSpan defaultServerIssuedTransitionTokenLifetime;
    internal static int defaultServerMaxCachedTokens;
    internal static bool defaultServerMaintainState;
    internal static SecurityStandardsManager defaultStandardsManager;
    internal static SecurityStateEncoder defaultSecurityStateEncoder;
    public IssuedSecurityTokenHandler IssuedSecurityTokenHandler { get; public set; }
    public RenewedSecurityTokenHandler RenewedSecurityTokenHandler { get; public set; }
    public bool EncryptStateInServiceToken { get; public set; }
    public TimeSpan ServiceTokenLifetime { get; public set; }
    public int MaximumCachedNegotiationState { get; public set; }
    public int MaximumConcurrentNegotiations { get; public set; }
    public TimeSpan NegotiationTimeout { get; public set; }
    public bool IsClientAnonymous { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public IMessageFilterTable`1<EndpointAddress> EndpointFilterTable { get; public set; }
    private ISecurityContextSecurityTokenCache System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCacheProvider.TokenCache { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public ISecurityContextSecurityTokenCache IssuedTokenCache { get; public set; }
    public AuditLogLocation AuditLogLocation { get; public set; }
    public bool SuppressAuditFailure { get; public set; }
    public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public BindingContext IssuerBindingContext { get; public set; }
    public Uri ListenUri { get; public set; }
    public SecurityStateEncoder SecurityStateEncoder { get; public set; }
    public IList`1<Type> KnownTypes { get; public set; }
    public int MaxMessageSize { get; public set; }
    protected string SecurityContextTokenUri { get; }
    protected bool IsMultiLegNegotiation { get; }
    private static NegotiationTokenAuthenticator`1();
    public sealed virtual IssuedSecurityTokenHandler get_IssuedSecurityTokenHandler();
    public sealed virtual void set_IssuedSecurityTokenHandler(IssuedSecurityTokenHandler value);
    public sealed virtual RenewedSecurityTokenHandler get_RenewedSecurityTokenHandler();
    public sealed virtual void set_RenewedSecurityTokenHandler(RenewedSecurityTokenHandler value);
    public bool get_EncryptStateInServiceToken();
    public void set_EncryptStateInServiceToken(bool value);
    public TimeSpan get_ServiceTokenLifetime();
    public void set_ServiceTokenLifetime(TimeSpan value);
    public int get_MaximumCachedNegotiationState();
    public void set_MaximumCachedNegotiationState(int value);
    public int get_MaximumConcurrentNegotiations();
    public void set_MaximumConcurrentNegotiations(int value);
    public TimeSpan get_NegotiationTimeout();
    public void set_NegotiationTimeout(TimeSpan value);
    public bool get_IsClientAnonymous();
    public void set_IsClientAnonymous(bool value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public IMessageFilterTable`1<EndpointAddress> get_EndpointFilterTable();
    public void set_EndpointFilterTable(IMessageFilterTable`1<EndpointAddress> value);
    private sealed virtual override ISecurityContextSecurityTokenCache System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCacheProvider.get_TokenCache();
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseFinalAction();
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public ISecurityContextSecurityTokenCache get_IssuedTokenCache();
    public void set_IssuedTokenCache(ISecurityContextSecurityTokenCache value);
    public AuditLogLocation get_AuditLogLocation();
    public void set_AuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public SecurityStateEncoder get_SecurityStateEncoder();
    public void set_SecurityStateEncoder(SecurityStateEncoder value);
    public IList`1<Type> get_KnownTypes();
    public void set_KnownTypes(IList`1<Type> value);
    public int get_MaxMessageSize();
    public void set_MaxMessageSize(int value);
    protected string get_SecurityContextTokenUri();
    protected SecurityContextSecurityToken IssueSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime tokenEffectiveTime, DateTime tokenExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode);
    protected SecurityContextSecurityToken IssueSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime tokenEffectiveTime, DateTime tokenExpirationTime, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnOpen(TimeSpan timeout);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    protected abstract virtual Binding GetNegotiationBinding(Binding binding);
    protected abstract virtual bool get_IsMultiLegNegotiation();
    protected abstract virtual MessageFilter GetListenerFilter();
    protected abstract virtual BodyWriter ProcessRequestSecurityToken(Message request, RequestSecurityToken requestSecurityToken, T& negotiationState);
    protected abstract virtual BodyWriter ProcessRequestSecurityTokenResponse(T negotiationState, Message request, RequestSecurityTokenResponse requestSecurityTokenResponse);
    protected virtual void ParseMessageBody(Message message, String& context, RequestSecurityToken& requestSecurityToken, RequestSecurityTokenResponse& requestSecurityTokenResponse);
}
internal class System.ServiceModel.Security.NegotiationTokenAuthenticatorState : object {
    public object ThisLock { get; }
    public bool IsNegotiationCompleted { get; }
    public SecurityContextSecurityToken ServiceToken { get; }
    public object get_ThisLock();
    public bool get_IsNegotiationCompleted();
    public SecurityContextSecurityToken get_ServiceToken();
    public virtual void Dispose();
    public void SetServiceToken(SecurityContextSecurityToken token);
    public virtual string GetRemoteIdentityName();
}
internal class System.ServiceModel.Security.NegotiationTokenAuthenticatorStateCache`1 : TimeBoundedCache {
    public NegotiationTokenAuthenticatorStateCache`1(TimeSpan cachingSpan, int maximumCachedState);
    private static NegotiationTokenAuthenticatorStateCache`1();
    public void AddState(string context, T state);
    public T GetState(string context);
    public void RemoveState(string context);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    protected virtual void OnRemove(object item);
}
internal abstract class System.ServiceModel.Security.NegotiationTokenProvider`1 : IssuanceTokenProviderBase`1<T> {
    public BindingContext IssuerBindingContext { get; public set; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    protected MessageVersion MessageVersion { get; }
    protected bool RequiresManualReplyAddressing { get; }
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    protected virtual MessageVersion get_MessageVersion();
    protected virtual bool get_RequiresManualReplyAddressing();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnOpen(TimeSpan timeout);
    protected abstract virtual IChannelFactory`1<IRequestChannel> GetNegotiationChannelFactory(IChannelFactory`1<IRequestChannel> transportChannelFactory, ChannelBuilder channelBuilder);
    protected virtual bool WillInitializeChannelFactoriesCompleteSynchronously(EndpointAddress target);
    protected virtual void InitializeChannelFactories(EndpointAddress target, TimeSpan timeout);
    protected virtual IAsyncResult BeginInitializeChannelFactories(EndpointAddress target, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void EndInitializeChannelFactories(IAsyncResult result);
    protected virtual IRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
}
public abstract class System.ServiceModel.Security.NonceCache : object {
    public TimeSpan CachingTimeSpan { get; public set; }
    public int CacheSize { get; public set; }
    public TimeSpan get_CachingTimeSpan();
    public void set_CachingTimeSpan(TimeSpan value);
    public int get_CacheSize();
    public void set_CacheSize(int value);
    public abstract virtual bool TryAddNonce(Byte[] nonce);
    public abstract virtual bool CheckNonce(Byte[] nonce);
}
internal class System.ServiceModel.Security.NonceToken : BinarySecretSecurityToken {
    public NonceToken(Byte[] key);
    public NonceToken(string id, Byte[] key);
    public NonceToken(int keySizeInBits);
}
internal class System.ServiceModel.Security.NoOpSecurityStateEncoder : SecurityStateEncoder {
    protected internal virtual Byte[] EncodeSecurityState(Byte[] data);
    protected internal virtual Byte[] DecodeSecurityState(Byte[] data);
}
internal class System.ServiceModel.Security.OperationWithTimeoutAsyncResult : TraceAsyncResult {
    public OperationWithTimeoutAsyncResult(OperationWithTimeoutCallback operationWithTimeout, TimeSpan timeout, AsyncCallback callback, object state);
    private static OperationWithTimeoutAsyncResult();
    public static void End(IAsyncResult result);
}
public class System.ServiceModel.Security.PeerCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    public X509Certificate2 Certificate { get; public set; }
    public string MeshPassword { get; public set; }
    public X509PeerCertificateAuthentication PeerAuthentication { get; public set; }
    public X509PeerCertificateAuthentication MessageSenderAuthentication { get; public set; }
    internal PeerCredential(PeerCredential other);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public string get_MeshPassword();
    public void set_MeshPassword(string value);
    public X509PeerCertificateAuthentication get_PeerAuthentication();
    public void set_PeerAuthentication(X509PeerCertificateAuthentication value);
    public X509PeerCertificateAuthentication get_MessageSenderAuthentication();
    public void set_MessageSenderAuthentication(X509PeerCertificateAuthentication value);
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    internal void MakeReadOnly();
    internal bool Equals(PeerCredential that, PeerAuthenticationMode mode, bool messageAuthentication);
}
internal static class System.ServiceModel.Security.ProtectionLevelHelper : object {
    internal static bool IsDefined(ProtectionLevel value);
    internal static void Validate(ProtectionLevel value);
    internal static bool IsStronger(ProtectionLevel v1, ProtectionLevel v2);
    internal static bool IsStrongerOrEqual(ProtectionLevel v1, ProtectionLevel v2);
    internal static ProtectionLevel Max(ProtectionLevel v1, ProtectionLevel v2);
    internal static int GetOrdinal(Nullable`1<ProtectionLevel> p);
}
internal static class System.ServiceModel.Security.Psha1DerivedKeyGeneratorHelper : object {
    internal static Byte[] GenerateDerivedKey(Byte[] key, Byte[] label, Byte[] nonce, int derivedKeySize, int position);
}
internal enum System.ServiceModel.Security.PurgingMode : Enum {
    public int value__;
    public static PurgingMode TimerBasedPurge;
    public static PurgingMode AccessBasedPurge;
}
internal abstract class System.ServiceModel.Security.ReceiveMessageAndVerifySecurityAsyncResultBase : AsyncResult {
    protected ReceiveMessageAndVerifySecurityAsyncResultBase(IInputChannel innerChannel, TimeSpan timeout, AsyncCallback callback, object state);
    private static ReceiveMessageAndVerifySecurityAsyncResultBase();
    public void Start();
    protected abstract virtual bool OnInnerReceiveDone(Message& message, TimeSpan timeout);
    public static bool End(IAsyncResult result, Message& message);
}
internal abstract class System.ServiceModel.Security.ReceiveSecurityHeader : SecurityHeader {
    public Collection`1<SecurityToken> BasicSupportingTokens { get; }
    public Collection`1<SecurityToken> SignedSupportingTokens { get; }
    public Collection`1<SecurityToken> EndorsingSupportingTokens { get; }
    public ReceiveSecurityHeaderElementManager ElementManager { get; }
    public Collection`1<SecurityToken> SignedEndorsingSupportingTokens { get; }
    public SecurityTokenAuthenticator DerivedTokenAuthenticator { get; public set; }
    public List`1<SecurityTokenAuthenticator> WrappedKeySecurityTokenAuthenticator { get; public set; }
    public bool EnforceDerivedKeyRequirement { get; public set; }
    public Byte[] PrimarySignatureValue { get; }
    public bool EncryptBeforeSignMode { get; }
    public SecurityToken EncryptionToken { get; }
    public bool ExpectBasicTokens { get; public set; }
    public bool ReplayDetectionEnabled { get; public set; }
    public bool ExpectEncryption { get; public set; }
    public bool ExpectSignature { get; public set; }
    public bool ExpectSignatureConfirmation { get; public set; }
    public bool ExpectSignedTokens { get; public set; }
    public bool RequireSignedPrimaryToken { get; public set; }
    public bool ExpectEndorsingTokens { get; public set; }
    public bool HasAtLeastOneItemInsideSecurityHeaderEncrypted { get; public set; }
    public SecurityHeaderTokenResolver PrimaryTokenResolver { get; }
    public SecurityTokenResolver CombinedUniversalTokenResolver { get; }
    public SecurityTokenResolver CombinedPrimaryTokenResolver { get; }
    protected EventTraceActivity EventTraceActivity { get; }
    internal int HeaderIndex { get; }
    internal long MaxReceivedMessageSize { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; internal set; }
    public string Name { get; }
    public string Namespace { get; }
    public Message ProcessedMessage { get; }
    public MessagePartSpecification RequiredEncryptionParts { get; public set; }
    public MessagePartSpecification RequiredSignatureParts { get; public set; }
    protected SignatureResourcePool ResourcePool { get; }
    internal SecurityVerifiedMessage SecurityVerifiedMessage { get; }
    public SecurityToken SignatureToken { get; }
    public Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> SecurityTokenAuthorizationPoliciesMapping { get; }
    public SecurityTimestamp Timestamp { get; }
    public int MaxDerivedKeyLength { get; }
    protected ReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
    public Collection`1<SecurityToken> get_BasicSupportingTokens();
    public Collection`1<SecurityToken> get_SignedSupportingTokens();
    public Collection`1<SecurityToken> get_EndorsingSupportingTokens();
    public ReceiveSecurityHeaderElementManager get_ElementManager();
    public Collection`1<SecurityToken> get_SignedEndorsingSupportingTokens();
    public SecurityTokenAuthenticator get_DerivedTokenAuthenticator();
    public void set_DerivedTokenAuthenticator(SecurityTokenAuthenticator value);
    public List`1<SecurityTokenAuthenticator> get_WrappedKeySecurityTokenAuthenticator();
    public void set_WrappedKeySecurityTokenAuthenticator(List`1<SecurityTokenAuthenticator> value);
    public bool get_EnforceDerivedKeyRequirement();
    public void set_EnforceDerivedKeyRequirement(bool value);
    public Byte[] get_PrimarySignatureValue();
    public bool get_EncryptBeforeSignMode();
    public SecurityToken get_EncryptionToken();
    public bool get_ExpectBasicTokens();
    public void set_ExpectBasicTokens(bool value);
    public bool get_ReplayDetectionEnabled();
    public void set_ReplayDetectionEnabled(bool value);
    public bool get_ExpectEncryption();
    public void set_ExpectEncryption(bool value);
    public bool get_ExpectSignature();
    public void set_ExpectSignature(bool value);
    public bool get_ExpectSignatureConfirmation();
    public void set_ExpectSignatureConfirmation(bool value);
    public bool get_ExpectSignedTokens();
    public void set_ExpectSignedTokens(bool value);
    public bool get_RequireSignedPrimaryToken();
    public void set_RequireSignedPrimaryToken(bool value);
    public bool get_ExpectEndorsingTokens();
    public void set_ExpectEndorsingTokens(bool value);
    public bool get_HasAtLeastOneItemInsideSecurityHeaderEncrypted();
    public void set_HasAtLeastOneItemInsideSecurityHeaderEncrypted(bool value);
    public SecurityHeaderTokenResolver get_PrimaryTokenResolver();
    public SecurityTokenResolver get_CombinedUniversalTokenResolver();
    public SecurityTokenResolver get_CombinedPrimaryTokenResolver();
    protected EventTraceActivity get_EventTraceActivity();
    protected void VerifySignatureEncryption();
    internal int get_HeaderIndex();
    internal long get_MaxReceivedMessageSize();
    internal void set_MaxReceivedMessageSize(long value);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public Message get_ProcessedMessage();
    public MessagePartSpecification get_RequiredEncryptionParts();
    public void set_RequiredEncryptionParts(MessagePartSpecification value);
    public MessagePartSpecification get_RequiredSignatureParts();
    public void set_RequiredSignatureParts(MessagePartSpecification value);
    protected SignatureResourcePool get_ResourcePool();
    internal SecurityVerifiedMessage get_SecurityVerifiedMessage();
    public SecurityToken get_SignatureToken();
    public Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> get_SecurityTokenAuthorizationPoliciesMapping();
    public SecurityTimestamp get_Timestamp();
    public int get_MaxDerivedKeyLength();
    internal XmlDictionaryReader CreateSecurityHeaderReader();
    public SignatureConfirmations GetSentSignatureConfirmations();
    public void ConfigureSymmetricBindingServerReceiveHeader(SecurityTokenAuthenticator primaryTokenAuthenticator, SecurityTokenParameters primaryTokenParameters, IList`1<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators);
    public void ConfigureSymmetricBindingServerReceiveHeader(SecurityToken wrappingToken, SecurityTokenParameters wrappingTokenParameters, IList`1<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators);
    public void ConfigureAsymmetricBindingServerReceiveHeader(SecurityTokenAuthenticator primaryTokenAuthenticator, SecurityTokenParameters primaryTokenParameters, SecurityToken wrappingToken, SecurityTokenParameters wrappingTokenParameters, IList`1<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators);
    public void ConfigureTransportBindingServerReceiveHeader(IList`1<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators);
    public void ConfigureAsymmetricBindingClientReceiveHeader(SecurityToken primaryToken, SecurityTokenParameters primaryTokenParameters, SecurityToken encryptionToken, SecurityTokenParameters encryptionTokenParameters, SecurityTokenAuthenticator primaryTokenAuthenticator);
    public void ConfigureSymmetricBindingClientReceiveHeader(SecurityToken primaryToken, SecurityTokenParameters primaryTokenParameters);
    public void ConfigureSymmetricBindingClientReceiveHeader(IList`1<SecurityToken> primaryTokens, SecurityTokenParameters primaryTokenParameters);
    public void ConfigureOutOfBandTokenResolver(ReadOnlyCollection`1<SecurityTokenResolver> outOfBandResolvers);
    protected abstract virtual EncryptedData ReadSecurityHeaderEncryptedItem(XmlDictionaryReader reader, bool readXmlreferenceKeyInfoClause);
    protected abstract virtual Byte[] DecryptSecurityHeaderElement(EncryptedData encryptedData, WrappedKeySecurityToken wrappedKeyToken, SecurityToken& encryptionToken);
    protected abstract virtual WrappedKeySecurityToken DecryptWrappedKey(XmlDictionaryReader reader);
    public SignatureConfirmations GetSentSignatureValues();
    protected abstract virtual bool IsReaderAtEncryptedKey(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtEncryptedData(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtReferenceList(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtSignature(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader);
    protected abstract virtual void OnDecryptionOfSecurityHeaderItemRequiringReferenceListEntry(string id);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void SetTimeParameters(NonceCache nonceCache, TimeSpan replayWindow, TimeSpan clockSkew);
    public void Process(TimeSpan timeout, ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy);
    protected abstract virtual void EnsureDecryptionComplete();
    protected abstract virtual void ExecuteMessageProtectionPass(bool hasAtLeastOneSupportingTokenExpectedToBeSigned);
    internal void ExecuteSignatureEncryptionProcessingPass();
    internal void ExecuteSubheaderDecryptionPass();
    internal void ExecuteReadingPass(XmlDictionaryReader reader);
    internal void ExecuteFullPass(XmlDictionaryReader reader);
    internal void EnsureDerivedKeyLimitNotReached();
    internal void ExecuteDerivedKeyTokenStubPass(bool isFinalPass);
    internal XmlDictionaryReader CreateDecryptedReader(Byte[] decryptedBuffer);
    protected abstract virtual ReferenceList ReadReferenceListCore(XmlDictionaryReader reader);
    protected abstract virtual void ProcessReferenceListCore(ReferenceList referenceList, WrappedKeySecurityToken wrappedKeyToken);
    protected abstract virtual void ReadSecurityTokenReference(XmlDictionaryReader reader);
    protected TokenTracker GetSupportingTokenTracker(SecurityTokenAuthenticator tokenAuthenticator, SupportingTokenAuthenticatorSpecification& spec);
    protected TAuthenticator FindAllowedAuthenticator(bool removeIfPresent);
    protected void RecordEncryptionToken(SecurityToken token);
    protected void RecordSignatureToken(SecurityToken token);
    public void SetRequiredProtectionOrder(MessageProtectionOrder protectionOrder);
    protected abstract virtual SignedXml ReadSignatureCore(XmlDictionaryReader signatureReader);
    protected abstract virtual SecurityToken VerifySignature(SignedXml signedXml, bool isPrimarySignature, SecurityHeaderTokenResolver resolver, object signatureTarget, string id);
    protected abstract virtual bool TryDeleteReferenceListEntry(string id);
}
[FlagsAttribute]
internal enum System.ServiceModel.Security.ReceiveSecurityHeaderBindingModes : Enum {
    public int value__;
    public static ReceiveSecurityHeaderBindingModes Unknown;
    public static ReceiveSecurityHeaderBindingModes Primary;
    public static ReceiveSecurityHeaderBindingModes Endorsing;
    public static ReceiveSecurityHeaderBindingModes Signed;
    public static ReceiveSecurityHeaderBindingModes SignedEndorsing;
    public static ReceiveSecurityHeaderBindingModes Basic;
}
internal enum System.ServiceModel.Security.ReceiveSecurityHeaderElementCategory : Enum {
    public int value__;
    public static ReceiveSecurityHeaderElementCategory Signature;
    public static ReceiveSecurityHeaderElementCategory EncryptedData;
    public static ReceiveSecurityHeaderElementCategory EncryptedKey;
    public static ReceiveSecurityHeaderElementCategory SignatureConfirmation;
    public static ReceiveSecurityHeaderElementCategory ReferenceList;
    public static ReceiveSecurityHeaderElementCategory SecurityTokenReference;
    public static ReceiveSecurityHeaderElementCategory Timestamp;
    public static ReceiveSecurityHeaderElementCategory Token;
}
internal class System.ServiceModel.Security.ReceiveSecurityHeaderElementManager : object {
    public int Count { get; }
    public bool IsPrimaryTokenSigned { get; public set; }
    public ReceiveSecurityHeaderElementManager(ReceiveSecurityHeader securityHeader);
    public int get_Count();
    public bool get_IsPrimaryTokenSigned();
    public void set_IsPrimaryTokenSigned(bool value);
    public void AppendElement(ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, TokenTracker supportingTokenTracker);
    public void AppendSignature(SignedXml signedXml);
    public void AppendReferenceList(ReferenceList referenceList);
    public void AppendEncryptedData(EncryptedData encryptedData);
    public void AppendSignatureConfirmation(ISignatureValueSecurityElement signatureConfirmationElement);
    public void AppendTimestamp(SecurityTimestamp timestamp);
    public void AppendSecurityTokenReference(SecurityKeyIdentifierClause strClause, string strId);
    public void AppendToken(SecurityToken token, ReceiveSecurityHeaderBindingModes mode, TokenTracker supportingTokenTracker);
    public void EnsureAllRequiredSecurityHeaderTargetsWereProtected();
    public object GetElement(int index);
    public T GetElement(int index);
    public void GetElementEntry(int index, ReceiveSecurityHeaderEntry& element);
    public ReceiveSecurityHeaderElementCategory GetElementCategory(int index);
    public void GetPrimarySignature(XmlDictionaryReader& reader, String& id);
    internal XmlDictionaryReader GetReader(int index, bool requiresEncryptedFormReader);
    public XmlDictionaryReader GetSignatureVerificationReader(string id, bool requiresEncryptedFormReaderIfDecrypted);
    public void SetBindingMode(int index, ReceiveSecurityHeaderBindingModes bindingMode);
    public void SetElement(int index, object element);
    public void ReplaceHeaderEntry(int index, ReceiveSecurityHeaderEntry element);
    public void SetElementAfterDecryption(int index, ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
    public void SetSignatureAfterDecryption(int index, SignedXml signedXml, Byte[] decryptedBuffer);
    public void SetSignatureConfirmationAfterDecryption(int index, ISignatureValueSecurityElement signatureConfirmationElement, Byte[] decryptedBuffer);
    internal void SetSigned(int index);
    public void SetTimestampSigned(string id);
    public void SetTokenAfterDecryption(int index, SecurityToken token, ReceiveSecurityHeaderBindingModes mode, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
    internal bool TryGetTokenElementIndexFromStrId(string strId, Int32& index);
    public void VerifyUniquenessAndSetBodyId(string id);
    public void VerifyUniquenessAndSetBodyContentId(string id);
    public void VerifyUniquenessAndSetDecryptedHeaderId(string id, int headerIndex);
    public void VerifyUniquenessAndSetHeaderId(string id, int headerIndex);
    private sealed virtual override XmlDictionaryReader System.IdentityModel.ISignatureReaderProvider.GetReader(object callbackContext);
    public void VerifySignatureConfirmationWasFound();
}
internal class System.ServiceModel.Security.ReceiveSecurityHeaderEntry : ValueType {
    internal ReceiveSecurityHeaderElementCategory elementCategory;
    internal object element;
    internal ReceiveSecurityHeaderBindingModes bindingMode;
    internal string id;
    internal string encryptedFormId;
    internal string encryptedFormWsuId;
    internal bool signed;
    internal bool encrypted;
    internal Byte[] decryptedBuffer;
    internal TokenTracker supportingTokenTracker;
    internal bool doubleEncrypted;
    public bool MatchesId(string id, bool requiresEncryptedFormId);
    public void PreserveIdBeforeDecryption();
    public void SetElement(ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, bool encrypted, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
}
internal class System.ServiceModel.Security.RequestSecurityToken : BodyWriter {
    public Message Message { get; public set; }
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public int KeySize { get; public set; }
    public bool IsReadOnly { get; }
    public OnGetBinaryNegotiationCallback OnGetBinaryNegotiation { get; public set; }
    public IEnumerable`1<XmlElement> RequestProperties { get; public set; }
    public string RequestType { get; public set; }
    public SecurityKeyIdentifierClause RenewTarget { get; public set; }
    public SecurityKeyIdentifierClause CloseTarget { get; public set; }
    public XmlElement RequestSecurityTokenXml { get; }
    internal SecurityStandardsManager StandardsManager { get; internal set; }
    internal bool IsReceiver { get; }
    internal object AppliesTo { get; }
    internal DataContractSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    protected object ThisLock { get; }
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    public RequestSecurityToken(XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, XmlElement rstXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, bool isBuffered);
    public ChannelBinding GetChannelBinding();
    public Message get_Message();
    public void set_Message(Message value);
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsReadOnly();
    public OnGetBinaryNegotiationCallback get_OnGetBinaryNegotiation();
    public void set_OnGetBinaryNegotiation(OnGetBinaryNegotiationCallback value);
    public IEnumerable`1<XmlElement> get_RequestProperties();
    public void set_RequestProperties(IEnumerable`1<XmlElement> value);
    public string get_RequestType();
    public void set_RequestType(string value);
    public SecurityKeyIdentifierClause get_RenewTarget();
    public void set_RenewTarget(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_CloseTarget();
    public void set_CloseTarget(SecurityKeyIdentifierClause value);
    public XmlElement get_RequestSecurityTokenXml();
    internal SecurityStandardsManager get_StandardsManager();
    internal void set_StandardsManager(SecurityStandardsManager value);
    internal bool get_IsReceiver();
    internal object get_AppliesTo();
    internal DataContractSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    protected object get_ThisLock();
    internal void SetBinaryNegotiation(BinaryNegotiation negotiation);
    internal BinaryNegotiation GetBinaryNegotiation();
    public SecurityToken GetRequestorEntropy();
    internal SecurityToken GetRequestorEntropy(SecurityTokenResolver resolver);
    public void SetRequestorEntropy(Byte[] entropy);
    internal void SetRequestorEntropy(WrappedKeySecurityToken entropyToken);
    public void SetAppliesTo(T appliesTo, DataContractSerializer serializer);
    public void GetAppliesToQName(String& localName, String& namespaceUri);
    public T GetAppliesTo();
    public T GetAppliesTo(XmlObjectSerializer serializer);
    public void WriteTo(XmlWriter writer);
    public static RequestSecurityToken CreateFrom(XmlReader reader);
    public static RequestSecurityToken CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static RequestSecurityToken CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    public void MakeReadOnly();
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected internal virtual void OnMakeReadOnly();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponse : BodyWriter {
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public SecurityKeyIdentifierClause RequestedAttachedReference { get; public set; }
    public SecurityKeyIdentifierClause RequestedUnattachedReference { get; public set; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public bool ComputeKey { get; public set; }
    public int KeySize { get; public set; }
    public bool IsRequestedTokenClosed { get; public set; }
    public bool IsReadOnly { get; }
    protected object ThisLock { get; }
    internal bool IsReceiver { get; }
    internal SecurityStandardsManager StandardsManager { get; internal set; }
    public SecurityToken EntropyToken { get; }
    public SecurityToken RequestedSecurityToken { get; public set; }
    public SecurityToken RequestedProofToken { get; public set; }
    public XmlElement RequestSecurityTokenResponseXml { get; }
    internal object AppliesTo { get; }
    internal XmlObjectSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    internal bool IsLifetimeSet { get; }
    internal XmlBuffer IssuedTokenBuffer { get; }
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityTokenResponse(XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager, XmlElement rstrXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed, XmlBuffer issuedTokenBuffer);
    private static RequestSecurityTokenResponse();
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public SecurityKeyIdentifierClause get_RequestedAttachedReference();
    public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_RequestedUnattachedReference();
    public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value);
    public DateTime get_ValidFrom();
    public DateTime get_ValidTo();
    public bool get_ComputeKey();
    public void set_ComputeKey(bool value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsRequestedTokenClosed();
    public void set_IsRequestedTokenClosed(bool value);
    public bool get_IsReadOnly();
    protected object get_ThisLock();
    internal bool get_IsReceiver();
    internal SecurityStandardsManager get_StandardsManager();
    internal void set_StandardsManager(SecurityStandardsManager value);
    public SecurityToken get_EntropyToken();
    public SecurityToken get_RequestedSecurityToken();
    public void set_RequestedSecurityToken(SecurityToken value);
    public SecurityToken get_RequestedProofToken();
    public void set_RequestedProofToken(SecurityToken value);
    public XmlElement get_RequestSecurityTokenResponseXml();
    internal object get_AppliesTo();
    internal XmlObjectSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    internal bool get_IsLifetimeSet();
    internal XmlBuffer get_IssuedTokenBuffer();
    public void SetIssuerEntropy(Byte[] issuerEntropy);
    internal void SetIssuerEntropy(WrappedKeySecurityToken issuerEntropy);
    public SecurityToken GetIssuerEntropy();
    internal SecurityToken GetIssuerEntropy(SecurityTokenResolver resolver);
    public void SetLifetime(DateTime validFrom, DateTime validTo);
    public void SetAppliesTo(T appliesTo, XmlObjectSerializer serializer);
    public void GetAppliesToQName(String& localName, String& namespaceUri);
    public T GetAppliesTo();
    public T GetAppliesTo(XmlObjectSerializer serializer);
    internal void SetBinaryNegotiation(BinaryNegotiation negotiation);
    internal BinaryNegotiation GetBinaryNegotiation();
    internal void SetAuthenticator(Byte[] authenticator);
    internal Byte[] GetAuthenticator();
    public void WriteTo(XmlWriter writer);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static RequestSecurityTokenResponse CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    public void MakeReadOnly();
    public GenericXmlSecurityToken GetIssuedToken(SecurityTokenResolver resolver, IList`1<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, Byte[] requestorEntropy, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public virtual GenericXmlSecurityToken GetIssuedToken(SecurityTokenResolver resolver, IList`1<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, Byte[] requestorEntropy, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType);
    public virtual GenericXmlSecurityToken GetIssuedToken(string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, RSA clientKey);
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected virtual void OnMakeReadOnly();
    public static Byte[] ComputeCombinedKey(Byte[] requestorEntropy, Byte[] issuerEntropy, int keySizeInBits);
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponseCollection : BodyWriter {
    public IEnumerable`1<RequestSecurityTokenResponse> RstrCollection { get; }
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection);
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection, SecurityStandardsManager standardsManager);
    public IEnumerable`1<RequestSecurityTokenResponse> get_RstrCollection();
    public void WriteTo(XmlWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.RoleProviderPrincipal : object {
    public IIdentity Identity { get; }
    public RoleProviderPrincipal(object roleProvider, ServiceSecurityContext securityContext);
    public sealed virtual IIdentity get_Identity();
    public sealed virtual bool IsInRole(string role);
}
public class System.ServiceModel.Security.ScopedMessagePartSpecification : object {
    public ICollection`1<string> Actions { get; }
    public MessagePartSpecification ChannelParts { get; }
    public bool IsReadOnly { get; }
    public ScopedMessagePartSpecification(ScopedMessagePartSpecification other);
    internal ScopedMessagePartSpecification(ScopedMessagePartSpecification other, bool newIncludeBody);
    public ICollection`1<string> get_Actions();
    public MessagePartSpecification get_ChannelParts();
    public bool get_IsReadOnly();
    public void AddParts(MessagePartSpecification parts);
    public void AddParts(MessagePartSpecification parts, string action);
    internal void AddParts(MessagePartSpecification parts, XmlDictionaryString action);
    internal bool IsEmpty();
    public bool TryGetParts(string action, bool excludeChannelScope, MessagePartSpecification& parts);
    internal void CopyTo(ScopedMessagePartSpecification target);
    public bool TryGetParts(string action, MessagePartSpecification& parts);
    public void MakeReadOnly();
}
internal class System.ServiceModel.Security.SctClaimDictionary : XmlDictionary {
    public static SctClaimDictionary Instance { get; }
    public XmlDictionaryString Claim { get; }
    public XmlDictionaryString ClaimSets { get; }
    public XmlDictionaryString ClaimSet { get; }
    public XmlDictionaryString PrimaryIssuer { get; }
    public XmlDictionaryString Identities { get; }
    public XmlDictionaryString PrimaryIdentity { get; }
    public XmlDictionaryString X509CertificateClaimSet { get; }
    public XmlDictionaryString SystemClaimSet { get; }
    public XmlDictionaryString WindowsClaimSet { get; }
    public XmlDictionaryString AnonymousClaimSet { get; }
    public XmlDictionaryString ContextId { get; }
    public XmlDictionaryString BinaryClaim { get; }
    public XmlDictionaryString DnsClaim { get; }
    public XmlDictionaryString GenericIdentity { get; }
    public XmlDictionaryString AuthenticationType { get; }
    public XmlDictionaryString Right { get; }
    public XmlDictionaryString HashClaim { get; }
    public XmlDictionaryString MailAddressClaim { get; }
    public XmlDictionaryString NameClaim { get; }
    public XmlDictionaryString RsaClaim { get; }
    public XmlDictionaryString SpnClaim { get; }
    public XmlDictionaryString SystemClaim { get; }
    public XmlDictionaryString UpnClaim { get; }
    public XmlDictionaryString UrlClaim { get; }
    public XmlDictionaryString WindowsSidClaim { get; }
    public XmlDictionaryString DenyOnlySidClaim { get; }
    public XmlDictionaryString WindowsSidIdentity { get; }
    public XmlDictionaryString X500DistinguishedNameClaim { get; }
    public XmlDictionaryString X509ThumbprintClaim { get; }
    public XmlDictionaryString EffectiveTime { get; }
    public XmlDictionaryString ExpiryTime { get; }
    public XmlDictionaryString Id { get; }
    public XmlDictionaryString IsCookieMode { get; }
    public XmlDictionaryString Key { get; }
    public XmlDictionaryString Sid { get; }
    public XmlDictionaryString Name { get; }
    public XmlDictionaryString NullValue { get; }
    public XmlDictionaryString SecurityContextSecurityToken { get; }
    public XmlDictionaryString ServiceContractId { get; }
    public XmlDictionaryString Value { get; }
    public XmlDictionaryString Version { get; }
    public XmlDictionaryString GenericXmlSecurityToken { get; }
    public XmlDictionaryString TokenType { get; }
    public XmlDictionaryString TokenXml { get; }
    public XmlDictionaryString InternalTokenReference { get; }
    public XmlDictionaryString ExternalTokenReference { get; }
    public XmlDictionaryString EmptyString { get; }
    public XmlDictionaryString KeyGeneration { get; }
    public XmlDictionaryString KeyEffectiveTime { get; }
    public XmlDictionaryString KeyExpiryTime { get; }
    private static SctClaimDictionary();
    public static SctClaimDictionary get_Instance();
    public XmlDictionaryString get_Claim();
    public XmlDictionaryString get_ClaimSets();
    public XmlDictionaryString get_ClaimSet();
    public XmlDictionaryString get_PrimaryIssuer();
    public XmlDictionaryString get_Identities();
    public XmlDictionaryString get_PrimaryIdentity();
    public XmlDictionaryString get_X509CertificateClaimSet();
    public XmlDictionaryString get_SystemClaimSet();
    public XmlDictionaryString get_WindowsClaimSet();
    public XmlDictionaryString get_AnonymousClaimSet();
    public XmlDictionaryString get_ContextId();
    public XmlDictionaryString get_BinaryClaim();
    public XmlDictionaryString get_DnsClaim();
    public XmlDictionaryString get_GenericIdentity();
    public XmlDictionaryString get_AuthenticationType();
    public XmlDictionaryString get_Right();
    public XmlDictionaryString get_HashClaim();
    public XmlDictionaryString get_MailAddressClaim();
    public XmlDictionaryString get_NameClaim();
    public XmlDictionaryString get_RsaClaim();
    public XmlDictionaryString get_SpnClaim();
    public XmlDictionaryString get_SystemClaim();
    public XmlDictionaryString get_UpnClaim();
    public XmlDictionaryString get_UrlClaim();
    public XmlDictionaryString get_WindowsSidClaim();
    public XmlDictionaryString get_DenyOnlySidClaim();
    public XmlDictionaryString get_WindowsSidIdentity();
    public XmlDictionaryString get_X500DistinguishedNameClaim();
    public XmlDictionaryString get_X509ThumbprintClaim();
    public XmlDictionaryString get_EffectiveTime();
    public XmlDictionaryString get_ExpiryTime();
    public XmlDictionaryString get_Id();
    public XmlDictionaryString get_IsCookieMode();
    public XmlDictionaryString get_Key();
    public XmlDictionaryString get_Sid();
    public XmlDictionaryString get_Name();
    public XmlDictionaryString get_NullValue();
    public XmlDictionaryString get_SecurityContextSecurityToken();
    public XmlDictionaryString get_ServiceContractId();
    public XmlDictionaryString get_Value();
    public XmlDictionaryString get_Version();
    public XmlDictionaryString get_GenericXmlSecurityToken();
    public XmlDictionaryString get_TokenType();
    public XmlDictionaryString get_TokenXml();
    public XmlDictionaryString get_InternalTokenReference();
    public XmlDictionaryString get_ExternalTokenReference();
    public XmlDictionaryString get_EmptyString();
    public XmlDictionaryString get_KeyGeneration();
    public XmlDictionaryString get_KeyEffectiveTime();
    public XmlDictionaryString get_KeyExpiryTime();
}
internal static class System.ServiceModel.Security.SctClaimSerializer : object {
    public static void SerializeClaim(Claim claim, SctClaimDictionary dictionary, XmlDictionaryWriter writer, XmlObjectSerializer serializer);
    public static void SerializeClaimSet(ClaimSet claimSet, SctClaimDictionary dictionary, XmlDictionaryWriter writer, XmlObjectSerializer serializer, XmlObjectSerializer claimSerializer);
    public static Claim DeserializeClaim(XmlDictionaryReader reader, SctClaimDictionary dictionary, XmlObjectSerializer serializer);
    public static ClaimSet DeserializeClaimSet(XmlDictionaryReader reader, SctClaimDictionary dictionary, XmlObjectSerializer serializer, XmlObjectSerializer claimSerializer);
    public static void SerializeIdentities(AuthorizationContext authContext, SctClaimDictionary dictionary, XmlDictionaryWriter writer, XmlObjectSerializer serializer);
    public static IList`1<IIdentity> DeserializeIdentities(XmlDictionaryReader reader, SctClaimDictionary dictionary, XmlObjectSerializer serializer);
}
internal class System.ServiceModel.Security.SctClaimsHandler : object {
    public string EndpointId { get; }
    public SecurityTokenHandlerCollection SecurityTokenHandlerCollection { get; }
    public SctClaimsHandler(SecurityTokenHandlerCollection securityTokenHandlerCollection, string endpointId);
    public string get_EndpointId();
    public SecurityTokenHandlerCollection get_SecurityTokenHandlerCollection();
    internal void SetPrincipalBootstrapTokensAndBindIdfxAuthPolicy(SecurityContextSecurityToken sct);
    public void OnTokenIssued(SecurityToken issuedToken, EndpointAddress tokenRequestor);
    public void OnTokenRenewed(SecurityToken issuedToken, SecurityToken oldToken);
}
internal abstract class System.ServiceModel.Security.SecureConversationDriver : object {
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString RenewNeededFaultCode { get; }
    public XmlDictionaryString BadContextTokenFaultCode { get; }
    public string TokenTypeUri { get; }
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_IssueAction();
    public abstract virtual XmlDictionaryString get_IssueResponseAction();
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual XmlDictionaryString get_RenewNeededFaultCode();
    public abstract virtual XmlDictionaryString get_BadContextTokenFaultCode();
    public abstract virtual string get_TokenTypeUri();
    public abstract virtual UniqueId GetSecurityContextTokenId(XmlDictionaryReader reader);
    public abstract virtual bool IsAtSecurityContextToken(XmlDictionaryReader reader);
}
public class System.ServiceModel.Security.SecureConversationServiceCredential : object {
    public SecurityStateEncoder SecurityStateEncoder { get; public set; }
    public Collection`1<Type> SecurityContextClaimTypes { get; }
    internal SecureConversationServiceCredential(SecureConversationServiceCredential other);
    private static SecureConversationServiceCredential();
    public SecurityStateEncoder get_SecurityStateEncoder();
    public void set_SecurityStateEncoder(SecurityStateEncoder value);
    public Collection`1<Type> get_SecurityContextClaimTypes();
    internal void MakeReadOnly();
}
public abstract class System.ServiceModel.Security.SecureConversationVersion : object {
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static SecureConversationVersion Default { get; }
    public static SecureConversationVersion WSSecureConversationFeb2005 { get; }
    public static SecureConversationVersion WSSecureConversation13 { get; }
    internal SecureConversationVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static SecureConversationVersion get_Default();
    public static SecureConversationVersion get_WSSecureConversationFeb2005();
    public static SecureConversationVersion get_WSSecureConversation13();
}
public class System.ServiceModel.Security.SecurityAccessDeniedException : CommunicationException {
    public SecurityAccessDeniedException(string message);
    public SecurityAccessDeniedException(string message, Exception innerException);
    protected SecurityAccessDeniedException(SerializationInfo info, StreamingContext context);
}
[TypeConverterAttribute("System.ServiceModel.Configuration.SecurityAlgorithmSuiteConverter")]
public abstract class System.ServiceModel.Security.SecurityAlgorithmSuite : object {
    internal static SecurityAlgorithmSuite KerberosDefault { get; }
    public static SecurityAlgorithmSuite Default { get; }
    public static SecurityAlgorithmSuite Basic256 { get; }
    public static SecurityAlgorithmSuite Basic192 { get; }
    public static SecurityAlgorithmSuite Basic128 { get; }
    public static SecurityAlgorithmSuite TripleDes { get; }
    public static SecurityAlgorithmSuite Basic256Rsa15 { get; }
    public static SecurityAlgorithmSuite Basic192Rsa15 { get; }
    public static SecurityAlgorithmSuite Basic128Rsa15 { get; }
    public static SecurityAlgorithmSuite TripleDesRsa15 { get; }
    public static SecurityAlgorithmSuite Basic256Sha256 { get; }
    public static SecurityAlgorithmSuite Basic192Sha256 { get; }
    public static SecurityAlgorithmSuite Basic128Sha256 { get; }
    public static SecurityAlgorithmSuite TripleDesSha256 { get; }
    public static SecurityAlgorithmSuite Basic256Sha256Rsa15 { get; }
    public static SecurityAlgorithmSuite Basic192Sha256Rsa15 { get; }
    public static SecurityAlgorithmSuite Basic128Sha256Rsa15 { get; }
    public static SecurityAlgorithmSuite TripleDesSha256Rsa15 { get; }
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal static SecurityAlgorithmSuite get_KerberosDefault();
    public static SecurityAlgorithmSuite get_Default();
    public static SecurityAlgorithmSuite get_Basic256();
    public static SecurityAlgorithmSuite get_Basic192();
    public static SecurityAlgorithmSuite get_Basic128();
    public static SecurityAlgorithmSuite get_TripleDes();
    public static SecurityAlgorithmSuite get_Basic256Rsa15();
    public static SecurityAlgorithmSuite get_Basic192Rsa15();
    public static SecurityAlgorithmSuite get_Basic128Rsa15();
    public static SecurityAlgorithmSuite get_TripleDesRsa15();
    public static SecurityAlgorithmSuite get_Basic256Sha256();
    public static SecurityAlgorithmSuite get_Basic192Sha256();
    public static SecurityAlgorithmSuite get_Basic128Sha256();
    public static SecurityAlgorithmSuite get_TripleDesSha256();
    public static SecurityAlgorithmSuite get_Basic256Sha256Rsa15();
    public static SecurityAlgorithmSuite get_Basic192Sha256Rsa15();
    public static SecurityAlgorithmSuite get_Basic128Sha256Rsa15();
    public static SecurityAlgorithmSuite get_TripleDesSha256Rsa15();
    public abstract virtual string get_DefaultCanonicalizationAlgorithm();
    public abstract virtual string get_DefaultDigestAlgorithm();
    public abstract virtual string get_DefaultEncryptionAlgorithm();
    public abstract virtual int get_DefaultEncryptionKeyDerivationLength();
    public abstract virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultSymmetricSignatureAlgorithm();
    public abstract virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public abstract virtual int get_DefaultSignatureKeyDerivationLength();
    public abstract virtual int get_DefaultSymmetricKeyLength();
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual bool IsCanonicalizationAlgorithmSupported(string algorithm);
    public virtual bool IsDigestAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionKeyDerivationAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsSignatureKeyDerivationAlgorithmSupported(string algorithm);
    public abstract virtual bool IsSymmetricKeyLengthSupported(int length);
    public abstract virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal static bool IsRsaSHA256(SecurityAlgorithmSuite suite);
    internal string GetEncryptionKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version);
    internal int GetEncryptionKeyDerivationLength(SecurityToken token, SecureConversationVersion version);
    internal void GetKeyWrapAlgorithm(SecurityToken token, String& keyWrapAlgorithm, XmlDictionaryString& keyWrapAlgorithmDictionaryString);
    internal void GetSignatureAlgorithmAndKey(SecurityToken token, String& signatureAlgorithm, SecurityKey& key, XmlDictionaryString& signatureAlgorithmDictionaryString);
    internal string GetSignatureKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version);
    internal int GetSignatureKeyDerivationLength(SecurityToken token, SecureConversationVersion version);
    internal void EnsureAcceptableSymmetricSignatureAlgorithm(string algorithm);
    internal void EnsureAcceptableSignatureKeySize(SecurityKey securityKey, SecurityToken token);
    internal void EnsureAcceptableSignatureSymmetricKeySize(SymmetricSecurityKey securityKey, SecurityToken token);
    internal void EnsureAcceptableDecryptionSymmetricKeySize(SymmetricSecurityKey securityKey, SecurityToken token);
    internal void EnsureAcceptableSignatureAlgorithm(SecurityKey verificationKey, string algorithm);
    internal void EnsureAcceptableAsymmetricSignatureAlgorithm(string algorithm);
    internal void EnsureAcceptableKeyWrapAlgorithm(string algorithm, bool isAsymmetric);
    internal void EnsureAcceptableEncryptionAlgorithm(string algorithm);
    internal void EnsureAcceptableSignatureKeyDerivationAlgorithm(string algorithm);
    internal void EnsureAcceptableEncryptionKeyDerivationAlgorithm(string algorithm);
    internal void EnsureAcceptableDigestAlgorithm(string algorithm);
}
internal class System.ServiceModel.Security.SecurityAppliedMessage : DelegatingMessage {
    public string BodyId { get; }
    public MessagePartProtectionMode BodyProtectionMode { get; }
    internal Byte[] PrimarySignatureValue { get; }
    public SecurityAppliedMessage(Message messageToProcess, SendSecurityHeader securityHeader, bool signBody, bool encryptBody);
    public string get_BodyId();
    public MessagePartProtectionMode get_BodyProtectionMode();
    internal Byte[] get_PrimarySignatureValue();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    public void WriteBodyToEncrypt(EncryptedData encryptedData, SymmetricAlgorithm algorithm);
    public void WriteBodyToEncryptThenSign(Stream canonicalStream, EncryptedData encryptedData, SymmetricAlgorithm algorithm);
    public void WriteBodyToSign(Stream canonicalStream);
    public void WriteBodyToSignThenEncrypt(Stream canonicalStream, EncryptedData encryptedData, SymmetricAlgorithm algorithm);
    public void WriteBodyToSignThenEncryptWithFragments(Stream stream, bool includeComments, String[] inclusivePrefixes, EncryptedData encryptedData, SymmetricAlgorithm algorithm, XmlDictionaryWriter writer);
    public void WriteBodyToSignWithFragments(Stream stream, bool includeComments, String[] inclusivePrefixes, XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.Security.SecurityAuditHelper : object {
    public static bool IsSecurityAuditSupported { get; }
    public static bool get_IsSecurityAuditSupported();
    public static void WriteServiceAuthorizationSuccessEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity, string authContextId, string serviceAuthorizationManager);
    public static void WriteServiceAuthorizationFailureEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity, string authContextId, string serviceAuthorizationManager, Exception exception);
    public static void WriteMessageAuthenticationSuccessEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity);
    public static void WriteMessageAuthenticationFailureEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity, Exception exception);
    public static void WriteImpersonationSuccessEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, string operationName, string clientIdentity);
    public static void WriteImpersonationFailureEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, string operationName, string clientIdentity, Exception exception);
    public static void WriteSecurityNegotiationSuccessEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity, string negotiationType);
    public static void WriteSecurityNegotiationFailureEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string action, string clientIdentity, string negotiationType, Exception exception);
    public static void WriteTransportAuthenticationSuccessEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string clientIdentity);
    public static void WriteTransportAuthenticationFailureEvent(AuditLogLocation auditLogLocation, bool suppressAuditFailure, Message message, Uri serviceUri, string clientIdentity, Exception exception);
}
internal abstract class System.ServiceModel.Security.SecurityChannel`1 : LayeredChannel`1<TChannel> {
    public SecurityProtocol SecurityProtocol { get; protected set; }
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel);
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel, SecurityProtocol securityProtocol);
    public virtual T GetProperty();
    public SecurityProtocol get_SecurityProtocol();
    protected void set_SecurityProtocol(SecurityProtocol value);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected void ThrowIfDisposedOrNotOpen(Message message);
}
internal class System.ServiceModel.Security.SecurityContextTokenCache : TimeBoundedCache {
    public SecurityContextTokenCache(int capacity, bool replaceOldestEntries);
    public SecurityContextTokenCache(int capacity, bool replaceOldestEntries, TimeSpan clockSkew);
    private static SecurityContextTokenCache();
    public void AddContext(SecurityContextSecurityToken token);
    public bool TryAddContext(SecurityContextSecurityToken token);
    public void ClearContexts();
    public SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public void RemoveContext(UniqueId contextId, UniqueId generation, bool throwIfNotPresent);
    public void RemoveAllContexts(UniqueId contextId);
    public void UpdateContextCachingTime(SecurityContextSecurityToken token, DateTime expirationTime);
    public Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    protected virtual void OnRemove(object item);
}
public abstract class System.ServiceModel.Security.SecurityCredentialsManager : object {
    public abstract virtual SecurityTokenManager CreateSecurityTokenManager();
}
internal abstract class System.ServiceModel.Security.SecurityHeader : MessageHeader {
    public string Actor { get; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; }
    public bool EncryptedKeyContainsReferenceList { get; public set; }
    public bool RequireMessageProtection { get; public set; }
    public bool MaintainSignatureConfirmationState { get; public set; }
    protected Message Message { get; protected set; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public SecurityHeaderLayout Layout { get; public set; }
    public SecurityStandardsManager StandardsManager { get; }
    public MessageDirection MessageDirection { get; }
    protected MessageVersion Version { get; }
    public SecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    public virtual string get_Actor();
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public bool get_EncryptedKeyContainsReferenceList();
    public void set_EncryptedKeyContainsReferenceList(bool value);
    public bool get_RequireMessageProtection();
    public void set_RequireMessageProtection(bool value);
    public bool get_MaintainSignatureConfirmationState();
    public void set_MaintainSignatureConfirmationState(bool value);
    protected Message get_Message();
    protected void set_Message(Message value);
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public SecurityHeaderLayout get_Layout();
    public void set_Layout(SecurityHeaderLayout value);
    public SecurityStandardsManager get_StandardsManager();
    public MessageDirection get_MessageDirection();
    protected MessageVersion get_Version();
    protected void SetProcessingStarted();
    protected void ThrowIfProcessingStarted();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Security.SecurityHeaderElementInferenceEngine : object {
    public abstract virtual void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
    public abstract virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
    public static SecurityHeaderElementInferenceEngine GetInferenceEngine(SecurityHeaderLayout layout);
}
internal class System.ServiceModel.Security.SecurityHeaderTokenResolver : SecurityTokenResolver {
    public SecurityToken ExpectedWrapper { get; public set; }
    public SecurityTokenParameters ExpectedWrapperTokenParameters { get; public set; }
    public SecurityHeaderTokenResolver(ReceiveSecurityHeader securityHeader);
    public sealed virtual SecurityToken get_ExpectedWrapper();
    public sealed virtual void set_ExpectedWrapper(SecurityToken value);
    public SecurityTokenParameters get_ExpectedWrapperTokenParameters();
    public void set_ExpectedWrapperTokenParameters(SecurityTokenParameters value);
    public void Add(SecurityToken token);
    public void Add(SecurityToken token, SecurityTokenReferenceStyle allowedReferenceStyle, SecurityTokenParameters tokenParameters);
    public sealed virtual bool CheckExternalWrapperMatch(SecurityKeyIdentifier keyIdentifier);
    internal SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause);
    internal SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternal, bool resolveIntrinsicKeyClause);
    public virtual string ToString();
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    internal bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    internal bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, SecurityToken& token);
    internal bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, bool createIntrinsicKeys, SecurityKey& key);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
}
public enum System.ServiceModel.Security.SecurityKeyEntropyMode : Enum {
    public int value__;
    public static SecurityKeyEntropyMode ClientEntropy;
    public static SecurityKeyEntropyMode ServerEntropy;
    public static SecurityKeyEntropyMode CombinedEntropy;
}
internal class System.ServiceModel.Security.SecurityKeyEntropyModeHelper : object {
    internal static bool IsDefined(SecurityKeyEntropyMode value);
    internal static void Validate(SecurityKeyEntropyMode value);
}
internal class System.ServiceModel.Security.SecurityListenerSettingsLifetimeManager : object {
    public SecurityListenerSettingsLifetimeManager(SecurityProtocolFactory securityProtocolFactory, SecuritySessionServerSettings sessionSettings, bool sessionMode, IChannelListener innerListener);
    public void Abort();
    public void AddReference();
    public void Open(TimeSpan timeout);
    public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult result);
    public void Close(TimeSpan timeout);
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndClose(IAsyncResult result);
}
public class System.ServiceModel.Security.SecurityMessageProperty : object {
    public ServiceSecurityContext ServiceSecurityContext { get; public set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; public set; }
    public SecurityTokenSpecification ProtectionToken { get; public set; }
    public SecurityTokenSpecification InitiatorToken { get; public set; }
    public SecurityTokenSpecification RecipientToken { get; public set; }
    public SecurityTokenSpecification TransportToken { get; public set; }
    public string SenderIdPrefix { get; public set; }
    public bool HasIncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> IncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> OutgoingSupportingTokens { get; }
    internal bool HasOutgoingSupportingTokens { get; }
    public ServiceSecurityContext get_ServiceSecurityContext();
    public void set_ServiceSecurityContext(ServiceSecurityContext value);
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_ExternalAuthorizationPolicies();
    public void set_ExternalAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public SecurityTokenSpecification get_ProtectionToken();
    public void set_ProtectionToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_InitiatorToken();
    public void set_InitiatorToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_RecipientToken();
    public void set_RecipientToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_TransportToken();
    public void set_TransportToken(SecurityTokenSpecification value);
    public string get_SenderIdPrefix();
    public void set_SenderIdPrefix(string value);
    public bool get_HasIncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_IncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_OutgoingSupportingTokens();
    internal bool get_HasOutgoingSupportingTokens();
    public sealed virtual IMessageProperty CreateCopy();
    public static SecurityMessageProperty GetOrCreate(Message message);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies();
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude);
    public sealed virtual void Dispose();
}
internal static class System.ServiceModel.Security.SecurityNegotiationConstants : object {
    internal static int NegotiationAuthenticatorSize;
    internal static string NegotiationFault;
}
public class System.ServiceModel.Security.SecurityNegotiationException : CommunicationException {
    public SecurityNegotiationException(string message);
    public SecurityNegotiationException(string message, Exception innerException);
    protected SecurityNegotiationException(SerializationInfo info, StreamingContext context);
}
internal static class System.ServiceModel.Security.SecurityPolicyStrings : object {
    public static string SecureConversationBootstrapBindingElementsBelowSecurityKey;
}
public abstract class System.ServiceModel.Security.SecurityPolicyVersion : object {
    public string Namespace { get; }
    public string Prefix { get; }
    public static SecurityPolicyVersion WSSecurityPolicy11 { get; }
    public static SecurityPolicyVersion WSSecurityPolicy12 { get; }
    internal SecurityPolicyVersion(string ns, string prefix);
    public string get_Namespace();
    public string get_Prefix();
    public static SecurityPolicyVersion get_WSSecurityPolicy11();
    public static SecurityPolicyVersion get_WSSecurityPolicy12();
}
internal abstract class System.ServiceModel.Security.SecurityProtocol : object {
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public SecurityProtocolFactory SecurityProtocolFactory { get; }
    public EndpointAddress Target { get; }
    public Uri Via { get; }
    public ICollection`1<SupportingTokenProviderSpecification> ChannelSupportingTokenProviderSpecification { get; }
    public Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> ScopedSupportingTokenProviderSpecification { get; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    protected SecurityProtocol(SecurityProtocolFactory factory, EndpointAddress target, Uri via);
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public SecurityProtocolFactory get_SecurityProtocolFactory();
    public EndpointAddress get_Target();
    public Uri get_Via();
    public ICollection`1<SupportingTokenProviderSpecification> get_ChannelSupportingTokenProviderSpecification();
    public Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> get_ScopedSupportingTokenProviderSpecification();
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    internal IList`1<SupportingTokenProviderSpecification> GetSupportingTokenProviders(string action);
    protected InitiatorServiceModelSecurityTokenRequirement CreateInitiatorSecurityTokenRequirement();
    public void Open(TimeSpan timeout);
    public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult result);
    public virtual void OnOpen(TimeSpan timeout);
    public void Close(bool aborted, TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndClose(IAsyncResult result);
    protected void AddSupportingTokenSpecification(SecurityMessageProperty security, IList`1<SecurityToken> basicTokens, IList`1<SecurityToken> endorsingTokens, IList`1<SecurityToken> signedEndorsingTokens, IList`1<SecurityToken> signedTokens, IDictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, SecurityProtocolFactory factory);
    protected SendSecurityHeader CreateSendSecurityHeaderForTransportProtocol(Message message, string actor, SecurityProtocolFactory factory);
    internal void AddMessageSupportingTokens(Message message, IList`1& supportingTokens);
    internal bool TryGetSupportingTokens(SecurityProtocolFactory factory, EndpointAddress target, Uri via, Message message, TimeSpan timeout, bool isBlockingCall, IList`1& supportingTokens);
    protected IList`1<SupportingTokenAuthenticatorSpecification> GetSupportingTokenAuthenticatorsAndSetExpectationFlags(SecurityProtocolFactory factory, Message message, ReceiveSecurityHeader securityHeader);
    protected ReadOnlyCollection`1<SecurityTokenResolver> MergeOutOfBandResolvers(IList`1<SupportingTokenAuthenticatorSpecification> supportingAuthenticators, ReadOnlyCollection`1<SecurityTokenResolver> primaryResolvers);
    protected void AddSupportingTokens(SendSecurityHeader securityHeader, IList`1<SupportingTokenSpecification> supportingTokens);
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginVerifyIncomingMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginVerifyIncomingMessage(Message message, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates, AsyncCallback callback, object state);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    public virtual void EndVerifyIncomingMessage(IAsyncResult result, Message& message);
    public virtual void EndVerifyIncomingMessage(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    internal static SecurityToken GetToken(SecurityTokenProvider provider, EndpointAddress target, TimeSpan timeout);
    public abstract virtual void SecureOutgoingMessage(Message& message, TimeSpan timeout);
    public virtual SecurityProtocolCorrelationState SecureOutgoingMessage(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual void OnOutgoingMessageSecured(Message securedMessage);
    protected virtual void OnSecureOutgoingMessageFailure(Message message);
    public abstract virtual void VerifyIncomingMessage(Message& message, TimeSpan timeout);
    public virtual SecurityProtocolCorrelationState VerifyIncomingMessage(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
    protected virtual void OnIncomingMessageVerified(Message verifiedMessage);
    protected virtual void OnVerifyIncomingMessageFailure(Message message, Exception exception);
}
internal class System.ServiceModel.Security.SecurityProtocolCorrelationState : object {
    public SecurityToken Token { get; }
    internal SignatureConfirmations SignatureConfirmations { get; internal set; }
    internal ServiceModelActivity Activity { get; }
    public SecurityProtocolCorrelationState(SecurityToken token);
    public SecurityToken get_Token();
    internal SignatureConfirmations get_SignatureConfirmations();
    internal void set_SignatureConfirmations(SignatureConfirmations value);
    internal ServiceModelActivity get_Activity();
}
internal abstract class System.ServiceModel.Security.SecurityProtocolFactory : object {
    internal static bool defaultAddTimestamp;
    internal static bool defaultDeriveKeys;
    internal static bool defaultDetectReplays;
    internal static string defaultMaxClockSkewString;
    internal static string defaultReplayWindowString;
    internal static TimeSpan defaultMaxClockSkew;
    internal static TimeSpan defaultReplayWindow;
    internal static int defaultMaxCachedNonces;
    internal static string defaultTimestampValidityDurationString;
    internal static TimeSpan defaultTimestampValidityDuration;
    internal static SecurityHeaderLayout defaultSecurityHeaderLayout;
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public bool ActAsInitiator { get; }
    public BufferManager StreamBufferManager { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    internal bool IsDuplexReply { get; internal set; }
    public bool AddTimestamp { get; public set; }
    public AuditLogLocation AuditLogLocation { get; public set; }
    public bool SuppressAuditFailure { get; public set; }
    public AuditLevel ServiceAuthorizationAuditLevel { get; public set; }
    public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public bool DetectReplays { get; public set; }
    public Uri PrivacyNoticeUri { get; public set; }
    public int PrivacyNoticeVersion { get; public set; }
    public IMessageFilterTable`1<EndpointAddress> EndpointFilterTable { get; public set; }
    internal NonValidatingSecurityTokenAuthenticator`1<DerivedKeySecurityToken> DerivedKeyTokenAuthenticator { get; }
    internal bool ExpectIncomingMessages { get; }
    internal bool ExpectOutgoingMessages { get; }
    internal bool ExpectKeyDerivation { get; internal set; }
    internal bool ExpectSupportingTokens { get; internal set; }
    public SecurityAlgorithmSuite IncomingAlgorithmSuite { get; public set; }
    protected bool IsReadOnly { get; }
    public int MaxCachedNonces { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public SecurityAlgorithmSuite OutgoingAlgorithmSuite { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public ICollection`1<SupportingTokenAuthenticatorSpecification> ChannelSupportingTokenAuthenticatorSpecification { get; }
    public Dictionary`2<string, ICollection`1<SupportingTokenAuthenticatorSpecification>> ScopedSupportingTokenAuthenticatorSpecification { get; }
    public SecurityBindingElement SecurityBindingElement { get; public set; }
    public SecurityTokenManager SecurityTokenManager { get; public set; }
    public bool SupportsDuplex { get; }
    public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    public bool SupportsReplayDetection { get; }
    public bool SupportsRequestReply { get; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    public Uri ListenUri { get; public set; }
    internal MessageSecurityVersion MessageSecurityVersion { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal SecurityProtocolFactory(SecurityProtocolFactory factory);
    private static SecurityProtocolFactory();
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public bool get_ActAsInitiator();
    public BufferManager get_StreamBufferManager();
    public void set_StreamBufferManager(BufferManager value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal bool get_IsDuplexReply();
    internal void set_IsDuplexReply(bool value);
    public bool get_AddTimestamp();
    public void set_AddTimestamp(bool value);
    public AuditLogLocation get_AuditLogLocation();
    public void set_AuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_ServiceAuthorizationAuditLevel();
    public void set_ServiceAuthorizationAuditLevel(AuditLevel value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public Uri get_PrivacyNoticeUri();
    public void set_PrivacyNoticeUri(Uri value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public IMessageFilterTable`1<EndpointAddress> get_EndpointFilterTable();
    public void set_EndpointFilterTable(IMessageFilterTable`1<EndpointAddress> value);
    internal NonValidatingSecurityTokenAuthenticator`1<DerivedKeySecurityToken> get_DerivedKeyTokenAuthenticator();
    internal bool get_ExpectIncomingMessages();
    internal bool get_ExpectOutgoingMessages();
    internal bool get_ExpectKeyDerivation();
    internal void set_ExpectKeyDerivation(bool value);
    internal bool get_ExpectSupportingTokens();
    internal void set_ExpectSupportingTokens(bool value);
    public SecurityAlgorithmSuite get_IncomingAlgorithmSuite();
    public void set_IncomingAlgorithmSuite(SecurityAlgorithmSuite value);
    protected bool get_IsReadOnly();
    public int get_MaxCachedNonces();
    public void set_MaxCachedNonces(int value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public NonceCache get_NonceCache();
    public void set_NonceCache(NonceCache value);
    public SecurityAlgorithmSuite get_OutgoingAlgorithmSuite();
    public void set_OutgoingAlgorithmSuite(SecurityAlgorithmSuite value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public ICollection`1<SupportingTokenAuthenticatorSpecification> get_ChannelSupportingTokenAuthenticatorSpecification();
    public Dictionary`2<string, ICollection`1<SupportingTokenAuthenticatorSpecification>> get_ScopedSupportingTokenAuthenticatorSpecification();
    public SecurityBindingElement get_SecurityBindingElement();
    public void set_SecurityBindingElement(SecurityBindingElement value);
    public SecurityTokenManager get_SecurityTokenManager();
    public void set_SecurityTokenManager(SecurityTokenManager value);
    public virtual bool get_SupportsDuplex();
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public virtual bool get_SupportsReplayDetection();
    public virtual bool get_SupportsRequestReply();
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    internal MessageSecurityVersion get_MessageSecurityVersion();
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    public virtual object CreateListenerSecurityState();
    public SecurityProtocol CreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, bool isReturnLegSecurityRequired, TimeSpan timeout);
    public virtual EndpointIdentity GetIdentityOfSelf();
    public virtual T GetProperty();
    protected abstract virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    internal IList`1<SupportingTokenAuthenticatorSpecification> GetSupportingTokenAuthenticators(string action, Boolean& expectSignedTokens, Boolean& expectBasicTokens, Boolean& expectEndorsingTokens);
    protected RecipientServiceModelSecurityTokenRequirement CreateRecipientSecurityTokenRequirement();
    public virtual void OnOpen(TimeSpan timeout);
    public void Open(bool actAsInitiator, TimeSpan timeout);
    public IAsyncResult BeginOpen(bool actAsInitiator, TimeSpan timeout, AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult result);
    public void Close(bool aborted, TimeSpan timeout);
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndClose(IAsyncResult result);
    internal void Open(string propertyName, bool requiredForForwardDirection, SecurityTokenAuthenticator authenticator, TimeSpan timeout);
    internal void Open(string propertyName, bool requiredForForwardDirection, SecurityTokenProvider provider, TimeSpan timeout);
    internal void OnPropertySettingsError(string propertyName, bool requiredForForwardDirection);
    internal void ThrowIfImmutable();
}
internal static class System.ServiceModel.Security.SecuritySessionClientSettings : object {
    internal static string defaultKeyRenewalIntervalString;
    internal static string defaultKeyRolloverIntervalString;
    internal static TimeSpan defaultKeyRenewalInterval;
    internal static TimeSpan defaultKeyRolloverInterval;
    internal static bool defaultTolerateTransportFailures;
    private static SecuritySessionClientSettings();
}
internal class System.ServiceModel.Security.SecuritySessionClientSettings`1 : object {
    internal ChannelBuilder ChannelBuilder { get; internal set; }
    public SecurityProtocolFactory SessionProtocolFactory { get; public set; }
    public TimeSpan KeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public bool TolerateTransportFailures { get; public set; }
    public bool CanRenewSession { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public SecurityStandardsManager SecurityStandardsManager { get; public set; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal ChannelBuilder get_ChannelBuilder();
    internal void set_ChannelBuilder(ChannelBuilder value);
    public SecurityProtocolFactory get_SessionProtocolFactory();
    public void set_SessionProtocolFactory(SecurityProtocolFactory value);
    public sealed virtual TimeSpan get_KeyRenewalInterval();
    public sealed virtual void set_KeyRenewalInterval(TimeSpan value);
    public sealed virtual TimeSpan get_KeyRolloverInterval();
    public sealed virtual void set_KeyRolloverInterval(TimeSpan value);
    public sealed virtual bool get_TolerateTransportFailures();
    public sealed virtual void set_TolerateTransportFailures(bool value);
    public bool get_CanRenewSession();
    public void set_CanRenewSession(bool value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public SecurityStandardsManager get_SecurityStandardsManager();
    public void set_SecurityStandardsManager(SecurityStandardsManager value);
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    internal IChannelFactory CreateInnerChannelFactory();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void EndClose(IAsyncResult result);
    private sealed virtual override IAsyncResult System.ServiceModel.Security.ISecurityCommunicationObject.OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.Security.ISecurityCommunicationObject.OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    private sealed virtual override void System.ServiceModel.Security.ISecurityCommunicationObject.OnEndClose(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.Security.ISecurityCommunicationObject.OnEndOpen(IAsyncResult result);
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public sealed virtual void OnClose(TimeSpan timeout);
    public sealed virtual void OnAbort();
    public sealed virtual void OnOpen(TimeSpan timeout);
    internal void Close(TimeSpan timeout);
    internal void Abort();
    internal void Open(SecurityChannelFactory`1<TChannel> securityChannelFactory, IChannelFactory innerChannelFactory, ChannelBuilder channelBuilder, TimeSpan timeout);
    internal TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via);
    internal TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via, MessageFilter filter);
}
internal class System.ServiceModel.Security.SecuritySessionFilter : HeaderFilter {
    public UniqueId SecurityContextTokenId { get; }
    public SecuritySessionFilter(UniqueId securityContextTokenId, SecurityStandardsManager standardsManager, bool isStrictMode, String[] excludedActions);
    private static SecuritySessionFilter();
    public UniqueId get_SecurityContextTokenId();
    internal static bool CanHandleException(Exception e);
    public virtual bool Match(Message message);
    public virtual bool Match(MessageBuffer buffer);
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
}
internal enum System.ServiceModel.Security.SecuritySessionOperation : Enum {
    public int value__;
    public static SecuritySessionOperation None;
    public static SecuritySessionOperation Issue;
    public static SecuritySessionOperation Renew;
    public static SecuritySessionOperation Close;
}
internal class System.ServiceModel.Security.SecuritySessionSecurityTokenAuthenticator : CommunicationObjectSecurityTokenAuthenticator {
    internal static TimeSpan defaultSessionTokenLifetime;
    internal static int defaultMaxCachedSessionTokens;
    internal static SecurityStandardsManager defaultStandardsManager;
    public IssuedSecurityTokenHandler IssuedSecurityTokenHandler { get; public set; }
    public RenewedSecurityTokenHandler RenewedSecurityTokenHandler { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    public bool IsClientAnonymous { get; public set; }
    public TimeSpan SessionTokenLifetime { get; public set; }
    public TimeSpan KeyRenewalInterval { get; public set; }
    public int MaximumConcurrentNegotiations { get; public set; }
    public TimeSpan NegotiationTimeout { get; public set; }
    public SecurityContextSecurityTokenAuthenticator SessionTokenAuthenticator { get; }
    public ISecurityContextSecurityTokenCache IssuedTokenCache { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public BindingContext IssuerBindingContext { get; public set; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public IMessageFilterTable`1<EndpointAddress> EndpointFilterTable { get; public set; }
    public Uri ListenUri { get; public set; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public bool PreserveBootstrapTokens { get; public set; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    internal ServiceHostBase RequestSecurityTokenListener { get; }
    private static SecuritySessionSecurityTokenAuthenticator();
    public sealed virtual IssuedSecurityTokenHandler get_IssuedSecurityTokenHandler();
    public sealed virtual void set_IssuedSecurityTokenHandler(IssuedSecurityTokenHandler value);
    public sealed virtual RenewedSecurityTokenHandler get_RenewedSecurityTokenHandler();
    public sealed virtual void set_RenewedSecurityTokenHandler(RenewedSecurityTokenHandler value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public bool get_IsClientAnonymous();
    public void set_IsClientAnonymous(bool value);
    public TimeSpan get_SessionTokenLifetime();
    public void set_SessionTokenLifetime(TimeSpan value);
    public TimeSpan get_KeyRenewalInterval();
    public void set_KeyRenewalInterval(TimeSpan value);
    public int get_MaximumConcurrentNegotiations();
    public void set_MaximumConcurrentNegotiations(int value);
    public TimeSpan get_NegotiationTimeout();
    public void set_NegotiationTimeout(TimeSpan value);
    public SecurityContextSecurityTokenAuthenticator get_SessionTokenAuthenticator();
    public ISecurityContextSecurityTokenCache get_IssuedTokenCache();
    public void set_IssuedTokenCache(ISecurityContextSecurityTokenCache value);
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public IMessageFilterTable`1<EndpointAddress> get_EndpointFilterTable();
    public void set_EndpointFilterTable(IMessageFilterTable`1<EndpointAddress> value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public virtual XmlDictionaryString get_IssueAction();
    public virtual XmlDictionaryString get_IssueResponseAction();
    public bool get_PreserveBootstrapTokens();
    public void set_PreserveBootstrapTokens(bool value);
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public sealed virtual bool RemoveCachedLogonToken(string username);
    public sealed virtual void FlushLogonTokenCache();
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateSecureConversationPolicies(SecurityMessageProperty security, DateTime expirationTime);
    protected virtual Message ProcessRenewRequest(Message request);
    internal static void RemoveCachedTokensIfRequired(SecurityMessageProperty security);
    protected virtual Message ProcessIssueRequest(Message request);
    internal static bool DoesSkiClauseMatchSigningToken(SecurityContextKeyIdentifierClause skiClause, Message request);
    internal ServiceHostBase get_RequestSecurityTokenListener();
    internal IChannelListener`1<TChannel> BuildResponderChannelListener(BindingContext context);
}
internal class System.ServiceModel.Security.SecuritySessionSecurityTokenProvider : CommunicationObjectSecurityTokenProvider {
    public WebHeaderCollection WebHeaders { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    public EndpointAddress TargetAddress { get; public set; }
    public EndpointAddress LocalAddress { get; public set; }
    public Uri Via { get; public set; }
    public BindingContext IssuerBindingContext { get; public set; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public Uri PrivacyNoticeUri { get; public set; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    public int PrivacyNoticeVersion { get; public set; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    public SecuritySessionSecurityTokenProvider(SafeFreeCredentials credentialsHandle);
    private static SecuritySessionSecurityTokenProvider();
    public WebHeaderCollection get_WebHeaders();
    public void set_WebHeaders(WebHeaderCollection value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public EndpointAddress get_LocalAddress();
    public void set_LocalAddress(EndpointAddress value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public Uri get_PrivacyNoticeUri();
    public void set_PrivacyNoticeUri(Uri value);
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public virtual XmlDictionaryString get_IssueAction();
    public virtual XmlDictionaryString get_IssueResponseAction();
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public virtual void OnAbort();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpening();
    public virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual IAsyncResult BeginRenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state);
    protected virtual SecurityToken EndRenewTokenCore(IAsyncResult result);
    protected virtual SecurityToken RenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    protected virtual Message CreateIssueRequest(EndpointAddress target, Object& requestState);
    protected virtual GenericXmlSecurityToken ProcessIssueResponse(Message response, object requestState);
    protected virtual Message CreateRenewRequest(EndpointAddress target, SecurityToken currentSessionToken, Object& requestState);
    protected virtual GenericXmlSecurityToken ProcessRenewResponse(Message response, object requestState);
    protected static void ThrowIfFault(Message message, EndpointAddress target);
    protected void ValidateKeySize(GenericXmlSecurityToken issuedToken);
}
internal class System.ServiceModel.Security.SecuritySessionServerSettings : object {
    internal static string defaultKeyRenewalIntervalString;
    internal static string defaultKeyRolloverIntervalString;
    internal static string defaultInactivityTimeoutString;
    internal static TimeSpan defaultKeyRenewalInterval;
    internal static TimeSpan defaultKeyRolloverInterval;
    internal static bool defaultTolerateTransportFailures;
    internal static int defaultMaximumPendingSessions;
    internal static TimeSpan defaultInactivityTimeout;
    internal ChannelBuilder ChannelBuilder { get; internal set; }
    internal SecurityListenerSettingsLifetimeManager SettingsLifetimeManager { get; internal set; }
    internal ChannelListenerBase SecurityChannelListener { get; internal set; }
    public SecurityTokenAuthenticator SessionTokenAuthenticator { get; }
    public ISecurityContextSecurityTokenCache SessionTokenCache { get; }
    public SecurityTokenResolver SessionTokenResolver { get; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public SecurityStandardsManager SecurityStandardsManager { get; public set; }
    public bool TolerateTransportFailures { get; public set; }
    public bool CanRenewSession { get; public set; }
    public int MaximumPendingSessions { get; public set; }
    public TimeSpan InactivityTimeout { get; public set; }
    public TimeSpan MaximumKeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public int MaximumPendingKeysPerSession { get; public set; }
    public SecurityProtocolFactory SessionProtocolFactory { get; public set; }
    public MessageVersion MessageVersion { get; }
    public TimeSpan OpenTimeout { get; }
    public TimeSpan CloseTimeout { get; }
    public TimeSpan SendTimeout { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    private static SecuritySessionServerSettings();
    internal ChannelBuilder get_ChannelBuilder();
    internal void set_ChannelBuilder(ChannelBuilder value);
    internal SecurityListenerSettingsLifetimeManager get_SettingsLifetimeManager();
    internal void set_SettingsLifetimeManager(SecurityListenerSettingsLifetimeManager value);
    internal ChannelListenerBase get_SecurityChannelListener();
    internal void set_SecurityChannelListener(ChannelListenerBase value);
    public SecurityTokenAuthenticator get_SessionTokenAuthenticator();
    public ISecurityContextSecurityTokenCache get_SessionTokenCache();
    public SecurityTokenResolver get_SessionTokenResolver();
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public SecurityStandardsManager get_SecurityStandardsManager();
    public void set_SecurityStandardsManager(SecurityStandardsManager value);
    public sealed virtual bool get_TolerateTransportFailures();
    public sealed virtual void set_TolerateTransportFailures(bool value);
    public bool get_CanRenewSession();
    public void set_CanRenewSession(bool value);
    public sealed virtual int get_MaximumPendingSessions();
    public sealed virtual void set_MaximumPendingSessions(int value);
    public sealed virtual TimeSpan get_InactivityTimeout();
    public sealed virtual void set_InactivityTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_MaximumKeyRenewalInterval();
    public sealed virtual void set_MaximumKeyRenewalInterval(TimeSpan value);
    public sealed virtual TimeSpan get_KeyRolloverInterval();
    public sealed virtual void set_KeyRolloverInterval(TimeSpan value);
    public sealed virtual int get_MaximumPendingKeysPerSession();
    public sealed virtual void set_MaximumPendingKeysPerSession(int value);
    public SecurityProtocolFactory get_SessionProtocolFactory();
    public void set_SessionProtocolFactory(SecurityProtocolFactory value);
    public MessageVersion get_MessageVersion();
    public TimeSpan get_OpenTimeout();
    public TimeSpan get_CloseTimeout();
    public TimeSpan get_SendTimeout();
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public sealed virtual void OnAbort();
    public sealed virtual void OnClose(TimeSpan timeout);
    internal void Close(TimeSpan timeout);
    internal IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndClose(IAsyncResult result);
    internal void Abort();
    internal void Open(TimeSpan timeout);
    internal IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndOpen(IAsyncResult result);
    public sealed virtual void OnOpen(TimeSpan timeout);
    public void StopAcceptingNewWork();
    internal IChannelAcceptor`1<TChannel> CreateAcceptor();
    internal IChannelListener CreateInnerChannelListener();
}
internal class System.ServiceModel.Security.SecurityStandardsManager : object {
    public static SecurityStandardsManager DefaultInstance { get; }
    public SecurityVersion SecurityVersion { get; }
    public MessageSecurityVersion MessageSecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    internal SecurityTokenSerializer SecurityTokenSerializer { get; }
    internal WSUtilitySpecificationVersion WSUtilitySpecificationVersion { get; }
    internal SignatureTargetIdManager IdManager { get; }
    internal SecureConversationDriver SecureConversationDriver { get; }
    internal TrustDriver TrustDriver { get; }
    public SecurityStandardsManager(SecurityTokenSerializer tokenSerializer);
    public SecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer tokenSerializer);
    public static SecurityStandardsManager get_DefaultInstance();
    public SecurityVersion get_SecurityVersion();
    public MessageSecurityVersion get_MessageSecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    internal SecurityTokenSerializer get_SecurityTokenSerializer();
    internal WSUtilitySpecificationVersion get_WSUtilitySpecificationVersion();
    internal SignatureTargetIdManager get_IdManager();
    internal SecureConversationDriver get_SecureConversationDriver();
    internal TrustDriver get_TrustDriver();
    internal bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, SecurityKeyIdentifierClause& securityKeyIdentifierClause);
    internal SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
    internal SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message, string actor, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message, string actor, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal bool DoesMessageContainSecurityHeader(Message message);
    internal bool TryGetSecurityContextIds(Message message, String[] actors, bool isStrictMode, ICollection`1<UniqueId> results);
}
public abstract class System.ServiceModel.Security.SecurityStateEncoder : object {
    protected internal abstract virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal abstract virtual Byte[] EncodeSecurityState(Byte[] data);
}
internal class System.ServiceModel.Security.SecurityTimestamp : object {
    internal static TimeSpan defaultTimeToLive;
    public DateTime CreationTimeUtc { get; }
    public DateTime ExpiryTimeUtc { get; }
    public string Id { get; }
    public string DigestAlgorithm { get; }
    public SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id);
    internal SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id, string digestAlgorithm, Byte[] digest);
    private static SecurityTimestamp();
    public DateTime get_CreationTimeUtc();
    public DateTime get_ExpiryTimeUtc();
    public string get_Id();
    public string get_DigestAlgorithm();
    internal Byte[] GetDigest();
    internal Char[] GetCreationTimeChars();
    internal Char[] GetExpiryTimeChars();
    public virtual string ToString();
    internal void ValidateRangeAndFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
    internal void ValidateFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
}
public enum System.ServiceModel.Security.SecurityTokenAttachmentMode : Enum {
    public int value__;
    public static SecurityTokenAttachmentMode Signed;
    public static SecurityTokenAttachmentMode Endorsing;
    public static SecurityTokenAttachmentMode SignedEndorsing;
    public static SecurityTokenAttachmentMode SignedEncrypted;
}
internal static class System.ServiceModel.Security.SecurityTokenAttachmentModeHelper : object {
    internal static bool IsDefined(SecurityTokenAttachmentMode value);
    internal static void Validate(SecurityTokenAttachmentMode value);
    internal static void Categorize(SecurityTokenAttachmentMode value, Boolean& isBasic, Boolean& isSignedButNotBasic, ReceiveSecurityHeaderBindingModes& mode);
}
internal class System.ServiceModel.Security.SecurityTokenAuthenticatorAdapter : SecurityTokenAuthenticator {
    public SecurityTokenAuthenticatorAdapter(SecurityTokenHandler securityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected sealed virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.SecurityTokenParametersEnumerable : object {
    public SecurityTokenParametersEnumerable(SecurityBindingElement sbe);
    public SecurityTokenParametersEnumerable(SecurityBindingElement sbe, bool clientTokensOnly);
    [IteratorStateMachineAttribute("System.ServiceModel.Security.SecurityTokenParametersEnumerable/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<SecurityTokenParameters> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ServiceModel.Security.SecurityTokenSpecification : object {
    public SecurityToken SecurityToken { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> SecurityTokenPolicies { get; }
    public SecurityTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies);
    public SecurityToken get_SecurityToken();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_SecurityTokenPolicies();
}
internal class System.ServiceModel.Security.SecurityTokenSpecificationEnumerable : object {
    public SecurityTokenSpecificationEnumerable(SecurityMessageProperty securityMessageProperty);
    [IteratorStateMachineAttribute("System.ServiceModel.Security.SecurityTokenSpecificationEnumerable/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<SecurityTokenSpecification> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.ServiceModel.Security.SecurityUniqueId : ValueType {
    private long id;
    private string prefix;
    private string val;
    public string Value { get; }
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.ServiceModel.Security.SecurityUtils : object {
    public static string Principal;
    public static string Identities;
    public static string AuthTypeNTLM;
    public static string AuthTypeNegotiate;
    public static string AuthTypeKerberos;
    public static string AuthTypeAnonymous;
    public static string AuthTypeCertMap;
    public static string AuthTypeBasic;
    internal static X509SecurityTokenAuthenticator NonValidatingX509Authenticator { get; }
    public static SecurityIdentifier AdministratorsSid { get; }
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MaxUtcDateTime { get; }
    public static DateTime MinUtcDateTime { get; }
    internal static Byte[] CombinedHashLabel { get; }
    internal static bool IsChannelBindingDisabled { get; }
    private static SecurityUtils();
    public static ChannelBinding GetChannelBindingFromMessage(Message message);
    internal static bool IsOsGreaterThanXP();
    internal static bool IsOSGreaterThanOrEqualToWin7();
    internal static bool IsCurrentlyTimeEffective(DateTime effectiveTime, DateTime expirationTime, TimeSpan maxClockSkew);
    internal static X509SecurityTokenAuthenticator get_NonValidatingX509Authenticator();
    public static SecurityIdentifier get_AdministratorsSid();
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MaxUtcDateTime();
    public static DateTime get_MinUtcDateTime();
    internal static IIdentity CreateIdentity(string name, string authenticationType);
    internal static IIdentity CreateIdentity(string name);
    internal static EndpointIdentity CreateWindowsIdentity();
    internal static EndpointIdentity CreateWindowsIdentity(NetworkCredential serverCredential);
    internal static EndpointIdentity CreateWindowsIdentity(bool spnOnly);
    [SecuritySafeCriticalAttribute]
internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid);
    [SecuritySafeCriticalAttribute]
internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid, string authType);
    internal static bool AllowsImpersonation(WindowsIdentity windowsIdentity, TokenImpersonationLevel impersonationLevel);
    internal static Byte[] get_CombinedHashLabel();
    internal static T GetSecurityKey(SecurityToken token);
    internal static bool HasSymmetricSecurityKey(SecurityToken token);
    internal static void EnsureExpectedSymmetricMatch(SecurityToken t1, SecurityToken t2, Message message);
    internal static SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm, SecurityToken token);
    internal static KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm, SecurityToken token);
    internal static ReadOnlyCollection`1<SecurityKey> CreateSymmetricSecurityKeys(Byte[] key);
    internal static Byte[] DecryptKey(SecurityToken unwrappingToken, string encryptionMethod, Byte[] wrappedKey, SecurityKey& unwrappingSecurityKey);
    internal static Byte[] EncryptKey(SecurityToken wrappingToken, string encryptionMethod, Byte[] keyToWrap);
    internal static Byte[] ReadContentAsBase64(XmlDictionaryReader reader, long maxBufferSize);
    internal static Byte[] GenerateDerivedKey(SecurityToken tokenToDerive, string derivationAlgorithm, Byte[] label, Byte[] nonce, int keySize, int offset);
    internal static string GetSpnFromIdentity(EndpointIdentity identity, EndpointAddress target);
    internal static string GetSpnFromTarget(EndpointAddress target);
    internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token);
    internal static Claim GetPrimaryIdentityClaim(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal static Claim GetPrimaryIdentityClaim(AuthorizationContext authContext);
    internal static int GetServiceAddressAndViaHash(EndpointAddress sr);
    internal static string GenerateId();
    internal static string GenerateIdWithPrefix(string prefix);
    internal static UniqueId GenerateUniqueId();
    internal static string GetPrimaryDomain();
    internal static string GetPrimaryDomain(bool isSystemAccount);
    internal static void EnsureCertificateCanDoKeyExchange(X509Certificate2 certificate);
    internal static string GetCertificateId(X509Certificate2 certificate);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreatePrincipalNameAuthorizationPolicies(string principalName);
    internal static string GetIdentityNamesFromPolicies(IList`1<IAuthorizationPolicy> authPolicies);
    internal static string GetIdentityNamesFromContext(AuthorizationContext authContext);
    internal static void AppendCertificateIdentityName(StringBuilder str, X509Certificate2 certificate);
    internal static void AppendIdentityName(StringBuilder str, IIdentity identity);
    [SecurityCriticalAttribute]
internal static string AppendWindowsAuthenticationInfo(string inputString, NetworkCredential credential, AuthenticationLevel authenticationLevel, TokenImpersonationLevel impersonationLevel);
    internal static string GetIdentityName(IIdentity identity);
    [SecuritySafeCriticalAttribute]
internal static bool get_IsChannelBindingDisabled();
    [SecurityCriticalAttribute]
internal static int GetSuppressChannelBindingValue();
    internal static bool IsSecurityBindingSuitableForChannelBinding(TransportSecurityBindingElement securityBindingElement);
    internal static bool AreSecurityTokenParametersSuitableForChannelBinding(Collection`1<SecurityTokenParameters> tokenParameters);
    internal static void ThrowIfNegotiationFault(Message message, EndpointAddress target);
    internal static bool IsSecurityFault(MessageFault fault, SecurityStandardsManager standardsManager);
    internal static Exception CreateSecurityFaultException(Message unverifiedMessage);
    internal static Exception CreateSecurityFaultException(MessageFault fault);
    internal static MessageFault CreateSecurityContextNotFoundFault(SecurityStandardsManager standardsManager, string action);
    internal static MessageFault CreateSecurityMessageFault(Exception e, SecurityStandardsManager standardsManager);
    internal static bool IsCompositeDuplexBinding(BindingContext context);
    internal static void ErasePasswordInUsernameTokenIfPresent(SecurityMessageProperty messageProperty);
    [SecuritySafeCriticalAttribute]
internal static void FixNetworkCredential(NetworkCredential& credential);
    internal static void PrepareNetworkCredential();
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    [SecuritySafeCriticalAttribute]
internal static void ResetCertificate(X509Certificate2 certificate);
    internal static bool IsDefaultNetworkCredential(NetworkCredential credential);
    internal static void OpenTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static IAsyncResult BeginOpenTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout, AsyncCallback callback, object state);
    internal static void EndOpenTokenProviderIfRequired(IAsyncResult result);
    internal static IAsyncResult BeginCloseTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout, AsyncCallback callback, object state);
    internal static void EndCloseTokenProviderIfRequired(IAsyncResult result);
    internal static void CloseTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static void CloseTokenProviderIfRequired(SecurityTokenProvider tokenProvider, bool aborted, TimeSpan timeout);
    internal static void AbortTokenProviderIfRequired(SecurityTokenProvider tokenProvider);
    internal static void OpenTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, bool aborted, TimeSpan timeout);
    internal static IAsyncResult BeginOpenTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout, AsyncCallback callback, object state);
    internal static void EndOpenTokenAuthenticatorIfRequired(IAsyncResult result);
    internal static IAsyncResult BeginCloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout, AsyncCallback callback, object state);
    internal static void EndCloseTokenAuthenticatorIfRequired(IAsyncResult result);
    internal static void AbortTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator);
    internal static void MatchRstWithEndpointFilter(Message rst, IMessageFilterTable`1<EndpointAddress> endpointFilterTable, Uri listenUri);
    internal static bool ShouldMatchRstWithEndpointFilter(SecurityBindingElement sbe);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(SecurityTokenRequirement requirement, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static EndpointIdentity GetServiceCertificateIdentity(X509Certificate2 certificate);
    [SecuritySafeCriticalAttribute]
internal static NetworkCredential GetNetworkCredentialsCopy(NetworkCredential networkCredential);
    internal static NetworkCredential GetNetworkCredentialOrDefault(NetworkCredential credential);
    public static bool CanReadPrivateKey(X509Certificate2 certificate);
    internal static SafeFreeCredentials GetCredentialsHandle(string package, NetworkCredential credential, bool isServer, String[] additionalPackages);
    internal static SafeFreeCredentials GetCredentialsHandle(Binding binding, KeyedByTypeCollection`1<IEndpointBehavior> behaviors);
    internal static SafeFreeCredentials GetCredentialsHandle(Binding binding, ClientCredentials clientCredentials);
    internal static SafeFreeCredentials GetCredentialsHandle(SecurityBindingElement sbe, BindingContext context);
    internal static SafeFreeCredentials GetCredentialsHandle(SecurityBindingElement sbe, ClientCredentials clientCredentials);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static X509Certificate2 GetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target);
    internal static bool TryGetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, X509Certificate2& certificate);
    public static SecurityBindingElement GetIssuerSecurityBindingElement(ServiceModelSecurityTokenRequirement requirement);
    public static int GetMaxNegotiationBufferSize(BindingContext bindingContext);
    public static bool TryCreateKeyFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenResolver resolver, SecurityKey& key);
    public static WrappedKeySecurityToken CreateTokenFromEncryptedKeyClause(EncryptedKeyIdentifierClause keyClause, SecurityToken unwrappingToken);
    public static void ValidateAnonymityConstraint(WindowsIdentity identity, bool allowUnauthenticatedCallers);
    public static bool ShouldValidateSslCipherStrength();
    public static void ValidateSslCipherStrength(int keySizeInBits);
    public static bool TryCreateX509CertificateFromRawData(Byte[] rawData, X509Certificate2& certificate);
    internal static string GetKeyDerivationAlgorithm(SecureConversationVersion version);
}
internal static class System.ServiceModel.Security.SecurityUtilsEx : object {
    internal static bool RequiresFipsCompliance { get; }
    private static SecurityUtilsEx();
    [SecuritySafeCriticalAttribute]
internal static bool get_RequiresFipsCompliance();
}
internal class System.ServiceModel.Security.SecurityVerifiedMessage : DelegatingMessage {
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    internal Byte[] PrimarySignatureValue { get; }
    internal ReceiveSecurityHeader ReceivedSecurityHeader { get; }
    public SecurityVerifiedMessage(Message messageToProcess, ReceiveSecurityHeader securityHeader);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    internal Byte[] get_PrimarySignatureValue();
    internal ReceiveSecurityHeader get_ReceivedSecurityHeader();
    public XmlDictionaryReader CreateFullBodyReader();
    public XmlAttributeHolder[] GetEnvelopeAttributes();
    public XmlAttributeHolder[] GetHeaderAttributes();
    public XmlDictionaryReader GetReaderAtFirstHeader();
    public XmlDictionaryReader GetReaderAtSecurityHeader();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    internal void OnMessageProtectionPassComplete(bool atLeastOneHeaderOrBodyEncrypted);
    internal void OnUnencryptedPart(string name, string ns);
    internal void OnUnsignedPart(string name, string ns);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    public void SetBodyPrefixAndAttributes(XmlDictionaryReader bodyReader);
    public void SetDecryptedBody(Byte[] decryptedBodyContent);
}
public abstract class System.ServiceModel.Security.SecurityVersion : object {
    internal XmlDictionaryString HeaderName { get; }
    internal XmlDictionaryString HeaderNamespace { get; }
    internal XmlDictionaryString HeaderPrefix { get; }
    internal XmlDictionaryString FailedAuthenticationFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityTokenFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityFaultCode { get; }
    internal bool SupportsSignatureConfirmation { get; }
    public static SecurityVersion WSSecurity10 { get; }
    public static SecurityVersion WSSecurity11 { get; }
    internal static SecurityVersion Default { get; }
    internal SecurityVersion(XmlDictionaryString headerName, XmlDictionaryString headerNamespace, XmlDictionaryString headerPrefix);
    internal XmlDictionaryString get_HeaderName();
    internal XmlDictionaryString get_HeaderNamespace();
    internal XmlDictionaryString get_HeaderPrefix();
    internal abstract virtual XmlDictionaryString get_FailedAuthenticationFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityTokenFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityFaultCode();
    internal virtual bool get_SupportsSignatureConfirmation();
    public static SecurityVersion get_WSSecurity10();
    public static SecurityVersion get_WSSecurity11();
    internal static SecurityVersion get_Default();
    internal abstract virtual ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction, int headerIndex);
    internal abstract virtual SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal bool DoesMessageContainSecurityHeader(Message message);
    internal int FindIndexOfSecurityHeader(Message message, String[] actors);
    internal virtual bool IsReaderAtSignatureConfirmation(XmlDictionaryReader reader);
    internal virtual ISignatureValueSecurityElement ReadSignatureConfirmation(XmlDictionaryReader reader);
    internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message, string actor, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal virtual void WriteSignatureConfirmation(XmlDictionaryWriter writer, string id, Byte[] signatureConfirmation);
    internal void WriteStartHeader(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Security.SendSecurityHeader : SecurityHeader {
    public SendSecurityHeaderElementContainer ElementContainer { get; }
    public SecurityProtocolCorrelationState CorrelationState { get; public set; }
    public BufferManager StreamBufferManager { get; public set; }
    public MessagePartSpecification EncryptionParts { get; public set; }
    public bool EncryptPrimarySignature { get; public set; }
    internal Byte[] PrimarySignatureValue { get; }
    protected internal SecurityTokenParameters SigningTokenParameters { get; }
    protected bool ShouldSignToHeader { get; }
    public string IdPrefix { get; public set; }
    public string Name { get; }
    public string Namespace { get; }
    protected SecurityAppliedMessage SecurityAppliedMessage { get; }
    public bool SignThenEncrypt { get; public set; }
    public bool ShouldProtectTokens { get; public set; }
    public MessagePartSpecification SignatureParts { get; public set; }
    public SecurityTimestamp Timestamp { get; }
    public bool HasSignedTokens { get; }
    public bool HasEncryptedTokens { get; }
    protected bool HasSignedEncryptedMessagePart { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    protected SendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    private static SendSecurityHeader();
    public SendSecurityHeaderElementContainer get_ElementContainer();
    public SecurityProtocolCorrelationState get_CorrelationState();
    public void set_CorrelationState(SecurityProtocolCorrelationState value);
    public BufferManager get_StreamBufferManager();
    public void set_StreamBufferManager(BufferManager value);
    public MessagePartSpecification get_EncryptionParts();
    public void set_EncryptionParts(MessagePartSpecification value);
    public bool get_EncryptPrimarySignature();
    public void set_EncryptPrimarySignature(bool value);
    internal Byte[] get_PrimarySignatureValue();
    protected internal SecurityTokenParameters get_SigningTokenParameters();
    protected bool get_ShouldSignToHeader();
    public string get_IdPrefix();
    public void set_IdPrefix(string value);
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected SecurityAppliedMessage get_SecurityAppliedMessage();
    public bool get_SignThenEncrypt();
    public void set_SignThenEncrypt(bool value);
    public bool get_ShouldProtectTokens();
    public void set_ShouldProtectTokens(bool value);
    public MessagePartSpecification get_SignatureParts();
    public void set_SignatureParts(MessagePartSpecification value);
    public SecurityTimestamp get_Timestamp();
    public bool get_HasSignedTokens();
    public bool get_HasEncryptedTokens();
    public void AddPrerequisiteToken(SecurityToken token);
    public abstract virtual void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    public abstract virtual void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    protected virtual bool get_HasSignedEncryptedMessagePart();
    public void SetSigningToken(SecurityToken token, SecurityTokenParameters tokenParameters);
    public void SetEncryptionToken(SecurityToken token, SecurityTokenParameters tokenParameters);
    public void AddBasicSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddSignedEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddSignedSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddSignatureConfirmations(SignatureConfirmations confirmations);
    public void AddTimestamp(TimeSpan timestampValidityDuration);
    public void AddTimestamp(SecurityTimestamp timestamp);
    protected virtual ISignatureValueSecurityElement[] CreateSignatureConfirmationElements(SignatureConfirmations signatureConfirmations);
    internal void StartSecurityApplication();
    internal void CompleteSecurityApplication();
    public void RemoveSignatureEncryptionIfAppropriate();
    public string GenerateId();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal static bool ShouldSerializeToken(SecurityTokenParameters parameters, MessageDirection transferDirection);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected abstract virtual void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters);
    public Message SetupExecution();
    protected internal SecurityTokenReferenceStyle GetTokenReferenceStyle(SecurityTokenParameters parameters);
    protected abstract virtual void StartPrimarySignatureCore(SecurityToken token, SecurityKeyIdentifier identifier, MessagePartSpecification signatureParts, bool generateTargettablePrimarySignature);
    protected abstract virtual ISignatureValueSecurityElement CompletePrimarySignatureCore(SendSecurityHeaderElement[] signatureConfirmations, SecurityToken[] signedEndorsingTokens, SecurityToken[] signedTokens, SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature);
    protected abstract virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier);
    protected abstract virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement primarySignature);
    protected abstract virtual void StartEncryptionCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual ISecurityElement CompleteEncryptionCore(SendSecurityHeaderElement primarySignature, SendSecurityHeaderElement[] basicTokens, SendSecurityHeaderElement[] signatureConfirmations, SendSecurityHeaderElement[] endorsingSignatures);
    protected bool ShouldUseStrTransformForToken(SecurityToken securityToken, int position, SecurityTokenAttachmentMode mode, SecurityKeyIdentifierClause& keyIdentifierClause);
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
}
internal class System.ServiceModel.Security.SendSecurityHeaderElement : object {
    public string Id { get; }
    public ISecurityElement Item { get; }
    public bool MarkedForEncryption { get; public set; }
    public SendSecurityHeaderElement(string id, ISecurityElement item);
    public string get_Id();
    public ISecurityElement get_Item();
    public bool get_MarkedForEncryption();
    public void set_MarkedForEncryption(bool value);
    public bool IsSameItem(ISecurityElement item);
    public void Replace(string id, ISecurityElement item);
}
internal class System.ServiceModel.Security.SendSecurityHeaderElementContainer : object {
    public SecurityTimestamp Timestamp;
    public SecurityToken PrerequisiteToken;
    public SecurityToken SourceSigningToken;
    public SecurityToken DerivedSigningToken;
    public SecurityToken SourceEncryptionToken;
    public SecurityToken WrappedEncryptionToken;
    public SecurityToken DerivedEncryptionToken;
    public ISecurityElement ReferenceList;
    public SendSecurityHeaderElement PrimarySignature;
    public List`1<SecurityToken> EndorsingSupportingTokens { get; }
    public SecurityToken[] GetSignedSupportingTokens();
    public void AddSignedSupportingToken(SecurityToken token);
    public List`1<SecurityToken> get_EndorsingSupportingTokens();
    public SendSecurityHeaderElement[] GetBasicSupportingTokens();
    public void AddBasicSupportingToken(SendSecurityHeaderElement tokenElement);
    public SecurityToken[] GetSignedEndorsingSupportingTokens();
    public void AddSignedEndorsingSupportingToken(SecurityToken token);
    public SecurityToken[] GetSignedEndorsingDerivedSupportingTokens();
    public void AddSignedEndorsingDerivedSupportingToken(SecurityToken token);
    public SecurityToken[] GetEndorsingSupportingTokens();
    public void AddEndorsingSupportingToken(SecurityToken token);
    public SecurityToken[] GetEndorsingDerivedSupportingTokens();
    public void AddEndorsingDerivedSupportingToken(SecurityToken token);
    public SendSecurityHeaderElement[] GetSignatureConfirmations();
    public void AddSignatureConfirmation(SendSecurityHeaderElement confirmation);
    public SendSecurityHeaderElement[] GetEndorsingSignatures();
    public void AddEndorsingSignature(SendSecurityHeaderElement signature);
    public void MapSecurityTokenToStrClause(SecurityToken securityToken, SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryGetIdentifierClauseFromSecurityToken(SecurityToken securityToken, SecurityKeyIdentifierClause& keyIdentifierClause);
}
public class System.ServiceModel.Security.ServiceCredentialsSecurityTokenManager : SecurityTokenManager {
    public ServiceCredentials ServiceCredentials { get; }
    public ServiceCredentialsSecurityTokenManager(ServiceCredentials parent);
    public ServiceCredentials get_ServiceCredentials();
    public virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    protected SecurityTokenAuthenticator CreateSecureConversationTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, bool preserveBootstrapTokens, SecurityTokenResolver& sctResolver);
    protected bool IsIssuedSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
    public virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement requirement);
    public virtual EndpointIdentity GetIdentityOfSelf(SecurityTokenRequirement tokenRequirement);
}
internal class System.ServiceModel.Security.ServiceModelDictionaryManager : object {
    public static DictionaryManager Instance { get; }
    public static DictionaryManager get_Instance();
}
internal class System.ServiceModel.Security.SessionActionFilter : HeaderFilter {
    public SessionActionFilter(SecurityStandardsManager standardsManager, String[] actions);
    public virtual bool Match(Message message);
}
internal class System.ServiceModel.Security.SessionDerivedKeySecurityTokenParameters : SecurityTokenParameters {
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected internal bool HasAsymmetricKey { get; }
    protected SessionDerivedKeySecurityTokenParameters(SessionDerivedKeySecurityTokenParameters other);
    public SessionDerivedKeySecurityTokenParameters(bool actAsInitiator);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected internal virtual bool get_HasAsymmetricKey();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual bool MatchesKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
internal class System.ServiceModel.Security.SessionKeyExpiredException : MessageSecurityException {
    public SessionKeyExpiredException(string message);
    public SessionKeyExpiredException(string message, Exception innerException);
    protected SessionKeyExpiredException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Security.SessionSymmetricMessageSecurityProtocolFactory : MessageSecurityProtocolFactory {
    public SecurityTokenParameters SecurityTokenParameters { get; public set; }
    public SecurityTokenParameters get_SecurityTokenParameters();
    public void set_SecurityTokenParameters(SecurityTokenParameters value);
    public virtual EndpointIdentity GetIdentityOfSelf();
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
    internal SecurityTokenParameters GetTokenParameters();
}
internal class System.ServiceModel.Security.SessionSymmetricTransportSecurityProtocolFactory : TransportSecurityProtocolFactory {
    public bool SupportsReplayDetection { get; }
    public SecurityTokenParameters SecurityTokenParameters { get; public set; }
    public virtual bool get_SupportsReplayDetection();
    public SecurityTokenParameters get_SecurityTokenParameters();
    public void set_SecurityTokenParameters(SecurityTokenParameters value);
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
    internal SecurityTokenParameters GetTokenParameters();
}
internal class System.ServiceModel.Security.SignatureConfirmationElement : object {
    public bool HasId { get; }
    public string Id { get; }
    public SignatureConfirmationElement(string id, Byte[] signatureValue, SecurityVersion version);
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public sealed virtual Byte[] GetSignatureValue();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.ServiceModel.Security.SignatureConfirmations : object {
    public int Count { get; }
    public bool IsMarkedForEncryption { get; }
    public int get_Count();
    public void AddConfirmation(Byte[] value, bool encrypted);
    public void GetConfirmation(int index, Byte[]& value, Boolean& encrypted);
    public bool get_IsMarkedForEncryption();
}
internal abstract class System.ServiceModel.Security.SignatureTargetIdManager : object {
    public string DefaultIdNamespacePrefix { get; }
    public string DefaultIdNamespaceUri { get; }
    public abstract virtual string get_DefaultIdNamespacePrefix();
    public abstract virtual string get_DefaultIdNamespaceUri();
    public abstract virtual string ExtractId(XmlDictionaryReader reader);
    public abstract virtual void WriteIdAttribute(XmlDictionaryWriter writer, string id);
}
public class System.ServiceModel.Security.SimpleSecurityTokenProvider : SecurityTokenProvider {
    public SimpleSecurityTokenProvider(SecurityToken token, SecurityTokenRequirement tokenRequirement);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
internal class System.ServiceModel.Security.SpnegoTokenAuthenticator : SspiNegotiationTokenAuthenticator {
    public bool ExtractGroupsForWindowsAccounts { get; public set; }
    public NetworkCredential ServerCredential { get; public set; }
    public bool AllowUnauthenticatedCallers { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    public bool get_ExtractGroupsForWindowsAccounts();
    public void set_ExtractGroupsForWindowsAccounts(bool value);
    public NetworkCredential get_ServerCredential();
    public void set_ServerCredential(NetworkCredential value);
    public bool get_AllowUnauthenticatedCallers();
    public void set_AllowUnauthenticatedCallers(bool value);
    public virtual XmlDictionaryString get_NegotiationValueType();
    public virtual void OnOpening();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual SspiNegotiationTokenAuthenticatorState CreateSspiState(Byte[] incomingBlob, string incomingValueTypeUri);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
}
internal class System.ServiceModel.Security.SpnegoTokenProvider : SspiNegotiationTokenProvider {
    public IdentityVerifier IdentityVerifier { get; public set; }
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    public ICredentials ClientCredential { get; public set; }
    public bool AllowNtlm { get; public set; }
    public bool AuthenticateServer { get; public set; }
    public bool InteractiveNegoExLogonEnabled { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    public SpnegoTokenProvider(SafeFreeCredentials credentialsHandle);
    public SpnegoTokenProvider(SafeFreeCredentials credentialsHandle, SecurityBindingElement securityBindingElement);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public ICredentials get_ClientCredential();
    public void set_ClientCredential(ICredentials value);
    public bool get_AllowNtlm();
    public void set_AllowNtlm(bool value);
    public bool get_AuthenticateServer();
    public void set_AuthenticateServer(bool value);
    public bool get_InteractiveNegoExLogonEnabled();
    public void set_InteractiveNegoExLogonEnabled(bool value);
    public virtual XmlDictionaryString get_NegotiationValueType();
    public virtual void OnOpening();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual bool CreateNegotiationStateCompletesSynchronously(EndpointAddress target, Uri via);
    protected virtual IAsyncResult BeginCreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SspiNegotiationTokenProviderState EndCreateNegotiationState(IAsyncResult result);
    protected virtual SspiNegotiationTokenProviderState CreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
}
internal static class System.ServiceModel.Security.SslProtocolsHelper : object {
    internal static bool IsDefined(SslProtocols value);
    internal static void Validate(SslProtocols value);
}
internal class System.ServiceModel.Security.SspiIssuanceChannelParameter : object {
    public bool GetTokenOnOpen { get; }
    public SafeFreeCredentials CredentialsHandle { get; }
    public SspiIssuanceChannelParameter(bool getTokenOnOpen, SafeFreeCredentials credentialsHandle);
    public bool get_GetTokenOnOpen();
    public SafeFreeCredentials get_CredentialsHandle();
}
internal abstract class System.ServiceModel.Security.SspiNegotiationTokenAuthenticator : NegotiationTokenAuthenticator`1<SspiNegotiationTokenAuthenticatorState> {
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    protected object ThisLock { get; }
    public string DefaultServiceBinding { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    protected bool IsMultiLegNegotiation { get; }
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    protected object get_ThisLock();
    public string get_DefaultServiceBinding();
    public void set_DefaultServiceBinding(string value);
    public abstract virtual XmlDictionaryString get_NegotiationValueType();
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
    protected abstract virtual SspiNegotiationTokenAuthenticatorState CreateSspiState(Byte[] incomingBlob, string incomingValueTypeUri);
    protected virtual void IssueServiceToken(SspiNegotiationTokenAuthenticatorState sspiState, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, SecurityContextSecurityToken& serviceToken, WrappedKeySecurityToken& proofToken, Int32& issuedKeySize);
    protected virtual void ValidateIncomingBinaryNegotiation(BinaryNegotiation incomingNego);
    protected virtual BinaryNegotiation GetOutgoingBinaryNegotiation(ISspiNegotiation sspiNegotiation, Byte[] outgoingBlob);
    protected virtual bool get_IsMultiLegNegotiation();
    protected virtual Binding GetNegotiationBinding(Binding binding);
    protected virtual MessageFilter GetListenerFilter();
    protected virtual BodyWriter ProcessRequestSecurityToken(Message request, RequestSecurityToken requestSecurityToken, SspiNegotiationTokenAuthenticatorState& negotiationState);
    protected virtual BodyWriter ProcessRequestSecurityTokenResponse(SspiNegotiationTokenAuthenticatorState negotiationState, Message request, RequestSecurityTokenResponse requestSecurityTokenResponse);
}
internal class System.ServiceModel.Security.SspiNegotiationTokenAuthenticatorState : NegotiationTokenAuthenticatorState {
    public ISspiNegotiation SspiNegotiation { get; }
    internal int RequestedKeySize { get; internal set; }
    internal HashAlgorithm NegotiationDigest { get; }
    internal string Context { get; internal set; }
    internal EndpointAddress AppliesTo { get; internal set; }
    internal DataContractSerializer AppliesToSerializer { get; internal set; }
    public SspiNegotiationTokenAuthenticatorState(ISspiNegotiation sspiNegotiation);
    public ISspiNegotiation get_SspiNegotiation();
    internal int get_RequestedKeySize();
    internal void set_RequestedKeySize(int value);
    internal HashAlgorithm get_NegotiationDigest();
    internal string get_Context();
    internal void set_Context(string value);
    internal EndpointAddress get_AppliesTo();
    internal void set_AppliesTo(EndpointAddress value);
    internal DataContractSerializer get_AppliesToSerializer();
    internal void set_AppliesToSerializer(DataContractSerializer value);
    public virtual string GetRemoteIdentityName();
    public virtual void Dispose();
}
internal abstract class System.ServiceModel.Security.SspiNegotiationTokenProvider : NegotiationTokenProvider`1<SspiNegotiationTokenProviderState> {
    public bool NegotiateTokenOnOpen { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    protected SspiNegotiationTokenProvider(SecurityBindingElement securityBindingElement);
    public bool get_NegotiateTokenOnOpen();
    public void set_NegotiateTokenOnOpen(bool value);
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
    public abstract virtual XmlDictionaryString get_NegotiationValueType();
    public virtual void OnOpen(TimeSpan timeout);
    protected virtual IChannelFactory`1<IRequestChannel> GetNegotiationChannelFactory(IChannelFactory`1<IRequestChannel> transportChannelFactory, ChannelBuilder channelBuilder);
    protected virtual BodyWriter GetFirstOutgoingMessageBody(SspiNegotiationTokenProviderState sspiState, MessageProperties& messageProperties);
    protected virtual IRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    protected virtual BodyWriter GetNextOutgoingMessageBody(Message incomingMessage, SspiNegotiationTokenProviderState sspiState);
}
internal class System.ServiceModel.Security.SspiNegotiationTokenProviderState : IssuanceTokenProviderState {
    public ISspiNegotiation SspiNegotiation { get; }
    internal HashAlgorithm NegotiationDigest { get; }
    public SspiNegotiationTokenProviderState(ISspiNegotiation sspiNegotiation);
    public ISspiNegotiation get_SspiNegotiation();
    internal HashAlgorithm get_NegotiationDigest();
    public virtual void Dispose();
}
public class System.ServiceModel.Security.SspiSecurityTokenProvider : SecurityTokenProvider {
    internal static bool DefaultAllowNtlm;
    internal static bool DefaultExtractWindowsGroupClaims;
    internal static bool DefaultAllowUnauthenticatedCallers;
    public SspiSecurityTokenProvider(NetworkCredential credential, bool allowNtlm, TokenImpersonationLevel impersonationLevel);
    public SspiSecurityTokenProvider(NetworkCredential credential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
internal static class System.ServiceModel.Security.StoreLocationHelper : object {
    internal static bool IsDefined(StoreLocation value);
}
internal class System.ServiceModel.Security.StrictModeSecurityHeaderElementInferenceEngine : SecurityHeaderElementInferenceEngine {
    internal static StrictModeSecurityHeaderElementInferenceEngine Instance { get; }
    private static StrictModeSecurityHeaderElementInferenceEngine();
    internal static StrictModeSecurityHeaderElementInferenceEngine get_Instance();
    public virtual void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
    public virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
}
internal class System.ServiceModel.Security.SupportingTokenAuthenticatorSpecification : object {
    public SecurityTokenAuthenticator TokenAuthenticator { get; }
    public SecurityTokenResolver TokenResolver { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    internal bool IsTokenOptional { get; internal set; }
    public SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    internal SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters, bool isTokenOptional);
    public SecurityTokenAuthenticator get_TokenAuthenticator();
    public SecurityTokenResolver get_TokenResolver();
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    public SecurityTokenParameters get_TokenParameters();
    internal bool get_IsTokenOptional();
    internal void set_IsTokenOptional(bool value);
}
internal class System.ServiceModel.Security.SupportingTokenProviderSpecification : object {
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    public SupportingTokenProviderSpecification(SecurityTokenProvider tokenProvider, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    public SecurityTokenProvider get_TokenProvider();
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    public SecurityTokenParameters get_TokenParameters();
}
public class System.ServiceModel.Security.SupportingTokenSpecification : SecurityTokenSpecification {
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    internal SecurityTokenParameters SecurityTokenParameters { get; }
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode);
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    internal SecurityTokenParameters get_SecurityTokenParameters();
}
internal class System.ServiceModel.Security.SymmetricSecurityProtocol : MessageSecurityProtocol {
    public SecurityTokenProvider InitiatorSymmetricTokenProvider { get; }
    public SecurityTokenProvider InitiatorAsymmetricTokenProvider { get; }
    public SecurityTokenAuthenticator InitiatorTokenAuthenticator { get; }
    public SymmetricSecurityProtocol(SymmetricSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    public SecurityTokenProvider get_InitiatorSymmetricTokenProvider();
    public SecurityTokenProvider get_InitiatorAsymmetricTokenProvider();
    public SecurityTokenAuthenticator get_InitiatorTokenAuthenticator();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnAbort();
    public virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult BeginSecureOutgoingMessageCore(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    protected virtual SecurityProtocolCorrelationState SecureOutgoingMessageCore(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual void EndSecureOutgoingMessageCore(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    protected virtual SecurityProtocolCorrelationState VerifyIncomingMessageCore(Message& message, string actor, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
}
internal class System.ServiceModel.Security.SymmetricSecurityProtocolFactory : MessageSecurityProtocolFactory {
    public SecurityTokenParameters SecurityTokenParameters { get; public set; }
    public SecurityTokenProvider RecipientAsymmetricTokenProvider { get; }
    public SecurityTokenAuthenticator RecipientSymmetricTokenAuthenticator { get; }
    public ReadOnlyCollection`1<SecurityTokenResolver> RecipientOutOfBandTokenResolverList { get; }
    internal SymmetricSecurityProtocolFactory(MessageSecurityProtocolFactory factory);
    public SecurityTokenParameters get_SecurityTokenParameters();
    public void set_SecurityTokenParameters(SecurityTokenParameters value);
    public SecurityTokenProvider get_RecipientAsymmetricTokenProvider();
    public SecurityTokenAuthenticator get_RecipientSymmetricTokenAuthenticator();
    public ReadOnlyCollection`1<SecurityTokenResolver> get_RecipientOutOfBandTokenResolverList();
    public virtual EndpointIdentity GetIdentityOfSelf();
    public virtual T GetProperty();
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    public virtual void OnOpen(TimeSpan timeout);
    internal SecurityTokenParameters GetProtectionTokenParameters();
}
internal class System.ServiceModel.Security.TimeBoundedCache : object {
    public int Count { get; }
    protected int Capacity { get; }
    protected Hashtable Entries { get; }
    protected ReaderWriterLock CacheLock { get; }
    protected TimeBoundedCache(int lowWaterMark, int maxCacheItems, IEqualityComparer keyComparer, PurgingMode purgingMode, TimeSpan purgeInterval, bool doRemoveNotification);
    public int get_Count();
    protected int get_Capacity();
    protected Hashtable get_Entries();
    protected ReaderWriterLock get_CacheLock();
    protected bool TryAddItem(object key, object item, DateTime expirationTime, bool replaceExistingEntry);
    protected bool TryAddItem(object key, IExpirableItem item, bool replaceExistingEntry);
    protected bool TryReplaceItem(object key, object item, DateTime expirationTime);
    protected void ClearItems();
    protected object GetItem(object key);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    protected virtual void OnRemove(object item);
    protected bool TryRemoveItem(object key);
    protected object ExtractItem(IExpirableItem val);
}
internal class System.ServiceModel.Security.TlsnegoTokenAuthenticator : SspiNegotiationTokenAuthenticator {
    public SecurityTokenAuthenticator ClientTokenAuthenticator { get; public set; }
    public SecurityTokenProvider ServerTokenProvider { get; public set; }
    public bool MapCertificateToWindowsAccount { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    public SecurityTokenAuthenticator get_ClientTokenAuthenticator();
    public void set_ClientTokenAuthenticator(SecurityTokenAuthenticator value);
    public SecurityTokenProvider get_ServerTokenProvider();
    public void set_ServerTokenProvider(SecurityTokenProvider value);
    public bool get_MapCertificateToWindowsAccount();
    public void set_MapCertificateToWindowsAccount(bool value);
    public virtual XmlDictionaryString get_NegotiationValueType();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual void ValidateIncomingBinaryNegotiation(BinaryNegotiation incomingNego);
    protected virtual SspiNegotiationTokenAuthenticatorState CreateSspiState(Byte[] incomingBlob, string incomingValueTypeUri);
    protected virtual BinaryNegotiation GetOutgoingBinaryNegotiation(ISspiNegotiation sspiNegotiation, Byte[] outgoingBlob);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
}
internal class System.ServiceModel.Security.TlsnegoTokenProvider : SspiNegotiationTokenProvider {
    public SecurityTokenAuthenticator ServerTokenAuthenticator { get; public set; }
    public SecurityTokenProvider ClientTokenProvider { get; public set; }
    public XmlDictionaryString NegotiationValueType { get; }
    public SecurityTokenAuthenticator get_ServerTokenAuthenticator();
    public void set_ServerTokenAuthenticator(SecurityTokenAuthenticator value);
    public SecurityTokenProvider get_ClientTokenProvider();
    public void set_ClientTokenProvider(SecurityTokenProvider value);
    public virtual XmlDictionaryString get_NegotiationValueType();
    protected virtual bool CreateNegotiationStateCompletesSynchronously(EndpointAddress target, Uri via);
    protected virtual IAsyncResult BeginCreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SspiNegotiationTokenProviderState EndCreateNegotiationState(IAsyncResult result);
    protected virtual SspiNegotiationTokenProviderState CreateNegotiationState(EndpointAddress target, Uri via, TimeSpan timeout);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateSspiNegotiation(ISspiNegotiation sspiNegotiation);
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnAbort();
}
internal class System.ServiceModel.Security.TlsSspiNegotiation : object {
    public X509Certificate2 ClientCertificate { get; }
    public bool ClientCertRequired { get; }
    public string Destination { get; }
    public DateTime ExpirationTimeUtc { get; }
    public bool IsCompleted { get; }
    public bool IsMutualAuthFlag { get; }
    public bool IsValidContext { get; }
    public string KeyEncryptionAlgorithm { get; }
    public X509Certificate2 RemoteCertificate { get; }
    public X509Certificate2Collection RemoteCertificateChain { get; }
    public X509Certificate2 ServerCertificate { get; }
    public bool WasClientCertificateSent { get; }
    internal SslConnectionInfo ConnectionInfo { get; }
    internal StreamSizes StreamSizes { get; }
    internal string IncomingValueTypeUri { get; internal set; }
    public TlsSspiNegotiation(string destination, SchProtocols protocolFlags, X509Certificate2 clientCertificate);
    public TlsSspiNegotiation(SchProtocols protocolFlags, X509Certificate2 serverCertificate, bool clientCertRequired);
    private static TlsSspiNegotiation();
    public X509Certificate2 get_ClientCertificate();
    public bool get_ClientCertRequired();
    public string get_Destination();
    public sealed virtual DateTime get_ExpirationTimeUtc();
    public sealed virtual bool get_IsCompleted();
    public bool get_IsMutualAuthFlag();
    public sealed virtual bool get_IsValidContext();
    public sealed virtual string get_KeyEncryptionAlgorithm();
    public X509Certificate2 get_RemoteCertificate();
    public X509Certificate2Collection get_RemoteCertificateChain();
    public X509Certificate2 get_ServerCertificate();
    public bool get_WasClientCertificateSent();
    internal SslConnectionInfo get_ConnectionInfo();
    internal StreamSizes get_StreamSizes();
    internal string get_IncomingValueTypeUri();
    internal void set_IncomingValueTypeUri(string value);
    public sealed virtual string GetRemoteIdentityName();
    public sealed virtual Byte[] Decrypt(Byte[] encryptedContent);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Encrypt(Byte[] input);
    public sealed virtual Byte[] GetOutgoingBlob(Byte[] incomingBlob, ChannelBinding channelbinding, ExtendedProtectionPolicy protectionPolicy);
    internal void DecryptInPlace(Byte[] encryptedContent, Int32& dataStartOffset, Int32& dataLen);
    internal void EncryptInPlace(Byte[] buffer, int bufferStartOffset, int dataLen, Int32& encryptedDataLen);
    internal bool TryGetContextIdentity(WindowsIdentity& mappedIdentity);
}
internal class System.ServiceModel.Security.TokenElement : object {
    public bool HasId { get; }
    public string Id { get; }
    public SecurityToken Token { get; }
    public TokenElement(SecurityToken token, SecurityStandardsManager standardsManager);
    public virtual bool Equals(object item);
    public virtual int GetHashCode();
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public SecurityToken get_Token();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal static class System.ServiceModel.Security.TokenImpersonationLevelHelper : object {
    private static TokenImpersonationLevelHelper();
    internal static bool IsDefined(TokenImpersonationLevel value);
    internal static void Validate(TokenImpersonationLevel value);
    internal static string ToString(TokenImpersonationLevel impersonationLevel);
    internal static bool IsGreaterOrEqual(TokenImpersonationLevel x, TokenImpersonationLevel y);
    internal static int Compare(TokenImpersonationLevel x, TokenImpersonationLevel y);
}
public class System.ServiceModel.Security.Tokens.ClaimTypeRequirement : object {
    internal static bool DefaultIsOptional;
    public string ClaimType { get; }
    public bool IsOptional { get; }
    public ClaimTypeRequirement(string claimType);
    public ClaimTypeRequirement(string claimType, bool isOptional);
    public string get_ClaimType();
    public bool get_IsOptional();
}
internal class System.ServiceModel.Security.Tokens.DerivedKeySecurityToken : SecurityToken {
    public static int DefaultNonceLength;
    public static int DefaultDerivedKeyLength;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string KeyDerivationAlgorithm { get; }
    public int Generation { get; }
    public string Label { get; }
    public int Length { get; }
    internal Byte[] Nonce { get; }
    public int Offset { get; }
    internal SecurityToken TokenToDerive { get; }
    internal SecurityKeyIdentifierClause TokenToDeriveIdentifier { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DerivedKeySecurityToken(SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, int length);
    internal DerivedKeySecurityToken(SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, int length, string id);
    internal DerivedKeySecurityToken(int generation, int offset, int length, string label, int minNonceLength, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    internal DerivedKeySecurityToken(int generation, int offset, int length, string label, Byte[] nonce, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    private static DerivedKeySecurityToken();
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_KeyDerivationAlgorithm();
    public int get_Generation();
    public string get_Label();
    public int get_Length();
    internal Byte[] get_Nonce();
    public int get_Offset();
    internal SecurityToken get_TokenToDerive();
    internal SecurityKeyIdentifierClause get_TokenToDeriveIdentifier();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Byte[] GetKeyBytes();
    public Byte[] GetNonce();
    internal bool TryGetSecurityKeys(ReadOnlyCollection`1& keys);
    public virtual string ToString();
    internal void InitializeDerivedKey(int maxKeyLength);
    internal void InitializeDerivedKey(ReadOnlyCollection`1<SecurityKey> securityKeys);
    internal static void EnsureAcceptableOffset(int offset, int generation, int length, int maxOffset);
}
internal class System.ServiceModel.Security.Tokens.DerivedKeySecurityTokenStub : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SecurityKeyIdentifierClause TokenToDeriveIdentifier { get; }
    public DerivedKeySecurityTokenStub(int generation, int offset, int length, string label, Byte[] nonce, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public SecurityKeyIdentifierClause get_TokenToDeriveIdentifier();
    public DerivedKeySecurityToken CreateToken(SecurityToken tokenToDerive, int maxKeyLength);
}
internal class System.ServiceModel.Security.Tokens.GenericXmlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public interface System.ServiceModel.Security.Tokens.IIssuanceSecurityTokenAuthenticator {
    public IssuedSecurityTokenHandler IssuedSecurityTokenHandler { get; public set; }
    public RenewedSecurityTokenHandler RenewedSecurityTokenHandler { get; public set; }
    public abstract virtual IssuedSecurityTokenHandler get_IssuedSecurityTokenHandler();
    public abstract virtual void set_IssuedSecurityTokenHandler(IssuedSecurityTokenHandler value);
    public abstract virtual RenewedSecurityTokenHandler get_RenewedSecurityTokenHandler();
    public abstract virtual void set_RenewedSecurityTokenHandler(RenewedSecurityTokenHandler value);
}
public interface System.ServiceModel.Security.Tokens.ILogonTokenCacheManager {
    public abstract virtual bool RemoveCachedLogonToken(string username);
    public abstract virtual void FlushLogonTokenCache();
}
public class System.ServiceModel.Security.Tokens.InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    public EndpointAddress TargetAddress { get; public set; }
    public Uri Via { get; public set; }
    internal bool IsOutOfBandToken { get; internal set; }
    internal bool PreferSslCertificateAuthenticator { get; internal set; }
    internal WebHeaderCollection WebHeaders { get; internal set; }
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public Uri get_Via();
    public void set_Via(Uri value);
    internal bool get_IsOutOfBandToken();
    internal void set_IsOutOfBandToken(bool value);
    internal bool get_PreferSslCertificateAuthenticator();
    internal void set_PreferSslCertificateAuthenticator(bool value);
    internal WebHeaderCollection get_WebHeaders();
    internal void set_WebHeaders(WebHeaderCollection value);
    public virtual string ToString();
}
public interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCache {
    public abstract virtual void AddContext(SecurityContextSecurityToken token);
    public abstract virtual bool TryAddContext(SecurityContextSecurityToken token);
    public abstract virtual void ClearContexts();
    public abstract virtual void RemoveContext(UniqueId contextId, UniqueId generation);
    public abstract virtual void RemoveAllContexts(UniqueId contextId);
    public abstract virtual SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public abstract virtual Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    public abstract virtual void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
}
internal interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCacheProvider {
    public ISecurityContextSecurityTokenCache TokenCache { get; }
    public abstract virtual ISecurityContextSecurityTokenCache get_TokenCache();
}
public class System.ServiceModel.Security.Tokens.IssuedSecurityTokenHandler : MulticastDelegate {
    public IssuedSecurityTokenHandler(object object, IntPtr method);
    public virtual void Invoke(SecurityToken issuedToken, EndpointAddress tokenRequestor);
    public virtual IAsyncResult BeginInvoke(SecurityToken issuedToken, EndpointAddress tokenRequestor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters : SecurityTokenParameters {
    internal static SecurityKeyType defaultKeyType;
    internal static bool defaultUseStrTransform;
    protected internal bool HasAsymmetricKey { get; }
    public Collection`1<XmlElement> AdditionalRequestParameters { get; }
    public MessageSecurityVersion DefaultMessageSecurityVersion { get; public set; }
    internal Collection`1<AlternativeIssuerEndpoint> AlternativeIssuerEndpoints { get; }
    public EndpointAddress IssuerAddress { get; public set; }
    public EndpointAddress IssuerMetadataAddress { get; public set; }
    public Binding IssuerBinding { get; public set; }
    public SecurityKeyType KeyType { get; public set; }
    public int KeySize { get; public set; }
    public bool UseStrTransform { get; public set; }
    public Collection`1<ClaimTypeRequirement> ClaimTypeRequirements { get; }
    public string TokenType { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected IssuedSecurityTokenParameters(IssuedSecurityTokenParameters other);
    public IssuedSecurityTokenParameters(string tokenType);
    public IssuedSecurityTokenParameters(string tokenType, EndpointAddress issuerAddress);
    public IssuedSecurityTokenParameters(string tokenType, EndpointAddress issuerAddress, Binding issuerBinding);
    private static IssuedSecurityTokenParameters();
    protected internal virtual bool get_HasAsymmetricKey();
    public Collection`1<XmlElement> get_AdditionalRequestParameters();
    public MessageSecurityVersion get_DefaultMessageSecurityVersion();
    public void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    internal Collection`1<AlternativeIssuerEndpoint> get_AlternativeIssuerEndpoints();
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public EndpointAddress get_IssuerMetadataAddress();
    public void set_IssuerMetadataAddress(EndpointAddress value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_UseStrTransform();
    public void set_UseStrTransform(bool value);
    public Collection`1<ClaimTypeRequirement> get_ClaimTypeRequirements();
    public string get_TokenType();
    public void set_TokenType(string value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    internal void SetRequestParameters(Collection`1<XmlElement> requestParameters, TrustDriver trustDriver);
    public Collection`1<XmlElement> CreateRequestParameters(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal Collection`1<XmlElement> CreateRequestParameters(TrustDriver driver);
    internal void AddAlgorithmParameters(SecurityAlgorithmSuite algorithmSuite, SecurityStandardsManager standardsManager, SecurityKeyType issuedKeyType);
    internal bool DoAlgorithmsMatch(SecurityAlgorithmSuite algorithmSuite, SecurityStandardsManager standardsManager, Collection`1& otherRequestParameters);
    internal static IssuedSecurityTokenParameters CreateInfoCardParameters(SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithm);
    internal static bool IsInfoCardParameters(IssuedSecurityTokenParameters parameters, SecurityStandardsManager standardsManager);
    internal static XmlElement GetClaimTypeRequirement(Collection`1<XmlElement> additionalRequestParameters, SecurityStandardsManager standardsManager);
    public virtual string ToString();
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
public class System.ServiceModel.Security.Tokens.IssuedSecurityTokenProvider : SecurityTokenProvider {
    public Binding IssuerBinding { get; public set; }
    public KeyedByTypeCollection`1<IEndpointBehavior> IssuerChannelBehaviors { get; }
    public Collection`1<XmlElement> TokenRequestParameters { get; }
    public EndpointAddress IssuerAddress { get; public set; }
    public EndpointAddress TargetAddress { get; public set; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    public IdentityVerifier IdentityVerifier { get; public set; }
    public bool CacheIssuedTokens { get; public set; }
    public TimeSpan MaxIssuedTokenCachingTime { get; public set; }
    public MessageSecurityVersion MessageSecurityVersion { get; public set; }
    public SecurityTokenSerializer SecurityTokenSerializer { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public int IssuedTokenRenewalThresholdPercentage { get; public set; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public bool SupportsTokenCancellation { get; }
    internal ChannelParameterCollection ChannelParameters { get; internal set; }
    internal SecurityTokenHandlerCollectionManager TokenHandlerCollectionManager { get; internal set; }
    internal IssuedSecurityTokenProvider(SafeFreeCredentials credentialsHandle);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public KeyedByTypeCollection`1<IEndpointBehavior> get_IssuerChannelBehaviors();
    public Collection`1<XmlElement> get_TokenRequestParameters();
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public bool get_CacheIssuedTokens();
    public void set_CacheIssuedTokens(bool value);
    public TimeSpan get_MaxIssuedTokenCachingTime();
    public void set_MaxIssuedTokenCachingTime(TimeSpan value);
    public MessageSecurityVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(MessageSecurityVersion value);
    public SecurityTokenSerializer get_SecurityTokenSerializer();
    public void set_SecurityTokenSerializer(SecurityTokenSerializer value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public int get_IssuedTokenRenewalThresholdPercentage();
    public void set_IssuedTokenRenewalThresholdPercentage(int value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public virtual bool get_SupportsTokenCancellation();
    internal ChannelParameterCollection get_ChannelParameters();
    internal void set_ChannelParameters(ChannelParameterCollection value);
    internal SecurityTokenHandlerCollectionManager get_TokenHandlerCollectionManager();
    internal void set_TokenHandlerCollectionManager(SecurityTokenHandlerCollectionManager value);
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    internal void SetupActAsOnBehalfOfParameters(FederatedClientCredentialsParameters actAsOnBehalfOfParameters);
}
internal class System.ServiceModel.Security.Tokens.KerberosRequestorSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.ServiceModel.Security.Tokens.KerberosSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected KerberosSecurityTokenParameters(KerberosSecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
internal class System.ServiceModel.Security.Tokens.LogonToken : object {
    public string UserName { get; }
    public LogonToken(string userName, string password, Byte[] salt, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public bool PasswordEquals(string password);
    public string get_UserName();
    public ReadOnlyCollection`1<IAuthorizationPolicy> GetAuthorizationPolicies();
    public sealed virtual void Dispose();
}
internal class System.ServiceModel.Security.Tokens.LogonTokenCache : TimeBoundedCache {
    public LogonTokenCache(int maxCachedLogonTokens, TimeSpan cachedLogonTokenLifetime);
    public bool TryGetTokenCache(string userName, LogonToken& token);
    public bool TryAddTokenCache(string userName, string password, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    public bool TryRemoveTokenCache(string userName);
    public void Flush();
    protected virtual void OnRemove(object item);
}
internal class System.ServiceModel.Security.Tokens.NonValidatingSecurityTokenAuthenticator`1 : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.Tokens.ProviderBackedSecurityToken : SecurityToken {
    public SecurityTokenProvider TokenProvider { get; }
    unknown ChannelBinding ChannelBinding {public set; }
    public SecurityToken Token { get; }
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public ProviderBackedSecurityToken(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    public SecurityTokenProvider get_TokenProvider();
    public void set_ChannelBinding(ChannelBinding value);
    public SecurityToken get_Token();
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
}
public class System.ServiceModel.Security.Tokens.RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    public Uri ListenUri { get; public set; }
    public AuditLogLocation AuditLogLocation { get; public set; }
    public bool SuppressAuditFailure { get; public set; }
    public AuditLevel MessageAuthenticationAuditLevel { get; public set; }
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public AuditLogLocation get_AuditLogLocation();
    public void set_AuditLogLocation(AuditLogLocation value);
    public bool get_SuppressAuditFailure();
    public void set_SuppressAuditFailure(bool value);
    public AuditLevel get_MessageAuthenticationAuditLevel();
    public void set_MessageAuthenticationAuditLevel(AuditLevel value);
    public virtual string ToString();
}
public class System.ServiceModel.Security.Tokens.RenewedSecurityTokenHandler : MulticastDelegate {
    public RenewedSecurityTokenHandler(object object, IntPtr method);
    public virtual void Invoke(SecurityToken newSecurityToken, SecurityToken oldSecurityToken);
    public virtual IAsyncResult BeginInvoke(SecurityToken newSecurityToken, SecurityToken oldSecurityToken, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ServiceModel.Security.Tokens.RsaSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected RsaSecurityTokenParameters(RsaSecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
public class System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters : SecurityTokenParameters {
    internal static bool defaultRequireCancellation;
    internal static bool defaultCanRenewSession;
    protected internal bool HasAsymmetricKey { get; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public ChannelProtectionRequirements BootstrapProtectionRequirements { get; }
    internal BindingContext IssuerBindingContext { get; internal set; }
    public bool RequireCancellation { get; public set; }
    public bool CanRenewSession { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecureConversationSecurityTokenParameters(SecureConversationSecurityTokenParameters other);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, bool canRenewSession);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, bool canRenewSession, ChannelProtectionRequirements bootstrapProtectionRequirements);
    protected internal virtual bool get_HasAsymmetricKey();
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public ChannelProtectionRequirements get_BootstrapProtectionRequirements();
    internal BindingContext get_IssuerBindingContext();
    internal void set_IssuerBindingContext(BindingContext value);
    public bool get_RequireCancellation();
    public void set_RequireCancellation(bool value);
    public bool get_CanRenewSession();
    public void set_CanRenewSession(bool value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityContextCookieSerializer : ValueType {
    private static int SupportedPersistanceVersion;
    private SecurityStateEncoder securityStateEncoder;
    private IList`1<Type> knownTypes;
    public SecurityContextCookieSerializer(SecurityStateEncoder securityStateEncoder, IList`1<Type> knownTypes);
    public Byte[] CreateCookieFromSecurityContext(UniqueId contextId, string id, Byte[] key, DateTime tokenEffectiveTime, DateTime tokenExpirationTime, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public SecurityContextSecurityToken CreateSecurityContextFromCookie(Byte[] encodedCookie, UniqueId contextId, UniqueId generation, string id, XmlDictionaryReaderQuotas quotas);
    internal static void OnInvalidCookieFailure(string reason);
    internal static void OnInvalidCookieFailure(string reason, Exception e);
}
public class System.ServiceModel.Security.Tokens.SecurityContextSecurityToken : SecurityToken {
    public SecurityMessageProperty BootstrapMessageProperty { get; public set; }
    public string Id { get; }
    public UniqueId ContextId { get; }
    public UniqueId KeyGeneration { get; }
    public DateTime KeyEffectiveTime { get; }
    public DateTime KeyExpirationTime { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; internal set; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    internal Byte[] CookieBlob { get; }
    public bool IsCookieMode { get; }
    public SecurityContextSecurityToken(UniqueId contextId, Byte[] key, DateTime validFrom, DateTime validTo);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id);
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id, Byte[] key, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, Byte[] cookieBlob);
    internal SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, Byte[] cookieBlob, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime);
    public SecurityMessageProperty get_BootstrapMessageProperty();
    public void set_BootstrapMessageProperty(SecurityMessageProperty value);
    public virtual string get_Id();
    public UniqueId get_ContextId();
    public UniqueId get_KeyGeneration();
    public DateTime get_KeyEffectiveTime();
    public DateTime get_KeyExpirationTime();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    internal void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    internal Byte[] get_CookieBlob();
    public bool get_IsCookieMode();
    private sealed virtual override DateTime System.ServiceModel.Security.TimeBoundedCache.IExpirableItem.get_ExpirationTime();
    internal string GetBase64KeyString();
    internal Byte[] GetKeyBytes();
    public virtual string ToString();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
    public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
    internal SecurityContextSecurityToken Clone();
    public sealed virtual void Dispose();
}
public class System.ServiceModel.Security.Tokens.SecurityContextSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal static class System.ServiceModel.Security.Tokens.SecurityContextSecurityTokenHelper : object {
    public static SessionSecurityToken ConvertSctToSessionToken(SecurityContextSecurityToken sct);
    public static SessionSecurityToken ConvertSctToSessionToken(SecurityContextSecurityToken sct, SecureConversationVersion version);
    public static SecurityContextSecurityToken ConvertSessionTokenToSecurityContextSecurityToken(SessionSecurityToken token);
}
internal class System.ServiceModel.Security.Tokens.SecurityContextSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected internal bool HasAsymmetricKey { get; }
    protected SecurityContextSecurityTokenParameters(SecurityContextSecurityTokenParameters other);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected internal virtual bool get_HasAsymmetricKey();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
public class System.ServiceModel.Security.Tokens.SecurityContextSecurityTokenResolver : SecurityTokenResolver {
    public int SecurityContextTokenCacheCapacity { get; }
    public TimeSpan ClockSkew { get; }
    public bool RemoveOldestTokensOnCacheFull { get; }
    public SecurityContextSecurityTokenResolver(int securityContextCacheCapacity, bool removeOldestTokensOnCacheFull);
    public SecurityContextSecurityTokenResolver(int securityContextCacheCapacity, bool removeOldestTokensOnCacheFull, TimeSpan clockSkew);
    public int get_SecurityContextTokenCacheCapacity();
    public TimeSpan get_ClockSkew();
    public bool get_RemoveOldestTokensOnCacheFull();
    public sealed virtual void AddContext(SecurityContextSecurityToken token);
    public sealed virtual bool TryAddContext(SecurityContextSecurityToken token);
    public sealed virtual void ClearContexts();
    public sealed virtual void RemoveContext(UniqueId contextId, UniqueId generation);
    public sealed virtual void RemoveAllContexts(UniqueId contextId);
    public sealed virtual SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public sealed virtual Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    public sealed virtual void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
}
internal class System.ServiceModel.Security.Tokens.SecurityContextTokenValidationException : SecurityTokenValidationException {
    public SecurityContextTokenValidationException(string message);
    public SecurityContextTokenValidationException(string message, Exception innerException);
    protected SecurityContextTokenValidationException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenContainer : object {
    public SecurityToken Token { get; }
    public SecurityTokenContainer(SecurityToken token);
    public SecurityToken get_Token();
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode : Enum {
    public int value__;
    public static SecurityTokenInclusionMode AlwaysToRecipient;
    public static SecurityTokenInclusionMode Never;
    public static SecurityTokenInclusionMode Once;
    public static SecurityTokenInclusionMode AlwaysToInitiator;
}
internal static class System.ServiceModel.Security.Tokens.SecurityTokenInclusionModeHelper : object {
    public static bool IsDefined(SecurityTokenInclusionMode value);
    public static void Validate(SecurityTokenInclusionMode value);
}
public abstract class System.ServiceModel.Security.Tokens.SecurityTokenParameters : object {
    internal static SecurityTokenInclusionMode defaultInclusionMode;
    internal static SecurityTokenReferenceStyle defaultReferenceStyle;
    internal static bool defaultRequireDerivedKeys;
    protected internal bool HasAsymmetricKey { get; }
    public SecurityTokenInclusionMode InclusionMode { get; public set; }
    public SecurityTokenReferenceStyle ReferenceStyle { get; public set; }
    public bool RequireDerivedKeys { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecurityTokenParameters(SecurityTokenParameters other);
    protected internal abstract virtual bool get_HasAsymmetricKey();
    public SecurityTokenInclusionMode get_InclusionMode();
    public void set_InclusionMode(SecurityTokenInclusionMode value);
    public SecurityTokenReferenceStyle get_ReferenceStyle();
    public void set_ReferenceStyle(SecurityTokenReferenceStyle value);
    public bool get_RequireDerivedKeys();
    public void set_RequireDerivedKeys(bool value);
    protected internal abstract virtual bool get_SupportsClientAuthentication();
    protected internal abstract virtual bool get_SupportsServerAuthentication();
    protected internal abstract virtual bool get_SupportsClientWindowsIdentity();
    public SecurityTokenParameters Clone();
    protected abstract virtual SecurityTokenParameters CloneCore();
    protected internal abstract virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal abstract virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    internal SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    internal SecurityKeyIdentifierClause CreateGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual bool MatchesKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle);
    internal bool MatchesGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle);
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenProviderContainer : object {
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenProviderContainer(SecurityTokenProvider tokenProvider);
    public SecurityTokenProvider get_TokenProvider();
    public void Close(TimeSpan timeout);
    public void Open(TimeSpan timeout);
    public void Abort();
    public X509Certificate2 GetCertificate(TimeSpan timeout);
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle : Enum {
    public int value__;
    public static SecurityTokenReferenceStyle Internal;
    public static SecurityTokenReferenceStyle External;
}
public abstract class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenRequirement : SecurityTokenRequirement {
    protected static string Namespace;
    public static string SecurityAlgorithmSuiteProperty { get; }
    public static string SecurityBindingElementProperty { get; }
    public static string IssuerAddressProperty { get; }
    public static string IssuerBindingProperty { get; }
    public static string SecureConversationSecurityBindingElementProperty { get; }
    public static string SupportSecurityContextCancellationProperty { get; }
    public static string MessageSecurityVersionProperty { get; }
    internal static string DefaultMessageSecurityVersionProperty { get; }
    public static string IssuerBindingContextProperty { get; }
    public static string TransportSchemeProperty { get; }
    public static string IsInitiatorProperty { get; }
    public static string TargetAddressProperty { get; }
    public static string ViaProperty { get; }
    public static string ListenUriProperty { get; }
    public static string AuditLogLocationProperty { get; }
    public static string SuppressAuditFailureProperty { get; }
    public static string MessageAuthenticationAuditLevelProperty { get; }
    public static string IsOutOfBandTokenProperty { get; }
    public static string PreferSslCertificateAuthenticatorProperty { get; }
    public static string SupportingTokenAttachmentModeProperty { get; }
    public static string MessageDirectionProperty { get; }
    public static string HttpAuthenticationSchemeProperty { get; }
    public static string IssuedSecurityTokenParametersProperty { get; }
    public static string PrivacyNoticeUriProperty { get; }
    public static string PrivacyNoticeVersionProperty { get; }
    public static string DuplexClientLocalAddressProperty { get; }
    public static string EndpointFilterTableProperty { get; }
    public static string ChannelParametersCollectionProperty { get; }
    public static string ExtendedProtectionPolicy { get; }
    public bool IsInitiator { get; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityBindingElement SecurityBindingElement { get; public set; }
    public EndpointAddress IssuerAddress { get; public set; }
    public Binding IssuerBinding { get; public set; }
    public SecurityBindingElement SecureConversationSecurityBindingElement { get; public set; }
    public SecurityTokenVersion MessageSecurityVersion { get; public set; }
    internal MessageSecurityVersion DefaultMessageSecurityVersion { get; internal set; }
    public string TransportScheme { get; public set; }
    internal bool SupportSecurityContextCancellation { get; internal set; }
    internal EndpointAddress DuplexClientLocalAddress { get; internal set; }
    public static string get_SecurityAlgorithmSuiteProperty();
    public static string get_SecurityBindingElementProperty();
    public static string get_IssuerAddressProperty();
    public static string get_IssuerBindingProperty();
    public static string get_SecureConversationSecurityBindingElementProperty();
    public static string get_SupportSecurityContextCancellationProperty();
    public static string get_MessageSecurityVersionProperty();
    internal static string get_DefaultMessageSecurityVersionProperty();
    public static string get_IssuerBindingContextProperty();
    public static string get_TransportSchemeProperty();
    public static string get_IsInitiatorProperty();
    public static string get_TargetAddressProperty();
    public static string get_ViaProperty();
    public static string get_ListenUriProperty();
    public static string get_AuditLogLocationProperty();
    public static string get_SuppressAuditFailureProperty();
    public static string get_MessageAuthenticationAuditLevelProperty();
    public static string get_IsOutOfBandTokenProperty();
    public static string get_PreferSslCertificateAuthenticatorProperty();
    public static string get_SupportingTokenAttachmentModeProperty();
    public static string get_MessageDirectionProperty();
    public static string get_HttpAuthenticationSchemeProperty();
    public static string get_IssuedSecurityTokenParametersProperty();
    public static string get_PrivacyNoticeUriProperty();
    public static string get_PrivacyNoticeVersionProperty();
    public static string get_DuplexClientLocalAddressProperty();
    public static string get_EndpointFilterTableProperty();
    public static string get_ChannelParametersCollectionProperty();
    public static string get_ExtendedProtectionPolicy();
    public bool get_IsInitiator();
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityBindingElement get_SecurityBindingElement();
    public void set_SecurityBindingElement(SecurityBindingElement value);
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public SecurityBindingElement get_SecureConversationSecurityBindingElement();
    public void set_SecureConversationSecurityBindingElement(SecurityBindingElement value);
    public SecurityTokenVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(SecurityTokenVersion value);
    internal MessageSecurityVersion get_DefaultMessageSecurityVersion();
    internal void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    public string get_TransportScheme();
    public void set_TransportScheme(string value);
    internal bool get_SupportSecurityContextCancellation();
    internal void set_SupportSecurityContextCancellation(bool value);
    internal EndpointAddress get_DuplexClientLocalAddress();
    internal void set_DuplexClientLocalAddress(EndpointAddress value);
    internal TValue GetPropertyOrDefault(string propertyName, TValue defaultValue);
    internal string InternalToString();
}
public static class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenTypes : object {
    public static string Spnego { get; }
    public static string MutualSslnego { get; }
    public static string AnonymousSslnego { get; }
    public static string SecurityContext { get; }
    public static string SecureConversation { get; }
    public static string SspiCredential { get; }
    public static string get_Spnego();
    public static string get_MutualSslnego();
    public static string get_AnonymousSslnego();
    public static string get_SecurityContext();
    public static string get_SecureConversation();
    public static string get_SspiCredential();
}
internal class System.ServiceModel.Security.Tokens.ServiceX509SecurityTokenProvider : X509SecurityTokenProvider {
    public ServiceX509SecurityTokenProvider(X509Certificate2 certificate);
    public ServiceX509SecurityTokenProvider(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
public class System.ServiceModel.Security.Tokens.SslSecurityTokenParameters : SecurityTokenParameters {
    internal static bool defaultRequireClientCertificate;
    internal static bool defaultRequireCancellation;
    protected internal bool HasAsymmetricKey { get; }
    public bool RequireCancellation { get; public set; }
    public bool RequireClientCertificate { get; public set; }
    internal BindingContext IssuerBindingContext { get; internal set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SslSecurityTokenParameters(SslSecurityTokenParameters other);
    public SslSecurityTokenParameters(bool requireClientCertificate);
    public SslSecurityTokenParameters(bool requireClientCertificate, bool requireCancellation);
    protected internal virtual bool get_HasAsymmetricKey();
    public bool get_RequireCancellation();
    public void set_RequireCancellation(bool value);
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    internal BindingContext get_IssuerBindingContext();
    internal void set_IssuerBindingContext(BindingContext value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
public class System.ServiceModel.Security.Tokens.SspiSecurityToken : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public bool AllowUnauthenticatedCallers { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public bool AllowNtlm { get; }
    public NetworkCredential NetworkCredential { get; }
    public bool ExtractGroupsForWindowsAccounts { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SspiSecurityToken(TokenImpersonationLevel impersonationLevel, bool allowNtlm, NetworkCredential networkCredential);
    public SspiSecurityToken(NetworkCredential networkCredential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public bool get_AllowUnauthenticatedCallers();
    public TokenImpersonationLevel get_ImpersonationLevel();
    public bool get_AllowNtlm();
    public NetworkCredential get_NetworkCredential();
    public bool get_ExtractGroupsForWindowsAccounts();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
}
public class System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters : SecurityTokenParameters {
    internal static bool defaultRequireCancellation;
    protected internal bool HasAsymmetricKey { get; }
    public bool RequireCancellation { get; public set; }
    internal BindingContext IssuerBindingContext { get; internal set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SspiSecurityTokenParameters(SspiSecurityTokenParameters other);
    public SspiSecurityTokenParameters(bool requireCancellation);
    protected internal virtual bool get_HasAsymmetricKey();
    public bool get_RequireCancellation();
    public void set_RequireCancellation(bool value);
    internal BindingContext get_IssuerBindingContext();
    internal void set_IssuerBindingContext(BindingContext value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
public class System.ServiceModel.Security.Tokens.SupportingTokenParameters : object {
    public Collection`1<SecurityTokenParameters> Endorsing { get; }
    public Collection`1<SecurityTokenParameters> SignedEndorsing { get; }
    public Collection`1<SecurityTokenParameters> Signed { get; }
    public Collection`1<SecurityTokenParameters> SignedEncrypted { get; }
    public Collection`1<SecurityTokenParameters> get_Endorsing();
    public Collection`1<SecurityTokenParameters> get_SignedEndorsing();
    public Collection`1<SecurityTokenParameters> get_Signed();
    public Collection`1<SecurityTokenParameters> get_SignedEncrypted();
    public void SetKeyDerivation(bool requireDerivedKeys);
    internal bool IsSetKeyDerivation(bool requireDerivedKeys);
    public virtual string ToString();
    public SupportingTokenParameters Clone();
    protected virtual SupportingTokenParameters CloneCore();
    internal bool IsEmpty();
}
internal static class System.ServiceModel.Security.Tokens.TokenReferenceStyleHelper : object {
    public static bool IsDefined(SecurityTokenReferenceStyle value);
    public static void Validate(SecurityTokenReferenceStyle value);
}
public class System.ServiceModel.Security.Tokens.UserNameSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected UserNameSecurityTokenParameters(UserNameSecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
internal class System.ServiceModel.Security.Tokens.WindowsSidIdentity : object {
    public SecurityIdentifier SecurityIdentifier { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public WindowsSidIdentity(SecurityIdentifier sid);
    public WindowsSidIdentity(SecurityIdentifier sid, string name, string authenticationType);
    public SecurityIdentifier get_SecurityIdentifier();
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_IsAuthenticated();
    public sealed virtual string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.ServiceModel.Security.Tokens.WindowsUserNameCachingSecurityTokenAuthenticator : WindowsUserNameSecurityTokenAuthenticator {
    public WindowsUserNameCachingSecurityTokenAuthenticator(bool includeWindowsGroups, int maxCachedLogonTokens, TimeSpan cachedLogonTokenLifetime);
    public sealed virtual void Dispose();
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password);
    public sealed virtual bool RemoveCachedLogonToken(string username);
    public sealed virtual void FlushLogonTokenCache();
}
internal class System.ServiceModel.Security.Tokens.WrappedKeySecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected WrappedKeySecurityTokenParameters(WrappedKeySecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
public enum System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType : Enum {
    public int value__;
    public static X509KeyIdentifierClauseType Any;
    public static X509KeyIdentifierClauseType Thumbprint;
    public static X509KeyIdentifierClauseType IssuerSerial;
    public static X509KeyIdentifierClauseType SubjectKeyIdentifier;
    public static X509KeyIdentifierClauseType RawDataKeyIdentifier;
}
public class System.ServiceModel.Security.Tokens.X509SecurityTokenParameters : SecurityTokenParameters {
    internal static X509KeyIdentifierClauseType defaultX509ReferenceStyle;
    protected internal bool HasAsymmetricKey { get; }
    public X509KeyIdentifierClauseType X509ReferenceStyle { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected X509SecurityTokenParameters(X509SecurityTokenParameters other);
    public X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle);
    public X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle, SecurityTokenInclusionMode inclusionMode);
    internal X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle, SecurityTokenInclusionMode inclusionMode, bool requireDerivedKeys);
    protected internal virtual bool get_HasAsymmetricKey();
    public X509KeyIdentifierClauseType get_X509ReferenceStyle();
    public void set_X509ReferenceStyle(X509KeyIdentifierClauseType value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
internal static class System.ServiceModel.Security.Tokens.X509SecurityTokenReferenceStyleHelper : object {
    public static bool IsDefined(X509KeyIdentifierClauseType value);
    public static void Validate(X509KeyIdentifierClauseType value);
}
internal class System.ServiceModel.Security.TokenTracker : object {
    public SecurityToken token;
    public bool IsDerivedFrom;
    public bool IsSigned;
    public bool IsEncrypted;
    public bool IsEndorsing;
    public bool AlreadyReadEndorsingSignature;
    public SupportingTokenAuthenticatorSpecification spec;
    public TokenTracker(SupportingTokenAuthenticatorSpecification spec);
    public TokenTracker(SupportingTokenAuthenticatorSpecification spec, SecurityToken token, bool allowFirstTokenMismatch);
    public void RecordToken(SecurityToken token);
}
internal class System.ServiceModel.Security.TransportSecurityProtocol : SecurityProtocol {
    public TransportSecurityProtocol(TransportSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    public virtual void SecureOutgoingMessage(Message& message, TimeSpan timeout);
    protected virtual void SecureOutgoingMessageAtInitiator(Message& message, string actor, TimeSpan timeout);
    protected void SecureOutgoingMessageAtResponder(Message& message, string actor);
    internal void SetUpDelayedSecurityExecution(Message& message, string actor, IList`1<SupportingTokenSpecification> supportingTokens);
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginSecureOutgoingMessage(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginSecureOutgoingMessageAtInitiatorCore(Message message, string actor, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual Message EndSecureOutgoingMessageAtInitiatorCore(IAsyncResult result);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message);
    public virtual void EndSecureOutgoingMessage(IAsyncResult result, Message& message, SecurityProtocolCorrelationState& newCorrelationState);
    public sealed virtual void VerifyIncomingMessage(Message& message, TimeSpan timeout);
    protected void AttachRecipientSecurityProperty(Message message, IList`1<SecurityToken> basicTokens, IList`1<SecurityToken> endorsingTokens, IList`1<SecurityToken> signedEndorsingTokens, IList`1<SecurityToken> signedTokens, Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected virtual void VerifyIncomingMessageCore(Message& message, TimeSpan timeout);
}
internal class System.ServiceModel.Security.TransportSecurityProtocolFactory : SecurityProtocolFactory {
    public bool SupportsDuplex { get; }
    public bool SupportsReplayDetection { get; }
    internal TransportSecurityProtocolFactory(TransportSecurityProtocolFactory factory);
    public virtual bool get_SupportsDuplex();
    public virtual bool get_SupportsReplayDetection();
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
}
internal class System.ServiceModel.Security.TripleDesRsa15SecurityAlgorithmSuite : TripleDesSecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    public virtual string ToString();
}
public class System.ServiceModel.Security.TripleDesSecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.TripleDesSha256Rsa15SecurityAlgorithmSuite : TripleDesRsa15SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.TripleDesSha256SecurityAlgorithmSuite : TripleDesSecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Security.TrustDriver : object {
    public bool IsIssuedTokensSupported { get; }
    public string IssuedTokensHeaderName { get; }
    public string IssuedTokensHeaderNamespace { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
    public string RequestTypeClose { get; }
    public string RequestTypeIssue { get; }
    public string RequestTypeRenew { get; }
    public string ComputedKeyAlgorithm { get; }
    public SecurityStandardsManager StandardsManager { get; }
    public XmlDictionaryString Namespace { get; }
    public virtual bool get_IsIssuedTokensSupported();
    public virtual string get_IssuedTokensHeaderName();
    public virtual string get_IssuedTokensHeaderNamespace();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseFinalAction();
    public virtual string get_RequestTypeClose();
    public abstract virtual string get_RequestTypeIssue();
    public virtual string get_RequestTypeRenew();
    public abstract virtual string get_ComputedKeyAlgorithm();
    public abstract virtual SecurityStandardsManager get_StandardsManager();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual RequestSecurityToken CreateRequestSecurityToken(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponse CreateRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponseCollection CreateRequestSecurityTokenResponseCollection(XmlReader xmlReader);
    public abstract virtual bool IsAtRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual bool IsAtRequestSecurityTokenResponseCollection(XmlReader reader);
    public abstract virtual bool IsRequestedSecurityTokenElement(string name, string nameSpace);
    public abstract virtual bool IsRequestedProofTokenElement(string name, string nameSpace);
    public abstract virtual T GetAppliesTo(RequestSecurityToken rst, XmlObjectSerializer serializer);
    public abstract virtual T GetAppliesTo(RequestSecurityTokenResponse rstr, XmlObjectSerializer serializer);
    public abstract virtual void GetAppliesToQName(RequestSecurityToken rst, String& localName, String& namespaceUri);
    public abstract virtual void GetAppliesToQName(RequestSecurityTokenResponse rstr, String& localName, String& namespaceUri);
    public abstract virtual bool IsAppliesTo(string localName, string namespaceUri);
    public abstract virtual Byte[] GetAuthenticator(RequestSecurityTokenResponse rstr);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityToken rst);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityTokenResponse rstr);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityToken rst, SecurityTokenResolver resolver);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver);
    public abstract virtual GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver, IList`1<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, Byte[] requestorEntropy, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType);
    public abstract virtual GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, RSA clientKey);
    public abstract virtual void OnRSTRorRSTRCMissingException();
    public abstract virtual void WriteRequestSecurityToken(RequestSecurityToken rst, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponse(RequestSecurityTokenResponse rstr, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponseCollection(RequestSecurityTokenResponseCollection rstrCollection, XmlWriter writer);
    public abstract virtual IChannelFactory`1<IRequestChannel> CreateFederationProxy(EndpointAddress address, Binding binding, KeyedByTypeCollection`1<IEndpointBehavior> channelBehaviors);
    public abstract virtual XmlElement CreateKeySizeElement(int keySize);
    public abstract virtual XmlElement CreateKeyTypeElement(SecurityKeyType keyType);
    public abstract virtual XmlElement CreateTokenTypeElement(string tokenTypeUri);
    public abstract virtual XmlElement CreateRequiredClaimsElement(IEnumerable`1<XmlElement> claimsList);
    public abstract virtual XmlElement CreateUseKeyElement(SecurityKeyIdentifier keyIdentifier, SecurityStandardsManager standardsManager);
    public abstract virtual XmlElement CreateSignWithElement(string signatureAlgorithm);
    public abstract virtual XmlElement CreateEncryptWithElement(string encryptionAlgorithm);
    public abstract virtual XmlElement CreateEncryptionAlgorithmElement(string encryptionAlgorithm);
    public abstract virtual XmlElement CreateCanonicalizationAlgorithmElement(string canonicalicationAlgorithm);
    public abstract virtual XmlElement CreateComputedKeyAlgorithmElement(string computedKeyAlgorithm);
    public abstract virtual Collection`1<XmlElement> ProcessUnknownRequestParameters(Collection`1<XmlElement> unknownRequestParameters, Collection`1<XmlElement> originalRequestParameters);
    public abstract virtual bool TryParseKeySizeElement(XmlElement element, Int32& keySize);
    public abstract virtual bool TryParseKeyTypeElement(XmlElement element, SecurityKeyType& keyType);
    public abstract virtual bool TryParseTokenTypeElement(XmlElement element, String& tokenType);
    public abstract virtual bool TryParseRequiredClaimsElement(XmlElement element, Collection`1& requiredClaims);
    internal virtual bool IsSignWithElement(XmlElement element, String& signatureAlgorithm);
    internal virtual bool IsEncryptWithElement(XmlElement element, String& encryptWithAlgorithm);
    internal virtual bool IsEncryptionAlgorithmElement(XmlElement element, String& encryptionAlgorithm);
    internal virtual bool IsCanonicalizationAlgorithmElement(XmlElement element, String& canonicalizationAlgorithm);
    internal virtual bool IsKeyWrapAlgorithmElement(XmlElement element, String& keyWrapAlgorithm);
}
public abstract class System.ServiceModel.Security.TrustVersion : object {
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static TrustVersion Default { get; }
    public static TrustVersion WSTrustFeb2005 { get; }
    public static TrustVersion WSTrust13 { get; }
    internal TrustVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static TrustVersion get_Default();
    public static TrustVersion get_WSTrustFeb2005();
    public static TrustVersion get_WSTrust13();
}
public class System.ServiceModel.Security.UserNamePasswordClientCredential : object {
    public string UserName { get; public set; }
    public string Password { get; public set; }
    internal UserNamePasswordClientCredential(UserNamePasswordClientCredential other);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.UserNamePasswordServiceCredential : object {
    internal static UserNamePasswordValidationMode DefaultUserNamePasswordValidationMode;
    internal static bool DefaultCacheLogonTokens;
    internal static int DefaultMaxCachedLogonTokens;
    internal static string DefaultCachedLogonTokenLifetimeString;
    internal static TimeSpan DefaultCachedLogonTokenLifetime;
    public UserNamePasswordValidationMode UserNamePasswordValidationMode { get; public set; }
    public UserNamePasswordValidator CustomUserNamePasswordValidator { get; public set; }
    public MembershipProvider MembershipProvider { get; public set; }
    public bool IncludeWindowsGroups { get; public set; }
    public bool CacheLogonTokens { get; public set; }
    public int MaxCachedLogonTokens { get; public set; }
    public TimeSpan CachedLogonTokenLifetime { get; public set; }
    internal UserNamePasswordServiceCredential(UserNamePasswordServiceCredential other);
    private static UserNamePasswordServiceCredential();
    public UserNamePasswordValidationMode get_UserNamePasswordValidationMode();
    public void set_UserNamePasswordValidationMode(UserNamePasswordValidationMode value);
    public UserNamePasswordValidator get_CustomUserNamePasswordValidator();
    public void set_CustomUserNamePasswordValidator(UserNamePasswordValidator value);
    public MembershipProvider get_MembershipProvider();
    public void set_MembershipProvider(MembershipProvider value);
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    public bool get_CacheLogonTokens();
    public void set_CacheLogonTokens(bool value);
    public int get_MaxCachedLogonTokens();
    public void set_MaxCachedLogonTokens(int value);
    public TimeSpan get_CachedLogonTokenLifetime();
    public void set_CachedLogonTokenLifetime(TimeSpan value);
    internal UserNamePasswordValidator GetUserNamePasswordValidator();
    internal void MakeReadOnly();
}
public enum System.ServiceModel.Security.UserNamePasswordValidationMode : Enum {
    public int value__;
    public static UserNamePasswordValidationMode Windows;
    public static UserNamePasswordValidationMode MembershipProvider;
    public static UserNamePasswordValidationMode Custom;
}
internal static class System.ServiceModel.Security.UserNamePasswordValidationModeHelper : object {
    public static bool IsDefined(UserNamePasswordValidationMode validationMode);
    public static void Validate(UserNamePasswordValidationMode value);
}
public class System.ServiceModel.Security.WindowsClientCredential : object {
    internal static TokenImpersonationLevel DefaultImpersonationLevel;
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    public NetworkCredential ClientCredential { get; public set; }
    [ObsoleteAttribute("This property is deprecated and is maintained for backward compatibility only. The local machine policy will be used to determine if NTLM should be used.")]
public bool AllowNtlm { get; public set; }
    internal WindowsClientCredential(WindowsClientCredential other);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    public bool get_AllowNtlm();
    public void set_AllowNtlm(bool value);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.WindowsServiceCredential : object {
    public bool AllowAnonymousLogons { get; public set; }
    public bool IncludeWindowsGroups { get; public set; }
    internal WindowsServiceCredential(WindowsServiceCredential other);
    public bool get_AllowAnonymousLogons();
    public void set_AllowAnonymousLogons(bool value);
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    internal void MakeReadOnly();
}
internal class System.ServiceModel.Security.WindowsSspiNegotiation : object {
    public DateTime ExpirationTimeUtc { get; }
    public bool IsCompleted { get; }
    public bool IsDelegationFlag { get; }
    public bool IsIdentifyFlag { get; }
    public bool IsMutualAuthFlag { get; }
    public bool IsValidContext { get; }
    public string KeyEncryptionAlgorithm { get; }
    public LifeSpan LifeSpan { get; }
    public string ProtocolName { get; }
    public string ServicePrincipalName { get; }
    internal WindowsSspiNegotiation(string package, SafeFreeCredentials credentialsHandle, TokenImpersonationLevel impersonationLevel, string servicePrincipalName, bool doMutualAuth, bool interactiveLogonEnabled, bool ntlmEnabled);
    internal WindowsSspiNegotiation(string package, SafeFreeCredentials credentialsHandle, string defaultServiceBinding);
    public sealed virtual DateTime get_ExpirationTimeUtc();
    public sealed virtual bool get_IsCompleted();
    public bool get_IsDelegationFlag();
    public bool get_IsIdentifyFlag();
    public bool get_IsMutualAuthFlag();
    public sealed virtual bool get_IsValidContext();
    public sealed virtual string get_KeyEncryptionAlgorithm();
    public LifeSpan get_LifeSpan();
    public string get_ProtocolName();
    public string get_ServicePrincipalName();
    public sealed virtual string GetRemoteIdentityName();
    public sealed virtual Byte[] Decrypt(Byte[] encryptedContent);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Encrypt(Byte[] input);
    public sealed virtual Byte[] GetOutgoingBlob(Byte[] incomingBlob, ChannelBinding channelbinding, ExtendedProtectionPolicy protectionPolicy);
    public void ImpersonateContext();
    internal void CloseContext();
    internal SafeCloseHandle GetContextToken();
}
internal class System.ServiceModel.Security.WrappedRsaSecurityTokenAuthenticator : RsaSecurityTokenAuthenticator {
    public WrappedRsaSecurityTokenAuthenticator(RsaSecurityTokenHandler wrappedRsaSecurityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.WrappedSaml11SecurityTokenAuthenticator : SamlSecurityTokenAuthenticator {
    public WrappedSaml11SecurityTokenAuthenticator(SamlSecurityTokenHandler saml11SecurityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.WrappedSaml2SecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public WrappedSaml2SecurityTokenAuthenticator(Saml2SecurityTokenHandler saml2SecurityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.WrappedSamlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public WrappedSamlSecurityTokenAuthenticator(WrappedSaml11SecurityTokenAuthenticator wrappedSaml11SecurityTokenAuthenticator, WrappedSaml2SecurityTokenAuthenticator wrappedSaml2SecurityTokenAuthenticator);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.WrappedSessionSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public IssuedSecurityTokenHandler IssuedSecurityTokenHandler { get; public set; }
    public RenewedSecurityTokenHandler RenewedSecurityTokenHandler { get; public set; }
    public CommunicationState State { get; }
    public WrappedSessionSecurityTokenAuthenticator(SessionSecurityTokenHandler sessionTokenHandler, SecurityTokenAuthenticator wcfSessionAuthenticator, SctClaimsHandler sctClaimsHandler, ExceptionMapper exceptionMapper);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    public sealed virtual IssuedSecurityTokenHandler get_IssuedSecurityTokenHandler();
    public sealed virtual void set_IssuedSecurityTokenHandler(IssuedSecurityTokenHandler value);
    public sealed virtual RenewedSecurityTokenHandler get_RenewedSecurityTokenHandler();
    public sealed virtual void set_RenewedSecurityTokenHandler(RenewedSecurityTokenHandler value);
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual void Close();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual void Open();
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
}
internal class System.ServiceModel.Security.WrappedTokenCache : SecurityTokenResolver {
    public WrappedTokenCache(SessionSecurityTokenCache tokenCache, SctClaimsHandler sctClaimsHandler);
    public sealed virtual void AddContext(SecurityContextSecurityToken token);
    public sealed virtual void ClearContexts();
    public sealed virtual Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    public sealed virtual SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public sealed virtual void RemoveAllContexts(UniqueId contextId);
    public sealed virtual void RemoveContext(UniqueId contextId, UniqueId generation);
    public sealed virtual bool TryAddContext(SecurityContextSecurityToken token);
    public sealed virtual void UpdateContextCachingTime(SecurityContextSecurityToken token, DateTime expirationTime);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
}
internal class System.ServiceModel.Security.WrappedUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
    public WrappedUserNameSecurityTokenAuthenticator(UserNameSecurityTokenHandler wrappedUserNameSecurityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password);
}
internal class System.ServiceModel.Security.WrappedX509SecurityTokenAuthenticator : X509SecurityTokenAuthenticator {
    public WrappedX509SecurityTokenAuthenticator(X509SecurityTokenHandler wrappedX509SecurityTokenHandler, ExceptionMapper exceptionMapper);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.ServiceModel.Security.WrappedXmlDictionaryWriter : XmlDictionaryWriter {
    public WriteState WriteState { get; }
    public WrappedXmlDictionaryWriter(XmlDictionaryWriter writer, string id);
    public virtual void WriteStartAttribute(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartElement(string prefix, string localName, string namespaceUri);
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
}
internal class System.ServiceModel.Security.WrapperSecurityCommunicationObject : CommunicationObject {
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public WrapperSecurityCommunicationObject(ISecurityCommunicationObject innerCommunicationObject);
    protected virtual Type GetCommunicationObjectType();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfDisposedOrImmutable();
}
internal class System.ServiceModel.Security.WSKeyInfoSerializer : KeyInfoSerializer {
    public WSKeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer, SecurityVersion securityVersion, SecureConversationVersion secureConversationVersion);
}
internal abstract class System.ServiceModel.Security.WSSecureConversation : SerializerEntries {
    public SecureConversationDictionary SerializerDictionary { get; }
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public string DerivationAlgorithm { get; }
    protected WSSecureConversation(WSSecurityTokenSerializer tokenSerializer, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public abstract virtual SecureConversationDictionary get_SerializerDictionary();
    public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual bool IsAtDerivedKeyToken(XmlDictionaryReader reader);
    public virtual void ReadDerivedKeyTokenParameters(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver, String& id, String& derivationAlgorithm, String& label, Int32& length, Byte[]& nonce, Int32& offset, Int32& generation, SecurityKeyIdentifierClause& tokenToDeriveIdentifier, SecurityToken& tokenToDerive);
    public virtual SecurityToken CreateDerivedKeyToken(string id, string derivationAlgorithm, string label, int length, Byte[] nonce, int offset, int generation, SecurityKeyIdentifierClause tokenToDeriveIdentifier, SecurityToken tokenToDerive);
    public virtual string get_DerivationAlgorithm();
}
internal class System.ServiceModel.Security.WSSecureConversationDec2005 : WSSecureConversation {
    public SecureConversationDictionary SerializerDictionary { get; }
    public string DerivationAlgorithm { get; }
    public WSSecureConversationDec2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public virtual SecureConversationDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual string get_DerivationAlgorithm();
}
internal class System.ServiceModel.Security.WSSecureConversationFeb2005 : WSSecureConversation {
    public SecureConversationDictionary SerializerDictionary { get; }
    public WSSecureConversationFeb2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public virtual SecureConversationDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.ServiceModel.Security.WSSecurityJan2004 : SerializerEntries {
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public SamlSerializer SamlSerializer { get; }
    public WSSecurityJan2004(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer);
    public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public SamlSerializer get_SamlSerializer();
    protected void PopulateJan2004TokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneReceiveSecurityHeader : WSSecurityOneDotZeroReceiveSecurityHeader {
    public WSSecurityOneDotOneReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
    protected virtual DecryptedHeader DecryptHeader(XmlDictionaryReader reader, WrappedKeySecurityToken wrappedKeyToken);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneSendSecurityHeader : WSSecurityOneDotZeroSendSecurityHeader {
    public WSSecurityOneDotOneSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    protected virtual ISignatureValueSecurityElement[] CreateSignatureConfirmationElements(SignatureConfirmations signatureConfirmations);
    protected virtual EncryptedHeader EncryptHeader(MessageHeader plainTextHeader, SymmetricAlgorithm algorithm, SecurityKeyIdentifier keyIdentifier, MessageVersion version, string id, MemoryStream stream);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroReceiveSecurityHeader : ReceiveSecurityHeader {
    public WSSecurityOneDotZeroReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection transferDirection);
    protected static SymmetricAlgorithm CreateDecryptionAlgorithm(SecurityToken token, string encryptionMethod, SecurityAlgorithmSuite suite);
    protected virtual DecryptedHeader DecryptHeader(XmlDictionaryReader reader, WrappedKeySecurityToken wrappedKeyToken);
    protected virtual Byte[] DecryptSecurityHeaderElement(EncryptedData encryptedData, WrappedKeySecurityToken wrappedKeyToken, SecurityToken& encryptionToken);
    protected virtual WrappedKeySecurityToken DecryptWrappedKey(XmlDictionaryReader reader);
    protected virtual void ExecuteMessageProtectionPass(bool hasAtLeastOneSupportingTokenExpectedToBeSigned);
    protected virtual bool IsReaderAtEncryptedData(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtEncryptedKey(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtReferenceList(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtSignature(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader);
    protected virtual void ProcessReferenceListCore(ReferenceList referenceList, WrappedKeySecurityToken wrappedKeyToken);
    protected virtual ReferenceList ReadReferenceListCore(XmlDictionaryReader reader);
    protected virtual EncryptedData ReadSecurityHeaderEncryptedItem(XmlDictionaryReader reader, bool readXmlreferenceKeyInfoClause);
    protected virtual SignedXml ReadSignatureCore(XmlDictionaryReader signatureReader);
    protected static bool TryResolveKeyIdentifier(SecurityKeyIdentifier keyIdentifier, SecurityTokenResolver resolver, bool isFromSignature, SecurityToken& token);
    protected static SecurityToken ResolveKeyIdentifier(SecurityKeyIdentifier keyIdentifier, SecurityTokenResolver resolver, bool isFromSignature);
    protected virtual void ReadSecurityTokenReference(XmlDictionaryReader reader);
    protected virtual bool TryDeleteReferenceListEntry(string id);
    protected virtual void EnsureDecryptionComplete();
    protected virtual void OnDecryptionOfSecurityHeaderItemRequiringReferenceListEntry(string id);
    protected virtual SecurityToken VerifySignature(SignedXml signedXml, bool isPrimarySignature, SecurityHeaderTokenResolver resolver, object signatureTarget, string id);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroSendSecurityHeader : SendSecurityHeader {
    protected string EncryptionAlgorithm { get; }
    protected XmlDictionaryString EncryptionAlgorithmDictionaryString { get; }
    protected bool HasSignedEncryptedMessagePart { get; }
    public WSSecurityOneDotZeroSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    protected string get_EncryptionAlgorithm();
    protected XmlDictionaryString get_EncryptionAlgorithmDictionaryString();
    protected virtual bool get_HasSignedEncryptedMessagePart();
    public virtual void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    public virtual void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    protected static MemoryStream CaptureToken(SecurityToken token, SecurityStandardsManager serializer);
    protected static MemoryStream CaptureSecurityElement(ISecurityElement element);
    protected virtual ISecurityElement CompleteEncryptionCore(SendSecurityHeaderElement primarySignature, SendSecurityHeaderElement[] basicTokens, SendSecurityHeaderElement[] signatureConfirmations, SendSecurityHeaderElement[] endorsingSignatures);
    protected virtual ISignatureValueSecurityElement CompletePrimarySignatureCore(SendSecurityHeaderElement[] signatureConfirmations, SecurityToken[] signedEndorsingTokens, SecurityToken[] signedTokens, SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature);
    protected virtual EncryptedHeader EncryptHeader(MessageHeader plainTextHeader, SymmetricAlgorithm algorithm, SecurityKeyIdentifier keyIdentifier, MessageVersion version, string id, MemoryStream stream);
    protected virtual void StartEncryptionCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier);
    protected virtual void StartPrimarySignatureCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier, MessagePartSpecification signatureParts, bool generateTargettableSignature);
    protected virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier);
    protected virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement elementToSign);
    protected virtual void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters);
}
internal abstract class System.ServiceModel.Security.WSSecurityPolicy : object {
    public static ContractDescription NullContract;
    public static ServiceEndpoint NullServiceEndpoint;
    public static XmlDocument doc;
    public static string WsspPrefix;
    public static string WspNamespace;
    public static string Wsp15Namespace;
    public static string WspPrefix;
    public static string MsspNamespace;
    public static string MsspPrefix;
    public static string PolicyName;
    public static string OptionalName;
    public static string TrueName;
    public static string FalseName;
    public static string SymmetricBindingName;
    public static string AsymmetricBindingName;
    public static string TransportBindingName;
    public static string OnlySignEntireHeadersAndBodyName;
    public static string ProtectionTokenName;
    public static string InitiatorTokenName;
    public static string RecipientTokenName;
    public static string TransportTokenName;
    public static string AlgorithmSuiteName;
    public static string LaxName;
    public static string LaxTsLastName;
    public static string LaxTsFirstName;
    public static string StrictName;
    public static string IncludeTimestampName;
    public static string EncryptBeforeSigningName;
    public static string ProtectTokens;
    public static string EncryptSignatureName;
    public static string SignedSupportingTokensName;
    public static string EndorsingSupportingTokensName;
    public static string SignedEndorsingSupportingTokensName;
    public static string Wss10Name;
    public static string MustSupportRefKeyIdentifierName;
    public static string MustSupportRefIssuerSerialName;
    public static string MustSupportRefThumbprintName;
    public static string MustSupportRefEncryptedKeyName;
    public static string RequireSignatureConfirmationName;
    public static string MustSupportIssuedTokensName;
    public static string RequireClientEntropyName;
    public static string RequireServerEntropyName;
    public static string Wss11Name;
    public static string Trust10Name;
    public static string Trust13Name;
    public static string RequireAppliesTo;
    public static string SignedPartsName;
    public static string EncryptedPartsName;
    public static string BodyName;
    public static string HeaderName;
    public static string NameName;
    public static string NamespaceName;
    public static string Basic128Name;
    public static string Basic192Name;
    public static string Basic256Name;
    public static string TripleDesName;
    public static string Basic128Rsa15Name;
    public static string Basic192Rsa15Name;
    public static string Basic256Rsa15Name;
    public static string TripleDesRsa15Name;
    public static string Basic128Sha256Name;
    public static string Basic192Sha256Name;
    public static string Basic256Sha256Name;
    public static string TripleDesSha256Name;
    public static string Basic128Sha256Rsa15Name;
    public static string Basic192Sha256Rsa15Name;
    public static string Basic256Sha256Rsa15Name;
    public static string TripleDesSha256Rsa15Name;
    public static string IncludeTokenName;
    public static string KerberosTokenName;
    public static string X509TokenName;
    public static string IssuedTokenName;
    public static string UsernameTokenName;
    public static string RsaTokenName;
    public static string KeyValueTokenName;
    public static string SpnegoContextTokenName;
    public static string SslContextTokenName;
    public static string SecureConversationTokenName;
    public static string WssGssKerberosV5ApReqToken11Name;
    public static string RequireDerivedKeysName;
    public static string RequireIssuerSerialReferenceName;
    public static string RequireKeyIdentifierReferenceName;
    public static string RequireThumbprintReferenceName;
    public static string WssX509V3Token10Name;
    public static string WssUsernameToken10Name;
    public static string RequestSecurityTokenTemplateName;
    public static string RequireExternalReferenceName;
    public static string RequireInternalReferenceName;
    public static string IssuerName;
    public static string RequireClientCertificateName;
    public static string MustNotSendCancelName;
    public static string MustNotSendAmendName;
    public static string MustNotSendRenewName;
    public static string LayoutName;
    public static string BootstrapPolicyName;
    public static string HttpsTokenName;
    public static string HttpBasicAuthenticationName;
    public static string HttpDigestAuthenticationName;
    public string WsspNamespaceUri { get; }
    public TrustDriver TrustDriver { get; }
    public string AlwaysToRecipientUri { get; }
    public string NeverUri { get; }
    public string OnceUri { get; }
    public string AlwaysToInitiatorUri { get; }
    private static WSSecurityPolicy();
    public virtual XmlElement CreateWsspAssertion(string name);
    public virtual bool IsWsspAssertion(XmlElement assertion);
    public virtual bool IsWsspAssertion(XmlElement assertion, string name);
    public virtual bool IsMsspAssertion(XmlElement assertion, string name);
    public virtual bool TryImportWsspAssertion(ICollection`1<XmlElement> assertions, string name, XmlElement& assertion);
    public virtual bool TryImportWsspAssertion(ICollection`1<XmlElement> assertions, string name);
    public virtual bool TryImportWsspAssertion(ICollection`1<XmlElement> assertions, string name, bool isOptional);
    public virtual XmlElement CreateMsspAssertion(string name);
    public virtual bool CanImportAssertion(ICollection`1<XmlElement> assertions);
    public abstract virtual bool IsSecurityVersionSupported(MessageSecurityVersion version);
    public abstract virtual MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version);
    public abstract virtual string get_WsspNamespaceUri();
    public abstract virtual TrustDriver get_TrustDriver();
    public virtual string get_AlwaysToRecipientUri();
    public virtual string get_NeverUri();
    public virtual string get_OnceUri();
    public virtual string get_AlwaysToInitiatorUri();
    public virtual bool TryImportMsspAssertion(ICollection`1<XmlElement> assertions, string name);
    public virtual XmlElement CreateWspPolicyWrapper(MetadataExporter exporter, XmlElement[] nestedAssertions);
    public virtual XmlElement CreateWsspSignedPartsAssertion(MessagePartSpecification parts);
    public virtual XmlElement CreateWsspEncryptedPartsAssertion(MessagePartSpecification parts);
    public virtual MessagePartSpecification TryGetProtectedParts(XmlElement assertion);
    public virtual bool TryImportWsspEncryptedPartsAssertion(ICollection`1<XmlElement> assertions, MessagePartSpecification& parts, XmlElement& assertion);
    public virtual bool TryImportWsspSignedPartsAssertion(ICollection`1<XmlElement> assertions, MessagePartSpecification& parts, XmlElement& assertion);
    public virtual XmlElement CreateWsspHeaderAssertion(XmlQualifiedName header);
    public virtual XmlElement CreateWsspSymmetricBindingAssertion(MetadataExporter exporter, PolicyConversionContext policyContext, SymmetricSecurityBindingElement binding);
    public virtual bool TryGetNestedPolicyAlternatives(MetadataImporter importer, XmlElement assertion, Collection`1& alternatives);
    public virtual bool TryImportWsspSymmetricBindingAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, SymmetricSecurityBindingElement& binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspAsymmetricBindingAssertion(MetadataExporter exporter, PolicyConversionContext policyContext, AsymmetricSecurityBindingElement binding);
    public virtual bool TryImportWsspAsymmetricBindingAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, AsymmetricSecurityBindingElement& binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspTransportBindingAssertion(MetadataExporter exporter, TransportSecurityBindingElement binding, XmlElement transportTokenAssertion);
    public virtual bool TryImportWsspTransportBindingAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, TransportSecurityBindingElement& binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspWssAssertion(MetadataExporter exporter, SecurityBindingElement binding);
    public virtual bool TryImportWsspWssAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspWss10Assertion(MetadataExporter exporter);
    public virtual XmlElement CreateWsspWss11Assertion(MetadataExporter exporter, bool requireSignatureConfirmation);
    public virtual XmlElement CreateWsspAssertionMustSupportRefKeyIdentifierName();
    public virtual XmlElement CreateWsspAssertionMustSupportRefIssuerSerialName();
    public virtual XmlElement CreateWsspAssertionMustSupportRefThumbprintName();
    public virtual XmlElement CreateWsspAssertionMustSupportRefEncryptedKeyName();
    public virtual XmlElement CreateWsspRequireSignatureConformationAssertion(bool requireSignatureConfirmation);
    public abstract virtual XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode);
    public abstract virtual bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding, XmlElement& assertion);
    protected XmlElement CreateWsspTrustAssertion(string trustName, MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode);
    protected bool TryImportWsspTrustAssertion(string trustName, MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspRequireClientEntropyAssertion(SecurityKeyEntropyMode keyEntropyMode);
    public virtual XmlElement CreateWsspRequireServerEntropyAssertion(SecurityKeyEntropyMode keyEntropyMode);
    public virtual Collection`1<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, Collection`1<SecurityTokenParameters> optionalEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing);
    public virtual Collection`1<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, Collection`1<SecurityTokenParameters> optionalEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion);
    protected XmlElement CreateWsspSignedSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted);
    protected XmlElement CreateWsspEndorsingSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> optionalEndorsing, AddressingVersion addressingVersion);
    protected XmlElement CreateWsspSignedEndorsingSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion);
    protected XmlElement CreateWsspiSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> optionalEndorsing, AddressingVersion addressingVersion, string assertionName);
    public virtual bool TryImportWsspSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, Collection`1<SecurityTokenParameters> optionalEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing);
    protected bool TryImportWsspSignedSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, XmlElement& assertion);
    protected bool TryImportWsspEndorsingSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> optionalEndorsing, XmlElement& assertion);
    protected bool TryImportWsspSignedEndorsingSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing, XmlElement& assertion);
    public virtual XmlElement CreateWsspEncryptSignatureAssertion(PolicyConversionContext policyContext, SecurityBindingElement binding);
    public virtual XmlElement CreateWsspEncryptBeforeSigningAssertion(MessageProtectionOrder protectionOrder);
    public virtual XmlElement CreateWsspProtectTokensAssertion(SecurityBindingElement sbe);
    public virtual bool TryImportMessageProtectionOrderAssertions(ICollection`1<XmlElement> assertions, MessageProtectionOrder& order);
    public virtual XmlElement CreateWsspIncludeTimestampAssertion(bool includeTimestamp);
    public virtual bool TryImportWsspIncludeTimestampAssertion(ICollection`1<XmlElement> assertions, SecurityBindingElement binding);
    public virtual bool TryImportWsspProtectTokensAssertion(ICollection`1<XmlElement> assertions, Boolean& protectTokens);
    public virtual XmlElement CreateWsspLayoutAssertion(MetadataExporter exporter, SecurityHeaderLayout layout);
    public virtual bool TryImportWsspLayoutAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding);
    public virtual XmlElement CreateLayoutAssertion(SecurityHeaderLayout layout);
    public virtual bool TryImportLayoutAssertion(ICollection`1<XmlElement> assertions, SecurityHeaderLayout& layout);
    public virtual XmlElement CreateWsspAlgorithmSuiteAssertion(MetadataExporter exporter, SecurityAlgorithmSuite suite);
    public virtual bool TryImportWsspAlgorithmSuiteAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding);
    public virtual XmlElement CreateAlgorithmSuiteAssertion(SecurityAlgorithmSuite suite);
    public virtual bool TryImportAlgorithmSuiteAssertion(ICollection`1<XmlElement> assertions, SecurityAlgorithmSuite& suite);
    public virtual XmlElement CreateWsspProtectionTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters);
    public virtual bool TryImportWsspProtectionTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, SymmetricSecurityBindingElement binding);
    public virtual bool TryImportWsspInitiatorTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, AsymmetricSecurityBindingElement binding);
    public virtual bool TryImportWsspRecipientTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, AsymmetricSecurityBindingElement binding);
    public virtual XmlElement CreateWsspInitiatorTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspRecipientTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspTransportTokenAssertion(MetadataExporter exporter, XmlElement transportTokenAssertion);
    public virtual bool TryImportWsspTransportTokenAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, XmlElement& transportBindingAssertion);
    public virtual XmlElement CreateTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters);
    public virtual XmlElement CreateTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters, bool isOptional);
    public virtual bool TryImportTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, Collection`1<XmlElement> assertions, SecurityTokenParameters& parameters, Boolean& isOptional);
    public virtual void SetIncludeTokenValue(XmlElement tokenAssertion, SecurityTokenInclusionMode inclusionMode);
    public virtual bool TryGetIncludeTokenValue(XmlElement assertion, SecurityTokenInclusionMode& mode);
    public virtual XmlElement CreateWsspRequireDerivedKeysAssertion(bool requireDerivedKeys);
    public virtual bool TryImportWsspRequireDerivedKeysAssertion(ICollection`1<XmlElement> assertions, SecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspKerberosTokenAssertion(MetadataExporter exporter, KerberosSecurityTokenParameters parameters);
    public virtual bool TryImportWsspKerberosTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateX509ReferenceStyleAssertion(X509KeyIdentifierClauseType referenceStyle);
    public virtual bool TryImportX509ReferenceStyleAssertion(ICollection`1<XmlElement> assertions, X509SecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspX509TokenAssertion(MetadataExporter exporter, X509SecurityTokenParameters parameters);
    public virtual bool TryImportWsspX509TokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateWsspUsernameTokenAssertion(MetadataExporter exporter, UserNameSecurityTokenParameters parameters);
    public virtual bool TryImportWsspUsernameTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateWsspRsaTokenAssertion(RsaSecurityTokenParameters parameters);
    public virtual bool TryImportWsspRsaTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateReferenceStyleAssertion(SecurityTokenReferenceStyle referenceStyle);
    public virtual bool TryImportReferenceStyleAssertion(ICollection`1<XmlElement> assertions, IssuedSecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspIssuerElement(EndpointAddress issuerAddress, EndpointAddress issuerMetadataAddress);
    public virtual bool TryGetIssuer(XmlElement assertion, EndpointAddress& issuer, EndpointAddress& issuerMetadata);
    public virtual XmlElement CreateWsspIssuedTokenAssertion(MetadataExporter exporter, IssuedSecurityTokenParameters parameters);
    public virtual bool TryGetRequestSecurityTokenTemplate(XmlElement assertion, Collection`1& requestParameters);
    public virtual bool TryImportWsspIssuedTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateWsspMustNotSendCancelAssertion(bool requireCancel);
    public virtual bool TryImportWsspMustNotSendCancelAssertion(ICollection`1<XmlElement> assertions, Boolean& requireCancellation);
    public virtual XmlElement CreateWsspSpnegoContextTokenAssertion(MetadataExporter exporter, SspiSecurityTokenParameters parameters);
    public virtual bool TryImportWsspSpnegoContextTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public abstract virtual XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding);
    public abstract virtual bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, HttpsTransportBindingElement httpsBinding);
    public virtual bool ContainsWsspHttpsTokenAssertion(ICollection`1<XmlElement> assertions);
    public virtual XmlElement CreateMsspRequireClientCertificateAssertion(bool requireClientCertificate);
    public virtual bool TryImportMsspRequireClientCertificateAssertion(ICollection`1<XmlElement> assertions, SslSecurityTokenParameters parameters);
    public virtual XmlElement CreateMsspSslContextTokenAssertion(MetadataExporter exporter, SslSecurityTokenParameters parameters);
    public virtual bool TryImportMsspSslContextTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual XmlElement CreateWsspBootstrapPolicyAssertion(MetadataExporter exporter, SecurityBindingElement bootstrapSecurity);
    public virtual ICollection`1<XmlElement> FilterWsspPolicyAssertions(ICollection`1<XmlElement> policyAssertions);
    public virtual bool TryImportWsspBootstrapPolicyAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecureConversationSecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspSecureConversationTokenAssertion(MetadataExporter exporter, SecureConversationSecurityTokenParameters parameters);
    public virtual bool TryImportWsspSecureConversationTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public static bool TryGetSecurityPolicyDriver(ICollection`1<XmlElement> assertions, WSSecurityPolicy& securityPolicy);
    public static WSSecurityPolicy GetSecurityPolicyDriver(MessageSecurityVersion version);
}
internal class System.ServiceModel.Security.WSSecurityPolicy11 : WSSecurityPolicy {
    public static string WsspNamespace;
    public string WsspNamespaceUri { get; }
    public TrustDriver TrustDriver { get; }
    public virtual string get_WsspNamespaceUri();
    public virtual bool IsSecurityVersionSupported(MessageSecurityVersion version);
    public virtual MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version);
    public virtual TrustDriver get_TrustDriver();
    public virtual XmlElement CreateWsspMustNotSendCancelAssertion(bool requireCancel);
    public virtual bool TryImportWsspMustNotSendCancelAssertion(ICollection`1<XmlElement> assertions, Boolean& requireCancellation);
    public virtual XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding);
    public virtual bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, HttpsTransportBindingElement httpsBinding);
    public virtual XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode);
    public virtual bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding, XmlElement& assertion);
}
internal class System.ServiceModel.Security.WSSecurityPolicy12 : WSSecurityPolicy {
    public static string WsspNamespace;
    public static string SignedEncryptedSupportingTokensName;
    public static string RequireImpliedDerivedKeysName;
    public static string RequireExplicitDerivedKeysName;
    public string WsspNamespaceUri { get; }
    public TrustDriver TrustDriver { get; }
    public virtual string get_WsspNamespaceUri();
    public virtual bool IsSecurityVersionSupported(MessageSecurityVersion version);
    public virtual MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version);
    public virtual TrustDriver get_TrustDriver();
    public virtual XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding);
    public virtual bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, HttpsTransportBindingElement httpsBinding);
    public virtual Collection`1<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, Collection`1<SecurityTokenParameters> optionalEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion);
    public virtual XmlElement CreateWsspSpnegoContextTokenAssertion(MetadataExporter exporter, SspiSecurityTokenParameters parameters);
    public virtual XmlElement CreateMsspSslContextTokenAssertion(MetadataExporter exporter, SslSecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspSecureConversationTokenAssertion(MetadataExporter exporter, SecureConversationSecurityTokenParameters parameters);
    public virtual bool TryImportWsspSpnegoContextTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual bool TryImportMsspSslContextTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual bool TryImportWsspSecureConversationTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
    public virtual bool TryImportWsspMustNotSendAmendAssertion(ICollection`1<XmlElement> assertions);
    public virtual bool TryImportWsspMustNotSendRenewAssertion(ICollection`1<XmlElement> assertions, Boolean& canRenewSession);
    public virtual bool TryImportWsspSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection`1<XmlElement> assertions, Collection`1<SecurityTokenParameters> signed, Collection`1<SecurityTokenParameters> signedEncrypted, Collection`1<SecurityTokenParameters> endorsing, Collection`1<SecurityTokenParameters> signedEndorsing, Collection`1<SecurityTokenParameters> optionalSigned, Collection`1<SecurityTokenParameters> optionalSignedEncrypted, Collection`1<SecurityTokenParameters> optionalEndorsing, Collection`1<SecurityTokenParameters> optionalSignedEndorsing);
    public virtual bool TryImportWsspRequireDerivedKeysAssertion(ICollection`1<XmlElement> assertions, SecurityTokenParameters parameters);
    public virtual XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode);
    public virtual bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection`1<XmlElement> assertions, SecurityBindingElement binding, XmlElement& assertion);
    public virtual XmlElement CreateWsspRsaTokenAssertion(RsaSecurityTokenParameters parameters);
    public virtual bool TryImportWsspRsaTokenAssertion(MetadataImporter importer, XmlElement assertion, SecurityTokenParameters& parameters);
}
public class System.ServiceModel.Security.WSSecurityTokenSerializer : SecurityTokenSerializer {
    public static WSSecurityTokenSerializer DefaultInstance { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public int MaximumKeyDerivationOffset { get; }
    public int MaximumKeyDerivationLabelLength { get; }
    public int MaximumKeyDerivationNonceLength { get; }
    internal WSSecureConversation SecureConversation { get; }
    public WSSecurityTokenSerializer(bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public static WSSecurityTokenSerializer get_DefaultInstance();
    public bool get_EmitBspRequiredAttributes();
    public SecurityVersion get_SecurityVersion();
    public int get_MaximumKeyDerivationOffset();
    public int get_MaximumKeyDerivationLabelLength();
    public int get_MaximumKeyDerivationNonceLength();
    internal WSSecureConversation get_SecureConversation();
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    internal Type[] GetTokenTypes(string tokenTypeUri);
    protected internal virtual string GetTokenTypeUri(Type tokenType);
    public virtual bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, SecurityKeyIdentifierClause& securityKeyIdentifierClause);
    public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
}
internal class System.ServiceModel.Security.WsSecurityTokenSerializerAdapter : WSSecurityTokenSerializer {
    public bool MapExceptionsToSoapFaults { get; public set; }
    public SecurityTokenHandlerCollection SecurityTokenHandlers { get; }
    public ExceptionMapper ExceptionMapper { get; public set; }
    public WsSecurityTokenSerializerAdapter(SecurityTokenHandlerCollection securityTokenHandlerCollection);
    public WsSecurityTokenSerializerAdapter(SecurityTokenHandlerCollection securityTokenHandlerCollection, SecurityVersion securityVersion);
    public WsSecurityTokenSerializerAdapter(SecurityTokenHandlerCollection securityTokenHandlerCollection, SecurityVersion securityVersion, bool emitBspAttributes, SamlSerializer samlSerializer, SecurityStateEncoder stateEncoder, IEnumerable`1<Type> knownTypes);
    public WsSecurityTokenSerializerAdapter(SecurityTokenHandlerCollection securityTokenHandlerCollection, SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspAttributes, SamlSerializer samlSerializer, SecurityStateEncoder stateEncoder, IEnumerable`1<Type> knownTypes);
    public bool get_MapExceptionsToSoapFaults();
    public void set_MapExceptionsToSoapFaults(bool value);
    public SecurityTokenHandlerCollection get_SecurityTokenHandlers();
    public ExceptionMapper get_ExceptionMapper();
    public void set_ExceptionMapper(ExceptionMapper value);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
internal class System.ServiceModel.Security.WSSecurityXXX2005 : WSSecurityJan2004 {
    public WSSecurityXXX2005(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal abstract class System.ServiceModel.Security.WSTrust : SerializerEntries {
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public TrustDictionary SerializerDictionary { get; }
    public WSTrust(WSSecurityTokenSerializer tokenSerializer);
    public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public abstract virtual TrustDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    protected static bool CheckElement(XmlElement element, string name, string ns, String& value);
}
public class System.ServiceModel.Security.WSTrustChannel : object {
    public IChannel Channel { get; protected set; }
    public WSTrustChannelFactory ChannelFactory { get; protected set; }
    public IWSTrustChannelContract Contract { get; protected set; }
    public TrustVersion TrustVersion { get; protected set; }
    public WSTrustSerializationContext WSTrustSerializationContext { get; protected set; }
    public WSTrustRequestSerializer WSTrustRequestSerializer { get; protected set; }
    public WSTrustResponseSerializer WSTrustResponseSerializer { get; protected set; }
    public CommunicationState State { get; }
    public WSTrustChannel(WSTrustChannelFactory factory, IWSTrustChannelContract inner, TrustVersion trustVersion, WSTrustSerializationContext context, WSTrustRequestSerializer requestSerializer, WSTrustResponseSerializer responseSerializer);
    public IChannel get_Channel();
    protected void set_Channel(IChannel value);
    public WSTrustChannelFactory get_ChannelFactory();
    protected void set_ChannelFactory(WSTrustChannelFactory value);
    public IWSTrustChannelContract get_Contract();
    protected void set_Contract(IWSTrustChannelContract value);
    public TrustVersion get_TrustVersion();
    protected void set_TrustVersion(TrustVersion value);
    public WSTrustSerializationContext get_WSTrustSerializationContext();
    protected void set_WSTrustSerializationContext(WSTrustSerializationContext value);
    public WSTrustRequestSerializer get_WSTrustRequestSerializer();
    protected void set_WSTrustRequestSerializer(WSTrustRequestSerializer value);
    public WSTrustResponseSerializer get_WSTrustResponseSerializer();
    protected void set_WSTrustResponseSerializer(WSTrustResponseSerializer value);
    protected virtual Message CreateRequest(RequestSecurityToken request, string requestType);
    protected virtual RequestSecurityTokenResponse ReadResponse(Message response);
    protected static string GetRequestAction(string requestType, TrustVersion trustVersion);
    public virtual SecurityToken GetTokenFromResponse(RequestSecurityToken request, RequestSecurityTokenResponse response);
    internal static SecurityToken GetUseKeySecurityToken(UseKey useKey, string requestKeyType);
    internal static ProofKeyType GetKeyType(string keyType);
    internal static bool IsPsha1(string algorithm);
    internal static SecurityToken ComputeProofKey(RequestSecurityToken request, RequestSecurityTokenResponse response);
    internal static SecurityToken GetProofKey(RequestSecurityToken request, RequestSecurityTokenResponse response);
    public sealed virtual T GetProperty();
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual void Close();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual void Open();
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual RequestSecurityTokenResponse Cancel(RequestSecurityToken rst);
    public virtual SecurityToken Issue(RequestSecurityToken rst);
    public virtual SecurityToken Issue(RequestSecurityToken rst, RequestSecurityTokenResponse& rstr);
    public virtual RequestSecurityTokenResponse Renew(RequestSecurityToken rst);
    public virtual RequestSecurityTokenResponse Validate(RequestSecurityToken rst);
    public sealed virtual IAsyncResult BeginCancel(RequestSecurityToken rst, AsyncCallback callback, object state);
    public sealed virtual void EndCancel(IAsyncResult result, RequestSecurityTokenResponse& rstr);
    public sealed virtual IAsyncResult BeginIssue(RequestSecurityToken rst, AsyncCallback callback, object asyncState);
    public sealed virtual SecurityToken EndIssue(IAsyncResult result, RequestSecurityTokenResponse& rstr);
    public sealed virtual IAsyncResult BeginRenew(RequestSecurityToken rst, AsyncCallback callback, object state);
    public sealed virtual void EndRenew(IAsyncResult result, RequestSecurityTokenResponse& rstr);
    public sealed virtual IAsyncResult BeginValidate(RequestSecurityToken rst, AsyncCallback callback, object state);
    public sealed virtual void EndValidate(IAsyncResult result, RequestSecurityTokenResponse& rstr);
    public sealed virtual Message Cancel(Message message);
    public sealed virtual IAsyncResult BeginCancel(Message message, AsyncCallback callback, object asyncState);
    public sealed virtual Message EndCancel(IAsyncResult asyncResult);
    public sealed virtual Message Issue(Message message);
    public sealed virtual IAsyncResult BeginIssue(Message message, AsyncCallback callback, object asyncState);
    public sealed virtual Message EndIssue(IAsyncResult asyncResult);
    public sealed virtual Message Renew(Message message);
    public sealed virtual IAsyncResult BeginRenew(Message message, AsyncCallback callback, object asyncState);
    public sealed virtual Message EndRenew(IAsyncResult asyncResult);
    public sealed virtual Message Validate(Message message);
    public sealed virtual IAsyncResult BeginValidate(Message message, AsyncCallback callback, object asyncState);
    public sealed virtual Message EndValidate(IAsyncResult asyncResult);
}
[ComVisibleAttribute("False")]
public class System.ServiceModel.Security.WSTrustChannelFactory : ChannelFactory`1<IWSTrustChannelContract> {
    public TrustVersion TrustVersion { get; public set; }
    public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager { get; public set; }
    public SecurityTokenResolver SecurityTokenResolver { get; public set; }
    public SecurityTokenResolver UseKeyTokenResolver { get; public set; }
    public WSTrustRequestSerializer WSTrustRequestSerializer { get; public set; }
    public WSTrustResponseSerializer WSTrustResponseSerializer { get; public set; }
    public WSTrustChannelFactory(string endpointConfigurationName);
    public WSTrustChannelFactory(Binding binding);
    public WSTrustChannelFactory(ServiceEndpoint endpoint);
    public WSTrustChannelFactory(string endpointConfigurationName, EndpointAddress remoteAddress);
    public WSTrustChannelFactory(Binding binding, EndpointAddress remoteAddress);
    public WSTrustChannelFactory(Binding binding, string remoteAddress);
    public TrustVersion get_TrustVersion();
    public void set_TrustVersion(TrustVersion value);
    public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager();
    public void set_SecurityTokenHandlerCollectionManager(SecurityTokenHandlerCollectionManager value);
    public SecurityTokenResolver get_SecurityTokenResolver();
    public void set_SecurityTokenResolver(SecurityTokenResolver value);
    public SecurityTokenResolver get_UseKeyTokenResolver();
    public void set_UseKeyTokenResolver(SecurityTokenResolver value);
    public WSTrustRequestSerializer get_WSTrustRequestSerializer();
    public void set_WSTrustRequestSerializer(WSTrustRequestSerializer value);
    public WSTrustResponseSerializer get_WSTrustResponseSerializer();
    public void set_WSTrustResponseSerializer(WSTrustResponseSerializer value);
    public virtual IWSTrustChannelContract CreateChannel(EndpointAddress address, Uri via);
    protected virtual WSTrustChannel CreateTrustChannel(IWSTrustChannelContract innerChannel, TrustVersion trustVersion, WSTrustSerializationContext context, WSTrustRequestSerializer requestSerializer, WSTrustResponseSerializer responseSerializer);
    protected virtual WSTrustSerializationContext CreateSerializationContext();
}
internal class System.ServiceModel.Security.WSTrustDec2005 : WSTrustFeb2005 {
    public TrustDictionary SerializerDictionary { get; }
    public WSTrustDec2005(WSSecurityTokenSerializer tokenSerializer);
    public virtual TrustDictionary get_SerializerDictionary();
}
internal class System.ServiceModel.Security.WSTrustFeb2005 : WSTrust {
    public TrustDictionary SerializerDictionary { get; }
    public WSTrustFeb2005(WSSecurityTokenSerializer tokenSerializer);
    public virtual TrustDictionary get_SerializerDictionary();
}
public class System.ServiceModel.Security.WSTrustRequestBodyWriter : BodyWriter {
    public WSTrustRequestBodyWriter(RequestSecurityToken requestSecurityToken, WSTrustRequestSerializer serializer, WSTrustSerializationContext serializationContext);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Security.WSTrustRequestProcessingErrorEventArgs : EventArgs {
    public Exception Exception { get; }
    public string RequestType { get; }
    public WSTrustRequestProcessingErrorEventArgs(string requestType, Exception exception);
    public Exception get_Exception();
    public string get_RequestType();
}
public class System.ServiceModel.Security.WSTrustResponseBodyWriter : BodyWriter {
    public WSTrustResponseBodyWriter(RequestSecurityTokenResponse requestSecurityTokenResponse, WSTrustResponseSerializer serializer, WSTrustSerializationContext context);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
[ServiceBehaviorAttribute]
[AspNetCompatibilityRequirementsAttribute]
public class System.ServiceModel.Security.WSTrustServiceContract : object {
    public SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }
    public WSTrustServiceContract(SecurityTokenServiceConfiguration securityTokenServiceConfiguration);
    public void add_RequestFailed(EventHandler`1<WSTrustRequestProcessingErrorEventArgs> value);
    public void remove_RequestFailed(EventHandler`1<WSTrustRequestProcessingErrorEventArgs> value);
    protected virtual SecurityTokenResolver GetSecurityHeaderTokenResolver(RequestContext requestContext);
    protected virtual SecurityTokenResolver GetRstSecurityTokenResolver();
    protected virtual WSTrustSerializationContext CreateSerializationContext();
    protected virtual IAsyncResult BeginDispatchRequest(DispatchContext dispatchContext, AsyncCallback asyncCallback, object asyncState);
    protected virtual DispatchContext EndDispatchRequest(IAsyncResult ar);
    protected virtual void DispatchRequest(DispatchContext dispatchContext);
    protected virtual Message ProcessCore(Message requestMessage, WSTrustRequestSerializer requestSerializer, WSTrustResponseSerializer responseSerializer, string requestAction, string responseAction, string trustNamespace);
    protected virtual DispatchContext CreateDispatchContext(Message requestMessage, string requestAction, string responseAction, string trustNamespace, WSTrustRequestSerializer requestSerializer, WSTrustResponseSerializer responseSerializer, WSTrustSerializationContext serializationContext);
    protected virtual void ValidateDispatchContext(DispatchContext dispatchContext);
    protected virtual IAsyncResult BeginProcessCore(Message requestMessage, WSTrustRequestSerializer requestSerializer, WSTrustResponseSerializer responseSerializer, string requestAction, string responseAction, string trustNamespace, AsyncCallback callback, object state);
    protected virtual Message EndProcessCore(IAsyncResult ar, string requestAction, string responseAction, string trustNamespace);
    protected virtual bool HandleException(Exception ex, string trustNamespace, string action, EnvelopeVersion requestEnvelopeVersion);
    public sealed virtual Message ProcessTrust13Cancel(Message message);
    public sealed virtual Message ProcessTrust13Issue(Message message);
    public sealed virtual Message ProcessTrust13Renew(Message message);
    public sealed virtual Message ProcessTrust13Validate(Message message);
    public sealed virtual Message ProcessTrust13CancelResponse(Message message);
    public sealed virtual Message ProcessTrust13IssueResponse(Message message);
    public sealed virtual Message ProcessTrust13RenewResponse(Message message);
    public sealed virtual Message ProcessTrust13ValidateResponse(Message message);
    public sealed virtual Message ProcessTrustFeb2005Cancel(Message message);
    public sealed virtual Message ProcessTrustFeb2005Issue(Message message);
    public sealed virtual Message ProcessTrustFeb2005Renew(Message message);
    public sealed virtual Message ProcessTrustFeb2005Validate(Message message);
    public sealed virtual Message ProcessTrustFeb2005CancelResponse(Message message);
    public sealed virtual Message ProcessTrustFeb2005IssueResponse(Message message);
    public sealed virtual Message ProcessTrustFeb2005RenewResponse(Message message);
    public sealed virtual Message ProcessTrustFeb2005ValidateResponse(Message message);
    public SecurityTokenServiceConfiguration get_SecurityTokenServiceConfiguration();
    public sealed virtual IAsyncResult BeginTrust13Cancel(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13Cancel(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13Issue(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13Issue(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13Renew(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13Renew(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13Validate(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13Validate(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13CancelResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13CancelResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13IssueResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13IssueResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13RenewResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13RenewResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrust13ValidateResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrust13ValidateResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005Cancel(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005Cancel(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005Issue(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005Issue(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005Renew(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005Renew(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005Validate(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005Validate(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005CancelResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005CancelResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005IssueResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005IssueResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005RenewResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005RenewResponse(IAsyncResult ar);
    public sealed virtual IAsyncResult BeginTrustFeb2005ValidateResponse(Message request, AsyncCallback callback, object state);
    public sealed virtual Message EndTrustFeb2005ValidateResponse(IAsyncResult ar);
    public sealed virtual void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    public sealed virtual void ApplyClientBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    public sealed virtual void ApplyDispatchBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, DispatchRuntime dispatchRuntime);
    public sealed virtual void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
    public virtual void ExportContract(WsdlExporter exporter, WsdlContractConversionContext context);
    public virtual void ExportEndpoint(WsdlExporter exporter, WsdlEndpointConversionContext context);
    protected virtual void IncludeNamespace(WsdlEndpointConversionContext context, string prefix, string ns);
    protected virtual void ImportSchema(WsdlExporter exporter, WsdlEndpointConversionContext context, string ns);
    protected virtual void FixMessageElement(ServiceDescription serviceDescription, PortType portType, WsdlEndpointConversionContext context, string operationName, XmlQualifiedName inputMessageElement, XmlQualifiedName outputMessageElement);
}
internal static class System.ServiceModel.Security.WSTrustServiceContractConstants : object {
    public static string ServiceBehaviorName;
    public static string Namespace;
}
public class System.ServiceModel.Security.WSTrustServiceHost : ServiceHost {
    public WSTrustServiceContract ServiceContract { get; }
    public SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }
    public WSTrustServiceHost(SecurityTokenServiceConfiguration securityTokenServiceConfiguration, Uri[] baseAddresses);
    public WSTrustServiceHost(WSTrustServiceContract serviceContract, Uri[] baseAddresses);
    public WSTrustServiceContract get_ServiceContract();
    public SecurityTokenServiceConfiguration get_SecurityTokenServiceConfiguration();
    protected virtual void ConfigureMetadata();
    protected virtual void ApplyConfiguration();
    protected virtual void InitializeRuntime();
    protected virtual void UpdateServiceConfiguration();
}
internal abstract class System.ServiceModel.Security.WSUtilitySpecificationVersion : object {
    internal static String[] AcceptedDateTimeFormats;
    public static WSUtilitySpecificationVersion Default { get; }
    internal XmlDictionaryString NamespaceUri { get; }
    public static WSUtilitySpecificationVersion OneDotZero { get; }
    internal WSUtilitySpecificationVersion(XmlDictionaryString namespaceUri);
    private static WSUtilitySpecificationVersion();
    public static WSUtilitySpecificationVersion get_Default();
    internal XmlDictionaryString get_NamespaceUri();
    public static WSUtilitySpecificationVersion get_OneDotZero();
    internal abstract virtual bool IsReaderAtTimestamp(XmlDictionaryReader reader);
    internal abstract virtual SecurityTimestamp ReadTimestamp(XmlDictionaryReader reader, string digestAlgorithm, SignatureResourcePool resourcePool);
    internal abstract virtual void WriteTimestamp(XmlDictionaryWriter writer, SecurityTimestamp timestamp);
    internal abstract virtual void WriteTimestampCanonicalForm(Stream stream, SecurityTimestamp timestamp, Byte[] buffer);
}
public class System.ServiceModel.Security.X509CertificateInitiatorClientCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    public X509Certificate2 Certificate { get; public set; }
    internal X509CertificateInitiatorClientCredential(X509CertificateInitiatorClientCredential other);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.X509CertificateInitiatorServiceCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    public X509Certificate2 Certificate { get; public set; }
    public X509ClientCertificateAuthentication Authentication { get; }
    internal X509CertificateInitiatorServiceCredential(X509CertificateInitiatorServiceCredential other);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public X509ClientCertificateAuthentication get_Authentication();
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.X509CertificateRecipientClientCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    public X509Certificate2 DefaultCertificate { get; public set; }
    public Dictionary`2<Uri, X509Certificate2> ScopedCertificates { get; }
    public X509ServiceCertificateAuthentication Authentication { get; }
    public X509ServiceCertificateAuthentication SslCertificateAuthentication { get; public set; }
    internal X509CertificateRecipientClientCredential(X509CertificateRecipientClientCredential other);
    public X509Certificate2 get_DefaultCertificate();
    public void set_DefaultCertificate(X509Certificate2 value);
    public Dictionary`2<Uri, X509Certificate2> get_ScopedCertificates();
    public X509ServiceCertificateAuthentication get_Authentication();
    public X509ServiceCertificateAuthentication get_SslCertificateAuthentication();
    public void set_SslCertificateAuthentication(X509ServiceCertificateAuthentication value);
    public void SetDefaultCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetDefaultCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    public void SetScopedCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName, Uri targetService);
    public void SetScopedCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue, Uri targetService);
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.X509CertificateRecipientServiceCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    public X509Certificate2 Certificate { get; public set; }
    internal X509CertificateRecipientServiceCredential(X509CertificateRecipientServiceCredential other);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public void SetCertificate(string subjectName);
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    internal void MakeReadOnly();
}
internal static class System.ServiceModel.Security.X509CertificateValidationModeHelper : object {
    public static bool IsDefined(X509CertificateValidationMode validationMode);
    internal static void Validate(X509CertificateValidationMode value);
}
public class System.ServiceModel.Security.X509ClientCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    internal static bool DefaultMapCertificateToWindowsAccount;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    public bool MapClientCertificateToWindowsAccount { get; public set; }
    public bool IncludeWindowsGroups { get; public set; }
    internal X509ClientCertificateAuthentication(X509ClientCertificateAuthentication other);
    internal static X509CertificateValidator get_DefaultCertificateValidator();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    public bool get_MapClientCertificateToWindowsAccount();
    public void set_MapClientCertificateToWindowsAccount(bool value);
    public bool get_IncludeWindowsGroups();
    public void set_IncludeWindowsGroups(bool value);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.X509PeerCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    internal X509PeerCertificateAuthentication(X509PeerCertificateAuthentication other);
    internal static X509CertificateValidator get_DefaultCertificateValidator();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    internal bool TryGetCertificateValidator(X509CertificateValidator& validator);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
}
public class System.ServiceModel.Security.X509ServiceCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    internal X509ServiceCertificateAuthentication(X509ServiceCertificateAuthentication other);
    internal static X509CertificateValidator get_DefaultCertificateValidator();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    internal bool TryGetCertificateValidator(X509CertificateValidator& validator);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
}
internal static class System.ServiceModel.Security.XmlHelper : object {
    internal static void AddNamespaceDeclaration(XmlDictionaryWriter writer, string prefix, XmlDictionaryString ns);
    internal static string EnsureNamespaceDefined(XmlDictionaryWriter writer, XmlDictionaryString ns, string defaultPrefix);
    internal static XmlQualifiedName GetAttributeValueAsQName(XmlReader reader, string attributeName);
    internal static XmlElement GetChildElement(XmlElement parent);
    internal static XmlElement GetChildElement(XmlElement parent, string childLocalName, string childNamespace);
    internal static XmlQualifiedName GetValueAsQName(XmlReader reader, string value);
    internal static string GetWhiteSpace(XmlReader reader);
    internal static bool IsWhitespaceOrComment(XmlReader reader);
    internal static void OnChildNodeTypeMissing(string parentName, XmlNodeType expectedNodeType);
    internal static void OnChildNodeTypeMissing(XmlElement parent, XmlNodeType expectedNodeType);
    internal static void OnEmptyElementError(XmlReader r);
    internal static void OnEmptyElementError(XmlElement e);
    internal static void OnEOF();
    internal static void OnNamespaceMissing(string prefix);
    internal static void OnRequiredAttributeMissing(string attrName, string elementName);
    internal static void OnRequiredElementMissing(string elementName, string elementNamespace);
    internal static void OnUnexpectedChildNodeError(string parentName, XmlReader r);
    internal static void OnUnexpectedChildNodeError(XmlElement parent, XmlNode n);
    internal static string ReadEmptyElementAndRequiredAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString namespaceUri, XmlDictionaryString attributeName, String& prefix);
    internal static string GetRequiredNonEmptyAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static Byte[] GetRequiredBase64Attribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static string ReadTextElementAsTrimmedString(XmlElement element);
    internal static void SplitIntoPrefixAndName(string qName, String& prefix, String& name);
    internal static void ValidateIdPrefix(string idPrefix);
    internal static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void WriteAttributeStringAsUniqueId(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlWriter writer, string localName, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementContentAsInt64(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, long value);
    public static long ReadElementContentAsInt64(XmlDictionaryReader reader);
    public static void WriteStringAsUniqueId(XmlDictionaryWriter writer, UniqueId id);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader);
    public static UniqueId ReadTextElementAsUniqueId(XmlElement element);
}
internal class System.ServiceModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public List`1<XmlDictionaryString> SecurityAlgorithmDictionaryStrings;
    public SecurityAlgorithmDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecurityAlgorithmDictionaryString();
}
internal static class System.ServiceModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.ServiceModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.ServiceModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityJan2004Strings : object {
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
public enum System.ServiceModel.SecurityMode : Enum {
    public int value__;
    public static SecurityMode None;
    public static SecurityMode Transport;
    public static SecurityMode Message;
    public static SecurityMode TransportWithMessageCredential;
}
internal static class System.ServiceModel.SecurityModeHelper : object {
    internal static bool IsDefined(SecurityMode value);
    internal static SecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
internal class System.ServiceModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public SecurityXXX2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityXXX2005Strings : object {
    public static string EncryptedHeader;
    public static string Namespace;
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
internal class System.ServiceModel.SerializationDictionary : object {
    public XmlDictionaryString XmlSchemaInstanceNamespace;
    public XmlDictionaryString XmlSchemaNamespace;
    public XmlDictionaryString Nil;
    public XmlDictionaryString Type;
    public XmlDictionaryString Char;
    public XmlDictionaryString Boolean;
    public XmlDictionaryString Byte;
    public XmlDictionaryString UnsignedByte;
    public XmlDictionaryString Short;
    public XmlDictionaryString UnsignedShort;
    public XmlDictionaryString Int;
    public XmlDictionaryString UnsignedInt;
    public XmlDictionaryString Long;
    public XmlDictionaryString UnsignedLong;
    public XmlDictionaryString Float;
    public XmlDictionaryString Double;
    public XmlDictionaryString Decimal;
    public XmlDictionaryString DateTime;
    public XmlDictionaryString String;
    public XmlDictionaryString Base64Binary;
    public XmlDictionaryString AnyType;
    public XmlDictionaryString Duration;
    public XmlDictionaryString Guid;
    public XmlDictionaryString AnyURI;
    public XmlDictionaryString QName;
    public XmlDictionaryString Time;
    public XmlDictionaryString Date;
    public XmlDictionaryString HexBinary;
    public XmlDictionaryString GYearMonth;
    public XmlDictionaryString GYear;
    public XmlDictionaryString GMonthDay;
    public XmlDictionaryString GDay;
    public XmlDictionaryString GMonth;
    public XmlDictionaryString Integer;
    public XmlDictionaryString PositiveInteger;
    public XmlDictionaryString NegativeInteger;
    public XmlDictionaryString NonPositiveInteger;
    public XmlDictionaryString NonNegativeInteger;
    public XmlDictionaryString NormalizedString;
    public SerializationDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SerializationStrings : object {
    public static string XmlSchemaInstanceNamespace;
    public static string XmlSchemaNamespace;
    public static string Nil;
    public static string Type;
    public static string Char;
    public static string Boolean;
    public static string Byte;
    public static string UnsignedByte;
    public static string Short;
    public static string UnsignedShort;
    public static string Int;
    public static string UnsignedInt;
    public static string Long;
    public static string UnsignedLong;
    public static string Float;
    public static string Double;
    public static string Decimal;
    public static string DateTime;
    public static string String;
    public static string Base64Binary;
    public static string AnyType;
    public static string Duration;
    public static string Guid;
    public static string AnyURI;
    public static string QName;
    public static string Time;
    public static string Date;
    public static string HexBinary;
    public static string GYearMonth;
    public static string GYear;
    public static string GMonthDay;
    public static string GDay;
    public static string GMonth;
    public static string Integer;
    public static string PositiveInteger;
    public static string NegativeInteger;
    public static string NonPositiveInteger;
    public static string NonNegativeInteger;
    public static string NormalizedString;
}
public class System.ServiceModel.ServerTooBusyException : CommunicationException {
    public ServerTooBusyException(string message);
    public ServerTooBusyException(string message, Exception innerException);
    protected ServerTooBusyException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.ServiceActivationException : CommunicationException {
    public ServiceActivationException(string message);
    public ServiceActivationException(string message, Exception innerException);
    protected ServiceActivationException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.ServiceAuthenticationManager : object {
    public virtual ReadOnlyCollection`1<IAuthorizationPolicy> Authenticate(ReadOnlyCollection`1<IAuthorizationPolicy> authPolicy, Uri listenUri, Message& message);
}
internal class System.ServiceModel.ServiceAuthenticationManagerWrapper : ServiceAuthenticationManager {
    internal ServiceAuthenticationManagerWrapper(ServiceAuthenticationManager wrappedServiceAuthManager, String[] actionUriFilter);
    public virtual ReadOnlyCollection`1<IAuthorizationPolicy> Authenticate(ReadOnlyCollection`1<IAuthorizationPolicy> authPolicy, Uri listenUri, Message& message);
}
public class System.ServiceModel.ServiceAuthorizationManager : object {
    public virtual bool CheckAccess(OperationContext operationContext, Message& message);
    public virtual bool CheckAccess(OperationContext operationContext);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> GetAuthorizationPolicies(OperationContext operationContext);
    protected virtual bool CheckAccessCore(OperationContext operationContext);
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.ServiceBehaviorAttribute : Attribute {
    internal static IsolationLevel DefaultIsolationLevel;
    [DefaultValueAttribute("")]
public string Name { get; public set; }
    [DefaultValueAttribute("")]
public string Namespace { get; public set; }
    unknown IInstanceProvider InstanceProvider {internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AddressFilterMode AddressFilterMode { get; public set; }
    [DefaultValueAttribute("True")]
public bool AutomaticSessionShutdown { get; public set; }
    [DefaultValueAttribute("")]
public string ConfigurationName { get; public set; }
    public IsolationLevel TransactionIsolationLevel { get; public set; }
    internal bool IsolationLevelSet { get; }
    [DefaultValueAttribute("False")]
public bool IncludeExceptionDetailInFaults { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ConcurrencyMode ConcurrencyMode { get; public set; }
    [DefaultValueAttribute("False")]
public bool EnsureOrderedDispatch { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public InstanceContextMode InstanceContextMode { get; public set; }
    public bool ReleaseServiceInstanceOnTransactionComplete { get; public set; }
    internal bool ReleaseServiceInstanceOnTransactionCompleteSet { get; }
    public bool TransactionAutoCompleteOnSessionClose { get; public set; }
    internal bool TransactionAutoCompleteOnSessionCloseSet { get; }
    public string TransactionTimeout { get; public set; }
    internal TimeSpan TransactionTimeoutTimespan { get; }
    internal bool TransactionTimeoutSet { get; }
    [DefaultValueAttribute("True")]
public bool ValidateMustUnderstand { get; public set; }
    [DefaultValueAttribute("False")]
public bool IgnoreExtensionDataObject { get; public set; }
    [DefaultValueAttribute("2147483647")]
public int MaxItemsInObjectGraph { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseSynchronizationContext { get; public set; }
    private static ServiceBehaviorAttribute();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    internal void set_InstanceProvider(IInstanceProvider value);
    public AddressFilterMode get_AddressFilterMode();
    public void set_AddressFilterMode(AddressFilterMode value);
    public bool get_AutomaticSessionShutdown();
    public void set_AutomaticSessionShutdown(bool value);
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public IsolationLevel get_TransactionIsolationLevel();
    public void set_TransactionIsolationLevel(IsolationLevel value);
    public bool ShouldSerializeTransactionIsolationLevel();
    internal bool get_IsolationLevelSet();
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public bool get_EnsureOrderedDispatch();
    public void set_EnsureOrderedDispatch(bool value);
    public InstanceContextMode get_InstanceContextMode();
    public void set_InstanceContextMode(InstanceContextMode value);
    public bool get_ReleaseServiceInstanceOnTransactionComplete();
    public void set_ReleaseServiceInstanceOnTransactionComplete(bool value);
    public bool ShouldSerializeConfigurationName();
    public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();
    internal bool get_ReleaseServiceInstanceOnTransactionCompleteSet();
    public bool get_TransactionAutoCompleteOnSessionClose();
    public void set_TransactionAutoCompleteOnSessionClose(bool value);
    public bool ShouldSerializeTransactionAutoCompleteOnSessionClose();
    internal bool get_TransactionAutoCompleteOnSessionCloseSet();
    public string get_TransactionTimeout();
    public void set_TransactionTimeout(string value);
    public bool ShouldSerializeTransactionTimeout();
    internal TimeSpan get_TransactionTimeoutTimespan();
    internal bool get_TransactionTimeoutSet();
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    public bool get_UseSynchronizationContext();
    public void set_UseSynchronizationContext(bool value);
    public object GetWellKnownSingleton();
    public void SetWellKnownSingleton(object value);
    internal object GetHiddenSingleton();
    internal void SetHiddenSingleton(object value);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal class System.ServiceModel.ServiceChannelManager : LifetimeManager {
    public int ActivityCount { get; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public bool IsBusy { get; }
    public ServiceChannelManager(InstanceContext instanceContext);
    public ServiceChannelManager(InstanceContext instanceContext, InstanceContextEmptyCallback emptyCallback);
    public int get_ActivityCount();
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    public bool get_IsBusy();
    public void AddIncomingChannel(IChannel channel);
    public IAsyncResult BeginCloseInput(TimeSpan timeout, AsyncCallback callback, object state);
    public void CloseInput(TimeSpan timeout);
    public void DecrementActivityCount();
    public void EndCloseInput(IAsyncResult result);
    public void IncrementActivityCount();
    protected virtual void IncrementBusyCount();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEmpty();
    public bool RemoveChannel(IChannel channel);
    public IChannel[] SnapshotChannels();
}
public class System.ServiceModel.ServiceConfiguration : object {
    public ServiceDescription Description { get; }
    public ServiceAuthenticationBehavior Authentication { get; }
    public ServiceAuthorizationBehavior Authorization { get; }
    public ServiceCredentials Credentials { get; }
    public ReadOnlyCollection`1<Uri> BaseAddresses { get; }
    public TimeSpan OpenTimeout { get; public set; }
    public TimeSpan CloseTimeout { get; public set; }
    public bool UseIdentityConfiguration { get; public set; }
    public IdentityConfiguration IdentityConfiguration { get; public set; }
    internal ServiceConfiguration(ServiceHost host);
    public ServiceDescription get_Description();
    public ServiceAuthenticationBehavior get_Authentication();
    public ServiceAuthorizationBehavior get_Authorization();
    public ServiceCredentials get_Credentials();
    public ReadOnlyCollection`1<Uri> get_BaseAddresses();
    public TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public bool get_UseIdentityConfiguration();
    public void set_UseIdentityConfiguration(bool value);
    public IdentityConfiguration get_IdentityConfiguration();
    public void set_IdentityConfiguration(IdentityConfiguration value);
    public void AddServiceEndpoint(ServiceEndpoint endpoint);
    public ServiceEndpoint AddServiceEndpoint(Type contractType, Binding binding, string address);
    public ServiceEndpoint AddServiceEndpoint(Type contractType, Binding binding, Uri address);
    public ServiceEndpoint AddServiceEndpoint(Type contractType, Binding binding, string address, Uri listenUri);
    public ServiceEndpoint AddServiceEndpoint(Type contractType, Binding binding, Uri address, Uri listenUri);
    public void SetEndpointAddress(ServiceEndpoint endpoint, string relativeAddress);
    public Collection`1<ServiceEndpoint> EnableProtocol(Binding protocol);
    public void LoadFromConfiguration();
    public void LoadFromConfiguration(Configuration configuration);
}
[AttributeUsageAttribute("1028")]
public class System.ServiceModel.ServiceContractAttribute : Attribute {
    public string ConfigurationName { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public SessionMode SessionMode { get; public set; }
    public Type CallbackContract { get; public set; }
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    public Type get_CallbackContract();
    public void set_CallbackContract(Type value);
}
internal static class System.ServiceModel.ServiceDefaults : object {
    internal static string ServiceHostCloseTimeoutString;
    internal static string CloseTimeoutString;
    internal static string OpenTimeoutString;
    internal static string ReceiveTimeoutString;
    internal static string SendTimeoutString;
    internal static string TransactionTimeoutString;
    internal static TimeSpan ServiceHostCloseTimeout { get; }
    internal static TimeSpan CloseTimeout { get; }
    internal static TimeSpan OpenTimeout { get; }
    internal static TimeSpan ReceiveTimeout { get; }
    internal static TimeSpan SendTimeout { get; }
    internal static TimeSpan TransactionTimeout { get; }
    internal static TimeSpan get_ServiceHostCloseTimeout();
    internal static TimeSpan get_CloseTimeout();
    internal static TimeSpan get_OpenTimeout();
    internal static TimeSpan get_ReceiveTimeout();
    internal static TimeSpan get_SendTimeout();
    internal static TimeSpan get_TransactionTimeout();
}
internal class System.ServiceModel.ServiceEndpointTrait`1 : EndpointTrait`1<TChannel> {
    public ServiceEndpointTrait`1(ServiceEndpoint endpoint, InstanceContext callbackInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ChannelFactory`1<TChannel> CreateChannelFactory();
}
public class System.ServiceModel.ServiceHost : ServiceHostBase {
    public object SingletonInstance { get; }
    internal object DisposableInstance { get; }
    internal string CloseActivityName { get; }
    internal string OpenActivityName { get; }
    public ServiceHost(Type serviceType, Uri[] baseAddresses);
    public ServiceHost(object singletonInstance, Uri[] baseAddresses);
    public object get_SingletonInstance();
    internal virtual object get_DisposableInstance();
    public ServiceEndpoint AddServiceEndpoint(Type implementedContract, Binding binding, string address);
    public ServiceEndpoint AddServiceEndpoint(Type implementedContract, Binding binding, string address, Uri listenUri);
    public ServiceEndpoint AddServiceEndpoint(Type implementedContract, Binding binding, Uri address);
    public ServiceEndpoint AddServiceEndpoint(Type implementedContract, Binding binding, Uri address, Uri listenUri);
    internal virtual void AddDefaultEndpoints(Binding defaultBinding, List`1<ServiceEndpoint> defaultEndpoints);
    protected virtual void ApplyConfiguration();
    internal void LoadFromConfiguration();
    internal void LoadFromConfiguration(Configuration configuration);
    internal virtual string get_CloseActivityName();
    internal virtual string get_OpenActivityName();
    protected virtual ServiceDescription CreateDescription(IDictionary`2& implementedContracts);
    protected void InitializeDescription(object singletonInstance, UriSchemeKeyedCollection baseAddresses);
    protected void InitializeDescription(Type serviceType, UriSchemeKeyedCollection baseAddresses);
    protected virtual void OnClosed();
}
public abstract class System.ServiceModel.ServiceHostBase : CommunicationObject {
    internal static Uri EmptyUri;
    internal EventTraceActivity EventTraceActivity { get; }
    public ServiceAuthorizationBehavior Authorization { get; }
    public ServiceAuthenticationBehavior Authentication { get; }
    public ReadOnlyCollection`1<Uri> BaseAddresses { get; }
    public ChannelDispatcherCollection ChannelDispatchers { get; }
    public TimeSpan CloseTimeout { get; public set; }
    internal ServicePerformanceCountersBase Counters { get; internal set; }
    internal DefaultPerformanceCounters DefaultCounters { get; internal set; }
    public ServiceCredentials Credentials { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public ServiceDescription Description { get; }
    public IExtensionCollection`1<ServiceHostBase> Extensions { get; }
    protected internal IDictionary`2<string, ContractDescription> ImplementedContracts { get; }
    internal UriSchemeKeyedCollection InternalBaseAddresses { get; }
    public int ManualFlowControlLimit { get; public set; }
    public TimeSpan OpenTimeout { get; public set; }
    internal ServiceThrottle ServiceThrottle { get; }
    internal object DisposableInstance { get; }
    internal Dictionary`2<ListenUriInfo, Collection`1<ServiceEndpoint>> EndpointsByListenUriInfo { get; }
    internal int BusyCount { get; }
    private static ServiceHostBase();
    [CompilerGeneratedAttribute]
internal void add_BusyCountIncremented(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BusyCountIncremented(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    internal EventTraceActivity get_EventTraceActivity();
    public ServiceAuthorizationBehavior get_Authorization();
    public ServiceAuthenticationBehavior get_Authentication();
    public ReadOnlyCollection`1<Uri> get_BaseAddresses();
    public ChannelDispatcherCollection get_ChannelDispatchers();
    public TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    internal ServicePerformanceCountersBase get_Counters();
    internal void set_Counters(ServicePerformanceCountersBase value);
    internal DefaultPerformanceCounters get_DefaultCounters();
    internal void set_DefaultCounters(DefaultPerformanceCounters value);
    public ServiceCredentials get_Credentials();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public ServiceDescription get_Description();
    public sealed virtual IExtensionCollection`1<ServiceHostBase> get_Extensions();
    protected internal IDictionary`2<string, ContractDescription> get_ImplementedContracts();
    internal UriSchemeKeyedCollection get_InternalBaseAddresses();
    public int get_ManualFlowControlLimit();
    public void set_ManualFlowControlLimit(int value);
    public TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    internal ServiceThrottle get_ServiceThrottle();
    internal virtual object get_DisposableInstance();
    internal Dictionary`2<ListenUriInfo, Collection`1<ServiceEndpoint>> get_EndpointsByListenUriInfo();
    protected void AddBaseAddress(Uri baseAddress);
    public ServiceEndpoint AddServiceEndpoint(string implementedContract, Binding binding, string address);
    public ServiceEndpoint AddServiceEndpoint(string implementedContract, Binding binding, string address, Uri listenUri);
    public ServiceEndpoint AddServiceEndpoint(string implementedContract, Binding binding, Uri address);
    public ServiceEndpoint AddServiceEndpoint(string implementedContract, Binding binding, Uri address, Uri listenUri);
    public virtual void AddServiceEndpoint(ServiceEndpoint endpoint);
    public void SetEndpointAddress(ServiceEndpoint endpoint, string relativeAddress);
    internal Uri MakeAbsoluteUri(Uri relativeOrAbsoluteUri, Binding binding);
    internal static Uri MakeAbsoluteUri(Uri relativeOrAbsoluteUri, Binding binding, UriSchemeKeyedCollection baseAddresses);
    protected virtual void ApplyConfiguration();
    internal void EnsureAuthenticationAuthorizationDebug(ServiceDescription description);
    public virtual ReadOnlyCollection`1<ServiceEndpoint> AddDefaultEndpoints();
    internal virtual void AddDefaultEndpoints(Binding defaultBinding, List`1<ServiceEndpoint> defaultEndpoints);
    internal virtual void BindInstance(InstanceContext instance);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual ServiceDescription CreateDescription(IDictionary`2& implementedContracts);
    protected virtual void InitializeRuntime();
    internal virtual void AfterInitializeRuntime(TimeSpan timeout);
    internal virtual IAsyncResult BeginAfterInitializeRuntime(TimeSpan timeout, AsyncCallback callback, object state);
    internal virtual void EndAfterInitializeRuntime(IAsyncResult result);
    internal void FaultInternal();
    internal string GetBaseAddressSchemes();
    internal static string GetBaseAddressSchemes(UriSchemeKeyedCollection uriSchemeKeyedCollection);
    internal BindingParameterCollection GetBindingParameters();
    internal BindingParameterCollection GetBindingParameters(ServiceEndpoint inputEndpoint);
    internal BindingParameterCollection GetBindingParameters(Collection`1<ServiceEndpoint> endpoints);
    internal ReadOnlyCollection`1<InstanceContext> GetInstanceContexts();
    internal virtual IContractResolver GetContractResolver(IDictionary`2<string, ContractDescription> implementedContracts);
    internal static Uri GetUri(Uri baseUri, Uri relativeUri);
    internal static Uri GetUri(Uri baseUri, string path);
    internal Uri GetVia(string scheme, Uri address);
    internal static Uri GetVia(string scheme, Uri address, UriSchemeKeyedCollection baseAddresses);
    public int IncrementManualFlowControlLimit(int incrementBy);
    protected void InitializeDescription(UriSchemeKeyedCollection baseAddresses);
    protected void LoadConfigurationSection(ServiceElement serviceSection);
    internal void LoadConfigurationSectionHelper(Uri baseAddress);
    protected virtual void OnAbort();
    internal void OnAddChannelDispatcher(ChannelDispatcherBase channelDispatcher);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    internal void OnRemoveChannelDispatcher(ChannelDispatcherBase channelDispatcher);
    internal void RaiseUnknownMessageReceived(Message message);
    protected void ReleasePerformanceCounters();
    internal virtual void UnbindInstance(InstanceContext instance);
    internal void IncrementBusyCount();
    internal void DecrementBusyCount();
    internal int get_BusyCount();
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.ServiceKnownTypeAttribute : Attribute {
    public Type DeclaringType { get; }
    public string MethodName { get; }
    public Type Type { get; }
    public ServiceKnownTypeAttribute(Type type);
    public ServiceKnownTypeAttribute(string methodName);
    public ServiceKnownTypeAttribute(string methodName, Type declaringType);
    public Type get_DeclaringType();
    public string get_MethodName();
    public Type get_Type();
}
[EventDataAttribute]
internal class System.ServiceModel.ServiceKPI : ValueType {
    [CompilerGeneratedAttribute]
private string <ServiceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Endpoints>k__BackingField;
    [EventFieldAttribute]
public string ServiceId { get; public set; }
    public string HostType { get; public set; }
    public string Endpoints { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServiceId();
    [CompilerGeneratedAttribute]
public void set_ServiceId(string value);
    [CompilerGeneratedAttribute]
public string get_HostType();
    [CompilerGeneratedAttribute]
public void set_HostType(string value);
    [CompilerGeneratedAttribute]
public string get_Endpoints();
    [CompilerGeneratedAttribute]
public void set_Endpoints(string value);
}
internal static class System.ServiceModel.ServiceModelAppSettings : object {
    internal static string HttpTransportPerFactoryConnectionPoolString;
    internal static string EnsureUniquePerformanceCounterInstanceNamesString;
    internal static string UseConfiguredTransportSecurityHeaderLayoutString;
    internal static string UseBestMatchNamedPipeUriString;
    internal static bool HttpTransportPerFactoryConnectionPool { get; }
    internal static bool EnsureUniquePerformanceCounterInstanceNames { get; }
    internal static bool UseConfiguredTransportSecurityHeaderLayout { get; }
    internal static bool UseBestMatchNamedPipeUri { get; }
    private static ServiceModelAppSettings();
    internal static bool get_HttpTransportPerFactoryConnectionPool();
    internal static bool get_EnsureUniquePerformanceCounterInstanceNames();
    internal static bool get_UseConfiguredTransportSecurityHeaderLayout();
    internal static bool get_UseBestMatchNamedPipeUri();
}
internal static class System.ServiceModel.ServiceModelAttributeTargets : object {
    public static AttributeTargets ServiceContract;
    public static AttributeTargets OperationContract;
    public static AttributeTargets MessageContract;
    public static AttributeTargets MessageMember;
    public static AttributeTargets Parameter;
    public static AttributeTargets ServiceBehavior;
    public static AttributeTargets CallbackBehavior;
    public static AttributeTargets ClientBehavior;
    public static AttributeTargets ContractBehavior;
    public static AttributeTargets OperationBehavior;
}
internal class System.ServiceModel.ServiceModelDictionary : object {
    public static ServiceModelDictionary Version1;
    public static ServiceModelDictionary CurrentVersion { get; }
    public ServiceModelDictionary(ServiceModelStrings strings);
    private static ServiceModelDictionary();
    public static ServiceModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.ServiceModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.ServiceModelStringsVersion1 : ServiceModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public static string String279;
    public static string String280;
    public static string String281;
    public static string String282;
    public static string String283;
    public static string String284;
    public static string String285;
    public static string String286;
    public static string String287;
    public static string String288;
    public static string String289;
    public static string String290;
    public static string String291;
    public static string String292;
    public static string String293;
    public static string String294;
    public static string String295;
    public static string String296;
    public static string String297;
    public static string String298;
    public static string String299;
    public static string String300;
    public static string String301;
    public static string String302;
    public static string String303;
    public static string String304;
    public static string String305;
    public static string String306;
    public static string String307;
    public static string String308;
    public static string String309;
    public static string String310;
    public static string String311;
    public static string String312;
    public static string String313;
    public static string String314;
    public static string String315;
    public static string String316;
    public static string String317;
    public static string String318;
    public static string String319;
    public static string String320;
    public static string String321;
    public static string String322;
    public static string String323;
    public static string String324;
    public static string String325;
    public static string String326;
    public static string String327;
    public static string String328;
    public static string String329;
    public static string String330;
    public static string String331;
    public static string String332;
    public static string String333;
    public static string String334;
    public static string String335;
    public static string String336;
    public static string String337;
    public static string String338;
    public static string String339;
    public static string String340;
    public static string String341;
    public static string String342;
    public static string String343;
    public static string String344;
    public static string String345;
    public static string String346;
    public static string String347;
    public static string String348;
    public static string String349;
    public static string String350;
    public static string String351;
    public static string String352;
    public static string String353;
    public static string String354;
    public static string String355;
    public static string String356;
    public static string String357;
    public static string String358;
    public static string String359;
    public static string String360;
    public static string String361;
    public static string String362;
    public static string String363;
    public static string String364;
    public static string String365;
    public static string String366;
    public static string String367;
    public static string String368;
    public static string String369;
    public static string String370;
    public static string String371;
    public static string String372;
    public static string String373;
    public static string String374;
    public static string String375;
    public static string String376;
    public static string String377;
    public static string String378;
    public static string String379;
    public static string String380;
    public static string String381;
    public static string String382;
    public static string String383;
    public static string String384;
    public static string String385;
    public static string String386;
    public static string String387;
    public static string String388;
    public static string String389;
    public static string String390;
    public static string String391;
    public static string String392;
    public static string String393;
    public static string String394;
    public static string String395;
    public static string String396;
    public static string String397;
    public static string String398;
    public static string String399;
    public static string String400;
    public static string String401;
    public static string String402;
    public static string String403;
    public static string String404;
    public static string String405;
    public static string String406;
    public static string String407;
    public static string String408;
    public static string String409;
    public static string String410;
    public static string String411;
    public static string String412;
    public static string String413;
    public static string String414;
    public static string String415;
    public static string String416;
    public static string String417;
    public static string String418;
    public static string String419;
    public static string String420;
    public static string String421;
    public static string String422;
    public static string String423;
    public static string String424;
    public static string String425;
    public static string String426;
    public static string String427;
    public static string String428;
    public static string String429;
    public static string String430;
    public static string String431;
    public static string String432;
    public static string String433;
    public static string String434;
    public static string String435;
    public static string String436;
    public static string String437;
    public static string String438;
    public static string String439;
    public static string String440;
    public static string String441;
    public static string String442;
    public static string String443;
    public static string String444;
    public static string String445;
    public static string String446;
    public static string String447;
    public static string String448;
    public static string String449;
    public static string String450;
    public static string String451;
    public static string String452;
    public static string String453;
    public static string String454;
    public static string String455;
    public static string String456;
    public static string String457;
    public static string String458;
    public static string String459;
    public static string String460;
    public static string String461;
    public static string String462;
    public static string String463;
    public static string String464;
    public static string String465;
    public static string String466;
    public static string String467;
    public static string String468;
    public static string String469;
    public static string String470;
    public static string String471;
    public static string String472;
    public static string String473;
    public static string String474;
    public static string String475;
    public static string String476;
    public static string String477;
    public static string String478;
    public static string String479;
    public static string String480;
    public static string String481;
    public static string String482;
    public static string String483;
    public static string String484;
    public static string String485;
    public static string String486;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
public class System.ServiceModel.ServiceSecurityContext : object {
    public static ServiceSecurityContext Anonymous { get; }
    public static ServiceSecurityContext Current { get; }
    public bool IsAnonymous { get; }
    internal Claim IdentityClaim { get; }
    public IIdentity PrimaryIdentity { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; public set; }
    public AuthorizationContext AuthorizationContext { get; }
    public ServiceSecurityContext(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public ServiceSecurityContext(AuthorizationContext authorizationContext);
    public ServiceSecurityContext(AuthorizationContext authorizationContext, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static ServiceSecurityContext get_Anonymous();
    public static ServiceSecurityContext get_Current();
    public bool get_IsAnonymous();
    internal Claim get_IdentityClaim();
    public IIdentity get_PrimaryIdentity();
    public WindowsIdentity get_WindowsIdentity();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    public void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public AuthorizationContext get_AuthorizationContext();
}
public enum System.ServiceModel.SessionMode : Enum {
    public int value__;
    public static SessionMode Allowed;
    public static SessionMode Required;
    public static SessionMode NotAllowed;
}
internal static class System.ServiceModel.SessionModeHelper : object {
    public static bool IsDefined(SessionMode sessionMode);
}
public class System.ServiceModel.SpnEndpointIdentity : EndpointIdentity {
    public static TimeSpan SpnLookupTime { get; public set; }
    public SpnEndpointIdentity(string spnName);
    public SpnEndpointIdentity(Claim identity);
    private static SpnEndpointIdentity();
    public static TimeSpan get_SpnLookupTime();
    public static void set_SpnLookupTime(TimeSpan value);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
    internal SecurityIdentifier GetSpnSid();
}
internal class System.ServiceModel.SR : object {
    internal static string NoIPEndpointsFoundForHost;
    internal static string DnsResolveFailed;
    internal static string RequiredAttributeMissing;
    internal static string UnsupportedCryptoAlgorithm;
    internal static string CustomCryptoAlgorithmIsNotValidHashAlgorithm;
    internal static string InvalidClientCredentials;
    internal static string SspiErrorOrInvalidClientCredentials;
    internal static string CustomCryptoAlgorithmIsNotValidAsymmetricSignature;
    internal static string TokenSerializerNotSetonFederationProvider;
    internal static string IssuerBindingNotPresentInTokenRequirement;
    internal static string IssuerChannelBehaviorsCannotContainSecurityCredentialsManager;
    internal static string ServiceBusyCountTrace;
    internal static string SecurityTokenManagerCannotCreateProviderForRequirement;
    internal static string SecurityTokenManagerCannotCreateAuthenticatorForRequirement;
    internal static string FailedSignatureVerification;
    internal static string SecurityTokenManagerCannotCreateSerializerForVersion;
    internal static string SupportingSignatureIsNotDerivedFrom;
    internal static string PrimarySignatureWasNotSignedByDerivedKey;
    internal static string PrimarySignatureWasNotSignedByDerivedWrappedKey;
    internal static string MessageWasNotEncryptedByDerivedWrappedKey;
    internal static string SecurityStateEncoderDecodingFailure;
    internal static string SecurityStateEncoderEncodingFailure;
    internal static string MessageWasNotEncryptedByDerivedEncryptionToken;
    internal static string TokenAuthenticatorRequiresSecurityBindingElement;
    internal static string TokenProviderRequiresSecurityBindingElement;
    internal static string UnexpectedSecuritySessionCloseResponse;
    internal static string UnexpectedSecuritySessionClose;
    internal static string CannotObtainSslConnectionInfo;
    internal static string HeaderEncryptionNotSupportedInWsSecurityJan2004;
    internal static string EncryptedHeaderNotSigned;
    internal static string EncodingBindingElementDoesNotHandleReaderQuotas;
    internal static string HeaderDecryptionNotSupportedInWsSecurityJan2004;
    internal static string DecryptionFailed;
    internal static string AuthenticationManagerShouldNotReturnNull;
    internal static string ErrorSerializingSecurityToken;
    internal static string ErrorDeserializingKeyIdentifierClauseFromTokenXml;
    internal static string ErrorDeserializingTokenXml;
    internal static string TokenRequirementDoesNotSpecifyTargetAddress;
    internal static string DerivedKeyNotInitialized;
    internal static string IssuedKeySizeNotCompatibleWithAlgorithmSuite;
    internal static string IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey;
    internal static string InvalidBearerKeyUsage;
    internal static string MultipleIssuerEndpointsFound;
    internal static string MultipleAuthenticationManagersInServiceBindingParameters;
    internal static string MultipleAuthenticationSchemesInServiceBindingParameters;
    internal static string NoSecurityBindingElementFound;
    internal static string MultipleSecurityCredentialsManagersInServiceBindingParameters;
    internal static string MultipleSecurityCredentialsManagersInChannelBindingParameters;
    internal static string NoClientCertificate;
    internal static string SecurityTokenParametersHasIncompatibleInclusionMode;
    internal static string CannotCreateTwoWayListenerForNegotiation;
    internal static string NegotiationQuotasExceededFaultReason;
    internal static string PendingSessionsExceededFaultReason;
    internal static string RequestSecurityTokenDoesNotMatchEndpointFilters;
    internal static string SecuritySessionRequiresIssuanceAuthenticator;
    internal static string SecuritySessionRequiresSecurityContextTokenCache;
    internal static string SessionTokenIsNotSecurityContextToken;
    internal static string SessionTokenIsNotGenericXmlToken;
    internal static string SecurityStandardsManagerNotSet;
    internal static string SecurityNegotiationMessageTooLarge;
    internal static string PreviousChannelDemuxerOpenFailed;
    internal static string SecurityChannelListenerNotSet;
    internal static string SecurityChannelListenerChannelExtendedProtectionNotSupported;
    internal static string SecurityChannelBindingMissing;
    internal static string SecuritySettingsLifetimeManagerNotSet;
    internal static string SecurityListenerClosing;
    internal static string SecurityListenerClosingFaultReason;
    internal static string SslCipherKeyTooSmall;
    internal static string DerivedKeyTokenNonceTooLong;
    internal static string DerivedKeyTokenLabelTooLong;
    internal static string DerivedKeyTokenOffsetTooHigh;
    internal static string DerivedKeyTokenGenerationAndLengthTooHigh;
    internal static string DerivedKeyLimitExceeded;
    internal static string WrappedKeyLimitExceeded;
    internal static string BufferQuotaExceededReadingBase64;
    internal static string MessageSecurityDoesNotWorkWithManualAddressing;
    internal static string TargetAddressIsNotSet;
    internal static string IssuedTokenCacheNotSet;
    internal static string SecurityAlgorithmSuiteNotSet;
    internal static string SecurityTokenFoundOutsideSecurityHeader;
    internal static string SecurityTokenNotResolved;
    internal static string SecureConversationCancelNotAllowedFaultReason;
    internal static string BootstrapSecurityBindingElementNotSet;
    internal static string IssuerBuildContextNotSet;
    internal static string StsBindingNotSet;
    internal static string SslCertMayNotDoKeyExchange;
    internal static string SslCertMustHavePrivateKey;
    internal static string NoOutgoingEndpointAddressAvailableForDoingIdentityCheck;
    internal static string NoOutgoingEndpointAddressAvailableForDoingIdentityCheckOnReply;
    internal static string NoSigningTokenAvailableToDoIncomingIdentityCheck;
    internal static string Psha1KeyLengthInvalid;
    internal static string CloneNotImplementedCorrectly;
    internal static string BadIssuedTokenType;
    internal static string OperationDoesNotAllowImpersonation;
    internal static string RstrHasMultipleIssuedTokens;
    internal static string RstrHasMultipleProofTokens;
    internal static string ProofTokenXmlUnexpectedInRstr;
    internal static string InvalidKeyLengthRequested;
    internal static string IssuedSecurityTokenParametersNotSet;
    internal static string InvalidOrUnrecognizedAction;
    internal static string UnsupportedTokenInclusionMode;
    internal static string CannotImportProtectionLevelForContract;
    internal static string OnlyOneOfEncryptedKeyOrSymmetricBindingCanBeSelected;
    internal static string ClientCredentialTypeMustBeSpecifiedForMixedMode;
    internal static string SecuritySessionIdAlreadyPresentInFilterTable;
    internal static string SupportingTokenNotProvided;
    internal static string SupportingTokenIsNotEndorsing;
    internal static string SupportingTokenIsNotSigned;
    internal static string SupportingTokenIsNotEncrypted;
    internal static string BasicTokenNotExpected;
    internal static string FailedAuthenticationTrustFaultCode;
    internal static string AuthenticationOfClientFailed;
    internal static string InvalidRequestTrustFaultCode;
    internal static string SignedSupportingTokenNotExpected;
    internal static string SenderSideSupportingTokensMustSpecifySecurityTokenParameters;
    internal static string SignatureAndEncryptionTokenMismatch;
    internal static string RevertingPrivilegeFailed;
    internal static string UnknownSupportingToken;
    internal static string MoreThanOneSupportingSignature;
    internal static string UnsecuredMessageFaultReceived;
    internal static string FailedAuthenticationFaultReason;
    internal static string BadContextTokenOrActionFaultReason;
    internal static string BadContextTokenFaultReason;
    internal static string NegotiationFailedIO;
    internal static string SecurityNegotiationCannotProtectConfidentialEndpointHeader;
    internal static string InvalidSecurityTokenFaultReason;
    internal static string InvalidSecurityFaultReason;
    internal static string AnonymousLogonsAreNotAllowed;
    internal static string UnableToObtainIssuerMetadata;
    internal static string ErrorImportingIssuerMetadata;
    internal static string MultipleCorrelationTokensFound;
    internal static string NoCorrelationTokenFound;
    internal static string MultipleSupportingAuthenticatorsOfSameType;
    internal static string TooManyIssuedSecurityTokenParameters;
    internal static string UnknownTokenAuthenticatorUsedInTokenProcessing;
    internal static string TokenMustBeNullWhenTokenParametersAre;
    internal static string SecurityTokenParametersCloneInvalidResult;
    internal static string CertificateUnsupportedForHttpTransportCredentialOnly;
    internal static string BasicHttpMessageSecurityRequiresCertificate;
    internal static string EntropyModeRequiresRequestorEntropy;
    internal static string BearerKeyTypeCannotHaveProofKey;
    internal static string BearerKeyIncompatibleWithWSFederationHttpBinding;
    internal static string UnableToCreateKeyTypeElementForUnknownKeyType;
    internal static string EntropyModeCannotHaveProofTokenOrIssuerEntropy;
    internal static string EntropyModeCannotHaveRequestorEntropy;
    internal static string EntropyModeRequiresProofToken;
    internal static string EntropyModeRequiresComputedKey;
    internal static string EntropyModeRequiresIssuerEntropy;
    internal static string EntropyModeCannotHaveComputedKey;
    internal static string UnknownComputedKeyAlgorithm;
    internal static string NoncesCachedInfinitely;
    internal static string ChannelMustBeOpenedToGetSessionId;
    internal static string SecurityVersionDoesNotSupportEncryptedKeyBinding;
    internal static string SecurityVersionDoesNotSupportThumbprintX509KeyIdentifierClause;
    internal static string SecurityBindingSupportsOneWayOnly;
    internal static string DownlevelNameCannotMapToUpn;
    internal static string ResolvingExternalTokensRequireSecurityTokenParameters;
    internal static string SecurityRenewFaultReason;
    internal static string ClientSecurityOutputSessionCloseTimeout;
    internal static string ClientSecurityNegotiationTimeout;
    internal static string ClientSecuritySessionRequestTimeout;
    internal static string ServiceSecurityCloseOutputSessionTimeout;
    internal static string ServiceSecurityCloseTimeout;
    internal static string ClientSecurityCloseTimeout;
    internal static string UnableToRenewSessionKey;
    internal static string SessionKeyRenewalNotSupported;
    internal static string SctCookieXmlParseError;
    internal static string SctCookieValueMissingOrIncorrect;
    internal static string SctCookieBlobDecodeFailure;
    internal static string SctCookieNotSupported;
    internal static string CannotImportSupportingTokensForOperationWithoutRequestAction;
    internal static string SignatureConfirmationsNotExpected;
    internal static string SignatureConfirmationsOccursAfterPrimarySignature;
    internal static string SignatureConfirmationWasExpected;
    internal static string SecurityVersionDoesNotSupportSignatureConfirmation;
    internal static string SignatureConfirmationRequiresRequestReply;
    internal static string NotAllSignaturesConfirmed;
    internal static string FoundUnexpectedSignatureConfirmations;
    internal static string TooManyPendingSessionKeys;
    internal static string SecuritySessionKeyIsStale;
    internal static string MultipleMatchingCryptosFound;
    internal static string CannotFindMatchingCrypto;
    internal static string SymmetricSecurityBindingElementNeedsProtectionTokenParameters;
    internal static string AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters;
    internal static string AsymmetricSecurityBindingElementNeedsRecipientTokenParameters;
    internal static string CachedNegotiationStateQuotaReached;
    internal static string LsaAuthorityNotContacted;
    internal static string KeyRolloverGreaterThanKeyRenewal;
    internal static string AtLeastOneContractOperationRequestRequiresProtectionLevelNotSupportedByBinding;
    internal static string AtLeastOneContractOperationResponseRequiresProtectionLevelNotSupportedByBinding;
    internal static string UnknownHeaderCannotProtected;
    internal static string NoStreamingWithSecurity;
    internal static string CurrentSessionTokenNotRenewed;
    internal static string IncorrectSpnOrUpnSpecified;
    internal static string IncomingSigningTokenMustBeAnEncryptedKey;
    internal static string SecuritySessionAbortedFaultReason;
    internal static string NoAppliesToPresent;
    internal static string UnsupportedKeyLength;
    internal static string ForReplayDetectionToBeDoneRequireIntegrityMustBeSet;
    internal static string CantInferReferenceForToken;
    internal static string TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences;
    internal static string TrustDriverVersionDoesNotSupportSession;
    internal static string TrustDriverVersionDoesNotSupportIssuedTokens;
    internal static string CannotPerformS4UImpersonationOnPlatform;
    internal static string CannotPerformImpersonationOnUsernameToken;
    internal static string SecureConversationRequiredByReliableSession;
    internal static string RevertImpersonationFailure;
    internal static string TransactionFlowRequiredIssuedTokens;
    internal static string SignatureConfirmationNotSupported;
    internal static string SecureConversationDriverVersionDoesNotSupportSession;
    internal static string SoapSecurityNegotiationFailed;
    internal static string SoapSecurityNegotiationFailedForIssuerAndTarget;
    internal static string OneWayOperationReturnedFault;
    internal static string OneWayOperationReturnedLargeFault;
    internal static string OneWayOperationReturnedMessage;
    internal static string CannotFindSecuritySession;
    internal static string SecurityContextKeyExpired;
    internal static string SecurityContextKeyExpiredNoKeyGeneration;
    internal static string SecuritySessionRequiresMessageIntegrity;
    internal static string RequiredTimestampMissingInSecurityHeader;
    internal static string ReceivedMessageInRequestContextNull;
    internal static string KeyLifetimeNotWithinTokenLifetime;
    internal static string EffectiveGreaterThanExpiration;
    internal static string NoSessionTokenPresentInMessage;
    internal static string KeyLengthMustBeMultipleOfEight;
    internal static string InvalidX509RawData;
    internal static string ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported;
    internal static string UnsupportedSecureConversationBootstrapProtectionRequirements;
    internal static string UnsupportedBooleanAttribute;
    internal static string NoTransportTokenAssertionProvided;
    internal static string PolicyRequiresConfidentialityWithoutIntegrity;
    internal static string PrimarySignatureIsRequiredToBeEncrypted;
    internal static string TokenCannotCreateSymmetricCrypto;
    internal static string TokenDoesNotMeetKeySizeRequirements;
    internal static string MessageProtectionOrderMismatch;
    internal static string PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures;
    internal static string ElementToSignMustHaveId;
    internal static string StandardsManagerCannotWriteObject;
    internal static string SigningWithoutPrimarySignatureRequiresTimestamp;
    internal static string OperationCannotBeDoneAfterProcessingIsStarted;
    internal static string MaximumPolicyRedirectionsExceeded;
    internal static string InvalidAttributeInSignedHeader;
    internal static string StsAddressNotSet;
    internal static string MoreThanOneSecurityBindingElementInTheBinding;
    internal static string ClientCredentialsUnableToCreateLocalTokenProvider;
    internal static string SecurityBindingElementCannotBeExpressedInConfig;
    internal static string ConfigurationSchemaInsuffientForSecurityBindingElementInstance;
    internal static string ConfigurationSchemaContainsX509IssuerSerialReference;
    internal static string SecurityProtocolCannotDoReplayDetection;
    internal static string UnableToFindSecurityHeaderInMessage;
    internal static string UnableToFindSecurityHeaderInMessageNoActor;
    internal static string NoPrimarySignatureAvailableForSupportingTokenSignatureVerification;
    internal static string SupportingTokenSignaturesNotExpected;
    internal static string CannotReadToken;
    internal static string ExpectedElementMissing;
    internal static string ExpectedOneOfTwoElementsFromNamespace;
    internal static string RstDirectDoesNotExpectRstr;
    internal static string RequireNonCookieMode;
    internal static string RequiredSignatureMissing;
    internal static string RequiredMessagePartNotSigned;
    internal static string RequiredMessagePartNotSignedNs;
    internal static string RequiredMessagePartNotEncrypted;
    internal static string RequiredMessagePartNotEncryptedNs;
    internal static string SignatureVerificationFailed;
    internal static string CannotIssueRstTokenType;
    internal static string NoNegotiationMessageToSend;
    internal static string InvalidIssuedTokenKeySize;
    internal static string CannotObtainIssuedTokenKeySize;
    internal static string NegotiationIsNotCompleted;
    internal static string NegotiationIsCompleted;
    internal static string MissingMessageID;
    internal static string SecuritySessionLimitReached;
    internal static string SecuritySessionAlreadyPending;
    internal static string SecuritySessionNotPending;
    internal static string SecuritySessionListenerNotFound;
    internal static string SessionTokenWasNotClosed;
    internal static string ProtocolMustBeInitiator;
    internal static string ProtocolMustBeRecipient;
    internal static string SendingOutgoingmessageOnRecipient;
    internal static string OnlyBodyReturnValuesSupported;
    internal static string UnknownTokenAttachmentMode;
    internal static string ProtocolMisMatch;
    internal static string AttemptToCreateMultipleRequestContext;
    internal static string ServerReceivedCloseMessageStateIsCreated;
    internal static string ShutdownRequestWasNotReceived;
    internal static string UnknownFilterType;
    internal static string StandardsManagerDoesNotMatch;
    internal static string FilterStrictModeDifferent;
    internal static string SSSSCreateAcceptor;
    internal static string TransactionFlowBadOption;
    internal static string TokenManagerCouldNotReadToken;
    internal static string InvalidActionForNegotiationMessage;
    internal static string InvalidKeySizeSpecifiedInNegotiation;
    internal static string GetTokenInfoFailed;
    internal static string UnexpectedEndOfFile;
    internal static string TimeStampHasCreationAheadOfExpiry;
    internal static string TimeStampHasExpiryTimeInPast;
    internal static string TimeStampHasCreationTimeInFuture;
    internal static string TimeStampWasCreatedTooLongAgo;
    internal static string InvalidOrReplayedNonce;
    internal static string MessagePartSpecificationMustBeImmutable;
    internal static string UnsupportedIssuerEntropyType;
    internal static string NoRequestSecurityTokenResponseElements;
    internal static string NoCookieInSct;
    internal static string TokenProviderReturnedBadToken;
    internal static string ItemNotAvailableInDeserializedRST;
    internal static string ItemAvailableInDeserializedRSTOnly;
    internal static string ItemNotAvailableInDeserializedRSTR;
    internal static string ItemAvailableInDeserializedRSTROnly;
    internal static string MoreThanOneRSTRInRSTRC;
    internal static string Hosting_VirtualPathExtenstionCanNotBeDetached;
    internal static string Hosting_NotSupportedProtocol;
    internal static string Hosting_BaseUriDeserializedNotValid;
    internal static string Hosting_RelativeAddressFormatError;
    internal static string Hosting_NoAbsoluteRelativeAddress;
    internal static string SecureConversationNeedsBootstrapSecurity;
    internal static string Hosting_MemoryGatesCheckFailedUnderPartialTrust;
    internal static string Hosting_CompatibilityServiceNotHosted;
    internal static string Hosting_MisformattedPort;
    internal static string Hosting_MisformattedBinding;
    internal static string Hosting_MisformattedBindingData;
    internal static string Hosting_NoHttpTransportManagerForUri;
    internal static string Hosting_NoTcpPipeTransportManagerForUri;
    internal static string Hosting_ProcessNotExecutingUnderHostedContext;
    internal static string Hosting_ServiceActivationFailed;
    internal static string Hosting_ServiceTypeNotProvided;
    internal static string SharedEndpointReadDenied;
    internal static string SharedEndpointReadNotFound;
    internal static string SharedManagerBase;
    internal static string SharedManagerServiceStartFailure;
    internal static string SharedManagerServiceStartFailureDisabled;
    internal static string SharedManagerServiceStartFailureNoError;
    internal static string SharedManagerServiceLookupFailure;
    internal static string SharedManagerServiceSidLookupFailure;
    internal static string SharedManagerServiceEndpointReadFailure;
    internal static string SharedManagerServiceSecurityFailed;
    internal static string SharedManagerUserSidLookupFailure;
    internal static string SharedManagerCurrentUserSidLookupFailure;
    internal static string SharedManagerLogonSidLookupFailure;
    internal static string SharedManagerDataConnectionFailure;
    internal static string SharedManagerDataConnectionCreateFailure;
    internal static string SharedManagerDataConnectionPipeFailed;
    internal static string SharedManagerVersionUnsupported;
    internal static string SharedManagerAllowDupHandleFailed;
    internal static string SharedManagerPathTooLong;
    internal static string SharedManagerRegistrationQuotaExceeded;
    internal static string SharedManagerProtocolUnsupported;
    internal static string SharedManagerConflictingRegistration;
    internal static string SharedManagerFailedToListen;
    internal static string Sharing_ConnectionDispatchFailed;
    internal static string Sharing_EndpointUnavailable;
    internal static string Sharing_EmptyListenerEndpoint;
    internal static string Sharing_ListenerProxyStopped;
    internal static string UnexpectedEmptyElementExpectingClaim;
    internal static string UnexpectedElementExpectingElement;
    internal static string UnexpectedDuplicateElement;
    internal static string UnsupportedSecurityPolicyAssertion;
    internal static string MultipleIdentities;
    internal static string InvalidUriValue;
    internal static string BindingDoesNotSupportProtectionForRst;
    internal static string TransportDoesNotProtectMessage;
    internal static string BindingDoesNotSupportWindowsIdenityForImpersonation;
    internal static string ListenUriNotSet;
    internal static string UnsupportedChannelInterfaceType;
    internal static string TransportManagerOpen;
    internal static string TransportManagerNotOpen;
    internal static string UnrecognizedIdentityType;
    internal static string InvalidIdentityElement;
    internal static string UnableToLoadCertificateIdentity;
    internal static string UnrecognizedClaimTypeForIdentity;
    internal static string AsyncCallbackException;
    internal static string SendCannotBeCalledAfterCloseOutputSession;
    internal static string CommunicationObjectCannotBeModifiedInState;
    internal static string CommunicationObjectCannotBeModified;
    internal static string CommunicationObjectCannotBeUsed;
    internal static string CommunicationObjectFaulted1;
    internal static string CommunicationObjectFaultedStack2;
    internal static string CommunicationObjectAborted1;
    internal static string CommunicationObjectAbortedStack2;
    internal static string CommunicationObjectBaseClassMethodNotCalled;
    internal static string CommunicationObjectInInvalidState;
    internal static string CommunicationObjectCloseInterrupted1;
    internal static string ChannelFactoryCannotBeUsedToCreateChannels;
    internal static string ChannelParametersCannotBeModified;
    internal static string ChannelParametersCannotBePropagated;
    internal static string OneWayInternalTypeNotSupported;
    internal static string ChannelTypeNotSupported;
    internal static string SecurityContextMissing;
    internal static string SecurityContextDoesNotAllowImpersonation;
    internal static string InvalidEnumValue;
    internal static string InvalidDecoderStateMachine;
    internal static string OperationPropertyIsRequiredForAttributeGeneration;
    internal static string InvalidMembershipProviderSpecifiedInConfig;
    internal static string InvalidRoleProviderSpecifiedInConfig;
    internal static string ObjectDisposed;
    internal static string InvalidReaderPositionOnCreateMessage;
    internal static string DuplicateMessageProperty;
    internal static string MessagePropertyNotFound;
    internal static string HeaderAlreadyUnderstood;
    internal static string HeaderAlreadyNotUnderstood;
    internal static string MultipleMessageHeaders;
    internal static string MultipleMessageHeadersWithActor;
    internal static string MultipleRelatesToHeaders;
    internal static string ExtraContentIsPresentInFaultDetail;
    internal static string MessageIsEmpty;
    internal static string MessageClosed;
    internal static string StreamClosed;
    internal static string BodyWriterReturnedIsNotBuffered;
    internal static string BodyWriterCanOnlyBeWrittenOnce;
    internal static string RstrKeySizeNotProvided;
    internal static string RequestMessageDoesNotHaveAMessageID;
    internal static string HeaderNotFound;
    internal static string MessageBufferIsClosed;
    internal static string MessageTextEncodingNotSupported;
    internal static string AtLeastOneFaultReasonMustBeSpecified;
    internal static string NoNullTranslations;
    internal static string FaultDoesNotHaveAnyDetail;
    internal static string InvalidXmlQualifiedName;
    internal static string UnboundPrefixInQName;
    internal static string MessageBodyIsUnknown;
    internal static string MessageBodyIsStream;
    internal static string MessageBodyToStringError;
    internal static string NoMatchingTranslationFoundForFaultText;
    internal static string CannotDetermineSPNBasedOnAddress;
    internal static string XmlLangAttributeMissing;
    internal static string EncoderUnrecognizedCharSet;
    internal static string EncoderUnrecognizedContentType;
    internal static string EncoderBadContentType;
    internal static string EncoderEnvelopeVersionMismatch;
    internal static string EncoderMessageVersionMismatch;
    internal static string MtomEncoderBadMessageVersion;
    internal static string ReadNotSupported;
    internal static string SeekNotSupported;
    internal static string WriterAsyncWritePending;
    internal static string ChannelInitializationTimeout;
    internal static string SocketCloseReadTimeout;
    internal static string SocketCloseReadReceivedData;
    internal static string PipeCantCloseWithPendingWrite;
    internal static string PipeShutdownWriteError;
    internal static string PipeShutdownReadError;
    internal static string PipeNameCanNotBeAccessed;
    internal static string PipeNameCanNotBeAccessed2;
    internal static string PipeModeChangeFailed;
    internal static string PipeCloseFailed;
    internal static string PipeAlreadyShuttingDown;
    internal static string PipeSignalExpected;
    internal static string PipeAlreadyClosing;
    internal static string PipeAcceptFailed;
    internal static string PipeListenFailed;
    internal static string PipeNameInUse;
    internal static string PipeNameCantBeReserved;
    internal static string PipeListenerDisposed;
    internal static string PipeListenerNotListening;
    internal static string PipeConnectAddressFailed;
    internal static string PipeConnectFailed;
    internal static string PipeConnectTimedOut;
    internal static string PipeConnectTimedOutServerTooBusy;
    internal static string PipeEndpointNotFound;
    internal static string PipeUriSchemeWrong;
    internal static string PipeWriteIncomplete;
    internal static string PipeClosed;
    internal static string PipeReadTimedOut;
    internal static string PipeWriteTimedOut;
    internal static string PipeConnectionAbortedReadTimedOut;
    internal static string PipeConnectionAbortedWriteTimedOut;
    internal static string PipeWriteError;
    internal static string PipeReadError;
    internal static string PipeUnknownWin32Error;
    internal static string PipeKnownWin32Error;
    internal static string PipeWritePending;
    internal static string PipeReadPending;
    internal static string PipeDuplicationFailed;
    internal static string SessionValueInvalid;
    internal static string PackageFullNameInvalid;
    internal static string SocketAbortedReceiveTimedOut;
    internal static string SocketAbortedSendTimedOut;
    internal static string OperationInvalidBeforeSecurityNegotiation;
    internal static string FramingError;
    internal static string FramingPrematureEOF;
    internal static string FramingRecordTypeMismatch;
    internal static string FramingVersionNotSupported;
    internal static string FramingModeNotSupported;
    internal static string FramingSizeTooLarge;
    internal static string FramingViaTooLong;
    internal static string FramingViaNotUri;
    internal static string FramingFaultTooLong;
    internal static string FramingContentTypeTooLong;
    internal static string FramingValueNotAvailable;
    internal static string FramingAtEnd;
    internal static string RemoteSecurityNotNegotiatedOnStreamUpgrade;
    internal static string BinaryEncoderSessionTooLarge;
    internal static string BinaryEncoderSessionInvalid;
    internal static string BinaryEncoderSessionMalformed;
    internal static string ReceiveShutdownReturnedFault;
    internal static string ReceiveShutdownReturnedLargeFault;
    internal static string ReceiveShutdownReturnedMessage;
    internal static string MaxReceivedMessageSizeExceeded;
    internal static string MaxSentMessageSizeExceeded;
    internal static string FramingMaxMessageSizeExceeded;
    internal static string StreamDoesNotSupportTimeout;
    internal static string FilterExists;
    internal static string FilterUnexpectedError;
    internal static string FilterNodeQuotaExceeded;
    internal static string FilterCapacityNegative;
    internal static string ActionFilterEmptyList;
    internal static string FilterUndefinedPrefix;
    internal static string FilterMultipleMatches;
    internal static string FilterTableTypeMismatch;
    internal static string FilterTableInvalidForLookup;
    internal static string FilterBadTableType;
    internal static string FilterQuotaRange;
    internal static string FilterEmptyString;
    internal static string FilterInvalidInner;
    internal static string FilterInvalidAttribute;
    internal static string FilterInvalidDialect;
    internal static string FilterCouldNotCompile;
    internal static string FilterReaderNotStartElem;
    internal static string SeekableMessageNavInvalidPosition;
    internal static string SeekableMessageNavNonAtomized;
    internal static string SeekableMessageNavIDNotSupported;
    internal static string SeekableMessageNavBodyForbidden;
    internal static string SeekableMessageNavOverrideForbidden;
    internal static string QueryNotImplemented;
    internal static string QueryNotSortable;
    internal static string QueryMustBeSeekable;
    internal static string QueryContextNotSupportedInSequences;
    internal static string QueryFunctionTypeNotSupported;
    internal static string QueryVariableTypeNotSupported;
    internal static string QueryVariableNull;
    internal static string QueryFunctionStringArg;
    internal static string QueryItemAlreadyExists;
    internal static string QueryBeforeNodes;
    internal static string QueryAfterNodes;
    internal static string QueryIteratorOutOfScope;
    internal static string QueryCantGetStringForMovedIterator;
    internal static string MessageVersionToStringFormat;
    internal static string Addressing10ToStringFormat;
    internal static string Addressing200408ToStringFormat;
    internal static string AddressingNoneToStringFormat;
    internal static string AddressingVersionNotSupported;
    internal static string SupportedAddressingModeNotSupported;
    internal static string Soap11ToStringFormat;
    internal static string Soap12ToStringFormat;
    internal static string EnvelopeNoneToStringFormat;
    internal static string MessagePropertyReturnedNullCopy;
    internal static string MessageVersionUnknown;
    internal static string EnvelopeVersionUnknown;
    internal static string EnvelopeVersionNotSupported;
    internal static string CannotDetectAddressingVersion;
    internal static string HeadersCannotBeAddedToEnvelopeVersion;
    internal static string AddressingHeadersCannotBeAddedToAddressingVersion;
    internal static string AddressingExtensionInBadNS;
    internal static string MessageHeaderVersionNotSupported;
    internal static string MessageHasBeenCopied;
    internal static string MessageHasBeenWritten;
    internal static string MessageHasBeenRead;
    internal static string InvalidMessageState;
    internal static string MessageBodyReaderInvalidReadState;
    internal static string XmlBufferQuotaExceeded;
    internal static string XmlBufferInInvalidState;
    internal static string MessageBodyMissing;
    internal static string MessageHeaderVersionMismatch;
    internal static string ManualAddressingRequiresAddressedMessages;
    internal static string OneWayHeaderNotFound;
    internal static string ReceiveTimedOut;
    internal static string ReceiveTimedOut2;
    internal static string WaitForMessageTimedOut;
    internal static string ReceiveTimedOutNoLocalAddress;
    internal static string ReceiveRequestTimedOutNoLocalAddress;
    internal static string ReceiveRequestTimedOut;
    internal static string SendToViaTimedOut;
    internal static string CloseTimedOut;
    internal static string OpenTimedOutEstablishingTransportSession;
    internal static string RequestTimedOutEstablishingTransportSession;
    internal static string TcpConnectingToViaTimedOut;
    internal static string RequestChannelSendTimedOut;
    internal static string RequestChannelWaitForReplyTimedOut;
    internal static string HttpTransportCannotHaveMultipleAuthenticationSchemes;
    internal static string MultipleCCbesInParameters;
    internal static string CookieContainerBindingElementNeedsHttp;
    internal static string HttpIfModifiedSinceParseError;
    internal static string HttpSoapActionMismatch;
    internal static string HttpSoapActionMismatchContentType;
    internal static string HttpSoapActionMismatchFault;
    internal static string HttpContentTypeFormatException;
    internal static string HttpServerTooBusy;
    internal static string HttpRequestAborted;
    internal static string HttpRequestTimedOut;
    internal static string HttpResponseTimedOut;
    internal static string HttpTransferError;
    internal static string HttpReceiveFailure;
    internal static string HttpSendFailure;
    internal static string HttpAuthDoesNotSupportRequestStreaming;
    internal static string ReplyAlreadySent;
    internal static string HttpInvalidListenURI;
    internal static string RequestContextAborted;
    internal static string ReceiveContextCannotBeUsed;
    internal static string ReceiveContextInInvalidState;
    internal static string ReceiveContextFaulted;
    internal static string UnrecognizedHostNameComparisonMode;
    internal static string BadData;
    internal static string InvalidRenewResponseAction;
    internal static string InvalidCloseResponseAction;
    internal static string IncompatibleBehaviors;
    internal static string NullSessionRequestMessage;
    internal static string IssueSessionTokenHandlerNotSet;
    internal static string RenewSessionTokenHandlerNotSet;
    internal static string WrongIdentityRenewingToken;
    internal static string InvalidRstRequestType;
    internal static string NoCloseTargetSpecified;
    internal static string FailedSspiNegotiation;
    internal static string BadCloseTarget;
    internal static string RenewSessionMissingSupportingToken;
    internal static string NoRenewTargetSpecified;
    internal static string BadRenewTarget;
    internal static string BadEncryptedBody;
    internal static string BadEncryptionState;
    internal static string NoSignaturePartsSpecified;
    internal static string NoEncryptionPartsSpecified;
    internal static string SecuritySessionFaultReplyWasSent;
    internal static string InnerListenerFactoryNotSet;
    internal static string SecureConversationBootstrapCannotUseSecureConversation;
    internal static string InnerChannelFactoryWasNotSet;
    internal static string SecurityProtocolFactoryDoesNotSupportDuplex;
    internal static string SecurityProtocolFactoryDoesNotSupportRequestReply;
    internal static string SecurityProtocolFactoryShouldBeSetBeforeThisOperation;
    internal static string SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation;
    internal static string SecureConversationSecurityTokenParametersRequireBootstrapBinding;
    internal static string PropertySettingErrorOnProtocolFactory;
    internal static string ProtocolFactoryCouldNotCreateProtocol;
    internal static string IdentityCheckFailedForOutgoingMessage;
    internal static string IdentityCheckFailedForIncomingMessage;
    internal static string DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim;
    internal static string DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim;
    internal static string DnsIdentityCheckFailedForIncomingMessage;
    internal static string DnsIdentityCheckFailedForOutgoingMessage;
    internal static string SerializedTokenVersionUnsupported;
    internal static string AuthenticatorNotPresentInRSTRCollection;
    internal static string RSTRAuthenticatorHasBadContext;
    internal static string ServerCertificateNotProvided;
    internal static string RSTRAuthenticatorNotPresent;
    internal static string RSTRAuthenticatorIncorrect;
    internal static string ClientCertificateNotProvided;
    internal static string ClientCertificateNotProvidedOnServiceCredentials;
    internal static string ClientCertificateNotProvidedOnClientCredentials;
    internal static string ServiceCertificateNotProvidedOnServiceCredentials;
    internal static string ServiceCertificateNotProvidedOnClientCredentials;
    internal static string UserNamePasswordNotProvidedOnClientCredentials;
    internal static string ObjectIsReadOnly;
    internal static string EmptyXmlElementError;
    internal static string UnexpectedXmlChildNode;
    internal static string ContextAlreadyRegistered;
    internal static string ContextAlreadyRegisteredNoKeyGeneration;
    internal static string ContextNotPresent;
    internal static string ContextNotPresentNoKeyGeneration;
    internal static string InvalidSecurityContextCookie;
    internal static string SecurityContextNotRegistered;
    internal static string SecurityContextExpired;
    internal static string SecurityContextExpiredNoKeyGeneration;
    internal static string NoSecurityContextIdentifier;
    internal static string MessageMustHaveViaOrToSetForSendingOnServerSideCompositeDuplexChannels;
    internal static string MessageViaCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels;
    internal static string MessageToCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels;
    internal static string SecurityBindingNotSetUpToProcessOutgoingMessages;
    internal static string SecurityBindingNotSetUpToProcessIncomingMessages;
    internal static string TokenProviderCannotGetTokensForTarget;
    internal static string UnsupportedKeyDerivationAlgorithm;
    internal static string CannotFindCorrelationStateForApplyingSecurity;
    internal static string ReplyWasNotSignedWithRequiredSigningToken;
    internal static string EncryptionNotExpected;
    internal static string SignatureNotExpected;
    internal static string InvalidQName;
    internal static string UnknownICryptoType;
    internal static string SameProtocolFactoryCannotBeSetForBothDuplexDirections;
    internal static string SuiteDoesNotAcceptAlgorithm;
    internal static string TokenDoesNotSupportKeyIdentifierClauseCreation;
    internal static string UnableToCreateICryptoFromTokenForSignatureVerification;
    internal static string MessageSecurityVerificationFailed;
    internal static string TransportSecurityRequireToHeader;
    internal static string TransportSecuredMessageMissingToHeader;
    internal static string UnsignedToHeaderInTransportSecuredMessage;
    internal static string TransportSecuredMessageHasMoreThanOneToHeader;
    internal static string TokenNotExpectedInSecurityHeader;
    internal static string CannotFindCert;
    internal static string CannotFindCertForTarget;
    internal static string FoundMultipleCerts;
    internal static string FoundMultipleCertsForTarget;
    internal static string MissingKeyInfoInEncryptedKey;
    internal static string EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken;
    internal static string MessageWasNotEncryptedWithTheRequiredEncryptingToken;
    internal static string TimestampMustOccurFirstInSecurityHeaderLayout;
    internal static string TimestampMustOccurLastInSecurityHeaderLayout;
    internal static string AtMostOnePrimarySignatureInReceiveSecurityHeader;
    internal static string SigningTokenHasNoKeys;
    internal static string SigningTokenHasNoKeysSupportingTheAlgorithmSuite;
    internal static string DelayedSecurityApplicationAlreadyCompleted;
    internal static string UnableToResolveKeyInfoClauseInDerivedKeyToken;
    internal static string UnableToDeriveKeyFromKeyInfoClause;
    internal static string UnableToResolveKeyInfoForVerifyingSignature;
    internal static string UnableToResolveKeyInfoForUnwrappingToken;
    internal static string UnableToResolveKeyInfoForDecryption;
    internal static string EmptyBase64Attribute;
    internal static string RequiredSecurityHeaderElementNotSigned;
    internal static string RequiredSecurityTokenNotSigned;
    internal static string RequiredSecurityTokenNotEncrypted;
    internal static string MessageBodyOperationNotValidInBodyState;
    internal static string EncryptedKeyWithReferenceListNotAllowed;
    internal static string UnableToFindTokenAuthenticator;
    internal static string NoPartsOfMessageMatchedPartsToSign;
    internal static string BasicTokenCannotBeWrittenWithoutEncryption;
    internal static string DuplicateIdInMessageToBeVerified;
    internal static string UnsupportedCanonicalizationAlgorithm;
    internal static string NoKeyInfoInEncryptedItemToFindDecryptingToken;
    internal static string NoKeyInfoInSignatureToFindVerificationToken;
    internal static string SecurityHeaderIsEmpty;
    internal static string EncryptionMethodMissingInEncryptedData;
    internal static string EncryptedHeaderAttributeMismatch;
    internal static string AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck;
    internal static string AtMostOneSignatureIsSupportedWithDefaultPolicyCheck;
    internal static string UnexpectedEncryptedElementInSecurityHeader;
    internal static string MissingIdInEncryptedElement;
    internal static string TokenManagerCannotCreateTokenReference;
    internal static string TimestampToSignHasNoId;
    internal static string EncryptedHeaderXmlMustHaveId;
    internal static string UnableToResolveDataReference;
    internal static string TimestampAlreadySetForSecurityHeader;
    internal static string DuplicateTimestampInSecurityHeader;
    internal static string MismatchInSecurityOperationToken;
    internal static string UnableToCreateSymmetricAlgorithmFromToken;
    internal static string UnknownEncodingInBinarySecurityToken;
    internal static string UnableToResolveReferenceUriForSignature;
    internal static string NoTimestampAvailableInSecurityHeaderToDoReplayDetection;
    internal static string NoSignatureAvailableInSecurityHeaderToDoReplayDetection;
    internal static string CouldNotFindNamespaceForPrefix;
    internal static string DerivedKeyCannotDeriveFromSecret;
    internal static string DerivedKeyPosAndGenBothSpecified;
    internal static string DerivedKeyPosAndGenNotSpecified;
    internal static string DerivedKeyTokenRequiresTokenReference;
    internal static string DerivedKeyLengthTooLong;
    internal static string DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong;
    internal static string DerivedKeyInvalidOffsetSpecified;
    internal static string DerivedKeyInvalidGenerationSpecified;
    internal static string ChildNodeTypeMissing;
    internal static string NoLicenseXml;
    internal static string UnsupportedBinaryEncoding;
    internal static string BadKeyEncryptionAlgorithm;
    internal static string InvalidAsyncResult;
    internal static string UnableToCreateTokenReference;
    internal static string ConfigNull;
    internal static string NonceLengthTooShort;
    internal static string NoBinaryNegoToSend;
    internal static string BadSecurityNegotiationContext;
    internal static string NoBinaryNegoToReceive;
    internal static string ProofTokenWasNotWrappedCorrectly;
    internal static string NoServiceTokenReceived;
    internal static string InvalidSspiNegotiation;
    internal static string CannotAuthenticateServer;
    internal static string IncorrectBinaryNegotiationValueType;
    internal static string ChannelNotOpen;
    internal static string FailToRecieveReplyFromNegotiation;
    internal static string MessageSecurityVersionOutOfRange;
    internal static string CreationTimeUtcIsAfterExpiryTime;
    internal static string NegotiationStateAlreadyPresent;
    internal static string CannotFindNegotiationState;
    internal static string OutputNotExpected;
    internal static string SessionClosedBeforeDone;
    internal static string CacheQuotaReached;
    internal static string NoServerX509TokenProvider;
    internal static string UnexpectedBinarySecretType;
    internal static string UnsupportedPasswordType;
    internal static string UnrecognizedIdentityPropertyType;
    internal static string UnableToDemuxChannel;
    internal static string EndpointNotFound;
    internal static string MaxReceivedMessageSizeMustBeInIntegerRange;
    internal static string MaxBufferSizeMustMatchMaxReceivedMessageSize;
    internal static string MaxBufferSizeMustNotExceedMaxReceivedMessageSize;
    internal static string MessageSizeMustBeInIntegerRange;
    internal static string UriLengthExceedsMaxSupportedSize;
    internal static string InValidateIdPrefix;
    internal static string InValidateId;
    internal static string HttpRegistrationAlreadyExists;
    internal static string HttpRegistrationAccessDenied;
    internal static string HttpRegistrationPortInUse;
    internal static string HttpRegistrationLimitExceeded;
    internal static string UnexpectedHttpResponseCode;
    internal static string HttpContentLengthIncorrect;
    internal static string OneWayUnexpectedResponse;
    internal static string MissingContentType;
    internal static string DuplexChannelAbortedDuringOpen;
    internal static string OperationAbortedDuringConnectionEstablishment;
    internal static string HttpAddressingNoneHeaderOnWire;
    internal static string MessageXmlProtocolError;
    internal static string TcpV4AddressInvalid;
    internal static string TcpV6AddressInvalid;
    internal static string UniquePortNotAvailable;
    internal static string TcpAddressInUse;
    internal static string TcpConnectNoBufs;
    internal static string InsufficentMemory;
    internal static string TcpConnectError;
    internal static string TcpConnectErrorWithTimeSpan;
    internal static string TcpListenError;
    internal static string TcpTransferError;
    internal static string TcpTransferErrorWithIP;
    internal static string TcpLocalConnectionAborted;
    internal static string HttpResponseAborted;
    internal static string TcpConnectionResetError;
    internal static string TcpConnectionResetErrorWithIP;
    internal static string TcpConnectionTimedOut;
    internal static string TcpConnectionTimedOutWithIP;
    internal static string SocketConnectionDisposed;
    internal static string SocketListenerDisposed;
    internal static string SocketListenerNotListening;
    internal static string DuplexSessionListenerNotFound;
    internal static string HttpTargetNameDictionaryConflict;
    internal static string HttpContentTypeHeaderRequired;
    internal static string ContentTypeMismatch;
    internal static string ResponseContentTypeMismatch;
    internal static string ResponseContentTypeNotSupported;
    internal static string HttpToMustEqualVia;
    internal static string NullReferenceOnHttpResponse;
    internal static string FramingContentTypeMismatch;
    internal static string FramingFaultUnrecognized;
    internal static string FramingContentTypeTooLongFault;
    internal static string FramingViaTooLongFault;
    internal static string FramingModeNotSupportedFault;
    internal static string FramingVersionNotSupportedFault;
    internal static string FramingUpgradeInvalid;
    internal static string SecurityServerTooBusy;
    internal static string SecurityEndpointNotFound;
    internal static string ServerTooBusy;
    internal static string UpgradeProtocolNotSupported;
    internal static string UpgradeRequestToNonupgradableService;
    internal static string PreambleAckIncorrect;
    internal static string PreambleAckIncorrectMaybeHttp;
    internal static string StreamError;
    internal static string ServerRejectedUpgradeRequest;
    internal static string ServerRejectedSessionPreamble;
    internal static string UnableToResolveHost;
    internal static string HttpRequiresSingleAuthScheme;
    internal static string HttpAuthSchemeCannotBeNone;
    internal static string HttpProxyRequiresSingleAuthScheme;
    internal static string HttpMutualAuthNotSatisfied;
    internal static string HttpAuthorizationFailed;
    internal static string HttpAuthenticationFailed;
    internal static string HttpAuthorizationForbidden;
    internal static string InvalidUriScheme;
    internal static string HttpAuthSchemeAndClientCert;
    internal static string NoTransportManagerForUri;
    internal static string ListenerFactoryNotRegistered;
    internal static string HttpsExplicitIdentity;
    internal static string HttpsIdentityMultipleCerts;
    internal static string HttpsServerCertThumbprintMismatch;
    internal static string DuplicateRegistration;
    internal static string SecureChannelFailure;
    internal static string TrustFailure;
    internal static string NoCompatibleTransportManagerForUri;
    internal static string HttpSpnNotFound;
    internal static string StreamMutualAuthNotSatisfied;
    internal static string TransferModeNotSupported;
    internal static string InvalidTokenProvided;
    internal static string NoUserNameTokenProvided;
    internal static string RemoteIdentityFailedVerification;
    internal static string UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress;
    internal static string ProxyImpersonationLevelMismatch;
    internal static string ProxyAuthenticationLevelMismatch;
    internal static string CredentialDisallowsNtlm;
    internal static string DigestExplicitCredsImpersonationLevel;
    internal static string UriGeneratorSchemeMustNotBeEmpty;
    internal static string UnsupportedSslProtectionLevel;
    internal static string HttpNoTrackingService;
    internal static string HttpNetnameDeleted;
    internal static string TimeoutServiceChannelConcurrentOpen1;
    internal static string TimeoutServiceChannelConcurrentOpen2;
    internal static string TimeSpanMustbeGreaterThanTimeSpanZero;
    internal static string TimeSpanCannotBeLessThanTimeSpanZero;
    internal static string ValueMustBeNonNegative;
    internal static string ValueMustBePositive;
    internal static string ValueMustBeGreaterThanZero;
    internal static string ValueMustBeInRange;
    internal static string OffsetExceedsBufferBound;
    internal static string OffsetExceedsBufferSize;
    internal static string SizeExceedsRemainingBufferSpace;
    internal static string SpaceNeededExceedsMessageFrameOffset;
    internal static string FaultConverterDidNotCreateFaultMessage;
    internal static string FaultConverterCreatedFaultMessage;
    internal static string FaultConverterDidNotCreateException;
    internal static string FaultConverterCreatedException;
    internal static string InfoCardInvalidChain;
    internal static string FullTrustOnlyBindingElementSecurityCheck1;
    internal static string FullTrustOnlyBindingElementSecurityCheckWSHttpBinding1;
    internal static string FullTrustOnlyBindingSecurityCheck1;
    internal static string PartialTrustServiceCtorNotVisible;
    internal static string PartialTrustServiceMethodNotVisible;
    internal static string PartialTrustPerformanceCountersNotEnabled;
    internal static string EnsureCategoriesExistFailedPermission;
    internal static string PartialTrustWMINotEnabled;
    internal static string PartialTrustMessageLoggingNotEnabled;
    internal static string ScopeNameMustBeSpecified;
    internal static string ProviderCannotBeEmptyString;
    internal static string CannotSetNameOnTheInvalidKey;
    internal static string UnsupportedMessageQueryResultType;
    internal static string CannotRepresentResultAsNodeset;
    internal static string MessageNotInLockedState;
    internal static string MessageValidityExpired;
    internal static string UnsupportedUpgradeInitiator;
    internal static string UnsupportedUpgradeAcceptor;
    internal static string StreamUpgradeUnsupportedChannelBindingKind;
    internal static string ExtendedProtectionNotSupported;
    internal static string ExtendedProtectionPolicyBasicAuthNotSupported;
    internal static string ExtendedProtectionPolicyCustomChannelBindingNotSupported;
    internal static string HttpClientCredentialTypeInvalid;
    internal static string SecurityTokenProviderIncludeWindowsGroupsInconsistent;
    internal static string AuthenticationSchemesCannotBeInheritedFromHost;
    internal static string AuthenticationSchemes_BindingAndHostConflict;
    internal static string FlagEnumTypeExpected;
    internal static string InvalidFlagEnumType;
    internal static string NoAsyncWritePending;
    internal static string FlushBufferAlreadyInUse;
    internal static string WriteAsyncWithoutFreeBuffer;
    internal static string TransportDoesNotSupportCompression;
    internal static string UnsupportedSecuritySetting;
    internal static string UnsupportedBindingProperty;
    internal static string HttpMaxPendingAcceptsTooLargeError;
    internal static string RequestInitializationTimeoutReached;
    internal static string UnsupportedTokenImpersonationLevel;
    internal static string AcksToMustBeSameAsRemoteAddress;
    internal static string AcksToMustBeSameAsRemoteAddressReason;
    internal static string AssertionNotSupported;
    internal static string CloseOutputSessionErrorReason;
    internal static string ConflictingAddress;
    internal static string ConflictingOffer;
    internal static string CouldNotParseWithAction;
    internal static string CSRefused;
    internal static string CSRefusedAcksToMustEqualEndpoint;
    internal static string CSRefusedAcksToMustEqualReplyTo;
    internal static string CSRefusedDuplexNoOffer;
    internal static string CSRefusedInputOffer;
    internal static string CSRefusedInvalidIncompleteSequenceBehavior;
    internal static string CSRefusedNoSTRWSSecurity;
    internal static string CSRefusedReplyNoOffer;
    internal static string CSRefusedRequiredSecurityElementMissing;
    internal static string CSRefusedSSLNotSupported;
    internal static string CSRefusedSTRNoWSSecurity;
    internal static string CSRefusedUnexpectedElementAtEndOfCSMessage;
    internal static string CSResponseOfferRejected;
    internal static string CSResponseOfferRejectedReason;
    internal static string CSResponseWithInvalidIncompleteSequenceBehavior;
    internal static string CSResponseWithOffer;
    internal static string CSResponseWithOfferReason;
    internal static string CSResponseWithoutOffer;
    internal static string CSResponseWithoutOfferReason;
    internal static string DeliveryAssuranceRequiredNothingFound;
    internal static string DeliveryAssuranceRequired;
    internal static string EarlyRequestTerminateSequence;
    internal static string EarlySecurityClose;
    internal static string EarlySecurityFaulted;
    internal static string EarlyTerminateSequence;
    internal static string ElementFound;
    internal static string ElementRequired;
    internal static string InconsistentLastMsgNumberExceptionString;
    internal static string InvalidAcknowledgementFaultReason;
    internal static string InvalidAcknowledgementReceived;
    internal static string InvalidBufferRemaining;
    internal static string InvalidSequenceNumber;
    internal static string InvalidSequenceRange;
    internal static string InvalidWsrmResponseChannelNotOpened;
    internal static string InvalidWsrmResponseSessionFaultedExceptionString;
    internal static string InvalidWsrmResponseSessionFaultedFaultString;
    internal static string LastMessageNumberExceeded;
    internal static string LastMessageNumberExceededFaultReason;
    internal static string ManualAddressingNotSupported;
    internal static string MaximumRetryCountExceeded;
    internal static string MessageExceptionOccurred;
    internal static string MessageNumberRollover;
    internal static string MessageNumberRolloverFaultReason;
    internal static string MillisecondsNotConvertibleToBindingRange;
    internal static string MissingFinalAckExceptionString;
    internal static string MissingMessageIdOnWsrmRequest;
    internal static string MissingRelatesToOnWsrmResponseReason;
    internal static string MissingReplyToOnWsrmRequest;
    internal static string MultipleVersionsFoundInPolicy;
    internal static string NoActionNoSequenceHeaderReason;
    internal static string NonEmptyWsrmMessageIsEmpty;
    internal static string NonWsrmFeb2005ActionNotSupported;
    internal static string NotAllRepliesAcknowledgedExceptionString;
    internal static string ReceivedResponseBeforeRequestExceptionString;
    internal static string ReceivedResponseBeforeRequestFaultString;
    internal static string ReplyMissingAcknowledgement;
    internal static string ReliableRequestContextAborted;
    internal static string RequiredAttributeIsMissing;
    internal static string RequiredMillisecondsAttributeIncorrect;
    internal static string RMEndpointNotFoundReason;
    internal static string SequenceClosedFaultString;
    internal static string SequenceTerminatedAddLastToWindowTimedOut;
    internal static string SequenceTerminatedBeforeReplySequenceAcked;
    internal static string SequenceTerminatedEarlyTerminateSequence;
    internal static string SequenceTerminatedInactivityTimeoutExceeded;
    internal static string SequenceTerminatedInconsistentLastMsgNumber;
    internal static string SequenceTerminatedMaximumRetryCountExceeded;
    internal static string SequenceTerminatedMissingFinalAck;
    internal static string SequenceTerminatedOnAbort;
    internal static string SequenceTerminatedQuotaExceededException;
    internal static string SequenceTerminatedReliableRequestThrew;
    internal static string SequenceTerminatedReplyMissingAcknowledgement;
    internal static string SequenceTerminatedNotAllRepliesAcknowledged;
    internal static string SequenceTerminatedSessionClosedBeforeDone;
    internal static string SequenceTerminatedSmallLastMsgNumber;
    internal static string SequenceTerminatedUnexpectedAcknowledgement;
    internal static string SequenceTerminatedUnexpectedAckRequested;
    internal static string SequenceTerminatedUnexpectedCloseSequence;
    internal static string SequenceTerminatedUnexpectedCloseSequenceResponse;
    internal static string SequenceTerminatedUnexpectedCS;
    internal static string SequenceTerminatedUnexpectedCSOfferId;
    internal static string SequenceTerminatedUnexpectedCSR;
    internal static string SequenceTerminatedUnexpectedCSROfferId;
    internal static string SequenceTerminatedUnexpectedTerminateSequence;
    internal static string SequenceTerminatedUnexpectedTerminateSequenceResponse;
    internal static string SequenceTerminatedUnsupportedClose;
    internal static string SequenceTerminatedUnsupportedTerminateSequence;
    internal static string SequenceTerminatedUnknownAddToWindowError;
    internal static string SmallLastMsgNumberExceptionString;
    internal static string TimeoutOnAddToWindow;
    internal static string TimeoutOnClose;
    internal static string TimeoutOnOpen;
    internal static string TimeoutOnOperation;
    internal static string TimeoutOnRequest;
    internal static string TimeoutOnSend;
    internal static string UnexpectedAcknowledgement;
    internal static string UnexpectedAckRequested;
    internal static string UnexpectedCloseSequence;
    internal static string UnexpectedCloseSequenceResponse;
    internal static string UnexpectedCS;
    internal static string UnexpectedCSR;
    internal static string UnexpectedCSOfferId;
    internal static string UnexpectedCSROfferId;
    internal static string UnexpectedTerminateSequence;
    internal static string UnexpectedTerminateSequenceResponse;
    internal static string UnparsableCSResponse;
    internal static string UnknownSequenceFaultReason;
    internal static string UnknownSequenceFaultReceived;
    internal static string UnknownSequenceMessageReceived;
    internal static string UnrecognizedFaultReceived;
    internal static string UnrecognizedFaultReceivedOnOpen;
    internal static string UnsupportedCloseExceptionString;
    internal static string UnsupportedTerminateSequenceExceptionString;
    internal static string WrongIdentifierFault;
    internal static string WSHttpDoesNotSupportRMWithHttps;
    internal static string WsrmFaultReceived;
    internal static string WsrmMessageProcessingError;
    internal static string WsrmMessageWithWrongRelatesToExceptionString;
    internal static string WsrmMessageWithWrongRelatesToFaultString;
    internal static string WsrmRequestIncorrectReplyToExceptionString;
    internal static string WsrmRequestIncorrectReplyToFaultString;
    internal static string WsrmRequiredExceptionString;
    internal static string WsrmRequiredFaultString;
    internal static string SFxActionDemuxerDuplicate;
    internal static string SFxActionMismatch;
    internal static string SFxAnonymousTypeNotSupported;
    internal static string SFxAsyncResultsDontMatch0;
    internal static string SFXBindingNameCannotBeNullOrEmpty;
    internal static string SFXUnvalidNamespaceValue;
    internal static string SFXUnvalidNamespaceParam;
    internal static string SFXHeaderNameCannotBeNullOrEmpty;
    internal static string SFxEndpointNoMatchingScheme;
    internal static string SFxBindingSchemeDoesNotMatch;
    internal static string SFxGetChannelDispatcherDoesNotSupportScheme;
    internal static string SFxIncorrectMessageVersion;
    internal static string SFxBindingNotSupportedForMetadataHttpGet;
    internal static string SFxBadByReferenceParameterMetadata;
    internal static string SFxBadByValueParameterMetadata;
    internal static string SFxBadMetadataMustBePolicy;
    internal static string SFxBadMetadataLocationUri;
    internal static string SFxBadMetadataLocationNoAppropriateBaseAddress;
    internal static string SFxBadMetadataDialect;
    internal static string SFxBadMetadataReference;
    internal static string SFxMaximumResolvedReferencesOutOfRange;
    internal static string SFxMetadataExchangeClientNoMetadataAddress;
    internal static string SFxMetadataExchangeClientCouldNotCreateChannelFactory;
    internal static string SFxMetadataExchangeClientCouldNotCreateWebRequest;
    internal static string SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme;
    internal static string SFxBadTransactionProtocols;
    internal static string SFxMetadataResolverKnownContractsArgumentCannotBeEmpty;
    internal static string SFxMetadataResolverKnownContractsUniqueQNames;
    internal static string SFxMetadataResolverKnownContractsCannotContainNull;
    internal static string SFxBindingDoesNotHaveATransportBindingElement;
    internal static string SFxBindingMustContainTransport2;
    internal static string SFxBodyCannotBeNull;
    internal static string SFxBodyObjectTypeCannotBeInherited;
    internal static string SFxBodyObjectTypeCannotBeInterface;
    internal static string SFxCallbackBehaviorAttributeOnlyOnDuplex;
    internal static string SFxCallbackRequestReplyInOrder1;
    internal static string SfxCallbackTypeCannotBeNull;
    internal static string SFxCannotActivateCallbackInstace;
    internal static string SFxCannotCallAddBaseAddress;
    internal static string SFxCannotCallAutoOpenWhenExplicitOpenCalled;
    internal static string SFxCannotGetMetadataFromRelativeAddress;
    internal static string SFxCannotHttpGetMetadataFromAddress;
    internal static string SFxCannotGetMetadataFromLocation;
    internal static string SFxCannotHaveDifferentTransactionProtocolsInOneBinding;
    internal static string SFxCannotImportAsParameters_Bare;
    internal static string SFxCannotImportAsParameters_DifferentWrapperNs;
    internal static string SFxCannotImportAsParameters_DifferentWrapperName;
    internal static string SFxCannotImportAsParameters_ElementIsNotNillable;
    internal static string SFxCannotImportAsParameters_MessageHasProtectionLevel;
    internal static string SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded;
    internal static string SFxCannotImportAsParameters_HeadersAreUnsupported;
    internal static string SFxCannotImportAsParameters_Message;
    internal static string SFxCannotImportAsParameters_NamespaceMismatch;
    internal static string SFxCannotRequireBothSessionAndDatagram3;
    internal static string SFxCannotSetExtensionsByIndex;
    internal static string SFxChannelDispatcherDifferentHost0;
    internal static string SFxChannelDispatcherMultipleHost0;
    internal static string SFxChannelDispatcherNoHost0;
    internal static string SFxChannelDispatcherNoMessageVersion;
    internal static string SFxChannelDispatcherUnableToOpen1;
    internal static string SFxChannelDispatcherUnableToOpen2;
    internal static string SFxChannelFactoryTypeMustBeInterface;
    internal static string SFxChannelFactoryCannotApplyConfigurationWithoutEndpoint;
    internal static string SFxChannelFactoryCannotCreateFactoryWithoutDescription;
    internal static string SFxChannelTerminated0;
    internal static string SFxClientOutputSessionAutoClosed;
    internal static string SFxCodeGenArrayTypeIsNotSupported;
    internal static string SFxCodeGenCanOnlyStoreIntoArgOrLocGot0;
    internal static string SFxCodeGenExpectingEnd;
    internal static string SFxCodeGenIsNotAssignableFrom;
    internal static string SFxCodeGenNoConversionPossibleTo;
    internal static string SFxCodeGenWarning;
    internal static string SFxCodeGenUnknownConstantType;
    internal static string SFxCollectionDoesNotSupportSet0;
    internal static string SFxCollectionReadOnly;
    internal static string SFxCollectionWrongType2;
    internal static string SFxConflictingGlobalElement;
    internal static string SFxConflictingGlobalType;
    internal static string SFxContextModifiedInsideScope0;
    internal static string SFxContractDescriptionNameCannotBeEmpty;
    internal static string SFxContractHasZeroOperations;
    internal static string SFxContractHasZeroInitiatingOperations;
    internal static string SFxContractInheritanceRequiresInterfaces;
    internal static string SFxContractInheritanceRequiresInterfaces2;
    internal static string SFxCopyToRequiresICollection;
    internal static string SFxCreateDuplexChannel1;
    internal static string SFxCreateDuplexChannelNoCallback;
    internal static string SFxCreateDuplexChannelNoCallback1;
    internal static string SFxCreateDuplexChannelNoCallbackUserObject;
    internal static string SFxCreateDuplexChannelBadCallbackUserObject;
    internal static string SFxCreateNonDuplexChannel1;
    internal static string SFxCustomBindingNeedsTransport1;
    internal static string SFxCustomBindingWithoutTransport;
    internal static string SFxDeserializationFailed1;
    internal static string SFxDictionaryIsEmpty;
    internal static string SFxDisallowedAttributeCombination;
    internal static string SFxEndpointAddressNotSpecified;
    internal static string SFxEndpointContractNotSpecified;
    internal static string SFxEndpointBindingNotSpecified;
    internal static string SFxInitializationUINotCalled;
    internal static string SFxInitializationUIDisallowed;
    internal static string SFxDocExt_NoMetadataSection1;
    internal static string SFxDocExt_NoMetadataSection2;
    internal static string SFxDocExt_NoMetadataSection3;
    internal static string SFxDocExt_NoMetadataSection4;
    internal static string SFxDocExt_NoMetadataSection5;
    internal static string SFxDocExt_NoMetadataConfigComment1;
    internal static string SFxDocExt_NoMetadataConfigComment2;
    internal static string SFxDocExt_NoMetadataConfigComment3;
    internal static string SFxDocExt_NoMetadataConfigComment4;
    internal static string SFxDocExt_CS;
    internal static string SFxDocExt_VB;
    internal static string SFxDocExt_MainPageTitleNoServiceName;
    internal static string SFxDocExt_MainPageTitle;
    internal static string SFxDocExt_MainPageIntro1a;
    internal static string SFxDocExt_MainPageIntro1b;
    internal static string SFxDocExt_MainPageIntro2;
    internal static string SFxDocExt_MainPageComment;
    internal static string SFxDocExt_MainPageComment2;
    internal static string SFxDocExt_Error;
    internal static string SFxDocEncodedNotSupported;
    internal static string SFxDocEncodedFaultNotSupported;
    internal static string SFxDuplicateMessageParts;
    internal static string SFxDuplicateInitiatingActionAtSameVia;
    internal static string SFXEndpointBehaviorUsedOnWrongSide;
    internal static string SFxEndpointDispatcherMultipleChannelDispatcher0;
    internal static string SFxEndpointDispatcherDifferentChannelDispatcher0;
    internal static string SFxErrorCreatingMtomReader;
    internal static string SFxErrorDeserializingRequestBody;
    internal static string SFxErrorDeserializingRequestBodyMore;
    internal static string SFxErrorDeserializingReplyBody;
    internal static string SFxErrorDeserializingReplyBodyMore;
    internal static string SFxErrorSerializingBody;
    internal static string SFxErrorDeserializingHeader;
    internal static string SFxErrorSerializingHeader;
    internal static string SFxErrorDeserializingFault;
    internal static string SFxErrorReflectingOnType2;
    internal static string SFxErrorReflectingOnMethod3;
    internal static string SFxErrorReflectingOnParameter4;
    internal static string SFxErrorReflectionOnUnknown1;
    internal static string SFxExceptionDetailEndOfInner;
    internal static string SFxExceptionDetailFormat;
    internal static string SFxExpectedIMethodCallMessage;
    internal static string SFxExportMustHaveType;
    internal static string SFxFaultCannotBeImported;
    internal static string SFxFaultContractDuplicateDetailType;
    internal static string SFxFaultContractDuplicateElement;
    internal static string SFxFaultExceptionToString3;
    internal static string SFxFaultReason;
    internal static string SFxFaultTypeAnonymous;
    internal static string SFxHeaderNameMismatchInMessageContract;
    internal static string SFxHeaderNameMismatchInOperation;
    internal static string SFxHeaderNamespaceMismatchInMessageContract;
    internal static string SFxHeaderNamespaceMismatchInOperation;
    internal static string SFxHeaderNotUnderstood;
    internal static string SFxHeadersAreNotSupportedInEncoded;
    internal static string SFxImmutableServiceHostBehavior0;
    internal static string SFxImmutableChannelFactoryBehavior0;
    internal static string SFxImmutableClientBaseCacheSetting;
    internal static string SFxImmutableThrottle1;
    internal static string SFxInconsistentBindingBodyParts;
    internal static string SFxInconsistentWsdlOperationStyleInHeader;
    internal static string SFxInconsistentWsdlOperationStyleInMessageParts;
    internal static string SFxInconsistentWsdlOperationStyleInOperationMessages;
    internal static string SFxInconsistentWsdlOperationUseAndStyleInBinding;
    internal static string SFxInconsistentWsdlOperationUseInBindingExtensions;
    internal static string SFxInconsistentWsdlOperationUseInBindingMessages;
    internal static string SFxInconsistentWsdlOperationUseInBindingFaults;
    internal static string SFxInputParametersToServiceInvalid;
    internal static string SFxInputParametersToServiceNull;
    internal static string SFxInstanceNotInitialized;
    internal static string SFxInterleavedContextScopes0;
    internal static string SFxInternalServerError;
    internal static string SFxInternalCallbackError;
    internal static string SFxInvalidAsyncResultState0;
    internal static string SFxInvalidCallbackIAsyncResult;
    internal static string SFxInvalidCallbackContractType;
    internal static string SFxInvalidChannelToOperationContext;
    internal static string SFxInvalidContextScopeThread0;
    internal static string SFxInvalidMessageBody;
    internal static string SFxInvalidMessageBodyEmptyMessage;
    internal static string SFxInvalidMessageBodyErrorSerializingParameter;
    internal static string SFxInvalidMessageBodyErrorDeserializingParameter;
    internal static string SFxInvalidMessageBodyErrorDeserializingParameterMore;
    internal static string SFxInvalidMessageContractSignature;
    internal static string SFxInvalidMessageHeaderArrayType;
    internal static string SFxInvalidRequestAction;
    internal static string SFxInvalidReplyAction;
    internal static string SFxInvalidStreamInTypedMessage;
    internal static string SFxInvalidStreamInRequest;
    internal static string SFxInvalidStreamInResponse;
    internal static string SFxInvalidStreamOffsetLength;
    internal static string SFxInvalidUseOfPrimitiveOperationFormatter;
    internal static string SFxInvalidStaticOverloadCalledForDuplexChannelFactory1;
    internal static string SFxInvalidSoapAttribute;
    internal static string SFxInvalidXmlAttributeInBare;
    internal static string SFxInvalidXmlAttributeInWrapped;
    internal static string SFxKnownTypeAttributeInvalid1;
    internal static string SFxKnownTypeAttributeReturnType3;
    internal static string SFxKnownTypeAttributeUnknownMethod3;
    internal static string SFxKnownTypeNull;
    internal static string SFxMessageContractBaseTypeNotValid;
    internal static string SFxMessageContractRequiresDefaultConstructor;
    internal static string SFxMessageOperationFormatterCannotSerializeFault;
    internal static string SFxMetadataReferenceInvalidLocation;
    internal static string SFxMethodNotSupported1;
    internal static string SFxMethodNotSupportedOnCallback1;
    internal static string SFxMethodNotSupportedByType2;
    internal static string SFxMismatchedOperationParent;
    internal static string SFxMissingActionHeader;
    internal static string SFxMultipleCallbackFromSynchronizationContext;
    internal static string SFxMultipleCallbackFromAsyncOperation;
    internal static string SFxMultipleUnknownHeaders;
    internal static string SFxMultipleContractStarOperations0;
    internal static string SFxMultipleContractsWithSameName;
    internal static string SFxMultiplePartsNotAllowedInEncoded;
    internal static string SFxNameCannotBeEmpty;
    internal static string SFxConfigurationNameCannotBeEmpty;
    internal static string SFxNeedProxyBehaviorOperationSelector2;
    internal static string SFxNoDefaultConstructor;
    internal static string SFxNoMostDerivedContract;
    internal static string SFxNullReplyFromExtension2;
    internal static string SFxNullReplyFromFormatter2;
    internal static string SFxServiceChannelIdleAborted;
    internal static string SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative;
    internal static string SFxServiceMetadataBehaviorNoHttpBaseAddress;
    internal static string SFxServiceMetadataBehaviorNoHttpsBaseAddress;
    internal static string SFxServiceMetadataBehaviorInstancingError;
    internal static string SFxServiceTypeNotCreatable;
    internal static string SFxSetEnableFaultsOnChannelDispatcher0;
    internal static string SFxSetManualAddresssingOnChannelDispatcher0;
    internal static string SFxNoBatchingForSession;
    internal static string SFxNoBatchingForReleaseOnComplete;
    internal static string SFxNoServiceObject;
    internal static string SFxNone2004;
    internal static string SFxNonExceptionThrown;
    internal static string SFxNonInitiatingOperation1;
    internal static string SfxNoTypeSpecifiedForParameter;
    internal static string SFxOneWayAndTransactionsIncompatible;
    internal static string SFxOneWayMessageToTwoWayMethod0;
    internal static string SFxOperationBehaviorAttributeOnlyOnServiceClass;
    internal static string SFxOperationBehaviorAttributeReleaseInstanceModeDoesNotApplyToCallback;
    internal static string SFxOperationContractOnNonServiceContract;
    internal static string SFxOperationContractProviderOnNonServiceContract;
    internal static string SFxOperationDescriptionNameCannotBeEmpty;
    internal static string SFxParameterNameCannotBeNull;
    internal static string SFxOperationMustHaveOneOrTwoMessages;
    internal static string SFxParameterCountMismatch;
    internal static string SFxParameterMustBeMessage;
    internal static string SFxParametersMustBeEmpty;
    internal static string SFxParameterMustBeArrayOfOneElement;
    internal static string SFxPartNameMustBeUniqueInRpc;
    internal static string SFxReceiveContextSettingsPropertyMissing;
    internal static string SFxReceiveContextPropertyMissing;
    internal static string SFxRequestHasInvalidReplyToOnClient;
    internal static string SFxRequestHasInvalidFaultToOnClient;
    internal static string SFxRequestHasInvalidFromOnClient;
    internal static string SFxRequestHasInvalidReplyToOnServer;
    internal static string SFxRequestHasInvalidFaultToOnServer;
    internal static string SFxRequestHasInvalidFromOnServer;
    internal static string SFxRequestReplyNone;
    internal static string SFxRequestTimedOut1;
    internal static string SFxRequestTimedOut2;
    internal static string SFxReplyActionMismatch3;
    internal static string SFxRequiredRuntimePropertyMissing;
    internal static string SFxResolvedMaxResolvedReferences;
    internal static string SFxResultMustBeMessage;
    internal static string SFxRevertImpersonationFailed0;
    internal static string SFxRpcMessageBodyPartNameInvalid;
    internal static string SFxRpcMessageMustHaveASingleBody;
    internal static string SFxSchemaDoesNotContainElement;
    internal static string SFxSchemaDoesNotContainType;
    internal static string SFxWsdlMessageDoesNotContainPart3;
    internal static string SFxSchemaNotFound;
    internal static string SFxSecurityContextPropertyMissingFromRequestMessage;
    internal static string SFxServerDidNotReply;
    internal static string SFxServiceHostBaseCannotAddEndpointAfterOpen;
    internal static string SFxServiceHostBaseCannotAddEndpointWithoutDescription;
    internal static string SFxServiceHostBaseCannotApplyConfigurationWithoutDescription;
    internal static string SFxServiceHostBaseCannotLoadConfigurationSectionWithoutDescription;
    internal static string SFxServiceHostBaseCannotInitializeRuntimeWithoutDescription;
    internal static string SFxServiceHostCannotCreateDescriptionWithoutServiceType;
    internal static string SFxStaticMessageHeaderPropertiesNotAllowed;
    internal static string SFxStreamIOException;
    internal static string SFxStreamRequestMessageClosed;
    internal static string SFxStreamResponseMessageClosed;
    internal static string SFxTerminatingOperationAlreadyCalled1;
    internal static string SFxThrottleLimitMustBeGreaterThanZero0;
    internal static string SFxTimeoutInvalidStringFormat;
    internal static string SFxTimeoutOutOfRange0;
    internal static string SFxTimeoutOutOfRangeTooBig;
    internal static string SFxTooManyPartsWithSameName;
    internal static string SFxTraceCodeElementIgnored;
    internal static string SfxTransactedBindingNeeded;
    internal static string SFxTransactionNonConcurrentOrAutoComplete2;
    internal static string SFxTransactionNonConcurrentOrReleaseServiceInstanceOnTxComplete;
    internal static string SFxNonConcurrentOrEnsureOrderedDispatch;
    internal static string SfxDispatchRuntimeNonConcurrentOrEnsureOrderedDispatch;
    internal static string SFxTransactionsNotSupported;
    internal static string SFxTransactionAsyncAborted;
    internal static string SFxTransactionInvalidSetTransactionComplete;
    internal static string SFxMultiSetTransactionComplete;
    internal static string SFxTransactionFlowAndMSMQ;
    internal static string SFxTransactionAutoCompleteFalseAndInstanceContextMode;
    internal static string SFxTransactionAutoCompleteFalseOnCallbackContract;
    internal static string SFxTransactionAutoCompleteFalseAndSupportsSession;
    internal static string SFxTransactionAutoCompleteOnSessionCloseNoSession;
    internal static string SFxTransactionTransactionTimeoutNeedsScope;
    internal static string SFxTransactionIsolationLevelNeedsScope;
    internal static string SFxTransactionReleaseServiceInstanceOnTransactionCompleteNeedsScope;
    internal static string SFxTransactionTransactionAutoCompleteOnSessionCloseNeedsScope;
    internal static string SFxTransactionFlowRequired;
    internal static string SFxTransactionUnmarshalFailed;
    internal static string SFxTransactionDeserializationFailed;
    internal static string SFxTransactionHeaderNotUnderstood;
    internal static string SFxTryAddMultipleTransactionsOnMessage;
    internal static string SFxTypedMessageCannotBeNull;
    internal static string SFxTypedMessageCannotBeRpcLiteral;
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithParameters;
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc;
    internal static string SFxUnknownFaultNoMatchingTranslation1;
    internal static string SFxUnknownFaultNullReason0;
    internal static string SFxUnknownFaultZeroReasons0;
    internal static string SFxUserCodeThrewException;
    internal static string SfxUseTypedMessageForCustomAttributes;
    internal static string SFxWellKnownNonSingleton0;
    internal static string SFxVersionMismatchInOperationContextAndMessage2;
    internal static string SFxWhenMultipleEndpointsShareAListenUriTheyMustHaveSameIdentity;
    internal static string SFxWrapperNameCannotBeEmpty;
    internal static string SFxWrapperTypeHasMultipleNamespaces;
    internal static string SFxWsdlPartMustHaveElementOrType;
    internal static string SFxDataContractSerializerDoesNotSupportBareArray;
    internal static string SFxDataContractSerializerDoesNotSupportEncoded;
    internal static string SFxXmlArrayNotAllowedForMultiple;
    internal static string SFxConfigContractNotFound;
    internal static string SFxConfigChannelConfigurationNotFound;
    internal static string SFxChannelFactoryEndpointAddressUri;
    internal static string SFxServiceContractGeneratorConfigRequired;
    internal static string SFxCloseTimedOut1;
    internal static string SfxCloseTimedOutWaitingForDispatchToComplete;
    internal static string SFxInvalidWsdlBindingOpMismatch2;
    internal static string SFxInvalidWsdlBindingOpNoName;
    internal static string SFxChannelFactoryNoBindingFoundInConfig1;
    internal static string SFxChannelFactoryNoBindingFoundInConfigOrCode;
    internal static string SFxConfigLoaderMultipleEndpointMatchesSpecified2;
    internal static string SFxConfigLoaderMultipleEndpointMatchesWildcard1;
    internal static string SFxProxyRuntimeMessageCannotBeNull;
    internal static string SFxDispatchRuntimeMessageCannotBeNull;
    internal static string SFxServiceHostNeedsClass;
    internal static string SfxReflectedContractKeyNotFound2;
    internal static string SfxReflectedContractKeyNotFoundEmpty;
    internal static string SfxReflectedContractKeyNotFoundIMetadataExchange;
    internal static string SfxServiceContractAttributeNotFound;
    internal static string SfxReflectedContractsNotInitialized1;
    internal static string SFxMessagePartDescriptionMissingType;
    internal static string SFxWsdlOperationInputNeedsMessageAttribute2;
    internal static string SFxWsdlOperationOutputNeedsMessageAttribute2;
    internal static string SFxWsdlOperationFaultNeedsMessageAttribute2;
    internal static string SFxMessageContractAttributeRequired;
    internal static string AChannelServiceEndpointIsNull0;
    internal static string AChannelServiceEndpointSBindingIsNull0;
    internal static string AChannelServiceEndpointSContractIsNull0;
    internal static string AChannelServiceEndpointSContractSNameIsNull0;
    internal static string AChannelServiceEndpointSContractSNamespace0;
    internal static string ServiceHasZeroAppEndpoints;
    internal static string BindingRequirementsAttributeRequiresQueuedDelivery1;
    internal static string BindingRequirementsAttributeDisallowsQueuedDelivery1;
    internal static string SinceTheBindingForDoesnTSupportIBindingCapabilities1_1;
    internal static string SinceTheBindingForDoesnTSupportIBindingCapabilities2_1;
    internal static string TheBindingForDoesnTSupportOrderedDelivery1;
    internal static string ChannelHasAtLeastOneOperationWithTransactionFlowEnabled;
    internal static string ServiceHasAtLeastOneOperationWithTransactionFlowEnabled;
    internal static string SFxNoEndpointMatchingContract;
    internal static string SFxNoEndpointMatchingAddress;
    internal static string SFxNoEndpointMatchingAddressForConnectionOpeningMessage;
    internal static string SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled;
    internal static string EndMethodsCannotBeDecoratedWithOperationContractAttribute;
    internal static string WsatMessagingInitializationFailed;
    internal static string WsatProxyCreationFailed;
    internal static string DispatchRuntimeRequiresFormatter0;
    internal static string ClientRuntimeRequiresFormatter0;
    internal static string RuntimeRequiresInvoker0;
    internal static string CouldnTCreateChannelForType2;
    internal static string CouldnTCreateChannelForChannelType2;
    internal static string EndpointListenerRequirementsCannotBeMetBy3;
    internal static string UnknownListenerType1;
    internal static string BindingDoesnTSupportSessionButContractRequires1;
    internal static string BindingDoesntSupportDatagramButContractRequires;
    internal static string BindingDoesnTSupportOneWayButContractRequires1;
    internal static string BindingDoesnTSupportTwoWayButContractRequires1;
    internal static string BindingDoesnTSupportRequestReplyButContract1;
    internal static string BindingDoesnTSupportDuplexButContractRequires1;
    internal static string BindingDoesnTSupportAnyChannelTypes1;
    internal static string ContractIsNotSelfConsistentItHasOneOrMore2;
    internal static string ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled;
    internal static string InstanceSettingsMustHaveTypeOrWellKnownObject0;
    internal static string TheServiceMetadataExtensionInstanceCouldNot2_0;
    internal static string TheServiceMetadataExtensionInstanceCouldNot3_0;
    internal static string TheServiceMetadataExtensionInstanceCouldNot4_0;
    internal static string SynchronizedCollectionWrongType1;
    internal static string SynchronizedCollectionWrongTypeNull;
    internal static string CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0;
    internal static string ItemDoesNotExistInSynchronizedKeyedCollection0;
    internal static string SuppliedMessageIsNotAReplyItHasNoRelatesTo0;
    internal static string channelIsNotAvailable0;
    internal static string channelDoesNotHaveADuplexSession0;
    internal static string EndpointsMustHaveAValidBinding1;
    internal static string ABindingInstanceHasAlreadyBeenAssociatedTo1;
    internal static string UnabletoImportPolicy;
    internal static string UnImportedAssertionList;
    internal static string XPathUnavailable;
    internal static string DuplicatePolicyInWsdlSkipped;
    internal static string DuplicatePolicyDocumentSkipped;
    internal static string PolicyDocumentMustHaveIdentifier;
    internal static string XPathPointer;
    internal static string UnableToFindPolicyWithId;
    internal static string PolicyReferenceInvalidId;
    internal static string PolicyReferenceMissingURI;
    internal static string ExceededMaxPolicyComplexity;
    internal static string ExceededMaxPolicySize;
    internal static string UnrecognizedPolicyElementInNamespace;
    internal static string UnsupportedPolicyDocumentRoot;
    internal static string UnrecognizedPolicyDocumentNamespace;
    internal static string NoUsablePolicyAssertions;
    internal static string PolicyInWsdlMustHaveFragmentId;
    internal static string FailedImportOfWsdl;
    internal static string OptionalWSDLExtensionIgnored;
    internal static string RequiredWSDLExtensionIgnored;
    internal static string UnknownWSDLExtensionIgnored;
    internal static string WsdlExporterIsFaulted;
    internal static string WsdlImporterIsFaulted;
    internal static string WsdlImporterContractMustBeInKnownContracts;
    internal static string WsdlItemAlreadyFaulted;
    internal static string InvalidPolicyExtensionTypeInConfig;
    internal static string PolicyExtensionTypeRequiresDefaultConstructor;
    internal static string PolicyExtensionImportError;
    internal static string PolicyExtensionExportError;
    internal static string MultipleCallsToExportContractWithSameContract;
    internal static string DuplicateContractQNameNameOnExport;
    internal static string WarnDuplicateBindingQNameNameOnExport;
    internal static string WarnSkippingOpertationWithWildcardAction;
    internal static string WarnSkippingOpertationWithSessionOpenNotificationEnabled;
    internal static string InvalidWsdlExtensionTypeInConfig;
    internal static string WsdlExtensionTypeRequiresDefaultConstructor;
    internal static string WsdlExtensionContractExportError;
    internal static string WsdlExtensionEndpointExportError;
    internal static string WsdlExtensionBeforeImportError;
    internal static string WsdlExtensionImportError;
    internal static string WsdlImportErrorMessageDetail;
    internal static string WsdlImportErrorDependencyDetail;
    internal static string UnsupportedEnvelopeVersion;
    internal static string NoValue0;
    internal static string UnsupportedBindingElementClone;
    internal static string UnrecognizedBindingAssertions1;
    internal static string ServicesWithoutAServiceContractAttributeCan2;
    internal static string tooManyAttributesOfTypeOn2;
    internal static string couldnTFindRequiredAttributeOfTypeOn2;
    internal static string AttemptedToGetContractTypeForButThatTypeIs1;
    internal static string NoEndMethodFoundForAsyncBeginMethod3;
    internal static string MoreThanOneEndMethodFoundForAsyncBeginMethod3;
    internal static string InvalidAsyncEndMethodSignatureForMethod2;
    internal static string InvalidAsyncBeginMethodSignatureForMethod2;
    internal static string InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo;
    internal static string InAContractInheritanceHierarchyTheServiceContract3_2;
    internal static string CannotHaveTwoOperationsWithTheSameName3;
    internal static string CannotHaveTwoOperationsWithTheSameElement5;
    internal static string CannotInheritTwoOperationsWithTheSameName3;
    internal static string SyncAsyncMatchConsistency_Parameters5;
    internal static string SyncTaskMatchConsistency_Parameters5;
    internal static string TaskAsyncMatchConsistency_Parameters5;
    internal static string SyncAsyncMatchConsistency_ReturnType5;
    internal static string SyncTaskMatchConsistency_ReturnType5;
    internal static string TaskAsyncMatchConsistency_ReturnType5;
    internal static string SyncAsyncMatchConsistency_Attributes6;
    internal static string SyncTaskMatchConsistency_Attributes6;
    internal static string TaskAsyncMatchConsistency_Attributes6;
    internal static string SyncAsyncMatchConsistency_Property6;
    internal static string SyncTaskMatchConsistency_Property6;
    internal static string TaskAsyncMatchConsistency_Property6;
    internal static string ServiceOperationsMarkedWithIsOneWayTrueMust0;
    internal static string OneWayOperationShouldNotSpecifyAReplyAction1;
    internal static string OneWayAndFaultsIncompatible2;
    internal static string OnlyMalformedMessagesAreSupported;
    internal static string UnableToLocateOperation2;
    internal static string UnsupportedWSDLOnlyOneMessage;
    internal static string UnsupportedWSDLTheFault;
    internal static string AsyncEndCalledOnWrongChannel;
    internal static string AsyncEndCalledWithAnIAsyncResult;
    internal static string IsolationLevelMismatch2;
    internal static string MessageHeaderIsNull0;
    internal static string MessagePropertiesArraySize0;
    internal static string DuplicateBehavior1;
    internal static string CantCreateChannelWithManualAddressing;
    internal static string XsdMissingRequiredAttribute1;
    internal static string IgnoreSoapHeaderBinding3;
    internal static string IgnoreSoapFaultBinding3;
    internal static string IgnoreMessagePart3;
    internal static string CannotImportPrivacyNoticeElementWithoutVersionAttribute;
    internal static string PrivacyNoticeElementVersionAttributeInvalid;
    internal static string MsmqActiveDirectoryRequiresNativeTransfer;
    internal static string MsmqAdvancedPoisonHandlingRequired;
    internal static string MsmqAmbientTransactionInactive;
    internal static string MsmqAuthCertificateRequiresProtectionSign;
    internal static string MsmqAuthNoneRequiresProtectionNone;
    internal static string MsmqAuthWindowsRequiresProtectionNotNone;
    internal static string MsmqBadCertificate;
    internal static string MsmqBadContentType;
    internal static string MsmqBadFrame;
    internal static string MsmqBadXml;
    internal static string MsmqBatchRequiresTransactionScope;
    internal static string MsmqByteArrayBodyExpected;
    internal static string MsmqCannotDeserializeActiveXMessage;
    internal static string MsmqCannotDeserializeXmlMessage;
    internal static string MsmqCannotUseBodyTypeWithActiveXSerialization;
    internal static string MsmqCertificateNotFound;
    internal static string MsmqCustomRequiresPerAppDLQ;
    internal static string MsmqDeserializationError;
    internal static string MsmqDirectFormatNameRequiredForPoison;
    internal static string MsmqDLQNotLocal;
    internal static string MsmqDLQNotWriteable;
    internal static string MsmqEncryptRequiresUseAD;
    internal static string MsmqExactlyOnceNeededForReceiveContext;
    internal static string MsmqGetPrivateComputerInformationError;
    internal static string MsmqInvalidMessageId;
    internal static string MsmqInvalidScheme;
    internal static string MsmqInvalidServiceOperationForMsmqIntegrationBinding;
    internal static string MsmqInvalidTypeDeserialization;
    internal static string MsmqInvalidTypeSerialization;
    internal static string MsmqKnownWin32Error;
    internal static string MsmqMessageDoesntHaveIntegrationProperty;
    internal static string MsmqNoAssurancesForVolatile;
    internal static string MsmqNonNegativeArgumentExpected;
    internal static string MsmqNonTransactionalQueueNeeded;
    internal static string MsmqNoMoveForSubqueues;
    internal static string MsmqNoSid;
    internal static string MsmqOpenError;
    internal static string MsmqPathLookupError;
    internal static string MsmqPerAppDLQRequiresCustom;
    internal static string MsmqPerAppDLQRequiresExactlyOnce;
    internal static string MsmqPerAppDLQRequiresMsmq4;
    internal static string MsmqPoisonMessage;
    internal static string MsmqQueueNotReadable;
    internal static string MsmqReceiveContextMessageNotReceived;
    internal static string MsmqReceiveContextMessageNotMoved;
    internal static string MsmqReceiveContextSubqueuesNotSupported;
    internal static string MsmqReceiveError;
    internal static string MsmqSameTransactionExpected;
    internal static string MsmqSendError;
    internal static string MsmqSerializationTableFull;
    internal static string MsmqSessionChannelAbort;
    internal static string MsmqSessionChannelHasPendingItems;
    internal static string MsmqSessionChannelsMustBeClosed;
    internal static string MsmqSessionGramSizeMustBeInIntegerRange;
    internal static string MsmqSessionMessagesNotConsumed;
    internal static string MsmqSessionPrematureClose;
    internal static string MsmqStreamBodyExpected;
    internal static string MsmqTimeSpanTooLarge;
    internal static string MsmqTokenProviderNeededForCertificates;
    internal static string MsmqTransactionNotActive;
    internal static string MsmqTransactionalQueueNeeded;
    internal static string MsmqTransactionCurrentRequired;
    internal static string MsmqTransactionRequired;
    internal static string MsmqTransactedDLQExpected;
    internal static string MsmqUnexpectedPort;
    internal static string MsmqUnknownWin32Error;
    internal static string MsmqUnsupportedSerializationFormat;
    internal static string MsmqWindowsAuthnRequiresAD;
    internal static string MsmqWrongPrivateQueueSyntax;
    internal static string MsmqWrongUri;
    internal static string MsmqCannotReacquireLock;
    internal static string XDCannotFindValueInDictionaryString;
    internal static string WmiGetObject;
    internal static string WmiPutInstance;
    internal static string ObjectMustBeOpenedToDequeue;
    internal static string NoChannelBuilderAvailable;
    internal static string InvalidBindingScheme;
    internal static string CustomBindingRequiresTransport;
    internal static string TransportBindingElementMustBeLast;
    internal static string MessageVersionMissingFromBinding;
    internal static string NotAllBindingElementsBuilt;
    internal static string MultipleMebesInParameters;
    internal static string MultipleStreamUpgradeProvidersInParameters;
    internal static string MultiplePeerResolverBindingElementsinParameters;
    internal static string MultiplePeerCustomResolverBindingElementsInParameters;
    internal static string SecurityCapabilitiesMismatched;
    internal static string BaseAddressMustBeAbsolute;
    internal static string BaseAddressDuplicateScheme;
    internal static string BaseAddressCannotHaveUserInfo;
    internal static string TransportBindingElementNotFound;
    internal static string ChannelDemuxerBindingElementNotFound;
    internal static string BaseAddressCannotHaveQuery;
    internal static string BaseAddressCannotHaveFragment;
    internal static string UriMustBeAbsolute;
    internal static string BindingProtocolMappingNotDefined;
    internal static string ConfigBindingCannotBeConfigured;
    internal static string ConfigBindingExtensionNotFound;
    internal static string ConfigBindingReferenceCycleDetected;
    internal static string ConfigBindingTypeCannotBeNullOrEmpty;
    internal static string ConfigCannotParseXPathFilter;
    internal static string ConfigEndpointExtensionNotFound;
    internal static string ConfigEndpointReferenceCycleDetected;
    internal static string ConfigEndpointTypeCannotBeNullOrEmpty;
    internal static string ConfigXPathFilterMustNotBeEmpty;
    internal static string ConfigDuplicateItem;
    internal static string ConfigDuplicateExtensionName;
    internal static string ConfigDuplicateExtensionType;
    internal static string ConfigDuplicateKey;
    internal static string ConfigDuplicateKeyAtSameScope;
    internal static string ConfigElementKeyNull;
    internal static string ConfigElementKeysNull;
    internal static string ConfigElementTypeNotAllowed;
    internal static string ConfigExtensionCollectionNotFound;
    internal static string ConfigExtensionTypeNotRegisteredInCollection;
    internal static string ConfigInvalidServiceAuthenticationManagerType;
    internal static string ConfigInvalidAuthorizationPolicyType;
    internal static string ConfigInvalidBindingConfigurationName;
    internal static string ConfigInvalidBindingName;
    internal static string ConfigInvalidCommonEndpointBehaviorType;
    internal static string ConfigInvalidCommonServiceBehaviorType;
    internal static string ConfigInvalidCertificateValidatorType;
    internal static string ConfigInvalidClientCredentialsType;
    internal static string ConfigInvalidClassFactoryValue;
    internal static string ConfigInvalidClassInstanceValue;
    internal static string ConfigInvalidEncodingValue;
    internal static string ConfigInvalidEndpointBehavior;
    internal static string ConfigInvalidEndpointBehaviorType;
    internal static string ConfigInvalidEndpointName;
    internal static string ConfigInvalidAttribute;
    internal static string ConfigNoEndpointCreated;
    internal static string ConfigInvalidExtensionElement;
    internal static string ConfigInvalidExtensionElementName;
    internal static string ConfigInvalidExtensionType;
    internal static string ConfigInvalidKeyType;
    internal static string ConfigInvalidReliableMessagingVersionValue;
    internal static string ConfigInvalidSamlSerializerType;
    internal static string ConfigInvalidSection;
    internal static string ConfigInvalidServiceCredentialsType;
    internal static string ConfigInvalidSecurityStateEncoderType;
    internal static string ConfigInvalidUserNamePasswordValidatorType;
    internal static string ConfigInvalidServiceAuthorizationManagerType;
    internal static string ConfigInvalidServiceBehavior;
    internal static string ConfigInvalidServiceBehaviorType;
    internal static string ConfigInvalidStartValue;
    internal static string ConfigInvalidTransactionFlowProtocolValue;
    internal static string ConfigInvalidType;
    internal static string ConfigInvalidTypeForBinding;
    internal static string ConfigInvalidTypeForBindingElement;
    internal static string ConfigInvalidTypeForEndpoint;
    internal static string ConfigKeyNotFoundInElementCollection;
    internal static string ConfigKeysDoNotMatch;
    internal static string ConfigMessageEncodingAlreadyInBinding;
    internal static string ConfigNoExtensionCollectionAssociatedWithType;
    internal static string ConfigNullIssuerAddress;
    internal static string ConfigReadOnly;
    internal static string ConfigSectionNotFound;
    internal static string ConfigStreamUpgradeElementAlreadyInBinding;
    internal static string ConfigTransportAlreadyInBinding;
    internal static string ConfigXmlElementMustBeSet;
    internal static string ConfigXPathFilterIsNull;
    internal static string ConfigXPathNamespacePrefixNotFound;
    internal static string Default;
    internal static string AdminMTAWorkerThreadException;
    internal static string InternalError;
    internal static string ClsidNotInApplication;
    internal static string ClsidNotInConfiguration;
    internal static string EndpointNotAnIID;
    internal static string ServiceStringFormatError;
    internal static string ContractTypeNotAnIID;
    internal static string ApplicationNotFound;
    internal static string NoVoteIssued;
    internal static string FailedToConvertTypelibraryToAssembly;
    internal static string BadInterfaceVersion;
    internal static string FailedToLoadTypeLibrary;
    internal static string NativeTypeLibraryNotAllowed;
    internal static string InterfaceNotFoundInAssembly;
    internal static string UdtNotFoundInAssembly;
    internal static string UnknownMonikerKeyword;
    internal static string MonikerIncorectSerializer;
    internal static string NoEqualSignFound;
    internal static string KewordMissingValue;
    internal static string BadlyTerminatedValue;
    internal static string MissingQuote;
    internal static string RepeatedKeyword;
    internal static string InterfaceNotFoundInConfig;
    internal static string CannotHaveNullOrEmptyNameOrNamespaceForIID;
    internal static string MethodGivenInConfigNotFoundOnInterface;
    internal static string MonikerIncorrectServerIdentityForMex;
    internal static string MonikerAddressNotSpecified;
    internal static string MonikerMexBindingSectionNameNotSpecified;
    internal static string MonikerMexAddressNotSpecified;
    internal static string MonikerContractNotSpecified;
    internal static string MonikerBindingNotSpecified;
    internal static string MonikerBindingNamespacetNotSpecified;
    internal static string MonikerFailedToDoMexRetrieve;
    internal static string MonikerContractNotFoundInRetreivedMex;
    internal static string MonikerNoneOfTheBindingMatchedTheSpecifiedBinding;
    internal static string MonikerMissingColon;
    internal static string MonikerIncorrectServerIdentity;
    internal static string NoInterface;
    internal static string DuplicateTokenExFailed;
    internal static string AccessCheckFailed;
    internal static string ImpersonateAnonymousTokenFailed;
    internal static string OnlyByRefVariantSafeArraysAllowed;
    internal static string OnlyOneDimensionalSafeArraysAllowed;
    internal static string OnlyVariantTypeElementsAllowed;
    internal static string OnlyZeroLBoundAllowed;
    internal static string OpenThreadTokenFailed;
    internal static string OpenProcessTokenFailed;
    internal static string InvalidIsolationLevelValue;
    internal static string UnsupportedConversion;
    internal static string FailedProxyProviderCreation;
    internal static string UnableToLoadDll;
    internal static string InterfaceNotRegistered;
    internal static string BadInterfaceRegistration;
    internal static string NotAComObject;
    internal static string NoTypeLibraryFoundForInterface;
    internal static string CannotFindClsidInApplication;
    internal static string ComActivationAccessDenied;
    internal static string ComActivationFailure;
    internal static string ComDllHostInitializerFoundNoServices;
    internal static string ComRequiresWindowsSecurity;
    internal static string ComInconsistentSessionRequirements;
    internal static string ComMessageAccessDenied;
    internal static string VariantArrayNull;
    internal static string UnableToRetrievepUnk;
    internal static string PersistWrapperIsNull;
    internal static string UnexpectedThreadingModel;
    internal static string NoneOfTheMethodsForInterfaceFoundInConfig;
    internal static string ComOperationNotFound;
    internal static string InvalidWebServiceInterface;
    internal static string InvalidWebServiceParameter;
    internal static string InvalidWebServiceReturnValue;
    internal static string OnlyClsidsAllowedForServiceType;
    internal static string OperationNotFound;
    internal static string BadDispID;
    internal static string ComNoAsyncOperationsAllowed;
    internal static string ComDuplicateOperation;
    internal static string BadParamCount;
    internal static string BindingNotFoundInConfig;
    internal static string AddressNotSpecified;
    internal static string BindingNotSpecified;
    internal static string OnlyVariantAllowedByRef;
    internal static string CannotResolveTypeForParamInMessageDescription;
    internal static string TooLate;
    internal static string RequireConfiguredMethods;
    internal static string RequireConfiguredInterfaces;
    internal static string CannotCreateChannelOption;
    internal static string NoTransactionInContext;
    internal static string IssuedTokenFlowNotAllowed;
    internal static string GeneralSchemaValidationError;
    internal static string SchemaValidationError;
    internal static string ContractBindingAddressCannotBeNull;
    internal static string TypeLoadForContractTypeIIDFailedWith;
    internal static string BindingLoadFromConfigFailedWith;
    internal static string PooledApplicationNotSupportedForComplusHostedScenarios;
    internal static string RecycledApplicationNotSupportedForComplusHostedScenarios;
    internal static string BadImpersonationLevelForOutOfProcWas;
    internal static string ComPlusInstanceProviderRequiresMessage0;
    internal static string ComPlusInstanceCreationRequestSchema;
    internal static string ComPlusMethodCallSchema;
    internal static string ComPlusServiceSchema;
    internal static string ComPlusServiceSchemaDllHost;
    internal static string ComPlusTLBImportSchema;
    internal static string ComPlusServiceHostStartingServiceErrorNoQFE;
    internal static string ComIntegrationManifestCreationFailed;
    internal static string TempDirectoryNotFound;
    internal static string CannotAccessDirectory;
    internal static string CLSIDDoesNotSupportIPersistStream;
    internal static string CLSIDOfTypeDoesNotMatch;
    internal static string TargetObjectDoesNotSupportIPersistStream;
    internal static string TargetTypeIsAnIntefaceButCorrespoindingTypeIsNotPersistStreamTypeWrapper;
    internal static string NotAllowedPersistableCLSID;
    internal static string TransferringToComplus;
    internal static string NamedArgsNotSupported;
    internal static string MexBindingNotFoundInConfig;
    internal static string ClaimTypeCannotBeEmpty;
    internal static string X509ChainIsEmpty;
    internal static string MissingCustomCertificateValidator;
    internal static string MissingMembershipProvider;
    internal static string MissingCustomUserNamePasswordValidator;
    internal static string SpnegoImpersonationLevelCannotBeSetToNone;
    internal static string PublicKeyNotRSA;
    internal static string SecurityAuditFailToLoadDll;
    internal static string SecurityAuditPlatformNotSupported;
    internal static string NoPrincipalSpecifiedInAuthorizationContext;
    internal static string AccessDenied;
    internal static string SecurityAuditNotSupportedOnChannelFactory;
    internal static string ExpiredTokenInChannelParameters;
    internal static string NoTokenInChannelParameters;
    internal static string PeerMessageMustHaveVia;
    internal static string PeerLinkUtilityInvalidValues;
    internal static string PeerNeighborInvalidState;
    internal static string PeerMaxReceivedMessageSizeConflict;
    internal static string PeerConflictingPeerNodeSettings;
    internal static string ArgumentOutOfRange;
    internal static string PeerChannelViaTooLong;
    internal static string PeerNodeAborted;
    internal static string PeerPnrpNotAvailable;
    internal static string PeerPnrpNotInstalled;
    internal static string PeerResolverBindingElementRequired;
    internal static string PeerResolverRequired;
    internal static string PeerResolverInvalid;
    internal static string PeerResolverSettingsInvalid;
    internal static string PeerListenIPAddressInvalid;
    internal static string PeerFlooderDisposed;
    internal static string PeerPnrpIllegalUri;
    internal static string PeerInvalidRegistrationId;
    internal static string PeerConflictingHeader;
    internal static string PnrpNoClouds;
    internal static string PnrpAddressesUnsupported;
    internal static string InsufficientCryptoSupport;
    internal static string InsufficientCredentials;
    internal static string UnexpectedSecurityTokensDuringHandshake;
    internal static string PnrpAddressesExceedLimit;
    internal static string InsufficientResolverSettings;
    internal static string InvalidResolverMode;
    internal static string MustOverrideInitialize;
    internal static string NotValidWhenOpen;
    internal static string NotValidWhenClosed;
    internal static string PeerNullRegistrationInfo;
    internal static string PeerNullResolveInfo;
    internal static string PeerNullRefreshInfo;
    internal static string PeerInvalidMessageBody;
    internal static string DuplicatePeerRegistration;
    internal static string PeerNodeToStringFormat;
    internal static string MessagePropagationException;
    internal static string NotificationException;
    internal static string ResolverException;
    internal static string PnrpCloudNotFound;
    internal static string PnrpCloudDisabled;
    internal static string PnrpCloudResolveOnly;
    internal static string PnrpPortBlocked;
    internal static string PnrpDuplicatePeerName;
    internal static string RefreshIntervalMustBeGreaterThanZero;
    internal static string CleanupIntervalMustBeGreaterThanZero;
    internal static string AmbiguousConnectivitySpec;
    internal static string MustRegisterMoreThanZeroAddresses;
    internal static string PeerCertGenFailure;
    internal static string PeerThrottleWaiting;
    internal static string PeerThrottlePruning;
    internal static string PeerMaintainerStarting;
    internal static string PeerMaintainerConnect;
    internal static string PeerMaintainerConnectFailure;
    internal static string PeerMaintainerInitialConnect;
    internal static string PeerMaintainerPruneMode;
    internal static string PeerMaintainerConnectMode;
    internal static string BasicHttpContextBindingRequiresAllowCookie;
    internal static string CallbackContextOnlySupportedInWSAddressing10;
    internal static string ListenAddressAlreadyContainsContext;
    internal static string MultipleContextHeadersFoundInCallbackAddress;
    internal static string CallbackContextNotExpectedOnIncomingMessageAtClient;
    internal static string CallbackContextOnlySupportedInSoap;
    internal static string ContextBindingElementCannotProvideChannelFactory;
    internal static string ContextBindingElementCannotProvideChannelListener;
    internal static string InvalidCookieContent;
    internal static string SchemaViolationInsideContextHeader;
    internal static string CallbackContextNotExpectedOnOutgoingMessageAtServer;
    internal static string ChannelIsOpen;
    internal static string ContextManagementNotEnabled;
    internal static string CachedContextIsImmutable;
    internal static string InvalidMessageContext;
    internal static string InvalidContextReceived;
    internal static string BehaviorRequiresContextProtocolSupportInBinding;
    internal static string HttpCookieContextExchangeMechanismNotCompatibleWithTransportType;
    internal static string HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting;
    internal static string PolicyImportContextBindingElementCollectionIsNull;
    internal static string ContextChannelFactoryChannelCreatedDetail;
    internal static string XmlFormatViolationInContextHeader;
    internal static string XmlFormatViolationInCallbackContextHeader;
    internal static string OleTxHeaderCorrupt;
    internal static string WsatHeaderCorrupt;
    internal static string FailedToDeserializeIssuedToken;
    internal static string InvalidPropagationToken;
    internal static string InvalidWsatExtendedInfo;
    internal static string TMCommunicationError;
    internal static string UnmarshalTransactionFaulted;
    internal static string InvalidRegistrationHeaderTransactionId;
    internal static string InvalidRegistrationHeaderIdentifier;
    internal static string InvalidRegistrationHeaderTokenId;
    internal static string InvalidCoordinationContextTransactionId;
    internal static string WsatRegistryValueReadError;
    internal static string WsatProtocolServiceDisabled;
    internal static string InboundTransactionsDisabled;
    internal static string SourceTransactionsDisabled;
    internal static string WsatUriCreationFailed;
    internal static string WhereaboutsReadFailed;
    internal static string WhereaboutsSignatureMissing;
    internal static string WhereaboutsImplausibleProtocolCount;
    internal static string WhereaboutsImplausibleHostNameByteCount;
    internal static string WhereaboutsInvalidHostName;
    internal static string WhereaboutsNoHostName;
    internal static string InvalidWsatProtocolVersion;
    internal static string ParameterCannotBeEmpty;
    internal static string RedirectCache;
    internal static string RedirectResource;
    internal static string RedirectUseIntermediary;
    internal static string RedirectGenericMessage;
    internal static string RedirectMustProvideLocation;
    internal static string RedirectCacheNoLocationAllowed;
    internal static string RedirectionInfoStringFormatWithNamespace;
    internal static string RedirectionInfoStringFormatNoNamespace;
    internal static string RetryGenericMessage;
    internal static string ActivityCallback;
    internal static string ActivityClose;
    internal static string ActivityConstructChannelFactory;
    internal static string ActivityConstructServiceHost;
    internal static string ActivityExecuteMethod;
    internal static string ActivityExecuteAsyncMethod;
    internal static string ActivityCloseChannelFactory;
    internal static string ActivityCloseClientBase;
    internal static string ActivityCloseServiceHost;
    internal static string ActivityListenAt;
    internal static string ActivityOpen;
    internal static string ActivityOpenServiceHost;
    internal static string ActivityOpenChannelFactory;
    internal static string ActivityOpenClientBase;
    internal static string ActivityProcessAction;
    internal static string ActivityProcessingMessage;
    internal static string ActivityReceiveBytes;
    internal static string ActivitySecuritySetup;
    internal static string ActivitySecurityRenew;
    internal static string ActivitySecurityClose;
    internal static string ActivitySharedListenerConnection;
    internal static string ActivitySocketConnection;
    internal static string ActivityReadOnConnection;
    internal static string ActivityReceiveAtVia;
    internal static string TraceCodeBeginExecuteMethod;
    internal static string TraceCodeChannelCreated;
    internal static string TraceCodeChannelDisposed;
    internal static string TraceCodeChannelMessageSent;
    internal static string TraceCodeChannelPreparedMessage;
    internal static string TraceCodeComIntegrationChannelCreated;
    internal static string TraceCodeComIntegrationDispatchMethod;
    internal static string TraceCodeComIntegrationDllHostInitializerAddingHost;
    internal static string TraceCodeComIntegrationDllHostInitializerStarted;
    internal static string TraceCodeComIntegrationDllHostInitializerStarting;
    internal static string TraceCodeComIntegrationDllHostInitializerStopped;
    internal static string TraceCodeComIntegrationDllHostInitializerStopping;
    internal static string TraceCodeComIntegrationEnteringActivity;
    internal static string TraceCodeComIntegrationExecutingCall;
    internal static string TraceCodeComIntegrationInstanceCreationRequest;
    internal static string TraceCodeComIntegrationInstanceCreationSuccess;
    internal static string TraceCodeComIntegrationInstanceReleased;
    internal static string TraceCodeComIntegrationInvokedMethod;
    internal static string TraceCodeComIntegrationInvokingMethod;
    internal static string TraceCodeComIntegrationInvokingMethodContextTransaction;
    internal static string TraceCodeComIntegrationInvokingMethodNewTransaction;
    internal static string TraceCodeComIntegrationLeftActivity;
    internal static string TraceCodeComIntegrationMexChannelBuilderLoaded;
    internal static string TraceCodeComIntegrationMexMonikerMetadataExchangeComplete;
    internal static string TraceCodeComIntegrationServiceHostCreatedServiceContract;
    internal static string TraceCodeComIntegrationServiceHostCreatedServiceEndpoint;
    internal static string TraceCodeComIntegrationServiceHostStartedService;
    internal static string TraceCodeComIntegrationServiceHostStartedServiceDetails;
    internal static string TraceCodeComIntegrationServiceHostStartingService;
    internal static string TraceCodeComIntegrationServiceHostStoppedService;
    internal static string TraceCodeComIntegrationServiceHostStoppingService;
    internal static string TraceCodeComIntegrationServiceMonikerParsed;
    internal static string TraceCodeComIntegrationTLBImportConverterEvent;
    internal static string TraceCodeComIntegrationTLBImportFinished;
    internal static string TraceCodeComIntegrationTLBImportFromAssembly;
    internal static string TraceCodeComIntegrationTLBImportFromTypelib;
    internal static string TraceCodeComIntegrationTLBImportStarting;
    internal static string TraceCodeComIntegrationTxProxyTxAbortedByContext;
    internal static string TraceCodeComIntegrationTxProxyTxAbortedByTM;
    internal static string TraceCodeComIntegrationTxProxyTxCommitted;
    internal static string TraceCodeComIntegrationTypedChannelBuilderLoaded;
    internal static string TraceCodeComIntegrationWsdlChannelBuilderLoaded;
    internal static string TraceCodeCommunicationObjectAborted;
    internal static string TraceCodeCommunicationObjectAbortFailed;
    internal static string TraceCodeCommunicationObjectCloseFailed;
    internal static string TraceCodeCommunicationObjectClosed;
    internal static string TraceCodeCommunicationObjectCreated;
    internal static string TraceCodeCommunicationObjectClosing;
    internal static string TraceCodeCommunicationObjectDisposing;
    internal static string TraceCodeCommunicationObjectFaultReason;
    internal static string TraceCodeCommunicationObjectFaulted;
    internal static string TraceCodeCommunicationObjectOpenFailed;
    internal static string TraceCodeCommunicationObjectOpened;
    internal static string TraceCodeCommunicationObjectOpening;
    internal static string TraceCodeConfigurationIsReadOnly;
    internal static string TraceCodeConfiguredExtensionTypeNotFound;
    internal static string TraceCodeConnectionAbandoned;
    internal static string TraceCodeConnectToIPEndpoint;
    internal static string TraceCodeConnectionPoolCloseException;
    internal static string TraceCodeConnectionPoolIdleTimeoutReached;
    internal static string TraceCodeConnectionPoolLeaseTimeoutReached;
    internal static string TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached;
    internal static string TraceCodeServerMaxPooledConnectionsQuotaReached;
    internal static string TraceCodeDefaultEndpointsAdded;
    internal static string TraceCodeDiagnosticsFailedMessageTrace;
    internal static string TraceCodeDidNotUnderstandMessageHeader;
    internal static string TraceCodeDroppedAMessage;
    internal static string TraceCodeCannotBeImportedInCurrentFormat;
    internal static string TraceCodeElementTypeDoesntMatchConfiguredType;
    internal static string TraceCodeEndExecuteMethod;
    internal static string TraceCodeEndpointListenerClose;
    internal static string TraceCodeEndpointListenerOpen;
    internal static string TraceCodeErrorInvokingUserCode;
    internal static string TraceCodeEvaluationContextNotFound;
    internal static string TraceCodeExportSecurityChannelBindingEntry;
    internal static string TraceCodeExportSecurityChannelBindingExit;
    internal static string TraceCodeExtensionCollectionDoesNotExist;
    internal static string TraceCodeExtensionCollectionIsEmpty;
    internal static string TraceCodeExtensionCollectionNameNotFound;
    internal static string TraceCodeExtensionElementAlreadyExistsInCollection;
    internal static string TraceCodeExtensionTypeNotFound;
    internal static string TraceCodeFailedToAddAnActivityIdHeader;
    internal static string TraceCodeFailedToReadAnActivityIdHeader;
    internal static string TraceCodeFilterNotMatchedNodeQuotaExceeded;
    internal static string TraceCodeGetBehaviorElement;
    internal static string TraceCodeGetChannelEndpointElement;
    internal static string TraceCodeGetCommonBehaviors;
    internal static string TraceCodeGetConfigurationSection;
    internal static string TraceCodeGetConfiguredBinding;
    internal static string TraceCodeGetDefaultConfiguredBinding;
    internal static string TraceCodeGetConfiguredEndpoint;
    internal static string TraceCodeGetDefaultConfiguredEndpoint;
    internal static string TraceCodeGetServiceElement;
    internal static string TraceCodeHttpAuthFailed;
    internal static string TraceCodeHttpActionMismatch;
    internal static string TraceCodeHttpChannelMessageReceiveFailed;
    internal static string TraceCodeHttpChannelRequestAborted;
    internal static string TraceCodeHttpChannelResponseAborted;
    internal static string TraceCodeHttpChannelUnexpectedResponse;
    internal static string TraceCodeHttpResponseReceived;
    internal static string TraceCodeHttpChannelConcurrentReceiveQuotaReached;
    internal static string TraceCodeHttpsClientCertificateInvalid;
    internal static string TraceCodeHttpsClientCertificateInvalid1;
    internal static string TraceCodeHttpsClientCertificateNotPresent;
    internal static string TraceCodeImportSecurityChannelBindingEntry;
    internal static string TraceCodeImportSecurityChannelBindingExit;
    internal static string TraceCodeIncompatibleExistingTransportManager;
    internal static string TraceCodeInitiatingNamedPipeConnection;
    internal static string TraceCodeInitiatingTcpConnection;
    internal static string TraceCodeIssuanceTokenProviderBeginSecurityNegotiation;
    internal static string TraceCodeIssuanceTokenProviderEndSecurityNegotiation;
    internal static string TraceCodeIssuanceTokenProviderRedirectApplied;
    internal static string TraceCodeIssuanceTokenProviderRemovedCachedToken;
    internal static string TraceCodeIssuanceTokenProviderServiceTokenCacheFull;
    internal static string TraceCodeIssuanceTokenProviderUsingCachedToken;
    internal static string TraceCodeListenerCreated;
    internal static string TraceCodeListenerDisposed;
    internal static string TraceCodeMaxPendingConnectionsReached;
    internal static string TraceCodeMaxAcceptedChannelsReached;
    internal static string TraceCodeMessageClosed;
    internal static string TraceCodeMessageClosedAgain;
    internal static string TraceCodeMessageCopied;
    internal static string TraceCodeMessageCountLimitExceeded;
    internal static string TraceCodeMessageNotLoggedQuotaExceeded;
    internal static string TraceCodeMessageRead;
    internal static string TraceCodeMessageSent;
    internal static string TraceCodeMessageReceived;
    internal static string TraceCodeMessageWritten;
    internal static string TraceCodeMessageProcessingPaused;
    internal static string TraceCodeMsmqCannotPeekOnQueue;
    internal static string TraceCodeMsmqCannotReadQueues;
    internal static string TraceCodeMsmqDatagramReceived;
    internal static string TraceCodeMsmqDatagramSent;
    internal static string TraceCodeMsmqDetected;
    internal static string TraceCodeMsmqEnteredBatch;
    internal static string TraceCodeMsmqExpectedException;
    internal static string TraceCodeMsmqFoundBaseAddress;
    internal static string TraceCodeMsmqLeftBatch;
    internal static string TraceCodeMsmqMatchedApplicationFound;
    internal static string TraceCodeMsmqMessageLockedUnderTheTransaction;
    internal static string TraceCodeMsmqMessageDropped;
    internal static string TraceCodeMsmqMessageRejected;
    internal static string TraceCodeMsmqMoveOrDeleteAttemptFailed;
    internal static string TraceCodeMsmqPoisonMessageMovedPoison;
    internal static string TraceCodeMsmqPoisonMessageMovedRetry;
    internal static string TraceCodeMsmqPoisonMessageRejected;
    internal static string TraceCodeMsmqPoolFull;
    internal static string TraceCodeMsmqPotentiallyPoisonMessageDetected;
    internal static string TraceCodeMsmqQueueClosed;
    internal static string TraceCodeMsmqQueueOpened;
    internal static string TraceCodeMsmqQueueTransactionalStatusUnknown;
    internal static string TraceCodeMsmqScanStarted;
    internal static string TraceCodeMsmqSessiongramReceived;
    internal static string TraceCodeMsmqSessiongramSent;
    internal static string TraceCodeMsmqStartingApplication;
    internal static string TraceCodeMsmqStartingService;
    internal static string TraceCodeMsmqUnexpectedAcknowledgment;
    internal static string TraceCodeNamedPipeChannelMessageReceiveFailed;
    internal static string TraceCodeNamedPipeChannelMessageReceived;
    internal static string TraceCodeNegotiationAuthenticatorAttached;
    internal static string TraceCodeNegotiationTokenProviderAttached;
    internal static string TraceCodeNoExistingTransportManager;
    internal static string TraceCodeOpenedListener;
    internal static string TraceCodeOverridingDuplicateConfigurationKey;
    internal static string TraceCodePeerChannelMessageReceived;
    internal static string TraceCodePeerChannelMessageSent;
    internal static string TraceCodePeerFloodedMessageNotMatched;
    internal static string TraceCodePeerFloodedMessageNotPropagated;
    internal static string TraceCodePeerFloodedMessageReceived;
    internal static string TraceCodePeerFlooderReceiveMessageQuotaExceeded;
    internal static string TraceCodePeerNeighborCloseFailed;
    internal static string TraceCodePeerNeighborClosingFailed;
    internal static string TraceCodePeerNeighborManagerOffline;
    internal static string TraceCodePeerNeighborManagerOnline;
    internal static string TraceCodePeerNeighborMessageReceived;
    internal static string TraceCodePeerNeighborNotAccepted;
    internal static string TraceCodePeerNeighborNotFound;
    internal static string TraceCodePeerNeighborOpenFailed;
    internal static string TraceCodePeerNeighborStateChangeFailed;
    internal static string TraceCodePeerNeighborStateChanged;
    internal static string TraceCodePeerNodeAddressChanged;
    internal static string TraceCodePeerNodeAuthenticationFailure;
    internal static string TraceCodePeerNodeAuthenticationTimeout;
    internal static string TraceCodePeerNodeClosed;
    internal static string TraceCodePeerNodeClosing;
    internal static string TraceCodePeerNodeOpenFailed;
    internal static string TraceCodePeerNodeOpened;
    internal static string TraceCodePeerNodeOpening;
    internal static string TraceCodePeerReceiveMessageAuthenticationFailure;
    internal static string TraceCodePeerServiceOpened;
    internal static string TraceCodePerformanceCounterFailedToLoad;
    internal static string TraceCodePerformanceCountersFailed;
    internal static string TraceCodePerformanceCountersFailedDuringUpdate;
    internal static string TraceCodePerformanceCountersFailedForService;
    internal static string TraceCodePerformanceCountersFailedOnRelease;
    internal static string TraceCodePnrpRegisteredAddresses;
    internal static string TraceCodePnrpResolvedAddresses;
    internal static string TraceCodePnrpResolveException;
    internal static string TraceCodePnrpUnregisteredAddresses;
    internal static string TraceCodePrematureDatagramEof;
    internal static string TraceCodePeerMaintainerActivity;
    internal static string TraceCodeReliableChannelOpened;
    internal static string TraceCodeRemoveBehavior;
    internal static string TraceCodeRequestChannelReplyReceived;
    internal static string TraceCodeSecurity;
    internal static string TraceCodeSecurityActiveServerSessionRemoved;
    internal static string TraceCodeSecurityAuditWrittenFailure;
    internal static string TraceCodeSecurityAuditWrittenSuccess;
    internal static string TraceCodeSecurityBindingIncomingMessageVerified;
    internal static string TraceCodeSecurityBindingOutgoingMessageSecured;
    internal static string TraceCodeSecurityBindingSecureOutgoingMessageFailure;
    internal static string TraceCodeSecurityBindingVerifyIncomingMessageFailure;
    internal static string TraceCodeSecurityClientSessionKeyRenewed;
    internal static string TraceCodeSecurityClientSessionCloseSent;
    internal static string TraceCodeSecurityClientSessionCloseResponseSent;
    internal static string TraceCodeSecurityClientSessionCloseMessageReceived;
    internal static string TraceCodeSecurityClientSessionPreviousKeyDiscarded;
    internal static string TraceCodeSecurityContextTokenCacheFull;
    internal static string TraceCodeSecurityIdentityDeterminationFailure;
    internal static string TraceCodeSecurityIdentityDeterminationSuccess;
    internal static string TraceCodeSecurityIdentityHostNameNormalizationFailure;
    internal static string TraceCodeSecurityIdentityVerificationFailure;
    internal static string TraceCodeSecurityIdentityVerificationSuccess;
    internal static string TraceCodeSecurityImpersonationFailure;
    internal static string TraceCodeSecurityImpersonationSuccess;
    internal static string TraceCodeSecurityInactiveSessionFaulted;
    internal static string TraceCodeSecurityNegotiationProcessingFailure;
    internal static string TraceCodeSecurityNewServerSessionKeyIssued;
    internal static string TraceCodeSecurityPendingServerSessionAdded;
    internal static string TraceCodeSecurityPendingServerSessionClosed;
    internal static string TraceCodeSecurityPendingServerSessionActivated;
    internal static string TraceCodeSecurityServerSessionCloseReceived;
    internal static string TraceCodeSecurityServerSessionCloseResponseReceived;
    internal static string TraceCodeSecurityServerSessionAbortedFaultSent;
    internal static string TraceCodeSecurityServerSessionKeyUpdated;
    internal static string TraceCodeSecurityServerSessionRenewalFaultSent;
    internal static string TraceCodeSecuritySessionCloseResponseSent;
    internal static string TraceCodeSecuritySessionServerCloseSent;
    internal static string TraceCodeSecuritySessionAbortedFaultReceived;
    internal static string TraceCodeSecuritySessionAbortedFaultSendFailure;
    internal static string TraceCodeSecuritySessionClosedResponseReceived;
    internal static string TraceCodeSecuritySessionClosedResponseSendFailure;
    internal static string TraceCodeSecuritySessionServerCloseSendFailure;
    internal static string TraceCodeSecuritySessionKeyRenewalFaultReceived;
    internal static string TraceCodeSecuritySessionRedirectApplied;
    internal static string TraceCodeSecuritySessionRenewFaultSendFailure;
    internal static string TraceCodeSecuritySessionRequestorOperationFailure;
    internal static string TraceCodeSecuritySessionRequestorOperationSuccess;
    internal static string TraceCodeSecuritySessionRequestorStartOperation;
    internal static string TraceCodeSecuritySessionResponderOperationFailure;
    internal static string TraceCodeSecuritySpnToSidMappingFailure;
    internal static string TraceCodeSecurityTokenAuthenticatorClosed;
    internal static string TraceCodeSecurityTokenAuthenticatorOpened;
    internal static string TraceCodeSecurityTokenProviderClosed;
    internal static string TraceCodeSecurityTokenProviderOpened;
    internal static string TraceCodeServiceChannelLifetime;
    internal static string TraceCodeServiceHostBaseAddresses;
    internal static string TraceCodeServiceHostTimeoutOnClose;
    internal static string TraceCodeServiceHostFaulted;
    internal static string TraceCodeServiceHostErrorOnReleasePerformanceCounter;
    internal static string TraceCodeServiceThrottleLimitReached;
    internal static string TraceCodeServiceThrottleLimitReachedInternal;
    internal static string TraceCodeManualFlowThrottleLimitReached;
    internal static string TraceCodeProcessMessage2Paused;
    internal static string TraceCodeProcessMessage3Paused;
    internal static string TraceCodeProcessMessage31Paused;
    internal static string TraceCodeProcessMessage4Paused;
    internal static string TraceCodeServiceOperationExceptionOnReply;
    internal static string TraceCodeServiceOperationMissingReply;
    internal static string TraceCodeServiceOperationMissingReplyContext;
    internal static string TraceCodeServiceSecurityNegotiationCompleted;
    internal static string TraceCodeSecuritySessionDemuxFailure;
    internal static string TraceCodeServiceHostCreation;
    internal static string TraceCodePortSharingClosed;
    internal static string TraceCodePortSharingDuplicatedPipe;
    internal static string TraceCodePortSharingDuplicatedSocket;
    internal static string TraceCodePortSharingDupHandleGranted;
    internal static string TraceCodePortSharingListening;
    internal static string TraceCodeSkipBehavior;
    internal static string TraceCodeFailedAcceptFromPool;
    internal static string TraceCodeFailedPipeConnect;
    internal static string TraceCodeSystemTimeResolution;
    internal static string TraceCodeRequestContextAbort;
    internal static string TraceCodePipeConnectionAbort;
    internal static string TraceCodeSharedManagerServiceEndpointNotExist;
    internal static string TraceCodeSocketConnectionAbort;
    internal static string TraceCodeSocketConnectionAbortClose;
    internal static string TraceCodeSocketConnectionClose;
    internal static string TraceCodeSocketConnectionCreate;
    internal static string TraceCodeSpnegoClientNegotiationCompleted;
    internal static string TraceCodeSpnegoServiceNegotiationCompleted;
    internal static string TraceCodeSpnegoClientNegotiation;
    internal static string TraceCodeSpnegoServiceNegotiation;
    internal static string TraceCodeSslClientCertMissing;
    internal static string TraceCodeStreamSecurityUpgradeAccepted;
    internal static string TraceCodeTcpChannelMessageReceiveFailed;
    internal static string TraceCodeTcpChannelMessageReceived;
    internal static string TraceCodeUnderstoodMessageHeader;
    internal static string TraceCodeUnhandledAction;
    internal static string TraceCodeUnhandledExceptionInUserOperation;
    internal static string TraceCodeWebHostFailedToActivateService;
    internal static string TraceCodeWebHostFailedToCompile;
    internal static string TraceCodeWmiPut;
    internal static string TraceCodeWsmexNonCriticalWsdlExportError;
    internal static string TraceCodeWsmexNonCriticalWsdlImportError;
    internal static string TraceCodeFailedToOpenIncomingChannel;
    internal static string TraceCodeTransportListen;
    internal static string TraceCodeWsrmInvalidCreateSequence;
    internal static string TraceCodeWsrmInvalidMessage;
    internal static string TraceCodeWsrmMaxPendingChannelsReached;
    internal static string TraceCodeWsrmMessageDropped;
    internal static string TraceCodeWsrmNegativeElapsedTimeDetected;
    internal static string TraceCodeWsrmReceiveAcknowledgement;
    internal static string TraceCodeWsrmReceiveLastSequenceMessage;
    internal static string TraceCodeWsrmReceiveSequenceMessage;
    internal static string TraceCodeWsrmSendAcknowledgement;
    internal static string TraceCodeWsrmSendLastSequenceMessage;
    internal static string TraceCodeWsrmSendSequenceMessage;
    internal static string TraceCodeWsrmSequenceFaulted;
    internal static string TraceCodeChannelConnectionDropped;
    internal static string TraceCodeAsyncCallbackThrewException;
    internal static string TraceCodeMetadataExchangeClientSendRequest;
    internal static string TraceCodeMetadataExchangeClientReceiveReply;
    internal static string TraceCodeWarnHelpPageEnabledNoBaseAddress;
    internal static string TraceCodeTcpConnectError;
    internal static string TraceCodeTxSourceTxScopeRequiredIsTransactedTransport;
    internal static string TraceCodeTxSourceTxScopeRequiredIsTransactionFlow;
    internal static string TraceCodeTxSourceTxScopeRequiredIsAttachedTransaction;
    internal static string TraceCodeTxSourceTxScopeRequiredUsingExistingTransaction;
    internal static string TraceCodeTxCompletionStatusCompletedForAutocomplete;
    internal static string TraceCodeTxCompletionStatusCompletedForError;
    internal static string TraceCodeTxCompletionStatusCompletedForSetComplete;
    internal static string TraceCodeTxCompletionStatusCompletedForTACOSC;
    internal static string TraceCodeTxCompletionStatusCompletedForAsyncAbort;
    internal static string TraceCodeTxCompletionStatusRemainsAttached;
    internal static string TraceCodeTxCompletionStatusAbortedOnSessionClose;
    internal static string TraceCodeTxReleaseServiceInstanceOnCompletion;
    internal static string TraceCodeTxAsyncAbort;
    internal static string TraceCodeTxFailedToNegotiateOleTx;
    internal static string TraceCodeTxSourceTxScopeRequiredIsCreateNewTransaction;
    internal static string TraceCodeActivatingMessageReceived;
    internal static string TraceCodeDICPInstanceContextCached;
    internal static string TraceCodeDICPInstanceContextRemovedFromCache;
    internal static string TraceCodeInstanceContextBoundToDurableInstance;
    internal static string TraceCodeInstanceContextDetachedFromDurableInstance;
    internal static string TraceCodeContextChannelFactoryChannelCreated;
    internal static string TraceCodeContextChannelListenerChannelAccepted;
    internal static string TraceCodeContextProtocolContextAddedToMessage;
    internal static string TraceCodeContextProtocolContextRetrievedFromMessage;
    internal static string TraceCodeWorkflowServiceHostCreated;
    internal static string TraceCodeServiceDurableInstanceDeleted;
    internal static string TraceCodeServiceDurableInstanceDisposed;
    internal static string TraceCodeServiceDurableInstanceLoaded;
    internal static string TraceCodeServiceDurableInstanceSaved;
    internal static string TraceCodeWorkflowDurableInstanceLoaded;
    internal static string TraceCodeWorkflowDurableInstanceActivated;
    internal static string TraceCodeWorkflowDurableInstanceAborted;
    internal static string TraceCodeWorkflowOperationInvokerItemQueued;
    internal static string TraceCodeWorkflowRequestContextReplySent;
    internal static string TraceCodeWorkflowRequestContextFaultSent;
    internal static string TraceCodeSqlPersistenceProviderSQLCallStart;
    internal static string TraceCodeSqlPersistenceProviderSQLCallEnd;
    internal static string TraceCodeSqlPersistenceProviderOpenParameters;
    internal static string TraceCodeSyncContextSchedulerServiceTimerCancelled;
    internal static string TraceCodeSyncContextSchedulerServiceTimerCreated;
    internal static string TraceCodeSyndicationReadFeedBegin;
    internal static string TraceCodeSyndicationReadFeedEnd;
    internal static string TraceCodeSyndicationReadItemBegin;
    internal static string TraceCodeSyndicationReadItemEnd;
    internal static string TraceCodeSyndicationWriteFeedBegin;
    internal static string TraceCodeSyndicationWriteFeedEnd;
    internal static string TraceCodeSyndicationWriteItemBegin;
    internal static string TraceCodeSyndicationWriteItemEnd;
    internal static string TraceCodeSyndicationProtocolElementIgnoredOnWrite;
    internal static string TraceCodeSyndicationProtocolElementInvalid;
    internal static string TraceCodeWebUnknownQueryParameterIgnored;
    internal static string TraceCodeWebRequestMatchesOperation;
    internal static string TraceCodeWebRequestDoesNotMatchOperations;
    internal static string UTTMustBeAbsolute;
    internal static string UTTBaseAddressMustBeAbsolute;
    internal static string UTTCannotChangeBaseAddress;
    internal static string UTTMultipleMatches;
    internal static string UTTBaseAddressNotSet;
    internal static string UTTEmptyKeyValuePairs;
    internal static string UTBindByPositionWrongCount;
    internal static string UTBadBaseAddress;
    internal static string UTQueryNamesMustBeUnique;
    internal static string UTQueryCannotEndInAmpersand;
    internal static string UTQueryCannotHaveEmptyName;
    internal static string UTVarNamesMustBeUnique;
    internal static string UTTAmbiguousQueries;
    internal static string UTTOtherAmbiguousQueries;
    internal static string UTTDuplicate;
    internal static string UTInvalidFormatSegmentOrQueryPart;
    internal static string BindUriTemplateToNullOrEmptyPathParam;
    internal static string UTBindByPositionNoVariables;
    internal static string UTCSRLookupBeforeMatch;
    internal static string UTDoesNotSupportAdjacentVarsInCompoundSegment;
    internal static string UTQueryCannotHaveCompoundValue;
    internal static string UTQueryMustHaveLiteralNames;
    internal static string UTAdditionalDefaultIsInvalid;
    internal static string UTDefaultValuesAreImmutable;
    internal static string UTDefaultValueToCompoundSegmentVar;
    internal static string UTDefaultValueToQueryVar;
    internal static string UTInvalidDefaultPathValue;
    internal static string UTInvalidVarDeclaration;
    internal static string UTInvalidWildcardInVariableOrLiteral;
    internal static string UTStarVariableWithDefaults;
    internal static string UTDefaultValueToCompoundSegmentVarFromAdditionalDefaults;
    internal static string UTDefaultValueToQueryVarFromAdditionalDefaults;
    internal static string UTNullableDefaultAtAdditionalDefaults;
    internal static string UTNullableDefaultMustBeFollowedWithNullables;
    internal static string UTNullableDefaultMustNotBeFollowedWithLiteral;
    internal static string UTNullableDefaultMustNotBeFollowedWithWildcard;
    internal static string UTStarVariableWithDefaultsFromAdditionalDefaults;
    internal static string UTTInvalidTemplateKey;
    internal static string UTTNullTemplateKey;
    internal static string UTBindByNameCalledWithEmptyKey;
    internal static string UTBothLiteralAndNameValueCollectionKey;
    internal static string ExtensionNameNotSpecified;
    internal static string UnsupportedRssVersion;
    internal static string Atom10SpecRequiresTextConstruct;
    internal static string ErrorInLine;
    internal static string ErrorParsingFeed;
    internal static string ErrorParsingDocument;
    internal static string ErrorParsingItem;
    internal static string ErrorParsingDateTime;
    internal static string OuterElementNameNotSpecified;
    internal static string UnknownFeedXml;
    internal static string UnknownDocumentXml;
    internal static string UnknownItemXml;
    internal static string FeedFormatterDoesNotHaveFeed;
    internal static string DocumentFormatterDoesNotHaveDocument;
    internal static string ItemFormatterDoesNotHaveItem;
    internal static string UnbufferedItemsCannotBeCloned;
    internal static string FeedHasNonContiguousItems;
    internal static string FeedCreatedNullCategory;
    internal static string ItemCreatedNullCategory;
    internal static string FeedCreatedNullPerson;
    internal static string ItemCreatedNullPerson;
    internal static string FeedCreatedNullItem;
    internal static string TraceCodeSyndicationFeedReadBegin;
    internal static string TraceCodeSyndicationFeedReadEnd;
    internal static string TraceCodeSyndicationItemReadBegin;
    internal static string TraceCodeSyndicationItemReadEnd;
    internal static string TraceCodeSyndicationFeedWriteBegin;
    internal static string TraceCodeSyndicationFeedWriteEnd;
    internal static string TraceCodeSyndicationItemWriteBegin;
    internal static string TraceCodeSyndicationItemWriteEnd;
    internal static string TraceCodeSyndicationProtocolElementIgnoredOnRead;
    internal static string TraceCodeSyndicationReadServiceDocumentBegin;
    internal static string TraceCodeSyndicationReadServiceDocumentEnd;
    internal static string TraceCodeSyndicationWriteServiceDocumentBegin;
    internal static string TraceCodeSyndicationWriteServiceDocumentEnd;
    internal static string TraceCodeSyndicationReadCategoriesDocumentBegin;
    internal static string TraceCodeSyndicationReadCategoriesDocumentEnd;
    internal static string TraceCodeSyndicationWriteCategoriesDocumentBegin;
    internal static string TraceCodeSyndicationWriteCategoriesDocumentEnd;
    internal static string FeedAuthorsIgnoredOnWrite;
    internal static string FeedContributorsIgnoredOnWrite;
    internal static string FeedIdIgnoredOnWrite;
    internal static string FeedLinksIgnoredOnWrite;
    internal static string ItemAuthorsIgnoredOnWrite;
    internal static string ItemContributorsIgnoredOnWrite;
    internal static string ItemLinksIgnoredOnWrite;
    internal static string ItemCopyrightIgnoredOnWrite;
    internal static string ItemContentIgnoredOnWrite;
    internal static string ItemLastUpdatedTimeIgnoredOnWrite;
    internal static string OuterNameOfElementExtensionEmpty;
    internal static string InvalidObjectTypePassed;
    internal static string UnableToImpersonateWhileSerializingReponse;
    internal static string XmlLineInfo;
    internal static string XmlFoundEndOfFile;
    internal static string XmlFoundElement;
    internal static string XmlFoundEndElement;
    internal static string XmlFoundText;
    internal static string XmlFoundCData;
    internal static string XmlFoundComment;
    internal static string XmlFoundNodeType;
    internal static string XmlStartElementExpected;
    internal static string SingleWsdlNotGenerated;
    internal static string SFxDocExt_MainPageIntroSingleWsdl;
    internal static string TaskMethodParameterNotSupported;
    internal static string TaskMethodMustNotHaveOutParameter;
    internal static string SFxCannotImportAsParameters_OutputParameterAndTask;
    internal static string ID0020;
    internal static string ID2004;
    internal static string ID3002;
    internal static string ID3004;
    internal static string ID3022;
    internal static string ID3023;
    internal static string ID3097;
    internal static string ID3112;
    internal static string ID3113;
    internal static string ID3114;
    internal static string ID3137;
    internal static string ID3138;
    internal static string ID3139;
    internal static string ID3140;
    internal static string ID3141;
    internal static string ID3144;
    internal static string ID3146;
    internal static string ID3147;
    internal static string ID3148;
    internal static string ID3149;
    internal static string ID3150;
    internal static string ID3190;
    internal static string ID3191;
    internal static string ID3192;
    internal static string ID3193;
    internal static string ID3194;
    internal static string ID3269;
    internal static string ID3270;
    internal static string ID3285;
    internal static string ID3286;
    internal static string ID3287;
    internal static string ID4008;
    internal static string ID4039;
    internal static string ID4041;
    internal static string ID4053;
    internal static string ID4072;
    internal static string ID4101;
    internal static string ID4192;
    internal static string ID4240;
    internal static string ID4244;
    internal static string ID4245;
    internal static string ID4268;
    internal static string ID4271;
    internal static string ID4274;
    internal static string ID4285;
    internal static string ID4287;
    internal static string ID5004;
    internal static string TraceAuthorize;
    internal static string TraceOnAuthorizeRequestFailed;
    internal static string TraceOnAuthorizeRequestSucceed;
    internal static string AuthFailed;
    internal static string DuplicateFederatedClientCredentialsParameters;
    internal static string UnsupportedTrustVersion;
    internal static string InputMustBeDelegatingHandlerElementError;
    internal static string InputTypeListEmptyError;
    internal static string DelegatingHandlerArrayHasNonNullInnerHandler;
    internal static string DelegatingHandlerArrayFromFuncContainsNullItem;
    internal static string HttpMessageHandlerFactoryConfigInvalid_WithBothTypeAndHandlerList;
    internal static string HttpMessageHandlerFactoryWithFuncCannotGenerateConfig;
    internal static string HttpMessageHandlerTypeNotSupported;
    internal static string HttpMessageHandlerChannelFactoryNullPipeline;
    internal static string HttpPipelineOperationCanceledError;
    internal static string HttpPipelineMessagePropertyMissingError;
    internal static string HttpPipelineMessagePropertyTypeError;
    internal static string InvalidContentTypeError;
    internal static string HttpPipelineNotSupportedOnClientSide;
    internal static string CanNotLoadTypeGotFromConfig;
    internal static string HttpPipelineNotSupportNullResponseMessage;
    internal static string WebSocketInvalidProtocolNoHeader;
    internal static string WebSocketInvalidProtocolNotInClientList;
    internal static string WebSocketInvalidProtocolInvalidCharInProtocolString;
    internal static string WebSocketInvalidProtocolContainsMultipleSubProtocolString;
    internal static string WebSocketInvalidProtocolEmptySubprotocolString;
    internal static string WebSocketOpaqueStreamContentNotSupportError;
    internal static string WebSocketElementConfigInvalidHttpMessageHandlerFactoryType;
    internal static string WebSocketEndpointOnlySupportWebSocketError;
    internal static string WebSocketEndpointDoesNotSupportWebSocketError;
    internal static string WebSocketUpgradeFailedError;
    internal static string WebSocketUpgradeFailedHeaderMissingError;
    internal static string WebSocketUpgradeFailedWrongHeaderError;
    internal static string WebSocketUpgradeFailedInvalidProtocolError;
    internal static string WebSocketContextWebSocketCannotBeAccessedError;
    internal static string WebSocketTransportError;
    internal static string WebSocketUnexpectedCloseMessageError;
    internal static string WebSocketStreamWriteCalledAfterEOMSent;
    internal static string WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage;
    internal static string WebSocketMaxPendingConnectionsReached;
    internal static string WebSocketOpeningHandshakePropertiesNotAvailable;
    internal static string AcceptWebSocketTimedOutError;
    internal static string TaskCancelledError;
    internal static string ClientWebSocketFactory_GetWebSocketVersionFailed;
    internal static string ClientWebSocketFactory_InvalidWebSocketVersion;
    internal static string ClientWebSocketFactory_CreateWebSocketFailed;
    internal static string ClientWebSocketFactory_InvalidWebSocket;
    internal static string ClientWebSocketFactory_InvalidSubProtocol;
    internal static string MultipleClientWebSocketFactoriesSpecified;
    internal static string WebSocketSendTimedOut;
    internal static string WebSocketReceiveTimedOut;
    internal static string WebSocketOperationTimedOut;
    internal static string WebSocketsServerSideNotSupported;
    internal static string WebSocketsClientSideNotSupported;
    internal static string WebSocketsNotSupportedInClassicPipeline;
    internal static string WebSocketModuleNotLoaded;
    internal static string WebSocketTransportPolicyAssertionInvalid;
    internal static string WebSocketVersionMismatchFromServer;
    internal static string WebSocketSubProtocolMismatchFromServer;
    internal static string WebSocketContentTypeMismatchFromServer;
    internal static string WebSocketContentTypeAndTransferModeMismatchFromServer;
    internal static string ResponseHeaderWithRequestHeadersCollection;
    internal static string RequestHeaderWithResponseHeadersCollection;
    internal static string MessageVersionNoneRequiredForHttpMessageSupport;
    internal static string WebHeaderEnumOperationCantHappen;
    internal static string WebHeaderEmptyStringCall;
    internal static string WebHeaderInvalidControlChars;
    internal static string WebHeaderInvalidCRLFChars;
    internal static string WebHeaderInvalidHeaderChars;
    internal static string WebHeaderInvalidNonAsciiChars;
    internal static string WebHeaderArgumentOutOfRange;
    internal static string CopyHttpHeaderFailed;
    public static ResourceManager Resources { get; }
    private static SR();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class System.ServiceModel.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.ServiceModel.SRDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal static class System.ServiceModel.StringUtil : object {
    private static StringUtil();
    internal static int GetNonRandomizedHashCode(string str);
}
internal class System.ServiceModel.SynchronizedDisposablePool`1 : object {
    public SynchronizedDisposablePool`1(int maxCount);
    public sealed virtual void Dispose();
    public bool Return(T value);
    public T Take();
}
internal static class System.ServiceModel.Syndication.App10Constants : object {
    public static string Accept;
    public static string Categories;
    public static string Collection;
    public static string Fixed;
    public static string Href;
    public static string Namespace;
    public static string Prefix;
    public static string Service;
    public static string Workspace;
}
internal static class System.ServiceModel.Syndication.Atom10Constants : object {
    public static string AlternateTag;
    public static string Atom10Namespace;
    public static string Atom10Prefix;
    public static string AtomMediaType;
    public static string AuthorTag;
    public static string CategoryTag;
    public static string ContentTag;
    public static string ContributorTag;
    public static string EmailTag;
    public static string EntryTag;
    public static string FeedTag;
    public static string GeneratorTag;
    public static string HrefTag;
    public static string HtmlMediaType;
    public static string HtmlType;
    public static string IdTag;
    public static string LabelTag;
    public static string LengthTag;
    public static string LinkTag;
    public static string LogoTag;
    public static string NameTag;
    public static string PlaintextType;
    public static string PublishedTag;
    public static string RelativeTag;
    public static string RightsTag;
    public static string SchemeTag;
    public static string SelfTag;
    public static string SourceFeedTag;
    public static string SourceTag;
    public static string SpecificationLink;
    public static string SubtitleTag;
    public static string SummaryTag;
    public static string TermTag;
    public static string TitleTag;
    public static string TypeTag;
    public static string UpdatedTag;
    public static string UriTag;
    public static string XHtmlMediaType;
    public static string XHtmlType;
    public static string XmlMediaType;
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Atom10FeedFormatter : SyndicationFeedFormatter {
    internal static TimeSpan zeroOffset;
    internal static string XmlNs;
    internal static string XmlNsNs;
    public bool PreserveAttributeExtensions { get; public set; }
    public bool PreserveElementExtensions { get; public set; }
    public string Version { get; }
    protected Type FeedType { get; }
    public Atom10FeedFormatter(Type feedTypeToCreate);
    public Atom10FeedFormatter(SyndicationFeed feedToWrite);
    private static Atom10FeedFormatter();
    public bool get_PreserveAttributeExtensions();
    public void set_PreserveAttributeExtensions(bool value);
    public bool get_PreserveElementExtensions();
    public void set_PreserveElementExtensions(bool value);
    public virtual string get_Version();
    protected Type get_FeedType();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    internal static void ReadCategory(XmlReader reader, SyndicationCategory category, string version, bool preserveAttributeExtensions, bool preserveElementExtensions, int maxExtensionSize);
    internal static TextSyndicationContent ReadTextContentFrom(XmlReader reader, string context, bool preserveAttributeExtensions);
    internal static void WriteCategory(XmlWriter writer, SyndicationCategory category, string version);
    internal void ReadItemFrom(XmlReader reader, SyndicationItem result);
    internal bool TryParseFeedElementFrom(XmlReader reader, SyndicationFeed result);
    internal bool TryParseItemElementFrom(XmlReader reader, SyndicationItem result);
    internal void WriteContentTo(XmlWriter writer, string elementName, SyndicationContent content);
    internal void WriteElement(XmlWriter writer, string elementName, string value);
    internal void WriteFeedAuthorsTo(XmlWriter writer, Collection`1<SyndicationPerson> authors);
    internal void WriteFeedContributorsTo(XmlWriter writer, Collection`1<SyndicationPerson> contributors);
    internal void WriteFeedLastUpdatedTimeTo(XmlWriter writer, DateTimeOffset lastUpdatedTime, bool isRequired);
    internal void WriteItemAuthorsTo(XmlWriter writer, Collection`1<SyndicationPerson> authors);
    internal void WriteItemContents(XmlWriter dictWriter, SyndicationItem item);
    internal void WriteItemContributorsTo(XmlWriter writer, Collection`1<SyndicationPerson> contributors);
    internal void WriteItemLastUpdatedTimeTo(XmlWriter writer, DateTimeOffset lastUpdatedTime);
    internal void WriteLink(XmlWriter writer, SyndicationLink link, Uri baseUri);
    protected virtual SyndicationFeed CreateFeedInstance();
    protected virtual SyndicationItem ReadItem(XmlReader reader, SyndicationFeed feed);
    protected virtual IEnumerable`1<SyndicationItem> ReadItems(XmlReader reader, SyndicationFeed feed, Boolean& areAllItemsRead);
    protected virtual void WriteItem(XmlWriter writer, SyndicationItem item, Uri feedBaseUri);
    protected virtual void WriteItems(XmlWriter writer, IEnumerable`1<SyndicationItem> items, Uri feedBaseUri);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Atom10FeedFormatter`1 : Atom10FeedFormatter {
    public Atom10FeedFormatter`1(TSyndicationFeed feedToWrite);
    protected virtual SyndicationFeed CreateFeedInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Atom10ItemFormatter : SyndicationItemFormatter {
    public bool PreserveAttributeExtensions { get; public set; }
    public bool PreserveElementExtensions { get; public set; }
    public string Version { get; }
    protected Type ItemType { get; }
    public Atom10ItemFormatter(Type itemTypeToCreate);
    public Atom10ItemFormatter(SyndicationItem itemToWrite);
    public bool get_PreserveAttributeExtensions();
    public void set_PreserveAttributeExtensions(bool value);
    public bool get_PreserveElementExtensions();
    public void set_PreserveElementExtensions(bool value);
    public virtual string get_Version();
    protected Type get_ItemType();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    protected virtual SyndicationItem CreateItemInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Atom10ItemFormatter`1 : Atom10ItemFormatter {
    public Atom10ItemFormatter`1(TSyndicationItem itemToWrite);
    protected virtual SyndicationItem CreateItemInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.AtomPub10CategoriesDocumentFormatter : CategoriesDocumentFormatter {
    public string Version { get; }
    public AtomPub10CategoriesDocumentFormatter(Type inlineDocumentType, Type referencedDocumentType);
    public AtomPub10CategoriesDocumentFormatter(CategoriesDocument documentToWrite);
    public virtual string get_Version();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    internal static void TraceCategoriesDocumentReadBegin();
    internal static void TraceCategoriesDocumentReadEnd();
    internal static void TraceCategoriesDocumentWriteBegin();
    internal static void TraceCategoriesDocumentWriteEnd();
    protected virtual InlineCategoriesDocument CreateInlineCategoriesDocument();
    protected virtual ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.AtomPub10ServiceDocumentFormatter : ServiceDocumentFormatter {
    public string Version { get; }
    public AtomPub10ServiceDocumentFormatter(Type documentTypeToCreate);
    public AtomPub10ServiceDocumentFormatter(ServiceDocument documentToWrite);
    public virtual string get_Version();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    internal static CategoriesDocument ReadCategories(XmlReader reader, Uri baseUri, CreateInlineCategoriesDelegate inlineCategoriesFactory, CreateReferencedCategoriesDelegate referencedCategoriesFactory, string version, bool preserveElementExtensions, bool preserveAttributeExtensions, int maxExtensionSize);
    internal static void TraceServiceDocumentReadBegin();
    internal static void TraceServiceDocumentReadEnd();
    internal static void TraceServiceDocumentWriteBegin();
    internal static void TraceServiceDocumentWriteEnd();
    internal static void WriteCategoriesInnerXml(XmlWriter writer, CategoriesDocument categories, Uri baseUri, string version);
    protected virtual ServiceDocument CreateDocumentInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.AtomPub10ServiceDocumentFormatter`1 : AtomPub10ServiceDocumentFormatter {
    public AtomPub10ServiceDocumentFormatter`1(TServiceDocument documentToWrite);
    protected virtual ServiceDocument CreateDocumentInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public abstract class System.ServiceModel.Syndication.CategoriesDocument : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Uri BaseUri { get; public set; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Language { get; public set; }
    internal bool IsInline { get; }
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Language();
    public void set_Language(string value);
    internal abstract virtual bool get_IsInline();
    public static InlineCategoriesDocument Create(Collection`1<SyndicationCategory> categories);
    public static InlineCategoriesDocument Create(Collection`1<SyndicationCategory> categories, bool isFixed, string scheme);
    public static ReferencedCategoriesDocument Create(Uri linkToCategoriesDocument);
    public static CategoriesDocument Load(XmlReader reader);
    public CategoriesDocumentFormatter GetFormatter();
    public void Save(XmlWriter writer);
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[DataContractAttribute]
public abstract class System.ServiceModel.Syndication.CategoriesDocumentFormatter : object {
    public CategoriesDocument Document { get; }
    public string Version { get; }
    protected CategoriesDocumentFormatter(CategoriesDocument documentToWrite);
    public CategoriesDocument get_Document();
    public abstract virtual string get_Version();
    public abstract virtual bool CanRead(XmlReader reader);
    public abstract virtual void ReadFrom(XmlReader reader);
    public abstract virtual void WriteTo(XmlWriter writer);
    protected virtual InlineCategoriesDocument CreateInlineCategoriesDocument();
    protected virtual ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
    protected virtual void SetDocument(CategoriesDocument document);
}
internal class System.ServiceModel.Syndication.CreateInlineCategoriesDelegate : MulticastDelegate {
    public CreateInlineCategoriesDelegate(object object, IntPtr method);
    public virtual InlineCategoriesDocument Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual InlineCategoriesDocument EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Syndication.CreateReferencedCategoriesDelegate : MulticastDelegate {
    public CreateReferencedCategoriesDelegate(object object, IntPtr method);
    public virtual ReferencedCategoriesDocument Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual ReferencedCategoriesDocument EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Syndication.ExtensibleSyndicationObject : ValueType {
    private Dictionary`2<XmlQualifiedName, string> attributeExtensions;
    private SyndicationElementExtensionCollection elementExtensions;
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
    internal void WriteAttributeExtensions(XmlWriter writer);
    internal void WriteElementExtensions(XmlWriter writer);
    public ExtensibleSyndicationObject Clone();
}
internal static class System.ServiceModel.Syndication.FeedUtils : object {
    public static string AddLineInfo(XmlReader reader, string error);
    internal static Collection`1<SyndicationCategory> CloneCategories(Collection`1<SyndicationCategory> categories);
    internal static Collection`1<SyndicationLink> CloneLinks(Collection`1<SyndicationLink> links);
    internal static Collection`1<SyndicationPerson> ClonePersons(Collection`1<SyndicationPerson> persons);
    internal static TextSyndicationContent CloneTextContent(TextSyndicationContent content);
    internal static Uri CombineXmlBase(Uri rootBase, string newBase);
    internal static Uri GetBaseUriToWrite(Uri rootBase, Uri currentBase);
    internal static string GetUriString(Uri uri);
    internal static bool IsXmlns(string name, string ns);
    internal static bool IsXmlSchemaType(string name, string ns);
}
internal interface System.ServiceModel.Syndication.IExtensibleSyndicationObject {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public abstract virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public abstract virtual SyndicationElementExtensionCollection get_ElementExtensions();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.InlineCategoriesDocument : CategoriesDocument {
    public Collection`1<SyndicationCategory> Categories { get; }
    public bool IsFixed { get; public set; }
    public string Scheme { get; public set; }
    internal bool IsInline { get; }
    public InlineCategoriesDocument(IEnumerable`1<SyndicationCategory> categories);
    public InlineCategoriesDocument(IEnumerable`1<SyndicationCategory> categories, bool isFixed, string scheme);
    public Collection`1<SyndicationCategory> get_Categories();
    public bool get_IsFixed();
    public void set_IsFixed(bool value);
    public string get_Scheme();
    public void set_Scheme(string value);
    internal virtual bool get_IsInline();
    protected internal virtual SyndicationCategory CreateCategory();
}
internal class System.ServiceModel.Syndication.NullNotAllowedCollection`1 : Collection`1<TCollectionItem> {
    protected virtual void InsertItem(int index, TCollectionItem item);
    protected virtual void SetItem(int index, TCollectionItem item);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.ReferencedCategoriesDocument : CategoriesDocument {
    public Uri Link { get; public set; }
    internal bool IsInline { get; }
    public ReferencedCategoriesDocument(Uri link);
    public Uri get_Link();
    public void set_Link(Uri value);
    internal virtual bool get_IsInline();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.ResourceCollectionInfo : object {
    public Collection`1<string> Accepts { get; }
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Uri BaseUri { get; public set; }
    public Collection`1<CategoriesDocument> Categories { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public Uri Link { get; public set; }
    public TextSyndicationContent Title { get; public set; }
    public ResourceCollectionInfo(string title, Uri link);
    public ResourceCollectionInfo(TextSyndicationContent title, Uri link);
    public ResourceCollectionInfo(TextSyndicationContent title, Uri link, IEnumerable`1<CategoriesDocument> categories, bool allowsNewEntries);
    public ResourceCollectionInfo(TextSyndicationContent title, Uri link, IEnumerable`1<CategoriesDocument> categories, IEnumerable`1<string> accepts);
    public Collection`1<string> get_Accepts();
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public Collection`1<CategoriesDocument> get_Categories();
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public Uri get_Link();
    public void set_Link(Uri value);
    public TextSyndicationContent get_Title();
    public void set_Title(TextSyndicationContent value);
    protected internal virtual InlineCategoriesDocument CreateInlineCategoriesDocument();
    protected internal virtual ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
internal static class System.ServiceModel.Syndication.Rss20Constants : object {
    public static string AuthorTag;
    public static string CategoryTag;
    public static string ChannelTag;
    public static string CopyrightTag;
    public static string DescriptionTag;
    public static string DomainTag;
    public static string EnclosureTag;
    public static string ExtensionWrapperTag;
    public static string GeneratorTag;
    public static string GuidTag;
    public static string ImageTag;
    public static string IsPermaLinkTag;
    public static string ItemTag;
    public static string LanguageTag;
    public static string LastBuildDateTag;
    public static string LengthTag;
    public static string LinkTag;
    public static string ManagingEditorTag;
    public static string PubDateTag;
    public static string Rss20Namespace;
    public static string RssTag;
    public static string SourceTag;
    public static string SpecificationLink;
    public static string TitleTag;
    public static string TypeTag;
    public static string UrlTag;
    public static string Version;
    public static string VersionTag;
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Rss20FeedFormatter : SyndicationFeedFormatter {
    public bool PreserveAttributeExtensions { get; public set; }
    public bool PreserveElementExtensions { get; public set; }
    public bool SerializeExtensionsAsAtom { get; public set; }
    public string Version { get; }
    protected Type FeedType { get; }
    public Rss20FeedFormatter(Type feedTypeToCreate);
    public Rss20FeedFormatter(SyndicationFeed feedToWrite);
    public Rss20FeedFormatter(SyndicationFeed feedToWrite, bool serializeExtensionsAsAtom);
    private static Rss20FeedFormatter();
    public bool get_PreserveAttributeExtensions();
    public void set_PreserveAttributeExtensions(bool value);
    public bool get_PreserveElementExtensions();
    public void set_PreserveElementExtensions(bool value);
    public bool get_SerializeExtensionsAsAtom();
    public void set_SerializeExtensionsAsAtom(bool value);
    public virtual string get_Version();
    protected Type get_FeedType();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    protected internal virtual void SetFeed(SyndicationFeed feed);
    internal static void TraceExtensionsIgnoredOnWrite(string message);
    internal void ReadItemFrom(XmlReader reader, SyndicationItem result);
    internal void WriteItemContents(XmlWriter writer, SyndicationItem item);
    protected virtual SyndicationFeed CreateFeedInstance();
    protected virtual SyndicationItem ReadItem(XmlReader reader, SyndicationFeed feed);
    protected virtual IEnumerable`1<SyndicationItem> ReadItems(XmlReader reader, SyndicationFeed feed, Boolean& areAllItemsRead);
    protected virtual void WriteItem(XmlWriter writer, SyndicationItem item, Uri feedBaseUri);
    protected virtual void WriteItems(XmlWriter writer, IEnumerable`1<SyndicationItem> items, Uri feedBaseUri);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Rss20FeedFormatter`1 : Rss20FeedFormatter {
    public Rss20FeedFormatter`1(TSyndicationFeed feedToWrite);
    public Rss20FeedFormatter`1(TSyndicationFeed feedToWrite, bool serializeExtensionsAsAtom);
    protected virtual SyndicationFeed CreateFeedInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Rss20ItemFormatter : SyndicationItemFormatter {
    public bool PreserveAttributeExtensions { get; public set; }
    public bool PreserveElementExtensions { get; public set; }
    public bool SerializeExtensionsAsAtom { get; public set; }
    public string Version { get; }
    protected Type ItemType { get; }
    public Rss20ItemFormatter(Type itemTypeToCreate);
    public Rss20ItemFormatter(SyndicationItem itemToWrite);
    public Rss20ItemFormatter(SyndicationItem itemToWrite, bool serializeExtensionsAsAtom);
    public bool get_PreserveAttributeExtensions();
    public void set_PreserveAttributeExtensions(bool value);
    public bool get_PreserveElementExtensions();
    public void set_PreserveElementExtensions(bool value);
    public bool get_SerializeExtensionsAsAtom();
    public void set_SerializeExtensionsAsAtom(bool value);
    public virtual string get_Version();
    protected Type get_ItemType();
    public virtual bool CanRead(XmlReader reader);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual void ReadFrom(XmlReader reader);
    public virtual void WriteTo(XmlWriter writer);
    protected virtual SyndicationItem CreateItemInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[XmlRootAttribute]
public class System.ServiceModel.Syndication.Rss20ItemFormatter`1 : Rss20ItemFormatter {
    public Rss20ItemFormatter`1(TSyndicationItem itemToWrite);
    public Rss20ItemFormatter`1(TSyndicationItem itemToWrite, bool serializeExtensionsAsAtom);
    protected virtual SyndicationItem CreateItemInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.ServiceDocument : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Uri BaseUri { get; public set; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Language { get; public set; }
    public Collection`1<Workspace> Workspaces { get; }
    public ServiceDocument(IEnumerable`1<Workspace> workspaces);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Language();
    public void set_Language(string value);
    public Collection`1<Workspace> get_Workspaces();
    public static ServiceDocument Load(XmlReader reader);
    public static TServiceDocument Load(XmlReader reader);
    public ServiceDocumentFormatter GetFormatter();
    public void Save(XmlWriter writer);
    protected internal virtual Workspace CreateWorkspace();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[DataContractAttribute]
public abstract class System.ServiceModel.Syndication.ServiceDocumentFormatter : object {
    public ServiceDocument Document { get; }
    public string Version { get; }
    protected ServiceDocumentFormatter(ServiceDocument documentToWrite);
    public ServiceDocument get_Document();
    public abstract virtual string get_Version();
    public abstract virtual bool CanRead(XmlReader reader);
    public abstract virtual void ReadFrom(XmlReader reader);
    public abstract virtual void WriteTo(XmlWriter writer);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, CategoriesDocument categories);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, ResourceCollectionInfo collection);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, Workspace workspace);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, ServiceDocument document);
    protected static SyndicationCategory CreateCategory(InlineCategoriesDocument inlineCategories);
    protected static ResourceCollectionInfo CreateCollection(Workspace workspace);
    protected static InlineCategoriesDocument CreateInlineCategories(ResourceCollectionInfo collection);
    protected static ReferencedCategoriesDocument CreateReferencedCategories(ResourceCollectionInfo collection);
    protected static Workspace CreateWorkspace(ServiceDocument document);
    protected static void LoadElementExtensions(XmlReader reader, CategoriesDocument categories, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, ResourceCollectionInfo collection, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, Workspace workspace, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, ServiceDocument document, int maxExtensionSize);
    protected static bool TryParseAttribute(string name, string ns, string value, ServiceDocument document, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, ResourceCollectionInfo collection, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, CategoriesDocument categories, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, Workspace workspace, string version);
    protected static bool TryParseElement(XmlReader reader, ResourceCollectionInfo collection, string version);
    protected static bool TryParseElement(XmlReader reader, ServiceDocument document, string version);
    protected static bool TryParseElement(XmlReader reader, Workspace workspace, string version);
    protected static bool TryParseElement(XmlReader reader, CategoriesDocument categories, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, ServiceDocument document, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, Workspace workspace, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, ResourceCollectionInfo collection, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, CategoriesDocument categories, string version);
    protected static void WriteElementExtensions(XmlWriter writer, ServiceDocument document, string version);
    protected static void WriteElementExtensions(XmlWriter writer, Workspace workspace, string version);
    protected static void WriteElementExtensions(XmlWriter writer, ResourceCollectionInfo collection, string version);
    protected static void WriteElementExtensions(XmlWriter writer, CategoriesDocument categories, string version);
    protected virtual ServiceDocument CreateDocumentInstance();
    protected virtual void SetDocument(ServiceDocument document);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationCategory : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Label { get; public set; }
    public string Name { get; public set; }
    public string Scheme { get; public set; }
    public SyndicationCategory(string name);
    public SyndicationCategory(string name, string scheme, string label);
    protected SyndicationCategory(SyndicationCategory source);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Label();
    public void set_Label(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public virtual SyndicationCategory Clone();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public abstract class System.ServiceModel.Syndication.SyndicationContent : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public string Type { get; }
    protected SyndicationContent(SyndicationContent source);
    public Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public abstract virtual string get_Type();
    public static TextSyndicationContent CreateHtmlContent(string content);
    public static TextSyndicationContent CreatePlaintextContent(string content);
    public static UrlSyndicationContent CreateUrlContent(Uri url, string mediaType);
    public static TextSyndicationContent CreateXhtmlContent(string content);
    public static XmlSyndicationContent CreateXmlContent(object dataContractObject);
    public static XmlSyndicationContent CreateXmlContent(object dataContractObject, XmlObjectSerializer dataContractSerializer);
    public static XmlSyndicationContent CreateXmlContent(XmlReader xmlReader);
    public static XmlSyndicationContent CreateXmlContent(object xmlSerializerObject, XmlSerializer serializer);
    public abstract virtual SyndicationContent Clone();
    public void WriteTo(XmlWriter writer, string outerElementName, string outerElementNamespace);
    internal void CopyAttributeExtensions(SyndicationContent source);
    protected abstract virtual void WriteContentsTo(XmlWriter writer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationElementExtension : object {
    public string OuterName { get; }
    public string OuterNamespace { get; }
    public SyndicationElementExtension(XmlReader xmlReader);
    public SyndicationElementExtension(object dataContractExtension);
    public SyndicationElementExtension(object dataContractExtension, XmlObjectSerializer dataContractSerializer);
    public SyndicationElementExtension(string outerName, string outerNamespace, object dataContractExtension);
    public SyndicationElementExtension(string outerName, string outerNamespace, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
    public SyndicationElementExtension(object xmlSerializerExtension, XmlSerializer serializer);
    internal SyndicationElementExtension(XmlBuffer buffer, int bufferElementIndex, string outerName, string outerNamespace);
    public string get_OuterName();
    public string get_OuterNamespace();
    public TExtension GetObject();
    public TExtension GetObject(XmlObjectSerializer serializer);
    public TExtension GetObject(XmlSerializer serializer);
    public XmlReader GetReader();
    public void WriteTo(XmlWriter writer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationElementExtensionCollection : Collection`1<SyndicationElementExtension> {
    internal SyndicationElementExtensionCollection(XmlBuffer buffer);
    internal SyndicationElementExtensionCollection(SyndicationElementExtensionCollection source);
    public void Add(object extension);
    public void Add(string outerName, string outerNamespace, object dataContractExtension);
    public void Add(object dataContractExtension, DataContractSerializer serializer);
    public void Add(string outerName, string outerNamespace, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
    public void Add(object xmlSerializerExtension, XmlSerializer serializer);
    public void Add(XmlReader xmlReader);
    public XmlReader GetReaderAtElementExtensions();
    public Collection`1<TExtension> ReadElementExtensions(string extensionName, string extensionNamespace);
    public Collection`1<TExtension> ReadElementExtensions(string extensionName, string extensionNamespace, XmlObjectSerializer serializer);
    public Collection`1<TExtension> ReadElementExtensions(string extensionName, string extensionNamespace, XmlSerializer serializer);
    internal void WriteTo(XmlWriter writer);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SyndicationElementExtension item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SyndicationElementExtension item);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationFeed : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Collection`1<SyndicationPerson> Authors { get; }
    public Uri BaseUri { get; public set; }
    public Collection`1<SyndicationCategory> Categories { get; }
    public Collection`1<SyndicationPerson> Contributors { get; }
    public TextSyndicationContent Copyright { get; public set; }
    public TextSyndicationContent Description { get; public set; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Generator { get; public set; }
    public string Id { get; public set; }
    public Uri ImageUrl { get; public set; }
    public IEnumerable`1<SyndicationItem> Items { get; public set; }
    public string Language { get; public set; }
    public DateTimeOffset LastUpdatedTime { get; public set; }
    public Collection`1<SyndicationLink> Links { get; }
    public TextSyndicationContent Title { get; public set; }
    public SyndicationFeed(IEnumerable`1<SyndicationItem> items);
    public SyndicationFeed(string title, string description, Uri feedAlternateLink);
    public SyndicationFeed(string title, string description, Uri feedAlternateLink, IEnumerable`1<SyndicationItem> items);
    public SyndicationFeed(string title, string description, Uri feedAlternateLink, string id, DateTimeOffset lastUpdatedTime);
    public SyndicationFeed(string title, string description, Uri feedAlternateLink, string id, DateTimeOffset lastUpdatedTime, IEnumerable`1<SyndicationItem> items);
    protected SyndicationFeed(SyndicationFeed source, bool cloneItems);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Collection`1<SyndicationPerson> get_Authors();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public Collection`1<SyndicationCategory> get_Categories();
    public Collection`1<SyndicationPerson> get_Contributors();
    public TextSyndicationContent get_Copyright();
    public void set_Copyright(TextSyndicationContent value);
    public TextSyndicationContent get_Description();
    public void set_Description(TextSyndicationContent value);
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Generator();
    public void set_Generator(string value);
    public string get_Id();
    public void set_Id(string value);
    public Uri get_ImageUrl();
    public void set_ImageUrl(Uri value);
    public IEnumerable`1<SyndicationItem> get_Items();
    public void set_Items(IEnumerable`1<SyndicationItem> value);
    public string get_Language();
    public void set_Language(string value);
    public DateTimeOffset get_LastUpdatedTime();
    public void set_LastUpdatedTime(DateTimeOffset value);
    public Collection`1<SyndicationLink> get_Links();
    public TextSyndicationContent get_Title();
    public void set_Title(TextSyndicationContent value);
    public static SyndicationFeed Load(XmlReader reader);
    public static TSyndicationFeed Load(XmlReader reader);
    public virtual SyndicationFeed Clone(bool cloneItems);
    public Atom10FeedFormatter GetAtom10Formatter();
    public Rss20FeedFormatter GetRss20Formatter();
    public Rss20FeedFormatter GetRss20Formatter(bool serializeExtensionsAsAtom);
    public void SaveAsAtom10(XmlWriter writer);
    public void SaveAsRss20(XmlWriter writer);
    protected internal virtual SyndicationCategory CreateCategory();
    protected internal virtual SyndicationItem CreateItem();
    protected internal virtual SyndicationLink CreateLink();
    protected internal virtual SyndicationPerson CreatePerson();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[DataContractAttribute]
public abstract class System.ServiceModel.Syndication.SyndicationFeedFormatter : object {
    public SyndicationFeed Feed { get; }
    public string Version { get; }
    protected SyndicationFeedFormatter(SyndicationFeed feedToWrite);
    public SyndicationFeed get_Feed();
    public abstract virtual string get_Version();
    public abstract virtual bool CanRead(XmlReader reader);
    public abstract virtual void ReadFrom(XmlReader reader);
    public virtual string ToString();
    public abstract virtual void WriteTo(XmlWriter writer);
    protected internal static SyndicationCategory CreateCategory(SyndicationFeed feed);
    protected internal static SyndicationCategory CreateCategory(SyndicationItem item);
    protected internal static SyndicationItem CreateItem(SyndicationFeed feed);
    protected internal static SyndicationLink CreateLink(SyndicationFeed feed);
    protected internal static SyndicationLink CreateLink(SyndicationItem item);
    protected internal static SyndicationPerson CreatePerson(SyndicationFeed feed);
    protected internal static SyndicationPerson CreatePerson(SyndicationItem item);
    protected internal static void LoadElementExtensions(XmlReader reader, SyndicationFeed feed, int maxExtensionSize);
    protected internal static void LoadElementExtensions(XmlReader reader, SyndicationItem item, int maxExtensionSize);
    protected internal static void LoadElementExtensions(XmlReader reader, SyndicationCategory category, int maxExtensionSize);
    protected internal static void LoadElementExtensions(XmlReader reader, SyndicationLink link, int maxExtensionSize);
    protected internal static void LoadElementExtensions(XmlReader reader, SyndicationPerson person, int maxExtensionSize);
    protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationFeed feed, string version);
    protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationItem item, string version);
    protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationCategory category, string version);
    protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationLink link, string version);
    protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationPerson person, string version);
    protected internal static bool TryParseContent(XmlReader reader, SyndicationItem item, string contentType, string version, SyndicationContent& content);
    protected internal static bool TryParseElement(XmlReader reader, SyndicationFeed feed, string version);
    protected internal static bool TryParseElement(XmlReader reader, SyndicationItem item, string version);
    protected internal static bool TryParseElement(XmlReader reader, SyndicationCategory category, string version);
    protected internal static bool TryParseElement(XmlReader reader, SyndicationLink link, string version);
    protected internal static bool TryParseElement(XmlReader reader, SyndicationPerson person, string version);
    protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationFeed feed, string version);
    protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationItem item, string version);
    protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationCategory category, string version);
    protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationLink link, string version);
    protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationPerson person, string version);
    protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationFeed feed, string version);
    protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationItem item, string version);
    protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationCategory category, string version);
    protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationLink link, string version);
    protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationPerson person, string version);
    protected internal virtual void SetFeed(SyndicationFeed feed);
    internal static void CloseBuffer(XmlBuffer buffer, XmlDictionaryWriter extWriter);
    internal static void CreateBufferIfRequiredAndWriteNode(XmlBuffer& buffer, XmlDictionaryWriter& extWriter, XmlReader reader, int maxExtensionSize);
    internal static SyndicationFeed CreateFeedInstance(Type feedType);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationFeed feed);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationItem item);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationCategory category);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationLink link);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationPerson person);
    internal static void MoveToStartElement(XmlReader reader);
    internal static void TraceFeedReadBegin();
    internal static void TraceFeedReadEnd();
    internal static void TraceFeedWriteBegin();
    internal static void TraceFeedWriteEnd();
    internal static void TraceItemReadBegin();
    internal static void TraceItemReadEnd();
    internal static void TraceItemWriteBegin();
    internal static void TraceItemWriteEnd();
    internal static void TraceSyndicationElementIgnoredOnRead(XmlReader reader);
    protected abstract virtual SyndicationFeed CreateFeedInstance();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationItem : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Collection`1<SyndicationPerson> Authors { get; }
    public Uri BaseUri { get; public set; }
    public Collection`1<SyndicationCategory> Categories { get; }
    public SyndicationContent Content { get; public set; }
    public Collection`1<SyndicationPerson> Contributors { get; }
    public TextSyndicationContent Copyright { get; public set; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Id { get; public set; }
    public DateTimeOffset LastUpdatedTime { get; public set; }
    public Collection`1<SyndicationLink> Links { get; }
    public DateTimeOffset PublishDate { get; public set; }
    public SyndicationFeed SourceFeed { get; public set; }
    public TextSyndicationContent Summary { get; public set; }
    public TextSyndicationContent Title { get; public set; }
    public SyndicationItem(string title, string content, Uri itemAlternateLink);
    public SyndicationItem(string title, string content, Uri itemAlternateLink, string id, DateTimeOffset lastUpdatedTime);
    public SyndicationItem(string title, SyndicationContent content, Uri itemAlternateLink, string id, DateTimeOffset lastUpdatedTime);
    protected SyndicationItem(SyndicationItem source);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Collection`1<SyndicationPerson> get_Authors();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public Collection`1<SyndicationCategory> get_Categories();
    public SyndicationContent get_Content();
    public void set_Content(SyndicationContent value);
    public Collection`1<SyndicationPerson> get_Contributors();
    public TextSyndicationContent get_Copyright();
    public void set_Copyright(TextSyndicationContent value);
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Id();
    public void set_Id(string value);
    public DateTimeOffset get_LastUpdatedTime();
    public void set_LastUpdatedTime(DateTimeOffset value);
    public Collection`1<SyndicationLink> get_Links();
    public DateTimeOffset get_PublishDate();
    public void set_PublishDate(DateTimeOffset value);
    public SyndicationFeed get_SourceFeed();
    public void set_SourceFeed(SyndicationFeed value);
    public TextSyndicationContent get_Summary();
    public void set_Summary(TextSyndicationContent value);
    public TextSyndicationContent get_Title();
    public void set_Title(TextSyndicationContent value);
    public static SyndicationItem Load(XmlReader reader);
    public static TSyndicationItem Load(XmlReader reader);
    public void AddPermalink(Uri permalink);
    public virtual SyndicationItem Clone();
    public Atom10ItemFormatter GetAtom10Formatter();
    public Rss20ItemFormatter GetRss20Formatter();
    public Rss20ItemFormatter GetRss20Formatter(bool serializeExtensionsAsAtom);
    public void SaveAsAtom10(XmlWriter writer);
    public void SaveAsRss20(XmlWriter writer);
    protected internal virtual SyndicationCategory CreateCategory();
    protected internal virtual SyndicationLink CreateLink();
    protected internal virtual SyndicationPerson CreatePerson();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseContent(XmlReader reader, string contentType, string version, SyndicationContent& content);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[DataContractAttribute]
public abstract class System.ServiceModel.Syndication.SyndicationItemFormatter : object {
    public SyndicationItem Item { get; }
    public string Version { get; }
    protected SyndicationItemFormatter(SyndicationItem itemToWrite);
    public SyndicationItem get_Item();
    public abstract virtual string get_Version();
    public abstract virtual bool CanRead(XmlReader reader);
    public abstract virtual void ReadFrom(XmlReader reader);
    public virtual string ToString();
    public abstract virtual void WriteTo(XmlWriter writer);
    protected internal virtual void SetItem(SyndicationItem item);
    internal static void CreateBufferIfRequiredAndWriteNode(XmlBuffer& buffer, XmlDictionaryWriter& extWriter, XmlDictionaryReader reader, int maxExtensionSize);
    internal static SyndicationItem CreateItemInstance(Type itemType);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationItem item);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationCategory category);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationLink link);
    internal static void LoadElementExtensions(XmlBuffer buffer, XmlDictionaryWriter writer, SyndicationPerson person);
    protected static SyndicationCategory CreateCategory(SyndicationItem item);
    protected static SyndicationLink CreateLink(SyndicationItem item);
    protected static SyndicationPerson CreatePerson(SyndicationItem item);
    protected static void LoadElementExtensions(XmlReader reader, SyndicationItem item, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, SyndicationCategory category, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, SyndicationLink link, int maxExtensionSize);
    protected static void LoadElementExtensions(XmlReader reader, SyndicationPerson person, int maxExtensionSize);
    protected static bool TryParseAttribute(string name, string ns, string value, SyndicationItem item, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, SyndicationCategory category, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, SyndicationLink link, string version);
    protected static bool TryParseAttribute(string name, string ns, string value, SyndicationPerson person, string version);
    protected static bool TryParseContent(XmlReader reader, SyndicationItem item, string contentType, string version, SyndicationContent& content);
    protected static bool TryParseElement(XmlReader reader, SyndicationItem item, string version);
    protected static bool TryParseElement(XmlReader reader, SyndicationCategory category, string version);
    protected static bool TryParseElement(XmlReader reader, SyndicationLink link, string version);
    protected static bool TryParseElement(XmlReader reader, SyndicationPerson person, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationItem item, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationCategory category, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationLink link, string version);
    protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationPerson person, string version);
    protected static void WriteElementExtensions(XmlWriter writer, SyndicationItem item, string version);
    protected abstract virtual SyndicationItem CreateItemInstance();
    protected void WriteElementExtensions(XmlWriter writer, SyndicationCategory category, string version);
    protected void WriteElementExtensions(XmlWriter writer, SyndicationLink link, string version);
    protected void WriteElementExtensions(XmlWriter writer, SyndicationPerson person, string version);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationLink : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Uri BaseUri { get; public set; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public long Length { get; public set; }
    public string MediaType { get; public set; }
    public string RelationshipType { get; public set; }
    public string Title { get; public set; }
    public Uri Uri { get; public set; }
    public SyndicationLink(Uri uri);
    public SyndicationLink(Uri uri, string relationshipType, string title, string mediaType, long length);
    protected SyndicationLink(SyndicationLink source);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public long get_Length();
    public void set_Length(long value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_RelationshipType();
    public void set_RelationshipType(string value);
    public string get_Title();
    public void set_Title(string value);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    public static SyndicationLink CreateAlternateLink(Uri uri);
    public static SyndicationLink CreateAlternateLink(Uri uri, string mediaType);
    public static SyndicationLink CreateMediaEnclosureLink(Uri uri, string mediaType, long length);
    public static SyndicationLink CreateSelfLink(Uri uri);
    public static SyndicationLink CreateSelfLink(Uri uri, string mediaType);
    public virtual SyndicationLink Clone();
    public Uri GetAbsoluteUri();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.SyndicationPerson : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public string Email { get; public set; }
    public string Name { get; public set; }
    public string Uri { get; public set; }
    public SyndicationPerson(string email);
    public SyndicationPerson(string email, string name, string uri);
    protected SyndicationPerson(SyndicationPerson source);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public string get_Email();
    public void set_Email(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Uri();
    public void set_Uri(string value);
    public virtual SyndicationPerson Clone();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public static class System.ServiceModel.Syndication.SyndicationVersions : object {
    public static string Atom10;
    public static string Rss20;
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.TextSyndicationContent : SyndicationContent {
    public string Text { get; }
    public string Type { get; }
    public TextSyndicationContent(string text);
    public TextSyndicationContent(string text, TextSyndicationContentKind textKind);
    protected TextSyndicationContent(TextSyndicationContent source);
    public string get_Text();
    public virtual string get_Type();
    public virtual SyndicationContent Clone();
    protected virtual void WriteContentsTo(XmlWriter writer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public enum System.ServiceModel.Syndication.TextSyndicationContentKind : Enum {
    public int value__;
    public static TextSyndicationContentKind Plaintext;
    public static TextSyndicationContentKind Html;
    public static TextSyndicationContentKind XHtml;
}
internal static class System.ServiceModel.Syndication.TextSyndicationContentKindHelper : object {
    public static bool IsDefined(TextSyndicationContentKind kind);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.UrlSyndicationContent : SyndicationContent {
    public string Type { get; }
    public Uri Url { get; }
    public UrlSyndicationContent(Uri url, string mediaType);
    protected UrlSyndicationContent(UrlSyndicationContent source);
    public virtual string get_Type();
    public Uri get_Url();
    public virtual SyndicationContent Clone();
    protected virtual void WriteContentsTo(XmlWriter writer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.Workspace : object {
    public Dictionary`2<XmlQualifiedName, string> AttributeExtensions { get; }
    public Uri BaseUri { get; public set; }
    public Collection`1<ResourceCollectionInfo> Collections { get; }
    public SyndicationElementExtensionCollection ElementExtensions { get; }
    public TextSyndicationContent Title { get; public set; }
    public Workspace(string title, IEnumerable`1<ResourceCollectionInfo> collections);
    public Workspace(TextSyndicationContent title, IEnumerable`1<ResourceCollectionInfo> collections);
    public sealed virtual Dictionary`2<XmlQualifiedName, string> get_AttributeExtensions();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public Collection`1<ResourceCollectionInfo> get_Collections();
    public sealed virtual SyndicationElementExtensionCollection get_ElementExtensions();
    public TextSyndicationContent get_Title();
    public void set_Title(TextSyndicationContent value);
    protected internal virtual ResourceCollectionInfo CreateResourceCollection();
    protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
    protected internal virtual bool TryParseElement(XmlReader reader, string version);
    protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
    protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
    internal void LoadElementExtensions(XmlReader readerOverUnparsedExtensions, int maxExtensionSize);
    internal void LoadElementExtensions(XmlBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.Syndication.XmlSyndicationContent : SyndicationContent {
    public SyndicationElementExtension Extension { get; }
    public string Type { get; }
    public XmlSyndicationContent(XmlReader reader);
    public XmlSyndicationContent(string type, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
    public XmlSyndicationContent(string type, object xmlSerializerExtension, XmlSerializer serializer);
    public XmlSyndicationContent(string type, SyndicationElementExtension extension);
    protected XmlSyndicationContent(XmlSyndicationContent source);
    public SyndicationElementExtension get_Extension();
    public virtual string get_Type();
    public virtual SyndicationContent Clone();
    public XmlDictionaryReader GetReaderAtContent();
    public TContent ReadContent();
    public TContent ReadContent(XmlObjectSerializer dataContractSerializer);
    public TContent ReadContent(XmlSerializer serializer);
    protected virtual void WriteContentsTo(XmlWriter writer);
}
public enum System.ServiceModel.TcpClientCredentialType : Enum {
    public int value__;
    public static TcpClientCredentialType None;
    public static TcpClientCredentialType Windows;
    public static TcpClientCredentialType Certificate;
}
internal static class System.ServiceModel.TcpClientCredentialTypeHelper : object {
    internal static bool IsDefined(TcpClientCredentialType value);
}
public class System.ServiceModel.TcpTransportSecurity : object {
    internal static TcpClientCredentialType DefaultClientCredentialType;
    internal static ProtectionLevel DefaultProtectionLevel;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TcpClientCredentialType ClientCredentialType { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ProtectionLevel { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SslProtocols SslProtocols { get; public set; }
    public TcpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(TcpClientCredentialType value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    internal BindingElement CreateTransportProtectionOnly();
    internal static bool SetTransportProtectionOnly(BindingElement transport, TcpTransportSecurity transportSecurity);
    internal BindingElement CreateTransportProtectionAndAuthentication();
    internal static bool SetTransportProtectionAndAuthentication(BindingElement transport, TcpTransportSecurity transportSecurity);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeExtendedProtectionPolicy();
}
internal class System.ServiceModel.TelemetryEventSource : EventSource {
    public static EventKeywords Reserved44Keyword;
    public static EventKeywords TelemetryKeyword;
    public static EventKeywords MeasuresKeyword;
    public static EventKeywords CriticalDataKeyword;
    public static EventTags CoreData;
    public static EventTags InjectXToken;
    public static EventTags RealtimeLatency;
    public static EventTags NormalLatency;
    public static EventTags CriticalPersistence;
    public static EventTags NormalPersistence;
    public static EventTags DropPii;
    public static EventTags HashPii;
    public static EventTags MarkPii;
    public static EventFieldTags DropPiiField;
    public static EventFieldTags HashPiiField;
    public TelemetryEventSource(string eventSourceName);
    private static TelemetryEventSource();
    public static EventSourceOptions MeasuresOptions();
}
internal class System.ServiceModel.TelemetryHelper : object {
    public string GetHostType();
    public string GetEndpoints(ServiceDescription description);
    public string GetServiceId(ServiceDescription description);
}
internal class System.ServiceModel.TelemetryTraceLogging : object {
    private static TelemetryTraceLogging();
    public static void LogSeriveKPIData(ServiceDescription description);
}
internal static class System.ServiceModel.ThreadTrace : object {
    public static void Trace(string operation);
    public static void StopTracing();
    public static void Save();
}
internal static class System.ServiceModel.TimeSpanHelper : object {
    public static TimeSpan FromMinutes(int minutes, string text);
    public static TimeSpan FromSeconds(int seconds, string text);
    public static TimeSpan FromMilliseconds(int ms, string text);
    public static TimeSpan FromDays(int days, string text);
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.TransactionFlowAttribute : Attribute {
    public TransactionFlowOption Transactions { get; }
    public TransactionFlowAttribute(TransactionFlowOption transactions);
    public TransactionFlowOption get_Transactions();
    internal static void OverrideFlow(BindingParameterCollection parameters, string action, MessageDirection direction, TransactionFlowOption option);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
public enum System.ServiceModel.TransactionFlowOption : Enum {
    public int value__;
    public static TransactionFlowOption NotAllowed;
    public static TransactionFlowOption Allowed;
    public static TransactionFlowOption Mandatory;
}
internal static class System.ServiceModel.TransactionFlowOptionHelper : object {
    public static bool IsDefined(TransactionFlowOption option);
    internal static bool AllowedOrRequired(TransactionFlowOption option);
}
[TypeConverterAttribute("System.ServiceModel.Configuration.TransactionProtocolConverter")]
public abstract class System.ServiceModel.TransactionProtocol : object {
    public static TransactionProtocol Default { get; }
    public static TransactionProtocol OleTransactions { get; }
    public static TransactionProtocol WSAtomicTransactionOctober2004 { get; }
    public static TransactionProtocol WSAtomicTransaction11 { get; }
    internal string Name { get; }
    public static TransactionProtocol get_Default();
    public static TransactionProtocol get_OleTransactions();
    public static TransactionProtocol get_WSAtomicTransactionOctober2004();
    public static TransactionProtocol get_WSAtomicTransaction11();
    internal abstract virtual string get_Name();
    internal static bool IsDefined(TransactionProtocol transactionProtocol);
}
[FlagsAttribute]
internal enum System.ServiceModel.Transactions.IsolationFlags : Enum {
    public int value__;
    public static IsolationFlags RetainCommitDC;
    public static IsolationFlags RetainCommit;
    public static IsolationFlags RetainCommitNo;
    public static IsolationFlags RetainAbortDC;
    public static IsolationFlags RetainAbort;
    public static IsolationFlags RetainAbortNo;
    public static IsolationFlags RetainDoNotCare;
    public static IsolationFlags RetainBoth;
    public static IsolationFlags RetainNone;
    public static IsolationFlags Optimistic;
    public static IsolationFlags ReadOnly;
}
internal class System.ServiceModel.Transactions.OleTxTransactionFormatter : TransactionFormatter {
    public MessageHeader EmptyTransactionHeader { get; }
    private static OleTxTransactionFormatter();
    public virtual MessageHeader get_EmptyTransactionHeader();
    public virtual void WriteTransaction(Transaction transaction, Message message);
    public virtual TransactionInfo ReadTransaction(Message message);
    public static UInt32 GetTimeoutFromTransaction(Transaction transaction);
    public static void GetTransactionAttributes(Transaction transaction, UInt32& timeout, IsolationFlags& isoFlags, String& description);
}
internal class System.ServiceModel.Transactions.OleTxTransactionHeader : MessageHeader {
    public bool MustUnderstand { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Byte[] PropagationToken { get; }
    public WsatExtendedInformation WsatExtendedInformation { get; }
    public OleTxTransactionHeader(Byte[] propagationToken, WsatExtendedInformation wsatInfo);
    private static OleTxTransactionHeader();
    public virtual bool get_MustUnderstand();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public Byte[] get_PropagationToken();
    public WsatExtendedInformation get_WsatExtendedInformation();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static OleTxTransactionHeader ReadFrom(Message message);
    public static void WritePropagationTokenElement(XmlDictionaryWriter writer, Byte[] propagationToken);
    public static bool IsStartPropagationTokenElement(XmlDictionaryReader reader);
    public static Byte[] ReadPropagationTokenElement(XmlDictionaryReader reader);
}
internal class System.ServiceModel.Transactions.OleTxTransactionInfo : TransactionInfo {
    public OleTxTransactionInfo(OleTxTransactionHeader header);
    public virtual Transaction UnmarshalTransaction();
    public static Transaction UnmarshalPropagationToken(Byte[] propToken);
}
internal abstract class System.ServiceModel.Transactions.TransactionCache`2 : object {
    private static TransactionCache`2();
    protected void AddEntry(Transaction transaction, T key, S value);
    public static bool Find(T key, S& value);
}
internal abstract class System.ServiceModel.Transactions.TransactionFormatter : object {
    public static TransactionFormatter OleTxFormatter { get; }
    public static TransactionFormatter WsatFormatter10 { get; }
    public static TransactionFormatter WsatFormatter11 { get; }
    public MessageHeader EmptyTransactionHeader { get; }
    private static TransactionFormatter();
    public static TransactionFormatter get_OleTxFormatter();
    public static TransactionFormatter get_WsatFormatter10();
    public static TransactionFormatter get_WsatFormatter11();
    public abstract virtual MessageHeader get_EmptyTransactionHeader();
    public abstract virtual void WriteTransaction(Transaction transaction, Message message);
    public abstract virtual TransactionInfo ReadTransaction(Message message);
}
internal abstract class System.ServiceModel.Transactions.TransactionInfo : object {
    public abstract virtual Transaction UnmarshalTransaction();
}
internal class System.ServiceModel.Transactions.TransactionManagerConfigurationException : TransactionException {
    public TransactionManagerConfigurationException(string error, Exception e);
    public TransactionManagerConfigurationException(string error);
}
internal class System.ServiceModel.Transactions.WhereaboutsReader : object {
    public string HostName { get; }
    public ProtocolInformationReader ProtocolInformation { get; }
    public WhereaboutsReader(Byte[] whereabouts);
    private static WhereaboutsReader();
    public string get_HostName();
    public ProtocolInformationReader get_ProtocolInformation();
}
internal class System.ServiceModel.Transactions.WsatConfiguration : object {
    public bool OleTxUpgradeEnabled { get; }
    public TimeSpan MaxTimeout { get; }
    public bool IssuedTokensEnabled { get; }
    public bool InboundEnabled { get; }
    private static WsatConfiguration();
    public bool get_OleTxUpgradeEnabled();
    public TimeSpan get_MaxTimeout();
    public bool get_IssuedTokensEnabled();
    public bool get_InboundEnabled();
    public bool IsProtocolServiceEnabled(ProtocolVersion protocolVersion);
    public EndpointAddress LocalActivationService(ProtocolVersion protocolVersion);
    public EndpointAddress RemoteActivationService(ProtocolVersion protocolVersion);
    public EndpointAddress CreateRegistrationService(AddressHeader refParam, ProtocolVersion protocolVersion);
    public bool IsLocalRegistrationService(EndpointAddress endpoint, ProtocolVersion protocolVersion);
    public bool IsDisabledRegistrationService(EndpointAddress endpoint);
}
internal class System.ServiceModel.Transactions.WsatExtendedInformation : object {
    public static string UuidScheme;
    public string Identifier { get; }
    public UInt32 Timeout { get; }
    public WsatExtendedInformation(string identifier, UInt32 timeout);
    public string get_Identifier();
    public UInt32 get_Timeout();
    public void TryCache(Transaction tx);
    public static string CreateNativeIdentifier(Guid transactionId);
    public static bool IsNativeIdentifier(string identifier, Guid transactionId);
}
internal class System.ServiceModel.Transactions.WsatExtendedInformationCache : TransactionCache`2<Transaction, WsatExtendedInformation> {
    public static void Cache(Transaction tx, WsatExtendedInformation info);
}
internal class System.ServiceModel.Transactions.WsatIncomingTransactionCache : TransactionCache`2<string, Transaction> {
    public static void Cache(string identifier, Transaction tx);
}
internal class System.ServiceModel.Transactions.WsatProxy : object {
    public WsatProxy(WsatConfiguration wsatConfig, ProtocolVersion protocolVersion);
    public Transaction UnmarshalTransaction(WsatTransactionInfo info);
}
internal class System.ServiceModel.Transactions.WsatRegistrationHeader : AddressHeader {
    public string Name { get; }
    public string Namespace { get; }
    public Guid TransactionId { get; }
    public string ContextId { get; }
    public string TokenId { get; }
    public WsatRegistrationHeader(Guid transactionId, string contextId, string tokenId);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public Guid get_TransactionId();
    public string get_ContextId();
    public string get_TokenId();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
    public static WsatRegistrationHeader ReadFrom(Message message);
}
internal abstract class System.ServiceModel.Transactions.WsatTransactionFormatter : TransactionFormatter {
    protected WsatTransactionFormatter(ProtocolVersion protocolVersion);
    public virtual void WriteTransaction(Transaction transaction, Message message);
    public virtual TransactionInfo ReadTransaction(Message message);
    public WsatTransactionInfo CreateTransactionInfo(CoordinationContext context, RequestSecurityTokenResponse issuedToken);
    public void MarshalAsCoordinationContext(Transaction transaction, CoordinationContext& context, RequestSecurityTokenResponse& issuedToken);
}
internal class System.ServiceModel.Transactions.WsatTransactionFormatter10 : WsatTransactionFormatter {
    public MessageHeader EmptyTransactionHeader { get; }
    private static WsatTransactionFormatter10();
    public virtual MessageHeader get_EmptyTransactionHeader();
}
internal class System.ServiceModel.Transactions.WsatTransactionFormatter11 : WsatTransactionFormatter {
    public MessageHeader EmptyTransactionHeader { get; }
    private static WsatTransactionFormatter11();
    public virtual MessageHeader get_EmptyTransactionHeader();
}
internal class System.ServiceModel.Transactions.WsatTransactionHeader : MessageHeader {
    public bool MustUnderstand { get; }
    public string Name { get; }
    public string Namespace { get; }
    public WsatTransactionHeader(CoordinationContext context, ProtocolVersion protocolVersion);
    public virtual bool get_MustUnderstand();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public static CoordinationContext GetCoordinationContext(Message message, ProtocolVersion protocolVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static CoordinationContext GetCoordinationContext(XmlDictionaryReader reader, ProtocolVersion protocolVersion);
}
internal class System.ServiceModel.Transactions.WsatTransactionInfo : TransactionInfo {
    public CoordinationContext Context { get; }
    public RequestSecurityTokenResponse IssuedToken { get; }
    public WsatTransactionInfo(WsatProxy wsatProxy, CoordinationContext context, RequestSecurityTokenResponse issuedToken);
    public virtual Transaction UnmarshalTransaction();
    public CoordinationContext get_Context();
    public RequestSecurityTokenResponse get_IssuedToken();
}
public enum System.ServiceModel.TransferMode : Enum {
    public int value__;
    public static TransferMode Buffered;
    public static TransferMode Streamed;
    public static TransferMode StreamedRequest;
    public static TransferMode StreamedResponse;
}
internal static class System.ServiceModel.TransferModeHelper : object {
    public static bool IsDefined(TransferMode v);
    public static bool IsRequestStreamed(TransferMode v);
    public static bool IsResponseStreamed(TransferMode v);
    public static void Validate(TransferMode value);
}
internal class System.ServiceModel.TrustApr2004Dictionary : TrustDictionary {
    public TrustApr2004Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.TrustApr2004Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string RequestSecurityTokenResponseCollection;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string Namespace;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string Psha1ComputedKeyUri;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string RequestFailedFaultCode;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string UseKey;
}
internal class System.ServiceModel.TrustDec2005Dictionary : TrustDictionary {
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public List`1<XmlDictionaryString> Feb2005DictionaryStrings;
    public List`1<XmlDictionaryString> Dec2005DictionaryString;
    public TrustDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateFeb2005DictionaryString();
    public void PopulateDec2005DictionaryStrings();
}
internal static class System.ServiceModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.ServiceModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString RequestFailedFaultCode;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public TrustDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.ServiceModel.TrustStrings : object {
}
internal abstract class System.ServiceModel.TypedHeaderManager : object {
    private static TypedHeaderManager();
    internal static object Create(Type t, object content, bool mustUnderstand, bool relay, string actor);
    internal static object GetContent(Type t, object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static Type GetMessageHeaderType(Type contentType);
    internal static Type GetHeaderType(Type headerParameterType);
    protected abstract virtual object Create(object content, bool mustUnderstand, bool relay, string actor);
    protected abstract virtual object GetContent(object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    protected abstract virtual Type GetMessageHeaderType();
}
[FlagsAttribute]
internal enum System.ServiceModel.UnifiedSecurityMode : Enum {
    public int value__;
    public static UnifiedSecurityMode None;
    public static UnifiedSecurityMode Transport;
    public static UnifiedSecurityMode Message;
    public static UnifiedSecurityMode Both;
    public static UnifiedSecurityMode TransportWithMessageCredential;
    public static UnifiedSecurityMode TransportCredentialOnly;
}
public class System.ServiceModel.UnknownMessageReceivedEventArgs : EventArgs {
    public Message Message { get; }
    internal UnknownMessageReceivedEventArgs(Message message);
    public Message get_Message();
}
public class System.ServiceModel.UpnEndpointIdentity : EndpointIdentity {
    public UpnEndpointIdentity(string upnName);
    public UpnEndpointIdentity(Claim identity);
    internal UpnEndpointIdentity(WindowsIdentity windowsIdentity);
    internal virtual void EnsureIdentityClaim();
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
    internal SecurityIdentifier GetUpnSid();
}
public class System.ServiceModel.UriSchemeKeyedCollection : SynchronizedKeyedCollection`2<string, Uri> {
    internal UriSchemeKeyedCollection(object syncRoot);
    public UriSchemeKeyedCollection(Uri[] addresses);
    protected virtual string GetKeyForItem(Uri item);
    protected virtual void InsertItem(int index, Uri item);
    protected virtual void SetItem(int index, Uri item);
    internal static void ValidateBaseAddress(Uri uri, string argumentName);
}
internal class System.ServiceModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString UniqueEndpointHeaderName;
    public XmlDictionaryString UniqueEndpointHeaderNamespace;
    public UtilityDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
    public static string UniqueEndpointHeaderName;
    public static string UniqueEndpointHeaderNamespace;
}
internal class System.ServiceModel.WrappedDispatcherException : SystemException {
    public WrappedDispatcherException(string message);
    public WrappedDispatcherException(SerializationInfo info, StreamingContext context);
    public WrappedDispatcherException(string message, Exception inner);
}
public class System.ServiceModel.WS2007FederationHttpBinding : WSFederationHttpBinding {
    public WS2007FederationHttpBinding(string configName);
    public WS2007FederationHttpBinding(WSFederationHttpSecurityMode securityMode);
    public WS2007FederationHttpBinding(WSFederationHttpSecurityMode securityMode, bool reliableSessionEnabled);
    private static WS2007FederationHttpBinding();
    protected virtual SecurityBindingElement CreateMessageSecurity();
    internal static bool TryCreate(SecurityBindingElement sbe, TransportBindingElement transport, PrivacyNoticeBindingElement privacy, ReliableSessionBindingElement rsbe, TransactionFlowBindingElement tfbe, Binding& binding);
}
public class System.ServiceModel.WS2007HttpBinding : WSHttpBinding {
    public WS2007HttpBinding(string configName);
    public WS2007HttpBinding(SecurityMode securityMode);
    public WS2007HttpBinding(SecurityMode securityMode, bool reliableSessionEnabled);
    internal WS2007HttpBinding(WSHttpSecurity security, bool reliableSessionEnabled);
    private static WS2007HttpBinding();
    protected virtual SecurityBindingElement CreateMessageSecurity();
    internal static bool TryCreate(SecurityBindingElement sbe, TransportBindingElement transport, ReliableSessionBindingElement rsbe, TransactionFlowBindingElement tfbe, Binding& binding);
}
internal class System.ServiceModel.WSAddressing10ProblemHeaderQNameFault : MessageFault {
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    public WSAddressing10ProblemHeaderQNameFault(MessageHeaderException e);
    public WSAddressing10ProblemHeaderQNameFault(ActionMismatchAddressingException e);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    public void AddHeaders(MessageHeaders headers);
}
internal class System.ServiceModel.WSAtomicTransaction11Protocol : TransactionProtocol {
    internal static TransactionProtocol Instance { get; }
    internal string Name { get; }
    private static WSAtomicTransaction11Protocol();
    internal static TransactionProtocol get_Instance();
    internal virtual string get_Name();
}
internal class System.ServiceModel.WSAtomicTransactionOctober2004Protocol : TransactionProtocol {
    internal static TransactionProtocol Instance { get; }
    internal string Name { get; }
    private static WSAtomicTransactionOctober2004Protocol();
    internal static TransactionProtocol get_Instance();
    internal virtual string get_Name();
}
public class System.ServiceModel.WSDualHttpBinding : Binding {
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("")]
public Uri ClientBaseAddress { get; public set; }
    [DefaultValueAttribute("False")]
public bool TransactionFlow { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public Uri ProxyAddress { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public ReliableSession ReliableSession { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    [TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    public WSDualHttpSecurity Security { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    public WSDualHttpBinding(string configName);
    public WSDualHttpBinding(WSDualHttpSecurityMode securityMode);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public Uri get_ClientBaseAddress();
    public void set_ClientBaseAddress(Uri value);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public ReliableSession get_ReliableSession();
    public void set_ReliableSession(ReliableSession value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    public WSDualHttpSecurity get_Security();
    public void set_Security(WSDualHttpSecurity value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTextEncoding();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReliableSession();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
}
public class System.ServiceModel.WSDualHttpSecurity : object {
    internal static WSDualHttpSecurityMode DefaultMode;
    public WSDualHttpSecurityMode Mode { get; public set; }
    public MessageSecurityOverHttp Message { get; public set; }
    private static WSDualHttpSecurity();
    public WSDualHttpSecurityMode get_Mode();
    public void set_Mode(WSDualHttpSecurityMode value);
    public MessageSecurityOverHttp get_Message();
    public void set_Message(MessageSecurityOverHttp value);
    internal SecurityBindingElement CreateMessageSecurity();
    internal static bool TryCreate(SecurityBindingElement sbe, WSDualHttpSecurity& security);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMode();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessage();
}
public enum System.ServiceModel.WSDualHttpSecurityMode : Enum {
    public int value__;
    public static WSDualHttpSecurityMode None;
    public static WSDualHttpSecurityMode Message;
}
internal static class System.ServiceModel.WSDualHttpSecurityModeHelper : object {
    internal static bool IsDefined(WSDualHttpSecurityMode value);
}
public class System.ServiceModel.WSFederationHttpBinding : WSHttpBindingBase {
    [DefaultValueAttribute("")]
public Uri PrivacyNoticeAt { get; public set; }
    [DefaultValueAttribute("0")]
public int PrivacyNoticeVersion { get; public set; }
    public WSFederationHttpSecurity Security { get; public set; }
    public WSFederationHttpBinding(string configName);
    public WSFederationHttpBinding(WSFederationHttpSecurityMode securityMode);
    public WSFederationHttpBinding(WSFederationHttpSecurityMode securityMode, bool reliableSessionEnabled);
    internal WSFederationHttpBinding(WSFederationHttpSecurity security, PrivacyNoticeBindingElement privacy, bool reliableSessionEnabled);
    private static WSFederationHttpBinding();
    public Uri get_PrivacyNoticeAt();
    public void set_PrivacyNoticeAt(Uri value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public WSFederationHttpSecurity get_Security();
    public void set_Security(WSFederationHttpSecurity value);
    internal static bool TryCreate(SecurityBindingElement sbe, TransportBindingElement transport, PrivacyNoticeBindingElement privacy, ReliableSessionBindingElement rsbe, TransactionFlowBindingElement tfbe, Binding& binding);
    protected virtual TransportBindingElement GetTransport();
    internal static bool GetSecurityModeFromTransport(TransportBindingElement transport, HttpTransportSecurity transportSecurity, WSFederationHttpSecurityMode& mode);
    protected virtual SecurityBindingElement CreateMessageSecurity();
    public virtual BindingElementCollection CreateBindingElements();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
}
public class System.ServiceModel.WSFederationHttpSecurity : object {
    internal static WSFederationHttpSecurityMode DefaultMode;
    public WSFederationHttpSecurityMode Mode { get; public set; }
    public FederatedMessageSecurityOverHttp Message { get; public set; }
    public WSFederationHttpSecurityMode get_Mode();
    public void set_Mode(WSFederationHttpSecurityMode value);
    public FederatedMessageSecurityOverHttp get_Message();
    public void set_Message(FederatedMessageSecurityOverHttp value);
    internal SecurityBindingElement CreateMessageSecurity(bool isReliableSessionEnabled, MessageSecurityVersion version);
    internal static bool TryCreate(SecurityBindingElement sbe, WSFederationHttpSecurityMode mode, HttpTransportSecurity transportSecurity, bool isReliableSessionEnabled, MessageSecurityVersion version, WSFederationHttpSecurity& security);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMode();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessage();
}
public enum System.ServiceModel.WSFederationHttpSecurityMode : Enum {
    public int value__;
    public static WSFederationHttpSecurityMode None;
    public static WSFederationHttpSecurityMode Message;
    public static WSFederationHttpSecurityMode TransportWithMessageCredential;
}
internal static class System.ServiceModel.WSFederationHttpSecurityModeHelper : object {
    internal static bool IsDefined(WSFederationHttpSecurityMode value);
}
public class System.ServiceModel.WSHttpBinding : WSHttpBindingBase {
    [DefaultValueAttribute("False")]
public bool AllowCookies { get; public set; }
    public WSHttpSecurity Security { get; public set; }
    public WSHttpBinding(string configName);
    public WSHttpBinding(SecurityMode securityMode);
    public WSHttpBinding(SecurityMode securityMode, bool reliableSessionEnabled);
    internal WSHttpBinding(WSHttpSecurity security, bool reliableSessionEnabled);
    private static WSHttpBinding();
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public WSHttpSecurity get_Security();
    public void set_Security(WSHttpSecurity value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(SecurityBindingElement sbe, TransportBindingElement transport, ReliableSessionBindingElement rsbe, TransactionFlowBindingElement tfbe, Binding& binding);
    protected virtual TransportBindingElement GetTransport();
    internal static bool GetSecurityModeFromTransport(TransportBindingElement transport, HttpTransportSecurity transportSecurity, UnifiedSecurityMode& mode);
    internal static bool TryGetAllowCookiesFromTransport(TransportBindingElement transport, Boolean& allowCookies);
    protected virtual SecurityBindingElement CreateMessageSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSecurity();
}
public abstract class System.ServiceModel.WSHttpBindingBase : Binding {
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("False")]
public bool TransactionFlow { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WSMessageEncoding MessageEncoding { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri ProxyAddress { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public OptionalReliableSession ReliableSession { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    [TypeConverterAttribute("System.ServiceModel.Configuration.EncodingConverter")]
public Encoding TextEncoding { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    internal HttpTransportBindingElement HttpTransport { get; }
    internal HttpsTransportBindingElement HttpsTransport { get; }
    internal ReliableSessionBindingElement ReliableSessionBindingElement { get; }
    internal TransactionFlowBindingElement TransactionFlowBindingElement { get; }
    protected WSHttpBindingBase(bool reliableSessionEnabled);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public bool get_TransactionFlow();
    public void set_TransactionFlow(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public WSMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(WSMessageEncoding value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public OptionalReliableSession get_ReliableSession();
    public void set_ReliableSession(OptionalReliableSession value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    internal HttpTransportBindingElement get_HttpTransport();
    internal HttpsTransportBindingElement get_HttpsTransport();
    internal ReliableSessionBindingElement get_ReliableSessionBindingElement();
    internal TransactionFlowBindingElement get_TransactionFlowBindingElement();
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection elements, Binding& binding);
    protected abstract virtual TransportBindingElement GetTransport();
    protected abstract virtual SecurityBindingElement CreateMessageSecurity();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTextEncoding();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReliableSession();
}
[TypeForwardedFromAttribute("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.ServiceModel.WSHttpContextBinding : WSHttpBinding {
    [DefaultValueAttribute("")]
public Uri ClientCallbackAddress { get; public set; }
    [DefaultValueAttribute("True")]
public bool ContextManagementEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ContextProtectionLevel { get; public set; }
    public WSHttpContextBinding(SecurityMode securityMode);
    public WSHttpContextBinding(string configName);
    public WSHttpContextBinding(SecurityMode securityMode, bool reliableSessionEnabled);
    [CompilerGeneratedAttribute]
public Uri get_ClientCallbackAddress();
    [CompilerGeneratedAttribute]
public void set_ClientCallbackAddress(Uri value);
    public bool get_ContextManagementEnabled();
    public void set_ContextManagementEnabled(bool value);
    public ProtectionLevel get_ContextProtectionLevel();
    public void set_ContextProtectionLevel(ProtectionLevel value);
    public virtual BindingElementCollection CreateBindingElements();
    internal static bool TryCreate(BindingElementCollection bindingElements, Binding& binding);
}
public class System.ServiceModel.WSHttpSecurity : object {
    internal static SecurityMode DefaultMode;
    public SecurityMode Mode { get; public set; }
    public HttpTransportSecurity Transport { get; public set; }
    public NonDualMessageSecurityOverHttp Message { get; public set; }
    internal WSHttpSecurity(SecurityMode mode, HttpTransportSecurity transportSecurity, NonDualMessageSecurityOverHttp messageSecurity);
    internal static HttpTransportSecurity GetDefaultHttpTransportSecurity();
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public HttpTransportSecurity get_Transport();
    public void set_Transport(HttpTransportSecurity value);
    public NonDualMessageSecurityOverHttp get_Message();
    public void set_Message(NonDualMessageSecurityOverHttp value);
    internal void ApplyTransportSecurity(HttpsTransportBindingElement https);
    internal static void ApplyTransportSecurity(HttpsTransportBindingElement transport, HttpTransportSecurity transportSecurity);
    internal SecurityBindingElement CreateMessageSecurity(bool isReliableSessionEnabled, MessageSecurityVersion version);
    internal static bool TryCreate(SecurityBindingElement sbe, UnifiedSecurityMode mode, HttpTransportSecurity transportSecurity, bool isReliableSessionEnabled, WSHttpSecurity& security);
    internal bool InternalShouldSerialize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMode();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessage();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransport();
}
public enum System.ServiceModel.WSMessageEncoding : Enum {
    public int value__;
    public static WSMessageEncoding Text;
    public static WSMessageEncoding Mtom;
}
internal static class System.ServiceModel.WSMessageEncodingHelper : object {
    internal static bool IsDefined(WSMessageEncoding value);
    internal static void SyncUpEncodingBindingElementProperties(TextMessageEncodingBindingElement textEncoding, MtomMessageEncodingBindingElement mtomEncoding);
}
internal class System.ServiceModel.WSReliableMessaging11Version : ReliableMessagingVersion {
    internal static ReliableMessagingVersion Instance { get; }
    private static WSReliableMessaging11Version();
    internal static ReliableMessagingVersion get_Instance();
    public virtual string ToString();
}
internal class System.ServiceModel.WSReliableMessagingFebruary2005Version : ReliableMessagingVersion {
    internal static ReliableMessagingVersion Instance { get; }
    private static WSReliableMessagingFebruary2005Version();
    internal static ReliableMessagingVersion get_Instance();
    public virtual string ToString();
}
internal class System.ServiceModel.Wsrm11Dictionary : object {
    public XmlDictionaryString AckRequestedAction;
    public XmlDictionaryString CloseSequence;
    public XmlDictionaryString CloseSequenceAction;
    public XmlDictionaryString CloseSequenceResponse;
    public XmlDictionaryString CloseSequenceResponseAction;
    public XmlDictionaryString CreateSequenceAction;
    public XmlDictionaryString CreateSequenceResponseAction;
    public XmlDictionaryString DiscardFollowingFirstGap;
    public XmlDictionaryString Endpoint;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString Final;
    public XmlDictionaryString IncompleteSequenceBehavior;
    public XmlDictionaryString LastMsgNumber;
    public XmlDictionaryString MaxMessageNumber;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NoDiscard;
    public XmlDictionaryString None;
    public XmlDictionaryString SequenceAcknowledgementAction;
    public XmlDictionaryString SequenceClosed;
    public XmlDictionaryString TerminateSequenceAction;
    public XmlDictionaryString TerminateSequenceResponse;
    public XmlDictionaryString TerminateSequenceResponseAction;
    public XmlDictionaryString UsesSequenceSSL;
    public XmlDictionaryString UsesSequenceSTR;
    public XmlDictionaryString WsrmRequired;
    public Wsrm11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.Wsrm11Strings : object {
    public static string AckRequestedAction;
    public static string CloseSequence;
    public static string CloseSequenceAction;
    public static string CloseSequenceResponse;
    public static string CloseSequenceResponseAction;
    public static string CreateSequenceAction;
    public static string CreateSequenceResponseAction;
    public static string DiscardFollowingFirstGap;
    public static string Endpoint;
    public static string FaultAction;
    public static string Final;
    public static string IncompleteSequenceBehavior;
    public static string LastMsgNumber;
    public static string MaxMessageNumber;
    public static string Namespace;
    public static string NoDiscard;
    public static string None;
    public static string SequenceAcknowledgementAction;
    public static string SequenceClosed;
    public static string TerminateSequenceAction;
    public static string TerminateSequenceResponse;
    public static string TerminateSequenceResponseAction;
    public static string UsesSequenceSSL;
    public static string UsesSequenceSTR;
    public static string WsrmRequired;
    public static string DiscardEntireSequence;
}
internal class System.ServiceModel.WsrmFeb2005Dictionary : object {
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString SequenceAcknowledgement;
    public XmlDictionaryString AcknowledgementRange;
    public XmlDictionaryString Upper;
    public XmlDictionaryString Lower;
    public XmlDictionaryString BufferRemaining;
    public XmlDictionaryString NETNamespace;
    public XmlDictionaryString SequenceAcknowledgementAction;
    public XmlDictionaryString Sequence;
    public XmlDictionaryString MessageNumber;
    public XmlDictionaryString AckRequested;
    public XmlDictionaryString AckRequestedAction;
    public XmlDictionaryString AcksTo;
    public XmlDictionaryString Accept;
    public XmlDictionaryString CreateSequence;
    public XmlDictionaryString CreateSequenceAction;
    public XmlDictionaryString CreateSequenceRefused;
    public XmlDictionaryString CreateSequenceResponse;
    public XmlDictionaryString CreateSequenceResponseAction;
    public XmlDictionaryString Expires;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString InvalidAcknowledgement;
    public XmlDictionaryString LastMessage;
    public XmlDictionaryString LastMessageAction;
    public XmlDictionaryString LastMessageNumberExceeded;
    public XmlDictionaryString MessageNumberRollover;
    public XmlDictionaryString Nack;
    public XmlDictionaryString NETPrefix;
    public XmlDictionaryString Offer;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SequenceFault;
    public XmlDictionaryString SequenceTerminated;
    public XmlDictionaryString TerminateSequence;
    public XmlDictionaryString TerminateSequenceAction;
    public XmlDictionaryString UnknownSequence;
    public XmlDictionaryString ConnectionLimitReached;
    public WsrmFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.WsrmFeb2005Strings : object {
    public static string Identifier;
    public static string Namespace;
    public static string SequenceAcknowledgement;
    public static string AcknowledgementRange;
    public static string Upper;
    public static string Lower;
    public static string BufferRemaining;
    public static string NETNamespace;
    public static string SequenceAcknowledgementAction;
    public static string Sequence;
    public static string MessageNumber;
    public static string AckRequested;
    public static string AckRequestedAction;
    public static string AcksTo;
    public static string Accept;
    public static string CreateSequence;
    public static string CreateSequenceAction;
    public static string CreateSequenceRefused;
    public static string CreateSequenceResponse;
    public static string CreateSequenceResponseAction;
    public static string Expires;
    public static string FaultCode;
    public static string InvalidAcknowledgement;
    public static string LastMessage;
    public static string LastMessageAction;
    public static string LastMessageNumberExceeded;
    public static string MessageNumberRollover;
    public static string Nack;
    public static string NETPrefix;
    public static string Offer;
    public static string Prefix;
    public static string SequenceFault;
    public static string SequenceTerminated;
    public static string TerminateSequence;
    public static string TerminateSequenceAction;
    public static string UnknownSequence;
    public static string ConnectionLimitReached;
}
public class System.ServiceModel.X509CertificateEndpointIdentity : EndpointIdentity {
    public X509Certificate2Collection Certificates { get; }
    public X509CertificateEndpointIdentity(X509Certificate2 certificate);
    public X509CertificateEndpointIdentity(X509Certificate2 primaryCertificate, X509Certificate2Collection supportingCertificates);
    internal X509CertificateEndpointIdentity(XmlDictionaryReader reader);
    public X509Certificate2Collection get_Certificates();
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
[ContentPropertyAttribute("Namespaces")]
public class System.ServiceModel.XamlIntegration.XPathMessageContextMarkupExtension : MarkupExtension {
    public Dictionary`2<string, string> Namespaces { get; }
    private static XPathMessageContextMarkupExtension();
    public XPathMessageContextMarkupExtension(XPathMessageContext context);
    public Dictionary`2<string, string> get_Namespaces();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class System.ServiceModel.XamlIntegration.XPathMessageContextTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal static class System.ServiceModel.XD : object {
    public static ServiceModelDictionary Dictionary { get; }
    public static ActivityIdFlowDictionary ActivityIdFlowDictionary { get; }
    public static AddressingDictionary AddressingDictionary { get; }
    public static Addressing10Dictionary Addressing10Dictionary { get; }
    public static Addressing200408Dictionary Addressing200408Dictionary { get; }
    public static AddressingNoneDictionary AddressingNoneDictionary { get; }
    public static AtomicTransactionExternalDictionary AtomicTransactionExternalDictionary { get; }
    public static AtomicTransactionExternal10Dictionary AtomicTransactionExternal10Dictionary { get; }
    public static CoordinationExternalDictionary CoordinationExternalDictionary { get; }
    public static CoordinationExternal10Dictionary CoordinationExternal10Dictionary { get; }
    public static DotNetAddressingDictionary DotNetAddressingDictionary { get; }
    public static DotNetAtomicTransactionExternalDictionary DotNetAtomicTransactionExternalDictionary { get; }
    public static DotNetOneWayDictionary DotNetOneWayDictionary { get; }
    public static DotNetSecurityDictionary DotNetSecurityDictionary { get; }
    public static ExclusiveC14NDictionary ExclusiveC14NDictionary { get; }
    public static MessageDictionary MessageDictionary { get; }
    public static Message11Dictionary Message11Dictionary { get; }
    public static Message12Dictionary Message12Dictionary { get; }
    public static OleTxTransactionExternalDictionary OleTxTransactionExternalDictionary { get; }
    public static PeerWireStringsDictionary PeerWireStringsDictionary { get; }
    public static PolicyDictionary PolicyDictionary { get; }
    public static SamlDictionary SamlDictionary { get; }
    public static SecureConversationApr2004Dictionary SecureConversationApr2004Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static SerializationDictionary SerializationDictionary { get; }
    public static TrustApr2004Dictionary TrustApr2004Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static WsrmFeb2005Dictionary WsrmFeb2005Dictionary { get; }
    public static XmlEncryptionDictionary XmlEncryptionDictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static ServiceModelDictionary get_Dictionary();
    public static ActivityIdFlowDictionary get_ActivityIdFlowDictionary();
    public static AddressingDictionary get_AddressingDictionary();
    public static Addressing10Dictionary get_Addressing10Dictionary();
    public static Addressing200408Dictionary get_Addressing200408Dictionary();
    public static AddressingNoneDictionary get_AddressingNoneDictionary();
    public static AtomicTransactionExternalDictionary get_AtomicTransactionExternalDictionary();
    public static AtomicTransactionExternal10Dictionary get_AtomicTransactionExternal10Dictionary();
    public static CoordinationExternalDictionary get_CoordinationExternalDictionary();
    public static CoordinationExternal10Dictionary get_CoordinationExternal10Dictionary();
    public static DotNetAddressingDictionary get_DotNetAddressingDictionary();
    public static DotNetAtomicTransactionExternalDictionary get_DotNetAtomicTransactionExternalDictionary();
    public static DotNetOneWayDictionary get_DotNetOneWayDictionary();
    public static DotNetSecurityDictionary get_DotNetSecurityDictionary();
    public static ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public static MessageDictionary get_MessageDictionary();
    public static Message11Dictionary get_Message11Dictionary();
    public static Message12Dictionary get_Message12Dictionary();
    public static OleTxTransactionExternalDictionary get_OleTxTransactionExternalDictionary();
    public static PeerWireStringsDictionary get_PeerWireStringsDictionary();
    public static PolicyDictionary get_PolicyDictionary();
    public static SamlDictionary get_SamlDictionary();
    public static SecureConversationApr2004Dictionary get_SecureConversationApr2004Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static SerializationDictionary get_SerializationDictionary();
    public static TrustApr2004Dictionary get_TrustApr2004Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static WsrmFeb2005Dictionary get_WsrmFeb2005Dictionary();
    public static XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.ServiceModel.XmlBuffer : object {
    public int BufferSize { get; }
    public int SectionCount { get; }
    public XmlBuffer(int maxBufferSize);
    public int get_BufferSize();
    public int get_SectionCount();
    public XmlDictionaryWriter OpenSection(XmlDictionaryReaderQuotas quotas);
    public void CloseSection();
    public void Close();
    public XmlDictionaryReader GetReader(int sectionIndex);
    public void WriteTo(int sectionIndex, XmlWriter writer);
}
internal class System.ServiceModel.XmlEncryptionDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DataReference;
    public XmlDictionaryString EncryptedData;
    public XmlDictionaryString EncryptionMethod;
    public XmlDictionaryString CipherData;
    public XmlDictionaryString CipherValue;
    public XmlDictionaryString ReferenceList;
    public XmlDictionaryString Encoding;
    public XmlDictionaryString MimeType;
    public XmlDictionaryString Type;
    public XmlDictionaryString Id;
    public XmlDictionaryString CarriedKeyName;
    public XmlDictionaryString Recipient;
    public XmlDictionaryString EncryptedKey;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyReference;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString ElementType;
    public XmlDictionaryString ContentType;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlEncryptionDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.XmlSerializerFormatAttribute : Attribute {
    public bool SupportFaults { get; public set; }
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatUse Use { get; public set; }
    internal bool IsEncoded { get; internal set; }
    public bool get_SupportFaults();
    public void set_SupportFaults(bool value);
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
    public OperationFormatUse get_Use();
    public void set_Use(OperationFormatUse value);
    internal bool get_IsEncoded();
    internal void set_IsEncoded(bool value);
    internal static void ValidateOperationFormatStyle(OperationFormatStyle value);
    internal static void ValidateOperationFormatUse(OperationFormatUse value);
}
internal class System.ServiceModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string X509Ski;
    public static string TransformationParameters;
}
internal static class System.ServiceModel.XmlUtil : object {
    public static string XmlNs;
    public static string XmlNsNs;
    public static string GetXmlLangAttribute(XmlReader reader);
    public static bool IsTrue(string booleanValue);
    public static void ReadContentAsQName(XmlReader reader, String& localName, String& ns);
    public static bool IsWhitespace(char ch);
    public static string TrimEnd(string s);
    public static string TrimStart(string s);
    public static string Trim(string s);
    public static void ParseQName(XmlReader reader, string qname, String& localName, String& ns);
}
[ContentPropertyAttribute("Expression")]
public class System.ServiceModel.XPathMessageQuery : MessageQuery {
    [DefaultValueAttribute("")]
public string Expression { get; public set; }
    [DefaultValueAttribute("")]
public XmlNamespaceManager Namespaces { get; public set; }
    public XPathMessageQuery(string expression);
    public XPathMessageQuery(string expression, XsltContext context);
    public XPathMessageQuery(string expression, XmlNamespaceManager namespaces);
    public string get_Expression();
    public void set_Expression(string value);
    public XmlNamespaceManager get_Namespaces();
    public void set_Namespaces(XmlNamespaceManager value);
    public virtual MessageQueryCollection CreateMessageQueryCollection();
    public virtual TResult Evaluate(Message message);
    public virtual TResult Evaluate(MessageBuffer buffer);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.UriTemplate : object {
    internal int firstOptionalSegment;
    internal string originalTemplate;
    internal Dictionary`2<string, UriTemplateQueryValue> queries;
    internal List`1<UriTemplatePathSegment> segments;
    internal static string WildcardPath;
    public IDictionary`2<string, string> Defaults { get; }
    public bool IgnoreTrailingSlash { get; }
    public ReadOnlyCollection`1<string> PathSegmentVariableNames { get; }
    public ReadOnlyCollection`1<string> QueryValueVariableNames { get; }
    internal bool HasNoVariables { get; }
    internal bool HasWildcard { get; }
    public UriTemplate(string template);
    public UriTemplate(string template, bool ignoreTrailingSlash);
    public UriTemplate(string template, IDictionary`2<string, string> additionalDefaults);
    public UriTemplate(string template, bool ignoreTrailingSlash, IDictionary`2<string, string> additionalDefaults);
    public IDictionary`2<string, string> get_Defaults();
    public bool get_IgnoreTrailingSlash();
    public ReadOnlyCollection`1<string> get_PathSegmentVariableNames();
    public ReadOnlyCollection`1<string> get_QueryValueVariableNames();
    internal bool get_HasNoVariables();
    internal bool get_HasWildcard();
    public Uri BindByName(Uri baseAddress, IDictionary`2<string, string> parameters);
    public Uri BindByName(Uri baseAddress, IDictionary`2<string, string> parameters, bool omitDefaults);
    public Uri BindByName(Uri baseAddress, NameValueCollection parameters);
    public Uri BindByName(Uri baseAddress, NameValueCollection parameters, bool omitDefaults);
    public Uri BindByPosition(Uri baseAddress, String[] values);
    public bool IsEquivalentTo(UriTemplate other);
    public UriTemplateMatch Match(Uri baseAddress, Uri candidate);
    public virtual string ToString();
    internal string AddPathVariable(UriTemplatePartType sourceNature, string varDeclaration);
    internal string AddPathVariable(UriTemplatePartType sourceNature, string varDeclaration, Boolean& hasDefaultValue);
    internal string AddQueryVariable(string varDeclaration);
    internal UriTemplateMatch CreateUriTemplateMatch(Uri baseUri, Uri uri, object data, int numMatchedSegments, Collection`1<string> relativePathSegments, NameValueCollection uriQuery);
    internal bool IsPathPartiallyEquivalentAt(UriTemplate other, int segmentsCount);
    internal bool IsQueryEquivalent(UriTemplate other);
    internal static Uri RewriteUri(Uri uri, string host);
}
internal class System.UriTemplateCompoundPathSegment : UriTemplatePathSegment {
    public static UriTemplateCompoundPathSegment CreateFromUriTemplate(string segment, UriTemplate template);
    public virtual void Bind(String[] values, Int32& valueIndex, StringBuilder path);
    public virtual bool IsEquivalentTo(UriTemplatePathSegment other, bool ignoreTrailingSlash);
    public virtual bool IsMatch(UriTemplateLiteralPathSegment segment, bool ignoreTrailingSlash);
    public virtual void Lookup(string segment, NameValueCollection boundParameters);
    private sealed virtual override int System.IComparable<System.UriTemplateCompoundPathSegment>.CompareTo(UriTemplateCompoundPathSegment other);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.UriTemplateEquivalenceComparer : object {
    internal static UriTemplateEquivalenceComparer Instance { get; }
    internal static UriTemplateEquivalenceComparer get_Instance();
    public sealed virtual bool Equals(UriTemplate x, UriTemplate y);
    public sealed virtual int GetHashCode(UriTemplate obj);
}
internal static class System.UriTemplateHelpers : object {
    private static UriTemplateHelpers();
    [ConditionalAttribute("DEBUG")]
public static void AssertCanonical(string s);
    public static bool CanMatchQueryInterestingly(UriTemplate ut, NameValueCollection query, bool mustBeEspeciallyInteresting);
    public static bool CanMatchQueryTrivially(UriTemplate ut);
    public static void DisambiguateSamePath(UriTemplate[] array, int a, int b, bool allowDuplicateEquivalentUriTemplates);
    public static IEqualityComparer`1<string> GetQueryKeyComparer();
    public static string GetUriPath(Uri uri);
    public static bool HasQueryLiteralRequirements(UriTemplate ut);
    public static UriTemplatePartType IdentifyPartType(string part);
    public static bool IsWildcardPath(string path);
    public static bool IsWildcardSegment(string segment, UriTemplatePartType& type);
    public static NameValueCollection ParseQueryString(string query);
}
internal class System.UriTemplateLiteralPathSegment : UriTemplatePathSegment {
    private static UriTemplateLiteralPathSegment();
    public static UriTemplateLiteralPathSegment CreateFromUriTemplate(string segment, UriTemplate template);
    public static UriTemplateLiteralPathSegment CreateFromWireData(string segment);
    public string AsUnescapedString();
    public virtual void Bind(String[] values, Int32& valueIndex, StringBuilder path);
    public sealed virtual int CompareTo(UriTemplateLiteralPathSegment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsEquivalentTo(UriTemplatePathSegment other, bool ignoreTrailingSlash);
    public virtual bool IsMatch(UriTemplateLiteralPathSegment segment, bool ignoreTrailingSlash);
    public bool IsNullOrEmpty();
    public virtual void Lookup(string segment, NameValueCollection boundParameters);
}
internal class System.UriTemplateLiteralQueryValue : UriTemplateQueryValue {
    public static UriTemplateLiteralQueryValue CreateFromUriTemplate(string value);
    public string AsEscapedString();
    public string AsRawUnescapedString();
    public virtual void Bind(string keyName, String[] values, Int32& valueIndex, StringBuilder query);
    public sealed virtual int CompareTo(UriTemplateLiteralQueryValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsEquivalentTo(UriTemplateQueryValue other);
    public virtual void Lookup(string value, NameValueCollection boundParameters);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.UriTemplateMatch : object {
    public Uri BaseUri { get; public set; }
    public NameValueCollection BoundVariables { get; }
    public object Data { get; public set; }
    public NameValueCollection QueryParameters { get; }
    public Collection`1<string> RelativePathSegments { get; }
    public Uri RequestUri { get; public set; }
    public UriTemplate Template { get; public set; }
    public Collection`1<string> WildcardPathSegments { get; }
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public NameValueCollection get_BoundVariables();
    public object get_Data();
    public void set_Data(object value);
    public NameValueCollection get_QueryParameters();
    public Collection`1<string> get_RelativePathSegments();
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
    public UriTemplate get_Template();
    public void set_Template(UriTemplate value);
    public Collection`1<string> get_WildcardPathSegments();
    internal void SetQueryParameters(NameValueCollection queryParameters);
    internal void SetRelativePathSegments(Collection`1<string> segments);
    internal void SetWildcardPathSegmentsStart(int startOffset);
    internal void SetBaseUri(Uri originalBaseUri, HttpRequestMessageProperty requestProp);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.UriTemplateMatchException : SystemException {
    public UriTemplateMatchException(string message);
    public UriTemplateMatchException(string message, Exception innerException);
    protected UriTemplateMatchException(SerializationInfo info, StreamingContext context);
}
internal enum System.UriTemplatePartType : Enum {
    public int value__;
    public static UriTemplatePartType Literal;
    public static UriTemplatePartType Compound;
    public static UriTemplatePartType Variable;
}
internal class System.UriTemplatePathPartiallyEquivalentSet : object {
    public List`1<KeyValuePair`2<UriTemplate, object>> Items { get; }
    public int SegmentsCount { get; }
    public UriTemplatePathPartiallyEquivalentSet(int segmentsCount);
    public List`1<KeyValuePair`2<UriTemplate, object>> get_Items();
    public int get_SegmentsCount();
}
[DebuggerDisplayAttribute("Segment={originalSegment} Nature={nature}")]
internal abstract class System.UriTemplatePathSegment : object {
    public bool EndsWithSlash { get; }
    public UriTemplatePartType Nature { get; }
    public string OriginalSegment { get; }
    protected UriTemplatePathSegment(string originalSegment, UriTemplatePartType nature, bool endsWithSlash);
    public bool get_EndsWithSlash();
    public UriTemplatePartType get_Nature();
    public string get_OriginalSegment();
    public static UriTemplatePathSegment CreateFromUriTemplate(string segment, UriTemplate template);
    public abstract virtual void Bind(String[] values, Int32& valueIndex, StringBuilder path);
    public abstract virtual bool IsEquivalentTo(UriTemplatePathSegment other, bool ignoreTrailingSlash);
    public bool IsMatch(UriTemplateLiteralPathSegment segment);
    public abstract virtual bool IsMatch(UriTemplateLiteralPathSegment segment, bool ignoreTrailingSlash);
    public abstract virtual void Lookup(string segment, NameValueCollection boundParameters);
}
internal abstract class System.UriTemplateQueryValue : object {
    public static UriTemplateQueryValue Empty { get; }
    public UriTemplatePartType Nature { get; }
    protected UriTemplateQueryValue(UriTemplatePartType nature);
    private static UriTemplateQueryValue();
    public static UriTemplateQueryValue get_Empty();
    public UriTemplatePartType get_Nature();
    public static UriTemplateQueryValue CreateFromUriTemplate(string value, UriTemplate template);
    public static bool IsNullOrEmpty(UriTemplateQueryValue utqv);
    public abstract virtual void Bind(string keyName, String[] values, Int32& valueIndex, StringBuilder query);
    public abstract virtual bool IsEquivalentTo(UriTemplateQueryValue other);
    public abstract virtual void Lookup(string value, NameValueCollection boundParameters);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.UriTemplateTable : object {
    public Uri BaseAddress { get; public set; }
    public Uri OriginalBaseAddress { get; }
    public bool IsReadOnly { get; }
    public IList`1<KeyValuePair`2<UriTemplate, object>> KeyValuePairs { get; }
    public UriTemplateTable(IEnumerable`1<KeyValuePair`2<UriTemplate, object>> keyValuePairs);
    public UriTemplateTable(Uri baseAddress);
    internal UriTemplateTable(Uri baseAddress, bool addTrailingSlashToBaseAddress);
    public UriTemplateTable(Uri baseAddress, IEnumerable`1<KeyValuePair`2<UriTemplate, object>> keyValuePairs);
    internal UriTemplateTable(Uri baseAddress, IEnumerable`1<KeyValuePair`2<UriTemplate, object>> keyValuePairs, bool addTrailingSlashToBaseAddress);
    public Uri get_BaseAddress();
    public void set_BaseAddress(Uri value);
    public Uri get_OriginalBaseAddress();
    public bool get_IsReadOnly();
    public IList`1<KeyValuePair`2<UriTemplate, object>> get_KeyValuePairs();
    public void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates);
    public Collection`1<UriTemplateMatch> Match(Uri uri);
    public UriTemplateMatch MatchSingle(Uri uri);
}
internal class System.UriTemplateTableMatchCandidate : ValueType {
    private object data;
    private int segmentsCount;
    private UriTemplate template;
    public object Data { get; }
    public int SegmentsCount { get; }
    public UriTemplate Template { get; }
    public UriTemplateTableMatchCandidate(UriTemplate template, int segmentsCount, object data);
    public object get_Data();
    public int get_SegmentsCount();
    public UriTemplate get_Template();
}
internal enum System.UriTemplateTrieIntraNodeLocation : Enum {
    public int value__;
    public static UriTemplateTrieIntraNodeLocation BeforeLiteral;
    public static UriTemplateTrieIntraNodeLocation AfterLiteral;
    public static UriTemplateTrieIntraNodeLocation AfterCompound;
    public static UriTemplateTrieIntraNodeLocation AfterVariable;
}
internal class System.UriTemplateTrieLocation : object {
    public UriTemplateTrieIntraNodeLocation locationWithin;
    public UriTemplateTrieNode node;
    public UriTemplateTrieLocation(UriTemplateTrieNode n, UriTemplateTrieIntraNodeLocation i);
}
internal class System.UriTemplateTrieNode : object {
    public static UriTemplateTrieNode Make(IEnumerable`1<KeyValuePair`2<UriTemplate, object>> keyValuePairs, bool allowDuplicateEquivalentUriTemplates);
    public bool Match(UriTemplateLiteralPathSegment[] wireData, ICollection`1<UriTemplateTableMatchCandidate> candidates);
}
internal class System.UriTemplateVariablePathSegment : UriTemplatePathSegment {
    public string VarName { get; }
    public UriTemplateVariablePathSegment(string originalSegment, bool endsWithSlash, string varName);
    public string get_VarName();
    public virtual void Bind(String[] values, Int32& valueIndex, StringBuilder path);
    public virtual bool IsEquivalentTo(UriTemplatePathSegment other, bool ignoreTrailingSlash);
    public virtual bool IsMatch(UriTemplateLiteralPathSegment segment, bool ignoreTrailingSlash);
    public virtual void Lookup(string segment, NameValueCollection boundParameters);
}
internal class System.UriTemplateVariableQueryValue : UriTemplateQueryValue {
    public UriTemplateVariableQueryValue(string varName);
    public virtual void Bind(string keyName, String[] values, Int32& valueIndex, StringBuilder query);
    public virtual bool IsEquivalentTo(UriTemplateQueryValue other);
    public virtual void Lookup(string value, NameValueCollection boundParameters);
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    public int value__;
    public static XmlBinaryNodeType EndElement;
    public static XmlBinaryNodeType Comment;
    public static XmlBinaryNodeType Array;
    public static XmlBinaryNodeType MinAttribute;
    public static XmlBinaryNodeType ShortAttribute;
    public static XmlBinaryNodeType Attribute;
    public static XmlBinaryNodeType ShortDictionaryAttribute;
    public static XmlBinaryNodeType DictionaryAttribute;
    public static XmlBinaryNodeType ShortXmlnsAttribute;
    public static XmlBinaryNodeType XmlnsAttribute;
    public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    public static XmlBinaryNodeType PrefixAttributeA;
    public static XmlBinaryNodeType PrefixAttributeB;
    public static XmlBinaryNodeType PrefixAttributeC;
    public static XmlBinaryNodeType PrefixAttributeD;
    public static XmlBinaryNodeType PrefixAttributeE;
    public static XmlBinaryNodeType PrefixAttributeF;
    public static XmlBinaryNodeType PrefixAttributeG;
    public static XmlBinaryNodeType PrefixAttributeH;
    public static XmlBinaryNodeType PrefixAttributeI;
    public static XmlBinaryNodeType PrefixAttributeJ;
    public static XmlBinaryNodeType PrefixAttributeK;
    public static XmlBinaryNodeType PrefixAttributeL;
    public static XmlBinaryNodeType PrefixAttributeM;
    public static XmlBinaryNodeType PrefixAttributeN;
    public static XmlBinaryNodeType PrefixAttributeO;
    public static XmlBinaryNodeType PrefixAttributeP;
    public static XmlBinaryNodeType PrefixAttributeQ;
    public static XmlBinaryNodeType PrefixAttributeR;
    public static XmlBinaryNodeType PrefixAttributeS;
    public static XmlBinaryNodeType PrefixAttributeT;
    public static XmlBinaryNodeType PrefixAttributeU;
    public static XmlBinaryNodeType PrefixAttributeV;
    public static XmlBinaryNodeType PrefixAttributeW;
    public static XmlBinaryNodeType PrefixAttributeX;
    public static XmlBinaryNodeType PrefixAttributeY;
    public static XmlBinaryNodeType PrefixAttributeZ;
    public static XmlBinaryNodeType MaxAttribute;
    public static XmlBinaryNodeType MinElement;
    public static XmlBinaryNodeType ShortElement;
    public static XmlBinaryNodeType Element;
    public static XmlBinaryNodeType ShortDictionaryElement;
    public static XmlBinaryNodeType DictionaryElement;
    public static XmlBinaryNodeType PrefixDictionaryElementA;
    public static XmlBinaryNodeType PrefixDictionaryElementB;
    public static XmlBinaryNodeType PrefixDictionaryElementC;
    public static XmlBinaryNodeType PrefixDictionaryElementD;
    public static XmlBinaryNodeType PrefixDictionaryElementE;
    public static XmlBinaryNodeType PrefixDictionaryElementF;
    public static XmlBinaryNodeType PrefixDictionaryElementG;
    public static XmlBinaryNodeType PrefixDictionaryElementH;
    public static XmlBinaryNodeType PrefixDictionaryElementI;
    public static XmlBinaryNodeType PrefixDictionaryElementJ;
    public static XmlBinaryNodeType PrefixDictionaryElementK;
    public static XmlBinaryNodeType PrefixDictionaryElementL;
    public static XmlBinaryNodeType PrefixDictionaryElementM;
    public static XmlBinaryNodeType PrefixDictionaryElementN;
    public static XmlBinaryNodeType PrefixDictionaryElementO;
    public static XmlBinaryNodeType PrefixDictionaryElementP;
    public static XmlBinaryNodeType PrefixDictionaryElementQ;
    public static XmlBinaryNodeType PrefixDictionaryElementR;
    public static XmlBinaryNodeType PrefixDictionaryElementS;
    public static XmlBinaryNodeType PrefixDictionaryElementT;
    public static XmlBinaryNodeType PrefixDictionaryElementU;
    public static XmlBinaryNodeType PrefixDictionaryElementV;
    public static XmlBinaryNodeType PrefixDictionaryElementW;
    public static XmlBinaryNodeType PrefixDictionaryElementX;
    public static XmlBinaryNodeType PrefixDictionaryElementY;
    public static XmlBinaryNodeType PrefixDictionaryElementZ;
    public static XmlBinaryNodeType PrefixElementA;
    public static XmlBinaryNodeType PrefixElementB;
    public static XmlBinaryNodeType PrefixElementC;
    public static XmlBinaryNodeType PrefixElementD;
    public static XmlBinaryNodeType PrefixElementE;
    public static XmlBinaryNodeType PrefixElementF;
    public static XmlBinaryNodeType PrefixElementG;
    public static XmlBinaryNodeType PrefixElementH;
    public static XmlBinaryNodeType PrefixElementI;
    public static XmlBinaryNodeType PrefixElementJ;
    public static XmlBinaryNodeType PrefixElementK;
    public static XmlBinaryNodeType PrefixElementL;
    public static XmlBinaryNodeType PrefixElementM;
    public static XmlBinaryNodeType PrefixElementN;
    public static XmlBinaryNodeType PrefixElementO;
    public static XmlBinaryNodeType PrefixElementP;
    public static XmlBinaryNodeType PrefixElementQ;
    public static XmlBinaryNodeType PrefixElementR;
    public static XmlBinaryNodeType PrefixElementS;
    public static XmlBinaryNodeType PrefixElementT;
    public static XmlBinaryNodeType PrefixElementU;
    public static XmlBinaryNodeType PrefixElementV;
    public static XmlBinaryNodeType PrefixElementW;
    public static XmlBinaryNodeType PrefixElementX;
    public static XmlBinaryNodeType PrefixElementY;
    public static XmlBinaryNodeType PrefixElementZ;
    public static XmlBinaryNodeType MaxElement;
    public static XmlBinaryNodeType MinText;
    public static XmlBinaryNodeType ZeroText;
    public static XmlBinaryNodeType OneText;
    public static XmlBinaryNodeType FalseText;
    public static XmlBinaryNodeType TrueText;
    public static XmlBinaryNodeType Int8Text;
    public static XmlBinaryNodeType Int16Text;
    public static XmlBinaryNodeType Int32Text;
    public static XmlBinaryNodeType Int64Text;
    public static XmlBinaryNodeType FloatText;
    public static XmlBinaryNodeType DoubleText;
    public static XmlBinaryNodeType DecimalText;
    public static XmlBinaryNodeType DateTimeText;
    public static XmlBinaryNodeType Chars8Text;
    public static XmlBinaryNodeType Chars16Text;
    public static XmlBinaryNodeType Chars32Text;
    public static XmlBinaryNodeType Bytes8Text;
    public static XmlBinaryNodeType Bytes16Text;
    public static XmlBinaryNodeType Bytes32Text;
    public static XmlBinaryNodeType StartListText;
    public static XmlBinaryNodeType EndListText;
    public static XmlBinaryNodeType EmptyText;
    public static XmlBinaryNodeType DictionaryText;
    public static XmlBinaryNodeType UniqueIdText;
    public static XmlBinaryNodeType TimeSpanText;
    public static XmlBinaryNodeType GuidText;
    public static XmlBinaryNodeType UInt64Text;
    public static XmlBinaryNodeType BoolText;
    public static XmlBinaryNodeType UnicodeChars8Text;
    public static XmlBinaryNodeType UnicodeChars16Text;
    public static XmlBinaryNodeType UnicodeChars32Text;
    public static XmlBinaryNodeType QNameDictionaryText;
    public static XmlBinaryNodeType ZeroTextWithEndElement;
    public static XmlBinaryNodeType OneTextWithEndElement;
    public static XmlBinaryNodeType FalseTextWithEndElement;
    public static XmlBinaryNodeType TrueTextWithEndElement;
    public static XmlBinaryNodeType Int8TextWithEndElement;
    public static XmlBinaryNodeType Int16TextWithEndElement;
    public static XmlBinaryNodeType Int32TextWithEndElement;
    public static XmlBinaryNodeType Int64TextWithEndElement;
    public static XmlBinaryNodeType FloatTextWithEndElement;
    public static XmlBinaryNodeType DoubleTextWithEndElement;
    public static XmlBinaryNodeType DecimalTextWithEndElement;
    public static XmlBinaryNodeType DateTimeTextWithEndElement;
    public static XmlBinaryNodeType Chars8TextWithEndElement;
    public static XmlBinaryNodeType Chars16TextWithEndElement;
    public static XmlBinaryNodeType Chars32TextWithEndElement;
    public static XmlBinaryNodeType Bytes8TextWithEndElement;
    public static XmlBinaryNodeType Bytes16TextWithEndElement;
    public static XmlBinaryNodeType Bytes32TextWithEndElement;
    public static XmlBinaryNodeType StartListTextWithEndElement;
    public static XmlBinaryNodeType EndListTextWithEndElement;
    public static XmlBinaryNodeType EmptyTextWithEndElement;
    public static XmlBinaryNodeType DictionaryTextWithEndElement;
    public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    public static XmlBinaryNodeType GuidTextWithEndElement;
    public static XmlBinaryNodeType UInt64TextWithEndElement;
    public static XmlBinaryNodeType BoolTextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    public static XmlBinaryNodeType MaxText;
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
